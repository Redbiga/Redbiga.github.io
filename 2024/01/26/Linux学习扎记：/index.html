

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
   <meta name="referrer" content="no-referrer">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar1.png">
  <link rel="icon" href="/img/avatar1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="山麋一笑">
  <meta name="keywords" content="">
  
    <meta name="description" content="磁盘：磁盘物理结构：硬盘结构(图文展示) - chuyaoxin - 博客园越是外面的柱面，线速度越大，读取信息越快 Linux中的&#x2F;表示什么？在Linux中，&#x2F;表示根目录。根目录是Linux系统中的最顶层目录，所有其他目录和文件都是在根目录下的子目录或文件。在Linux中，根目录是所有文件系统的起点，包括硬盘、光驱、USB设备等等，因此所有文件和目录都是相对于根">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux学习札记">
<meta property="og:url" content="http://www.bojiboqi.fun/2024/01/26/Linux%E5%AD%A6%E4%B9%A0%E6%89%8E%E8%AE%B0%EF%BC%9A/index.html">
<meta property="og:site_name" content="山麋一笑">
<meta property="og:description" content="磁盘：磁盘物理结构：硬盘结构(图文展示) - chuyaoxin - 博客园越是外面的柱面，线速度越大，读取信息越快 Linux中的&#x2F;表示什么？在Linux中，&#x2F;表示根目录。根目录是Linux系统中的最顶层目录，所有其他目录和文件都是在根目录下的子目录或文件。在Linux中，根目录是所有文件系统的起点，包括硬盘、光驱、USB设备等等，因此所有文件和目录都是相对于根">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/28066124/1678673169268-b600099d-9341-433a-8b00-cfe152516215.png#averageHue=%23faf9f9&clientId=u7a7618ef-de57-4&from=paste&height=274&id=u507bf137&originHeight=342&originWidth=654&originalType=binary&ratio=1&rotation=0&showTitle=false&size=136503&status=done&style=none&taskId=u4fe61dc9-8c68-4abc-a3f9-b14efebd1b1&title=&width=523.2">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/28066124/1678673220974-79677498-e5ab-4bba-a800-5a198579c32c.png#averageHue=%23f5f0d3&clientId=u7a7618ef-de57-4&from=paste&height=325&id=ue7a0496a&originHeight=406&originWidth=761&originalType=binary&ratio=1&rotation=0&showTitle=false&size=231058&status=done&style=none&taskId=uccf8c4f1-e23c-4ae3-ad01-2646e77339d&title=&width=608.8">
<meta property="article:published_time" content="2024-01-26T08:27:13.582Z">
<meta property="article:modified_time" content="2024-01-26T08:28:04.155Z">
<meta property="article:author" content="山麋一笑">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2023/png/28066124/1678673169268-b600099d-9341-433a-8b00-cfe152516215.png#averageHue=%23faf9f9&clientId=u7a7618ef-de57-4&from=paste&height=274&id=u507bf137&originHeight=342&originWidth=654&originalType=binary&ratio=1&rotation=0&showTitle=false&size=136503&status=done&style=none&taskId=u4fe61dc9-8c68-4abc-a3f9-b14efebd1b1&title=&width=523.2">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Linux学习札记 - 山麋一笑</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/xm_custom/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.bojiboqi.fun","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"NkSNF5NG3Uup8tDgwIfBlJ9d-gzGzoHsz","app_key":"Y2GZN9C0SLdOpVG4hMb1TEJM","server_url":"https://nksnf5ng.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body><!-- hexo injector body_begin start --><div id="web_bg"></div><!-- hexo injector body_begin end -->
  
  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>山麋一笑</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于我</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default1.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Linux学习札记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-01-26 16:27" pubdate>
          2024年1月26日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          16k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          132 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      


<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Linux学习札记</h1>
            
            
              <div class="markdown-body">
                
                 <meta name="referrer" content="no-referrer">





<h2 id="磁盘："><a href="#磁盘：" class="headerlink" title="磁盘："></a>磁盘：</h2><h4 id="磁盘物理结构："><a href="#磁盘物理结构：" class="headerlink" title="磁盘物理结构："></a>磁盘物理结构：</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cyx-b/p/14095057.html">硬盘结构(图文展示) - chuyaoxin - 博客园</a><br>越是外面的柱面，线速度越大，读取信息越快</p>
<h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>Linux中的&#x2F;表示什么？<br>在Linux中，&#x2F;表示根目录。根目录是Linux系统中的最顶层目录，所有其他目录和文件都是在根目录下的子目录或文件。在Linux中，根目录是所有文件系统的起点，包括硬盘、光驱、USB设备等等，因此所有文件和目录都是相对于根目录的路径来表示的。例如，&#x2F;etc表示根目录下的etc目录，&#x2F;home&#x2F;user表示根目录下的home目录下的user目录，以此类推。在Linux中，根目录还包含其他特殊的目录，例如&#x2F;dev、&#x2F;proc、&#x2F;sys等等，分别用于存储设备文件、进程信息、系统信息等等。</p>
<h4 id="主引导扇区："><a href="#主引导扇区：" class="headerlink" title="主引导扇区："></a>主引导扇区：</h4><p>主引导扇区（Master Boot Record，MBR）是硬盘上的第一个扇区，大小为512字节。MBR中包含了硬盘的分区表以及引导程序。当计算机开机时，BIOS会读取MBR中的引导程序，将控制权交给引导程序执行。引导程序会根据分区表找到操作系统所在的分区，并将操作系统的引导程序加载到内存中，最终启动操作系统。 MBR分为三个部分：引导程序（bootLoad)、分区表和MBR签名。其中，引导程序位于MBR的前446字节，用于加载操作系统的引导程序。分区表位于MBR的接下来64字节，用于记录硬盘分区的信息，包括分区的起始位置、结束位置、分区类型等等。MBR签名位于MBR的最后两个字节，用于验证MBR的合法性。 MBR只支持最多4个主分区或3个主分区和1个扩展分区。如果需要更多的分区，可以将一个主分区设置为扩展分区，并在其中创建逻辑分区。近年来，由于MBR的局限性，逐渐被GPT（GUID Partition Table）所取代。</p>
<h4 id="计算机启动："><a href="#计算机启动：" class="headerlink" title="计算机启动："></a>计算机启动：</h4><p><a target="_blank" rel="noopener" href="https://www.initroot.com/linuxintroduction/computerbootprocess.html">计算机启动过程</a><br>DBR和激活分区的区别<br>DBR（DOS Boot Record）和激活分区是两个不同的概念。 DBR是可引导分区的引导扇区，也就是分区内的第一个扇区。DBR中包含了分区的文件系统信息和引导程序，用于启动分区内的操作系统。每个可引导分区都有自己的DBR。 而激活分区是硬盘上被指定为启动分区的分区，也就是系统启动时将要启动的分区。在MBR中，分区表记录了硬盘上所有分区的信息，其中被标记为“激活”的分区就是硬盘的启动分区。一个硬盘只能有一个激活分区。 在启动计算机时，BIOS会读取硬盘的MBR，并将控制权交给MBR中被标记为激活的分区。然后，该分区的DBR会被读取，引导程序会加载操作系统的引导文件，并将其加载到内存中，最终启动操作系统。 因此，DBR和激活分区是两个不同的概念，但它们是相互关联的，共同完成了操作系统的启动。<br>那什么是可引导分区<br>可引导分区是指可以安装操作系统并进行启动的硬盘分区。在硬盘上，每个分区都有自己的文件系统和分区表，其中一个或多个分区可以被指定为可引导分区。通常情况下，每个硬盘只有一个可引导分区，它被称为系统分区，用于安装操作系统和启动计算机。 可引导分区的引导扇区（DBR）是分区内的第一个扇区，它包含了分区的文件系统信息和引导程序。当计算机启动时，BIOS会读取硬盘的MBR（Master Boot Record），找到系统分区并将控制权交给系统分区的DBR，引导程序会根据文件系统信息找到操作系统的引导文件，并将其加载到内存中，最终启动操作系统。 需要注意的是，不是所有的分区都可以被指定为可引导分区。只有基本分区和主分区才能被指定为可引导分区，扩展分区和逻辑分区则不能被指定为可引导分区。因此，在分区硬盘时需要注意分区类型，确保系统分区被正确地分配和指定。</p>
<p>DBR和MBR的区别？<br>DBR（DOS Boot Record）和MBR（Master Boot Record）都是硬盘上的扇区，但它们有以下不同点：</p>
<ol>
<li>位置不同：MBR位于硬盘的第一个扇区，而DBR位于可引导分区的第一个扇区。</li>
<li>功能不同：MBR主要包含硬盘的分区表以及引导程序，用于找到操作系统所在的分区并启动操作系统；而DBR主要包含分区的文件系统信息以及引导程序，用于找到操作系统的引导文件并启动操作系统。</li>
<li>结构不同：MBR和DBR的结构类似，但有所不同。MBR包含了分区表和MBR签名，而DBR包含了文件系统信息和DBR签名。</li>
<li>作用不同：MBR是硬盘的引导扇区，控制整个硬盘的启动过程；而DBR是分区的引导扇区，控制分区内的启动过程。 需要注意的是，MBR和DBR的结构和作用是相互关联的。MBR中的分区表记录了可引导分区的信息，而DBR中的引导程序则是由MBR中的引导程序加载的。因此，在硬盘启动过程中，MBR和DBR是相互配合的，共同完成操作系统的启动。</li>
</ol>
<p>什么是可引导分区的引导扇区DBR？<br>可引导分区的引导扇区也称为DBR（DOS Boot Record），它是可引导分区的第一个扇区，大小为512字节。DBR中包含了分区的引导程序以及分区的文件系统信息。当计算机开机时，BIOS会读取分区表中的分区信息，找到可引导分区的DBR，并将控制权交给DBR中的引导程序执行。引导程序会根据文件系统信息找到操作系统的引导文件，并将其加载到内存中，最终启动操作系统。 DBR的结构与MBR类似，也包含了引导程序和DBR签名。引导程序位于DBR的前446字节，用于加载操作系统的引导程序。DBR签名位于DBR的最后两个字节，用于验证DBR的合法性。 DBR中的引导程序有多种，例如Windows操作系统使用的NTLDR或BOOTMGR程序，Linux操作系统使用的GRUB或LILO程序等等。不同的引导程序支持的操作系统和文件系统也有所不同。</p>
<h4 id="文件系统基础知识："><a href="#文件系统基础知识：" class="headerlink" title="文件系统基础知识："></a>文件系统基础知识：</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wkfvawl/p/11847413.html#2%E3%80%81%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E2%80%94%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D">操作系统——文件系统概述、文件逻辑地址、目录、物理地址 - 王陸 - 博客园</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yuexiaxiaoxi27172319/article/details/45241923">Linux文件系统详解(文件系统层次、分类、存储结构、存储介质、文件节点inode)_mooncreek的博客-CSDN博客</a></p>
<h4 id="虚拟文件系统："><a href="#虚拟文件系统：" class="headerlink" title="虚拟文件系统："></a>虚拟文件系统：</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/orange-CC/p/12720341.html">存储系列之 VFS虚拟文件系统简介 - orange-C - 博客园</a><br>虚拟文件系统（Virtual File System）是操作系统内核中的一种机制，它用于抽象不同文件系统的底层实现细节，为应用程序提供一个统一的文件系统接口。虚拟文件系统将不同的文件系统（如ext4、NTFS、FAT等）抽象为一个统一的文件系统层次结构，使得应用程序可以使用相同的系统调用（如open、read、write、close等）来访问不同类型的文件系统，而不需要关心底层文件系统的具体实现。 虚拟文件系统的实现通常包括以下几个组件：</p>
<ol>
<li>VFS层：虚拟文件系统的核心，负责管理所有文件系统的挂载和卸载，以及提供统一的文件系统接口。</li>
<li>文件系统驱动：每种文件系统都有自己的文件系统驱动，用于将底层文件系统的操作转换为VFS层的统一接口。</li>
<li>文件系统缓存：用于缓存文件系统的元数据和数据，提高文件系统的访问效率。</li>
<li>文件系统对象：VFS层维护了文件、目录、超级块等多种文件系统对象，用于描述文件系统的层次结构和属性。 虚拟文件系统的优点在于可以屏蔽不同文件系统之间的差异，使得应用程序可以使用统一的接口来处理不同类型的文件系统。此外，虚拟文件系统也为系统管理员提供了更灵活的管理方式，可以在运行时动态挂载和卸载不同类型的文件系统，以满足不同的需求。</li>
</ol>
<h4 id="主流文件系统："><a href="#主流文件系统：" class="headerlink" title="主流文件系统："></a>主流文件系统：</h4><p><a target="_blank" rel="noopener" href="https://www.51cto.com/article/609405.html">Linux文件系统：Ext、XFS、Btrfs等，选择适合自己的文件系统-51CTO.COM</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bangerlee/archive/2012/03/31/2426069.html">Linux文件系统介绍 - bangerlee - 博客园</a></p>
<h4 id="磁盘分区："><a href="#磁盘分区：" class="headerlink" title="磁盘分区："></a>磁盘分区：</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/renshengdezheli/p/13941563.html">linux下使用fdisk进行磁盘分区详解 - 人生的哲理 - 博客园</a></p>
<h4 id="为什么要给不同的分区创建不一样的文件系统"><a href="#为什么要给不同的分区创建不一样的文件系统" class="headerlink" title="为什么要给不同的分区创建不一样的文件系统"></a>为什么要给不同的分区创建不一样的文件系统</h4><p>给不同的分区创建不同的文件系统类型是因为不同的应用场景需要不同的文件系统类型来优化性能、提高可靠性和满足特定的需求。以下是一些例子：</p>
<ol>
<li>根分区：Linux操作系统的根分区通常采用ext4等文件系统类型，因为这些文件系统类型具有高性能和可靠性，并支持快速数据访问和文件系统扩展。</li>
<li>数据分区：数据分区通常需要支持大容量数据存储和高速数据访问，因此可以采用如NTFS、FAT、exFAT等文件系统类型。</li>
<li>交换分区：交换分区是Linux系统用来交换内存数据的一种特殊分区，通常采用Linux Swap文件系统类型，因为这种文件系统类型可以支持快速的内存数据交换操作。</li>
<li>备份分区：备份分区通常需要支持数据快速备份和恢复操作，因此可以采用如NTFS、FAT、exFAT、ext4等文件系统类型。 总之，根据不同的应用场景和需求，选择不同的文件系统类型可以帮助优化系统性能、提高数据可靠性和满足特定的需求。</li>
</ol>
<h4 id="tune2fs"><a href="#tune2fs" class="headerlink" title="tune2fs"></a>tune2fs</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yaobai609/archive/2012/11/21/2781292.html">tune2fs命令详解 - 我想叫晴朗 - 博客园</a><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1678673169268-b600099d-9341-433a-8b00-cfe152516215.png#averageHue=%23faf9f9&clientId=u7a7618ef-de57-4&from=paste&height=274&id=u507bf137&originHeight=342&originWidth=654&originalType=binary&ratio=1&rotation=0&showTitle=false&size=136503&status=done&style=none&taskId=u4fe61dc9-8c68-4abc-a3f9-b14efebd1b1&title=&width=523.2" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="挂载和卸载文件系统"><a href="#挂载和卸载文件系统" class="headerlink" title="挂载和卸载文件系统"></a>挂载和卸载文件系统</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1678673220974-79677498-e5ab-4bba-a800-5a198579c32c.png#averageHue=%23f5f0d3&clientId=u7a7618ef-de57-4&from=paste&height=325&id=ue7a0496a&originHeight=406&originWidth=761&originalType=binary&ratio=1&rotation=0&showTitle=false&size=231058&status=done&style=none&taskId=uccf8c4f1-e23c-4ae3-ad01-2646e77339d&title=&width=608.8" srcset="/img/loading.gif" lazyload alt="image.png"><br>&#x2F;dev目录下所有Linux系统中使用的外部设备。但是这里并不是放的外部设备的驱动程序，<br>&#x2F;dev 目录下的设备文件只是对硬件设备的抽象，并不能直接使用（仅仅包括一些文件的相关属性，并没有和Linux系统创建联系）。在 Linux 中，为了能够对硬件设备进行操作，需要先将其挂载到文件系统中。挂载操作会把设备文件与文件系统中的一个目录建立关联，使得文件系统中的应用程序可以通过该目录来访问设备文件。 具体来说，挂载操作会将设备文件的数据块映射到文件系统中的一个目录下，并将该目录作为设备文件的访问入口。这样，当应用程序访问该目录中的文件时，系统就会将其转发到与其映射的设备文件中，从而实现对设备的访问和控制。<br>外部设备的驱动程序放在哪的？<br>外部设备的驱动程序通常是由设备制造商提供的，可以从设备制造商的官方网站或光盘中下载到相应的驱动程序。驱动程序通常被编写为动态链接库（.so 文件）或内核模块（.ko 文件）的形式，并包含了设备与操作系统之间的接口，以及设备所支持的各种功能和特性。 在 Linux 系统中，驱动程序通常被安装到 <strong>&#x2F;lib&#x2F;modules</strong> 目录下，其中 <strong>&#x2F;lib&#x2F;modules&#x2F;<kernel_version>&#x2F;kernel&#x2F;drivers</strong> 目录下存储的是内核自带的驱动程序，而 <strong>&#x2F;lib&#x2F;modules&#x2F;<kernel_version>&#x2F;extra</strong> 目录下存储的是额外的驱动程序。当系统启动时，内核会自动加载相应的驱动程序模块，以便操作系统可以访问并控制相应的外部设备。 除了从设备制造商处获取驱动程序之外，一些开源社区也为一些常见的外部设备提供了通用的驱动程序，例如 Linux USB 设备驱动程序、Linux 网络设备驱动程序等等。这些通用驱动程序通常已经被包含在 Linux 内核中，因此不需要额外下载和安装。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/maopig/article/details/7195048">Linux &#x2F;dev目录详解和Linux系统各个目录的作用_linux dev目录_maopig的博客-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cangqinglang/p/12170828.html">什么是挂载，Linux挂载如何实现详解 - 苍青浪 - 博客园</a></p>
<h4 id="如何创建交换文件"><a href="#如何创建交换文件" class="headerlink" title="如何创建交换文件"></a>如何创建交换文件</h4><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/842822">Linux创建swap分区（用文件作为Swap分区）-阿里云开发者社区</a><br>在 Linux 中，可以通过创建交换文件（swap file）来扩展系统的虚拟内存空间。以下是创建交换文件的步骤：</p>
<ol>
<li><p>确定需要创建的交换文件大小。一般来说，交换文件大小应该为系统内存大小的 2 倍。例如，如果系统内存为 2GB，则交换文件大小应该为 4GB。</p>
</li>
<li><p>使用以下命令创建一个指定大小的空文件：</p>
<div class="code-wrapper"><pre><code class="hljs arduino">plaintextCopy code
sudo fallocate -l size /swapfile</code></pre></div>
<p>其中，<strong>size</strong> 是需要创建的交换文件大小，可以使用 <strong>M</strong> 表示单位为 MB，使用 <strong>G</strong> 表示单位为 GB。例如，要创建一个大小为 4GB 的交换文件，可以使用以下命令：</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">plaintextCopy</span> code
<span class="hljs-attribute">sudo</span> fallocate -l <span class="hljs-number">4</span>G /swapfile</code></pre></div>
</li>
<li><p>使用以下命令将文件格式化为交换文件：</p>
<div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">plaintextCopy</span> <span class="hljs-meta">code</span>
<span class="hljs-symbol">sudo</span> mkswap /swapfile</code></pre></div>
</li>
<li><p>使用以下命令启用交换文件：</p>
<div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">plaintextCopy</span> <span class="hljs-meta">code</span>
<span class="hljs-symbol">sudo</span> swapon /swapfile</code></pre></div>
</li>
<li><p>使用以下命令将交换文件添加到 <strong>&#x2F;etc&#x2F;fstab</strong> 文件中，以便系统在启动时自动挂载：</p>
<div class="code-wrapper"><pre><code class="hljs bash">plaintextCopy code
sudo <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/swapfile none swap sw 0 0&quot;</span> &gt;&gt; /etc/fstab</code></pre></div>
<p>至此，交换文件创建完成。可以使用以下命令来查看系统的交换空间情况：</p>
<div class="code-wrapper"><pre><code class="hljs css">plaintextCopy <span class="hljs-selector-tag">code</span>
sudo swapon <span class="hljs-attr">--show</span></code></pre></div>
<p>需要注意的是，创建交换文件可能会影响系统的性能，因此应该谨慎使用。如果系统内存不足，建议考虑升级硬件或者优化应用程序，而不是通过创建交换文件来扩展虚拟内存空间。</p>
</li>
</ol>
<h4 id="Hex-代码-输入-L-列出所有代码-：82"><a href="#Hex-代码-输入-L-列出所有代码-：82" class="headerlink" title="Hex 代码(输入 L 列出所有代码)：82"></a>Hex 代码(输入 L 列出所有代码)：82</h4><p>根据所给的 Hex 代码 82，无法确定其对应的字符或者含义。如果您需要查看 Hex 代码对应的字符或者含义，可以使用 Linux 终端中的 <strong>hexdump</strong> 命令或者在线 Hex 转换工具来实现。具体步骤如下： 使用 <strong>hexdump</strong> 命令： 在 Linux 终端中，可以使用 <strong>hexdump</strong> 命令来查看 Hex 代码对应的字符或者含义。具体命令如下：</p>
<div class="code-wrapper"><pre><code class="hljs 1c">bashCopy code
echo -n &#x27;\x82&#x27; <span class="hljs-string">| hexdump -C</span></code></pre></div>
<p>执行上述命令后，终端会输出类似以下的结果：</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">plaintextCopy</span> code
<span class="hljs-attribute">00000000</span>  <span class="hljs-number">82</span>                                                |.| <span class="hljs-number">00000001</span></code></pre></div>
<p>其中，第一行的 <strong>82</strong> 是所给的 Hex 代码，第二行中的 <strong>.</strong> 则表示对应的字符为空格。 使用在线 Hex 转换工具： 除了使用 Linux 终端中的 <strong>hexdump</strong> 命令外，还可以使用在线 Hex 转换工具来查看 Hex 代码对应的字符或者含义。具体步骤如下：</p>
<ol>
<li>打开任意一个在线 Hex 转换工具，如 <a target="_blank" rel="noopener" href="https://www.rapidtables.com/convert/number/hex-to-ascii.html%E3%80%82">https://www.rapidtables.com/convert/number/hex-to-ascii.html。</a></li>
<li>在 Hex 代码输入框中输入所给的 Hex 代码 <strong>82</strong>。</li>
<li>点击转换按钮，工具会自动将 Hex 代码转换成对应的字符或者含义。在该工具中，对应的字符为空格。 综上所述，所给的 Hex 代码 <strong>82</strong> 对应的字符或者含义是空格。</li>
</ol>
<h4 id="Linux出现乱码怎么解决"><a href="#Linux出现乱码怎么解决" class="headerlink" title="Linux出现乱码怎么解决"></a>Linux出现乱码怎么解决</h4><h4 id="在-Linux-中出现乱码的原因可能有很多，可以根据具体情况采取不同的解决方法。以下是一些常见的乱码问题及其解决方法："><a href="#在-Linux-中出现乱码的原因可能有很多，可以根据具体情况采取不同的解决方法。以下是一些常见的乱码问题及其解决方法：" class="headerlink" title="在 Linux 中出现乱码的原因可能有很多，可以根据具体情况采取不同的解决方法。以下是一些常见的乱码问题及其解决方法："></a>在 Linux 中出现乱码的原因可能有很多，可以根据具体情况采取不同的解决方法。以下是一些常见的乱码问题及其解决方法：</h4><p>终端乱码：如果在终端中出现了乱码，可以尝试修改终端的字符编码设置。可以使用以下命令来查看当前终端的字符编码：</p>
<p>plaintext<br>Copy code<br>echo $LANG</p>
<p>如果输出的结果不是 UTF-8 编码，可以使用以下命令来修改终端的字符编码：</p>
<p>plaintext<br>Copy code<br>export LANG&#x3D;en_US.UTF-8</p>
<p>文件名乱码：如果在文件管理器中或命令行中出现了文件名乱码，可以尝试修改文件名的字符编码。可以使用以下命令来查看文件名的字符编码：</p>
<p>plaintext<br>Copy code<br>file -i filename</p>
<p>如果输出的结果不是 UTF-8 编码，可以使用以下命令来修改文件名的字符编码：</p>
<p>plaintext<br>Copy code<br>convmv -f old_charset -t utf8 –notest filename</p>
<p>其中，old_charset 是当前文件名的字符编码。<br>3. 应用程序乱码：如果某个应用程序出现了乱码，可以尝试修改应用程序的字符编码设置。具体方法可以参考应用程序的官方文档或社区支持论坛。<br>需要注意的是，修改字符编码设置可能会影响其他应用程序或系统组件的正常运行，因此在修改前应该先备份相关配置文件，并谨慎操作。如果无法解决乱码问题，可以考虑使用其他字符编码转换工具，如 iconv、enca 等。</p>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><p>Linux如何查看pdf文档</p>
<h4 id="在-Linux-中，可以使用多种工具来查看-PDF-文档，以下是一些常用的工具："><a href="#在-Linux-中，可以使用多种工具来查看-PDF-文档，以下是一些常用的工具：" class="headerlink" title="在 Linux 中，可以使用多种工具来查看 PDF 文档，以下是一些常用的工具："></a>在 Linux 中，可以使用多种工具来查看 PDF 文档，以下是一些常用的工具：</h4><ol>
<li><p>Evince：Evince 是 GNOME 桌面环境自带的 PDF 阅读器，支持多种文档格式，包括 PDF、PostScript、DjVu 等。使用以下命令来安装 Evince：</p>
<div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">plaintextCopy</span> <span class="hljs-meta">code</span>
<span class="hljs-symbol">sudo</span> apt install evince</code></pre></div>
<p>安装完成后，可以使用以下命令来打开 PDF 文档：</p>
<div class="code-wrapper"><pre><code class="hljs applescript">plaintextCopy code
evince /path/<span class="hljs-keyword">to</span>/<span class="hljs-built_in">file</span>.pdf</code></pre></div>
</li>
<li><p>Okular：Okular 是 KDE 桌面环境自带的 PDF 阅读器，也支持多种文档格式。使用以下命令来安装 Okular：</p>
<div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">plaintextCopy</span> <span class="hljs-meta">code</span>
<span class="hljs-symbol">sudo</span> apt install okular</code></pre></div>
<p>安装完成后，可以使用以下命令来打开 PDF 文档：</p>
<div class="code-wrapper"><pre><code class="hljs applescript">plaintextCopy code
okular /path/<span class="hljs-keyword">to</span>/<span class="hljs-built_in">file</span>.pdf</code></pre></div>
</li>
<li><p>Xpdf：Xpdf 是一款轻量级的 PDF 阅读器，可以在终端中使用。使用以下命令来安装 Xpdf：</p>
<div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">plaintextCopy</span> <span class="hljs-meta">code</span>
<span class="hljs-symbol">sudo</span> apt install xpdf</code></pre></div>
<p>安装完成后，可以使用以下命令来打开 PDF 文档：</p>
<div class="code-wrapper"><pre><code class="hljs applescript">plaintextCopy code
xpdf /path/<span class="hljs-keyword">to</span>/<span class="hljs-built_in">file</span>.pdf</code></pre></div>
</li>
<li><p>Foxit Reader：Foxit Reader 是一款跨平台的 PDF 阅读器，可以在 Linux、Windows、MacOS 等系统中使用。可以从 Foxit 官网下载并安装 Linux 版本的 Foxit Reader，安装完成后可以使用 GUI 界面来打开 PDF 文档。 上述工具中，Evince 和 Okular 是 Linux 系统自带的 PDF 阅读器，Xpdf 则是一款轻量级的 PDF 阅读器，Foxit Reader 则是一款跨平台的 PDF 阅读器，用户可以根据自己的需求选择适合自己的工具来查看 PDF 文档。</p>
</li>
</ol>
<h4 id="成功挂载u盘后-怎么访问里面的文件"><a href="#成功挂载u盘后-怎么访问里面的文件" class="headerlink" title="成功挂载u盘后,怎么访问里面的文件"></a>成功挂载u盘后,怎么访问里面的文件</h4><h4 id="在成功挂载-U-盘后，可以使用-cd-命令进入-U-盘的挂载点目录，然后使用-ls-命令列出-U-盘中的文件和目录，最后使用-cat、vi、less-等命令来访问和编辑文件。具体步骤如下："><a href="#在成功挂载-U-盘后，可以使用-cd-命令进入-U-盘的挂载点目录，然后使用-ls-命令列出-U-盘中的文件和目录，最后使用-cat、vi、less-等命令来访问和编辑文件。具体步骤如下：" class="headerlink" title="在成功挂载 U 盘后，可以使用 cd 命令进入 U 盘的挂载点目录，然后使用 ls 命令列出 U 盘中的文件和目录，最后使用 cat、vi、less 等命令来访问和编辑文件。具体步骤如下："></a>在成功挂载 U 盘后，可以使用 <strong>cd</strong> 命令进入 U 盘的挂载点目录，然后使用 <strong>ls</strong> 命令列出 U 盘中的文件和目录，最后使用 <strong>cat</strong>、<strong>vi</strong>、<strong>less</strong> 等命令来访问和编辑文件。具体步骤如下：</h4><ol>
<li><p>使用 <strong>cd</strong> 命令进入 U 盘的挂载点目录。例如，如果 U 盘被挂载到 <strong>&#x2F;mnt&#x2F;myusb</strong> 目录下，可以使用以下命令进入该目录：</p>
<div class="code-wrapper"><pre><code class="hljs bash">plaintextCopy code
<span class="hljs-built_in">cd</span> /mnt/myusb</code></pre></div>
</li>
<li><p>使用 <strong>ls</strong> 命令列出 U 盘中的文件和目录。例如，可以使用以下命令来查看 U 盘中的文件和目录：</p>
<div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">plaintextCopy</span> <span class="hljs-meta">code</span>
<span class="hljs-symbol">ls</span></code></pre></div>
</li>
<li><p>使用 <strong>cat</strong> 命令来查看文件内容。例如，可以使用以下命令来查看 <strong>example.txt</strong> 文件的内容：</p>
<div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">plaintextCopy</span> <span class="hljs-meta">code</span>
<span class="hljs-symbol">cat</span> example.txt</code></pre></div>
</li>
<li><p>使用 <strong>vi</strong>、<strong>nano</strong>、<strong>emacs</strong> 等命令来编辑文件。例如，可以使用以下命令来编辑 <strong>example.txt</strong> 文件：</p>
<div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">plaintextCopy</span> <span class="hljs-meta">code</span>
<span class="hljs-symbol">vi</span> example.txt</code></pre></div>
</li>
<li><p>使用 <strong>less</strong> 命令来查看长文件内容。例如，可以使用以下命令来查看 <strong>longfile.log</strong> 文件的内容：</p>
<div class="code-wrapper"><pre><code class="hljs 1c">plaintextCopy code
less longfile.<span class="hljs-built_in">log</span></code></pre></div>
<p>在使用以上命令访问和编辑 U 盘中的文件时，需要注意 U 盘的读写权限问题。如果 U 盘的文件系统是 NTFS、FAT32 等 Windows 系统常用的文件系统，则需要在挂载 U 盘时添加 <strong>uid</strong> 和 <strong>gid</strong> 参数来指定 U 盘的读写权限。具体方法可以参考挂载 U 盘的相关文档。</p>
</li>
</ol>
<h4 id="如何实现文件系统的自动挂载"><a href="#如何实现文件系统的自动挂载" class="headerlink" title="如何实现文件系统的自动挂载"></a>如何实现文件系统的自动挂载</h4><h4 id="在-Linux-中，可以通过修改-etc-fstab-文件来实现文件系统的自动挂载。-etc-fstab-文件是系统中用于描述文件系统挂载信息的配置文件，其中包含了每个文件系统的设备文件名、挂载点、文件系统类型、挂载选项等信息。-具体来说，要实现文件系统的自动挂载，需要在-etc-fstab-文件中添加相应的挂载信息。例如，如果要将-dev-sdb1-分区自动挂载到-mnt-myusb-目录下，可以在-etc-fstab-文件中添加以下一行："><a href="#在-Linux-中，可以通过修改-etc-fstab-文件来实现文件系统的自动挂载。-etc-fstab-文件是系统中用于描述文件系统挂载信息的配置文件，其中包含了每个文件系统的设备文件名、挂载点、文件系统类型、挂载选项等信息。-具体来说，要实现文件系统的自动挂载，需要在-etc-fstab-文件中添加相应的挂载信息。例如，如果要将-dev-sdb1-分区自动挂载到-mnt-myusb-目录下，可以在-etc-fstab-文件中添加以下一行：" class="headerlink" title="在 Linux 中，可以通过修改 &#x2F;etc&#x2F;fstab 文件来实现文件系统的自动挂载。**&#x2F;etc&#x2F;fstab** 文件是系统中用于描述文件系统挂载信息的配置文件，其中包含了每个文件系统的设备文件名、挂载点、文件系统类型、挂载选项等信息。 具体来说，要实现文件系统的自动挂载，需要在 &#x2F;etc&#x2F;fstab 文件中添加相应的挂载信息。例如，如果要将 &#x2F;dev&#x2F;sdb1 分区自动挂载到 &#x2F;mnt&#x2F;myusb 目录下，可以在 &#x2F;etc&#x2F;fstab 文件中添加以下一行："></a>在 Linux 中，可以通过修改 <strong>&#x2F;etc&#x2F;fstab</strong> 文件来实现文件系统的自动挂载。**&#x2F;etc&#x2F;fstab** 文件是系统中用于描述文件系统挂载信息的配置文件，其中包含了每个文件系统的设备文件名、挂载点、文件系统类型、挂载选项等信息。 具体来说，要实现文件系统的自动挂载，需要在 <strong>&#x2F;etc&#x2F;fstab</strong> 文件中添加相应的挂载信息。例如，如果要将 <strong>&#x2F;dev&#x2F;sdb1</strong> 分区自动挂载到 <strong>&#x2F;mnt&#x2F;myusb</strong> 目录下，可以在 <strong>&#x2F;etc&#x2F;fstab</strong> 文件中添加以下一行：</h4><div class="code-wrapper"><pre><code class="hljs awk">plaintextCopy code
<span class="hljs-regexp">/dev/</span>sdb1   <span class="hljs-regexp">/mnt/myu</span>sb   ext4   defaults   <span class="hljs-number">0</span>   <span class="hljs-number">0</span></code></pre></div>
<p>其中，第一列为设备文件名，第二列为挂载点，第三列为文件系统类型，第四列为挂载选项，第五列为备份标志，第六列为自检顺序。在这个例子中，<strong>defaults</strong> 是一个常用的挂载选项，表示使用系统默认的挂载选项。 保存 <strong>&#x2F;etc&#x2F;fstab</strong> 文件后，系统会在每次启动时自动读取该文件，并根据其中的挂载信息来挂载文件系统。如果需要立即挂载文件系统，可以使用 <strong>mount -a</strong> 命令来让系统重新读取 <strong>&#x2F;etc&#x2F;fstab</strong> 文件并挂载其中的文件系统。</p>
<h4 id="etc-cron-deny这是什么文件"><a href="#etc-cron-deny这是什么文件" class="headerlink" title="&#x2F;etc&#x2F;cron.deny这是什么文件"></a>&#x2F;etc&#x2F;cron.deny这是什么文件</h4><p>&#x2F;etc&#x2F;cron.deny是一个用于限制用户使用计划任务（crontab）的文件。如果一个用户的用户名在该文件中列出，那么该用户将被禁止使用crontab命令来创建和管理定时任务。 当用户尝试使用crontab命令时，系统会首先检查&#x2F;etc&#x2F;cron.deny文件，如果该文件中包含该用户的用户名，则系统会拒绝该用户使用crontab命令。如果该文件不存在，则系统会检查&#x2F;etc&#x2F;cron.allow文件，如果该文件中包含该用户的用户名，则系统允许该用户使用crontab命令。如果两个文件都不存在，则系统默认允许所有用户使用crontab命令。 需要注意的是，&#x2F;etc&#x2F;cron.deny文件的作用范围仅限于本地系统。如果用户可以通过其他方式远程登录到系统，那么该用户仍然可以使用计划任务来执行定时任务。因此，在安全性要求较高的环境中，建议禁用远程登录，或限制只允许受信任的用户远程登录。</p>
<h4 id="ps-kill-top命令"><a href="#ps-kill-top命令" class="headerlink" title="ps,kill,top命令"></a>ps,kill,top命令</h4><h4 id="以下是ps、kill和top命令的简要介绍："><a href="#以下是ps、kill和top命令的简要介绍：" class="headerlink" title="以下是ps、kill和top命令的简要介绍："></a>以下是ps、kill和top命令的简要介绍：</h4><ol>
<li>ps命令：用于显示当前系统中正在运行的进程信息。ps命令可以显示进程的PID、进程名、运行状态、CPU占用率、内存占用率等信息。常用的选项包括：<ul>
<li><strong>ps aux</strong>：显示所有用户的所有进程。</li>
<li><strong>ps -ef</strong>：显示所有进程。</li>
<li>**ps -u <username>**：显示指定用户的进程。</li>
</ul>
</li>
<li>kill命令：用于终止进程。可以使用进程的PID或者进程名来指定要终止的进程。常用的选项包括：<ul>
<li>**kill <PID>**：根据进程PID终止进程。</li>
<li>**killall &lt;进程名&gt;**：根据进程名终止进程。</li>
</ul>
</li>
<li>top命令：用于动态地展示系统中正在运行的进程信息。top命令会实时更新进程的CPU占用率、内存占用率等信息，同时还会显示系统的负载情况、进程数、CPU使用情况等。常用的选项包括：<ul>
<li><strong>top</strong>：默认情况下，top命令会按照CPU占用率降序排列进程信息。</li>
<li>**top -u <username>**：显示指定用户的进程信息。</li>
<li>**top -p <PID>**：显示指定PID的进程信息。 这三个命令经常被系统管理员用于进程管理和性能监控。</li>
</ul>
</li>
</ol>
<h4 id="sbin"><a href="#sbin" class="headerlink" title="&#x2F;sbin"></a>&#x2F;sbin</h4><p>&#x2F;sbin是Linux系统中的一个目录，它包含了一些系统管理员使用的二进制可执行文件。&#x2F;sbin目录通常包含一些用于系统管理和维护的工具和命令，这些工具和命令只有root用户才能够执行。 在默认的Linux文件系统层次结构中，&#x2F;sbin目录通常包含以下一些命令和工具：</p>
<ul>
<li><strong>&#x2F;sbin&#x2F;shutdown</strong>：用于关闭系统。</li>
<li><strong>&#x2F;sbin&#x2F;ifconfig</strong>：用于配置网络接口。</li>
<li><strong>&#x2F;sbin&#x2F;route</strong>：用于配置网络路由。</li>
<li><strong>&#x2F;sbin&#x2F;fdisk</strong>：用于磁盘分区。</li>
<li><strong>&#x2F;sbin&#x2F;mkfs</strong>：用于创建文件系统。</li>
<li><strong>&#x2F;sbin&#x2F;fsck</strong>：用于检查和修复文件系统。</li>
<li><strong>&#x2F;sbin&#x2F;service</strong>：用于启动、停止和查询系统服务的状态。 总的来说，**&#x2F;sbin<strong>目录包含了一些系统管理员常用的命令和工具，这些命令和工具对于系统的管理、维护和修复是非常重要的。在一些Linux系统中，</strong>&#x2F;sbin<strong>目录的内容可能会被合并到</strong>&#x2F;usr&#x2F;sbin**目录中，以便于管理和维护。</li>
</ul>
<h4 id="usr-sbin-service"><a href="#usr-sbin-service" class="headerlink" title="&#x2F;usr&#x2F;sbin&#x2F;service"></a>&#x2F;usr&#x2F;sbin&#x2F;service</h4><p><strong>&#x2F;usr&#x2F;sbin&#x2F;service</strong>是一个命令，用于在Linux系统上启动、停止、重启和查询系统服务的状态。通过使用<strong>service</strong>命令，可以方便地管理系统服务，而无需记住每个服务的具体命令和参数。 <strong>service</strong>命令的语法如下：</p>
<div class="code-wrapper"><pre><code class="hljs xml">plaintextCopy code
service <span class="hljs-tag">&lt;<span class="hljs-name">服务名</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">命令</span>&gt;</span></code></pre></div>
<p>其中，**&lt;服务名&gt;<strong>是要操作的服务的名称，</strong>&lt;命令&gt;**可以是以下之一：</p>
<ul>
<li>start：启动服务</li>
<li>stop：停止服务</li>
<li>restart：重启服务</li>
<li>reload：重新加载服务配置文件</li>
<li>status：查询服务状态 例如，要启动Apache HTTP Server服务，可以使用以下命令：<div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">plaintextCopy</span> <span class="hljs-meta">code</span>
<span class="hljs-symbol">service</span> httpd start</code></pre></div>
在不同的Linux发行版中，<strong>service</strong>命令可能会被替换为其他命令，例如<strong>systemctl</strong>。</li>
</ul>
<h4 id="每天早上7-50自动开启sshd服务，22点50时关闭--每隔5天清空一次FTP服务器公共目录-var-ftp-pub--每周六的7-30时，重新启动httpd服务--每周一、三、五的17-30时，打包备份-etc-httpd目录--每天晚上9：30重启linux系统，并删除-var-www-user1下的所有文件--周一到周五下午五点半自动关机。"><a href="#每天早上7-50自动开启sshd服务，22点50时关闭--每隔5天清空一次FTP服务器公共目录-var-ftp-pub--每周六的7-30时，重新启动httpd服务--每周一、三、五的17-30时，打包备份-etc-httpd目录--每天晚上9：30重启linux系统，并删除-var-www-user1下的所有文件--周一到周五下午五点半自动关机。" class="headerlink" title="每天早上7:50自动开启sshd服务，22点50时关闭  每隔5天清空一次FTP服务器公共目录&#x2F;var&#x2F;ftp&#x2F;pub  每周六的7:30时，重新启动httpd服务  每周一、三、五的17:30时，打包备份&#x2F;etc&#x2F;httpd目录  每天晚上9：30重启linux系统，并删除&#x2F;var&#x2F;www&#x2F;user1下的所有文件  周一到周五下午五点半自动关机。"></a>每天早上7:50自动开启sshd服务，22点50时关闭  每隔5天清空一次FTP服务器公共目录&#x2F;var&#x2F;ftp&#x2F;pub  每周六的7:30时，重新启动httpd服务  每周一、三、五的17:30时，打包备份&#x2F;etc&#x2F;httpd目录  每天晚上9：30重启linux系统，并删除&#x2F;var&#x2F;www&#x2F;user1下的所有文件  周一到周五下午五点半自动关机。</h4><p>You can set up these tasks using a tool called <strong>cron</strong> on your Linux server. <strong>cron</strong> allows you to schedule tasks to run automatically at specified times and dates. You can edit the <strong>crontab</strong> file to specify the tasks and their schedules.<br>For example, to automatically start the <strong>sshd</strong> service at 7:50 AM every day and stop it at 10:50 PM, you can add the following lines to your <strong>crontab</strong> file:<br>50 7 * * * &#x2F;usr&#x2F;sbin&#x2F;service sshd start 50 22 * * * &#x2F;usr&#x2F;sbin&#x2F;service sshd stop<br>Here are the cron entries for the other tasks in your list:</p>
<p>To clear the &#x2F;var&#x2F;ftp&#x2F;pub directory on the FTP server every 5 days:<br>0 0 <em>&#x2F;5 _ _ rm -rf &#x2F;var&#x2F;ftp&#x2F;pub&#x2F;</em><br>To restart the httpd service at 7:30 AM every Saturday:<br>30 7 _ _ 6 &#x2F;usr&#x2F;sbin&#x2F;service httpd restart<br>To create a backup of the &#x2F;etc&#x2F;httpd directory at 5:30 PM every Monday, Wednesday, and Friday:<br>30 17 _ _ 1,3,5 tar -czf &#x2F;path&#x2F;to&#x2F;backup&#x2F;httpd-$(date +%Y%m%d).tar.gz &#x2F;etc&#x2F;httpd<br>To restart the Linux system at 9:30 PM every day and delete all files in the &#x2F;var&#x2F;www&#x2F;user1 directory:<br>30 21 _ _ _ rm -rf &#x2F;var&#x2F;www&#x2F;user1&#x2F;_ &amp;&amp; &#x2F;sbin&#x2F;shutdown -r now<br>To automatically shut down the system at 5:30 PM from Monday to Friday:<br>30 17 _ _ 1-5 &#x2F;sbin&#x2F;shutdown -h now<br>You can add these lines to your crontab file to set up these tasks. Make sure to replace &#x2F;path&#x2F;to&#x2F;backup with the actual path where you want to store the backup files.</p>
<p>Is there anything else you would like to know?</p>
<p>已收到消息. Here are the <code>cron</code> entries for the other tasks in your list: - To clear the <code>/var/ftp/pub</code> directory on the FTP server every 5 days: <code>0 0 */5 * * rm -rf /var/ftp/pub/*</code> - To restart the <code>httpd</code> service at 7:30 AM every Saturday: <code>30 7 * * 6 /usr/sbin/service httpd restart</code> - To create a backup of the <code>/etc/httpd</code> directory at 5:30 PM every Monday, Wednesday, and Friday: <code>30 17 * * 1,3,5 tar -czf /path/to/backup/httpd-$(date +\%Y\%m\%d).tar.gz /etc/httpd</code> - To restart the Linux system at 9:30 PM every day and delete all files in the <code>/var/www/user1</code> directory: <code>30 21 * * * rm -rf /var/www/user1/* &amp;&amp; /sbin/shutdown -r now</code> - To automatically shut down the system at 5:30 PM from Monday to Friday: <code>30 17 * * 1-5 /sbin/shutdown -h now</code> You can add these lines to your <code>crontab</code> file to set up these tasks. Make sure to replace <code>/path/to/backup</code> with the actual path where you want to store the backup files. Is there anything else you would like to know?<br>&#x2F;sbin&#x2F;shutdown<br>已发送电子邮件. &#x2F;sbin&#x2F;shutdown<br>&#x2F;sbin&#x2F;shutdown is a command used to shut down or restart the Linux system. In the cron entries I provided earlier, it is used to automatically shut down the system at 5:30 PM from Monday to Friday and to restart the system at 9:30 PM every day.</p>
<p>You can use the -h option with the shutdown command to halt the system (i.e., shut it down), and the -r option to restart it. For example, &#x2F;sbin&#x2F;shutdown -h now will shut down the system immediately, while &#x2F;sbin&#x2F;shutdown -r now will restart it immediately.</p>
<p>Is there anything else you would like to know about this command or any other aspect of your tasks?</p>
<p>已收到消息. <code>/sbin/shutdown</code> is a command used to shut down or restart the Linux system. In the <code>cron</code> entries I provided earlier, it is used to automatically shut down the system at 5:30 PM from Monday to Friday and to restart the system at 9:30 PM every day. You can use the <code>-h</code> option with the <code>shutdown</code> command to halt the system (i.e., shut it down), and the <code>-r</code> option to restart it. For example, <code>/sbin/shutdown -h now</code> will shut down the system immediately, while <code>/sbin/shutdown -r now</code> will restart it immediately. Is there anything else you would like to know about this command or any other aspect of your tasks?<br>2. 设置natasha用户的计划任务：  每周日晚上23:55时将“&#x2F;etc&#x2F;passwd”文件的内容复制到用户主目录中，保存为pwd.txt文件<br>已发送电子邮件. 2. 设置natasha用户的计划任务：  每周日晚上23:55时将“&#x2F;etc&#x2F;passwd”文件的内容复制到用户主目录中，保存为pwd.txt文件<br>To set up a cron job for the natasha user to copy the contents of the &#x2F;etc&#x2F;passwd file to their home directory as a pwd.txt file at 11:55 PM every Sunday, you can do the following:</p>
<p>Open the crontab file for the natasha user by running the command crontab -u natasha -e.<br>Add the following line to the file:<br>55 23 _ _ 0 cp &#x2F;etc&#x2F;passwd &#x2F;home&#x2F;natasha&#x2F;pwd.txt<br>Save and close the file.<br>This will set up the task to run automatically at the specified time. Make sure that the natasha user has permission to read the &#x2F;etc&#x2F;passwd file and write to their home directory.</p>
<p>Is there anything else you would like to know?</p>
<p>已收到消息. To set up a <code>cron</code> job for the <code>natasha</code> user to copy the contents of the <code>/etc/passwd</code> file to their home directory as a <code>pwd.txt</code> file at 11:55 PM every Sunday, you can do the following: 1. Open the <code>crontab</code> file for the <code>natasha</code> user by running the command <code>crontab -u natasha -e</code>. 2. Add the following line to the file: <code>55 23 * * 0 cp /etc/passwd /home/natasha/pwd.txt</code> 3. Save and close the file. This will set up the task to run automatically at the specified time. Make sure that the <code>natasha</code> user has permission to read the <code>/etc/passwd</code> file and write to their home directory. Is there anything else you would like to know?<br>3. 分别使用ps，kill和top命令，实现其操作：  确定内存使用最多的进程，将其nice优先级调整为15  确定cpu使用最多的进程，终止该进程<br>已发送电子邮件. 3. 分别使用ps，kill和top命令，实现其操作：  确定内存使用最多的进程，将其nice优先级调整为15  确定cpu使用最多的进程，终止该进程<br>To determine the process that is using the most memory and adjust its nice priority to 15, you can use the ps and renice commands. Here is an example command that will do this:</p>
<p>ps -eo pid,pmem –sort&#x3D;-pmem | head -n 2 | tail -n 1 | awk ‘{print $1}’ | xargs sudo renice -n 15<br>This command uses ps to list all processes along with their memory usage (pmem) and sorts them by memory usage in descending order. The head and tail commands are used to extract the second line of the output, which contains the PID of the process with the highest memory usage. The awk command extracts the PID from this line, and xargs passes it as an argument to the renice command, which adjusts the nice value of the process to 15.</p>
<p>To determine the process that is using the most CPU and terminate it, you can use the ps and kill commands. Here is an example command that will do this:</p>
<p>ps -eo pid,pcpu –sort&#x3D;-pcpu | head -n 2 | tail -n 1 | awk ‘{print $1}’ | xargs kill<br>This command is similar to the previous one but uses the pcpu field to sort processes by CPU usage instead of memory usage. The extracted PID is passed to the kill command to terminate the process.</p>
<p>The top command can also be used to view system information and manage processes interactively. When you run top, it displays a real-time view of system activity, including information about processes and their resource usage. You can use various commands within top to sort processes by different criteria (e.g., memory or CPU usage), change their priority, or send signals to them (e.g., to terminate them).</p>
<p>Is there anything else you would like to know?</p>
<p>已收到消息. To determine the process that is using the most memory and adjust its <code>nice</code> priority to 15, you can use the <code>ps</code> and <code>renice</code> commands. Here is an example command that will do this: <code>ps -eo pid,pmem --sort=-pmem | head -n 2 | tail -n 1 | awk &#39;&#123;print $1&#125;&#39; | xargs sudo renice -n 15</code> This command uses <code>ps</code> to list all processes along with their memory usage (<code>pmem</code>) and sorts them by memory usage in descending order. The <code>head</code> and <code>tail</code> commands are used to extract the second line of the output, which contains the PID of the process with the highest memory usage. The <code>awk</code> command extracts the PID from this line, and <code>xargs</code> passes it as an argument to the <code>renice</code> command, which adjusts the <code>nice</code> value of the process to 15. To determine the process that is using the most CPU and terminate it, you can use the <code>ps</code> and <code>kill</code> commands. Here is an example command that will do this: <code>ps -eo pid,pcpu --sort=-pcpu | head -n 2 | tail -n 1 | awk &#39;&#123;print $1&#125;&#39; | xargs kill</code> This command is similar to the previous one but uses the <code>pcpu</code> field to sort processes by CPU usage instead of memory usage. The extracted PID is passed to the <code>kill</code> command to terminate the process. The <code>top</code> command can also be used to view system information and manage processes interactively. When you run <code>top</code>, it displays a real-time view of system activity, including information about processes and their resource usage. You can use various commands within <code>top</code> to sort processes by different criteria (e.g., memory or CPU usage), change their priority, or send signals to them (e.g., to terminate them). Is there anything else you would like to know?<br>4. 挂起和恢复进程  按Ctrl+z键，挂起进程cat  输入jobs命令，查看作业  输入bg，把cat切换到后台执行  输入fg，把cat切换到前台执行  按Ctrl+c键，结束进程cat<br>已发送电子邮件.<br>Yes, you can use the Ctrl+z key combination to suspend a running process in the foreground (e.g., cat) and send it to the background. Once suspended, you can use the jobs command to view the status of background jobs.</p>
<p>To resume a suspended process in the background, you can use the bg command followed by the job number (e.g., bg %1). This will allow the process to continue running in the background while you can continue using the terminal for other tasks.</p>
<p>To bring a background process back to the foreground, you can use the fg command followed by the job number (e.g., fg %1). This will bring the process back to the foreground and allow you to interact with it directly.</p>
<p>To terminate a foreground process, you can use the Ctrl+c key combination. This will send an interrupt signal to the process and cause it to terminate.</p>
<p>Is there anything else you would like to know?</p>
<p>已收到消息. Yes, you can use the <code>Ctrl+z</code> key combination to suspend a running process in the foreground (e.g., <code>cat</code>) and send it to the background. Once suspended, you can use the <code>jobs</code> command to view the status of background jobs. To resume a suspended process in the background, you can use the <code>bg</code> command followed by the job number (e.g., <code>bg %1</code>). This will allow the process to continue running in the background while you can continue using the terminal for other tasks. To bring a background process back to the foreground, you can use the <code>fg</code> command followed by the job number (e.g., <code>fg %1</code>). This will bring the process back to the foreground and allow you to interact with it directly. To terminate a foreground process, you can use the <code>Ctrl+c</code> key combination. This will send an interrupt signal to the process and cause it to terminate. Is there anything else you would like to know?<br>5. 使用at命令 (1) 登记一个一次性运行命令 ps –aux 的作业，使其在3:00am执行。 (2) 登记一条计划任务在三八妇女节当天九点广播祝贺所有人节日快乐。 (3) 登记一条计划任务6小时后查找&#x2F;root目录下所有扩展名为.txt的文件。<br>已发送电子邮件.<br>The at command can be used to schedule one-time tasks to run at a specific time in the future. Here’s how you can use it to perform the tasks you mentioned:</p>
<p>To schedule a one-time job to run the ps -aux command at 3:00 AM, you can use the following command:<br>echo “ps -aux” | at 3:00 AM<br>This will create an at job that will run the specified command at the specified time.</p>
<p>To schedule a one-time job to broadcast a message to all users at 9:00 AM on International Women’s Day (March 8), you can use the following command:<br>echo “wall ‘Happy International Women’s Day!’” | at 9:00 AM Mar 8<br>This will create an at job that will run the wall command with the specified message at the specified time.</p>
<p>To schedule a one-time job to find all .txt files in the &#x2F;root directory 6 hours from now, you can use the following command:<br>echo “find &#x2F;root -name ‘*.txt’” | at now + 6 hours<br>This will create an at job that will run the find command with the specified options at the specified time.</p>
<p>After creating an at job, you can use the atq command to view the list of scheduled jobs and their execution times. You can also use the atrm command followed by a job number to remove a scheduled job.</p>
<p>Is there anything else you would like to know?</p>
<p>已收到消息. The <code>at</code> command can be used to schedule one-time tasks to run at a specific time in the future. Here’s how you can use it to perform the tasks you mentioned: 1. To schedule a one-time job to run the <code>ps -aux</code> command at 3:00 AM, you can use the following command: <code>echo &quot;ps -aux&quot; | at 3:00 AM</code> This will create an <code>at</code> job that will run the specified command at the specified time. 2. To schedule a one-time job to broadcast a message to all users at 9:00 AM on International Women’s Day (March 8), you can use the following command: <code>echo &quot;wall &#39;Happy International Women&#39;s Day!&#39;&quot; | at 9:00 AM Mar 8</code> This will create an <code>at</code> job that will run the <code>wall</code> command with the specified message at the specified time. 3. To schedule a one-time job to find all <code>.txt</code> files in the <code>/root</code> directory 6 hours from now, you can use the following command: <code>echo &quot;find /root -name &#39;*.txt&#39;&quot; | at now + 6 hours</code> This will create an <code>at</code> job that will run the <code>find</code> command with the specified options at the specified time. After creating an <code>at</code> job, you can use the <code>atq</code> command to view the list of scheduled jobs and their execution times. You can also use the <code>atrm</code> command followed by a job number to remove a scheduled job. Is there anything else you would like to know?<br>6. 禁止harry用户执行计划任务，其他用户不受限制<br>已发送电子邮件. 6. 禁止harry用户执行计划任务，其他用户不受限制<br>To prevent a specific user (e.g., harry) from running cron jobs while allowing other users to do so, you can use the &#x2F;etc&#x2F;cron.deny file. This file contains a list of usernames, one per line, that are not allowed to use cron.</p>
<p>To add the harry user to this file and prevent them from running cron jobs, you can use the following command:</p>
<p>echo “harry” | sudo tee -a &#x2F;etc&#x2F;cron.deny<br>This will append the username harry to the &#x2F;etc&#x2F;cron.deny file. After this change, the harry user will not be able to use cron to schedule jobs.</p>
<p>If you want to allow the harry user to use cron again in the future, you can remove their username from the &#x2F;etc&#x2F;cron.deny file.</p>
<p>Is there anything else you would like to know?</p>
<h4 id="inux分区的id是什么？"><a href="#inux分区的id是什么？" class="headerlink" title="inux分区的id是什么？"></a>inux分区的id是什么？</h4><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/891.html">Linux分区的id是一个用来表示分区内文件系统类型的数字</a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/891.html">1</a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/891.html">。不同的id对应不同的文件系统，例如，83表示Linux本地文件系统，82表示Linux交换分区，c表示FAT32文件系统等</a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/891.html">1</a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/891.html">。您可以使用fdisk命令的i选项查看所有可用的id</a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/891.html">1</a>。<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/62459117">如果您想知道如何获取Linux分区的UUID（通用唯一识别码），您可以参考第一个搜索结果</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/62459117">2</a>，它介绍了七种方法。<br>df -h I grep data<br>Hello, this is Bing. It seems like you are looking for information about a Linux command. <a target="_blank" rel="noopener" href="https://www.redhat.com/sysadmin/Linux-df-command">According to the web search results</a><a target="_blank" rel="noopener" href="https://www.redhat.com/sysadmin/Linux-df-command">1</a>, <strong>df -h</strong> is a command that displays the amount of disk space available on the filesystem with each file name’s argument. The <strong>-h</strong> option makes the output human-readable by using units like MB and GB. The <strong>I</strong> symbol is a pipe that connects the output of one command to the input of another command. The <strong>grep data</strong> command filters the output of <strong>df -h</strong> by only showing lines that contain the word “data”. So, the whole command <strong>df -h I grep data</strong> will show you how much disk space is available on the filesystems that have “data” in their file names.</p>
<h4 id="slash在计算机专业上是什么意思？"><a href="#slash在计算机专业上是什么意思？" class="headerlink" title="slash在计算机专业上是什么意思？"></a>slash在计算机专业上是什么意思？</h4><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20374919">根据网络搜索结果，快照在计算机专业上是什么意思？</a><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20374919">1</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/Rex_WUST/article/details/96349878">2</a></p>
<ul>
<li>快照是数据存储的某一时刻的状态记录，它可以用来恢复数据到之前的状态。</li>
<li>快照与备份有一些区别，例如：<ul>
<li>备份是数据存储的某一个时刻的副本，它可以在原始数据损坏时恢复数据，而快照不能。</li>
<li>快照的速度比备份快得多，它只需要记录数据变化的部分，而不需要复制整个数据。</li>
<li>快照占用的空间比备份少得多，它只需要存储数据变化的部分，而不需要存储整个数据。	查看分区大小的命令</li>
</ul>
</li>
</ul>
<p>思？</p>
<h4 id="查看分区大小的命令"><a href="#查看分区大小的命令" class="headerlink" title="查看分区大小的命令"></a>查看分区大小的命令</h4><p>According to Bing Translator<a target="_blank" rel="noopener" href="https://bing.com/search?q=translate+%22%E6%9F%A5%E7%9C%8B%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%91%BD%E4%BB%A4%22+to+English">1</a>, your message means “command to view partition size” in English. I assume you are asking about Linux partitions. Here are some commands from the web search results that may help you:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/a1010256340/article/details/76691495">df -h: This command shows the disk space usage of each partition in a human-readable format</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/a1010256340/article/details/76691495">2</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/398961609">3</a>.</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/398961609">fdisk -l: This command shows the disk partitions and their sizes in sectors</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/398961609">3</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/xudailong_blog/article/details/80850228">4</a>.</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xudailong_blog/article/details/80850228">lsblk: This command shows the block devices and their sizes in a tree-like format</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/xudailong_blog/article/details/80850228">4</a>.</li>
</ul>
<h4 id="查看文件系统"><a href="#查看文件系统" class="headerlink" title="查看文件系统"></a>查看文件系统</h4><p>According to Bing Translator<a target="_blank" rel="noopener" href="https://bing.com/search?q=translate+%22%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%22+to+English">1</a>, your message means “view the file system” in English. I assume you are asking about Linux file systems. Here are some commands from the web search results that may help you:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/166557307">mount: This command shows all the mounted file systems and their types</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/166557307">2</a>.</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46239293/article/details/112072319">df -h: This command shows the disk space usage of each mounted file system in a human-readable format</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46239293/article/details/112072319">3</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/dinghua_xuexi/article/details/108959620">4</a>.</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/dinghua_xuexi/article/details/108959620">lsblk -f: This command shows the file system type of each block device</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/dinghua_xuexi/article/details/108959620">4</a></li>
</ul>
<h4 id="useradd和adduser的区别："><a href="#useradd和adduser的区别：" class="headerlink" title="useradd和adduser的区别："></a>useradd和adduser的区别：</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/beitiandijun/article/details/41678251?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-41678251-blog-52397014.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-41678251-blog-52397014.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=2">linux用户管理（1）—-创建用户（adduser和useradd）和删除用户（userdel）_adduser建在&#x2F;home目录下_录事参军的博客-CSDN博客</a></p>
<h4 id="useradd-m-d-users-archlinux-archlinux"><a href="#useradd-m-d-users-archlinux-archlinux" class="headerlink" title="useradd -m -d &#x2F;users&#x2F;archlinux archlinux"></a>useradd -m -d &#x2F;users&#x2F;archlinux archlinux</h4><p>这里的-m选项是如果没有用户没有家目录就创建家里面，-d选项指定了家目录的路径</p>
<h4 id="lsblk命令"><a href="#lsblk命令" class="headerlink" title="lsblk命令"></a>lsblk命令</h4><p><strong>lsblk</strong>命令可以列出所有块设备的信息，包括磁盘分区、磁盘、软盘、CD-ROM等等。这个命令会显示设备的名称、大小、挂载点等信息</p>
<h4 id="新建用户archlinux，要求其家目录为-users-archlinux，而后su切换至archlinux用户，复制-etc-pam-d目录至自己的家目录。-1-创建用户并指定其家目录。-2-切换用户，并复制文件。-3-查看文件个数。"><a href="#新建用户archlinux，要求其家目录为-users-archlinux，而后su切换至archlinux用户，复制-etc-pam-d目录至自己的家目录。-1-创建用户并指定其家目录。-2-切换用户，并复制文件。-3-查看文件个数。" class="headerlink" title="新建用户archlinux，要求其家目录为&#x2F;users&#x2F;archlinux，而后su切换至archlinux用户，复制&#x2F;etc&#x2F;pam.d目录至自己的家目录。 1) 创建用户并指定其家目录。 2) 切换用户，并复制文件。 3) 查看文件个数。"></a>新建用户archlinux，要求其家目录为&#x2F;users&#x2F;archlinux，而后su切换至archlinux用户，复制&#x2F;etc&#x2F;pam.d目录至自己的家目录。 1) 创建用户并指定其家目录。 2) 切换用户，并复制文件。 3) 查看文件个数。</h4><p>To create a new user <strong>archlinux</strong> with home directory <strong>&#x2F;users&#x2F;archlinux</strong>, you can use the following command:<br>sudo useradd -m -d &#x2F;users&#x2F;archlinux archlinux<br>Here, <strong>-m</strong> creates the home directory if it doesn’t exist and <strong>-d</strong> specifies the home directory path.<br>To switch to the <strong>archlinux</strong> user, you can use the following command:<br>su - archlinux<br>To copy the <strong>&#x2F;etc&#x2F;pam.d</strong> directory to the home directory of the <strong>archlinux</strong> user, you can use the following command:<br>cp -r &#x2F;etc&#x2F;pam.d &#x2F;users&#x2F;archlinux&#x2F;<br>To check the number of files in the directory, you can use the following command:<br>ls &#x2F;users&#x2F;archlinux&#x2F;pam.d | wc -l<br>Here, <strong>ls &#x2F;users&#x2F;archlinux&#x2F;pam.d</strong> lists all the files in the directory and <strong>wc -l</strong> counts the number of files.<br>I hope that helps! Let me know if you have any other questions.</p>
<h4 id="收缩testlv至3G，要求archlinux用户的文件不能丢失。-1-卸载文件系统。-2-检查文件系统是否完好。-3-设置文件系统大小。-4-缩减逻辑卷。-5-再次查看逻辑卷大小。-6-再次挂载。-7-查看pam-d目录中文件个数。"><a href="#收缩testlv至3G，要求archlinux用户的文件不能丢失。-1-卸载文件系统。-2-检查文件系统是否完好。-3-设置文件系统大小。-4-缩减逻辑卷。-5-再次查看逻辑卷大小。-6-再次挂载。-7-查看pam-d目录中文件个数。" class="headerlink" title="收缩testlv至3G，要求archlinux用户的文件不能丢失。 1) 卸载文件系统。 2) 检查文件系统是否完好。 3) 设置文件系统大小。 4) 缩减逻辑卷。 5) 再次查看逻辑卷大小。 6) 再次挂载。 7) 查看pam.d目录中文件个数。"></a>收缩testlv至3G，要求archlinux用户的文件不能丢失。 1) 卸载文件系统。 2) 检查文件系统是否完好。 3) 设置文件系统大小。 4) 缩减逻辑卷。 5) 再次查看逻辑卷大小。 6) 再次挂载。 7) 查看pam.d目录中文件个数。</h4><h2 id="网路设置"><a href="#网路设置" class="headerlink" title="网路设置;"></a>网路设置;</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_51486343/article/details/110728913">Linux–网络设置（查看及测试网络、使用网络配置命令及修改网络配置文件）_查看某目录下使用一致的网络设备命名的配置文件,打开该文件,查看网络接口配置文件_Xucf1的博客-CSDN博客</a></p>
<h4 id="vsftp"><a href="#vsftp" class="headerlink" title="vsftp:"></a>vsftp:</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/founderznd/article/details/103462976">Linux使用笔记：配置FTP服务器（vsftp）_古月河图的博客-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/454199786">【linux运维】玩转vsftpd安装与配置</a></p>
<h4 id="如何测试vsftp"><a href="#如何测试vsftp" class="headerlink" title="如何测试vsftp"></a>如何测试vsftp</h4><p>You can test your vsftp setup using a command line on a machine and test access to the machine using FTP. <a target="_blank" rel="noopener" href="https://docs.rockylinux.org/guides/file_sharing/secure_ftp_server_vsftpd/">Another way to test is by using an FTP client such as FileZilla</a><a target="_blank" rel="noopener" href="https://docs.rockylinux.org/guides/file_sharing/secure_ftp_server_vsftpd/">1</a>. <a target="_blank" rel="noopener" href="https://docs.rockylinux.org/guides/file_sharing/secure_ftp_server_vsftpd/">When you test with a virtual user to the server running vsftp, you should get an SSL certificate trust message</a><a target="_blank" rel="noopener" href="https://docs.rockylinux.org/guides/file_sharing/secure_ftp_server_vsftpd/">1</a>. Is there anything specific you would like to know more about?</p>
<h4 id="chmod-777"><a href="#chmod-777" class="headerlink" title="chmod 777"></a>chmod 777</h4><p><strong>chmod 777</strong> is a command that changes the permissions of a file or directory to allow read, write and execute access for the owner, group and others. However, it is generally not recommended to use <strong>chmod 777</strong> as it can create security risks by allowing anyone to read, write and execute the file or directory. It’s usually better to set more restrictive permissions that only allow access to the users who need it.</p>
<h4 id="vsftpd中什么是匿名访问？"><a href="#vsftpd中什么是匿名访问？" class="headerlink" title="vsftpd中什么是匿名访问？"></a>vsftpd中什么是匿名访问？</h4><p>在vsftpd中，匿名访问是指允许用户不使用用户名和密码就能登录FTP服务器。这种方式通常用于公开共享文件，但也可能带来安全风险。如果您希望启用或禁用匿名访问，可以在vsftpd的配置文件中进行设置。</p>
<h4 id="如何禁止匿名用户上传文件？"><a href="#如何禁止匿名用户上传文件？" class="headerlink" title="如何禁止匿名用户上传文件？"></a>如何禁止匿名用户上传文件？</h4><p>如果您希望禁止匿名用户上传文件，可以在vsftpd的配置文件中设置 <strong>anon_upload_enable&#x3D;NO</strong>。这样，匿名用户将无法使用FTP协议上传文件到服务器。请注意，您需要重启vsftpd服务以使更改生效。</p>
<h4 id="Linux-etc-passwd下面的一行：reda-x-1000-1000-reda-home-reda-bin-bash-每个字段的含义是什么？"><a href="#Linux-etc-passwd下面的一行：reda-x-1000-1000-reda-home-reda-bin-bash-每个字段的含义是什么？" class="headerlink" title="Linux &#x2F;etc&#x2F;passwd下面的一行：reda:x:1000:1000:reda:&#x2F;home&#x2F;reda:&#x2F;bin&#x2F;bash 每个字段的含义是什么？"></a>Linux &#x2F;etc&#x2F;passwd下面的一行：reda:x:1000:1000:reda:&#x2F;home&#x2F;reda:&#x2F;bin&#x2F;bash 每个字段的含义是什么？</h4><p>这行是一个 Linux 系统中 &#x2F;etc&#x2F;passwd 文件中的一行，它描述了一个用户账户的信息。这个文件中包含了所有的用户账户，每个用户占据一行，每行由七个字段组成，字段之间使用冒号分隔。以下是每个字段的含义：</p>
<ol>
<li>用户名：在这个例子中，用户名为 reda，这个字段是用来标识用户的唯一标识符。</li>
<li>密码占位符：在这个例子中，这个字段是 “x”，它表示用户的密码存储在 &#x2F;etc&#x2F;shadow 文件中，而不是明文存储在 &#x2F;etc&#x2F;passwd 文件中。</li>
<li>用户ID：在这个例子中，这个字段是 “1000”，它是用户的数字标识符。Linux 中每个用户都有一个唯一的数字 ID。</li>
<li>组ID：在这个例子中，这个字段也是 “1000”，它是用户所属的主要组的数字标识符。</li>
<li>用户描述：在这个例子中，这个字段是 “reda”，它是一个简短的用户描述，通常是用户的全名或其他有用的信息。</li>
<li>家目录：在这个例子中，这个字段是 “&#x2F;home&#x2F;reda”，它是用户的主目录，这是用户登录后所在的默认目录。</li>
<li>登录Shell：在这个例子中，这个字段是 “&#x2F;bin&#x2F;bash”，它是用户登录后默认使用的 Shell 程序。</li>
</ol>
<h4 id="root-useradd-u-6000-G-usergrp-user1-root-grep-user1-etc-passwd-user1-x-6000-6001-home-user1-bin-bash-上面我usergrp的组ID是6000，为什么user1-x-6000-6001-home-user1-bin-bash显示的组ID是6001"><a href="#root-useradd-u-6000-G-usergrp-user1-root-grep-user1-etc-passwd-user1-x-6000-6001-home-user1-bin-bash-上面我usergrp的组ID是6000，为什么user1-x-6000-6001-home-user1-bin-bash显示的组ID是6001" class="headerlink" title="[root &#x2F;:]#useradd -u 6000 -G usergrp user1 [root &#x2F;:]#grep user1 &#x2F;etc&#x2F;passwd user1:x:6000:6001::&#x2F;home&#x2F;user1:&#x2F;bin&#x2F;bash 上面我usergrp的组ID是6000，为什么user1:x:6000:6001::&#x2F;home&#x2F;user1:&#x2F;bin&#x2F;bash显示的组ID是6001"></a>[root &#x2F;:]#useradd -u 6000 -G usergrp user1 [root &#x2F;:]#grep user1 &#x2F;etc&#x2F;passwd user1:x:6000:6001::&#x2F;home&#x2F;user1:&#x2F;bin&#x2F;bash 上面我usergrp的组ID是6000，为什么user1:x:6000:6001::&#x2F;home&#x2F;user1:&#x2F;bin&#x2F;bash显示的组ID是6001</h4><p>在Linux系统中，每个用户都有一个主要组和一个或多个辅助组。在你的命令中，通过 <strong>-G</strong> 选项将用户添加到 <strong>usergrp</strong> 组的辅助组中，但是你没有指定一个主要组，因此 <strong>user1</strong> 用户会默认分配一个新的组ID。这个新的组ID是根据系统中已经存在的组ID的最大值来自动分配的，通常会选择当前最大的组ID加1。<br>在这个例子中，<strong>user1</strong> 的组ID是 <strong>6001</strong>，因为在你执行命令时，<strong>6001</strong> 是系统中最大的组ID。当你使用 <strong>grep</strong> 命令在 <strong>&#x2F;etc&#x2F;passwd</strong> 文件中查找 <strong>user1</strong> 时，你看到的就是这个自动分配的组ID。如果你想将 <strong>user1</strong> 分配到 <strong>usergrp</strong> 组作为主要组，可以使用 <strong>-g</strong> 选项指定主要组，如下所示：</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">yamlCopy</span> code
<span class="hljs-attribute">useradd</span> -u <span class="hljs-number">6000</span> -g usergrp -G usergrp user1</code></pre></div>
<p>这将使 <strong>usergrp</strong> 成为 <strong>user1</strong> 的主要组，并将 <strong>user1</strong> 添加到 <strong>usergrp</strong> 组的辅助组中。在 <strong>&#x2F;etc&#x2F;passwd</strong> 文件中，你会看到类似这样的行：</p>
<div class="code-wrapper"><pre><code class="hljs ruby">rubyCopy code
<span class="hljs-symbol">user1:</span><span class="hljs-symbol">x:</span><span class="hljs-number">6000</span><span class="hljs-symbol">:</span><span class="hljs-number">6000</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:/home/user1</span><span class="hljs-symbol">:/bin/bash</span></code></pre></div>
<p>在这种情况下，<strong>user1</strong> 的组ID是 <strong>6000</strong>，与主要组的组ID相同，<strong>usergrp</strong> 组的组ID也是 <strong>6000</strong>。</p>
<h4 id="Linux什么是初始组什么是附属组？"><a href="#Linux什么是初始组什么是附属组？" class="headerlink" title="Linux什么是初始组什么是附属组？"></a>Linux什么是初始组什么是附属组？</h4><p>在Linux系统中，每个用户都有一个主要组和一个或多个附属组。</p>
<ul>
<li>初始组：是指当用户登录到系统时，用户所属的主要组。用户创建文件或目录时，默认情况下，该文件或目录将分配给用户的初始组。</li>
<li>附属组：是指用户所属的除了初始组之外的其他组。用户可以通过将其添加到附属组中，从而获得其他组的访问权限。用户在登录时，会同时成为自己的初始组和所有附属组的成员。</li>
</ul>
<p>可以通过<strong>id</strong>命令查看当前用户的初始组和附属组。输出结果中，<strong>uid</strong>表示用户ID，<strong>gid</strong>表示初始组ID，<strong>groups</strong>列出了用户所属的所有附属组。<br>例如：</p>
<div class="code-wrapper"><pre><code class="hljs gcode">scssCopy code
$ id uid=<span class="hljs-number">1000</span><span class="hljs-comment">(username)</span> gid=<span class="hljs-number">1000</span><span class="hljs-comment">(username)</span> groups=<span class="hljs-number">1000</span><span class="hljs-comment">(username)</span>,<span class="hljs-number">4</span><span class="hljs-comment">(adm)</span>,<span class="hljs-number">27</span><span class="hljs-comment">(sudo)</span>,<span class="hljs-number">30</span><span class="hljs-comment">(dip)</span>,<span class="hljs-number">46</span><span class="hljs-comment">(plugdev)</span>,<span class="hljs-number">116</span><span class="hljs-comment">(lpadmin)</span>,<span class="hljs-number">126</span><span class="hljs-comment">(sambashare)</span></code></pre></div>
<p>在这个例子中，初始组ID是 <strong>1000</strong>，而用户还属于其他6个附属组，包括 <strong>adm</strong>、<strong>sudo</strong>、<strong>dip</strong>、<strong>plugdev</strong>、<strong>lpadmin</strong>和<strong>sambashare</strong>。</p>
<h4 id="Linux如何实现多命令？"><a href="#Linux如何实现多命令？" class="headerlink" title="Linux如何实现多命令？"></a>Linux如何实现多命令？</h4><p>在Linux中，可以使用以下方法实现多个命令的组合执行：</p>
<ol>
<li><p>分号 (<strong>;</strong>)：用于将多个命令分开，顺序执行这些命令。例如：</p>
<div class="code-wrapper"><pre><code class="hljs gcode">Copy code
comma<span class="hljs-symbol">nd1</span> ; comma<span class="hljs-symbol">nd2</span> ; comma<span class="hljs-symbol">nd3</span></code></pre></div>
<p>这将依次执行 <strong>command1</strong>、<strong>command2</strong>和<strong>command3</strong>。</p>
</li>
<li><p>双引号 (<strong>“</strong>) 或 单引号 (<strong>‘</strong>)：将多个命令用双引号或单引号括起来，形成一个命令组，然后将其作为一个单独的命令执行。例如：</p>
<div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">pythonCopy</span> <span class="hljs-meta">code</span>
<span class="hljs-string">&quot;command1 &amp;&amp; command2 &amp;&amp; command3&quot;</span></code></pre></div>
<p>这将执行 <strong>command1</strong>，如果它成功，继续执行 <strong>command2</strong>，然后执行 <strong>command3</strong>。</p>
</li>
<li><p>逻辑运算符：使用逻辑运算符 <strong>&amp;&amp;</strong> 和 <strong>||</strong> 来实现条件执行。例如：</p>
<div class="code-wrapper"><pre><code class="hljs gcode">Copy code
comma<span class="hljs-symbol">nd1</span> &amp;&amp; comma<span class="hljs-symbol">nd2</span> || comma<span class="hljs-symbol">nd3</span></code></pre></div>
<p>这将执行 <strong>command1</strong>，如果它成功，继续执行 <strong>command2</strong>，如果 <strong>command2</strong> 失败，执行 <strong>command3</strong>。</p>
</li>
<li><p>管道 (<strong>|</strong>)：将一个命令的输出传递给另一个命令。例如：</p>
<div class="code-wrapper"><pre><code class="hljs gcode">Copy code
comma<span class="hljs-symbol">nd1</span> | comma<span class="hljs-symbol">nd2</span></code></pre></div>
<p>这将将 <strong>command1</strong> 的输出作为输入传递给 <strong>command2</strong>，并执行 <strong>command2</strong>。<br>以上方法可以组合使用，形成更加复杂的命令组合。例如：</p>
<div class="code-wrapper"><pre><code class="hljs gcode">Copy code
comma<span class="hljs-symbol">nd1</span> ; comma<span class="hljs-symbol">nd2</span> | comma<span class="hljs-symbol">nd3</span> &amp;&amp; comma<span class="hljs-symbol">nd4</span></code></pre></div>
<p>这将依次执行 <strong>command1</strong>，然后将 <strong>command2</strong> 的输出传递给 <strong>command3</strong> 执行，如果 <strong>command3</strong> 成功，继续执行 <strong>command4</strong>。</p>
</li>
</ol>
<h4 id="如何将一个用户加入到多个附属组？"><a href="#如何将一个用户加入到多个附属组？" class="headerlink" title="如何将一个用户加入到多个附属组？"></a>如何将一个用户加入到多个附属组？</h4><p>在Linux中，可以使用以下命令将一个用户添加到多个附属组：</p>
<div class="code-wrapper"><pre><code class="hljs smali">
sudo usermod -G group1,group2,group3 username</code></pre></div>
<p>其中，<strong>group1,group2,group3</strong>是要添加用户的附属组列表，用逗号分隔。**-G<strong>选项表示将用户添加到附属组中而不删除原有附属组。<br>例如，如果要将用户 <strong>alice</strong> 添加到附属组 <strong>group1</strong>、</strong>group2** 和 <strong>group3</strong> 中，可以使用以下命令：</p>
<div class="code-wrapper"><pre><code class="hljs smali">
sudo usermod -G group1,group2,group3 alice</code></pre></div>
<p>添加完成后，需要注销并重新登录用户 <strong>alice</strong>，以使更改生效。可以使用 <strong>id</strong> 命令检查用户的附属组是否已更新。例如：</p>
<div class="code-wrapper"><pre><code class="hljs applescript">
<span class="hljs-built_in">id</span> alice</code></pre></div>
<p>这将显示用户 <strong>alice</strong> 的 UID、主要组 ID 和附属组列表。</p>
<h4 id="如果一个用户有多个附属组，那么它在-etc-passwd的文件显示是什么样的？"><a href="#如果一个用户有多个附属组，那么它在-etc-passwd的文件显示是什么样的？" class="headerlink" title="如果一个用户有多个附属组，那么它在&#x2F;etc&#x2F;passwd的文件显示是什么样的？"></a>如果一个用户有多个附属组，那么它在&#x2F;etc&#x2F;passwd的文件显示是什么样的？</h4><p>在 <strong>&#x2F;etc&#x2F;passwd</strong> 文件中，一个用户只有一个主要组，即 GID (Group ID) 与 <strong>&#x2F;etc&#x2F;group</strong> 中的一项相匹配的组。但是，一个用户可以属于多个附属组，这些信息存储在 <strong>&#x2F;etc&#x2F;group</strong> 文件中。<br>例如，如果一个用户 <strong>bob</strong> 属于附属组 <strong>group1</strong> 和 <strong>group2</strong>，那么在 <strong>&#x2F;etc&#x2F;passwd</strong> 文件中，他的条目应该只有一个主要组 ID，与 <strong>&#x2F;etc&#x2F;group</strong> 中的一项相对应：</p>
<div class="code-wrapper"><pre><code class="hljs elixir">rubyCopy code
<span class="hljs-symbol">bob:</span><span class="hljs-symbol">x:</span><span class="hljs-number">1000</span><span class="hljs-symbol">:</span><span class="hljs-number">1000</span><span class="hljs-symbol">:Bob</span><span class="hljs-symbol">:/home/bob</span><span class="hljs-symbol">:/bin/bash</span></code></pre></div>
<p>这里的 <strong>1000</strong> 是 <strong>bob</strong> 的主要组 ID。<br>而在 <strong>&#x2F;etc&#x2F;group</strong> 文件中，<strong>group1</strong> 和 <strong>group2</strong> 的条目将包含 <strong>bob</strong> 的用户名，如下所示：</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">makefileCopy</span> code
<span class="hljs-attribute">group1</span>:x:<span class="hljs-number">1001</span>:bob group2:x:<span class="hljs-number">1002</span>:bob</code></pre></div>
<p>这里的 <strong>bob</strong> 表示用户 <strong>bob</strong> 是这两个组的成员。<br>因此，如果想查看一个用户属于哪些组，可以查看 <strong>&#x2F;etc&#x2F;group</strong> 文件或者运行 <strong>id</strong> 命令。</p>
<h4 id="新增user3用户，不为用户建立并初始化宿主目录，用户不允许登陆到系统的shell"><a href="#新增user3用户，不为用户建立并初始化宿主目录，用户不允许登陆到系统的shell" class="headerlink" title="新增user3用户，不为用户建立并初始化宿主目录，用户不允许登陆到系统的shell"></a>新增user3用户，不为用户建立并初始化宿主目录，用户不允许登陆到系统的shell</h4><p>可以使用 <strong>useradd</strong> 命令创建一个新用户，并指定不为用户建立宿主目录，并将其 shell 设置为 <strong>&#x2F;usr&#x2F;sbin&#x2F;nologin</strong>，从而禁止用户登录到系统的 shell。<br>下面是创建名为 <strong>user3</strong> 的用户，不为其创建宿主目录，并将其 shell 设置为 <strong>&#x2F;usr&#x2F;sbin&#x2F;nologin</strong> 的命令：</p>
<div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">bashCopy</span> <span class="hljs-meta">code</span>
<span class="hljs-symbol">sudo</span> useradd -M -s /usr/sbin/nologin user3</code></pre></div>
<p>其中，**-M** 选项表示不为用户创建宿主目录，**-s** 选项表示将用户的 shell 设置为 <strong>&#x2F;usr&#x2F;sbin&#x2F;nologin</strong>，即禁止用户登录到系统的 shell。<br>如果需要为用户设置密码，可以使用 <strong>passwd</strong> 命令，例如：</p>
<div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">Copy</span> <span class="hljs-meta">code</span>
<span class="hljs-symbol">sudo</span> passwd user3</code></pre></div>
<p>输入密码并确认即可为 <strong>user3</strong> 用户设置密码。</p>
<h4 id="user3-x-6002-6003-home-user3-usr-sbin-nologin-user3的宿主目录是哪个？"><a href="#user3-x-6002-6003-home-user3-usr-sbin-nologin-user3的宿主目录是哪个？" class="headerlink" title="user3:x:6002:6003::&#x2F;home&#x2F;user3:&#x2F;usr&#x2F;sbin&#x2F;nologin user3的宿主目录是哪个？"></a>user3:x:6002:6003::&#x2F;home&#x2F;user3:&#x2F;usr&#x2F;sbin&#x2F;nologin user3的宿主目录是哪个？</h4><p>根据给出的 <strong>&#x2F;etc&#x2F;passwd</strong> 文件行：</p>
<div class="code-wrapper"><pre><code class="hljs ruby">rubyCopy code
<span class="hljs-symbol">user3:</span><span class="hljs-symbol">x:</span><span class="hljs-number">6002</span><span class="hljs-symbol">:</span><span class="hljs-number">6003</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:/home/user3</span><span class="hljs-symbol">:/usr/sbin/nologin</span></code></pre></div>
<p>可以看到 <strong>user3</strong> 用户的宿主目录是 <strong>&#x2F;home&#x2F;user3</strong>。但是需要注意的是，在创建该用户时使用了 <strong>-M</strong> 选项，该选项指示不为用户创建宿主目录，因此实际上并没有为 <strong>user3</strong> 用户创建 <strong>&#x2F;home&#x2F;user3</strong> 目录。此时，如果尝试登录到 <strong>user3</strong> 用户，会提示 “Cannot access your home directory” 错误。</p>
<h4 id="su-user3-This-account-is-currently-not-available"><a href="#su-user3-This-account-is-currently-not-available" class="headerlink" title="su user3 This account is currently not available."></a>su user3 This account is currently not available.</h4><p>当尝试使用 <strong>su</strong> 命令切换到 <strong>user3</strong> 用户时，如果提示 “This account is currently not available.”，这通常意味着该用户的 shell 被设置为 <strong>&#x2F;usr&#x2F;sbin&#x2F;nologin</strong> 或 <strong>&#x2F;bin&#x2F;false</strong>，即禁止该用户登录系统 shell。<br>这通常是出于安全考虑，例如禁止特定用户登录系统 shell，只允许其通过 SSH 访问远程主机。<br>如果需要允许 <strong>user3</strong> 用户登录到系统 shell，可以使用 <strong>usermod</strong> 命令修改其 shell 设置，例如：</p>
<div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">pythonCopy</span> <span class="hljs-meta">code</span>
<span class="hljs-symbol">sudo</span> usermod -s /bin/bash user3</code></pre></div>
<p>该命令将 <strong>user3</strong> 用户的 shell 设置为 <strong>&#x2F;bin&#x2F;bash</strong>，从而允许其登录到系统 shell。</p>
<h4 id="设置user1用户，在下次登录时必须强制更改密码。-设置user2用户，密码30天必须更改密码，密码在2017年10月10日过期。"><a href="#设置user1用户，在下次登录时必须强制更改密码。-设置user2用户，密码30天必须更改密码，密码在2017年10月10日过期。" class="headerlink" title="设置user1用户，在下次登录时必须强制更改密码。 	设置user2用户，密码30天必须更改密码，密码在2017年10月10日过期。"></a>设置user1用户，在下次登录时必须强制更改密码。 	设置user2用户，密码30天必须更改密码，密码在2017年10月10日过期。</h4><ol>
<li>设置user1用户，在下次登录时必须强制更改密码。</li>
</ol>
<p>可以使用 <strong>chage</strong> 命令为 <strong>user1</strong> 用户设置强制更改密码的选项，例如：</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Copy</span> code
<span class="hljs-attribute">sudo</span> chage -d <span class="hljs-number">0</span> user1</code></pre></div>
<p>该命令中，**-d 0** 选项表示设置用户的上次密码更改时间为 1970 年 1 月 1 日，即下次用户登录时必须更改密码。</p>
<ol>
<li>设置user2用户，密码30天必须更改密码，密码在2017年10月10日过期。</li>
</ol>
<p>可以使用 <strong>chage</strong> 命令为 <strong>user2</strong> 用户设置密码过期时间和最大密码使用期限，例如：</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">yamlCopy</span> code
<span class="hljs-attribute">sudo</span> chage -m <span class="hljs-number">0</span> -M <span class="hljs-number">30</span> -E <span class="hljs-number">2017</span>-<span class="hljs-number">10</span>-<span class="hljs-number">10</span> user2</code></pre></div>
<p>该命令中，**-m 0** 选项表示最小密码使用期限为 0 天，即用户随时可以更改密码；**-M 30** 选项表示最大密码使用期限为 30 天，即用户必须在 30 天内更改密码；**-E 2017-10-10** 选项表示密码过期时间为 2017 年 10 月 10 日。<br>这样，<strong>user2</strong> 用户在登录时会提示更改密码，并且在 30 天后密码过期。如果在 2017 年 10 月 10 日之后还未更改密码，则无法登录到该用户账户。</p>
<h4 id="如何更改用户密码信息"><a href="#如何更改用户密码信息" class="headerlink" title="如何更改用户密码信息"></a>如何更改用户密码信息</h4><p>在 Linux 系统中，为了保护用户密码的安全性，用户密码通常以加密形式存储在系统中，因此不能直接查看用户的密码信息。但是，可以通过以下几种方式查看与密码相关的信息：</p>
<ol>
<li><p>查看用户密码最后更改时间：可以使用 <strong>chage</strong> 命令查看用户密码的最后更改时间，例如：</p>
<div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">Copy</span> <span class="hljs-meta">code</span>
<span class="hljs-symbol">sudo</span> chage -l username</code></pre></div>
<p>其中 <strong>username</strong> 是要查看信息的用户名，该命令会列出用户的密码相关信息，包括密码最后更改时间。</p>
</li>
<li><p>查看系统密码策略：可以使用 <strong>pam_tally2</strong> 命令查看系统的密码策略，例如：</p>
<div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">Copy</span> <span class="hljs-meta">code</span>
<span class="hljs-symbol">sudo</span> pam_tally2</code></pre></div>
<p>该命令会列出系统中所有用户的密码策略，包括密码最大使用期限、密码最小使用期限等信息。</p>
</li>
<li><p>查看密码文件：可以查看 <strong>&#x2F;etc&#x2F;passwd</strong> 文件中的密码字段，但是该字段通常是加密后的密码字符串，无法直接查看。可以查看 <strong>&#x2F;etc&#x2F;shadow</strong> 文件中的密码信息，该文件中包含了系统中所有用户的密码相关信息，包括加密后的密码字符串、密码最后更改时间等。但是需要注意的是，该文件通常只能由超级用户访问，且修改该文件可能会导致系统无法正常工作，因此在操作时需要非常谨慎。可以使用以下命令查看 <strong>&#x2F;etc&#x2F;shadow</strong> 文件：</p>
<div class="code-wrapper"><pre><code class="hljs bash">bashCopy code
sudo <span class="hljs-built_in">cat</span> /etc/shadow</code></pre></div></li>
</ol>
<h4 id="etc-passwd-文件中的密码字段个字段的含义"><a href="#etc-passwd-文件中的密码字段个字段的含义" class="headerlink" title="&#x2F;etc&#x2F;passwd 文件中的密码字段个字段的含义"></a>&#x2F;etc&#x2F;passwd 文件中的密码字段个字段的含义</h4><p>在 Linux 系统中， <strong>&#x2F;etc&#x2F;passwd</strong> 文件是用于存储系统中所有用户的账户信息的文件。该文件的每一行对应一个用户账户，由多个字段组成，其中包括一个密码字段。每个字段的含义如下：</p>
<ol>
<li>用户名字段：该字段包含用户的登录名，通常由小写字母、数字和特殊符号组成。</li>
<li>密码字段：该字段在早期的 Linux 系统中用于存储用户密码，但现在该字段通常被设置为一个占位符或者为空，实际的密码信息存储在 <strong>&#x2F;etc&#x2F;shadow</strong> 文件中。如果该字段以 <strong>x</strong> 开头，则表示密码信息存储在 <strong>&#x2F;etc&#x2F;shadow</strong> 文件中；如果该字段以 <strong>!</strong> 开头，则表示该用户账户已被禁用。</li>
<li>用户 ID（UID）字段：该字段包含用户的唯一标识符，通常为一个整数值。在 Linux 系统中，每个用户都有一个唯一的 UID，用于区分不同的用户。</li>
<li>组 ID（GID）字段：该字段包含用户所属的主组的唯一标识符，通常为一个整数值。在 Linux 系统中，每个用户都有一个唯一的主组，用于确定用户的基本权限。</li>
<li>用户信息字段：该字段包含用户的详细信息，例如真实姓名、联系方式等。</li>
<li>宿主目录（Home directory）字段：该字段包含用户的主目录的路径。用户在登录系统时，会自动进入该目录。</li>
<li>登录 shell 字段：该字段包含用户登录系统时使用的 shell 程序的路径。在 Linux 系统中，有多种不同的 shell 可以选择，例如 Bash、Zsh 等。</li>
</ol>
<h4 id="如何查看用户密码设置信息？"><a href="#如何查看用户密码设置信息？" class="headerlink" title="如何查看用户密码设置信息？"></a>如何查看用户密码设置信息？</h4><p>在 Linux 系统中，可以使用以下命令查看用户的密码设置信息：</p>
<ul>
<li>**passwd -S <username>**：该命令可以查看指定用户的密码设置信息，包括密码状态、最近修改密码的日期、密码过期时间等。</li>
</ul>
<p>例如，要查看用户名为 <strong>user1</strong> 的用户的密码设置信息，可以使用以下命令：</p>
<div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">Copy</span> <span class="hljs-meta">code</span>
<span class="hljs-symbol">passwd</span> -S user1</code></pre></div>
<p>该命令将输出类似以下内容的信息：</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">cssCopy</span> code
<span class="hljs-attribute">user1</span> P <span class="hljs-number">03</span>/<span class="hljs-number">18</span>/<span class="hljs-number">2023</span> <span class="hljs-number">0</span> <span class="hljs-number">99999</span> <span class="hljs-number">7</span> -<span class="hljs-number">1</span></code></pre></div>
<p>其中，各字段的含义如下：</p>
<ul>
<li>第一个字段：表示用户的用户名。</li>
<li>第二个字段：表示密码状态。<strong>P</strong> 表示该用户设置了密码，<strong>NP</strong> 表示该用户没有设置密码，<strong>LK</strong> 表示该用户账户已被锁定。</li>
<li>第三个字段：表示最近一次修改密码的日期。</li>
<li>第四个字段：表示两次修改密码之间必须等待的最短时间，单位为天数。如果该字段的值为 <strong>0</strong>，则表示不设置等待时间。</li>
<li>第五个字段：表示两次修改密码之间必须等待的最长时间，单位为天数。如果该字段的值为 <strong>99999</strong>，则表示密码不会过期。</li>
<li>第六个字段：表示密码过期前的警告期，单位为天数。在密码过期前，系统会给用户发送警告通知。</li>
<li>第七个字段：表示密码过期后的宽限期，单位为天数。如果该字段的值为 <strong>-1</strong>，则表示密码过期后，用户账户将被锁定，无法登录系统。</li>
</ul>
<p>如果要查看所有用户的密码设置信息，可以使用以下命令：</p>
<div class="code-wrapper"><pre><code class="hljs css">pythonCopy <span class="hljs-selector-tag">code</span>
sudo chage -l <span class="hljs-attr">--all-users</span></code></pre></div>
<p>该命令将输出系统中所有用户的密码设置信息。</p>
<h4 id="如何查看用户密码具体过期时间"><a href="#如何查看用户密码具体过期时间" class="headerlink" title="如何查看用户密码具体过期时间"></a>如何查看用户密码具体过期时间</h4><p>在 Linux 系统中，可以使用以下命令查看用户密码的具体过期时间：</p>
<ul>
<li>**chage -l <username>**：该命令可以查看指定用户的密码过期时间，以及密码最近一次修改的时间、密码失效时间等。</li>
</ul>
<p>例如，要查看用户名为 <strong>user1</strong> 的用户的密码具体过期时间，可以使用以下命令：</p>
<div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">Copy</span> <span class="hljs-meta">code</span>
<span class="hljs-symbol">chage</span> -l user1</code></pre></div>
<p>该命令将输出类似以下内容的信息：</p>
<div class="code-wrapper"><pre><code class="hljs pgsql">yamlCopy code
Last <span class="hljs-keyword">password</span> change                                 : Mar <span class="hljs-number">18</span>, <span class="hljs-number">2023</span> <span class="hljs-keyword">Password</span> expires                                     : never <span class="hljs-keyword">Password</span> inactive                                    : never Account expires                                      : never Minimum number <span class="hljs-keyword">of</span> days <span class="hljs-keyword">between</span> <span class="hljs-keyword">password</span> change       : <span class="hljs-number">0</span> Maximum number <span class="hljs-keyword">of</span> days <span class="hljs-keyword">between</span> <span class="hljs-keyword">password</span> change       : <span class="hljs-number">99999</span> Number <span class="hljs-keyword">of</span> days <span class="hljs-keyword">of</span> <span class="hljs-built_in">warning</span> <span class="hljs-keyword">before</span> <span class="hljs-keyword">password</span> expires    : <span class="hljs-number">7</span></code></pre></div>
<p>其中，各字段的含义如下：</p>
<ul>
<li><strong>Last password change</strong>：表示密码最近一次修改的时间。</li>
<li><strong>Password expires</strong>：表示密码的过期时间。如果该字段的值为 <strong>never</strong>，则表示密码永不过期。</li>
<li><strong>Password inactive</strong>：表示密码失效的时间。如果该字段的值为 <strong>never</strong>，则表示密码永不失效。</li>
<li><strong>Account expires</strong>：表示用户账户的过期时间。如果该字段的值为 <strong>never</strong>，则表示账户永不过期。</li>
<li><strong>Minimum number of days between password change</strong>：表示两次修改密码之间必须等待的最短时间，单位为天数。如果该字段的值为 <strong>0</strong>，则表示不设置等待时间。</li>
<li><strong>Maximum number of days between password change</strong>：表示两次修改密码之间必须等待的最长时间，单位为天数。如果该字段的值为 <strong>99999</strong>，则表示密码不会过期。</li>
<li><strong>Number of days of warning before password expires</strong>：表示密码过期前的警告期，单位为天数。在密码过期前，系统会给用户发送警告通知。</li>
</ul>
<p>如果要查看所有用户的密码过期时间，可以使用以下命令：</p>
<div class="code-wrapper"><pre><code class="hljs css">pythonCopy <span class="hljs-selector-tag">code</span>
sudo chage -l <span class="hljs-attr">--all-users</span></code></pre></div>
<p>该命令将输出系统中所有用户的密码过期时间信息。<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/97931380">U盘格式化后容量变小了怎么恢复</a></p>
<h4 id="yum源的配置和安装"><a href="#yum源的配置和安装" class="headerlink" title="yum源的配置和安装:"></a>yum源的配置和安装:</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/KingveyLee/article/details/114981036">RedHat7配置本地yum源（超详细过程）_redhat7 yum源配置_KingveyLee的博客-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gaoBlog/p/10944138.html">深入理解yum工作原理 - 豁然高 - 博客园</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/guohaosun/article/details/81481848">YUM工作原理及使用_$releaserver_Galaxy_hao的博客-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.51cto.com/silian20122/1791447">刨根问底：什么是yum源,yum的工作原理又是什么_51CTO博客_linux的yum源是什么</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/CenCenNA/article/details/102748845">linux配置本地yum源及网络yum源详细步骤_CEnCenNA的博客-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/KingveyLee/article/details/114981036">RedHat7配置本地yum源（超详细过程）_redhat7 yum源配置_KingveyLee的博客-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43596002/article/details/104567426">红帽上安装wireshark_雕沙的博客-CSDN博客</a></p>
<h2 id="磁盘创建问题："><a href="#磁盘创建问题：" class="headerlink" title="磁盘创建问题："></a>磁盘创建问题：</h2><h4 id="mke2fs-1-42-9-28-Dec-2013"><a href="#mke2fs-1-42-9-28-Dec-2013" class="headerlink" title="mke2fs 1.42.9 (28-Dec-2013)"></a>mke2fs 1.42.9 (28-Dec-2013)</h4><p>&#x2F;dev&#x2F;sdc1 is apparently in use by the system; will not make a 文件系统 here!<br>这个错误信息通常是因为你正在尝试创建一个文件系统，但该设备当前正在被系统使用，因此无法进行操作。这可能是因为该设备已经被挂载或正在被其他进程使用。<br>要解决这个问题，你可以尝试以下步骤：</p>
<ol>
<li>确认设备是否已经挂载：可以使用命令 mount 来查看设备是否已经挂载。如果设备已经挂载，请卸载设备并重试。</li>
<li>检查是否有其他进程使用该设备：有时，其他进程可能会占用该设备，例如正在进行备份或复制操作。可以使用命令 lsof &#x2F;dev&#x2F;sdc1 来查看哪些进程正在使用该设备。如果有进程使用该设备，请停止该进程并重试。</li>
<li>确认设备是否正确连接：有时设备连接不良会导致系统无法正确识别设备。可以尝试重新连接设备并重试。</li>
<li>如果上述方法都无法解决问题，可以尝试重启系统并重试创建文件系统的操作。</li>
</ol>
<p>总之，要解决设备正在被系统使用的问题，需要先确认设备是否已经被挂载或被其他进程使用，并采取相应的措施来停止这些进程或卸载设备。如果问题仍然存在，可以尝试重新连接设备或重启系统。</p>
<h4 id="echo-“-dev-sdb1-swap-ext3-defaults-0-0-“-etc-fstab"><a href="#echo-“-dev-sdb1-swap-ext3-defaults-0-0-“-etc-fstab" class="headerlink" title="echo “ &#x2F;dev&#x2F;sdb1 &#x2F;swap ext3 defaults 0 0 “ &gt; &#x2F;etc&#x2F;fstab"></a>echo “ &#x2F;dev&#x2F;sdb1 &#x2F;swap ext3 defaults 0 0 “ &gt; &#x2F;etc&#x2F;fstab</h4><p>为什么这样操作后原理的&#x2F;etc&#x2F;fstab的信息没了<br>这个命令会将一行文本（&#x2F;dev&#x2F;sdb1 &#x2F;swap ext3 defaults 0 0）写入 &#x2F;etc&#x2F;fstab 文件中，覆盖原有的内容。如果你只写入了这一行文本，则 &#x2F;etc&#x2F;fstab 文件的其他内容将被清除掉，只剩下这一行新的内容。<br>如果你想保留 &#x2F;etc&#x2F;fstab 文件中原有的内容，可以使用重定向运算符 &gt;&gt; 来将新的内容追加到文件末尾，而不是覆盖原有的内容。例如，可以使用以下命令向 &#x2F;etc&#x2F;fstab 文件中添加新的一行内容：<br>echo “&#x2F;dev&#x2F;sdb1 &#x2F;swap ext3 defaults 0 0” &gt;&gt; &#x2F;etc&#x2F;fstab<br>这将在 &#x2F;etc&#x2F;fstab 文件的末尾添加一行新的内容，而不会覆盖原有的内容。</p>
<h4 id="dev-sdb1-UUID-”f812f15f-e1c1-4c5c-a02e-503fadcf3873”-SEC-TYPE-”ext2”-TYPE-”ext3”"><a href="#dev-sdb1-UUID-”f812f15f-e1c1-4c5c-a02e-503fadcf3873”-SEC-TYPE-”ext2”-TYPE-”ext3”" class="headerlink" title="&#x2F;dev&#x2F;sdb1: UUID&#x3D;”f812f15f-e1c1-4c5c-a02e-503fadcf3873” SEC_TYPE&#x3D;”ext2” TYPE&#x3D;”ext3”"></a>&#x2F;dev&#x2F;sdb1: UUID&#x3D;”f812f15f-e1c1-4c5c-a02e-503fadcf3873” SEC_TYPE&#x3D;”ext2” TYPE&#x3D;”ext3”</h4><p>其中的type和sec_type是什么？<br>TYPE 和 SEC_TYPE 都是文件系统类型的标识符，用于指定文件系统的类型和安全属性。</p>
<ul>
<li>TYPE 标识符指定文件系统的类型，表示文件系统的格式和结构。在你的例子中，TYPE&#x3D;”ext3” 表示该设备使用的是 ext3 文件系统。常见的文件系统类型还包括 ext4、NTFS、FAT32 等。</li>
<li>SEC_TYPE 标识符指定文件系统的安全属性，表示文件系统的安全级别和访问控制。在你的例子中，SEC_TYPE&#x3D;”ext2” 表示该设备的安全属性与 ext2 文件系统相同。SEC_TYPE 通常用于启用文件系统的 SELinux 安全策略。</li>
</ul>
<p>这些标识符通常由操作系统自动识别和设置，但也可以手动指定。在 &#x2F;etc&#x2F;fstab 中，你可以使用 type 和 sec_type 选项来指定文件系统的类型和安全属性。例如：<br>&#x2F;dev&#x2F;sdb1 &#x2F;mnt&#x2F;data ext4 defaults,type&#x3D;ext4,sec_type&#x3D;ext2 0 0<br>这将将 &#x2F;dev&#x2F;sdb1 设备挂载到 &#x2F;mnt&#x2F;data 目录，使用 ext4 文件系统，并指定类型为 ext4，安全属性为 ext2。<br>dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;swap&#x2F;back.swap bs&#x3D;1M count&#x3D;256这句话是什么意思<br>这句命令的作用是在文件系统中创建一个大小为256MB的文件 &#x2F;swap&#x2F;back.swap，其中内容全部由0填充，相当于创建了一个空文件。<br>具体解释如下：</p>
<ul>
<li>dd 命令是一个复制命令，可以用来复制文件、设备或者数据流。</li>
<li>if&#x3D;&#x2F;dev&#x2F;zero 表示输入文件是 &#x2F;dev&#x2F;zero，这是一个特殊的文件，它会不断输出0。</li>
<li>of&#x3D;&#x2F;swap&#x2F;back.swap 表示输出文件是 &#x2F;swap&#x2F;back.swap，即创建一个名为 back.swap 的文件。</li>
<li>bs&#x3D;1M 表示每次读写的块大小为1MB，这样可以提高数据传输速度。</li>
<li>count&#x3D;256 表示复制256个块，即总共复制256MB的数据。因为每个块的大小为1MB，所以总文件大小为256MB。</li>
</ul>
<p>因此，这句命令的作用是在 &#x2F;swap 目录下创建一个名为 back.swap 的文件，大小为256MB，用于作为交换分区。这个文件的内容全部由0填充，因为交换分区是用来存储内存中暂时不需要的数据，所以里面的内容可以是任意的。<br>&#x2F;swap&#x2F;back.swap none swap sw 0 0这个是什么意思<br>这是一条用于描述交换分区的 &#x2F;etc&#x2F;fstab 文件中的行。具体解释如下：</p>
<ul>
<li>&#x2F;swap&#x2F;back.swap 表示交换分区所在的文件路径。</li>
<li>none 表示该交换分区没有对应的磁盘分区，而是使用一个文件来模拟交换分区。</li>
<li>swap 表示文件系统类型为交换分区。</li>
<li>sw 表示挂载选项，其中 sw 表示启用交换分区。</li>
<li>0 和 0 是用于指定文件系统检查时的参数，分别表示在启动时不检查该文件系统，并且不进行备份。</li>
</ul>
<p>这条 &#x2F;etc&#x2F;fstab 文件中的行的作用是将 &#x2F;swap&#x2F;back.swap 文件作为交换分区挂载到系统中，并在系统启动时自动加载该交换分区。</p>
<h4 id="如何查看交换分区"><a href="#如何查看交换分区" class="headerlink" title="如何查看交换分区"></a>如何查看交换分区</h4><p>你可以使用 swapon 命令来查看当前系统中已经启用的交换分区。具体操作如下：</p>
<ol>
<li>打开终端，在命令行中输入以下命令：swapon –show 这会列出系统中所有已经启用的交换分区的信息，包括文件名、类型、大小等。</li>
<li>如果你只想查看某一个交换分区的信息，可以在命令后面加上交换分区的路径，例如：swapon –show &#x2F;swap&#x2F;back.swap 这会仅显示名为 &#x2F;swap&#x2F;back.swap 的交换分区的信息。</li>
</ol>
<p>另外，你也可以使用 free 命令来查看系统的内存和交换分区使用情况。在终端中输入以下命令：<br>free -h<br>这会显示系统中的内存和交换分区的使用情况，包括已用、可用和总大小等信息。<br>&#x2F;dev&#x2F;sdb2 swap swap defaults 0 0什么意思这是 &#x2F;etc&#x2F;fstab 文件中一行用于定义交换分区的条目，具体解释如下：</p>
<ul>
<li>&#x2F;dev&#x2F;sdb2 表示交换分区所对应的磁盘设备或文件的路径。在这个例子中，交换分区对应的是 &#x2F;dev&#x2F;sdb2 设备。</li>
<li>swap 表示文件系统的类型为交换分区。</li>
<li>swap 表示挂载点的名称，也就是交换分区的标识符。</li>
<li>defaults 表示挂载选项，其中包含了一些默认的选项，比如读写权限、文件系统检查等。</li>
<li>0 和 0 是用于指定文件系统检查时的参数，分别表示在启动时不检查该文件系统，并且不进行备份。</li>
</ul>
<p>因此，这条条目的作用是将 &#x2F;dev&#x2F;sdb2 设备上的交换分区挂载到系统中，并在系统启动时自动加载该交换分区。<br>&#x2F;swap&#x2F;back.swap none swap sw 0 0那这个了？这是 &#x2F;etc&#x2F;fstab 文件中另一行用于定义交换分区的条目，具体解释如下：</p>
<ul>
<li>&#x2F;swap&#x2F;back.swap 表示交换分区所对应的文件的路径。在这个例子中，交换分区对应的是 &#x2F;swap&#x2F;back.swap 文件。</li>
<li>none 表示该交换分区没有对应的磁盘分区，而是使用一个文件来模拟交换分区。</li>
<li>swap 表示文件系统的类型为交换分区。</li>
<li>sw 表示挂载选项，其中 sw 表示启用交换分区。</li>
<li>0 和 0 是用于指定文件系统检查时的参数，分别表示在启动时不检查该文件系统，并且不进行备份。</li>
</ul>
<p>因此，这条条目的作用是将 &#x2F;swap&#x2F;back.swap 文件作为交换分区挂载到系统中，并在系统启动时自动加载该交换分区。<br>&#x2F;dev&#x2F;sdb2 swap swap defaults 0 0写入&#x2F;etc&#x2F;fstab会马上生效吗？<br>sudo mount -a sudo swapon -a<br>在将交换分区的信息写入 &#x2F;etc&#x2F;fstab 文件后，需要手动执行以下命令才能使其生效：<br>这个命令会将 &#x2F;etc&#x2F;fstab 文件中定义的所有文件系统挂载到系统中。如果没有出现错误，那么交换分区就已经成功地挂载到了系统中。也可以使用以下命令单独挂载交换分区：<br>这个命令会启用 &#x2F;etc&#x2F;fstab 文件中定义的所有交换分区，包括新添加的交换分区。如果想要禁用某个交换分区，可以使用 swapoff 命令。<br>将网卡(eth0)配置成ip地址为192.168.1.13同时激活此网卡的命令是<br>sudo ifconfig eth0 192.168.1.13 up sudo ip addr add 192.168.1.13&#x2F;24 dev eth0 sudo ip link set eth0 up<br>可以使用以下命令将网卡 eth0 配置为 IP 地址为 192.168.1.13，并激活该网卡：<br>这个命令会使用 ifconfig 工具来配置网卡 eth0 的 IP 地址，将其设置为 192.168.1.13，并激活该网卡。如果 eth0 网卡已经被配置过 IP 地址，那么这个命令会更新该网卡的 IP 地址。<br>请注意，ifconfig 命令已经被弃用，建议使用 ip 命令来管理网络接口。使用 ip 命令来配置网卡 eth0 的 IP 地址和激活该网卡的命令如下：<br>这个命令会使用 ip 命令来配置网卡 eth0 的 IP 地址，将其设置为 192.168.1.13，并激活该网卡。如果 eth0 网卡已经被配置过 IP 地址，那么这个命令会更新该网卡的 IP 地址。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_53946852/article/details/125542849">Linux进程和进程优先级（top+ps+kill+renice+df+free命令）_linux查看进程优先级命令_爱敲代码的三毛的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yxd1308243944/p/13920434.html">Linux Sever简单笔记（第十堂课）之linux下的任务计划及相关的命令 - 我杨晓东太难了 - 博客园</a><br> <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ea566208dca6">FTP server vsftpd配置文件详解</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Linux/" class="category-chain-item">Linux</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Linux/" class="print-no-link">#Linux</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Linux学习札记</div>
      <div>http://www.bojiboqi.fun/2024/01/26/Linux学习扎记：/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>山麋一笑</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年1月26日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/01/26/shell%E7%BC%96%E7%A8%8B%EF%BC%88ubuntu%EF%BC%89%EF%BC%9A/" title="shell编程">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">shell编程</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/01/26/Linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0_/" title="Linux期末复习">
                        <span class="hidden-mobile">Linux期末复习</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"NkSNF5NG3Uup8tDgwIfBlJ9d-gzGzoHsz","appKey":"Y2GZN9C0SLdOpVG4hMb1TEJM","path":"window.location.pathname","placeholder":"如有错误还望指正","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://nksnf5ng.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":true},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
  



</div>



  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="/js/DynamicLine.js"></script>
<script src="/js/custom.js"></script>
<script src="/js/yinhua.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>

<!-- hexo injector body_end start --><script src="/js/backgroundize.js"></script>
  <link defer rel="stylesheet" href="/css/backgroundize.css" />
  <!-- hexo injector body_end end --></body>
</html>
