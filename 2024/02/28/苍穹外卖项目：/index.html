<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>苍穹外卖项目： | 山麋一笑</title><meta name="author" content="山麋一笑"><meta name="copyright" content="山麋一笑"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="登录和相关的CRUD: Nginx教程_54笨鸟Nginx 从入门到实践，万字详解！_nginx_前端下午茶_InfoQ写作社区  相关概念:  12345678910111.DTO是数据传输对象是一种用于封装数据并将其从应用程序的一个子系统发送到另一个子系统的对象。2.N 层应用程序中的服务层最常使用 DTO 在其自身和 UI 层之间传输数据。这里的主要好处是它减少了分布式应用程序中需要通过线">
<meta property="og:type" content="article">
<meta property="og:title" content="苍穹外卖项目：">
<meta property="og:url" content="http://www.bojiboqi.fun/2024/02/28/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%EF%BC%9A/index.html">
<meta property="og:site_name" content="山麋一笑">
<meta property="og:description" content="登录和相关的CRUD: Nginx教程_54笨鸟Nginx 从入门到实践，万字详解！_nginx_前端下午茶_InfoQ写作社区  相关概念:  12345678910111.DTO是数据传输对象是一种用于封装数据并将其从应用程序的一个子系统发送到另一个子系统的对象。2.N 层应用程序中的服务层最常使用 DTO 在其自身和 UI 层之间传输数据。这里的主要好处是它减少了分布式应用程序中需要通过线">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.bojiboqi.fun/img/wakawaka/photo_2024-02-28_10-44-54.webp">
<meta property="article:published_time" content="2024-02-28T13:02:28.484Z">
<meta property="article:modified_time" content="2024-04-09T04:01:41.400Z">
<meta property="article:author" content="山麋一笑">
<meta property="article:tag" content="项目">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.bojiboqi.fun/img/wakawaka/photo_2024-02-28_10-44-54.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.bojiboqi.fun/2024/02/28/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%EF%BC%9A/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '苍穹外卖项目：',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-09 12:01:41'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/transpancy.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="山麋一笑" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg" style="background:url(/img/wakawaka/photo_2024-02-28_10-44-54.webp);background-attachment: local;background-position: center;background-size: cover;background-repeat: no-repeat;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/images/1.webp" data-lazy-src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">74</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-list"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/wakawaka/photo_2024-02-28_10-44-54.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="山麋一笑"><span class="site-name">山麋一笑</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-list"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">苍穹外卖项目：</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-28T13:02:28.484Z" title="发表于 2024-02-28 21:02:28">2024-02-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-09T04:01:41.400Z" title="更新于 2024-04-09 12:01:41">2024-04-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="苍穹外卖项目："><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a name="eWQhc"></a></p>
<h2 id="登录和相关的CRUD">登录和相关的CRUD:</h2>
<p><a target="_blank" rel="noopener" href="https://www.54benniao.com/nginx/">Nginx教程_54笨鸟</a><br /><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/2051e9a2e76e80393353d826a">Nginx 从入门到实践，万字详解！_nginx_前端下午茶_InfoQ写作社区</a><br>
<a name="X9t4g"></a></p>
<h4 id="相关概念">相关概念:</h4>
<p><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696409163321-2cc73f8c-954d-43e5-9054-a61e380237c1.png#averageHue=%23e0ccd5&amp;clientId=uf56011de-eac3-4&amp;from=paste&amp;height=143&amp;id=u67c7cf82&amp;originHeight=179&amp;originWidth=574&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=76437&amp;status=done&amp;style=none&amp;taskId=uc0d357a1-e23a-4b5f-bf87-bcd2e713d04&amp;title=&amp;width=459.2" alt="image.png"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="selector-class">.DTO</span>是数据传输对象是一种用于封装数据并将其从应用程序的一个子系统发送到另一个子系统的对象。</span><br><span class="line"><span class="number">2</span><span class="selector-class">.N</span> 层应用程序中的服务层最常使用 DTO 在其自身和 UI 层之间传输数据。这里的主要好处是它减少了分布式</span><br><span class="line">应用程序中需要通过线路发送的数据量。他们还在 MVC 模式中制作了很棒的模型。</span><br><span class="line"><span class="number">3</span><span class="selector-class">.DTO</span> 的另一个用途是封装方法调用的参数。如果方法采用四个或五个以上参数（把这些参数封装为一个DTO对象），</span><br><span class="line">这可能很有用。java这种单值返回对象，可以将多个不同的对象封装在一个DTO对象里面，然后返回该对象，</span><br><span class="line">并把该对象传递给其他应用程序。</span><br><span class="line"><span class="number">4</span><span class="selector-class">.DTO</span>类型的对象, 不应该掺杂任何业务逻辑; 只包含获取和设置属性的方法, 以及用于序列化或反序列化</span><br><span class="line">的解析器。</span><br><span class="line"><span class="number">5</span>.如果想从数据库传输一些信息，但其中包含一些敏感信息，那么我们可以使用 DTO，只传输必要的信息。</span><br><span class="line"><span class="number">6</span><span class="selector-class">.DTO</span>的好处之一：用于在服务器和客户端进程通信的时候，可以一次性传递更多的信息。节省了通信成本</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.是表现层状态转换，</span><br><span class="line"><span class="number">2</span><span class="selector-class">.REST</span> API通过使用HTTP协议中的不同方法（如GET、POST、PUT、DELETE等）来对资源进行操作。</span><br><span class="line"><span class="number">3</span>.以下是<span class="attribute">REST</span> API的一些关键特点：</span><br><span class="line"></span><br><span class="line">资源（Resources）：<span class="attribute">REST</span> API通过URL（统一资源定位符）来表示资源。每个资源都有唯一的URL，用于</span><br><span class="line">标识和访问该资源。例如，/users可以表示用户资源。</span><br><span class="line"></span><br><span class="line">HTTP方法（HTTP Methods）：<span class="attribute">REST</span> API使用HTTP协议的不同方法来表示对资源的操作。常用的方法包括</span><br><span class="line">GET（获取资源）、POST（创建资源）、PUT（更新资源）和DELETE（删除资源）等。</span><br><span class="line"></span><br><span class="line">状态无关性（Statelessness）：<span class="attribute">REST</span> API是无状态的，意味着每个请求应该包含足够的信息来理解和处理</span><br><span class="line">该请求，而不依赖于之前的请求。服务器不会保留客户端的状态，每个请求都是独立的。</span><br><span class="line"></span><br><span class="line">表征性（Representation）：<span class="attribute">REST</span> API使用不同的表示形式来传输资源的状态。常见的表示形式包括JSON</span><br><span class="line">（JavaScript <span class="selector-tag">Object</span> Notation）和XML（eXtensible Markup Language）等。</span><br><span class="line"></span><br><span class="line">超媒体驱动（HATEOAS）：<span class="attribute">REST</span> API可以通过在响应中提供超媒体链接来支持自描述性。这些链接可以指导</span><br><span class="line">客户端在资源之间进行导航和操作。</span><br><span class="line"></span><br><span class="line">通过使用<span class="attribute">REST</span> API，客户端可以通过发送HTTP请求来与服务器进行通信，并执行对资源的操作。服务器根据</span><br><span class="line">请求的方法和URL来确定要执行的操作，并返回相应的响应。</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-tw/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2">REST</a><br />VO:展示用的数据，会更加业务要求把DTO的数据进行删除和业务解释。<br />PO：PO就是数据库中的记录<br />BO：多个PO组成的业务对象<br />DAO：通常是一个接口或类，用来操作数据库的<br /><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/webp/28066124/1696409881882-187b1730-bbee-4628-8a80-b0bb2896274c.webp#averageHue=%23ebebeb&amp;clientId=uf56011de-eac3-4&amp;from=paste&amp;id=u5e94b9ef&amp;originHeight=843&amp;originWidth=603&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u13e32b46-1e8a-4c98-b2a5-3d3cd0ef7a0&amp;title=" alt=""><br />Java 8 Streams ：<br /><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903830254010381">[译] 一文带你玩转 Java8 Stream 流，从此操作集合 So Easy - 掘金</a><br /><a target="_blank" rel="noopener" href="https://www.exception.site/java8/java8-new-features">Java8 新特性教程 - 异常教程</a><br /><a target="_blank" rel="noopener" href="https://blog.csdn.net/bluuusea/article/details/79967039">JAVA8新特性–集合流操作Stream_stream().maptolong-CSDN博客</a></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;String&gt; myList =</span><br><span class="line">                Arrays<span class="selector-class">.asList</span>(&quot;a1&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;c2&quot;, &quot;c1&quot;);</span><br><span class="line"></span><br><span class="line">        myList</span><br><span class="line">                <span class="selector-class">.stream</span>() // 创建流</span><br><span class="line">                <span class="selector-class">.filter</span>(s -&gt; s<span class="selector-class">.startsWith</span>(&quot;c&quot;)) // 执行过滤，过滤出以 c 为前缀的字符串</span><br><span class="line">                <span class="selector-class">.map</span>(String::toUpperCase) // 转换成大写</span><br><span class="line">                .<span class="built_in">sorted</span>() // 排序</span><br><span class="line">                .<span class="built_in">forEach</span>(System.out::println); // for 循环打印</span><br><span class="line"></span><br><span class="line">// C1</span><br><span class="line">// C2</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xuwenjin/p/8830850.html">JPA之@Entity、@Table、@Column、@Id - 仅此而已-远方 - 博客园</a><br />@Enity是将该对象和数据库的表联系起来（类名是表名的驼峰转换，eg：<strong>@Entity</strong> 表明该类 (UserEntity) 为一个实体类，它默认对应数据库中的表名是user_entity。），@Table是当@Enity注解的对象和数据库的表名不匹配的时候手动添加其对象联系的表。<br />@Mapper注解详解：   <br /><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012060033/article/details/128040322">Mapper层注解讲解_爱吃牛肉的大老虎的博客-CSDN博客</a></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="keyword">@Mapper</span>: 这个注解一般使用在Dao层接口上，它的作用就是将接口生成一个动态代理类。</span><br><span class="line">使用@mapper后，不需要在spring配置中设置扫描地址，通过mapper.xml里面的namespace属性对应相关的</span><br><span class="line">mapper类，spring将动态的生成Bean后注入到ServiceImpl中。@Mapper注解写在每个Dao接口层的接口类上，@MapperScan注解写在SpringBoot的启动类上。</span><br><span class="line"></span><br><span class="line">当我们的一个项目中存在多个Dao层接口的时候，此时我们需要对每个接口类都写上</span><br><span class="line">@Mapper注解，非常的麻烦，此时可以使用@MapperScan注解来解决这个问题。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>源码浅析：<br /><a target="_blank" rel="noopener" href="https://blog.csdn.net/a23452/article/details/122353919">框架技术 — Mybatis动态_object.class.equals(method.getdeclaringclass()_码农C风的博客-CSDN博客</a><br />1.Mybatis会利用动态代理生成一个Dao接口的实例并注入到容器中，不需要自己创建对象了。而查询数据库的操作是通过SqlSession接口实现的。<br />JWT是在客户端发送登录信息，判断登录成功后在返回token.<br />JWT生成toke的方式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">            // 设置过期时间，System<span class="selector-class">.currentTimeMillis</span>() 是 Java 中的一个静态方法，</span><br><span class="line">  //它返回当前系统时间的毫秒数，也称为时间戳;java中的Date对象本身的构造方法传递的是一个</span><br><span class="line">  //long的数值，它表示Date对象存储的是一个long形的时间戳，它的toring方法会将它转化为字符串</span><br><span class="line">  //格式的日期。	</span><br><span class="line">            Date date = new Date(System<span class="selector-class">.currentTimeMillis</span>() + EXPIRE_TIME);</span><br><span class="line">            // 私钥和加密算法</span><br><span class="line">            Algorithm algorithm = Algorithm<span class="selector-class">.HMAC256</span>(TOKEN_SECRET);</span><br><span class="line">            // 设置头部信息</span><br><span class="line">            Map&lt;String, <span class="selector-tag">Object</span>&gt; <span class="selector-tag">header</span> = new HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">            <span class="selector-tag">header</span><span class="selector-class">.put</span>(&quot;Type&quot;, &quot;Jwt&quot;);</span><br><span class="line">            <span class="selector-tag">header</span><span class="selector-class">.put</span>(&quot;alg&quot;, &quot;HS256&quot;);</span><br><span class="line">            // 返回token字符串</span><br><span class="line">            return JWT<span class="selector-class">.create</span>()</span><br><span class="line">                    <span class="selector-class">.withHeader</span>(<span class="selector-tag">header</span>)</span><br><span class="line">                    <span class="selector-class">.withClaim</span>(&quot;loginName&quot;, username)</span><br><span class="line">                    <span class="selector-class">.withClaim</span>(&quot;loginTime&quot;, loginTime)</span><br><span class="line">                    <span class="selector-class">.withExpiresAt</span>(date)</span><br><span class="line">                    <span class="selector-class">.sign</span>(algorithm);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e<span class="selector-class">.printStackTrace</span>();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  // 设置过期时间为 <span class="number">1</span> 天</span><br><span class="line">        long expirationTime = System<span class="selector-class">.currentTimeMillis</span>() + <span class="number">86400000</span>;</span><br><span class="line">//</span><br><span class="line">        String token = Jwts<span class="selector-class">.builder</span>()</span><br><span class="line">                <span class="selector-class">.setSubject</span>(&quot;user123&quot;) // 设置 subject</span><br><span class="line">                <span class="selector-class">.setExpiration</span>(new Date(expirationTime)) // 设置过期时间</span><br><span class="line">                <span class="selector-class">.signWith</span>(SignatureAlgorithm<span class="selector-class">.HS256</span>, &quot;secret&quot;) // 设置签名</span><br><span class="line">                <span class="selector-class">.compact</span>();//构建并获取最终的 JWT 字符串,没有这一步返回的是一个 JwtBuilder 对象</span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(token);</span><br><span class="line"></span><br><span class="line">//上面也可以使用setClaims(claims)方法设置playload</span><br></pre></td></tr></table></figure>
<p>上面2种生成token的方式不一样，一个使用Jwt生成token一个使用Jwts生成token，也就是使用生成jwt的库不一样，导入的依赖不一样。第一个是使用Auth0 java-jwt库生成的，第二个是使用JJWT库生成的。<br /><a target="_blank" rel="noopener" href="https://howtodoinjava.com/java/java-security/jwt-json-web-token/">JWTS</a><br /><a target="_blank" rel="noopener" href="https://www.baeldung.com/java-auth0-jwt">Managing JWT With Auth0 java-jwt | Baeldung</a></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    com:</span><br><span class="line">      sky:</span><br><span class="line">        mapper: debug</span><br><span class="line">        service: info</span><br><span class="line">        controller: info</span><br><span class="line">//上面的代码分别是设置com包下的sky下的mapper和service和controller个包的日志级别</span><br></pre></td></tr></table></figure>
<p>@<strong>RestControllerAdvice：</strong><br />    @RestControllerAdvice是一个组合注解，由@ControllerAdvice、@ResponseBody等组成。其作用是将控制层的全局的错误俘获，然后将返回结果写进返回体中。@ExceptionHandler(value = Exception.class) ExceptionHandler的作用是用来捕获指定的异常，其中的value指定当某种异常发送后做什么处理，该注解常标记在方法上，标记的方法代表对某一具体的异常进行处理。当有多个@ExceptionHandler注解标识的类时，对于异常的处理是就近原则（优先按照该异常的类，没有找到就按照最近的父类处理）。<a target="_blank" rel="noopener" href="https://blog.csdn.net/lkforce/article/details/98494922">Spring的@ExceptionHandler注解使用方法-CSDN博客</a>该注解修饰的方法，如果在该注解之下方法之上添加，@ResponseBody<br /><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;mid=2247512022&amp;idx=3&amp;sn=bb53d67af6799b71eb57989d393d434a&amp;chksm=fa4ad067cd3d59713cde18ab64dc4230436c15a809c751e874e63c28b6d83cbaf71434c53d4d&amp;scene=27&amp;poc_token=HDqAHWWjGBUxJqZJSpKne8JW6U992SEqHHb-3r1d">看看人家 SpringBoot 的全局异常处理，多么优雅。。。</a><br />spring中的错误处理：<br /><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45503796/article/details/119246584">Springboot核心功能：高级特性、原理解析-CSDN博客</a><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696468145165-abe54739-e721-4a0c-aa86-ec31162c6239.png#averageHue=%23fefefe&amp;clientId=uf56011de-eac3-4&amp;from=paste&amp;height=427&amp;id=u2124a994&amp;originHeight=534&amp;originWidth=1001&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=215896&amp;status=done&amp;style=none&amp;taskId=u3dc7ddf4-1714-4e6e-930a-8ffc38e1700&amp;title=&amp;width=800.8" alt="image.png"><br /><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696468246891-8fa6fba4-b44b-4b1c-82b1-818c09f548da.png#averageHue=%23fcf8f2&amp;clientId=uf56011de-eac3-4&amp;from=paste&amp;height=406&amp;id=u118afe69&amp;originHeight=508&amp;originWidth=996&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=142930&amp;status=done&amp;style=none&amp;taskId=uaabf2c91-00c5-49e8-966d-455f8183295&amp;title=&amp;width=796.8" alt="image.png"><br /><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696468472665-e4d83cd9-5242-4894-8943-caa2a4064f56.png#averageHue=%23faf4e9&amp;clientId=uf56011de-eac3-4&amp;from=paste&amp;height=370&amp;id=ub8575eef&amp;originHeight=462&amp;originWidth=859&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=121041&amp;status=done&amp;style=none&amp;taskId=u07214a89-8913-47cd-96f8-69699b957db&amp;title=&amp;width=687.2" alt="image.png"><br /><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696468545858-89aff1c9-c410-44cf-aadb-a5edfad08949.png#averageHue=%23e7e8e9&amp;clientId=uf56011de-eac3-4&amp;from=paste&amp;height=276&amp;id=uace24f9f&amp;originHeight=345&amp;originWidth=829&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=157034&amp;status=done&amp;style=none&amp;taskId=u1ad5023a-9c95-4ed3-9507-325db630959&amp;title=&amp;width=663.2" alt="image.png"><br />springsecurity的复习：<br /><a target="_blank" rel="noopener" href="https://juejin.cn/post/6999952004990631949">Spring Security核心接口用户权限获取，鉴权流程执行原理｜8月更文挑战 - 掘金</a>（暂时还不是很理解）</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> //把result转成JSON</span><br><span class="line">        String json = objectMapper<span class="selector-class">.writeValueAsString</span>(result);</span><br><span class="line">        //响应出去</span><br><span class="line">        PrintWriter out = response<span class="selector-class">.getWriter</span>();</span><br><span class="line">        out<span class="selector-class">.write</span>(json);</span><br><span class="line">        out<span class="selector-class">.flush</span>();</span><br><span class="line">//上面的response<span class="selector-class">.getWriter</span>();指明了流要输出的对象是response里面，输入的是json字符串</span><br><span class="line">//输出流一般都是指明输出的地址的。</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Spring Security中的安全上下文（SecurityContext）是一个存储当前用户认证信息和权限信息的对象，</span><br><span class="line">它可以通过SecurityContextHolder类获取和设置。安全上下文的持续时间取决</span><br><span class="line">于SecurityContextHolder的策略和HttpSession的生命周期。</span><br><span class="line">SecurityContextHolder有三种策略，分别是：</span><br><span class="line"></span><br><span class="line">•  MODE_THREADLOCAL：这是默认的策略，它使用ThreadLocal来存储安全上下文，这意味着安全上下文只</span><br><span class="line">在当前线程中有效，当线程结束时，安全上下文也会消失。</span><br><span class="line">•  MODE_INHERITABLETHREADLOCAL：这种策略也使用ThreadLocal来存储安全上下文，</span><br><span class="line">但是它允许子线程继承父线程的安全上下文，这对于使用线程池的情况比较有用。</span><br><span class="line"></span><br><span class="line">•  MODE_GLOBAL：这种策略使用一个全局的变量来存储安全上下文，这意味着所有的线程都共享同一个</span><br><span class="line">安全上下文，这种策略很少使用，因为它可能导致数据混乱和安全风险。</span><br><span class="line">HttpSession是一个用于存储用户会话信息的对象，它可以在多个请求之间保持用户状态。</span><br><span class="line">HttpSession的持续时间取决于服务器的配置和客户端的行为，一般有以下几种情况：</span><br><span class="line"></span><br><span class="line">•  如果服务器设置了HttpSession的超时时间（timeout），那么当用户在一段时间内没有发起任何请求时，HttpSession会自动失效，安全上下文也会被清除。https://spring.io/projects/spring-security/</span><br><span class="line"></span><br><span class="line">•  如果用户主动退出登录或关闭浏览器，那么HttpSession会被销毁，安全上下文也会被清除</span><br><span class="line"></span><br><span class="line">•  如果用户在同一个浏览器中打开多个标签页或窗口访问同一个应用，那么它们会共享同一</span><br><span class="line">个HttpSession和安全上下文。</span><br><span class="line">•  如果用户在不同的浏览器或设备中访问同一个应用，那么它们会拥有不同的HttpSession</span><br><span class="line">和安全上下文。</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sheng0113/article/details/122712947">Java迭代器详解，看这一篇就够了-CSDN博客</a></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DigestUtils是spring提供的加密类，DigestUtils<span class="selector-class">.md5DigestAsHex</span>(password<span class="selector-class">.getBytes</span>());</span><br></pre></td></tr></table></figure>
<p>在IDEA中可以通过在注释中添加TODO来标识待完善的部分。可以点击左下角的TODO来快速定位TODO的位置。<br /><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696484149698-36a5f1a3-e706-4970-a632-6b942e003334.png#averageHue=%23fcfaf9&amp;clientId=ua374d035-53e1-4&amp;from=paste&amp;height=333&amp;id=u69887b62&amp;originHeight=416&amp;originWidth=733&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=80915&amp;status=done&amp;style=none&amp;taskId=u388ed148-fca9-4b52-a028-f42c138b3b6&amp;title=&amp;width=586.4" alt="image.png"><br />Swagger:<br /><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696484636385-8e226c29-29cf-4c87-af60-71f5ad2671ed.png#averageHue=%23fcfaf6&amp;clientId=ua374d035-53e1-4&amp;from=paste&amp;height=304&amp;id=u88ff5e7b&amp;originHeight=380&amp;originWidth=984&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=134543&amp;status=done&amp;style=none&amp;taskId=u23493cee-f634-4219-acd2-6e860b58e88&amp;title=&amp;width=787.2" alt="image.png"><br />springboot2和springboot3中swaager导入的版本不同<br /><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696485481258-17f092d0-ef2b-490b-b6ba-1dd4cf26831f.png#averageHue=%23f8f0e2&amp;clientId=ua374d035-53e1-4&amp;from=paste&amp;height=267&amp;id=u0819f7ac&amp;originHeight=334&amp;originWidth=802&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=135270&amp;status=done&amp;style=none&amp;taskId=u30768b4e-de18-4032-95b9-f65dcec97e9&amp;title=&amp;width=641.6" alt="image.png"><br /><a target="_blank" rel="noopener" href="https://doc.xiaominfo.com/docs/quick-start">快速开始 | Knife4j</a><br /><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696487431526-e530cba7-6a71-4b22-9905-e9f9e6e5651b.png#averageHue=%2372805d&amp;clientId=ua374d035-53e1-4&amp;from=paste&amp;height=242&amp;id=u3d20006f&amp;originHeight=302&amp;originWidth=1366&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=330870&amp;status=done&amp;style=none&amp;taskId=u42d64647-10a0-4913-832e-fede2183a10&amp;title=&amp;width=1092.8" alt="image.png"><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696487700354-5ef5e3a5-1629-4909-807b-815c05d3c041.png#averageHue=%23f2f1f2&amp;clientId=ua374d035-53e1-4&amp;from=paste&amp;height=436&amp;id=u13a6538a&amp;originHeight=545&amp;originWidth=1511&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=352888&amp;status=done&amp;style=none&amp;taskId=uf3c8f14b-356d-4196-9a2a-397b55b3002&amp;title=&amp;width=1208.8" alt="image.png"><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696488049625-cd8d61ba-8624-4d82-97a0-8460650eff87.png#averageHue=%2393a4a6&amp;clientId=ua374d035-53e1-4&amp;from=paste&amp;height=341&amp;id=u8d495c29&amp;originHeight=426&amp;originWidth=935&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=94680&amp;status=done&amp;style=none&amp;taskId=u758aeb31-a544-4578-bb3c-812aa615abc&amp;title=&amp;width=748" alt="image.png"><br />BeanUtils.<em>copyProperties</em>(employeeDTO, employee);是将employeeDTO该对象的相关属性赋值给employee.<br /><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696496769542-58321bd5-e845-474c-8c2e-3a1994bc0430.png#averageHue=%23627d66&amp;clientId=u44c118de-c29f-4&amp;from=paste&amp;height=238&amp;id=u013ef5b6&amp;originHeight=297&amp;originWidth=1414&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=361070&amp;status=done&amp;style=none&amp;taskId=u7fb9f95d-6840-43fa-8d7c-fc45215ffbf&amp;title=&amp;width=1131.2" alt="image.png"><br /><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696496875531-1d116105-5551-48ce-b42f-41328647ff30.png#averageHue=%23282c36&amp;clientId=u44c118de-c29f-4&amp;from=paste&amp;height=87&amp;id=u99745c08&amp;originHeight=109&amp;originWidth=860&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=75745&amp;status=done&amp;style=none&amp;taskId=u928d3187-8b81-4665-a22c-16e66a5ef91&amp;title=&amp;width=688" alt="image.png"><br />controller层注入service接口，service接口的实现类注入mapper接口类，并利用注入的接口类中的接口方法操作数据库。<br />IDEA实现修改Springboot项目后不用重新启动就可以看到更改：<br />1.导入依赖：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org<span class="selector-class">.springframework</span><span class="selector-class">.boot</span>&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>2.<img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696499235039-fd2c1235-8480-4e09-a91a-d79292f87937.png#averageHue=%233f444a&amp;clientId=u44c118de-c29f-4&amp;from=paste&amp;height=509&amp;id=u8fbec3b4&amp;originHeight=636&amp;originWidth=1292&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=239320&amp;status=done&amp;style=none&amp;taskId=u4575fa55-807c-4869-8130-b5a2d39145c&amp;title=&amp;width=1033.6" alt="image.png"><br />3.<img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696499245170-1573a9b7-1138-47cf-9cd2-b6a0a069bd30.png#averageHue=%233e4348&amp;clientId=u44c118de-c29f-4&amp;from=paste&amp;height=671&amp;id=u89514ab4&amp;originHeight=839&amp;originWidth=1286&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=271719&amp;status=done&amp;style=none&amp;taskId=ud5fe3661-0f8d-4d6a-ad76-d71083ba80e&amp;title=&amp;width=1028.8" alt="image.png"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spring-boot-devtools 是 Spring Boot 提供的一个开发工具模块，旨在提高开发人员的开发体验和生产力。它为开发人员提供了一些有用的功能，以加快应用程序的开发、调试和重新加载过程。</span><br><span class="line"></span><br><span class="line">以下是 spring-boot-devtools 提供的主要功能：</span><br><span class="line"></span><br><span class="line">自动应用程序重启：当你进行代码更改时，spring-boot-devtools 可以自动监测到变化，并自动重新启动应用程序，以便立即看到更改的效果，而无需手动停止和启动应用程序。</span><br><span class="line"></span><br><span class="line">自动重新加载：除了重启应用程序外，spring-boot-devtools 还支持许多类文件的自动重新加载，而无需重新启动整个应用程序。这对于一些轻量级的更改，如修改控制器、视图模板或静态资源文件等，可以更快地生效。</span><br><span class="line"></span><br><span class="line">禁用模板缓存：在开发阶段，模板引擎通常会对模板文件进行缓存，以提高性能。但这也会导致在更改模板文件后，你无法立即看到更改的效果。spring-boot-devtools 可以自动禁用模板缓存，以便在每次请求时都重新加载模板文件。</span><br><span class="line"></span><br><span class="line">静态资源自动更新：当你修改静态资源文件（如 CSS、JavaScript 或图片文件）时，spring-boot-devtools 可以自动检测到更改，并将其复制到应用程序的类路径中，以便立即生效。</span><br><span class="line"></span><br><span class="line">全局设置更改：spring-boot-devtools 还提供了一个 META-INF/spring-devtools<span class="selector-class">.properties</span> 文件，你可以在其中配置一些全局设置，如禁用某些特性或自定义重新加载的策略等。</span><br></pre></td></tr></table></figure>
<p><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696501056331-bef4cb36-255b-44af-ad86-b9a10ac62a3d.png#averageHue=%232a303b&amp;clientId=u44c118de-c29f-4&amp;from=paste&amp;height=313&amp;id=u23828f62&amp;originHeight=391&amp;originWidth=1148&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=357659&amp;status=done&amp;style=none&amp;taskId=u64c19e3e-8e81-4717-82b2-b4e0b46ca1a&amp;title=&amp;width=918.4" alt="image.png"></p>
<ol>
<li>@ConfigurationProperties 的 POJO类的命名比较严格,因为它必须和prefix的后缀名要一致, 不然值会绑定不上, 特殊的后缀名是“driver-class-name”这种带横杠的情况,在POJO里面的命名规则是 <strong>下划线转驼峰</strong> 就可以绑定成功，所以就是 “driverClassName”</li>
</ol>
<p>@ConfigurationProperties实现从配置文件自动注入对应的配置值到对应的Bean对象时所采取的绑定是宽松绑定（把中划线-、下划线_ 都去掉,且不区分大小写）但是prefix只能使用纯小写字母，数字，下划线。：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_45877477/article/details/125451975">SpringBoot松散绑定(宽松绑定)@ConfigurationProperties_spring boot 2.7 @configurationproperties_梨轻巧的博客-CSDN博客</a><br />request.getHeader（）传入请求头的名，返回请求头的值。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/判断当前拦截到的是Controller的方法还是其他资源</span><br><span class="line">        if (!(handler instanceof HandlerMethod)) &#123;</span><br><span class="line">            //当前拦截到的不是动态方法，直接放行</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">使用了 instanceof 运算符，它可以判断一个对象是否属于某个类或接口。</span><br><span class="line">你判断了 handler 是否属于 HandlerMethod 类，它是一个表示控制器方法的对象。</span><br><span class="line">如果 handler 不是 HandlerMethod 的实例，说明当前拦截到的不是控制器方法，</span><br><span class="line">而是其他资源，比如静态文件、视图等。这时，你直接返回 true，表示放行请求，</span><br><span class="line">不进行任何拦截处理。如果 handler 是 HandlerMethod 的实例，说明当前拦截到的</span><br><span class="line">是控制器方法，这时你可以根据你的业务逻辑来决定是否拦截或处理请求。</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> Claims claims = Jwts<span class="selector-class">.parser</span>()</span><br><span class="line">                // 设置签名的秘钥</span><br><span class="line">                <span class="selector-class">.setSigningKey</span>(secretKey<span class="selector-class">.getBytes</span>(StandardCharsets<span class="selector-class">.UTF_8</span>))</span><br><span class="line">                // 设置需要解析的jwt</span><br><span class="line">                <span class="selector-class">.parseClaimsJws</span>(token)<span class="selector-class">.getBody</span>();</span><br><span class="line">代码调用 Jwts<span class="selector-class">.parser</span>() 返回一个 JwtParser 对象，用于解析 JWT。</span><br><span class="line"></span><br><span class="line">接下来，通过链式调用 setSigningKey(secretKey<span class="selector-class">.getBytes</span>(StandardCharsets<span class="selector-class">.UTF_8</span>)) 方法设置签名的密钥。secretKey 是一个字符串表示的密钥，通过 getBytes() 方法将其转换为字节数组。</span><br><span class="line"></span><br><span class="line">然后，调用 parseClaimsJws(token) 方法，并将 JWT 作为参数传递给该方法。token 是要解析的 JWT 字符串。</span><br></pre></td></tr></table></figure>
<p><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696503439259-050e74a1-2435-4a63-8838-800fadce6b17.png#averageHue=%2385765d&amp;clientId=u44c118de-c29f-4&amp;from=paste&amp;height=118&amp;id=u2fedafc8&amp;originHeight=147&amp;originWidth=1217&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=35361&amp;status=done&amp;style=none&amp;taskId=u83b24789-491c-4c1b-8825-14a3d7639a4&amp;title=&amp;width=973.6" alt="image.png"><br>
<a name="NSkXN"></a></p>
<h2 id="分页查询：">分页查询：</h2>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">请求参数类型为 Query 是指在 HTTP 请求中，将参数以键值对的形式附加在 URL 后面，</span><br><span class="line">用问号（?）分隔，用与号（&amp;）连接。例如：</span><br><span class="line"></span><br><span class="line">http://example.com/search?keyword=apple&amp;sort=price</span><br><span class="line"></span><br><span class="line">这个 URL 中，keyword 和 sort 就是 Query 参数的名称，apple 和 price 就是 Query 参数的值。</span><br><span class="line">Query 参数可以用来传递一些简单的字符串类型的数据，比如搜索关键词、</span><br><span class="line">排序方式、分页信息等。Query 参数的优点是可以直接在浏览器地址栏中输入和修改，</span><br><span class="line">方便测试和调试。Query 参数的缺点是长度有限制，不能传递复杂的对象类型的数据</span><br><span class="line">，而且会暴露在 URL 中，不适合传递敏感或私密的数据。</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@Data</span> 是一个 Lombok 注解，它可以自动生成一些常见的 Java 类代码，如字段的 getter 和 setter</span><br><span class="line">方法、equals() 和 hashCode() 方法、toString() 方法等</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log<span class="selector-class">.info</span>(&quot;分页查询：&#123;&#125;&quot;,employeePageQueryDTO);花括号&#123;&#125;充当变量值的占位符</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;pageQuery&quot; resultType=&quot;com<span class="selector-class">.sky</span><span class="selector-class">.entity</span><span class="selector-class">.Employee</span>&quot;&gt;</span><br><span class="line">    select * <span class="selector-tag">from</span> employee</span><br><span class="line">    &lt;where&gt;</span><br><span class="line">        &lt;if test=&quot;name != null and name != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            and name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/where&gt;</span><br><span class="line">    <span class="attribute">order</span> by create_time desc</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">//&lt;where&gt; 标签和 &lt;if&gt; 条件判断：用于根据条件动态生成查询语句的 WHERE 子句。</span><br><span class="line">//其中的resultType绑定查询到的每条结果的映射。这里的mapper接口的方法是返回一个</span><br><span class="line">//page&lt;Employee&gt;所以这里的resultType是com<span class="selector-class">.sky</span><span class="selector-class">.entity</span><span class="selector-class">.Employee</span>。</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://pagehelper.github.io/docs/howtouse/#2-%E9%85%8D%E7%BD%AE%E6%8B%A6%E6%88%AA%E5%99%A8%E6%8F%92%E4%BB%B6">如何使用分页插件</a><br /><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696510139759-6aa1ef5f-7f45-4c53-81dd-a4dfcdf1c2a0.png#averageHue=%23747c66&amp;clientId=u44c118de-c29f-4&amp;from=paste&amp;height=157&amp;id=ud6b729b2&amp;originHeight=196&amp;originWidth=702&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=95518&amp;status=done&amp;style=none&amp;taskId=u6645482a-ce44-4ffd-ab84-b4e576cb6bc&amp;title=&amp;width=561.6" alt="image.png"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PageHelper<span class="selector-class">.startPage</span>(employeePageQueryDTO<span class="selector-class">.getPage</span>(), employeePageQueryDTO<span class="selector-class">.getPageSize</span>());</span><br><span class="line">这个方法的第一个参数是查询第几页（第一页为最初页）第二个参数是每页的条数。如果显示的查询为</span><br><span class="line">第<span class="number">0</span>页，不会返回查询对象。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696511481893-51a7dec1-71b3-4c72-b721-e9d28e3d4225.png#averageHue=%23353433&amp;clientId=u44c118de-c29f-4&amp;from=paste&amp;height=188&amp;id=u71713dd8&amp;originHeight=235&amp;originWidth=981&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=47340&amp;status=done&amp;style=none&amp;taskId=u1afbb47f-ebf1-4b55-92a8-e63be3109ec&amp;title=&amp;width=784.8" alt="image.png"><br /><a target="_blank" rel="noopener" href="https://www.baeldung.com/spring-httpmessageconverter-rest">https://www.baeldung.com/spring-httpmessageconverter-rest</a><br />利用SpringMVC框架，可以使得我们在开发时，只要在代码中使用@RequestBody和@ResponseBody两个注解，就可以分别完成从请求报文到对象和从对象到响应报文的转换。而在源码内部，其实这种灵活的消息转换机制就是利用HttpMessageConverter来实现的。<br />HttpMessageConverter的调用是RequestResponseBodyMethodProcessor类的解析请求参数的方法resolveArgument()和处理返回值的方法handleReturnValue()中进行调用的。这是关于@RequestBody和@ResponseBody两个注解的原理。</p>
<p><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/webp/28066124/1696514104432-ba89f22e-3e8d-4493-adb6-27fbfb0910c2.webp#averageHue=%23f5f5f5&amp;clientId=u44c118de-c29f-4&amp;from=paste&amp;id=u5df98b36&amp;originHeight=491&amp;originWidth=1512&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3e2ad3ad-bd0d-4a6f-82af-6a2c7916b35&amp;title=" alt=""><br />day3:<br />AOP，即面向切面编程，是一种编程范式，它可以将一些与业务逻辑无关的功能，如日志、安全、事务等，抽取出来，独立实现，然后在运行时动态地插入到目标对象中，从而实现功能的统一维护和复用<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/395709988">https://zhuanlan.zhihu.com/p/395709988</a>。AOP是OOP的延续和补充，它可以解决OOP中的横切关注点问题<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/161705262">https://zhuanlan.zhihu.com/p/161705262</a>。</p>
<p>AOP的核心概念有以下几个<a target="_blank" rel="noopener" href="https://bing.com/search?q=AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F&amp;form=SKPBOT">https://bing.com/search?q=AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F&amp;form=SKPBOT</a>：</p>
<p>•  切面（Aspect）：一个切面包含了一些通知和切点，定义了切面的功能和作用范围。</p>
<p>•  通知（Advice）：一个通知是切面要执行的具体操作，比如在方法前后打印日志等。通知有五种类型：前置通知、后置通知、返回通知、异常通知和环绕通知。</p>
<p>•  切点（Pointcut）：一个切点是指定哪些连接点需要被通知的条件，比如匹配某些类或方法等。切点可以通过AspectJ的切点表达式语言来定义。</p>
<p>•  连接点（Joinpoint）：一个连接点是程序执行过程中的一个点，比如方法调用、异常抛出等。连接点是通知的应用对象。</p>
<p>•  织入（Weaving）：织入是将切面应用到目标对象的过程，可以在编译期、类加载期或运行期进行。</p>
<p>AOP的优点有以下几个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/AOP/1332219">https://baike.baidu.com/item/AOP/1332219</a>：</p>
<p>•  可以提高代码的模块化和复用性，减少代码冗余和耦合。</p>
<p>•  可以提高代码的可读性和可维护性，增加代码的清晰度和一致性。</p>
<p>•  可以提高代码的安全性和性能，增加代码的灵活性和扩展性。<br /><a target="_blank" rel="noopener" href="https://blog.csdn.net/q982151756/article/details/80513340">细说Spring——AOP详解（AOP概览）-CSDN博客</a><br />@Retention(RetentionPolicy.RUNTIME)<br />@Retention(RetentionPolicy.RUNTIME) 是一个 Java 注解，用于指定注解的保留策略（retention policy）。在这个特定的注解中，RetentionPolicy.RUNTIME 表示注解将在运行时保留，可以通过反射来获取注解的信息。<br />Java 注解的保留策略有三种：</p>
<ol>
<li>RetentionPolicy.SOURCE：源代码级别的保留策略。注解仅存在于源代码中，在编译后的字节码文件中不可见。</li>
<li>RetentionPolicy.CLASS：类文件级别的保留策略。注解将保留到编译后的字节码文件中，但在运行时不可见。</li>
<li>RetentionPolicy.RUNTIME：运行时级别的保留策略。注解将保留到编译后的字节码文件中，并且在运行时可以通过反射获取注解的信息。</li>
</ol>
<p>当使用 @Retention 注解时，通过设置 RetentionPolicy 参数来指定所需的保留策略。对于 @Retention(RetentionPolicy.RUNTIME)，它表示注解将在运行时保留，并且可以通过反射在运行时访问注解的信息。<br />以下是一个示例，展示了如何定义一个注解并使用 @Retention(RetentionPolicy.RUNTIME) 设置其保留策略为运行时级别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line"></span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyAnnotation &#123;</span><br><span class="line">    // 注解的元素</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，@MyAnnotation 是一个自定义的注解，通过 @Retention(RetentionPolicy.RUNTIME) 设置其保留策略为运行时级别。<br />通过设置注解的保留策略为运行时级别，可以在程序运行时使用反射来获取注解的信息。例如，可以获取注解的值、解析注解中的元素等。<br />请注意，注解的保留策略根据不同的使用场景进行选择。根据需要，您可以选择适合您应用程序的保留策略。<br>
<a name="SxB4Z"></a></p>
<h2 id="IOC和AOP：">IOC和AOP：</h2>
<p>IOC：<br /><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696562276048-4e6a24df-4e41-49e9-81b6-2e015cc72ae3.png#averageHue=%23f2f1f1&amp;clientId=u44c118de-c29f-4&amp;from=paste&amp;height=87&amp;id=u25b98ac9&amp;originHeight=109&amp;originWidth=602&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=46356&amp;status=done&amp;style=none&amp;taskId=u449e49c9-a658-436d-83af-e40c4567505&amp;title=&amp;width=481.6" alt="image.png"><br />添加依赖：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org<span class="selector-class">.springframework</span>&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">6.0</span>.<span class="number">12</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>spring-context是Spring框架的一个模块，该模块的功能是实现IOC（控制反转容器），它使用依赖注入来实现控制反转的。在springboot项目中可以不用导入该依赖，因为 spring-boot-starter-* 依赖来自动导入 Spring Framework 的核心模块，包括 spring-context。<br />依赖注入设计模式：就算将一个类的依赖不用在本类中new,而是交给一个容器来利用反射机制来创建。<br /><a target="_blank" rel="noopener" href="https://juejin.cn/post/7233587830387015741">一起来学设计模式之依赖注入模式 - 掘金</a></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">@Target</span>(&#123;ElementType<span class="selector-class">.CONSTRUCTOR</span>, ElementType<span class="selector-class">.METHOD</span>, ElementType<span class="selector-class">.PARAMETER</span>, ElementType<span class="selector-class">.FIELD</span>, ElementType<span class="selector-class">.ANNOTATION_TYPE</span>&#125;)</span><br><span class="line"><span class="keyword">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Autowired &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Declares whether the annotated dependency is required.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Defaults to &#123;@code true&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    boolean required() default true;//required是一个方法，用来表示注解元素是否是必须的</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义Java类的接口及实现类</span><br><span class="line">public interface UserService &#123;</span><br><span class="line">    void sayHello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@Autowired</span></span><br><span class="line">    private UserService userService1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@Override</span></span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        userService1<span class="selector-class">.sayHello</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class UserService1Impl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@Override</span></span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(&quot;Hello, userService1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用反射机制在IOC容器中创建Java对象</span><br><span class="line">public class BeanFactory &#123;</span><br><span class="line">    public static <span class="selector-tag">Object</span> getBean(String className) &#123;</span><br><span class="line">        <span class="selector-tag">Object</span> <span class="selector-tag">object</span> = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class clazz = Class<span class="selector-class">.forName</span>(className);</span><br><span class="line">            <span class="selector-tag">object</span> = clazz<span class="selector-class">.newInstance</span>();// clazz<span class="selector-class">.newInstance</span>()是使用</span><br><span class="line">          //无参构造创建实例</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            // handle exception</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            // handle exception</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            // handle exception</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="selector-tag">object</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义IOC容器类，即存储Java对象的容器</span><br><span class="line">// 对象依赖关系的维护，即在创建对象时，扫描对象的属性并注入依赖的对象</span><br><span class="line">public class Container &#123;</span><br><span class="line">    private Map&lt;String, <span class="selector-tag">Object</span>&gt; beans = new HashMap&lt;&gt;();</span><br><span class="line">    public void register(String beanName, <span class="selector-tag">Object</span> bean) &#123;</span><br><span class="line">        beans<span class="selector-class">.put</span>(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="selector-tag">Object</span> getBean(String beanName) &#123;</span><br><span class="line">        <span class="selector-tag">Object</span> <span class="selector-tag">object</span> = beans<span class="selector-class">.get</span>(beanName);</span><br><span class="line">        // 获取对象的所有属性，通过反射获取所有的成员对象数组</span><br><span class="line">        Field<span class="selector-attr">[]</span> fields = <span class="selector-tag">object</span><span class="selector-class">.getClass</span>()<span class="selector-class">.getDeclaredFields</span>();</span><br><span class="line">        // 遍历属性，注入依赖的对象</span><br><span class="line">        for (Field field : fields) &#123;</span><br><span class="line">            if (field<span class="selector-class">.isAnnotationPresent</span>(Autowired<span class="selector-class">.class</span>)) &#123;</span><br><span class="line">                String fieldName = field<span class="selector-class">.getName</span>();</span><br><span class="line">                <span class="selector-tag">Object</span> dependency = getBean(fieldName);</span><br><span class="line">                if (dependency != null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        field<span class="selector-class">.setAccessible</span>(true);</span><br><span class="line">                        field<span class="selector-class">.set</span>(<span class="selector-tag">object</span>, dependency);</span><br><span class="line">                    &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">                        // handle exception</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="selector-tag">object</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class <span class="selector-tag">Main</span> &#123;</span><br><span class="line">    public static void <span class="selector-tag">main</span>(String<span class="selector-attr">[]</span> args) &#123;</span><br><span class="line">        Container container = new Container();</span><br><span class="line">        // 注册Java对象到IOC容器</span><br><span class="line">        container<span class="selector-class">.register</span>(&quot;userService&quot;, BeanFactory<span class="selector-class">.getBean</span>(&quot;com<span class="selector-class">.java</span><span class="selector-class">.design</span><span class="selector-class">.dependency</span><span class="selector-class">.UserServiceImpl</span>&quot;));</span><br><span class="line">        container<span class="selector-class">.register</span>(&quot;userService1&quot;, BeanFactory<span class="selector-class">.getBean</span>(&quot;com<span class="selector-class">.java</span><span class="selector-class">.design</span><span class="selector-class">.dependency</span><span class="selector-class">.UserService1Impl</span>&quot;));</span><br><span class="line"></span><br><span class="line">        // 从IOC容器中获取Java对象并使用</span><br><span class="line">        UserService userService = (UserService) container<span class="selector-class">.getBean</span>(&quot;userService&quot;);</span><br><span class="line">        userService<span class="selector-class">.sayHello</span>();</span><br><span class="line"></span><br><span class="line">        // Hello, userService1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//后面的userServiceImp1和userServiceImp2互相依赖。但是他们并不都是在直接类中new对方实例；</span><br><span class="line">  而是通过BeanFactory<span class="selector-class">.getBean</span>方法，无参构造一个对象然后注入中进行管理。容器根据扫描注入类的</span><br><span class="line">  属性，看是否有 <span class="keyword">@Autowired</span>注解修饰，如果有就通过反射在该对象类创建依赖的对象。</span><br></pre></td></tr></table></figure>
<p>一个类A依赖类B，按理来说类A中的方法要使用到类B的实例，就需要在类A中new一个类B，但是这样类A和类B的耦合度就高了。依赖注入就算让类A不在使用new来声明B实例了，而是在A中的B属性前用@Autowierd   注解表示自动注入。这个时候声明一个容器，这个容器存放类A和类B的实例（一般是无参构造的实例），把A和B放入容器后，容器利用反射机制扫描类A和类B的属性，发现了@Autowired  注解修饰的属性时，这里也就扫描A的属性发现了B属性，然后将B属性的实例名在容器中寻找B实例。将该属性的值赋值为容器中找到的B实例。至于为什么会有依赖注入和IOC的设置我暂且不知道，可能是为了更好的维护吧？<br />AOP：<br /><a target="_blank" rel="noopener" href="https://juejin.cn/post/7096780005295783973">Spring中的AOP面向切面编程 - 掘金</a><br />AOP的实现是靠动态代理实现的，AOP的动态代理有JDK动态代理和CGLib动态代理。JDK动态代理是实现要代理的类的全部接口，继承了<strong>Proxy类；使用JDK动态代理生成的对应的AOP方法（如果该方法在原类不是实现接口的方法）无法对非接口中的方法生效。CGLib是</strong>通过操作字节码重写父类的方法生成子类实现的，但是由于重新无法重新fianl修饰的方法，所以该代理生成的AOP方法无法对原类中的final修饰的方法生效。<br /><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tuyang1129/p/12878549.html">浅析Spring中AOP的实现原理——动态代理 - 特务依昂 - 博客园</a><br /><a target="_blank" rel="noopener" href="https://pdai.tech/md/spring/spring-x-framework-aop.html#aop%E6%9C%AF%E8%AF%AD">Spring基础 - Spring核心之面向切面编程(AOP)</a><br />AOP编程的方法可以自己声明一个注解标记在要进行AOP操作的方法上，写一个@Aspect修饰的处理类。<br />@Aspect  声明的方法中有一个单独的@Pointcut声明的切入点方法。后面的@Before等  通知的注解的值可以是这个，在相关的通知方法利用反射机制书写特定的逻辑。然后在要进行织入的方法上用该注解修饰。<br />AOP切面如果书写的切面类的切面点是一个私有方法，那么将无法代理该私有方法，也就是切面方法无法织入到切面点的。JDK代理是生成公共的接口，私有方法不会存在于代理类中，CGLib代理会在生成代理对象的过程中pass掉私有方法。<br />反射：<br /><a target="_blank" rel="noopener" href="https://blog.csdn.net/a745233700/article/details/82893076">Java基础篇：反射机制详解_java反射机制原理详解-CSDN博客</a><br /><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/basic/java-basic-x-reflection.html">Java 基础 - 反射机制详解</a><br /><a target="_blank" rel="noopener" href="https://blog.csdn.net/a745233700/article/details/90232862">Java虚拟机：对象创建过程与类加载机制、双亲委派模型-CSDN博客</a><br />文件上传：<br />这里使用的阿里云图片上传的OSS技术，其实在图片上传的时候是将图片上传到阿里云的OSS然后在将返回地址返回给前端，然后前端在把图片地址信息和其他相关信息上传给后端，然后后端在数据库当中储存图片的地址。<br />上传到阿里云OSS成功后但是后面的访问无法访问的问题：<br />原因是阿里云OSS的文件权限的问题设置为私有的。<br /><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696596200087-d7b6442b-79e4-42c2-ab53-3c1a534a5122.png#averageHue=%23fcfbfa&amp;clientId=u44c118de-c29f-4&amp;from=paste&amp;height=429&amp;id=u5387fd6e&amp;originHeight=536&amp;originWidth=1154&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=88796&amp;status=done&amp;style=none&amp;taskId=u16e3e2c4-85bb-4518-8fb2-a1748c57b6d&amp;title=&amp;width=923.2" alt="image.png"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MultipartFile 是 Spring Framework 中提供的一个接口，用于处理文件上传的封装。</span><br><span class="line"></span><br><span class="line">MultipartFile 接口定义了用于获取上传文件信息和操作文件内容的方法。它是对 HTTP 请求中的文件数据进行封装，使得在 Spring Web 应用中可以方便地处理文件上传操作。</span><br><span class="line"></span><br><span class="line">通过使用 MultipartFile，您可以轻松地获取上传文件的原始文件名、文件类型、文件大小以及文件内容。</span><br><span class="line"></span><br><span class="line">以下是 MultipartFile 接口的一些常用方法：</span><br><span class="line"></span><br><span class="line">getOriginalFilename()：获取上传文件的原始文件名。</span><br><span class="line">getContentType()：获取上传文件的内容类型。</span><br><span class="line">getSize()：获取上传文件的大小。</span><br><span class="line">getBytes()：获取上传文件的字节数组。</span><br><span class="line">getInputStream()：获取上传文件的输入流，用于读取文件内容。</span><br></pre></td></tr></table></figure>
<p>mybits如果插入的是一个链表：这里的flavors是mapper接口传来的参数，是一个链表。这里使用的是foreach标签来实现循环插入</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertBatch&quot;&gt;</span><br><span class="line">        insert into dish_flavor (dish_id, name, value) VALUES</span><br><span class="line">        &lt;foreach collection=&quot;flavors&quot; item=&quot;df&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">            (#&#123;df<span class="selector-class">.dishId</span>&#125;,#&#123;df<span class="selector-class">.name</span>&#125;,#&#123;df<span class="selector-class">.value</span>&#125;)</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line">                  </span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    &lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;</span><br><span class="line">        insert into dish (name, category_id, price, image, description, create_time, update_time, create_user,update_user, status)</span><br><span class="line">        values (#&#123;name&#125;, #&#123;categoryId&#125;, #&#123;price&#125;, #&#123;image&#125;, #&#123;description&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;, #&#123;status&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line">//insert 是 &lt;insert&gt; 标签的 id 属性，用于标识该插入语句的唯一标识符，以便在其他地方引用。</span><br><span class="line">useGeneratedKeys=&quot;true&quot; 是 &lt;insert&gt; 标签的属性之一，用于指示 MyBatis 是否应该返回生成的主键值</span><br><span class="line">。将其设置为 true 表示希望获取自动生成的主键值。</span><br><span class="line">keyProperty=&quot;id&quot; 是 &lt;insert&gt; 标签的属性之一，用于指定将生成的主键值设置到哪个属性中。</span><br><span class="line">在这个例子中，生成的主键值将被设置到名为 id 的属性中。</span><br><span class="line">这段代码表明在执行插入操作后，MyBatis 将自动获取生成的主键值，并将其设置到名为 id 的属性中。</span><br><span class="line">这样可以方便地获取插入操作后生成的主键值，以便后续的处理或展示。</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/57693064">最全面的SpringBoot配置文件详解</a><br /><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696592788345-07faa46e-0a5d-46a0-81eb-c2482a183218.png#averageHue=%23697f60&amp;clientId=u44c118de-c29f-4&amp;from=paste&amp;height=219&amp;id=u18fe79aa&amp;originHeight=274&amp;originWidth=835&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=202335&amp;status=done&amp;style=none&amp;taskId=ucdbe73d5-ffc6-4daf-ac91-64af1f2a39d&amp;title=&amp;width=668" alt="image.png"><br /><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696594819349-04903179-f045-46c2-be29-9096ae4af7a2.png#averageHue=%23353433&amp;clientId=u44c118de-c29f-4&amp;from=paste&amp;height=203&amp;id=ueb42be43&amp;originHeight=254&amp;originWidth=807&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=53645&amp;status=done&amp;style=none&amp;taskId=ud9d3c0dc-202a-47e0-aa12-6c415b9c638&amp;title=&amp;width=645.6" alt="image.png"><br />解决IDEAmapper文件报未设置SQL方言警告的方法：<br />IDEA设置里面选中SQL相关的设置，按照下面的配置：<br /><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696599153092-2bf0e6a2-bb89-4a43-89ae-451c006ca770.png#averageHue=%23383d42&amp;clientId=u01839493-c0e4-4&amp;from=paste&amp;height=712&amp;id=u9c49debe&amp;originHeight=890&amp;originWidth=1242&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=143921&amp;status=done&amp;style=none&amp;taskId=u041d804c-58e9-44fe-8b74-349a4fe3075&amp;title=&amp;width=993.6" alt="image.png"><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696599237875-59b79bf8-b80a-457c-b81e-ee86c46c3123.png#averageHue=%23373e4b&amp;clientId=u01839493-c0e4-4&amp;from=paste&amp;height=150&amp;id=ud117139e&amp;originHeight=187&amp;originWidth=753&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=102878&amp;status=done&amp;style=none&amp;taskId=u54c29bed-7123-459b-9c21-72548aba864&amp;title=&amp;width=602.4" alt="image.png"><br />代码规范：方法注释模板设置，实现在方法头部添加注释实现在注释块添加返回参数类型和方法参数类型<br />1.进入<br />- 设置 - 编辑器 - 活动模板<br />添加如下模板</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> $param$</span><br><span class="line"> * <span class="keyword">@return</span> $return$</span><br><span class="line"> * @date $date$ $time$</span><br><span class="line"> * @description $description$</span><br><span class="line"> */</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696602753869-f1f8dee7-c54c-44ea-8064-c7df4f2c4b6e.png#averageHue=%233c4146&amp;clientId=u01839493-c0e4-4&amp;from=paste&amp;height=696&amp;id=u2210aa34&amp;originHeight=870&amp;originWidth=1193&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=115405&amp;status=done&amp;style=none&amp;taskId=ubc1503d2-a015-41dc-addc-f0f5df63485&amp;title=&amp;width=954.4" alt="image.png"><br />编辑环境变量：<br /><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696602837186-b6cc6b83-5fce-48e9-b022-194f2477b0f3.png#averageHue=%233e444a&amp;clientId=u01839493-c0e4-4&amp;from=paste&amp;height=312&amp;id=gxy03&amp;originHeight=390&amp;originWidth=780&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=47627&amp;status=done&amp;style=none&amp;taskId=u51752a25-2626-4256-837a-448c8aee419&amp;title=&amp;width=624" alt="image.png"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groovyScript(&quot;def result=&#x27;&#x27;; def params=\&quot;$&#123;_1&#125;\&quot;<span class="selector-class">.replaceAll</span>(&#x27;<span class="selector-attr">[\\\\[|\\\\]</span>|\\\\s]&#x27;, &#x27;&#x27;)<span class="selector-class">.split</span>(&#x27;,&#x27;)<span class="selector-class">.toList</span>(); for(<span class="selector-tag">i</span> = <span class="number">0</span>; <span class="selector-tag">i</span> &lt; params<span class="selector-class">.size</span>(); <span class="selector-tag">i</span>++) &#123;result+=&#x27;* <span class="keyword">@param</span>: <span class="string">&#x27; + params[i] + ((i &lt; params.size() - 1) ? &#x27;</span>\\n <span class="string">&#x27; : &#x27;</span><span class="string">&#x27;)&#125;;return result&quot;, methodParameters())  </span></span><br></pre></td></tr></table></figure>
<p>在方法上面使用注解块的时候/**然后按tab就可以生成了。<br /><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cc11001100/p/7811257.html">mybatis笔记之使用Mapper接口注解 - CC11001100 - 博客园</a></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">在 Spring AOP 中，<span class="keyword">@within</span> 是一个切点表达式，用于选择标记有特定注解的类或类的方法。</span><br><span class="line"></span><br><span class="line">@within 切点表达式的语法如下：</span><br><span class="line"></span><br><span class="line">Copy</span><br><span class="line">@within(annotationType)</span><br><span class="line">其中，annotationType 是一个注解类型的名称，用于选择标记有该注解的类或类的方法。</span><br><span class="line"></span><br><span class="line">以下是一个示例，展示如何在 Spring AOP 中使用 @within 切点表达式：</span><br><span class="line"></span><br><span class="line">java</span><br><span class="line">Copy</span><br><span class="line">@Aspect</span><br><span class="line">public class MyAspect &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@Pointcut</span>(&quot;<span class="keyword">@within</span>(org.springframework.stereotype.Controller)&quot;)</span><br><span class="line">    public void controllerMethods() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@Before</span>(&quot;controllerMethods()&quot;)</span><br><span class="line">    public void beforeControllerMethod(JoinPoint joinPoint) &#123;</span><br><span class="line">        // 在标记有 <span class="keyword">@Controller</span> 注解的类的方法执行前执行</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">在上述示例中，我们定义了一个切点 controllerMethods()，使用 @within(org.springframework.stereotype.Controller) 来选择标记有 @Controller 注解的类或类的方法。然后，我们在 beforeControllerMethod() 方法上使用 @Before 注解来指定在符合切点条件的方法执行前执行的通知。</span><br><span class="line"></span><br><span class="line">这样，当任何标记有 @Controller 注解的类的方法被调用时，beforeControllerMethod() 方法将会在方法执行前被调用。</span><br><span class="line">需要注意的是，切点表达式中的注解类型名称应使用全限定名，例如 org.springframework.stereotype.Controller。</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cc11001100/p/7811257.html">mybatis笔记之使用Mapper接口注解 - CC11001100 - 博客园</a><br>
<a name="xP9dV"></a></p>
<h2 id="第二部分：">第二部分：</h2>
<p><a name="GTOLH"></a></p>
<h3 id="redis">redis:</h3>
<p>redis设置远程连接：<br /><a target="_blank" rel="noopener" href="https://blog.csdn.net/LONG_Yi_1994/article/details/113940332">redis远程连接配置文件</a>如果远程连接中的时候要关闭掉原来的redis-serve进程，但是这个时候用kill-9命令却是无法关闭掉redis-server的时候可以用service redis-server stop命令关闭redis-server进程，然后在使用redis-server “新的redis配置文件的路径”启动redis.之所以上面的kill -9无法关闭启动了的redis的原因是：redis将启动设置写入了一个配置文件中了的，这个时候关闭了redis，相应的配置文件会利用其父进程生成新的redis-server<br />redis操作：<br /><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904094545477640">Spring Data Redis 最佳实践！ - 掘金</a><br /><a target="_blank" rel="noopener" href="https://ost.51cto.com/posts/2333">spring boot整合redis ---- RedisTemplate 三分钟快速入门-开源基础软件社区-51CTO.COM</a><br />IOC容器中注入了2个一样的Bean</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果向Spring的IOC容器中注入两个同类的Bean，会发生什么呢？这取决于您如何配置和使用这两个Bean。一般来说，有以下几种可能的情况：</span><br><span class="line"></span><br><span class="line">•  如果您为这两个Bean指定了不同的id或name属性，那么它们就是不同的Bean实例，可以通过它们的id或name来区分和引用</span><br><span class="line">•  如果您为这两个Bean指定了相同的id或name属性，那么后面定义的Bean会覆盖前面定义的Bean，只有后面定义的Bean会被创建和使用</span><br><span class="line">•  如果您没有为这两个Bean指定id或name属性，那么它们就是匿名Bean，不能直接被引用，但可以作为其他Bean的依赖注入</span><br><span class="line">•  如果您想要在一个地方使用这两个Bean，那么您需要使用<span class="keyword">@Qualifier</span>注解或其他方式来指定您想要使用哪一个Bean，否则会出现歧义（NoUniqueBeanDefinitionException）</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bean中如果注入的是方法返回的bean，那么这个bean的id默认为方法名，如果容器中已经存在同Id的bean。</span><br><span class="line">那么后面注入的bean会覆盖前面的；常见的<span class="keyword">@configuration</span>就是这样实现对原本自动注入容器中的bean</span><br><span class="line">进行覆盖的。如果注入的是类，那么该bean的id是全类名</span><br></pre></td></tr></table></figure>
<p><a name="eILgq"></a></p>
<h3 id="同名bean：">同名bean：</h3>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903696954818568">SpringBoot基础篇之重名Bean的解决与多实例选择 - 掘金</a><br />同名bean：多个bean 有相同的 name 或者 id，称之为同名bean<br /><strong>bean 的id 和 name的区别</strong><br />id和name都是spring 容器中中bean 的唯一<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%A0%87%E8%AF%86%E7%AC%A6&amp;spm=1001.2101.3001.7020">标识符</a>。</p>
<ol>
<li>id: 一个bean的唯一标识 ， 命名格式必须符合XML ID属性的命名规范</li>
<li>name: 可以用特殊字符，并且一个bean可以用多个名称：name=“bean1,bean2,bean3”<br />,用逗号或者分号或者空格隔开。如果没有id，则name的第一个名称默认是id</li>
</ol>
<p>spring 容器如何处理同名bean？</p>
<ul>
<li>同一个spring配置文件中，bean的 id、name是不能够重复的，否则spring容器启动时会报错。<br />如果一个spring容器从多个配置文件中加载配置信息，则多个配置文件中是允许有同名bean的，并且后面加载的配置文件的中的bean定义会覆盖前面加载的同名bean。<br />1、在spring同一个配置文件中，不能存在id相同的两个bean，否则会报错。<br />2、在两个不同的spring配置文件中，可以存在id相同的两个bean，启动时，不会报错。这是因为spring<br />ioc容器在加载bean的过程中，类DefaultListableBeanFactory会对id相同的bean进行处理：后加载的配置文件的bean，覆盖先加载的配置文件的bean。DefaultListableBeanFactory类中，有个属性allowBeanDefinitionOverriding，默认值为true，该值就是用来指定出现两个bean的id相同的情况下，如何进行处理。如果该值为false，则不会进行覆盖，而是抛出异常。</li>
</ul>
<p>spring 容器如何处理没有指定id、name属性的bean？<br />如果 一个 bean 标签未指定 id、name 属性，则 spring容器会给其一个默认的id，值为其类全名。<br />如果有多个bean标签未指定 id、name 属性，则spring容器会按照其出现的次序，分别给其指定 id 值为 “类全名#1”, “类全名#2”<br />如下：<br />配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;com.xxx.UserInfo&quot;&gt;  </span><br><span class="line">    &lt;property name=&quot;accountName&quot; value=&quot;no-id-no-name0&quot;&gt;&lt;/property&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;bean class=&quot;com.xxx.UserInfo&quot;&gt;  </span><br><span class="line">    &lt;property name=&quot;accountName&quot; value=&quot;no-id-no-name1&quot;&gt;&lt;/property&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;bean class=&quot;com.xxx.UserInfo&quot;&gt;  </span><br><span class="line">    &lt;property name=&quot;accountName&quot; value=&quot;no-id-no-name2&quot;&gt;&lt;/property&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br></pre></td></tr></table></figure>
<p>获取bean的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UserInfo u4 = (UserInfo)ctx.getBean(&quot;com.xxx.UserInfo&quot;);  </span><br><span class="line">UserInfo u5 = (UserInfo)ctx.getBean(&quot;com.xxx.UserInfo#1&quot;);  </span><br><span class="line">UserInfo u6 = (UserInfo)ctx.getBean(&quot;com.xxx.UserInfo#2&quot;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当一个类被标记为 @Configuration 时，它就变成了一个配置类，可以用来定义 beans、配置组件扫描、</span><br><span class="line">声明依赖关系等。配置类主要用于替代传统的 XML 配置文件，通过 Java 代码方式进行配置。</span><br><span class="line">@Configuration 注解告诉 Spring 框架这个类是一个配置类，Spring 在启动时会扫描这个类，</span><br><span class="line">并根据其中的配置信息来创建和初始化相应的 beans。通过配置类的方式，</span><br><span class="line">可以更加灵活和可读性强的方式来配置和组织应用程序。</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1497568">【小家Spring】Redis序列化、RedisTemplate序列化方式大解读，介绍Genericjackson2jsonredisserializer序列化器的坑-腾讯云开发者社区-腾讯云</a><br />IDEA无法连接远程的redis解决方法：<br />我这里的原因是因为版本不兼容的原因造成的，也就是springboot和redis中的版本不兼容造成无法连接的。就不该在这上面浪费那么多时间的！！！下次在选择软件搭配的时候，第一件事情就是想着版本搭配。<br /><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696683872839-504bd5b1-d5b3-4a41-b59f-a9b67eeb6e99.png#averageHue=%23363433&amp;clientId=uaab8ed78-6ff9-4&amp;from=paste&amp;height=94&amp;id=u7b797e1e&amp;originHeight=117&amp;originWidth=940&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=28663&amp;status=done&amp;style=none&amp;taskId=u471d87fc-bec8-4938-9052-2644b842096&amp;title=&amp;width=752" alt="image.png"><br /><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696685225386-2ddceecd-ae85-4cf6-a3cc-0b0efbad2a22.png#averageHue=%23696649&amp;clientId=uaab8ed78-6ff9-4&amp;from=paste&amp;height=85&amp;id=u800e55bd&amp;originHeight=106&amp;originWidth=767&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=87266&amp;status=done&amp;style=none&amp;taskId=u6b61fca3-6415-4f23-b697-21945a01b6c&amp;title=&amp;width=613.6" alt="image.png"><br />消息转换器：<br /><a target="_blank" rel="noopener" href="https://juejin.cn/post/7169590769789960205">Spring Mvc：HttpMessageConverter 消息转换器 - 掘金</a><br /><a target="_blank" rel="noopener" href="https://blog.csdn.net/JokerLJG/article/details/125099369">SpringBoot消息转换器：HttpMessageConverter-CSDN博客</a><br />HttpClient<br /><a target="_blank" rel="noopener" href="https://blog.icexmoon.cn/archives/450.html">从零开始 Spring Boot 15：Http Client - 红茶的个人站点</a><br /><a target="_blank" rel="noopener" href="https://blog.csdn.net/sco5282/article/details/121458401">【HttpClient】在 SpringBoot 中使用 HttpClient 实现 HTTP 请求_springboot使用httpclient-CSDN博客</a><br /><a target="_blank" rel="noopener" href="https://www.baeldung.com/httpclient-guide">Just a moment…</a><br /><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1537173">springboot实战之常用http客户端整合-腾讯云开发者社区-腾讯云</a><br /><a target="_blank" rel="noopener" href="https://reflectoring.io/spring-webclient/">Sending HTTP requests with Spring WebClient</a><br>
<a name="nmGlC"></a></p>
<h3 id="小程序开发：">小程序开发：</h3>
<p>1.小程序中的json不能有注释。<br>
<a name="KL8m2"></a></p>
<h5 id="查看appid和appsecret的方法：">查看appid和appsecret的方法：</h5>
<p>登录：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/">微信公众平台</a><br /><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696938122732-4ca99cf6-323c-47dc-866c-ecd383004ef2.png#averageHue=%236ac15e&amp;clientId=u56082022-af55-4&amp;from=paste&amp;height=821&amp;id=u5d84ba38&amp;originHeight=1026&amp;originWidth=1740&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=99598&amp;status=done&amp;style=none&amp;taskId=u94022fb8-4aa7-458d-82e5-559bbf3eaa5&amp;title=&amp;width=1392" alt="image.png"><br /><a target="_blank" rel="noopener" href="https://juejin.cn/post/7076244567569203208#heading-6">SpringBoot教程(十四) | SpringBoot集成Redis(全网最全) - 掘金</a><br />springboot在使用redis的时候导入了相关的依赖的时候，这个依赖里面有相关的配置类和配置文件中的redis配置信息相关联，redis会根据导入的客户端类来判断redis使用的客户端是什么，是根据@ConditionalOnClass组件来判断加载那种客户端。可以自己配置redis的配置类从而覆盖依赖导入的配置类，从而实现修改redis序列化时自己的序列化方式。redis导入依赖的时候就把redisTemplate类注入到容器了，在控制层使用redisTemplate的时候可以使用@AutoWired  的方式注入该依赖。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Set</span> keys = redisTemplate.<span class="title function_">keys</span>(pattern);</span><br><span class="line"><span class="title function_">keys</span>(pattern)是<span class="title class_">RedisTemplate</span>中的一个方法，它可以根据一个通配符模式来查询匹配的key集合，</span><br><span class="line">  返回一个<span class="title class_">Set</span>类型的结果。</span><br></pre></td></tr></table></figure>
<p>SpringCache:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  @<span class="title class_">Insert</span>(<span class="string">&quot;insert into user(name,age) values (#&#123;name&#125;,#&#123;age&#125;)&quot;</span>)</span><br><span class="line">    @<span class="title class_">Options</span>(useGeneratedKeys = <span class="literal">true</span>,keyProperty = <span class="string">&quot;id&quot;</span>)</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span>(<span class="title class_">User</span> user);</span><br><span class="line">@options指定<span class="variable constant_">SQL</span>语句的其他选项。</span><br><span class="line">useGeneratedKeys 设置为<span class="string">&quot;true&quot;</span> 表明要 <span class="title class_">MyBatis</span> 获取由数据库自动生成的主键。</span><br><span class="line">keyProperty=“eqCsImgId” 指定把获取到的主键值注入到相对应实体类中 eqCsImgId属性。</span><br><span class="line">keyColumn=<span class="string">&quot;eq_cs_img_id指定数据中自增主键的名称。</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">CachePut</span>(value = <span class="string">&quot;userCache&quot;</span>, key = <span class="string">&quot;#user.id&quot;</span>)</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p><a name="PqhSP"></a></p>
<h4 id="springboot缓存">springboot缓存:</h4>
<p>IDEA的插件有时候会因为版本原因等问题导致插件是无法正常工作的。这个时候在排查错误的时候如果实战没有发现错误的时候，一定不要忘了可能是插件的版本或者插件中存在的问题。<br /><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697112999200-717bdda5-5636-4fb9-a888-56c453dda8c3.png#averageHue=%23f6f5f5&amp;clientId=u18117cc1-8688-4&amp;from=paste&amp;height=302&amp;id=ucea6d794&amp;originHeight=377&amp;originWidth=932&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=88714&amp;status=done&amp;style=none&amp;taskId=uebb761f0-03e1-4d79-9a3d-349ffa37c88&amp;title=&amp;width=745.6" alt="image.png"><br /><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697112450948-bd75f5e8-a645-4573-aced-6068f2f869e2.png#averageHue=%23f8f5f2&amp;clientId=u18117cc1-8688-4&amp;from=paste&amp;height=113&amp;id=u17def977&amp;originHeight=141&amp;originWidth=464&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=24360&amp;status=done&amp;style=none&amp;taskId=u0783b0f8-0985-4aef-b5cf-5f782c545db&amp;title=&amp;width=371.2" alt="image.png"><img src= "/images/1.webp" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697112466354-3789921e-54aa-490d-8500-2a73352c8f8a.png#averageHue=%23faf9f8&amp;clientId=u18117cc1-8688-4&amp;from=paste&amp;height=269&amp;id=ud2403e04&amp;originHeight=336&amp;originWidth=1181&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=37008&amp;status=done&amp;style=none&amp;taskId=u0af9ea70-12c7-4306-89c7-ed7fb423ce0&amp;title=&amp;width=944.8" alt="image.png"><br>
<a name="ueo5E"></a></p>
<h5 id="Caching-参数">@Caching(参数)</h5>
<p>用于同时添加多个缓存注解，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">Caching</span>(evict=&#123;</span><br><span class="line">  @<span class="title class_">CacheEvict</span>(...)</span><br><span class="line">  @<span class="title class_">CacheEvict</span>(...)</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   @<span class="title class_">Cacheable</span>(cacheNames = <span class="string">&quot;user&quot;</span> ,condition=<span class="string">&quot;#id!=null&quot;</span>)</span><br><span class="line">     public <span class="title class_">User</span> <span class="title function_">getById</span>(<span class="params">  Long id</span>)&#123;</span><br><span class="line">     这里的cacheNames和上面的vaule是一样的。</span><br><span class="line">这里的condition的意思是要缓存的是下面方法的参数id但是该id不能为<span class="literal">null</span>。</span><br><span class="line">     <span class="string">`condition`</span> 是 <span class="string">`@Cacheable`</span> 注解的一个参数属性，用于指定缓存条件。</span><br><span class="line">  如果指定了 <span class="string">`condition`</span> 属性，则只有当条件表达式为 <span class="string">`true`</span> 时才会进行缓存操作</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247486428&amp;idx=1&amp;sn=e64947b13d5261db72e7c8d3e56e9cfe&amp;chksm=fce71070cb90996677ae7a42600977855e45a9fe2fa24700b21936287c6dcfa44b9eb2ff68dd&amp;token=1673053889&amp;lang=zh_CN#rd">Spring系列缓存注解@Cacheable @CacheEvit @CachePut 使用姿势介绍</a><br /><a target="_blank" rel="noopener" href="https://blog.csdn.net/justry_deng/article/details/89283664">SpringBoot使用Spring缓存注解_org.springframework.cache.annotation.abstractcachi-CSDN博客</a><br /><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42418169/article/details/112907375">mybatis之多行插入（批量操作）_mybatis多行插入_百日梦想家的博客-CSDN博客</a><br /><a target="_blank" rel="noopener" href="https://blog.csdn.net/beilizhang/article/details/117390536">mysql插入语句</a><br /><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fnlingnzb-learner/p/10566452.html">mybatis之foreach用法 - Boblim - 博客园</a><br /><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37965811/article/details/117635299">Mybatis——foreach用法_mybatis foreach_火山彬的博客-CSDN博客</a><br /><a target="_blank" rel="noopener" href="https://blog.csdn.net/wt_better/article/details/80941646?spm=1001.2101.3001.6650.14&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-14-80941646-blog-117635299.235%5Ev38%5Epc_relevant_default_base&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-14-80941646-blog-117635299.235%5Ev38%5Epc_relevant_default_base&amp;utm_relevant_index=21">mybatis foreach标签的使用-CSDN博客</a><br />数据库中表关系中的主键和外键设置后，删除表的时候特别不方便。删除主键表必须要把其关联的外键表删除了！这个时候为了方便删除表，可以在业务层也就是用代码对插入删除进行特殊的处理让他们（这些表）处于一种逻辑上面的主键和外键关系。<br />springTask:<br /><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41941477/article/details/103532393">mybatis的Update之if标签的使用-CSDN博客</a><br /><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq991658923/article/details/127022522">Spring Boot 集成 WebSocket（原生注解与Spring封装）_springboot集成websocket-CSDN博客</a><br /><a target="_blank" rel="noopener" href="https://juejin.cn/post/7020964728386093093">一文吃透 WebSocket 原理 刚面试完，趁热赶紧整理 - 掘金</a><br /><a target="_blank" rel="noopener" href="https://echarts.apache.org/handbook/zh/get-started/?sid=iDR6W2">https://echarts.apache.org/handbook/zh/get-started/?sid=iDR6W2</a></p>
<meta name="referrer" content="no-referrer">
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://www.bojiboqi.fun">山麋一笑</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://www.bojiboqi.fun/2024/02/28/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%EF%BC%9A/">http://www.bojiboqi.fun/2024/02/28/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%EF%BC%9A/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.bojiboqi.fun" target="_blank">山麋一笑</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%A1%B9%E7%9B%AE/">项目</a></div><div class="post_share"><div class="social-share" data-image="/img/wakawaka/photo_2024-02-28_10-44-54.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/02/28/%E9%94%99%E9%A2%98%EF%BC%9A/" title="错题："><img class="cover" src= "/images/1.webp" data-lazy-src="/img/wakawaka/photo_2024-02-28_19-49-27.webp" onerror="onerror=null;src='/img/404.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">错题：</div></div></a></div><div class="next-post pull-right"><a href="/2024/02/28/web%E5%89%8D%E7%AB%AF%EF%BC%9A/" title="web前端"><img class="cover" src= "/images/1.webp" data-lazy-src="/images/default.webp" onerror="onerror=null;src='/img/404.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">web前端</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E5%92%8C%E7%9B%B8%E5%85%B3%E7%9A%84CRUD"><span class="toc-number">1.</span> <span class="toc-text">登录和相关的CRUD:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.0.1.</span> <span class="toc-text">相关概念:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">分页查询：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IOC%E5%92%8CAOP%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">IOC和AOP：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">第二部分：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis"><span class="toc-number">4.1.</span> <span class="toc-text">redis:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E5%90%8Dbean%EF%BC%9A"><span class="toc-number">4.2.</span> <span class="toc-text">同名bean：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%EF%BC%9A"><span class="toc-number">4.3.</span> <span class="toc-text">小程序开发：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Bappid%E5%92%8Cappsecret%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">4.3.0.1.</span> <span class="toc-text">查看appid和appsecret的方法：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#springboot%E7%BC%93%E5%AD%98"><span class="toc-number">4.3.1.</span> <span class="toc-text">springboot缓存:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Caching-%E5%8F%82%E6%95%B0"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">@Caching(参数)</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 山麋一笑</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div id="runtime"></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twik.bojiboqi.fun/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.29/dist/twikoo.all.min.js').then(init)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twik.bojiboqi.fun/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
      
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.js"></script><div class="aplayer no-destroy" data-id="2914905159" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="auto" data-autoplay="true" muted></div><script  async data-pjax="" defer="" src="/js/fish.js"></script><script async src="/js/diytitle.js"></script><script async src="/js/runtime.js"></script><script async src="/js/leaf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div></body></html>