<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Springboot学习笔记 | 山麋一笑</title><meta name="author" content="山麋一笑"><meta name="copyright" content="山麋一笑"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="1.创建第一个项目： 1.引入依赖： 123456&lt;!--    所有springboot项目都必须继承自 spring-boot-starter-parent ,如果报	--&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId">
<meta property="og:type" content="article">
<meta property="og:title" content="Springboot学习笔记">
<meta property="og:url" content="http://www.bojiboqi.fun/2024/02/28/Springboot_/index.html">
<meta property="og:site_name" content="山麋一笑">
<meta property="og:description" content="1.创建第一个项目： 1.引入依赖： 123456&lt;!--    所有springboot项目都必须继承自 spring-boot-starter-parent ,如果报	--&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.dmoe.cc/random.php?2357">
<meta property="article:published_time" content="2024-02-28T13:02:28.457Z">
<meta property="article:modified_time" content="2024-02-28T10:44:05.263Z">
<meta property="article:author" content="山麋一笑">
<meta property="article:tag" content="springboot2">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.dmoe.cc/random.php?2357"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.bojiboqi.fun/2024/02/28/Springboot_/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Springboot学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-28 18:44:05'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href='/css/footer.css'><link rel="stylesheet" href='/css/wave.css'><link rel="stylesheet" href='/css/universe.css'><link rel="stylesheet" href='/css/custom.css'><link rel="stylesheet" href="/css/transpancy.css"><link rel="stylesheet" href="/css/runtime.css"><link rel="stylesheet" href="/css/darkRead.css"><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="山麋一笑" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">56</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-list"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.dmoe.cc/random.php?2357')"><nav id="nav"><span id="blog-info"><a href="/" title="山麋一笑"><span class="site-name">山麋一笑</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-list"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Springboot学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-28T13:02:28.457Z" title="发表于 2024-02-28 21:02:28">2024-02-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-28T10:44:05.263Z" title="更新于 2024-02-28 18:44:05">2024-02-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/springboot2/">springboot2</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">33.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>133分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Springboot学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"> <meta name="referrer" content="no-referrer">
<h1>1.创建第一个项目：</h1>
<h2 id="1-引入依赖：">1.引入依赖：</h2>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    所有springboot项目都必须继承自 spring-boot-starter-parent ,如果报	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里可能会报错：<a target="_blank" rel="noopener" href="https://blog.csdn.net/BingTaiLi/article/details/109735778">解决Maven ‘parent.relativePath‘ of POM_BingTaiLi的博客-CSDN博客</a></p>
<h3 id="2-导入场景">2. 导入场景</h3>
<p>场景启动器</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        web开发的场景启动器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-主程序">3. 主程序</h3>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication //这是一个SpringBoot应用</span><br><span class="line">public class MainApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-业务">4. 业务</h3>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RestController//将返回内容写入返回体中</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello()&#123;</span><br><span class="line"></span><br><span class="line">        return &quot;Hello,Spring Boot 3!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-测试">5. 测试</h3>
<p>默认启动访问： localhost:8080/hello</p>
<h3 id="6-打包">6. 打包</h3>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    SpringBoot应用打包插件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>mvn clean package把项目打成可执行的jar包<br>
java -jar demo.jar启动项目<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1689254342403-1c7d5be2-59f7-4d6a-8fa3-8cdcff5aa805.png#averageHue=%233b1f02&amp;clientId=uc9135780-ac3d-4&amp;from=paste&amp;height=262&amp;id=u4bd0926f&amp;originHeight=327&amp;originWidth=581&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=29111&amp;status=done&amp;style=none&amp;taskId=u817b6fc9-a2b3-41c6-beca-6e10804204b&amp;title=&amp;width=464.8" alt="image.png"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1689254431253-f1db82c5-2aff-4240-bbea-b4abbaeb24aa.png#averageHue=%23fbfaf8&amp;clientId=uc9135780-ac3d-4&amp;from=paste&amp;height=269&amp;id=u27e3853e&amp;originHeight=336&amp;originWidth=720&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=38821&amp;status=done&amp;style=none&amp;taskId=ua69cfde8-d2bd-4782-ab37-348c54090d6&amp;title=&amp;width=576" alt="image.png"><br>
在该路径下输入cmd，然后运行jar包（命令:jva -jar demo.jar,注意这里必须要字面-jar，因为运行的是jar包）<br>
但是能够成功运行要求系统java的环境变量配置的jdk17以上。</p>
<h1>3、应用分析</h1>
<p>思考：<br>
1、为什么导入starter-web所有相关依赖都导入进来？</p>
<ul>
<li>开发什么场景，导入什么<strong>场景启动器。</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--● 官方提供的场景：命名为：spring-boot-starter-*</span></span><br><span class="line"><span class="comment">		● 第三方提供场景：命名为：*-spring-boot-starter</span></span><br><span class="line"><span class="comment">		ctrl+鼠标右键即可在IDEA查看相关场景所依赖的jar包和场景--&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>maven依赖传递原则。A-B-C： A就拥有B和C</strong></li>
<li>导入 场景启动器。 场景启动器 自动把这个场景的所有核心依赖全部导入进来</li>
</ul>
<p>2、为什么版本号都不用写？</p>
<ul>
<li>每个boot项目都有一个父项目spring-boot-starter-parent（它也是一个场景）</li>
<li>parent的父项目是spring-boot-dependencies（其中的<properties>标签中把所有常见的jar的依赖版本都声明好了。）</li>
<li>父项目 <strong>版本仲裁中心</strong>，把所有常见的jar的依赖版本都声明好了。</li>
<li>比如：mysql-connector-j</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1689258459738-3f6e1e17-aff8-45a2-9c3e-e5e00b943868.png#averageHue=%2312151c&amp;clientId=uc9135780-ac3d-4&amp;from=paste&amp;height=410&amp;id=u0c91b9c1&amp;originHeight=512&amp;originWidth=890&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=95403&amp;status=done&amp;style=none&amp;taskId=ua520442b-66a3-465a-bfe4-8badcfef6af&amp;title=&amp;width=712" alt="image.png"></li>
</ul>
<p>3、自定义版本号</p>
<ul>
<li>利用maven的就近原则
<ul>
<li>直接在当前项目properties标签中声明父项目用的版本属性的key</li>
<li>直接在<strong>导入依赖的时候声明版本</strong></li>
</ul>
</li>
</ul>
<p>4、第三方的jar包</p>
<ul>
<li>boot父项目没有管理的需要自行声明好</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1689257659269-0968fa4d-b7a3-45a8-9fde-d2d34eb062bf.png#averageHue=%23dcb88c&amp;clientId=uc9135780-ac3d-4&amp;from=paste&amp;height=343&amp;id=u81f02c80&amp;originHeight=429&amp;originWidth=864&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=35824&amp;status=done&amp;style=none&amp;taskId=u601e8e76-00f7-4aec-86cf-eb00c95aad8&amp;title=&amp;width=691.2" alt="image.png"></p>
<h2 id="2-自动配置机制">2. 自动配置机制</h2>
<h3 id="1-初步理解">1. 初步理解</h3>
<ul>
<li><strong>自动配置</strong>的 Tomcat、SpringMVC 等
<ul>
<li><strong>导入场景</strong>，容器中就会自动配置好这个场景的核心组件。</li>
<li>以前：DispatcherServlet、ViewResolver、CharacterEncodingFilter…</li>
<li>现在：自动配置好的这些组件</li>
<li>验证：<strong>容器中有了什么组件，就具有什么功能</strong></li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    //java10： 局部变量类型的自动推断（可以不用声明变量的类型，直接根据右边的表达式推断）</span><br><span class="line">    var ioc = SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">    //1、获取容器中所有组件的名字</span><br><span class="line">    String[] names = ioc.getBeanDefinitionNames();</span><br><span class="line">    //2、挨个遍历：</span><br><span class="line">    // dispatcherServlet、beanNameViewResolver、characterEncodingFilter、multipartResolver</span><br><span class="line">    // SpringBoot把以前配置的核心组件现在都给我们自动配置好了。</span><br><span class="line">    for (String name : names) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>默认的包扫描规则</strong>
<ul>
<li>@SpringBootApplication 标注的类就是主程序类</li>
<li><strong>SpringBoot只会扫描主程序所在的包及其下面的子包，自动的component-scan功能</strong></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1689259030746-d45575cd-4785-4951-aea6-41a141d23f5c.png#averageHue=%23267d49&amp;clientId=uc9135780-ac3d-4&amp;from=paste&amp;height=202&amp;id=x93dY&amp;originHeight=252&amp;originWidth=1193&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=55265&amp;status=done&amp;style=none&amp;taskId=u319fb788-593b-49b5-a964-acbd641d340&amp;title=&amp;width=954.4" alt="image.png"></li>
<li><strong>自定义扫描路径</strong>
<ul>
<li>@SpringBootApplication(scanBasePackages = “com.atguigu”)//scanBasePackages指定扫描的位置</li>
<li>@ComponentScan(“com.atguigu”) 直接指定扫描的路径</li>
</ul>
</li>
</ul>
</li>
<li><strong>配置默认值</strong>
<ul>
<li><strong>配置文件</strong>的所有配置项是和某个<strong>类的对象</strong>值进行一一绑定的。</li>
<li>绑定了配置文件中每一项值的类： <strong>属性类</strong>。</li>
<li>比如：
<ul>
<li>ServerProperties绑定了所有Tomcat服务器有关的配置</li>
<li>MultipartProperties绑定了所有文件上传相关的配置</li>
<li>…参照<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.server">官方文档</a>：或者参照 绑定的 <strong>属性类</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>按需加载自动配置
<ul>
<li>导入场景spring-boot-starter-web</li>
<li>场景启动器除了会导入相关功能依赖(ctrl+鼠标右击可以查看导入的依赖），还导入一个spring-boot-starter(每个场景ctrl点进去的配置文件都有一个的spring-boot-starter），是所有starter的starter，这个starter基础核心starter</li>
<li>spring-boot-starter导入了一个包 spring-boot-autoconfigure。包里面都是各种场景的AutoConfiguration<strong>自动配置类</strong></li>
<li>虽然全场景的自动配置都在 spring-boot-autoconfigure这个包，但是不是全都开启的。
<ul>
<li>导入哪个场景就开启哪个自动配置</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>总结： 导入场景启动器、触发 spring-boot-autoconfigure这个包的自动配置生效、容器中就会具有相关场景的功能</p>
<h2 id="1-常用注解">1. 常用注解</h2>
<p>SpringBoot摒弃XML配置方式，改为<strong>全注解驱动</strong></p>
<h3 id="1-组件注册">1. 组件注册</h3>
<p><strong>@Configuration</strong>、<strong>@SpringBootConfiguration</strong><br>
<strong>@Bean</strong>、<strong>@Scope</strong><br>
<strong>@Controller、 @Service、@Repository、@Component</strong><br>
<strong>@Import</strong><br>
@ComponentScan<br>
步骤：<br>
<strong>1、@Configuration 编写一个配置类</strong><br>
<strong>2、在配置类中，自定义方法给容器中注册组件。配合@Bean</strong><br>
<strong>3、或使用@Import 导入第三方的组件</strong></p>
<h3 id="2-条件注解">2. 条件注解</h3>
<p>如果注解指定的<strong>条件成立</strong>，则触发指定行为<br>
<em><strong>@ConditionalOnXxx</strong></em><br>
<strong>@ConditionalOnClass：如果类路径中存在这个类，则触发指定行为</strong><br>
<strong>@ConditionalOnMissingClass：如果类路径中不存在这个类，则触发指定行为</strong><br>
<strong>@ConditionalOnBean：如果容器中存在这个Bean（组件），则触发指定行为</strong><br>
<strong>@ConditionalOnMissingBean：如果容器中不存在这个Bean（组件），则触发指定行为</strong><br>
场景：</p>
<ul>
<li>如果存在FastsqlException这个类，给容器中放一个Cat组件，名cat01，</li>
<li>否则，就给容器中放一个Dog组件，名dog01</li>
<li>如果系统中有dog01这个组件，就给容器中放一个 User组件，名zhangsan</li>
<li>否则，就放一个User，名叫lisi</li>
</ul>
<p><strong>@ConditionalOnBean（value=组件类型，name=组件名字）：判断容器中是否有这个类型的组件，并且名字是指定的值</strong></p>
<p>@ConditionalOnRepositoryType (org.springframework.boot.autoconfigure.data)<br>
@ConditionalOnDefaultWebSecurity (org.springframework.boot.autoconfigure.security)<br>
@ConditionalOnSingleCandidate (org.springframework.boot.autoconfigure.condition)<br>
@ConditionalOnWebApplication (org.springframework.boot.autoconfigure.condition)<br>
@ConditionalOnWarDeployment (org.springframework.boot.autoconfigure.condition)<br>
@ConditionalOnJndi (org.springframework.boot.autoconfigure.condition)<br>
@ConditionalOnResource (org.springframework.boot.autoconfigure.condition)<br>
@ConditionalOnExpression (org.springframework.boot.autoconfigure.condition)<br>
<strong>@ConditionalOnClass</strong> (org.springframework.boot.autoconfigure.condition)<br>
@ConditionalOnEnabledResourceChain (<a target="_blank" rel="noopener" href="http://org.springframework.boot.autoconfigure.web">org.springframework.boot.autoconfigure.web</a>)<br>
<strong>@ConditionalOnMissingClass</strong>(org.springframework.boot.autoconfigure.condition)<br>
@ConditionalOnNotWebApplication (org.springframework.boot.autoconfigure.condition)<br>
@ConditionalOnProperty (org.springframework.boot.autoconfigure.condition)<br>
@ConditionalOnCloudPlatform (org.springframework.boot.autoconfigure.condition)<br>
<strong>@ConditionalOnBean</strong> (org.springframework.boot.autoconfigure.condition)<br>
<strong>@ConditionalOnMissingBean</strong> (org.springframework.boot.autoconfigure.condition)<br>
@ConditionalOnMissingFilterBean (org.springframework.boot.autoconfigure.web.servlet)<br>
@Profile (org.springframework.context.annotation)<br>
@ConditionalOnInitializedRestarter (org.springframework.boot.devtools.restart)<br>
@ConditionalOnGraphQlSchema (org.springframework.boot.autoconfigure.graphql)<br>
@ConditionalOnJava (org.springframework.boot.autoconfigure.condition)</p>
<h3 id="3-属性绑定">3. 属性绑定</h3>
<p><strong>@ConfigurationProperties： 声明组件的属性和配置文件哪些前缀开始项进行绑定</strong><br>
<strong>@EnableConfigurationProperties：快速注册注解：</strong></p>
<ul>
<li><strong>场景：<strong>SpringBoot默认只扫描自己主程序所在的包。如果导入第三方包，即使组件上标注了 @Component、@ConfigurationProperties 注解，也没用。因为组件都扫描不进来，此时使用这个注解就可以快</strong>速进行属性绑定并把组件注册进容器</strong></li>
</ul>
<p>将容器中任意<strong>组件（Bean）的属性值</strong>和<strong>配置文件</strong>的配置项的值<strong>进行绑定</strong></p>
<ul>
<li><strong>1、给容器中注册组件（@Component、@Bean）</strong></li>
<li><strong>2、使用@ConfigurationProperties 声明组件和配置文件的哪些配置项进行绑定</strong></li>
</ul>
<p>更多注解参照：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gW411W7wy">Spring注解驱动开发</a>【1-26集】</p>
<h2 id="待复习常用注解（视频1-26集）：">待复习常用注解（视频1-26集）：</h2>
<h3 id="核心容器：">核心容器：</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1689338993030-dddbdbb3-8d2a-4fb6-99df-400c6bffe713.png#averageHue=%23f6f9f6&amp;clientId=u50cc7f0e-9aa6-4&amp;from=paste&amp;height=117&amp;id=u6123668b&amp;originHeight=146&amp;originWidth=414&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=22183&amp;status=done&amp;style=none&amp;taskId=u609bdd38-2b1f-48b5-86cc-fdde5105864&amp;title=&amp;width=331.2" alt="image.png"></p>
<h3 id="组件注册：">组件注册：</h3>
<h4 id="Congfiguration">@Congfiguration:</h4>
<p>基于xml的注入方式，需要根据<bean>标签逐渐赋值注入容器的。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1689341306219-26dac878-fe79-4a28-9b71-acf8d3693b8c.png#averageHue=%23f7fcfb&amp;clientId=u50cc7f0e-9aa6-4&amp;from=paste&amp;height=21&amp;id=u5063fa94&amp;originHeight=26&amp;originWidth=468&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=15894&amp;status=done&amp;style=none&amp;taskId=u791ed171-4320-4022-8d64-0e763d147b7&amp;title=&amp;width=374.4" alt="image.png">都有注入容器的功能</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.example.annotationstudy.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.core.io.Resource;</span><br><span class="line">import org.springframework.core.type.AnnotationMetadata;</span><br><span class="line">import org.springframework.core.type.ClassMetadata;</span><br><span class="line">import org.springframework.core.type.classreading.MetadataReader;</span><br><span class="line">import org.springframework.core.type.classreading.MetadataReaderFactory;</span><br><span class="line">import org.springframework.core.type.filter.TypeFilter;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.lang.annotation.Annotation;</span><br><span class="line"></span><br><span class="line">public class MytypeFilter implements TypeFilter</span><br><span class="line">    &#123;</span><br><span class="line">    @Override</span><br><span class="line">//    MetadataReader读取到当前真正扫描的类，MetadataReaderFactory可以获取其他任何类的信息</span><br><span class="line">    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException</span><br><span class="line">    &#123;</span><br><span class="line">//        获取当前正在扫描的类的注解信息</span><br><span class="line">        AnnotationMetadata annotation= metadataReader.getAnnotationMetadata();</span><br><span class="line">        //获取当前真正扫描类的类信息，比如它的类型是什么，实现了什么接口</span><br><span class="line">         ClassMetadata classMetadata = metadataReader.getClassMetadata();</span><br><span class="line">        //获取当前类资源信息(类路径）</span><br><span class="line">       Resource resource =  metadataReader.getResource();</span><br><span class="line">       String className =classMetadata.getClassName();</span><br><span class="line">        System.out.println(&quot;---&gt;&quot;+className);</span><br><span class="line">        if(className.contains(&quot;er&quot;))</span><br><span class="line">        return  true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">package com.example.annotationstudy;</span><br><span class="line"></span><br><span class="line">import com.example.annotationstudy.config.test;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line">//SpringApplication.run(AnnotationStudyApplication.class, args);</span><br><span class="line">public class AnnotationStudyApplication</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        ApplicationContext applicationContext =  new AnnotationConfigApplicationContext(test.class);</span><br><span class="line">        System.out.println( applicationContext.getBean(Person.class));</span><br><span class="line">        String[] nameType = applicationContext.getBeanNamesForType(Person.class);//查看Person类的Bean数组在容器中的id数组</span><br><span class="line">        for (String string:nameType)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//    Person&#123;name=&#x27;1&#x27;, age=1&#125;</span><br><span class="line">//     person1</span><br><span class="line">@Test</span><br><span class="line">public void  test01()</span><br><span class="line">&#123;</span><br><span class="line">    ApplicationContext applicationContext =  new AnnotationConfigApplicationContext(test.class);</span><br><span class="line">    String[] nameType = applicationContext.getBeanDefinitionNames();//查看Person类的Bean数组在容器中的id数组</span><br><span class="line">    for (String string:nameType)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*没有加过滤器前的结果：</span><br><span class="line">test//@Configuration注入的组件,@Configuration注解有@Component修饰</span><br><span class="line">bookController//@Controller注入的组件</span><br><span class="line">bookDao//@Repository注入的组件</span><br><span class="line">bookService//@Service注入的组件</span><br><span class="line">person//  @Bean(&quot;person&quot;)注入的组件</span><br><span class="line">*/</span><br><span class="line">/*加了过滤器:</span><br><span class="line">test</span><br><span class="line">bookDao</span><br><span class="line">bookService</span><br><span class="line">person*/</span><br><span class="line">/*自定义过滤规则的输出结果</span><br><span class="line">---&gt;com.example.annotationstudy.AnnotationStudyApplication</span><br><span class="line">---&gt;com.example.annotationstudy.config.MytypeFilter</span><br><span class="line">---&gt;com.example.annotationstudy.controller.BookController</span><br><span class="line">---&gt;com.example.annotationstudy.dao.BookDao</span><br><span class="line">---&gt;com.example.annotationstudy.Person</span><br><span class="line">---&gt;com.example.annotationstudy.service.bookService</span><br><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">        test</span><br><span class="line">bookDao</span><br><span class="line">        person</span><br><span class="line"></span><br><span class="line">进程已结束,退出代码0*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.example.annotationstudy.config;</span><br><span class="line"></span><br><span class="line">import com.example.annotationstudy.Person;</span><br><span class="line">import com.example.annotationstudy.service.bookService;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.FilterType;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line">//配置类===配置文件</span><br><span class="line">@Configuration//告诉spring这是一个配置类</span><br><span class="line">@ComponentScan(value=&quot;com.example.annotationstudy&quot;,</span><br><span class="line">        includeFilters = &#123;@ComponentScan.Filter(type = FilterType.CUSTOM,classes = MytypeFilter.class)&#125;)</span><br><span class="line">//将Controller注解过滤掉</span><br><span class="line">//类似xml中的包扫描标签<span class="tag">&lt;<span class="name">context:component-sacn</span> <span class="attr">base-package</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">//@ComponentScan value（数组类型）指定要扫描的包， Filter[] excludeFilters();指定过滤规则；</span><br><span class="line">// Filter[] includeFilters()指定扫描只包含哪些注解</span><br><span class="line">//FilterType.ANNOTATION按照给定的注解加载（type = FilterType.ANNOTATION,classes = Controller.class)排除/只加载Contorller注解</span><br><span class="line">//FilterType.ASSIGNABLE_TYPE按照给定类型加载,type = FilterType.ASSIGNABLE_TYPE,classes = bookService.class排除/只加载bookService类型的bean</span><br><span class="line">//FilterType.REGEX按照正则表达式，</span><br><span class="line">//FilterType.CUSTOM;使用自定义规则；@ComponentScan.Filter(type = FilterType.CUSTOM,classes = MytypeFilter.class)</span><br><span class="line">//MytypeFilter.class返回ture或false决定是否排除/加载类到容器，如果为ture就加载/排除bean到容器内，其中value指定的路径下所有的类</span><br><span class="line">// 都会在MytypeFilter中进行判断，看能否加入到容器中</span><br><span class="line">public class test</span><br><span class="line">&#123;</span><br><span class="line">//    给容器中注册一个bean,类型为方法的返回值的类型，id默认为方法名作为id,其中该注解的vaule值赋值id的优先级高于方法名</span><br><span class="line">    @Bean(&quot;person&quot;)//也可以这样给bean赋值为person,最后这里注入bean的id是person;类似xml中的bean标签</span><br><span class="line">    public Person person1()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Person(&quot;1&quot;,1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-完整流程">2. 完整流程</h2>
<p>思考：<br>
<strong>1、SpringBoot怎么实现导一个starter、写一些简单配置，应用就能跑起来，我们无需关心整合</strong><br>
2、为什么Tomcat的端口号可以配置在application.properties中，并且Tomcat能启动成功？<br>
3、导入场景后哪些<strong>自动配置能生效</strong>？<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1679970508234-3c6b8ecc-6372-4eb5-8c67-563054d1a72d.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_37%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23b9b985&amp;from=url&amp;id=Xvkxy&amp;originHeight=583&amp;originWidth=1281&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p><em><strong>自动配置流程细节梳理：</strong></em><br>
**1、**导入starter-web：导入了web开发场景</p>
<ul>
<li>1、场景启动器导入了相关场景的所有依赖：starter-json、starter-tomcat、springmvc</li>
<li>2、每个场景启动器都引入了一个spring-boot-starter，核心场景启动器。</li>
<li>3、<strong>核心场景启动器</strong>引入了spring-boot-autoconfigure包。</li>
<li>4、spring-boot-autoconfigure里面囊括了所有场景的所有配置。</li>
<li>5、只要这个包下的所有类都能生效，那么相当于SpringBoot官方写好的整合功能就生效了。</li>
<li>6、SpringBoot默认却扫描不到 spring-boot-autoconfigure下写好的所有<strong>配置类</strong>。（这些<strong>配置类</strong>给我们做了整合操作），<strong>默认只扫描主程序所在的包</strong>。</li>
</ul>
<p><strong>2、主程序</strong>：@SpringBootApplication</p>
<ul>
<li>1、@SpringBootApplication由三个注解组成@SpringBootConfiguration、@EnableAutoConfiguratio、@ComponentScan</li>
<li>2、SpringBoot默认只能扫描自己主程序所在的包及其下面的子包，扫描不到 spring-boot-autoconfigure包中官方写好的<strong>配置类</strong></li>
<li>3、<strong>@EnableAutoConfiguration</strong>：SpringBoot <strong>开启自动配置的核心</strong>。
<ul>
<li>
<ol>
<li>是由@Import(AutoConfigurationImportSelector.class){，@Import是一个注解，允许您将其他配置类导入到应用程序上下文中}提供功能：批量给容器中导入组件。</li>
</ol>
</li>
<li>
<ol start="2">
<li>SpringBoot启动会默认加载 142个配置类。</li>
</ol>
</li>
<li>
<ol start="3">
<li>这<strong>142个配置类</strong>来自于spring-boot-autoconfigure下 META-INF/spring/<strong>org.springframework.boot.autoconfigure.AutoConfiguration</strong>.imports文件指定的</li>
</ol>
</li>
<li>项目启动的时候利用 @Import 批量导入组件机制把 autoconfigure 包下的142 xxxxAutoConfiguration类导入进来（<strong>自动配置类</strong>）</li>
<li>虽然导入了142个自动配置类</li>
</ul>
</li>
<li>4、按需生效：
<ul>
<li>并不是这142个自动配置类都能生效</li>
<li>每一个自动配置类，都有条件注解@ConditionalOnxxx，只有条件成立，才能生效</li>
</ul>
</li>
</ul>
<p><strong>3、xxxxAutoConfiguration自动配置类</strong></p>
<ul>
<li><strong>1、给容器中使用@Bean 放一堆组件。</strong></li>
<li>2、每个<strong>自动配置类</strong>都可能有这个注解@EnableConfigurationProperties(<strong>ServerProperties</strong>.class)，用来把配置文件中配的指定前缀的属性值封装到 xxxProperties<strong>属性类</strong>中</li>
<li>3、以Tomcat为例：把服务器的所有配置都是以server开头的。配置都封装到了属性类中。</li>
<li>4、给<strong>容器</strong>中放的所有<strong>组件</strong>的一些<strong>核心参数</strong>，都来自于<strong>xxxProperties。xxxProperties都是和配置文件绑定。</strong></li>
<li><strong>只需要改配置文件的值，核心组件的底层参数都能修改</strong></li>
</ul>
<p>**4、**写业务，全程无需关心各种整合（底层这些整合写好了，而且也生效了）</p>
<p><strong>核心流程总结：</strong><br>
1、导入starter，就会导入autoconfigure包。<br>
2、autoconfigure 包里面 有一个文件 META-INF/spring/<strong>org.springframework.boot.autoconfigure.AutoConfiguration</strong>.imports,里面指定的所有启动要加载的自动配置类<br>
3、@EnableAutoConfiguration 会自动的把上面文件里面写的所有<strong>自动配置类都导入进来。xxxAutoConfiguration 是有条件注解进行按需加载</strong><br>
4、xxxAutoConfiguration给容器中导入一堆组件，组件都是从 xxxProperties中提取属性值<br>
5、xxxProperties又是和<strong>配置文件</strong>进行了绑定<br>
**效果：**导入starter、修改配置文件，就能修改底层行为。</p>
<h2 id="2-YAML配置文件">2. YAML配置文件</h2>
<p><strong>痛点</strong>：SpringBoot 集中化管理配置，application.properties<br>
<strong>问题</strong>：配置多以后难阅读和修改，<strong>层级结构辨识度不高</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1689294105675-0b73afd6-0887-4d7c-9d56-9e988a84a0ae.png#averageHue=%23fbfaf9&amp;clientId=uc9135780-ac3d-4&amp;from=paste&amp;height=255&amp;id=uc7eaf023&amp;originHeight=319&amp;originWidth=357&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=56709&amp;status=done&amp;style=none&amp;taskId=u8e460c2b-84b7-458e-8da8-d7cc2244fd0&amp;title=&amp;width=285.6" alt="image.png"></p>
<p>YAML 是 “YAML Ain’t a Markup Language”（YAML 不是一种标记语言）。在开发的这种语言时，YAML 的意思其实是：“Yet Another Markup Language”（是另一种标记语言）。</p>
<ul>
<li>设计目标，就是<strong>方便人类读写</strong></li>
<li><strong>层次分明</strong>，更适合做配置文件</li>
<li>使用.yaml或 .yml作为文件后缀</li>
</ul>
<h3 id="1-基本语法">1. 基本语法</h3>
<ul>
<li><strong>大小写敏感</strong></li>
<li>使用<strong>缩进表示层级关系，k: v，使用空格分割k,v</strong></li>
<li>缩进时不允许使用Tab键，只允许<strong>使用空格</strong>。换行</li>
<li>缩进的空格数目不重要，只要<strong>相同层级</strong>的元素<strong>左侧对齐</strong>即可</li>
<li><strong># 表示注释</strong>，从这个字符一直到行尾，都会被解析器忽略。</li>
</ul>
<p>支持的写法：</p>
<ul>
<li><strong>对象</strong>：<strong>键值对</strong>的集合，如：映射（map）/ 哈希（hash） / 字典（dictionary）</li>
<li><strong>数组</strong>：一组按次序排列的值，如：序列（sequence） / 列表（list）</li>
<li><strong>纯量</strong>：单个的、不可再分的值，如：字符串、数字、bool、日期</li>
</ul>
<h3 id="2-示例">2. 示例</h3>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;person&quot;) //和配置文件person前缀的所有配置进行绑定，</span><br><span class="line">//ConfigurationProperties注解可以将配置文件中的属性映射到一个Java Bean中。</span><br><span class="line">@Data //自动生成JavaBean属性的getter/setter</span><br><span class="line">//@NoArgsConstructor //自动生成无参构造器</span><br><span class="line">//@AllArgsConstructor //自动生成全参构造器</span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Date birthDay;</span><br><span class="line">    private Boolean like;</span><br><span class="line">    private Child child; //嵌套对象</span><br><span class="line">    private List<span class="tag">&lt;<span class="name">Dog</span>&gt;</span> dogs; //数组（里面是对象）</span><br><span class="line">    private Map&lt;String,Cat&gt; cats; //表示Map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class Dog &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class Child &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Date birthDay;</span><br><span class="line">    private List<span class="tag">&lt;<span class="name">String</span>&gt;</span> text; //数组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class Cat &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>properties表示法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">person.name=张三</span><br><span class="line">person.age=18</span><br><span class="line">person.birthDay=2010/10/12 12:12:12</span><br><span class="line">person.like=true</span><br><span class="line">person.child.name=李四</span><br><span class="line">person.child.age=12</span><br><span class="line">person.child.birthDay=2018/10/12</span><br><span class="line">person.child.text[0]=abc</span><br><span class="line">person.child.text[1]=def</span><br><span class="line">person.dogs[0].name=小黑</span><br><span class="line">person.dogs[0].age=3</span><br><span class="line">person.dogs[1].name=小白</span><br><span class="line">person.dogs[1].age=2</span><br><span class="line">person.cats.c1.name=小蓝</span><br><span class="line">person.cats.c1.age=3</span><br><span class="line">person.cats.c2.name=小灰</span><br><span class="line">person.cats.c2.age=2</span><br></pre></td></tr></table></figure>
<p>yaml表示法：注意数组的写法：text和dogs两种写法，cat是map的写法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">person:</span><br><span class="line">  name: 张三</span><br><span class="line">  age: 18</span><br><span class="line">  birthDay: 2010/10/10 12:12:12</span><br><span class="line">  like: true</span><br><span class="line">  child:</span><br><span class="line">    name: 李四</span><br><span class="line">    age: 20</span><br><span class="line">    birthDay: 2018/10/10</span><br><span class="line">    text: [&quot;abc&quot;,&quot;def&quot;]</span><br><span class="line">#数组的2中写法，可以是text形式还可以是dogs的形式（每一个元素用一个-表示，下面的age是一个元素里</span><br><span class="line">#面的内容，要同级并没有-表示。</span><br><span class="line">  dogs:</span><br><span class="line">    - name: 小黑</span><br><span class="line">      age: 3</span><br><span class="line">    - name: 小白</span><br><span class="line">      age: 2</span><br><span class="line">  cats:</span><br><span class="line">    c1:</span><br><span class="line">      name: 小蓝</span><br><span class="line">      age: 3</span><br><span class="line">    c2: &#123;name: 小绿,age: 2&#125; #对象也可用&#123;&#125;表示</span><br></pre></td></tr></table></figure>
<h3 id="3-细节">3. 细节</h3>
<ul>
<li>birthDay 推荐写为 birth-day,@ConfigurationProperties(prefix = “person”) //和配置文件person前缀的所有配置进行绑定，</li>
<li><strong>文本</strong>：
<ul>
<li><strong>单引号</strong>不会转义【\n 则为普通字符串显示】</li>
<li><strong>双引号</strong>会转义【\n会显示为<strong>换行符</strong>】</li>
</ul>
</li>
<li><strong>大文本</strong>
<ul>
<li>|开头，大文本写在下层，<strong>保留文本格式</strong>，<strong>换行符正确显示</strong></li>
<li>
<blockquote>
<p>开头，大文本写在下层，折叠换行符</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>多文档合并</strong>
<ul>
<li>使用—可以把多个yaml文档合并在一个文档中，每个文档区依然认为内容独立</li>
</ul>
</li>
</ul>
<h3 id="4-小技巧：lombok">4. 小技巧：lombok</h3>
<p>简化JavaBean 开发。自动生成构造器、getter/setter、自动生成Builder模式等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>使用@Data等注解</p>
<h2 id="3-日志配置">3. 日志配置</h2>
<p>规范：项目开发不要编写System.out.println()，应该用<strong>日志</strong>记录信息<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1680232037132-d2fa8085-3847-46f2-ac62-14a6188492aa.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_29%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23b5c5db&amp;from=url&amp;id=ZTIkc&amp;originHeight=251&amp;originWidth=1029&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>
<strong>感兴趣日志框架关系与起源可参考</strong>：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gW411W76m">https://www.bilibili.com/video/BV1gW411W76m</a> 视频 21~27集</p>
<h3 id="1-简介">1. 简介</h3>
<ol>
<li>Spring使用commons-logging作为内部日志，但底层日志实现是开放的。可对接其他日志框架。
<ol>
<li>spring5及以后 commons-logging被spring直接自己写了。</li>
</ol>
</li>
<li>支持 jul，log4j2,logback。SpringBoot 提供了默认的控制台输出配置，也可以配置输出为文件。</li>
<li>logback是默认使用的。</li>
<li>虽然<strong>日志框架很多</strong>，但是我们不用担心，使用 SpringBoot 的<strong>默认配置就能工作的很好</strong>。</li>
</ol>
<p><strong>SpringBoot怎么把日志默认配置好的</strong><br>
1、每个starter场景，都会导入一个核心场景spring-boot-starter<br>
2、核心场景引入了日志的所用功能spring-boot-starter-logging（eg:spring-boot-starter-web-&gt;spring-boot-starter-&gt;spring-boot-starter-logging)<br>
3、默认使用了logback + slf4j 组合作为默认底层日志<br>
4、日志是系统一启动就要用，xxxAutoConfiguration是系统启动好了以后放好的组件，后来用的。<br>
5、日志是利用<strong>监听器机制</strong>配置好的。ApplicationListener。<br>
6、日志所有的配置都可以通过修改配置文件实现。以logging开始的所有配置。</p>
<h3 id="2-日志格式">2. 日志格式</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2023-03-31T13:56:17.511+08:00  INFO 4944 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]</span><br><span class="line">2023-03-31T13:56:17.511+08:00  INFO 4944 --- [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.7]</span><br></pre></td></tr></table></figure>
<p>默认输出格式：</p>
<ul>
<li>时间和日期：毫秒级精度</li>
<li>日志级别：ERROR,WARN,INFO,DEBUG, orTRACE.</li>
<li>进程 ID(可以在终端使用jps列出当前java程序的进程）</li>
<li>—： 消息分割符</li>
<li>线程名： 使用[]包含</li>
<li>Logger 名： 通常是产生日志的<strong>类名</strong></li>
<li>消息： 日志记录的内容</li>
</ul>
<p>注意： logback 没有FATAL级别，对应的是ERROR<br>
默认值：参照：spring-boot包additional-spring-configuration-metadata.json文件<br>
默认输出格式值：%clr(%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd’T’HH:mm:ss.SSSXXX}}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(—){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}<br>
可修改为：‘%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level [%thread] %logger{15} ===&gt; %msg%n’</p>
<h3 id="3-记录日志">3. 记录日志</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Logger logger = LoggerFactory.getLogger(getClass());//使用日志工厂生成日志类</span><br><span class="line"> log.info(&quot;info 日志..... 参数a:&#123;&#125; b:&#123;&#125;&quot;,a,b);</span><br><span class="line">或者使用Lombok的@Slf4j注解,在该类上使用，就可以不用日志工厂生成日志类直接使用log</span><br></pre></td></tr></table></figure>
<h3 id="4-日志级别">4. 日志级别</h3>
<ul>
<li>由低到高：ALL,TRACE, DEBUG, INFO, WARN, ERROR,FATAL,OFF；
<ul>
<li><strong>只会打印指定级别及以上级别的日志</strong></li>
<li>ALL：打印所有日志</li>
<li>TRACE：追踪框架详细流程日志，一般不使用</li>
<li>DEBUG：开发调试细节日志</li>
<li>INFO：关键、感兴趣信息日志</li>
<li>WARN：警告但不是错误的信息日志，比如：版本过时</li>
<li>ERROR：业务错误日志，比如出现各种异常</li>
<li>FATAL：致命错误日志，比如jvm系统崩溃</li>
<li>OFF：关闭所有日志记录</li>
</ul>
</li>
<li>不指定级别的所有类，都使用root指定的级别作为默认级别</li>
<li>SpringBoot日志<strong>默认级别是 INFO</strong></li>
</ul>
<ol>
<li>在application.properties/yaml中配置logging.level.<logger-name>=<level>指定日志级别</li>
<li>level可取值范围：TRACE, DEBUG, INFO, WARN, ERROR, FATAL, or OFF，定义在 LogLevel类中</li>
<li>root 的logger-name叫root，可以配置logging.level.root=warn，代表所有未指定日志级别都使用 root 的 warn 级别</li>
</ol>
<h3 id="5-日志分组">5. 日志分组</h3>
<p>比较有用的技巧是：<br>
将相关的logger分组在一起，统一配置。SpringBoot 也支持。比如：Tomcat 相关的日志统一设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logging.group.tomcat=org.apache.catalina,org.apache.coyote,org.apache.tomcat</span><br><span class="line">//这里是将org.apache.catalina,org.apache.coyote,org.apache.tomcat2个包当成一个组为tomcat</span><br><span class="line">logging.level.tomcat=trace</span><br><span class="line">//这里是将tomcat组的日志级别设置为trace级别</span><br></pre></td></tr></table></figure>
<p>SpringBoot 预定义两个组</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Loggers</th>
</tr>
</thead>
<tbody>
<tr>
<td>web</td>
<td>org.springframework.core.codec,org.springframework.http,<a target="_blank" rel="noopener" href="http://org.springframework.web">org.springframework.web</a>,<a target="_blank" rel="noopener" href="http://org.springframework.boot.actuate.endpoint.web">org.springframework.boot.actuate.endpoint.web</a>,org.springframework.boot.web.servlet.ServletContextInitializerBeans</td>
</tr>
<tr>
<td>sql</td>
<td>org.springframework.jdbc.core,org.hibernate.SQL,org.jooq.tools.LoggerListener</td>
</tr>
</tbody>
</table>
<h3 id="6-文件输出">6. 文件输出</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> #指定文件路径路径，日志文件默认叫spring.log</span><br><span class="line">#logging.file.path=D:\\</span><br><span class="line">#指定日志文件的名，只写名字就在当前项目的同位置生成相对应的日志文件。</span><br><span class="line">#也可以写名字+路径，就会在指定的路径下生成相应的日志文件然后把日志写进去</span><br><span class="line">logging.file.name </span><br><span class="line">#file.name和file.path同时存在,只有file.name生效</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>SpringBoot 默认只把日志写在控制台，如果想额外记录到文件，<a target="_blank" rel="noopener" href="http://xn--application-2u0r773cbuk.xn--propertieslogging-4g60al23dy78j.file.name">可以在application.properties中添加logging.file.name</a> or logging.file.path配置项。</p>
<table>
<thead>
<tr>
<th><a target="_blank" rel="noopener" href="http://logging.file.name">logging.file.name</a></th>
<th>logging.file.path</th>
<th>示例</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>未指定</td>
<td>未指定</td>
<td></td>
<td>仅控制台输出</td>
</tr>
<tr>
<td><strong>指定</strong></td>
<td>未指定</td>
<td>my.log</td>
<td>写入指定文件。可以加路径</td>
</tr>
<tr>
<td>未指定</td>
<td><strong>指定</strong></td>
<td>/var/log</td>
<td>写入指定目录，文件名为spring.log</td>
</tr>
<tr>
<td><strong>指定</strong></td>
<td><strong>指定</strong></td>
<td></td>
<td>以logging.file.name为准</td>
</tr>
</tbody>
</table>
<h3 id="7-文件归档与滚动切割">7. 文件归档与滚动切割</h3>
<p>归档：每天的日志单独存到一个文档中。<br>
切割：每个文件10MB，超过大小切割成另外一个文件。</p>
<ol>
<li>每天的日志应该独立分割出来存档。如果使用logback（SpringBoot 默认整合），可以通过application.properties/yaml文件指定日志滚动规则。</li>
<li>如果是其他日志系统，需要自行配置（添加log4j2.xml或log4j2-spring.xml）</li>
<li>不用特意配置日志，会使用默认的日志</li>
<li>支持的滚动规则设置如下<br>
| 配置项 | 描述 |<br>
| — | — |<br>
| logging.logback.rollingpolicy.file-name-pattern | 日志存档的文件名（类似每天产生的日志单独生成在一个文件中） 格式（默认值：${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz） |<br>
| logging.logback.rollingpolicy.clean-history-on-start | 应用启动时是否清除以前存档（默认值：false） |<br>
| logging.logback.rollingpolicy.max-file-size | 存档前，每个日志文件的最大大小（默认值：10MB） |<br>
| logging.logback.rollingpolicy.total-size-cap | 日志文件被删除之前，可以容纳的最大大小（默认值：0B）。设置1GB则磁盘存储超过 1GB 日志后就会删除旧日志文件 |<br>
| logging.logback.rollingpolicy.max-history | 日志文件保存的最大天数(默认值：7). |</li>
</ol>
<h3 id="8-自定义配置">8. 自定义配置</h3>
<p>通常我们配置 application.properties 就够了。当然也可以自定义。比如：</p>
<table>
<thead>
<tr>
<th>日志系统</th>
<th>自定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Logback</td>
<td>logback-spring.xml,logback-spring.groovy,</td>
</tr>
<tr>
<td>logback.xml, or logback.groovy</td>
<td></td>
</tr>
<tr>
<td>Log4j2</td>
<td>log4j2-spring.xmlorlog4j2.xml</td>
</tr>
<tr>
<td>JDK (Java Util Logging)</td>
<td>logging.properties</td>
</tr>
</tbody>
</table>
<p>如果可能，我们建议您在日志配置中使用-spring 变量（例如，logback-spring.xml 而不是 logback.xml）。如果您使用标准配置文件，spring 无法完全控制日志初始化。<br>
最佳实战：自己要写配置，配置文件名加上 xx-spring.xml</p>
<h3 id="9-切换日志组合">9. 切换日志组合</h3>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>log4j2支持yaml和json格式的配置文件</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>依赖</th>
<th>文件名</th>
</tr>
</thead>
<tbody>
<tr>
<td>YAML</td>
<td>com.fasterxml.jackson.core:jackson-databind+com.fasterxml.jackson.dataformat:jackson-dataformat-yaml</td>
<td>log4j2.yaml+log4j2.yml</td>
</tr>
<tr>
<td>JSON</td>
<td>com.fasterxml.jackson.core:jackson-databind</td>
<td>log4j2.json+log4j2.jsn</td>
</tr>
</tbody>
</table>
<h3 id="10-最佳实战">10. 最佳实战</h3>
<ol>
<li>导入任何第三方框架，先排除它的日志包，因为Boot底层控制好了日志</li>
<li>修改 application.properties 配置文件，就可以调整日志的所有行为。如果不够，可以编写日志框架自己的配置文件放在类路径下就行，比如logback-spring.xml，log4j2-spring.xml</li>
<li>如需对接<strong>专业日志系统</strong>，也只需要把 logback 记录的<strong>日志</strong>灌倒** kafka**之类的中间件，这和SpringBoot没关系，都是日志框架自己的配置，<strong>修改配置文件即可</strong></li>
<li><strong>业务中使用slf4j-api记录日志。不要再 sout 了</strong></li>
</ol>
<h1>2、SpringBoot3-Web开发</h1>
<p>SpringBoot的Web开发能力，由<strong>SpringMVC</strong>提供。</p>
<h2 id="1-Web场景">1. Web场景</h2>
<p>1、整合web场景</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>2、引入了 autoconfigure功能（是spring-boot-starter-web下的spring-boot-starter里面的一个依赖）<br>
3、springboot起点的时候会加载一个@EnableAutoConfiguration注解（@SpringBootApplication注解里被@EnableAutoConfiguration注解修饰）。@EnableAutoConfiguration注解使用@Import(AutoConfigurationImportSelector.class)批量导入组件，加载 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 文件中配置的所有组件<br>
5、所有自动配置类如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration</span><br><span class="line">====以下是响应式web场景和现在的没关系======</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.ReactiveMultipartAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.WebSessionIdResolverAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration</span><br><span class="line">================以上没关系=================</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration</span><br></pre></td></tr></table></figure>
<p>6、绑定了配置文件的一堆配置项</p>
<ul>
<li>1、SpringMVC的所有配置 spring.mvc</li>
<li>2、Web场景通用配置 <a target="_blank" rel="noopener" href="http://spring.web">spring.web</a></li>
<li>3、文件上传配置 spring.servlet.multipart</li>
<li>4、服务器的配置 server: 比如：编码方式</li>
</ul>
<h2 id="2-默认效果">2. 默认效果</h2>
<p>默认配置：</p>
<ol>
<li>包含了 ContentNegotiatingViewResolver 和 BeanNameViewResolver 组件，<strong>方便视图解析</strong></li>
<li><strong>默认的静态资源处理机制</strong>： 静态资源放在 static 文件夹下即可直接访问</li>
<li><strong>自动注册</strong>了 <strong>Converter</strong>,GenericConverter,<strong>Formatter</strong>组件，适配常见<strong>数据类型转换</strong>和<strong>格式化需求</strong></li>
<li><strong>支持 HttpMessageConverters</strong>，可以<strong>方便返回</strong>json等<strong>数据类型（比如：</strong>@RestController 注解会自动将处理方法的返回值序列化为 JSON式的响应体，并将其发送给客户端。）</li>
<li><strong>注册 <strong>MessageCodesResolver，方便</strong>国际化</strong>及错误消息处理</li>
<li><strong>支持 静态</strong>index.html</li>
<li><strong>自动使用</strong>ConfigurableWebBindingInitializer，实现消息处理、数据绑定（比如将前段传递过来的参数和某些bean绑定)、类型转化、数据校验等功能</li>
</ol>
<p><strong>重要：</strong></p>
<ul>
<li><em>如果想保持 <em><strong><em>boot mvc 的默认配置</em></strong></em>，并且自定义更多的 mvc 配置，如：</em><strong><em>interceptors</em></strong><em>, <em><strong><em>formatters</em></strong></em>, <em><strong><em>view controllers</em></strong></em> 等。可以使用@Configuration注解添加一个 WebMvcConfigurer 类型的配置类，并不要标注 @EnableWebMvc</em></li>
<li><em>如果想保持 boot mvc 的默认配置，但要自定义核心组件实例，比如：RequestMappingHandlerMapping, RequestMappingHandlerAdapter, 或ExceptionHandlerExceptionResolver，给容器中放一个 WebMvcRegistrations 组件即可</em></li>
<li><em>如果想全面接管 Spring MVC，@Configuration 标注一个配置类，并加上 @EnableWebMvc注解，</em></li>
<li><em>实现 WebMvcConfigurer 接口</em></li>
</ul>
<h2 id="WebMvcAutoConfiguration原理">WebMvcAutoConfiguration原理</h2>
<p>WebMvcAutoConfiguration 是 Spring Boot 中的一个自动配置类，它负责自动配置 Spring MVC（Model-View-Controller）的相关功能。<br>
在 Spring Boot 应用程序中，当您引入了 spring-boot-starter-web  依赖时，WebMvcAutoConfiguration 将自动生效。它会根据应用程序的类路径和配置属性来自动配置 Spring MVC。它是@EnableAutoConfiguration注解使用@Import(AutoConfigurationImportSelector.class)批量导入组件中的一个组件。</p>
<h3 id="1-生效条件">1. 生效条件</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@AutoConfiguration(after = &#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span><br><span class="line">		ValidationAutoConfiguration.class &#125;) //在这些自动配置之后,</span><br><span class="line">@ConditionalOnWebApplication(type = Type.SERVLET) //如果是web应用就生效，类型是SERVLETweb，其他还有、REACTIVE 响应式web</span><br><span class="line">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span><br><span class="line">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class) //容器中没有这个Bean，才生效。默认就是没有</span><br><span class="line">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)//优先级</span><br><span class="line">@ImportRuntimeHints(WebResourcesRuntimeHints.class)</span><br><span class="line">public class WebMvcAutoConfiguration &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-WebMvcAutoConfiguration产生的效果">2. WebMvcAutoConfiguration产生的效果</h3>
<ol>
<li>放了两个Filter：
<ol>
<li>HiddenHttpMethodFilter；页面表单提交Rest请求（GET、POST、PUT、DELETE）<a target="_blank" rel="noopener" href="https://blog.csdn.net/geloin/article/details/7444321">Spring MVC过滤器-HiddenHttpMethodFilter_Korbin Luo的博客-CSDN博客</a></li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">某些场景下，例如 HTML 表单只支持 GET 和 POST 方法，无法直接发送 PUT 或 DELETE 请求。</span><br><span class="line">为了解决这个问题，Spring Framework 提供了 HiddenHttpMethodFilter 过滤器。</span><br><span class="line">HiddenHttpMethodFilter 允许您在 HTML 表单中使用一个隐藏字段（通常命名为 &quot;_method&quot;）</span><br><span class="line">来指定要使用的 HTTP 方法，例如 PUT 或 DELETE。当表单提交时，过滤器会检查隐藏字段的值，并将请求方法转换为相应的 HTTP 方法。</span><br><span class="line">&lt;form action=&quot;/example&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot;&gt;</span><br><span class="line">    &lt;!-- 其他表单字段 --&gt;</span><br><span class="line">    &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">在上面的示例中，隐藏字段 _method 的值被设置为 &quot;put&quot;，表示要使用 PUT 方法进行请求。</span><br><span class="line">在您的控制器方法中，使用 @RequestMapping 注解或其他合适的注解来处理相应的请求方法。</span><br><span class="line">@RequestMapping(value = &quot;/example&quot;, method = RequestMethod.PUT)</span><br><span class="line">public ResponseEntity&lt;String&gt; updateExample() &#123;</span><br><span class="line">    // 处理 PUT 请求</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>FormContentFilter： 表单内容Filter，GET（数据放URL后面）、POST（数据放请求体）请求可以携带数据，PUT、DELETE 的请求体数据会被忽略.为了让put和delete的请求体内容不会被忽略，可以加一个FormContentFilter。</li>
<li>给容器中放了WebMvcConfigurer组件（WebMvcAutoConfigurationAdapter）；给SpringMVC添加各种定制功能</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	@Configuration(proxyBeanMethods = false)</span><br><span class="line">	@Import(EnableWebMvcConfiguration.class) //额外导入了其他配置</span><br><span class="line">	@EnableConfigurationProperties(&#123; WebMvcProperties.class, WebProperties.class &#125;)</span><br><span class="line">	@Order(0)</span><br><span class="line">	public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer, </span><br><span class="line">ServletContextAware&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>所有的功能最终会和配置文件进行绑定</li>
<li>WebMvcProperties： spring.mvc配置文件</li>
<li>WebProperties： spring.web配置文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(</span><br><span class="line">prefix = &quot;spring.mvc&quot;</span><br><span class="line">)//@ConfigurationProperties 注解的 prefix 属性被设置为 &quot;spring.mvc&quot;，表示要绑定以</span><br><span class="line">&quot;spring.mvc&quot; 开头的配置属性。</span><br><span class="line">使用 @ConfigurationProperties 注解可以将配置文件中的属性值与 Java 类中的字段或方法关联起来，</span><br><span class="line">从而方便地获取、设置和管理配置属性。</span><br></pre></td></tr></table></figure>
<h3 id="WebMvcConfigurer接口">WebMvcConfigurer接口</h3>
<p>WebMvcAutoConfiguration中的WebMvcAutoConfigurationAdapter属性实现了该接口。<br>
提供了配置SpringMVC底层的所有组件入口<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681093891854-26205c88-4c20-4b63-a2c3-02574778072f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_36%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23faf8f6&amp;from=url&amp;id=zLAUH&amp;originHeight=497&amp;originWidth=1267&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h3 id="2-静态资源">2. 静态资源</h3>
<h4 id="1-默认规则">1. 默认规则</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">    if (!this.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">        logger.debug(&quot;Default resource handling disabled&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //1、</span><br><span class="line">    addResourceHandler(registry, this.mvcProperties.getWebjarsPathPattern(),</span><br><span class="line">            &quot;classpath:/META-INF/resources/webjars/&quot;);</span><br><span class="line">    addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;</span><br><span class="line">        registration.addResourceLocations(this.resourceProperties.getStaticLocations());</span><br><span class="line">        if (this.servletContext != null) &#123;</span><br><span class="line">            ServletContextResource resource = new ServletContextResource(this.servletContext, SERVLET_LOCATION);</span><br><span class="line">            registration.addResourceLocations(resource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">//</span><br></pre></td></tr></table></figure>
<ol>
<li>规则一：访问： /webjars/**路径就去 classpath:/META-INF/resources/webjars/下找资源.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/webjars/ 是一个特定的路径前缀，用于在Web应用程序中访问 WebJars 资源。</span><br><span class="line"></span><br><span class="line">WebJars 是一种将前端库以 JAR 文件的形式打包并发布到 Maven 仓库的方式。它们允许您通过 Maven </span><br><span class="line">或 Gradle 等构建工具来管理和引入前端库，就像管理其他 Java 依赖项一样。</span><br><span class="line"></span><br><span class="line">当您在 Maven 项目中引入 WebJars 依赖时，它们将被下载并存储在您的项目的 Maven 依赖目录中。</span><br><span class="line">为了在 Web 应用程序中有效地访问这些资源，Spring Boot 提供了一个特殊的处理器来映射 /webjars/</span><br><span class="line">路径。</span><br></pre></td></tr></table></figure>
<ol>
<li>maven 导入依赖</li>
<li>规则二：访问： /**路径就去 静态资源默认的四个位置找资源
<ol>
<li>classpath:/META-INF/resources/</li>
<li>classpath:/resources/</li>
<li>classpath:/static/</li>
<li>classpath:/public/</li>
</ol>
</li>
<li>规则三：<strong>静态资源默认都有缓存规则的设置</strong>
<ol>
<li>所有缓存的设置，直接通过<strong>配置文件</strong>： <a target="_blank" rel="noopener" href="http://spring.web">spring.web</a></li>
<li>cachePeriod： 缓存周期； 多久不用找服务器要新的。 默认没有，以s为单位</li>
<li>cacheControl： <strong>HTTP缓存</strong>控制；<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching#%E6%A6%82%E8%A7%88">https://develop er.mozilla.org/zh-CN/docs/Web/HTTP/Caching</a></li>
<li><strong>useLastModified</strong>：是否使用最后一次修改。配合HTTP Cache规则</li>
</ol>
</li>
</ol>
<p>如果浏览器访问了一个静态资源 index.js，如果服务这个资源没有发生变化，下次访问的时候就可以直接让浏览器用自己缓存中的东西，而不用给服务器发请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">registration.setCachePeriod(getSeconds(this.resourceProperties.getCache().getPeriod()));</span><br><span class="line">registration.setCacheControl(this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl());</span><br><span class="line">registration.setUseLastModified(this.resourceProperties.getCache().isUseLastModified());</span><br></pre></td></tr></table></figure>
<h4 id="1-静态资源映射">1. 静态资源映射</h4>
<p>静态资源映射规则在WebMvcAutoConfiguration中进行了定义：</p>
<ol>
<li>/webjars/**的所有路径 资源都在classpath:/META-INF/resources/webjars/</li>
<li>/**的所有路径 资源都在classpath:/META-INF/resources/、classpath:/resources/、classpath:/static/、classpath:/public/</li>
<li>所有静态资源都定义了缓存规则。【浏览器访问过一次，就会缓存一段时间】，但此功能参数无默认值
<ol>
<li>period： 缓存间隔。 默认 0S；</li>
<li>cacheControl：缓存控制。 默认无；</li>
<li>useLastModified：是否使用lastModified头。 默认 false；</li>
</ol>
</li>
</ol>
<h4 id="2-静态资源缓存">2. 静态资源缓存</h4>
<p>如前面所述</p>
<ol>
<li>所有静态资源都定义了缓存规则。【浏览器访问过一次，就会缓存一段时间】，但此功能参数无默认值
<ol>
<li>period： 缓存间隔。 默认 0S；</li>
<li>cacheControl：缓存控制。 默认无；</li>
<li>useLastModified：是否使用lastModified头。 默认 false；</li>
</ol>
</li>
</ol>
<h4 id="3-欢迎页">3. 欢迎页</h4>
<p>欢迎页规则在WebMvcAutoConfiguration中进行了定义：</p>
<ol>
<li>在<strong>静态资源</strong>目录下找 index.html</li>
<li>没有就在 templates下找index模板页</li>
</ol>
<h4 id="4-Favicon">4. Favicon</h4>
<ol>
<li>在静态资源目录下找 favicon.ico</li>
</ol>
<h4 id="5-缓存实验">5. 缓存实验</h4>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">9000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#1、spring.web：</span></span><br><span class="line"><span class="comment"># 1.配置国际化的区域信息</span></span><br><span class="line"><span class="comment"># 2.静态资源策略(开启、处理链、缓存)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#开启静态资源映射规则</span></span><br><span class="line"><span class="attr">spring.web.resources.add-mappings</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#设置缓存</span></span><br><span class="line"><span class="comment">#spring.web.resources.cache.period=3600</span></span><br><span class="line"><span class="comment">##缓存详细合并项控制，覆盖period配置：</span></span><br><span class="line"><span class="comment">## 浏览器第一次请求服务器，服务器告诉浏览器此资源缓存7200秒，7200秒以内的所有此资源访问</span></span><br><span class="line"><span class="comment">#不用发给服务器请求，7200秒以后发请求给服务器</span></span><br><span class="line"><span class="attr">spring.web.resources.cache.cachecontrol.max-age</span>=<span class="string">7200</span></span><br><span class="line"><span class="comment">#使用资源 last-modified 时间，来对比服务器和浏览器的资源是否相同没有变化。相同返回 304,默认开启</span></span><br><span class="line"><span class="attr">spring.web.resources.cache.use-last-modified</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<h3 id="2-自定义静态资源规则">2. 自定义静态资源规则</h3>
<p>自定义静态资源路径、自定义缓存规则</p>
<h4 id="1-配置方式">1. 配置方式</h4>
<p>spring.mvc： 静态资源访问前缀路径<br>
<a target="_blank" rel="noopener" href="http://spring.web">spring.web</a>：</p>
<ul>
<li>静态资源目录</li>
<li>静态资源缓存策略</li>
</ul>
<h4 id="2-代码方式">2. 代码方式</h4>
<ul>
<li>容器中只要有一个 WebMvcConfigurer 组件。配置的底层行为都会生效</li>
<li>@EnableWebMvc //禁用boot的默认配置</li>
</ul>
<h3 id="5-EnableWebMvcConfiguration-源码">5. EnableWebMvcConfiguration 源码</h3>
<p>也是WebMvcAutoConfiguration的内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SpringBoot 给容器中放 WebMvcConfigurationSupport 组件。</span></span><br><span class="line"><span class="comment">//我们如果自己放了 WebMvcConfigurationSupport 组件，Boot的WebMvcAutoConfiguration都会失效。</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(WebProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EnableWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title class_">DelegatingWebMvcConfiguration</span> <span class="keyword">implements</span> <span class="title class_">ResourceLoaderAware</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>HandlerMapping： 根据请求路径  找那个handler能处理请求</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f04816ee2495">SpringMVC工作原理之处理映射[HandlerMapping]</a><br>
SpringMVC 内部是根据 HandlerMapping 将 Request 和 Controller 里面的方法对应起来的</p>
<ol>
<li>WelcomePageHandlerMapping(webmvcAutoConfiguration里面注入所依赖的bean)：
<ol>
<li>访问 /**路径下的所有请求，都在以前四个静态资源路径下找，欢迎页也一样</li>
<li>找index.html：只要静态资源的位置有一个 index.html页面，项目启动默认访问（意思是如果静态资源里面有index.html，那么项目启动也就是根路径默认跳转到index.html）</li>
</ol>
</li>
</ol>
<h4 id="Favicon：网站图标">Favicon	：网站图标</h4>
<ol>
<li>在静态资源目录下找 favicon.ico</li>
</ol>
<p>理解：springboot启动成功后会在静态资源文件中寻找favicon.ico文件，如果存在这个文件就把网站的图标设置为这个，当然这里的favicon.ico文件名要正确。如果删除了favicon.ico文件，但是浏览器的图标仍然存在，那是因为浏览器的缓存机制缓存了该图标。</p>
<h4 id="5-缓存实验-2">5. 缓存实验</h4>
<p>1.跟缓存有关的配置是spring.web前缀的配置属性 。<br>
2.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties 是一个 Spring Boot 注解，用于将配置属性绑定到 Java 类的字段上。</span><br><span class="line"></span><br><span class="line">在 Spring Boot 应用程序中，配置属性通常存储在配置文件（如 application.properties </span><br><span class="line">或 application.yml）中。@ConfigurationProperties 注解可以使用在一个类上，用于将配置文件中的</span><br><span class="line">属性值绑定到该类的字段上，实现属性的自动注入。</span><br><span class="line">@ConfigurationProperties(&quot;spring.web&quot;)是将以 &quot;spring.web&quot; 为前缀的配置属性绑定到 Java 类</span><br><span class="line">的字段上。</span><br><span class="line">使用 @ConfigurationProperties 需要进行以下步骤：</span><br><span class="line">创建一个普通的 Java 类，该类的字段将用于存储配置属性的值。</span><br><span class="line">在该类上添加 @ConfigurationProperties 注解，并指定要绑定的配置属性的前缀。</span><br><span class="line">@Configuration</span><br><span class="line">@ConfigurationProperties(prefix = &quot;myapp&quot;)</span><br><span class="line">public class MyAppProperties &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String version;</span><br><span class="line">    // 其他属性及对应的 getter 和 setter 方法</span><br><span class="line">&#125;</span><br><span class="line">在上述示例中，MyAppProperties 类使用 @ConfigurationProperties 注解，并指定了 prefix 属性为</span><br><span class="line">&quot;myapp&quot;。这意味着该类的字段将与以 &quot;myapp&quot; 为前缀的配置属性进行绑定。</span><br><span class="line"></span><br><span class="line">假设在配置文件中有以下属性：</span><br><span class="line">myapp.name=My App</span><br><span class="line">myapp.version=1.0.0</span><br><span class="line">通过使用 @ConfigurationProperties 注解，可以将 &quot;My App&quot; 绑定到 name 字段上，</span><br><span class="line">将 &quot;1.0.0&quot; 绑定到 version 字段上。</span><br></pre></td></tr></table></figure>
<p>3.spring.web可以配置国际化的区域信息，配置静态资源策略（开启，处理链，缓存），</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server.port=9000</span><br><span class="line"></span><br><span class="line">#1、spring.web：</span><br><span class="line"># 1.配置国际化的区域信息</span><br><span class="line"># 2.静态资源策略(开启、处理链、缓存)</span><br><span class="line"></span><br><span class="line">#开启静态资源映射规则，默认结果为true,spring.web.resources.add-mappings和Resources类</span><br><span class="line">#的addMappings属性对应。</span><br><span class="line">spring.web.resources.add-mappings=true</span><br><span class="line"></span><br><span class="line">#设置缓存,设置了缓存时间为3600s</span><br><span class="line">#spring.web.resources.cache.period=3600</span><br><span class="line">##缓存详细合并项控制，覆盖period配置：</span><br><span class="line">## 浏览器第一次请求服务器，服务器告诉浏览器此资源缓存7200秒，7200秒以内的所有此资源访问不用发给服务器请求，7200秒以后发请求给服务器</span><br><span class="line">spring.web.resources.cache.cachecontrol.max-age=7200</span><br><span class="line">#使用资源 last-modified 时间，来对比服务器和浏览器的资源是否相同没有变化。相同返回 304</span><br><span class="line">spring.web.resources.cache.use-last-modified=true</span><br></pre></td></tr></table></figure>
<h2 id="2-自定义静态资源规则-2">2. 自定义静态资源规则</h2>
<p>自定义静态资源路径、自定义缓存规则</p>
<h3 id="1-配置方式-2">1. 配置方式</h3>
<p>spring.mvc： 静态资源访问前缀路径<br>
<a target="_blank" rel="noopener" href="http://spring.web">spring.web</a>：</p>
<ul>
<li>静态资源目录</li>
<li>静态资源缓存策略</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1、spring.web：</span></span><br><span class="line"><span class="comment"># 1.配置国际化的区域信息</span></span><br><span class="line"><span class="comment"># 2.静态资源策略(开启、处理链、缓存)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#开启静态资源映射规则</span></span><br><span class="line"><span class="attr">spring.web.resources.add-mappings</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#设置缓存</span></span><br><span class="line"><span class="attr">spring.web.resources.cache.period</span>=<span class="string">3600</span></span><br><span class="line"><span class="comment">##缓存详细合并项控制，覆盖period配置：</span></span><br><span class="line"><span class="comment">## 浏览器第一次请求服务器，服务器告诉浏览器此资源缓存7200秒，7200秒以内的所有此资源访问不用发给服务器请求，7200秒以后发请求给服务器</span></span><br><span class="line"><span class="attr">spring.web.resources.cache.cachecontrol.max-age</span>=<span class="string">7200</span></span><br><span class="line"><span class="comment">## 共享缓存，只要是这个客户端其他用户都可以使用这个缓存</span></span><br><span class="line"><span class="attr">spring.web.resources.cache.cachecontrol.cache-public</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#使用资源 last-modified 时间，来对比服务器和浏览器的资源是否相同没有变化。相同返回 304</span></span><br><span class="line"><span class="attr">spring.web.resources.cache.use-last-modified</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#自定义静态资源文件夹位置</span></span><br><span class="line"><span class="attr">spring.web.resources.static-locations</span>=<span class="string">classpath:/a/,classpath:/b/,classpath:/static/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#2、 spring.mvc</span></span><br><span class="line"><span class="comment">## 2.1. 自定义webjars路径前缀,以后访问/wj/**路径的时候会在/wedjars/**路径下寻找 </span></span><br><span class="line"><span class="attr">spring.mvc.webjars-path-pattern</span>=<span class="string">/wj/**</span></span><br><span class="line"><span class="comment">## 2.2. 静态资源访问路径前缀常和spring.web.resources.static-locations联合使用</span></span><br><span class="line"><span class="attr">spring.mvc.static-path-pattern</span>=<span class="string">/static/**</span></span><br></pre></td></tr></table></figure>
<h3 id="2-代码方式-2">2. 代码方式</h3>
<ul>
<li>容器中只要有一个 WebMvcConfigurer 组件。配置的底层行为都会生效</li>
<li>@EnableWebMvc //禁用boot的默认配置</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">//@EnableWebMvc</span> <span class="string">//禁用boot的默认配置，添加了就会禁用boot的默认配置的规则。</span></span><br><span class="line"><span class="attr">//，没有添加就会保留以前的规则和自己新写的规则</span></span><br><span class="line"><span class="attr">@Configuration</span> <span class="string">//这是一个配置类</span></span><br><span class="line"><span class="attr">public</span> <span class="string">class MyConfig implements WebMvcConfigurer &#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">@Override</span></span><br><span class="line">    <span class="attr">public</span> <span class="string">void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span></span><br><span class="line">        <span class="attr">//保留以前规则</span></span><br><span class="line">        <span class="attr">//自己写新的规则。</span></span><br><span class="line">        <span class="attr">registry.addResourceHandler(&quot;/static/**&quot;)</span></span><br><span class="line">                <span class="attr">.addResourceLocations(&quot;classpath</span>:<span class="string">/a/&quot;,&quot;classpath:/b/&quot;)</span></span><br><span class="line">                <span class="attr">.setCacheControl(CacheControl.maxAge(1180,</span> <span class="string">TimeUnit.SECONDS));</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">@Configuration</span> <span class="string">//这是一个配置类,给容器中放一个 WebMvcConfigurer 组件，就能自定义底层</span></span><br><span class="line"><span class="attr">public</span> <span class="string">class MyConfig  /*implements WebMvcConfigurer*/ &#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">@Bean</span></span><br><span class="line">    <span class="attr">public</span> <span class="string">WebMvcConfigurer webMvcConfigurer()&#123;</span></span><br><span class="line">        <span class="attr">return</span> <span class="string">new WebMvcConfigurer() &#123;</span></span><br><span class="line">            <span class="attr">@Override</span></span><br><span class="line">            <span class="attr">public</span> <span class="string">void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span></span><br><span class="line">                <span class="attr">registry.addResourceHandler(&quot;/static/**&quot;)</span></span><br><span class="line">                        <span class="attr">.addResourceLocations(&quot;classpath</span>:<span class="string">/a/&quot;, &quot;classpath:/b/&quot;)</span></span><br><span class="line">                        <span class="attr">.setCacheControl(CacheControl.maxAge(1180,</span> <span class="string">TimeUnit.SECONDS));</span></span><br><span class="line">            <span class="attr">&#125;</span></span><br><span class="line">        <span class="attr">&#125;;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="6-为什么容器中放一个WebMvcConfigurer就能配置底层行为">6. 为什么容器中放一个WebMvcConfigurer就能配置底层行为</h3>
<ol>
<li>WebMvcAutoConfiguration 是一个自动配置类，它里面有一个 EnableWebMvcConfiguration</li>
<li>EnableWebMvcConfiguration继承与 DelegatingWebMvcConfiguration，这两个都生效</li>
<li>DelegatingWebMvcConfiguration利用 ID 把容器中 所有 WebMvcConfigurer 注入进来</li>
<li>别人调用 <code>DelegatingWebMvcConfiguration</code> 的方法配置底层规则，而它调用所有 WebMvcConfigurer的配置底层方法。</li>
</ol>
<h2 id="3-路径匹配">3. 路径匹配</h2>
<p><strong>Spring5.3</strong> 之后加入了更多的请求路径匹配的实现策略；<br>
以前只支持 AntPathMatcher 策略, 现在提供了 <strong>PathPatternParser</strong>策略。并且可以让我们指定到底使用那种策略。</p>
<h3 id="1-Ant风格路径用法">1. Ant风格路径用法</h3>
<p>Ant 风格的路径模式语法具有以下规则：</p>
<ul>
<li>*：表示<strong>任意数量</strong>的字符。</li>
<li>?：表示任意<strong>一个字符</strong>。</li>
<li><strong>：表示</strong>任意数量的目录**。</li>
<li>{}：表示一个命名的模式<strong>占位符</strong>。</li>
<li>[]：表示<strong>字符集合</strong>，例如[a-z]表示小写字母。</li>
</ul>
<p>例如：</p>
<ul>
<li>*.html匹配任意名称，扩展名为.html的文件。</li>
<li>/folder1/<em>/</em>.java匹配在folder1目录下的任意两级目录下的.java文件。</li>
<li>/folder2/**/*.jsp匹配在folder2目录下任意目录深度的.jsp文件。</li>
<li>/{type}/{id}.html匹配任意文件名为{id}.html，在任意命名的{type}目录下的文件。</li>
</ul>
<p>注意：Ant 风格的路径模式语法中的特殊字符需要转义，如：</p>
<ul>
<li>要匹配文件路径中的星号，则需要转义为\*。</li>
<li>要匹配文件路径中的问号，则需要转义为\?。</li>
</ul>
<h3 id="2-模式切换">2. 模式切换</h3>
<h4 id="AntPathMatcher-与-PathPatternParser">AntPathMatcher 与 PathPatternParser</h4>
<ul>
<li>PathPatternParser在 jmh 基准测试下，有 6~8 倍吞吐量提升，降低 30%~40%空间分配率</li>
<li>PathPatternParser 兼容 AntPathMatcher语法，并支持更多类型的路径模式</li>
<li>PathPatternParser &quot;**<strong><strong>&quot; <strong>多段匹配</strong>的支持</strong>仅允许在模式末尾使用</strong></li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">@GetMapping(&quot;/a*/b?/&#123;p1</span>:<span class="string">[a-f]+&#125;&quot;)</span></span><br><span class="line"><span class="attr">public</span> <span class="string">String hello(HttpServletRequest request, </span></span><br><span class="line">                    <span class="attr">@PathVariable(&quot;p1&quot;)</span> <span class="string">String path) &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">log.info(&quot;路径变量p1：</span> <span class="string">&#123;&#125;&quot;, path);</span></span><br><span class="line">    <span class="attr">//获取请求路径</span></span><br><span class="line">    <span class="attr">String</span> <span class="string">uri = request.getRequestURI();</span></span><br><span class="line">    <span class="attr">return</span> <span class="string">uri;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>使用默认的路径匹配规则，是由 PathPatternParser 提供的</li>
<li>如果路径中间需要有 **，替换成ant风格路径</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改变路径匹配策略：</span></span><br><span class="line"><span class="comment"># ant_path_matcher 老版策略；</span></span><br><span class="line"><span class="comment"># path_pattern_parser 新版策略；</span></span><br><span class="line"><span class="attr">spring.mvc.pathmatch.matching-strategy</span>=<span class="string">ant_path_matcher</span></span><br></pre></td></tr></table></figure>
<h2 id="4-内容协商">4. 内容协商</h2>
<p>一套系统适配多端数据返回<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681217799861-dde49224-a767-489b-80b7-7d8d503e33cf.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_23%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23faf9f7&amp;from=url&amp;id=gZ4iS&amp;originHeight=420&amp;originWidth=797&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h3 id="1-多端内容适配">1. 多端内容适配</h3>
<h4 id="1-默认规则-2">1. 默认规则</h4>
<ol>
<li><strong>SpringBoot 多端内容适配</strong>。
<ol>
<li><strong>基于请求头内容协商</strong>：（默认开启）
<ol>
<li>客户端向服务端发送请求，携带HTTP标准的<strong>Accept请求头</strong>。
<ol>
<li><strong>Accept</strong>: application/json、text/xml、text/yaml</li>
<li>服务端根据客户端<strong>请求头期望的数据类型</strong>进行<strong>动态返回</strong></li>
<li>**1、默认支持把对象写为json。因为默认web场景导入了jackson处理json的包;jackson-core</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<ul>
<li>2、jackson也支持把数据写为xml。导入xml相关依赖**<br>
2. <strong>基于请求参数内容协商：（需要开启）下面的?format就是要返回数据的格式。</strong><br>
1. 发送请求 GET /projects/spring-boot?format=json<br>
2. 匹配到 @GetMapping(“/projects/spring-boot”)<br>
3. 根据<strong>参数协商</strong>，优先返回 json 类型数据【<strong>需要开启参数匹配设置</strong>】<br>
4. 发送请求 GET /projects/spring-boot?format=xml,优先返回 xml 类型数据</li>
</ul>
<h4 id="2-效果演示">2. 效果演示</h4>
<p>请求同一个接口，可以返回json和xml不同格式数据,<strong>、默认支持把对象写为json。因为默认web场景导入了jackson处理json的包;jackson-core,jackson也支持把数据写为xml。导入xml相关依赖</strong></p>
<ol>
<li>引入支持写出xml内容依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>标注注解</li>
</ol>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">@JacksonXmlRootElement</span>  <span class="string">// 可以写出为xml文档</span></span><br><span class="line"><span class="attr">@Data</span></span><br><span class="line"><span class="attr">public</span> <span class="string">class Person &#123;</span></span><br><span class="line">    <span class="attr">private</span> <span class="string">Long id;</span></span><br><span class="line">    <span class="attr">private</span> <span class="string">String userName;</span></span><br><span class="line">    <span class="attr">private</span> <span class="string">String email;</span></span><br><span class="line">    <span class="attr">private</span> <span class="string">Integer age;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>开启基于请求参数的内容协商</li>
</ol>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启基于请求参数的内容协商功能。 默认参数名：format。 默认此功能不开启</span></span><br><span class="line"><span class="attr">spring.mvc.contentnegotiation.favor-parameter</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 指定内容协商时使用的参数名。默认是 format</span></span><br><span class="line"><span class="attr">spring.mvc.contentnegotiation.parameter-name</span>=<span class="string">type</span></span><br></pre></td></tr></table></figure>
<ol>
<li>效果</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681220124448-e8611612-97bc-4823-9b00-20dd9d579abf.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_17%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f9f8f8&amp;from=url&amp;id=tIIrj&amp;originHeight=306&amp;originWidth=594&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681220145378-86fabd90-a78c-4f60-9efa-eb2960915832.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_16%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f6f5f5&amp;from=url&amp;id=mh0xz&amp;originHeight=256&amp;originWidth=575&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h3 id="3-配置协商规则与支持类型">3. 配置协商规则与支持类型</h3>
<ol>
<li>修改<strong>内容协商方式</strong></li>
</ol>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用参数进行内容协商</span></span><br><span class="line"><span class="attr">spring.mvc.contentnegotiation.favor-parameter</span>=<span class="string">true  </span></span><br><span class="line"><span class="comment">#自定义参数名，默认为format</span></span><br><span class="line"><span class="attr">spring.mvc.contentnegotiation.parameter-name</span>=<span class="string">myparam </span></span><br></pre></td></tr></table></figure>
<ol>
<li>大多数 MediaType 都是开箱即用的。也可以<strong>自定义内容类型，如：</strong></li>
</ol>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.mvc.contentnegotiation.media-types.yaml</span>=<span class="string">text/yaml</span></span><br></pre></td></tr></table></figure>
<h3 id="2-自定义内容返回">2. 自定义内容返回</h3>
<h4 id="1-增加yaml返回支持">1. 增加yaml返回支持</h4>
<p>导入依赖</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;dependency&gt;</span></span><br><span class="line">    <span class="attr">&lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;</span></span><br><span class="line">    <span class="attr">&lt;artifactId&gt;jackson-dataformat-yaml&lt;/artifactId&gt;</span></span><br><span class="line"><span class="attr">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure>
<p>把对象写出成YAML</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="attr">public</span> <span class="string">static void main(String[] args) throws JsonProcessingException &#123;</span></span><br><span class="line">        <span class="attr">Person</span> <span class="string">person = new Person();</span></span><br><span class="line">        <span class="attr">person.setId(1L);</span></span><br><span class="line">        <span class="attr">person.setUserName(&quot;张三&quot;);</span></span><br><span class="line">        <span class="attr">person.setEmail(&quot;aaa@qq.com&quot;);</span></span><br><span class="line">        <span class="attr">person.setAge(18);</span></span><br><span class="line"><span class="attr">//禁用文档的开始标记</span></span><br><span class="line">        <span class="attr">YAMLFactory</span> <span class="string">factory = new YAMLFactory().disable(YAMLGenerator.Feature.WRITE_DOC_START_MARKER);</span></span><br><span class="line">        <span class="attr">ObjectMapper</span> <span class="string">mapper = new ObjectMapper(factory);</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">String</span> <span class="string">s = mapper.writeValueAsString(person);</span></span><br><span class="line">        <span class="attr">System.out.println(s);</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>
<p>编写配置</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#新增一种媒体类型，</span></span><br><span class="line"><span class="attr">spring.mvc.contentnegotiation.media-types.yaml</span>=<span class="string">text/yaml</span></span><br></pre></td></tr></table></figure>
<p>增加HttpMessageConverter组件，专门负责把对象写出为yaml格式</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">@Bean</span></span><br><span class="line"><span class="attr">public</span> <span class="string">WebMvcConfigurer webMvcConfigurer()&#123;</span></span><br><span class="line">    <span class="attr">return</span> <span class="string">new WebMvcConfigurer() &#123;</span></span><br><span class="line">        <span class="attr">@Override</span> <span class="string">//配置一个能把对象转为yaml的messageConverter</span></span><br><span class="line">        <span class="attr">public</span> <span class="string">void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;</span></span><br><span class="line">            <span class="attr">converters.add(new</span> <span class="string">MyYamlHttpMessageConverter());//将新增的配置格式和配置类关联起来</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-HttpMessageConverter的示例写法">3. HttpMessageConverter的示例写法</h3>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">public</span> <span class="string">class MyYamlHttpMessageConverter extends AbstractHttpMessageConverter&lt;Object&gt; &#123;</span></span><br><span class="line"><span class="attr">//或者是实现</span> <span class="string">HttpMessageConverter</span></span><br><span class="line">    <span class="attr">private</span> <span class="string">ObjectMapper objectMapper = null; //把对象转成yaml</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">public</span> <span class="string">MyYamlHttpMessageConverter()&#123;</span></span><br><span class="line">        <span class="attr">//告诉SpringBoot这个MessageConverter支持哪种媒体类型</span>  <span class="string">//媒体类型</span></span><br><span class="line">        <span class="attr">super(new</span> <span class="string">MediaType(&quot;text&quot;, &quot;yaml&quot;, Charset.forName(&quot;UTF-8&quot;)));</span></span><br><span class="line">        <span class="attr">YAMLFactory</span> <span class="string">factory = new YAMLFactory()</span></span><br><span class="line">                <span class="attr">.disable(YAMLGenerator.Feature.WRITE_DOC_START_MARKER);</span></span><br><span class="line">        <span class="attr">this.objectMapper</span> = <span class="string">new ObjectMapper(factory);</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">@Override</span></span><br><span class="line">    <span class="attr">protected</span> <span class="string">boolean supports(Class&lt;?&gt; clazz) &#123;</span></span><br><span class="line">        <span class="attr">//只要是对象类型，不是基本类型</span></span><br><span class="line">        <span class="attr">return</span> <span class="string">true;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">@Override</span>  <span class="string">//@RequestBody,读取请求对象 </span></span><br><span class="line">    <span class="attr">protected</span> <span class="string">Object readInternal(Class&lt;?&gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException &#123;</span></span><br><span class="line">        <span class="attr">return</span> <span class="string">null;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">@Override</span> <span class="string">//@ResponseBody 把对象怎么写出去</span></span><br><span class="line">    <span class="attr">protected</span> <span class="string">void writeInternal(Object methodReturnValue, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">//try-with写法，自动关流</span></span><br><span class="line">        <span class="attr">try(OutputStream</span> <span class="string">os = outputMessage.getBody())&#123;</span></span><br><span class="line">            <span class="attr">this.objectMapper.writeValue(os,methodReturnValue);</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-思考：如何增加其他">2. 思考：如何增加其他</h4>
<ul>
<li>配置媒体类型支持:
<ul>
<li>spring.mvc.contentnegotiation.media-types.yaml=text/yaml</li>
</ul>
</li>
<li>编写对应的HttpMessageConverter，要告诉Boot这个支持的媒体类型
<ul>
<li>按照3的示例</li>
</ul>
</li>
<li>把MessageConverter组件加入到底层
<ul>
<li>容器中放一个<code>WebMvcConfigurer</code> 组件，并配置底层的MessageConverter</li>
</ul>
</li>
</ul>
<h2 id="3-内容协商原理-HttpMessageConverter">3. 内容协商原理-HttpMessageConverter</h2>
<ul>
<li>HttpMessageConverter 怎么工作？合适工作？</li>
<li>定制 HttpMessageConverter 来实现多端内容协商</li>
<li>编写WebMvcConfigurer提供的configureMessageConverters底层，修改底层的MessageConverter</li>
</ul>
<h3 id="1-ResponseBody由HttpMessageConverter处理">1. @ResponseBody由HttpMessageConverter处理</h3>
<p>标注了@ResponseBody的返回值 将会由支持它的 HttpMessageConverter写给浏览器</p>
<ol>
<li>如果controller方法的返回值标注了 @ResponseBody 注解
<ol>
<li>请求进来先来到DispatcherServlet的doDispatch()进行处理</li>
</ol>
</li>
</ol>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">doDispatch()</span> <span class="string">是 Spring MVC 中的核心方法之一，用于处理请求的分发和调度。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">在</span> <span class="string">Spring MVC 中，请求的处理流程如下：</span></span><br><span class="line"></span><br><span class="line"><span class="attr">1.客户端发送一个</span> <span class="string">HTTP 请求到服务器。</span></span><br><span class="line"><span class="attr">2.前端控制器（Front</span> <span class="string">Controller）接收到请求，这个控制器通常是 DispatcherServlet，它是 </span></span><br><span class="line"><span class="attr">Spring</span> <span class="string">MVC 的核心组件。</span></span><br><span class="line"><span class="attr">3.DispatcherServlet</span> <span class="string">根据请求的 URL 找到相应的处理器（Handler）。</span></span><br><span class="line"><span class="attr">4.处理器执行相应的业务逻辑并返回一个</span> <span class="string">ModelAndView 对象。(其中执行目标方法要准备参数解析器和</span></span><br><span class="line"><span class="attr">返回值解析器）</span></span><br><span class="line"><span class="attr">5.DispatcherServlet</span> <span class="string">根据 ModelAndView 对象选择合适的视图（View）进行渲染。</span></span><br><span class="line"><span class="attr">最终将渲染结果返回给客户端。（</span></span><br><span class="line"><span class="attr">在这个处理流程中，doDispatch()</span> <span class="string">方法负责实际执行第 4 步和第 5 步的操作。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">具体而言，doDispatch()</span> <span class="string">方法会执行以下主要任务：</span></span><br><span class="line"></span><br><span class="line"><span class="attr">解析请求，包括解析请求的方法、路径、参数等信息。</span></span><br><span class="line"><span class="attr">根据请求的方法和路径，确定匹配的处理器（Handler）。</span></span><br><span class="line"><span class="attr">执行处理器的业务逻辑，处理请求并返回一个</span> <span class="string">ModelAndView 对象。</span></span><br><span class="line"><span class="attr">根据</span> <span class="string">ModelAndView 对象中的视图名字，选择合适的视图（View）进行渲染。</span></span><br><span class="line"><span class="attr">渲染视图，生成最终的响应结果。</span></span><br><span class="line"><span class="attr">doDispatch()</span> <span class="string">方法的具体实现会涉及到请求的映射、处理器适配器、处理器拦截器、参数解析器等等。</span></span><br><span class="line"><span class="attr">该方法是</span> <span class="string">Spring MVC 框架的核心之一，在请求的处理过程中起到了关键的作用。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">需要注意的是，doDispatch()</span> <span class="string">方法通常由 DispatcherServlet 自动调用，开发者一般不需要直接调用</span></span><br><span class="line"><span class="attr">该方法。开发者主要关注配置合适的请求映射、编写处理器方法以及配置视图解析器等，框架会自动根据</span></span><br><span class="line"><span class="attr">配置和规则来调用</span> <span class="string">doDispatch() 方法来处理请求。</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>找到一个 HandlerAdapter 适配器。利用适配器执行目标方法</li>
<li>RequestMappingHandlerAdapter来执行，调用invokeHandlerMethod（）来执行目标方法</li>
<li>目标方法执行之前，准备好两个东西
<ol>
<li>HandlerMethodArgumentResolver：参数解析器，确定目标方法每个参数值</li>
<li>HandlerMethodReturnValueHandler：返回值处理器，确定目标方法的返回值改怎么处理</li>
</ol>
</li>
<li>RequestMappingHandlerAdapter 里面的invokeAndHandle()真正执行目标方法</li>
<li>目标方法执行完成，会返回<strong>返回值对象</strong></li>
<li>**找到一个合适的返回值处理器 **HandlerMethodReturnValueHandler</li>
<li>最终找到 RequestResponseBodyMethodProcessor能处理 标注了 @ResponseBody注解的方法</li>
<li>RequestResponseBodyMethodProcessor 调用writeWithMessageConverters ,利用MessageConverter把返回值写出去</li>
</ol>
<p>上面解释：@ResponseBody由HttpMessageConverter处理</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">HttpMessageConverter</span> <span class="string">是 Spring MVC 中的一个关键接口，用于处理 HTTP 请求和响应消息的转换。</span></span><br><span class="line"><span class="attr">它负责将</span> <span class="string">Java 对象与 HTTP 请求/响应的内容进行转换，使得应用程序可以方便地处理不同类型的数据格式，</span></span><br><span class="line"><span class="attr">如</span> <span class="string">JSON、XML、表单数据等。</span></span><br></pre></td></tr></table></figure>
<ol>
<li>HttpMessageConverter 会<strong>先进行内容协商</strong>
<ol>
<li>遍历所有的MessageConverter看谁支持这种<strong>内容类型的数据</strong></li>
<li>默认MessageConverter有以下</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681275459547-89d8d651-b52f-4d47-bff9-6db123624424.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_15%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f0eeeb&amp;from=url&amp;id=w9v5M&amp;originHeight=282&amp;originWidth=532&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></li>
<li>最终因为要json所以MappingJackson2HttpMessageConverter支持写出json</li>
<li>jackson用ObjectMapper（是一个类）把对象写出去</li>
</ol>
</li>
</ol>
<h3 id="2-WebMvcAutoConfiguration提供几种默认HttpMessageConverters">2. WebMvcAutoConfiguration提供几种默认HttpMessageConverters</h3>
<ul>
<li>EnableWebMvcConfiguration通过 addDefaultHttpMessageConverters添加了默认的MessageConverter；如下：
<ul>
<li>ByteArrayHttpMessageConverter： 支持字节数据读写</li>
<li>StringHttpMessageConverter： 支持字符串读写</li>
<li>ResourceHttpMessageConverter：支持资源读写</li>
<li>ResourceRegionHttpMessageConverter: 支持分区资源写出</li>
<li>AllEncompassingFormHttpMessageConverter：支持表单xml/json读写</li>
<li>MappingJackson2HttpMessageConverter： 支持请求响应体Json读写</li>
</ul>
</li>
</ul>
<p>默认8个：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681302411019-0c0425aa-6679-4b2b-a456-b31c151c6e83.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_15%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f1eeec&amp;from=url&amp;id=WrjKA&amp;originHeight=237&amp;originWidth=532&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>
系统提供默认的MessageConverter 功能有限，仅用于json或者普通返回数据。额外增加新的内容协商功能，必须增加新的HttpMessageConverter</p>
<h1>5. 模板引擎</h1>
<ul>
<li>由于 <strong>SpringBoot</strong> 使用了<strong>嵌入式 Servlet 容器</strong>。所以 <strong>JSP</strong> 默认是<strong>不能使用</strong>的。</li>
<li>如果需要<strong>服务端页面渲染</strong>，优先考虑使用 模板引擎。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681354523290-b89d7e0d-b9aa-40f5-8d22-d3d09d02b136.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_28%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f6f5f5&amp;from=url&amp;id=FMo0Z&amp;originHeight=654&amp;originWidth=999&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>
模板引擎页面默认放在 src/main/resources/templates<br>
<strong>SpringBoot</strong> 包含以下模板引擎的自动配置</p>
<ul>
<li>FreeMarker</li>
<li>Groovy</li>
<li><strong>Thymeleaf</strong></li>
<li>Mustache</li>
</ul>
<p><strong>Thymeleaf官网</strong>：<a target="_blank" rel="noopener" href="https://www.thymeleaf.org/">https://www.thymeleaf.org/</a></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;!DOCTYPE</span> <span class="string">html&gt;</span></span><br><span class="line"><span class="attr">&lt;html</span> <span class="string">xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span></span><br><span class="line"><span class="attr">&lt;head&gt;</span></span><br><span class="line">	<span class="attr">&lt;title&gt;Good</span> <span class="string">Thymes Virtual Grocery&lt;/title&gt;</span></span><br><span class="line">	<span class="attr">&lt;meta</span> <span class="string">http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;</span></span><br><span class="line">	<span class="attr">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot; th:href=&quot;@&#123;/css/gtvg.css&#125;&quot; /&gt;</span></span><br><span class="line"><span class="attr">&lt;/head&gt;</span></span><br><span class="line"><span class="attr">&lt;body&gt;</span></span><br><span class="line">	<span class="attr">&lt;p</span> <span class="string">th:text=&quot;#&#123;home.welcome&#125;&quot;&gt;Welcome to our grocery store!&lt;/p&gt;</span></span><br><span class="line"><span class="attr">&lt;/body</span></span><br><span class="line"><span class="attr">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-Thymeleaf整合（是前后端一体的开发）">1. Thymeleaf整合（是前后端一体的开发）</h2>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;dependency&gt;</span></span><br><span class="line">    <span class="attr">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">    <span class="attr">&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span></span><br><span class="line"><span class="attr">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure>
<p>自动配置原理</p>
<ol>
<li>开启了org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration自动配置</li>
<li>属性绑定在 ThymeleafProperties类 中，对应配置文件 spring.thymeleaf 内容（也就是配置文件中以spring.thymeleaf开头的属性）</li>
<li>所有的模板页面默认在 classpath:/templates文件夹下</li>
<li>默认效果
<ol>
<li>所有的模板页面在 classpath:/templates/下面找</li>
<li>找后缀名为.html的页面</li>
</ol>
</li>
</ol>
<p>事例：<br>
1.使用Thymeleaf来处理的项目其controller类用@Controller //适配 服务端渲染 前后不分离模式开始;而前后端分离的项目用@Resttroller注解<br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/east7/p/10462279.html">Spring 注解之@RestController与@Controller的区别 - 楼兰胡杨 - 博客园</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RestController无法返回指定页面，而@Controller可以；前者可以直接返回数据，</span><br><span class="line">后者需要@ResponseBody辅助。</span><br><span class="line">如果需要返回JSON，XML或自定义mediaType内容到页面，@RestController自己就可以搞定，</span><br><span class="line">这个注解对于返回数据比较方便，因为它会自动将对象实体转换为JSON格式。而@Controller需要在对应的</span><br><span class="line">方法加上@ResponseBody注解。</span><br></pre></td></tr></table></figure>
<p>2.get请求其参数是写在url中的，而post请求参数是在请求体中的。<br>
3.@GetMapping（）用来修饰处理get请求的方法。<br>
4.//模板的逻辑视图名<br>
//物理视图 = 前缀 + 逻辑视图名 + 后缀<br>
//真实地址 = classpath:/templates/welcome.html其中的前缀和后缀在ThymeleafProperties类中指定了的<br>
5.其Thymeleaf还提供了一些工具类，常用#类名表示，例如：#string。这些工具类可以进行简单的运行操作。<br>
6.如果html中要使用Thymeleaf语法，需要提供其命名空间</p>
<h2 id="2-基础语法（在html中使用Thymeleaf）">2. 基础语法（在html中使用Thymeleaf）</h2>
<h3 id="1-核心用法">1. 核心用法</h3>
<p>导入命名空间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">xmlns:th属性，该属性是Thymeleaf命名空间（http://www.thymeleaf.org）的声明。</span><br><span class="line">这个命名空间允许您在HTML代码中使用Thymeleaf特定的属性和表达式。</span><br></pre></td></tr></table></figure>
<p><strong>th:xxx：动态渲染指定的 html 标签属性值、或者th指令（遍历、判断等）</strong></p>
<ul>
<li>th:text：标签体内文本值渲染
<ul>
<li>th:utext：不会转义，显示为html原本的样子。也就是文本中的html元素可以被解析</li>
</ul>
</li>
<li>th:属性：标签指定属性渲染</li>
<li>th:attr：标签任意属性渲染</li>
<li>th:if  （根据后端逻辑或数据的条件来控制是否在渲染过程中包含或显示某个元素。）  th:each…：其他th指令</li>
<li>例如：</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;p</span> <span class="string">th:text=&quot;$&#123;content&#125;&quot;&gt;原内容&lt;/p&gt;</span></span><br><span class="line"><span class="attr">&lt;a</span> <span class="string">th:href=&quot;$&#123;url&#125;&quot;&gt;登录&lt;/a&gt;</span></span><br><span class="line"><span class="attr">&lt;img</span> <span class="string">src=&quot;../../images/gtvglogo.png&quot; </span></span><br><span class="line">     <span class="attr">th</span>:<span class="string">attr=&quot;src=@&#123;/images/gtvglogo.png&#125;,title=#&#123;logo&#125;,alt=#&#123;logo&#125;&quot; /&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>表达式：用来动态取值</strong></p>
<ul>
<li><strong>${}：变量取值；使用model共享给页面的值都直接用${}是用下面的方法实现的：</strong></li>
</ul>
<p>model.addAttribute(“imgUrl”<strong>,</strong>“/4.jpg”)<strong>;imgUrl就是共享的值</strong></p>
<ul>
<li><strong>@{}：url路径；@{}是一个Thymeleaf的URL表达式，它用来在HTML文档中生成一个相对于当前应用上下文的URL路径。当然也可以直接使用{}表示，例如：src=&quot;{}&quot;但是其如果在配置文件中配置了</strong>server.servlet.context-path=/demo那么要想配置的src路径生效需要在src的路径前添加/demo前缀否则无法访问，如果是使用的是src=的是@{}那么可以不用修改src仍旧可以正常访问。</li>
<li>**@{}路径中的内容会自动添加链接头部和尾部	**</li>
<li>#{}：国际化消息</li>
<li>~{}：片段引用</li>
<li>*{}：变量选择：需要配合th:object绑定对象</li>
</ul>
<p><strong>系统工具&amp;内置对象：</strong><a target="_blank" rel="noopener" href="https://www.thymeleaf.org/doc/tutorials/3.1/usingthymeleaf.html#appendix-a-expression-basic-objects">详细文档</a></p>
<ul>
<li>param：请求参数对象</li>
<li>session：session对象</li>
<li>application：application对象</li>
<li>#execInfo：模板执行信息</li>
<li>#messages：国际化消息</li>
<li>#uris：uri/url工具</li>
<li>#conversions：类型转换工具</li>
<li>#dates：日期工具，是java.util.Date对象的工具类</li>
<li>#calendars：类似#dates，只不过是java.util.Calendar对象的工具类</li>
<li>#temporals： JDK8+ <strong>java.time</strong> API 工具类</li>
<li>#numbers：数字操作工具</li>
<li>#strings：字符串操作</li>
<li>#objects：对象操作</li>
<li>#bools：bool操作</li>
<li>#arrays：array工具</li>
<li>#lists：list工具</li>
<li>#sets：set工具</li>
<li>#maps：map工具</li>
<li>#aggregates：集合聚合工具（sum、avg）</li>
<li>#ids：id生成工具</li>
</ul>
<h3 id="2-语法示例">2. 语法示例</h3>
<p><strong>表达式：</strong></p>
<ul>
<li>变量取值：${…}</li>
<li>url 取值：@{…}</li>
<li>国际化消息：#{…}</li>
<li>变量选择：*{…}</li>
<li>片段引用:~{…}</li>
</ul>
<p><strong>常见：</strong></p>
<ul>
<li>文本：‘one text’，‘another one!’,…</li>
<li>数字：0,34,3.0,12.3,…</li>
<li>布尔：true、false</li>
<li>null:null</li>
<li>变量名：one,sometext,main…</li>
</ul>
<p><strong>文本操作：</strong></p>
<ul>
<li>拼串：+</li>
<li>文本替换：| The name is ${name} |</li>
</ul>
<p><strong>布尔操作：</strong></p>
<ul>
<li>二进制运算：and,or</li>
<li>取反：!,not</li>
</ul>
<p><strong>比较运算：</strong></p>
<ul>
<li>比较：&gt;，&lt;，&lt;=，&gt;=（gt，lt，ge,le）</li>
<li>等值运算：==,!=（eq，ne）</li>
</ul>
<p><strong>条件运算：</strong></p>
<ul>
<li>if-then：(if)?(then)</li>
<li>if-then-else:(if)?(then):(else)</li>
<li>default:(value)?:(defaultValue)</li>
</ul>
<p><strong>特殊语法：</strong></p>
<ul>
<li>无操作：_</li>
</ul>
<p><strong>所有以上都可以嵌套组合</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;User is of type &#x27; + ($&#123;user.isAdmin()&#125; ? &#x27;Administrator&#x27; : ($&#123;user.type&#125; ?: &#x27;Unknown&#x27;))</span><br></pre></td></tr></table></figure>
<h2 id="3-属性设置">3. 属性设置</h2>
<ol>
<li>th:href=“@{/product/list}”</li>
<li>th:attr=“class=${active}”</li>
<li>th:attr=“src=@{/images/gtvglogo.png},title=${logo},alt=#{logo}”</li>
<li>th:checked=“${user.active}”</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p th:text=&quot;$&#123;content&#125;&quot;&gt;原内容&lt;/p&gt;</span><br><span class="line">&lt;a th:href=&quot;$&#123;url&#125;&quot;&gt;登录&lt;/a&gt;</span><br><span class="line">&lt;img src=&quot;../../images/gtvglogo.png&quot; </span><br><span class="line">     th:attr=&quot;src=@&#123;/images/gtvglogo.png&#125;,title=#&#123;logo&#125;,alt=#&#123;logo&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h2 id="4-遍历">4. 遍历</h2>
<p>语法： th:each=“元素名,迭代状态 : ${集合}”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr th:each=&quot;prod : $&#123;prods&#125;&quot;&gt;</span><br><span class="line">  &lt;td th:text=&quot;$&#123;prod.name&#125;&quot;&gt;Onions&lt;/td&gt;</span><br><span class="line">  &lt;td th:text=&quot;$&#123;prod.price&#125;&quot;&gt;2.41&lt;/td&gt;</span><br><span class="line">  &lt;td th:text=&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;&gt;yes&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">&lt;tr th:each=&quot;prod,iterStat : $&#123;prods&#125;&quot; th:class=&quot;$&#123;iterStat.odd&#125;? &#x27;odd&#x27;&quot;&gt;</span><br><span class="line">  &lt;td th:text=&quot;$&#123;prod.name&#125;&quot;&gt;Onions&lt;/td&gt;</span><br><span class="line">  &lt;td th:text=&quot;$&#123;prod.price&#125;&quot;&gt;2.41&lt;/td&gt;</span><br><span class="line">  &lt;td th:text=&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;&gt;yes&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure>
<p>iterStat 有以下属性：</p>
<ul>
<li>index：当前遍历元素的索引，从0开始</li>
<li>count：当前遍历元素的索引，从1开始</li>
<li>size：需要遍历元素的总数量</li>
<li>current：当前正在遍历的元素对象</li>
<li>even/odd：是否偶数/奇数行</li>
<li>first：是否第一个元素</li>
<li>last：是否最后一个元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;th scope=&quot;col&quot;&gt;#&lt;/th&gt;这里的th标签表示是一个表头标签，scope属性指定表头单元格的范围，这里的范围</span><br><span class="line">是一个表头占据一个单元格。</span><br></pre></td></tr></table></figure>
<h2 id="5-判断">5. 判断</h2>
<h3 id="th-if">th:if</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;td th:text=&quot;| $&#123;person.age&#125; / $&#123;person.age &gt;= 18?&#x27;成年&#x27;:&#x27;未成年&#x27; &#125;|&quot;&gt;  &lt;/td&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;a</span><br><span class="line">  href=&quot;comments.html&quot;</span><br><span class="line">  th:href=&quot;@&#123;/product/comments(prodId=$&#123;prod.id&#125;)&#125;&quot;</span><br><span class="line">  th:if=&quot;$&#123;not #lists.isEmpty(prod.comments)&#125;&quot;</span><br><span class="line">  &gt;view&lt;/a</span><br></pre></td></tr></table></figure>
<h3 id="th-switch">th:switch</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div th:switch=&quot;$&#123;user.role&#125;&quot;&gt;</span><br><span class="line">  &lt;p th:case=&quot;&#x27;admin&#x27;&quot;&gt;User is an administrator&lt;/p&gt;//这里的admin的单引号表示其为一个字符串</span><br><span class="line">//，和变量区分</span><br><span class="line"></span><br><span class="line">  &lt;p th:case=&quot;#&#123;roles.manager&#125;&quot;&gt;User is a manager&lt;/p&gt;</span><br><span class="line">  &lt;p th:case=&quot;*&quot;&gt;User is some other thing&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h2 id="6-属性优先级">6. 属性优先级</h2>
<ul>
<li>片段</li>
<li>遍历</li>
<li>判断</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li th:each=&quot;item : $&#123;items&#125;&quot; th:text=&quot;$&#123;item.description&#125;&quot;&gt;Item description here...&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Order</th>
<th>Feature</th>
<th>Attributes</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>片段包含</td>
<td>th:insertth:replace</td>
</tr>
<tr>
<td>2</td>
<td>遍历</td>
<td>th:each</td>
</tr>
<tr>
<td>3</td>
<td>判断</td>
<td>th:ifth:unlessth:switchth:case</td>
</tr>
<tr>
<td>4</td>
<td>定义本地变量</td>
<td>th:objectth:with</td>
</tr>
<tr>
<td>5</td>
<td>通用方式属性修改</td>
<td>th:attrth:attrprependth:attrappend</td>
</tr>
<tr>
<td>6</td>
<td>指定属性修改</td>
<td>th:valueth:hrefth:src…</td>
</tr>
<tr>
<td>7</td>
<td>文本值</td>
<td>th:textth:utext</td>
</tr>
<tr>
<td>8</td>
<td>片段指定</td>
<td>th:fragment</td>
</tr>
<tr>
<td>9</td>
<td>片段移除</td>
<td>th:remove</td>
</tr>
</tbody>
</table>
<h2 id="7-行内写法">7. 行内写法</h2>
<p>[[…]] or [(…)]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Hello, [[$&#123;session.user.name&#125;]]!&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<h2 id="8-变量选择">8. 变量选择</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt;</span><br><span class="line">  &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;p&gt;Name: &lt;span th:text=&quot;$&#123;session.user.firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Surname: &lt;span th:text=&quot;$&#123;session.user.lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Nationality: &lt;span th:text=&quot;$&#123;session.user.nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;</span><br><span class="line">&lt;/div</span><br></pre></td></tr></table></figure>
<h2 id="9-模板布局">9. 模板布局</h2>
<ul>
<li>定义模板： th:fragment</li>
<li>引用模板：~{templatename::selector}</li>
<li>插入模板：th:insert、th:replace</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;footer th:fragment=&quot;copy&quot;&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div th:insert=&quot;~&#123;footer :: copy&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div th:replace=&quot;~&#123;footer :: copy&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  结果：</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">th:insert和th:replace是Thymeleaf模板引擎中的两个属性，用于在模板中插入或替换其他模板片段。</span><br><span class="line">th:insert属性用于在当前模板中插入另一个模板片段。</span><br><span class="line">th:replace属性用于在当前模板中替换自身的内容为另一个模板片段。</span><br></pre></td></tr></table></figure>
<h2 id="10-devtools">10. devtools</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>修改页面后；ctrl+F9刷新效果（热启动）；前提是配置了devtools。<br>
java代码的修改，如果devtools热启动了，可能会引起一些bug，难以排查<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1691304138965-1792688e-a546-44c5-b225-df80d9bc8562.png#averageHue=%23f2f1dc&amp;clientId=u5acfc650-ecf6-4&amp;from=paste&amp;height=46&amp;id=u926de390&amp;originHeight=58&amp;originWidth=223&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=12806&amp;status=done&amp;style=none&amp;taskId=u16c89229-3bdc-4732-9eb3-5693e766448&amp;title=&amp;width=178.4" alt="image.png">（缓存机制）<br>
spring.thymeleaf.check-template=false检查模板是否存在</p>
<h1>6. 国际化</h1>
<p>国际化的自动配置参照MessageSourceAutoConfiguration<br>
<strong>实现步骤</strong>：</p>
<ol>
<li>Spring Boot 在类路径根下查找messages资源绑定文件（配置。文件名为：messages.properties</li>
<li>多语言可以定义多个消息文件，命名为messages_区域代码.properties。如：
<ol>
<li>messages.properties：默认</li>
<li>messages_zh_CN.properties：中文环境</li>
<li>messages_en_US.properties：英语环境</li>
</ol>
</li>
<li>在<strong>程序中</strong>可以自动注入 MessageSource组件，获取国际化的配置项值</li>
<li>在<strong>页面中</strong>可以使用表达式  #{}获取国际化的配置项值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Autowired  //国际化取消息用的组件</span><br><span class="line">MessageSource messageSource;</span><br><span class="line">@GetMapping(&quot;/haha&quot;)</span><br><span class="line">public String haha(HttpServletRequest request)&#123;</span><br><span class="line"></span><br><span class="line">    Locale locale = request.getLocale();</span><br><span class="line">    //利用代码的方式获取国际化配置文件中指定的配置项的值</span><br><span class="line">    String login = messageSource.getMessage(&quot;login&quot;, null, locale);</span><br><span class="line">    return login;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>7. 错误处理</h1>
<h2 id="1-默认机制">1. 默认机制</h2>
<p><strong>错误处理的自动配置</strong>都在ErrorMvcAutoConfiguration中，两大核心机制：</p>
<ul>
<li>
<ol>
<li>SpringBoot 会<strong>自适应处理错误</strong>，<strong>响应页面</strong>或<strong>JSON数据</strong></li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Spring Boot 会根据请求的类型和接受的媒体类型，自适应地处理错误，返回合适的响应格式。</span><br><span class="line">如果请求是一个浏览器请求，Spring Boot 会返回一个 HTML 错误页面，这个页面也被称为白标错误页面。</span><br><span class="line">如果请求是一个 RESTful 请求，或者接受的媒体类型是 JSON，Spring Boot 会返回一个 JSON 响应，</span><br><span class="line">包含错误的详细信息，HTTP 状态码，和异常消息</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>2.** SpringMVC的错误处理机制<strong>依然保留，<strong>MVC处理不了</strong>，才会</strong>交给boot进行处理**</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/svg/1613913/1681723795095-828d2034-1e6c-4d98-8e47-573dd6b5463b.svg#from=url&amp;id=ez8nQ&amp;originHeight=842&amp;originWidth=1047&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>
1.springMvc处理错误：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1691307013013-0d54dd7b-2189-4f1b-b63d-f880eeadd942.png#averageHue=%23fdfdfb&amp;clientId=u8fdb1034-8532-4&amp;from=paste&amp;height=370&amp;id=u8cfa0ee8&amp;originHeight=463&amp;originWidth=960&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=134823&amp;status=done&amp;style=none&amp;taskId=ud0d4529f-dec1-4e92-8baa-78f5b60dba9&amp;title=&amp;width=768" alt="image.png"><br>
这里如果发生了错误，会执行@ExceptionHandler修饰的方法，这里是将handleException中的方法的返回值写到返回体中，然后返回该浏览器。<br>
2.<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1691307230435-8c06a2a5-20ea-423f-b5e3-cc14688b812f.png#averageHue=%23f7f4e0&amp;clientId=u8fdb1034-8532-4&amp;from=paste&amp;height=66&amp;id=ubf31b11b&amp;originHeight=83&amp;originWidth=571&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=36513&amp;status=done&amp;style=none&amp;taskId=ua92b8fb3-30aa-4271-908a-08bf7d846ed&amp;title=&amp;width=456.8" alt="image.png"></p>
<ul>
<li>发生错误以后，转发给/error路径，SpringBoot在底层写好一个 BasicErrorController的组件，专门处理这个请求</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(produces = MediaType.TEXT_HTML_VALUE) //返回HTML</span><br><span class="line">public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">	HttpStatus status = getStatus(request);</span><br><span class="line">	Map&lt;String, Object&gt; model = Collections</span><br><span class="line">		.unmodifiableMap(getErrorAttributes(request, getErrorAttributeOptions(request, MediaType.TEXT_HTML)));</span><br><span class="line">	response.setStatus(status.value());</span><br><span class="line">	ModelAndView modelAndView = resolveErrorView(request, response, status, model);</span><br><span class="line">	return (modelAndView != null) ? modelAndView : new ModelAndView(&quot;error&quot;, model);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RequestMapping  //返回 ResponseEntity, JSON</span><br><span class="line">public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;</span><br><span class="line">	HttpStatus status = getStatus(request);</span><br><span class="line">	if (status == HttpStatus.NO_CONTENT) &#123;</span><br><span class="line">		return new ResponseEntity&lt;&gt;(status);</span><br><span class="line">	&#125;</span><br><span class="line">	Map&lt;String, Object&gt; body = getErrorAttributes(request, getErrorAttributeOptions(request, MediaType.ALL));</span><br><span class="line">	return new ResponseEntity&lt;&gt;(body, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>错误页面是这么解析到的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//1、解析错误的自定义视图地址	</span><br><span class="line">ModelAndView modelAndView = resolveErrorView(request, response, status, model);</span><br><span class="line">//2、如果解析不到错误页面的地址，默认的错误页就是 error</span><br><span class="line">return (modelAndView != null) ? modelAndView : new ModelAndView(&quot;error&quot;, model);</span><br></pre></td></tr></table></figure>
<p>容器中专门有一个错误视图解析器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@ConditionalOnBean(DispatcherServlet.class)</span><br><span class="line">@ConditionalOnMissingBean(ErrorViewResolver.class)</span><br><span class="line">DefaultErrorViewResolver conventionErrorViewResolver() &#123;</span><br><span class="line">    return new DefaultErrorViewResolver(this.applicationContext, this.resources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SpringBoot解析自定义错误页的默认规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123;</span><br><span class="line">	ModelAndView modelAndView = resolve(String.valueOf(status.value()), model);</span><br><span class="line">	if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123;</span><br><span class="line">		modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);</span><br><span class="line">	&#125;</span><br><span class="line">	return modelAndView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123;</span><br><span class="line">	String errorViewName = &quot;error/&quot; + viewName;</span><br><span class="line">	TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName,</span><br><span class="line">			this.applicationContext);</span><br><span class="line">	if (provider != null) &#123;</span><br><span class="line">		return new ModelAndView(errorViewName, model);</span><br><span class="line">	&#125;</span><br><span class="line">	return resolveResource(errorViewName, model);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ModelAndView resolveResource(String viewName, Map&lt;String, Object&gt; model) &#123;</span><br><span class="line">	for (String location : this.resources.getStaticLocations()) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			Resource resource = this.applicationContext.getResource(location);</span><br><span class="line">			resource = resource.createRelative(viewName + &quot;.html&quot;);</span><br><span class="line">			if (resource.exists()) &#123;</span><br><span class="line">				return new ModelAndView(new HtmlResourceView(resource), model);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Exception ex) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容器中有一个默认的名为 error 的 view； 提供了默认白页功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean(name = &quot;error&quot;)</span><br><span class="line">@ConditionalOnMissingBean(name = &quot;error&quot;)</span><br><span class="line">public View defaultErrorView() &#123;</span><br><span class="line">    return this.defaultErrorView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封装了JSON格式的错误信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT)</span><br><span class="line">public DefaultErrorAttributes errorAttributes() &#123;</span><br><span class="line">	return new DefaultErrorAttributes();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>规则：</p>
<ol>
<li><strong>解析一个错误页</strong>
<ol>
<li>如果发生了500、404、503、403 这些错误
<ol>
<li>如果有<strong>模板引擎</strong>，默认在 classpath:/templates/error/<strong>精确码.html</strong></li>
<li>如果没有模板引擎，在静态资源文件夹下找 <strong>精确码.html</strong></li>
</ol>
</li>
<li>如果匹配不到精确码.html这些精确的错误页，就去找5xx.html，4xx.html<strong>模糊匹配</strong>
<ol>
<li>如果有模板引擎，默认在 classpath:/templates/error/5xx.html</li>
<li>如果没有模板引擎，在静态资源文件夹下找 5xx.html</li>
</ol>
</li>
</ol>
</li>
<li>如果模板引擎路径templates下有 error.html页面，就直接渲染</li>
</ol>
<h2 id="2-自定义错误响应">2. 自定义错误响应</h2>
<h3 id="1-自定义json响应">1. 自定义json响应</h3>
<p>使用@ControllerAdvice + @ExceptionHandler 进行统一异常处理</p>
<h3 id="2-自定义页面响应">2. 自定义页面响应</h3>
<p>根据boot的错误页面规则，自定义页面模板</p>
<h2 id="3-最佳实战">3. 最佳实战</h2>
<ul>
<li><strong>前后分离</strong>
<ul>
<li>后台发生的所有错误，@ControllerAdvice + @ExceptionHandler进行统一异常处理。</li>
</ul>
</li>
<li><strong>服务端页面渲染</strong>
<ul>
<li><strong>不可预知的一些，HTTP码表示的服务器或客户端错误</strong>
<ul>
<li>给classpath:/templates/error/下面，放常用精确的错误码页面。500.html，404.html</li>
<li>给classpath:/templates/error/下面，放通用模糊匹配的错误码页面。 5xx.html，4xx.html</li>
</ul>
</li>
<li><strong>发生业务错误</strong>
<ul>
<li><strong>核心业务</strong>，每一种错误，都应该代码控制，<strong>跳转到自己定制的错误页</strong>。</li>
<li><strong>通用业务</strong>，classpath:/templates/error.html页面，<strong>显示错误信息（可以通过在错误页面中添加[[${trance}]]来显示错误堆栈信息）</strong>。</li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>
<p>页面，JSON，可用的Model数据如下<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681724501227-077073b7-349d-414f-8916-a822eb86c772.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_26%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f5f4f3&amp;from=url&amp;id=PNxJP&amp;originHeight=196&amp;originWidth=919&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h1>8. 嵌入式容器</h1>
<p><strong>Servlet容器</strong>：管理、运行<strong>Servlet组件</strong>（Servlet、Filter、Listener）的环境，一般指<strong>服务器</strong></p>
<h2 id="1-自动配置原理">1. 自动配置原理</h2>
<ul>
<li>SpringBoot 默认嵌入Tomcat作为Servlet容器。</li>
<li><strong>自动配置类</strong>是ServletWebServerFactoryAutoConfiguration，EmbeddedWebServerFactoryCustomizerAutoConfiguration</li>
<li>自动配置类开始分析功能。<code>xxxxAutoConfiguration</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@AutoConfiguration</span><br><span class="line">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line">@ConditionalOnClass(ServletRequest.class)//@ConditionOn表示满足这些条件才将该类加载到容器中</span><br><span class="line">@ConditionalOnWebApplication(type = Type.SERVLET)</span><br><span class="line">@EnableConfigurationProperties(ServerProperties.class)</span><br><span class="line">@Import(&#123; ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,</span><br><span class="line">		ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,</span><br><span class="line">		ServletWebServerFactoryConfiguration.EmbeddedJetty.class,</span><br><span class="line">		ServletWebServerFactoryConfiguration.EmbeddedUndertow.class &#125;)</span><br><span class="line">public class ServletWebServerFactoryAutoConfiguration &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@AutoConfiguration：该注解表示这是一个自动配置类，用于自动配置应用程序的某些功能或组件。</span><br><span class="line"></span><br><span class="line">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)：该注解指定了自动配置类的优先级，</span><br><span class="line">使用 Ordered.HIGHEST_PRECEDENCE 表示具有最高优先级。优先级较高的自动配置类将在启动过程中优先</span><br><span class="line">加载和应用。</span><br><span class="line"></span><br><span class="line">@ConditionalOnClass(ServletRequest.class)：该注解表示只有当类路径上存在 ServletRequest 类时</span><br><span class="line">，才会加载和应用该自动配置类。也就是说，只有当 Servlet 相关的类存在时，该自动配置类才会生效。</span><br><span class="line"></span><br><span class="line">@ConditionalOnWebApplication(type = Type.SERVLET)：该注解表示只有当应用程序类型为 Servlet</span><br><span class="line">Web 应用时，才会加载和应用该自动配置类。这意味着该自动配置类仅适用于基于 Servlet 的 Web </span><br><span class="line">应用程序，而不适用于其他类型的应用程序。web程序除了servlet外还有其他的，比如：响应式，JSP等。</span><br><span class="line">关于 Servlet 的特点，以下是一些主要的特点：</span><br><span class="line">平台无关性：Servlet 是基于 Java 技术的，可以在任何支持 Java 的平台上运行，无论是 Windows、</span><br><span class="line">Linux 还是其他操作系统。</span><br><span class="line">可移植性：Servlet 可以在不同的 Web 容器中运行，例如 Tomcat、Jetty、WebLogic 等。</span><br><span class="line">这使得开发人员可以在不同的容器中部署和运行 Servlet，而不需要修改代码。</span><br><span class="line"></span><br><span class="line">@EnableConfigurationProperties(ServerProperties.class)：用于启用配置属性的绑定并将其注入到</span><br><span class="line">Spring 容器中。</span><br><span class="line">在这种情况下，ServerProperties 类的配置属性将被绑定到该自动配置类中。</span><br><span class="line">其中ServerProperties 类被@ConfigurationProperties(</span><br><span class="line">    prefix = &quot;server&quot;,</span><br><span class="line">    ignoreUnknownFields = true</span><br><span class="line">)修饰，@ConfigurationProperties 是一个注解，用于将配置属性绑定到一个类上。在上述代码中，</span><br><span class="line">它被应用在类级别上，表示将配置属性绑定到带有 prefix 前缀的属性上，并且忽略未知的字段。</span><br><span class="line">但是其ServerProperties 类在此时并未注入到容器中。</span><br><span class="line"></span><br><span class="line">@Import(&#123; ... &#125;)：该注解用于导入其他的配置类或组件。在这个例子中，它导入了与 Servlet Web</span><br><span class="line">服务器工厂相关的配置类，包括 Tomcat、Jetty 和 Undertow 的配置。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>ServletWebServerFactoryAutoConfiguration 自动配置了嵌入式容器场景</li>
<li>绑定了ServerProperties配置类，所有和服务器有关的配置 server（也就是配置文件·中以server开头的配置属性是关于服务器的）</li>
<li>ServletWebServerFactoryAutoConfiguration 导入了 嵌入式的三大服务器 Tomcat、Jetty、Undertow</li>
</ol>
<p>1.servlet不仅支持Tomcat服务器还支持Jetty ，Netty，Undertow服务器<br>
2.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ConditionalOnClass(&#123;Servlet.class, Tomcat.class, UpgradeProtocol.class&#125;)</span><br><span class="line">    @ConditionalOnMissingBean(</span><br><span class="line">        value = &#123;ServletWebServerFactory.class&#125;,</span><br><span class="line">        search = SearchStrategy.CURRENT</span><br><span class="line">    )</span><br><span class="line">    static class EmbeddedTomcat &#123;</span><br><span class="line">        EmbeddedTomcat() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">@ConditionalOnClass(&#123;Servlet.class, Tomcat.class, UpgradeProtocol.class&#125;)决定了web程序的服务器</span><br><span class="line">类型，而避免了其他类型的服务器。</span><br></pre></td></tr></table></figure>
<ol>
<li>导入 Tomcat、Jetty、Undertow 都有条件注解。系统中有这个类才行（也就是导了包）也是这种方式决定了web程序采用的服务器类型。</li>
<li>默认 Tomcat配置生效。给容器中放 TomcatServletWebServerFactory</li>
<li>都给容器中 ServletWebServerFactory放了一个** web服务器工厂（造web服务器的）可以在ServletWebServerFactoryAutoConfiguration类中查看到注入了不同的 ServletWebServerFactory**</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">       TomcatServletWebServerFactory tomcatServletWebServerFactory</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>**web服务器工厂 都有一个功能，**getWebServer获取web服务器。其中TomcatServletWebServerFactory 创建了tomcat而其他服务器工厂没有创建。</li>
<li>TomcatServletWebServerFactory 创建了 tomcat。</li>
<li>ServletWebServerFactory 什么时候会创建 webServer出来。</li>
<li>ServletWebServerApplicationContextioc容器，启动的时候会调用创建web服务器</li>
<li>Spring**容器刷新（启动）**的时候，会预留一个时机，刷新子容器。onRefresh()</li>
<li>refresh() 容器刷新 十二大步的刷新子容器会调用 onRefresh()；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onRefresh() &#123;</span><br><span class="line">	super.onRefresh();</span><br><span class="line">	try &#123;</span><br><span class="line">		createWebServer();</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		throw new ApplicationContextException(&quot;Unable to start web server&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Web场景的Spring容器启动，在onRefresh的时候，会调用创建web服务器的方法。<br>
Web服务器的创建是通过WebServerFactory搞定的。容器中又会根据导了什么包条件注解，启动相关的 服务器配置，默认EmbeddedTomcat会给容器中放一个 TomcatServletWebServerFactory，导致项目启动，自动创建出Tomcat。<br>
用法：<br>
1.修改server下的相关配置就可以修改服务器的参数<br>
2.通过给容器中放一个ServletWebServerFactory,来禁用掉springBoot默认配置的服务器工厂，实现自定义的嵌入式服务器。</p>
<h2 id="2-自定义">2. 自定义</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681725850466-2ecf12f4-8b66-469f-9d5d-377a33923b3c.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_19%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23ceae84&amp;from=url&amp;id=W0Ot4&amp;originHeight=268&amp;originWidth=668&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;servlet-api.version&gt;3.1.0&lt;/servlet-api.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;!-- Exclude the Tomcat dependency --&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- Use Jetty instead --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="3-最佳实践">3. 最佳实践</h2>
<p><strong>用法：</strong></p>
<ul>
<li>修改server下的相关配置就可以修改<strong>服务器参数</strong></li>
<li>通过给容器中放一个<strong>ServletWebServerFactory</strong>，来禁用掉SpringBoot默认放的服务器工厂，实现自定义嵌入<strong>任意服务器</strong>。</li>
</ul>
<h1>9. 全面接管SpringMVC</h1>
<ul>
<li>SpringBoot 默认配置好了 SpringMVC 的所有常用特性。</li>
<li>如果我们需要全面接管SpringMVC的所有配置并<strong>禁用默认配置</strong>，仅需要编写一个WebMvcConfigurer配置类，并标注 @EnableWebMvc 即可</li>
<li>全手动模式
<ul>
<li>@EnableWebMvc : 禁用默认配置，该注解在@Configuration上</li>
<li><strong>WebMvcConfigurer</strong>组件：定义MVC的底层行为</li>
</ul>
</li>
</ul>
<h2 id="1-WebMvcAutoConfiguration-到底自动配置了哪些规则">1. WebMvcAutoConfiguration 到底自动配置了哪些规则</h2>
<p>SpringMVC自动配置场景给我们配置了如下所有<strong>默认行为</strong></p>
<ol>
<li>WebMvcAutoConfigurationweb场景的自动配置类
<ol>
<li>支持RESTful的filter：HiddenHttpMethodFilter(HiddenHttpMethodFilter 的作用就是检查通过 POST 请求提交的表单数据中是否包含名为 _method 的隐藏字段，并将其值作为实际的 HTTP 方法进行处理。也就是新增了delete,和patch)</li>
<li>支持非POST请求，请求体携带数据：FormContentFilter(FormContentFilter 的作用是解析请求体中的表单数据，并将其转换为相应的请求参数，以便后续的处理器（Handler）能够方便地获取和使用这些参数。)</li>
<li>导入<strong>EnableWebMvcConfiguration</strong>：
<ol>
<li>RequestMappingHandlerAdapter</li>
<li>WelcomePageHandlerMapping： <strong>欢迎页功能</strong>支持（模板引擎目录、静态资源目录放index.html），项目访问/ 就默认展示这个页面.</li>
<li>RequestMappingHandlerMapping：找每个请求由谁处理的映射关系</li>
<li>ExceptionHandlerExceptionResolver：默认的异常解析器</li>
<li>LocaleResolver：国际化解析器</li>
<li>ThemeResolver：主题解析器</li>
<li>FlashMapManager：临时数据共享</li>
<li>FormattingConversionService： 数据格式化 、类型转化</li>
<li>Validator： 数据校验JSR303提供的数据校验功能</li>
<li>WebBindingInitializer：请求参数的封装与绑定</li>
<li>ContentNegotiationManager：内容协商管理器</li>
</ol>
</li>
<li><strong>WebMvcAutoConfigurationAdapter</strong>配置生效，它是一个WebMvcConfigurer，定义mvc底层组件
<ol>
<li>定义好 WebMvcConfigurer<strong>底层组件默认功能；所有功能详见列表</strong></li>
<li>视图解析器：InternalResourceViewResolver</li>
<li>视图解析器：BeanNameViewResolver,**视图名（controller方法的返回值字符串）**就是组件名</li>
<li>内容协商解析器：ContentNegotiatingViewResolver</li>
<li>请求上下文过滤器：RequestContextFilter: 任意位置直接获取当前请求</li>
<li>静态资源链规则</li>
<li>ProblemDetailsExceptionHandler：错误详情
<ol>
<li>SpringMVC内部场景异常被它捕获：</li>
</ol>
</li>
</ol>
</li>
<li>定义了MVC默认的底层行为: WebMvcConfigurer</li>
</ol>
</li>
</ol>
<h2 id="2-EnableWebMvc-禁用默认行为">2. @EnableWebMvc 禁用默认行为</h2>
<ol>
<li>@EnableWebMvc给容器中导入 DelegatingWebMvcConfiguration组件，</li>
</ol>
<p>他是 WebMvcConfigurationSupport</p>
<ol>
<li>WebMvcAutoConfiguration有一个核心的条件注解, @ConditionalOnMissingBean(WebMvcConfigurationSupport.class)，容器中没有WebMvcConfigurationSupport，WebMvcAutoConfiguration才生效.</li>
<li>@EnableWebMvc 导入 WebMvcConfigurationSupport 导致 WebMvcAutoConfiguration 失效。导致禁用了默认行为</li>
</ol>
<ul>
<li>@EnableWebMVC 禁用了 Mvc的自动配置</li>
<li>WebMvcConfigurer 定义SpringMVC底层组件的功能类</li>
</ul>
<h2 id="2-WebMvcConfigurer-功能">2. WebMvcConfigurer 功能</h2>
<p>定义扩展SpringMVC底层功能</p>
<table>
<thead>
<tr>
<th>提供方法</th>
<th>核心参数</th>
<th>功能</th>
<th>默认</th>
</tr>
</thead>
<tbody>
<tr>
<td>addFormatters</td>
<td>FormatterRegistry</td>
<td><strong>格式化器</strong>：支持属性上@NumberFormat和@DatetimeFormat的数据类型转换</td>
<td>GenericConversionService</td>
</tr>
<tr>
<td>getValidator</td>
<td>无</td>
<td><strong>数据校验</strong>：校验 Controller 上使用@Valid标注的参数合法性。需要导入starter-validator</td>
<td>无</td>
</tr>
<tr>
<td>addInterceptors</td>
<td>InterceptorRegistry</td>
<td><strong>拦截器</strong>：拦截收到的所有请求</td>
<td>无</td>
</tr>
<tr>
<td>configureContentNegotiation</td>
<td>ContentNegotiationConfigurer</td>
<td><strong>内容协商</strong>：支持多种数据格式返回。需要配合支持这种类型的HttpMessageConverter</td>
<td>支持 json</td>
</tr>
<tr>
<td>configureMessageConverters</td>
<td>List&lt;HttpMessageConverter&lt;?&gt;&gt;</td>
<td><strong>消息转换器</strong>：标注@ResponseBody的返回值会利用MessageConverter直接写出去</td>
<td>8 个，支持byte，string,multipart,resource，json</td>
</tr>
<tr>
<td>addViewControllers</td>
<td>ViewControllerRegistry</td>
<td><strong>视图映射</strong>：直接将请求路径与物理视图映射。用于无 java 业务逻辑的直接视图页渲染</td>
<td>无</td>
</tr>
<tr>
<td><a href="mvc:view-controller">mvc:view-controller</a></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>configureViewResolvers</td>
<td>ViewResolverRegistry</td>
<td><strong>视图解析器</strong>：逻辑视图转为物理视图</td>
<td>ViewResolverComposite</td>
</tr>
<tr>
<td>addResourceHandlers</td>
<td>ResourceHandlerRegistry</td>
<td><strong>静态资源处理</strong>：静态资源路径映射、缓存控制</td>
<td>ResourceHandlerRegistry</td>
</tr>
<tr>
<td>configureDefaultServletHandling</td>
<td>DefaultServletHandlerConfigurer</td>
<td><strong>默认 Servlet</strong>：可以覆盖 Tomcat 的DefaultServlet。让DispatcherServlet拦截/</td>
<td>无</td>
</tr>
<tr>
<td>configurePathMatch</td>
<td>PathMatchConfigurer</td>
<td><strong>路径匹配</strong>：自定义 URL 路径匹配。可以自动为所有路径加上指定前缀，比如 /api</td>
<td>无</td>
</tr>
<tr>
<td>configureAsyncSupport</td>
<td>AsyncSupportConfigurer</td>
<td><strong>异步支持</strong>：</td>
<td>TaskExecutionAutoConfiguration</td>
</tr>
<tr>
<td>addCorsMappings</td>
<td>CorsRegistry</td>
<td><strong>跨域</strong>：</td>
<td>无</td>
</tr>
<tr>
<td>addArgumentResolvers</td>
<td>List<HandlerMethodArgumentResolver></td>
<td><strong>参数解析器</strong>：</td>
<td>mvc 默认提供</td>
</tr>
<tr>
<td>addReturnValueHandlers</td>
<td>List<HandlerMethodReturnValueHandler></td>
<td><strong>返回值解析器</strong>：</td>
<td>mvc 默认提供</td>
</tr>
<tr>
<td>configureHandlerExceptionResolvers</td>
<td>List<HandlerExceptionResolver></td>
<td><strong>异常处理器</strong>：</td>
<td>默认 3 个</td>
</tr>
<tr>
<td>ExceptionHandlerExceptionResolver</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ResponseStatusExceptionResolver</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>DefaultHandlerExceptionResolver</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>getMessageCodesResolver</td>
<td>无</td>
<td><strong>消息码解析器</strong>：国际化使用</td>
<td>无</td>
</tr>
</tbody>
</table>
<h1>10. 最佳实践</h1>
<p>SpringBoot 已经默认配置好了<strong>Web开发</strong>场景常用功能。我们直接使用即可。</p>
<h2 id="三种方式">三种方式</h2>
<table>
<thead>
<tr>
<th>方式</th>
<th>用法</th>
<th></th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>全自动</strong></td>
<td>直接编写控制器逻辑</td>
<td></td>
<td>全部使用<strong>自动配置默认效果</strong></td>
</tr>
<tr>
<td><strong>手自一体</strong></td>
<td>@Configuration +</td>
<td></td>
<td></td>
</tr>
<tr>
<td>配置<strong>WebMvcConfigurer</strong>+</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>配置 WebMvcRegistrations</em></td>
<td><strong>不要标注</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>@<strong>EnableWebMvc</strong></td>
<td><strong>保留自动配置效果</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>手动设置部分功能</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>定义MVC底层组件</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>全手动</strong></td>
<td>@Configuration +</td>
<td></td>
<td></td>
</tr>
<tr>
<td>配置<strong>WebMvcConfigurer</strong></td>
<td><strong>标注</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>@<strong>EnableWebMvc</strong></td>
<td><strong>禁用自动配置效果</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>全手动设置</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>总结：<br>
<strong>给容器中写一个配置类@Configuration实现 WebMvcConfigurer但是不要标注 @EnableWebMvc注解，实现手自一体的效果。</strong></p>
<h1>11. Web新特性</h1>
<h2 id="1-Problemdetails">1. Problemdetails</h2>
<p>RFC 7807: <a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/rfc7807">https://www.rfc-editor.org/rfc/rfc7807</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProblemDetails 是一种在Web API中表示错误和异常信息的规范化格式。它是根据RFC 7807规范定义的，</span><br><span class="line">旨在提供一种统一的方式来描述和传递错误信息。</span><br></pre></td></tr></table></figure>
<p><strong>错误信息</strong>返回新格式<br>
原理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration(proxyBeanMethods = false)</span><br><span class="line">//配置过一个属性 spring.mvc.problemdetails.enabled=true才能让</span><br><span class="line">//ProblemDetailsErrorHandlingConfiguration生效，其中spring.mvc.problemdetails.enabled</span><br><span class="line">//默认是false的，也就是ProbleDetailsErroHandlingConfiguration默认是关闭的</span><br><span class="line">@ConditionalOnProperty(prefix = &quot;spring.mvc.problemdetails&quot;, name = &quot;enabled&quot;, havingValue = &quot;true&quot;)</span><br><span class="line">static class ProblemDetailsErrorHandlingConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(ResponseEntityExceptionHandler.class)</span><br><span class="line">    ProblemDetailsExceptionHandler problemDetailsExceptionHandler() &#123;</span><br><span class="line">        return new ProblemDetailsExceptionHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>ProblemDetailsExceptionHandler (被 @ControllerAdvice修饰的类）是一个 @ControllerAdvice集中处理系统异常,</strong></li>
<li><strong>ProblemDetailsExceptionHandler 继承</strong>ResponseEntityExceptionHandler ，而ResponseEntityExceptionHandler类有一个@ExceptionHandle注解用于修饰ResponseEntity<Object>类，其中@ExceptionHandle**处理以下异常。如果系统出现以下异常，会被SpringBoot支持以 **RFC 7807规范方式返回错误数据（但是该规范不是默认生效的）：</li>
</ol>
<p>使用@ExceptionHandler 注解时，您需要在方法中定义异常类型作为参数，并在方法体中编写相应的逻辑来处理该异常。当发生定义的异常时，Spring Boot将调用带有 @ExceptionHandler 注解的方法，并将异常传递给该方法进行处理。您可以在该方法中执行适当的操作，例如记录日志、返回自定义错误响应等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@ExceptionHandler(&#123;</span><br><span class="line">		HttpRequestMethodNotSupportedException.class, //请求方式不支持</span><br><span class="line">		HttpMediaTypeNotSupportedException.class,</span><br><span class="line">		HttpMediaTypeNotAcceptableException.class,</span><br><span class="line">		MissingPathVariableException.class,</span><br><span class="line">		MissingServletRequestParameterException.class,</span><br><span class="line">		MissingServletRequestPartException.class,</span><br><span class="line">		ServletRequestBindingException.class,</span><br><span class="line">		MethodArgumentNotValidException.class,</span><br><span class="line">		NoHandlerFoundException.class,</span><br><span class="line">		AsyncRequestTimeoutException.class,</span><br><span class="line">		ErrorResponseException.class,</span><br><span class="line">		ConversionNotSupportedException.class,</span><br><span class="line">		TypeMismatchException.class,</span><br><span class="line">		HttpMessageNotReadableException.class,</span><br><span class="line">		HttpMessageNotWritableException.class,</span><br><span class="line">		BindException.class</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<p>效果：也就是上面的ResponseEntity<Object>类处理异常的效果<br>
默认响应错误的json。状态码 405</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;timestamp&quot;: &quot;2023-04-18T11:13:05.515+00:00&quot;,</span><br><span class="line">    &quot;status&quot;: 405,</span><br><span class="line">    &quot;error&quot;: &quot;Method Not Allowed&quot;,</span><br><span class="line">    &quot;trace&quot;: &quot;org.springframework.web.HttpRequestMethodNotSupportedException: Request method &#x27;POST&#x27; is not supported\r\n\tat org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.handleNoMatch(RequestMappingInfoHandlerMapping.java:265)\r\n\tat org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.lookupHandlerMethod(AbstractHandlerMethodMapping.java:441)\r\n\tat org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.getHandlerInternal(AbstractHandlerMethodMapping.java:382)\r\n\tat org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getHandlerInternal(RequestMappingInfoHandlerMapping.java:126)\r\n\tat org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getHandlerInternal(RequestMappingInfoHandlerMapping.java:68)\r\n\tat org.springframework.web.servlet.handler.AbstractHandlerMapping.getHandler(AbstractHandlerMapping.java:505)\r\n\tat org.springframework.web.servlet.DispatcherServlet.getHandler(DispatcherServlet.java:1275)\r\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057)\r\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)\r\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)\r\n\tat org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)\r\n\tat jakarta.servlet.http.HttpServlet.service(HttpServlet.java:563)\r\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)\r\n\tat jakarta.servlet.http.HttpServlet.service(HttpServlet.java:631)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)\r\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)\r\n\tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)\r\n\tat org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)\r\n\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)\r\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)\r\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)\r\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:493)\r\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)\r\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)\r\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)\r\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)\r\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:390)\r\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)\r\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)\r\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1741)\r\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)\r\n\tat org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)\r\n\tat org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)\r\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n\tat java.base/java.lang.Thread.run(Thread.java:833)\r\n&quot;,</span><br><span class="line">    &quot;message&quot;: &quot;Method &#x27;POST&#x27; is not supported.&quot;,</span><br><span class="line">    &quot;path&quot;: &quot;/list&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开启ProblemDetails返回, 使用新的MediaType<br>
<strong>Content-Type: application/problem+json+ 额外扩展返回</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681816524680-e75cbe89-f90c-4ac4-8247-ec850308df65.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_29%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23fafaf9&amp;from=url&amp;id=xnTyF&amp;originHeight=40&amp;originWidth=1030&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="">**</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;: &quot;about:blank&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;Method Not Allowed&quot;,</span><br><span class="line">    &quot;status&quot;: 405,</span><br><span class="line">    &quot;detail&quot;: &quot;Method &#x27;POST&#x27; is not supported.&quot;,</span><br><span class="line">    &quot;instance&quot;: &quot;/list&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-函数式Web"><strong>2. 函数式Web</strong></h2>
<p><strong>SpringMVC 5.2 以后 允许我们使用函数式的方式，定义Web的请求处理流程。</strong><br>
<strong>函数式接口</strong><br>
<strong>Web请求处理的方式：</strong></p>
<ol>
<li><strong>@Controller + @RequestMapping：耦合式 （路由、业务耦合）</strong></li>
<li><strong>函数式Web：分离式（路由、业务分离）</strong></li>
</ol>
<h3 id="1-场景">1. 场景</h3>
<p>场景：User RESTful - CRUD</p>
<ul>
<li>GET /user/1 获取1号用户</li>
<li>GET /users 获取所有用户</li>
<li>POST /user ** 请求体**携带JSON，新增一个用户</li>
<li>PUT /user/1 <strong>请求体</strong>携带JSON，修改1号用户</li>
<li>DELETE /user/1** 删除**1号用户</li>
</ul>
<h3 id="2-核心类">2. 核心类</h3>
<ul>
<li><strong>RouterFunction</strong></li>
<li><strong>RequestPredicate</strong></li>
<li><strong>ServerRequest</strong></li>
<li><strong>ServerResponse</strong></li>
</ul>
<h3 id="3-示例">3. 示例</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.http.MediaType;</span><br><span class="line">import org.springframework.web.servlet.function.RequestPredicate;</span><br><span class="line">import org.springframework.web.servlet.function.RouterFunction;</span><br><span class="line">import org.springframework.web.servlet.function.ServerResponse;</span><br><span class="line"></span><br><span class="line">import static org.springframework.web.servlet.function.RequestPredicates.accept;</span><br><span class="line">import static org.springframework.web.servlet.function.RouterFunctions.route;</span><br><span class="line"></span><br><span class="line">@Configuration(proxyBeanMethods = false)</span><br><span class="line">public class MyRoutingConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    private static final RequestPredicate ACCEPT_JSON = accept(MediaType.APPLICATION_JSON);</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RouterFunction&lt;ServerResponse&gt; routerFunction(MyUserHandler userHandler) &#123;</span><br><span class="line">        return route()</span><br><span class="line">                .GET(&quot;/&#123;user&#125;&quot;, ACCEPT_JSON, userHandler::getUser)</span><br><span class="line">                .GET(&quot;/&#123;user&#125;/customers&quot;, ACCEPT_JSON, userHandler::getUserCustomers)</span><br><span class="line">                .DELETE(&quot;/&#123;user&#125;&quot;, ACCEPT_JSON, userHandler::deleteUser)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.web.servlet.function.ServerRequest;</span><br><span class="line">import org.springframework.web.servlet.function.ServerResponse;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class MyUserHandler &#123;</span><br><span class="line"></span><br><span class="line">    public ServerResponse getUser(ServerRequest request) &#123;</span><br><span class="line">        ...</span><br><span class="line">        return ServerResponse.ok().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ServerResponse getUserCustomers(ServerRequest request) &#123;</span><br><span class="line">        ...</span><br><span class="line">        return ServerResponse.ok().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ServerResponse deleteUser(ServerRequest request) &#123;</span><br><span class="line">        ...</span><br><span class="line">        return ServerResponse.ok().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.web.config;</span><br><span class="line"></span><br><span class="line">import com.atguigu.web.bean.Person;</span><br><span class="line">import com.atguigu.web.biz.UserBizHandler;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.http.MediaType;</span><br><span class="line">import org.springframework.web.servlet.function.RequestPredicates;</span><br><span class="line">import org.springframework.web.servlet.function.RouterFunction;</span><br><span class="line">import org.springframework.web.servlet.function.RouterFunctions;</span><br><span class="line">import org.springframework.web.servlet.function.ServerResponse;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author lfy</span><br><span class="line"> * @Description</span><br><span class="line"> * @create 2023-04-18 21:46</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 场景：User RESTful - CRUD</span><br><span class="line"> * ● GET /user/1  获取1号用户</span><br><span class="line"> * ● GET /users   获取所有用户</span><br><span class="line"> * ● POST /user  请求体携带JSON，新增一个用户</span><br><span class="line"> * ● PUT /user/1 请求体携带JSON，修改1号用户</span><br><span class="line"> * ● DELETE /user/1 删除1号用户</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class WebFunctionConfig &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 函数式Web：</span><br><span class="line">     * 1、给容器中放一个Bean：类型是 RouterFunction&lt;ServerResponse&gt;，集中所有路由信息</span><br><span class="line">     * 2、每个业务准备一个自己的Handler</span><br><span class="line">     *</span><br><span class="line">     *</span><br><span class="line">     * 核心四大对象</span><br><span class="line">     * 1、RouterFunction： 定义路由信息。发什么请求，谁来处理</span><br><span class="line">     * 2、RequestPredicate：定义请求规则：请求谓语。请求方式（GET、POST）、请求参数</span><br><span class="line">     * 3、ServerRequest：  封装请求完整数据</span><br><span class="line">     * 4、ServerResponse： 封装响应完整数据</span><br><span class="line">     */</span><br><span class="line">    @Bean//如果修饰在方法上，那么其方法的参数是从容器中获取的</span><br><span class="line">    public RouterFunction&lt;ServerResponse&gt; userRoute(UserBizHandler userBizHandler/*这个会被自动注入进来*/)&#123;</span><br><span class="line"></span><br><span class="line">        return RouterFunctions.route() //开始定义路由信息</span><br><span class="line">                .GET(&quot;/user/&#123;id&#125;&quot;, RequestPredicates.accept(MediaType.ALL), userBizHandler::getUser)</span><br><span class="line">                .GET(&quot;/users&quot;, userBizHandler::getUsers)</span><br><span class="line">                .POST(&quot;/user&quot;, RequestPredicates.accept(MediaType.APPLICATION_JSON), userBizHandler::saveUser)</span><br><span class="line">                .PUT(&quot;/user/&#123;id&#125;&quot;, RequestPredicates.accept(MediaType.APPLICATION_JSON), userBizHandler::updateUser)</span><br><span class="line">                .DELETE(&quot;/user/&#123;id&#125;&quot;, userBizHandler::deleteUser)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//    @Bean</span><br><span class="line">//    public RouterFunction&lt;ServerResponse&gt; groupRoute(UserBizHandler userBizHandler/*这个会被自动注入进来*/)&#123;</span><br><span class="line">//</span><br><span class="line">//        return RouterFunctions.route() //开始定义路由信息</span><br><span class="line">//                .GET(&quot;/user/&#123;id&#125;&quot;, RequestPredicates.accept(MediaType.ALL), userBizHandler::getUser)</span><br><span class="line">//                .GET(&quot;/users&quot;, userBizHandler::getUsers)</span><br><span class="line">//                .POST(&quot;/user&quot;, RequestPredicates.accept(MediaType.APPLICATION_JSON), userBizHandler::saveUser)</span><br><span class="line">//                .PUT(&quot;/user/&#123;id&#125;&quot;, RequestPredicates.accept(MediaType.APPLICATION_JSON), userBizHandler::updateUser)</span><br><span class="line">//                .DELETE(&quot;/user/&#123;id&#125;&quot;, userBizHandler::deleteUser)</span><br><span class="line">//                .build();</span><br><span class="line">//    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.web.biz;</span><br><span class="line"></span><br><span class="line">import com.atguigu.web.bean.Person;</span><br><span class="line">import jakarta.servlet.ServletException;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.web.servlet.function.ServerRequest;</span><br><span class="line">import org.springframework.web.servlet.function.ServerResponse;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author lfy</span><br><span class="line"> * @Description 专门处理User有关的业务</span><br><span class="line"> * @create 2023-04-18 21:55</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">@Service</span><br><span class="line">public class UserBizHandler &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询指定id的用户</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public ServerResponse getUser(ServerRequest request) throws Exception&#123;</span><br><span class="line">        String id = request.pathVariable(&quot;id&quot;);</span><br><span class="line">        log.info(&quot;查询 【&#123;&#125;】 用户信息，数据库正在检索&quot;,id);</span><br><span class="line">        //业务处理</span><br><span class="line">        Person person = new Person(1L,&quot;哈哈&quot;,&quot;aa@qq.com&quot;,18,&quot;admin&quot;);</span><br><span class="line">        //构造响应</span><br><span class="line">        return ServerResponse</span><br><span class="line">                .ok()</span><br><span class="line">                .body(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取所有用户</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public ServerResponse getUsers(ServerRequest request) throws Exception&#123;</span><br><span class="line">        log.info(&quot;查询所有用户信息完成&quot;);</span><br><span class="line">        //业务处理</span><br><span class="line">        List&lt;Person&gt; list = Arrays.asList(new Person(1L, &quot;哈哈&quot;, &quot;aa@qq.com&quot;, 18, &quot;admin&quot;),</span><br><span class="line">                new Person(2L, &quot;哈哈2&quot;, &quot;aa2@qq.com&quot;, 12, &quot;admin2&quot;));</span><br><span class="line"></span><br><span class="line">        //构造响应</span><br><span class="line">        return ServerResponse</span><br><span class="line">                .ok()</span><br><span class="line">                .body(list); //凡是body中的对象，就是以前@ResponseBody原理。利用HttpMessageConverter 写出为json</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 保存用户</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public ServerResponse saveUser(ServerRequest request) throws ServletException, IOException &#123;</span><br><span class="line">        //提取请求体</span><br><span class="line">        Person body = request.body(Person.class);</span><br><span class="line">        log.info(&quot;保存用户信息：&#123;&#125;&quot;,body);</span><br><span class="line">        return ServerResponse.ok().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 更新用户</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public ServerResponse updateUser(ServerRequest request) throws ServletException, IOException &#123;</span><br><span class="line">        Person body = request.body(Person.class);</span><br><span class="line">        log.info(&quot;保存用户信息更新: &#123;&#125;&quot;,body);</span><br><span class="line">        return ServerResponse.ok().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除用户</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public ServerResponse deleteUser(ServerRequest request) &#123;</span><br><span class="line">        String id = request.pathVariable(&quot;id&quot;);</span><br><span class="line">        log.info(&quot;删除【&#123;&#125;】用户信息&quot;,id);</span><br><span class="line">        return ServerResponse.ok().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1><strong>3、SpringBoot3-数据访问</strong></h1>
<p><strong>整合SSM场景SpringBoot 整合 Spring、SpringMVC、MyBatis 进行数据访问场景开发</strong><br>
**创建SSM项目（在创建springboot的时候勾选要导入的包）：</p>
<p>**</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.0.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-配置数据源">2. 配置数据源</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://192.168.200.100:3306/demo</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br><span class="line">spring.datasource.type=com.zaxxer.hikari.HikariDataSource</span><br></pre></td></tr></table></figure>
<p>安装MyBatisX 插件，帮我们生成Mapper接口的xml文件即可。MyBatisX的使用：<br>
选中接口名-&gt;点击右键-&gt;选择显示上下文操作-&gt;选择MybatisX的功能<br>
或者选中接口名Altet+Enter<br>
在接口下的方法使用Alter+Enter可以生成相应的sql语句 片段</p>
<h2 id="3-配置MyBatis">3. 配置MyBatis</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#指定mapper映射文件位置</span><br><span class="line">mybatis.mapper-locations=classpath:/mapper/*.xml</span><br><span class="line">#参数项调整，也就是可以把数据库表中的下划线命名的属性转换为驼峰命名</span><br><span class="line">mybatis.configuration.map-underscore-to-camel-case=true</span><br></pre></td></tr></table></figure>
<h2 id="4-CRUD编写"><strong>4. CRUD编写</strong></h2>
<p>CRUD 是一个常用的术语，用于描述对于持久化数据的基本操作。CRUD 是 Create（创建）、Read（读取）、Update（更新）和Delete（删除）的缩写。</p>
<ul>
<li><strong>编写Bean</strong></li>
<li><strong>编写Mapper</strong></li>
<li><strong>使用mybatisx插件，快速生成MapperXML</strong></li>
<li><strong>测试CRUD</strong></li>
</ul>
<p><strong>总结：</strong><br>
<strong>1.</strong>@Data//生成get和set方法<br>
<strong>2.controller类下的</strong><br>
@Autowired//下面的提示的来源是因为这个时候，UserMapper中的接口没有注入到容器中，是springboot启动利用@MapperScan才将该接口注入到容器中的<br>
UserMapper userMapper**;<strong>3.mapper接口中的</strong><em>每个方法都在Mapper文件中有一个sql标签对应。所有参数都应该用@Param进行签名，以后使用指定的名字在SQL中取值</em><br>
4.mapper.xml文件中的<mapper>标签namespace属性也就是全类名接口的全类名和namespace的值是一一对应的<br>
5.使用mybatis对数据库进行操作的时候，在spriongboot启动类的前要添加MapperScan(basePackages = “com.atguigu.boot3.ssm.mapper”)<br>
_1、@MapperScan【批量扫描注解】； 告诉MyBatis，扫描哪个包下面的所有接口</p>
<ul>
<li><em>**</em>@MapperScan _**_是 MyBatis-Spring 框架提供的注解，用于扫描指定包下的 Mapper 接口，并将其注册为 Spring 的 Bean。</li>
<li>这样就可以在controller中使用自动注入</li>
<li>2、在配置文件中使用mybatis.mapper-locations，告诉MyBatis，每个接口的xml文件都在哪里_</li>
</ul>
<h2 id="5-自动配置原理"><strong>5. 自动配置原理</strong></h2>
<p><strong>SSM整合总结：</strong></p>
<ol>
<li><strong>导入 mybatis-spring-boot-starter</strong></li>
<li><strong>配置数据源信息</strong></li>
<li><strong>配置mybatis的mapper接口扫描与xml映射文件扫描</strong></li>
<li><strong>编写bean，mapper，生成xml，编写sql 进行crud。事务等操作依然和Spring中用法一样</strong></li>
<li><strong>效果：</strong>
<ol>
<li><strong>所有sql写在xml中</strong></li>
<li><strong>所有mybatis配置写在application.properties下面</strong></li>
</ol>
</li>
</ol>
<ul>
<li>jdbc场景的自动配置：
<ul>
<li><strong>mybatis-spring-boot-starter导入 spring-boot-starter-jdbc，jdbc是操作数据库的场景</strong></li>
<li><strong>Jdbc场景的几个自动配置()</strong>
<ul>
<li><strong>org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</strong>
<ul>
<li><strong>数据源的自动配置</strong></li>
<li><strong>所有和数据源有关的配置都绑定在DataSourceProperties类中</strong></li>
<li><strong>默认使用 HikariDataSource。</strong></li>
</ul>
</li>
<li><strong>org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration</strong>
<ul>
<li><strong>给容器中放了JdbcTemplate操作数据库</strong></li>
</ul>
</li>
<li><strong>org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration</strong></li>
<li><strong>org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration</strong>
<ul>
<li><strong>基于XA二阶提交协议的分布式事务数据源</strong></li>
</ul>
</li>
<li><strong>org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration</strong>
<ul>
<li><strong>支持事务</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>具有的底层能力：数据源、JdbcTemplate、事务</strong></li>
</ul>
</li>
<li>MyBatisAutoConfiguration：配置了MyBatis的整合流程
<ul>
<li>mybatis-spring-boot-starter导入 mybatis-spring-boot-autoconfigure（mybatis的自动配置包），</li>
<li>默认加载两个自动配置类：
<ul>
<li>org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration</li>
<li>org.mybatis.spring.boot.autoconfigure.<strong>MybatisAutoConfiguration</strong>
<ul>
<li><strong>必须在数据源配置好之后才配置</strong></li>
<li>给容器中SqlSessionFactory组件。创建和数据库的一次会话</li>
<li>给容器中SqlSessionTemplate组件。操作数据库</li>
</ul>
</li>
</ul>
</li>
<li><strong>MyBatis的所有配置绑定在</strong>MybatisProperties</li>
<li>每个<strong>Mapper接口</strong>的<strong>代理对象</strong>是怎么创建放到容器中。详见**@MapperScan**原理：
<ul>
<li>利用@Import(MapperScannerRegistrar.class)批量给容器中注册组件。解析指定的包路径里面的每一个类，为每一个Mapper接口类，创建Bean定义信息，注册到容器中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如何分析哪个场景导入以后，开启了哪些自动配置类。<br>
找：classpath:/<strong>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</strong>文件中配置的所有值，就是要开启的自动配置类，但是每个类可能有条件注解，基于条件注解判断哪个自动配置类生效了。</p>
<h2 id="6-快速定位生效的配置">6. 快速定位生效的配置</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#开启调试模式，详细打印开启了哪些自动配置</span><br><span class="line">debug=true</span><br><span class="line"># Positive（生效的自动配置）  Negative（不生效的自动配置）</span><br></pre></td></tr></table></figure>
<h2 id="7-扩展：整合其他数据源">7. 扩展：整合其他数据源</h2>
<h3 id="1-Druid-数据源">1. Druid 数据源</h3>
<p>暂不支持 SpringBoot3</p>
<ul>
<li>导入druid-starter</li>
<li>写配置</li>
<li>分析自动配置了哪些东西，怎么用</li>
</ul>
<p>Druid官网：<a target="_blank" rel="noopener" href="https://github.com/alibaba/druid">https://github.com/alibaba/druid</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#数据源基本配置</span><br><span class="line">spring.datasource.url=jdbc:mysql://192.168.200.100:3306/demo</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"></span><br><span class="line"># 配置StatFilter监控</span><br><span class="line">spring.datasource.druid.filter.stat.enabled=true</span><br><span class="line">spring.datasource.druid.filter.stat.db-type=mysql</span><br><span class="line">spring.datasource.druid.filter.stat.log-slow-sql=true</span><br><span class="line">spring.datasource.druid.filter.stat.slow-sql-millis=2000</span><br><span class="line"># 配置WallFilter防火墙</span><br><span class="line">spring.datasource.druid.filter.wall.enabled=true</span><br><span class="line">spring.datasource.druid.filter.wall.db-type=mysql</span><br><span class="line">spring.datasource.druid.filter.wall.config.delete-allow=false</span><br><span class="line">spring.datasource.druid.filter.wall.config.drop-table-allow=false</span><br><span class="line"># 配置监控页，内置监控页面的首页是 /druid/index.html</span><br><span class="line">spring.datasource.druid.stat-view-servlet.enabled=true</span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-username=admin</span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-password=admin</span><br><span class="line">spring.datasource.druid.stat-view-servlet.allow=*</span><br><span class="line"></span><br><span class="line"># 其他 Filter 配置不再演示</span><br><span class="line"># 目前为以下 Filter 提供了配置支持，请参考文档或者根据IDE提示（spring.datasource.druid.filter.*）进行配置。</span><br><span class="line"># StatFilter</span><br><span class="line"># WallFilter</span><br><span class="line"># ConfigFilter</span><br><span class="line"># EncodingConvertFilter</span><br><span class="line"># Slf4jLogFilter</span><br><span class="line"># Log4jFilter</span><br><span class="line"># Log4j2Filter</span><br><span class="line"># CommonsLogFilter</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="附录：示例数据库-要先自己创建test数据库）"><strong>附录：示例数据库(要先自己创建test数据库）</strong></h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t_user`</span><br><span class="line">(</span><br><span class="line">    `id`         BIGINT(20)   NOT NULL AUTO_INCREMENT COMMENT &#x27;编号&#x27;,</span><br><span class="line">    `login_name` VARCHAR(200) NULL DEFAULT NULL COMMENT &#x27;用户名称&#x27; COLLATE &#x27;utf8_general_ci&#x27;,</span><br><span class="line">    `nick_name`  VARCHAR(200) NULL DEFAULT NULL COMMENT &#x27;用户昵称&#x27; COLLATE &#x27;utf8_general_ci&#x27;,</span><br><span class="line">    `passwd`     VARCHAR(200) NULL DEFAULT NULL COMMENT &#x27;用户密码&#x27; COLLATE &#x27;utf8_general_ci&#x27;,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">);</span><br><span class="line">insert into t_user(login_name, nick_name, passwd) VALUES (&#x27;zhangsan&#x27;,&#x27;张三&#x27;,&#x27;123456&#x27;);</span><br></pre></td></tr></table></figure>
<h1><strong>4、SpringBoot3-基础特性</strong></h1>
<ol>
<li>SpringApplication1.1. 自定义 banner类路径添加banner.txt或设置spring.banner.location就可以定制<br>
这里是在配置文件中设置spring.banner.location=classpath:banner.txt然后在banner.txt文件中填充即可。<br>
banner.txt中可以存放Ascll类型的文本，当然图片生成的Ascall类型的也是可以的<br>
banner推荐网站：<a target="_blank" rel="noopener" href="https://www.bootschool.net/ascii"><strong>Spring Boot banner 在线生成工具，制作下载英文 banner.txt，修改替换 banner.txt 文字实现自定义，个性化启动 banner-bootschool.net</strong></a><br>
**Spring Boot 中有一个名为 “Banner” 的功能，它用于在应用程序启动时显示自定义的启动横幅。横幅是一个包含 ASCII 艺术、应用程序名称和版本号等信息的文本，它可以用于个性化应用程序的启动过程。<br>
上面的横幅就是启动成功的这个：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1691459425977-b78e1673-8a61-41ae-b1b0-d487510bd937.png#averageHue=%23383532&amp;clientId=u8fdb1034-8532-4&amp;from=paste&amp;height=173&amp;id=u65bf48e5&amp;originHeight=216&amp;originWidth=752&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=13871&amp;status=done&amp;style=none&amp;taskId=u3dae8db9-32d1-451c-8898-afe829c3c40&amp;title=&amp;width=601.6" alt="image.png"></li>
</ol>
<h2 id="1-2-自定义-SpringApplication">1.2. 自定义 SpringApplication</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.boot.Banner;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class MyApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication application = new SpringApplication(MyApplication.class);</span><br><span class="line">        application.setBannerMode(Banner.Mode.OFF);</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-FluentBuilder-API">1.3. FluentBuilder API</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new SpringApplicationBuilder()</span><br><span class="line">    .sources(Parent.class)</span><br><span class="line">    .child(Application.class)</span><br><span class="line">    .bannerMode(Banner.Mode.OFF)</span><br><span class="line">    .run(args);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication //主程序类</span><br><span class="line">public class  Boot306FeaturesApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //1、SpringApplication: Boot应用的核心API入口</span><br><span class="line">//        SpringApplication.run(Boot306FeaturesApplication.class, args);</span><br><span class="line">//        args是springboot应用启动的核心参数</span><br><span class="line"></span><br><span class="line">        //===============1、自定义 SpringApplication 的底层设置，也就是把SpringApplication.run(Boot306FeaturesApplication.class, args);</span><br><span class="line">//        分开，生成SpringApplication类,然后根据SpringApplication类来自定义启动的相关设置</span><br><span class="line">//        SpringApplication application = new SpringApplication(Boot306FeaturesApplication.class);</span><br><span class="line">//</span><br><span class="line">//        //程序化调整【SpringApplication的参数】</span><br><span class="line">////        application.setDefaultProperties();</span><br><span class="line">//        //这个配置不优先，作用是将banner的打印关闭。如果配置文件有类似的配置，配置文件优先</span><br><span class="line">//        application.setBannerMode(Banner.Mode.OFF);</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">//        //【配置文件优先级高于程序化调整的优先级】</span><br><span class="line">//</span><br><span class="line">//        //2、SpringApplication 运行起来</span><br><span class="line">//        application.run(args);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //================2、Builder方式构建 SpringApplication； 通过FluentAPI进行设置</span><br><span class="line">        ConfigurableApplicationContext context = new SpringApplicationBuilder()</span><br><span class="line">                .main(Boot306FeaturesApplication.class) //各种参数均可设置</span><br><span class="line">                .sources(Boot306FeaturesApplication.class)</span><br><span class="line">                .bannerMode(Banner.Mode.CONSOLE)</span><br><span class="line">                .properties(&quot;server.port=8888&quot;,&quot;aaa=bbb&quot;) //springboot所有配置项都可以在这里定义</span><br><span class="line">//                .environment(null)</span><br><span class="line">//                .listeners(null)</span><br><span class="line">                .run(args);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Cat cat = context.getBean(Cat.class);</span><br><span class="line">            log.info(&quot;组件cat：&#123;&#125;&quot;,cat);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Dog dog = context.getBean(Dog.class);</span><br><span class="line">            log.info(&quot;组件dog：&#123;&#125;&quot;,dog);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Pig pig = context.getBean(Pig.class);</span><br><span class="line">            log.info(&quot;组件pig：&#123;&#125;&quot;,pig);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Sheep sheep = context.getBean(Sheep.class);</span><br><span class="line">            log.info(&quot;组件sheep：&#123;&#125;&quot;,sheep);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#指定banner文本的路径</span><br><span class="line">spring.banner.location=classpath:banner.txt</span><br><span class="line">#关闭banner模式</span><br><span class="line">spring.main.banner-mode=off</span><br></pre></td></tr></table></figure>
<h1>2. Profiles</h1>
<p>环境隔离能力；快速切换开发、测试、生产环境(最好的例子就是在开发，测试，生产所需要的数据库不一样，这个时候就需要自动切换数据库）<br>
步骤：</p>
<ol>
<li><strong>标识环境</strong>：指定哪些组件、配置在哪个环境生效</li>
<li><strong>切换环境</strong>：这个环境对应的所有组件和配置就应该生效</li>
</ol>
<h2 id="2-1-使用">2.1. 使用</h2>
<h3 id="2-1-1-指定环境"><strong>2.1.1 指定环境</strong></h3>
<ul>
<li>Spring Profiles 提供一种<strong>隔离配置</strong>的方式，使其仅在<strong>特定环境</strong>生效；</li>
<li>任何@Component, @Configuration 或 @ConfigurationProperties 可以使用 @Profile 标记，来指定何时被加载。【<strong>容器中的组件</strong>都可以被 @Profile标记】</li>
</ul>
<h3 id="2-1-2-环境激活（也就是指定当前系统运行的特定环境）"><strong>2.1.2 环境激活（也就是指定当前系统运行的特定环境）</strong></h3>
<ol>
<li>配置激活指定环境； 配置文件</li>
</ol>
<p>spring.profiles.active=production,hsqldb</p>
<ol>
<li>也可以使用命令行激活。–spring.profiles.active=dev,hsqldb</li>
<li>还可以配置<strong>默认环境</strong>； 不标注@Profile 的组件永远都存在。
<ol>
<li>以前默认环境叫default</li>
<li>spring.profiles.default=test修改默认环境是test，变形激活了test环境</li>
</ol>
</li>
<li>推荐使用激活方式激活指定环境</li>
</ol>
<h3 id="2-1-3-环境包含"><strong>2.1.3 环境包含</strong></h3>
<p>注意：</p>
<ol>
<li>spring.profiles.active 和spring.profiles.default 只能用到** 无 profile 的文件<strong>中，如果在application-dev.yaml中编写就是</strong>无效的**</li>
<li>也可以额外添加生效文件，而不是激活替换。比如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.include[0]=common</span><br><span class="line">spring.profiles.include[1]=local</span><br></pre></td></tr></table></figure>
<p>最佳实战：</p>
<ul>
<li>**生效的环境 **= <strong>激活的环境/默认环境</strong> + <strong>包含的环境</strong></li>
<li>项目里面这么用
<ul>
<li>基础的配置mybatis、log、xxx：写到<strong>包含环境中</strong></li>
<li>需要动态切换变化的 db、redis：写到<strong>激活的环境中</strong></li>
</ul>
</li>
</ul>
<h2 id="2-2-Profile-分组">2.2. Profile 分组</h2>
<p>创建prod组，指定包含db和mq配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.group.prod[0]=db</span><br><span class="line">spring.profiles.group.prod[1]=mq</span><br></pre></td></tr></table></figure>
<p>使用–spring.profiles.active=prod ，就会激活prod，db，mq配置文件</p>
<h2 id="2-3-Profile-配置文件">2.3. Profile 配置文件</h2>
<ul>
<li>application-{profile}.properties可以作为<strong>指定环境的配置文件</strong>。</li>
<li>激活这个环境，<strong>配置</strong>就会生效。最终生效的所有<strong>配置</strong>是
<ul>
<li>application.properties：主配置文件，任意时候都生效</li>
<li>application-{profile}.properties：指定环境配置文件，激活指定环境生效</li>
</ul>
</li>
</ul>
<p>profile优先级 &gt; application</p>
<h1>3. 外部化配置</h1>
<p><strong>场景</strong>：线上应用如何<strong>快速修改配置</strong>，并应<strong>用最新配置</strong>？</p>
<ul>
<li>SpringBoot 使用 <strong>配置优先级</strong> + <strong>外部配置</strong> 简化配置更新、简化运维。</li>
<li>只需要给jar应用所在的文件夹放一个application.properties最新配置文件，重启项目就能自动应用最新配置</li>
</ul>
<h2 id="3-1-配置优先级">3.1. 配置优先级</h2>
<p>Spring Boot 允许将<strong>配置外部化</strong>，以便可以在不同的环境中使用相同的应用程序代码。<br>
我们可以使用各种<strong>外部配置源</strong>，包括Java Properties文件、YAML文件、环境变量和命令行参数。<br>
@Value可以获取值，也可以用@ConfigurationProperties将所有属性绑定到java object中<br>
<strong>以下是 SpringBoot 属性源加载顺序。后面的会覆盖前面的值</strong>。由低到高，高优先级配置覆盖低优先级</p>
<ol>
<li><strong>默认属性</strong>（通过SpringApplication.setDefaultProperties指定的）</li>
<li>@PropertySource指定加载的配置（需要写在@Configuration类上才可生效）,其中指定加载 类的文件一般是配置文件</li>
<li><strong>配置文件（application.properties/yml等）</strong></li>
<li>RandomValuePropertySource支持的random.*配置（如：@Value(“${random.int}”)）</li>
<li>OS 环境变量</li>
<li>Java 系统属性（System.getProperties()）</li>
<li>JNDI 属性（来自java:comp/env）</li>
<li>ServletContext初始化参数</li>
<li>ServletConfig初始化参数</li>
<li>SPRING_APPLICATION_JSON属性（内置在环境变量或系统属性中的 JSON）</li>
<li><strong>命令行参数</strong></li>
<li>测试属性。(@SpringBootTest进行测试时指定的属性)</li>
<li>测试类@TestPropertySource注解</li>
<li>Devtools 设置的全局属性。($HOME/.config/spring-boot)</li>
</ol>
<p>结论：配置可以写到很多位置，常见的优先级顺序：</p>
<ul>
<li>命令行&gt; 配置文件&gt; springapplication配置（可以这样理解程序运行的时候，先运行springboot启动程序的默认配置，然后读取配置文件，然后是命令行运行。相当于后面的配置信息会覆盖前面的，可以这样理解但是实际上并非是这样的）</li>
</ul>
<p><strong>配置文件优先级</strong>如下：(<strong>后面覆盖前面</strong>)</p>
<ol>
<li><strong>jar 包内</strong>的application.properties/yml</li>
<li><strong>jar 包内</strong>的application-{profile}.properties/yml</li>
<li><strong>jar 包外</strong>的application.properties/yml</li>
<li><strong>jar 包外</strong>的application-{profile}.properties/yml</li>
</ol>
<p><strong>建议</strong>：<strong>用一种格式的配置文件</strong>。<strong>如果.properties和.yml同时存在,则.properties优先</strong><br>
结论：包外 &gt; 包内； 同级情况：profile配置 &gt; application配置<br>
<strong>所有参数均可由命令行传入，使用–参数项=参数值，将会被添加到环境变量中，并优先于配置文件。</strong><br>
<strong>比如java -jar app.jar --name=“Spring”,可以使用@Value(“${name}”)获取</strong></p>
<p>演示场景：</p>
<ul>
<li>包内： application.properties server.port=8000</li>
<li>包内： application-dev.properties server.port=9000</li>
<li>包外：  application.properties server.port=8001</li>
<li>包外： application-dev.properties server.port=9001</li>
</ul>
<p>启动端口？：命令行 &gt; 9001 &gt; 8001 &gt; 9000 &gt; 8000</p>
<h2 id="3-2-外部配置">3.2. 外部配置</h2>
<p>SpringBoot 应用启动时会自动寻找application.properties和application.yaml位置，进行加载。顺序如下：（<strong>后面覆盖前面</strong>）</p>
<ol>
<li>类路径: 内部
<ol>
<li>类根路径</li>
<li>类下/config包</li>
</ol>
</li>
<li>当前路径（项目所在的位置）
<ol>
<li>当前路径</li>
<li>当前下/config子目录</li>
<li>/config目录的直接子目录</li>
</ol>
</li>
</ol>
<p>最终效果：优先级由高到低，前面覆盖后面</p>
<ul>
<li>命令行 &gt; 包外config直接子目录 &gt; 包外config目录 &gt; 包外根目录 &gt; 包内目录</li>
<li>同级比较：
<ul>
<li>profile配置 &gt; 默认配置</li>
<li>properties配置 &gt; yaml配置</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/svg/28066124/1691418639180-bac5ede2-c3e2-4a60-bf81-b015e53ea599.svg#clientId=u8fdb1034-8532-4&amp;from=paste&amp;height=535&amp;id=u4b284044&amp;originHeight=669&amp;originWidth=694&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=91719&amp;status=done&amp;style=none&amp;taskId=ue9940951-a38d-4801-9025-9879191c5cd&amp;title=&amp;width=555.2" alt="未命名绘图.svg"><br>
**规律：最外层的最优先。</p>
<ul>
<li><strong>命令行 &gt; 所有</strong></li>
<li><strong>包外 &gt; 包内</strong></li>
<li><strong>config目录 &gt; 根目录</strong></li>
<li>**profile &gt; application **</li>
</ul>
<p><strong>配置不同就都生效（互补），配置相同高优先级覆盖低优先级</strong></p>
<h2 id="3-3-导入配置">3.3. 导入配置</h2>
<p>使用spring.config.import可以导入额外配置：<br>
导入配置的优先级低于配置文件的优先级。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.config.import=my.properties</span><br><span class="line">my.property=value</span><br></pre></td></tr></table></figure>
<p>无论以上写法的先后顺序，my.properties的值总是优先于直接在文件中编写的my.property。</p>
<h2 id="3-4-属性占位符">3.4. 属性占位符</h2>
<p>配置文件中可以使用 ${name:default}形式取出之前配置过的值，${name:default}这里的意思是配置文件中有name值，就采用该值，没有的换就让name的值为default的值。@Value可以获取配置文件中的值，@Value(${name：hahha}) String name表示如果配置文件没有name的配置那么name的值为haha,如果有name的值就是配置文件中的值，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Value注解是Spring框架提供的一种方式，可以从外部的配置文件、系统属性或表达式中获取值，</span><br><span class="line">并赋给Bean中的字段或参数。@Value注解的参数是一个字符串，可以是一个普通的字符串，也可以是一个占</span><br><span class="line">位符或表达式，用$ &#123;&#125;或# &#123;&#125;包围。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.name=MyApp</span><br><span class="line">app.description=$&#123;app.name&#125; is a Spring Boot application written by $&#123;username:Unknown&#125;</span><br></pre></td></tr></table></figure>
<h1><strong>4. 单元测试-JUnit5</strong></h1>
<h2 id="4-1-整合">4.1. 整合</h2>
<p>SpringBoot 提供一系列测试工具集及注解方便我们进行测试。<br>
spring-boot-test提供核心测试能力，spring-boot-test-autoconfigure提供测试的一些自动配置。<br>
我们只需要导入spring-boot-starter-test即可整合测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>spring-boot-starter-test默认提供了以下库供我们测试使用</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://junit.org/junit5/"><strong>JUnit 5</strong></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/6.0.4/reference/html/testing.html#integration-testing"><strong>Spring Test</strong></a></li>
<li><a target="_blank" rel="noopener" href="https://assertj.github.io/doc/"><strong>AssertJ</strong></a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/hamcrest/JavaHamcrest"><strong>Hamcrest</strong></a></li>
<li><a target="_blank" rel="noopener" href="https://site.mockito.org/"><strong>Mockito</strong></a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/skyscreamer/JSONassert"><strong>JSONassert</strong></a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/jayway/JsonPath"><strong>JsonPath</strong></a></li>
</ul>
<h2 id="4-2-测试"><strong>4.2. 测试</strong></h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.@SpringBootTest //具备测试SpringBoot应用容器中所有组件的功能,测试的时候会启动spingboot</span><br><span class="line"></span><br><span class="line">//测试类也必须在主程序所在的包及其子包;这里的主程序是springbootApplication修饰的类，之所以</span><br><span class="line">测试类必须在主程序所在的包及其子包的原因是：SpringBoot的默认扫描规则，只扫描自己主程序所在的包以</span><br><span class="line">及子包，这样测试类的注解才能被扫描到。</span><br></pre></td></tr></table></figure>
<h3 id="4-2-0-组件测试"><strong>4.2.0 组件测试</strong></h3>
<p><strong>直接@Autowired容器中的组件进行测试</strong><br>
JUnit5的注解与JUnit4的注解有所变化<br>
<a target="_blank" rel="noopener" href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations"><strong>https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations</strong></a><br>
@DisplayName(“测试1”)//自定义测试名字<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1691632824115-17aa44c2-d941-4cf4-9275-e179fff05255.png#averageHue=%23c19757&amp;clientId=u6136e5eb-a4ad-4&amp;from=paste&amp;height=159&amp;id=u91faa989&amp;originHeight=199&amp;originWidth=746&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=52561&amp;status=done&amp;style=none&amp;taskId=ue972d580-cb68-4f6e-babc-29509d58909&amp;title=&amp;width=596.8" alt="image.png"></p>
<h3 id="4-2-1-注解"><strong>4.2.1 注解</strong></h3>
<ul>
<li>**@Test :**表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试</li>
<li>**@ParameterizedTest :**表示方法是参数化测试，下方会有详细介绍</li>
<li>**@RepeatedTest :**表示方法可重复执行，下方会有详细介绍</li>
<li>**@DisplayName :**为测试类或者测试方法设置展示名称</li>
<li>**@BeforeEach :**表示在每个单元测试之前执行</li>
<li>**@AfterEach :**表示在每个单元测试之后执行</li>
<li>**@BeforeAll :**表示在所有单元测试之前执行</li>
<li>**@AfterAll :**表示在所有单元测试之后执行</li>
<li>**@Tag :**表示单元测试类别，类似于JUnit4中的@Categories</li>
<li>**@Disabled :**表示测试类或测试方法不执行，类似于JUnit4中的@Ignore</li>
<li>**@Timeout :**表示测试方法运行如果超过了指定时间将会返回错误</li>
<li>**@ExtendWith :**为测试类或测试方法提供扩展类引用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import static org.junit.jupiter.api.Assertions.fail;</span><br><span class="line">import static org.junit.jupiter.api.Assumptions.assumeTrue;</span><br><span class="line"></span><br><span class="line">import org.junit.jupiter.api.AfterAll;</span><br><span class="line">import org.junit.jupiter.api.AfterEach;</span><br><span class="line">import org.junit.jupiter.api.BeforeAll;</span><br><span class="line">import org.junit.jupiter.api.BeforeEach;</span><br><span class="line">import org.junit.jupiter.api.Disabled;</span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line">class StandardTests &#123;</span><br><span class="line"></span><br><span class="line">    @BeforeAll</span><br><span class="line">    static void initAll() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @BeforeEach</span><br><span class="line">    void init() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DisplayName(&quot;😱&quot;)</span><br><span class="line">    @Test</span><br><span class="line">    void succeedingTest() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void failingTest() &#123;</span><br><span class="line">        fail(&quot;a failing test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    @Disabled(&quot;for demonstration purposes&quot;)</span><br><span class="line">    void skippedTest() &#123;</span><br><span class="line">        // not executed</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void abortedTest() &#123;</span><br><span class="line">        assumeTrue(&quot;abc&quot;.contains(&quot;Z&quot;));</span><br><span class="line">        fail(&quot;test should have been aborted&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterEach</span><br><span class="line">    void tearDown() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterAll</span><br><span class="line">    static void tearDownAll() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-2-断言"><strong>4.2.2 断言</strong></h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1691418910556-4050b5e8-46b0-4d5c-890a-2432fdb1491c.png#averageHue=%23fbfaf9&amp;clientId=u8fdb1034-8532-4&amp;from=paste&amp;height=526&amp;id=ue8811d01&amp;originHeight=658&amp;originWidth=938&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=51295&amp;status=done&amp;style=none&amp;taskId=u8fbc1a6a-e039-4e45-87a7-d19b86d95c6&amp;title=&amp;width=750.4" alt="image.png"></p>
<h3 id="4-2-3-嵌套测试"><strong>4.2.3 嵌套测试</strong></h3>
<p>JUnit 5 可以通过 Java 中的内部类和@Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用@BeforeEach 和@AfterEach 注解，而且嵌套的层次没有限制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">@DisplayName(&quot;A stack&quot;)</span><br><span class="line">class TestingAStackDemo &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Object&gt; stack;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    @DisplayName(&quot;is instantiated with new Stack()&quot;)</span><br><span class="line">    void isInstantiatedWithNew() &#123;</span><br><span class="line">        new Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nested</span><br><span class="line">    @DisplayName(&quot;when new&quot;)</span><br><span class="line">    class WhenNew &#123;</span><br><span class="line"></span><br><span class="line">        @BeforeEach</span><br><span class="line">        void createNewStack() &#123;</span><br><span class="line">            stack = new Stack&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Test</span><br><span class="line">        @DisplayName(&quot;is empty&quot;)</span><br><span class="line">        void isEmpty() &#123;</span><br><span class="line">            assertTrue(stack.isEmpty());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Test</span><br><span class="line">        @DisplayName(&quot;throws EmptyStackException when popped&quot;)</span><br><span class="line">        void throwsExceptionWhenPopped() &#123;</span><br><span class="line">            assertThrows(EmptyStackException.class, stack::pop);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Test</span><br><span class="line">        @DisplayName(&quot;throws EmptyStackException when peeked&quot;)</span><br><span class="line">        void throwsExceptionWhenPeeked() &#123;</span><br><span class="line">            assertThrows(EmptyStackException.class, stack::peek);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Nested</span><br><span class="line">        @DisplayName(&quot;after pushing an element&quot;)</span><br><span class="line">        class AfterPushing &#123;</span><br><span class="line"></span><br><span class="line">            String anElement = &quot;an element&quot;;</span><br><span class="line"></span><br><span class="line">            @BeforeEach</span><br><span class="line">            void pushAnElement() &#123;</span><br><span class="line">                stack.push(anElement);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Test</span><br><span class="line">            @DisplayName(&quot;it is no longer empty&quot;)</span><br><span class="line">            void isNotEmpty() &#123;</span><br><span class="line">                assertFalse(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Test</span><br><span class="line">            @DisplayName(&quot;returns the element when popped and is empty&quot;)</span><br><span class="line">            void returnElementWhenPopped() &#123;</span><br><span class="line">                assertEquals(anElement, stack.pop());</span><br><span class="line">                assertTrue(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Test</span><br><span class="line">            @DisplayName(&quot;returns the element when peeked but remains not empty&quot;)</span><br><span class="line">            void returnElementWhenPeeked() &#123;</span><br><span class="line">                assertEquals(anElement, stack.peek());</span><br><span class="line">                assertFalse(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-4-参数化测试"><strong>4.2.4 参数化测试</strong></h3>
<p>参数化测试是JUnit5很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。<br>
**</p>
<p>利用**@ValueSource**等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。<br>
<strong>@ValueSource</strong>: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型<br>
<strong>@NullSource</strong>: 表示为参数化测试提供一个null的入参<br>
<strong>@EnumSource</strong>: 表示为参数化测试提供一个枚举入参<br>
<strong>@CsvFileSource</strong>：表示读取指定CSV文件内容作为参数化测试入参<br>
<strong>@MethodSource</strong>：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@ParameterizedTest</span><br><span class="line">@ValueSource(strings = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;)</span><br><span class="line">@DisplayName(&quot;参数化测试1&quot;)</span><br><span class="line">public void parameterizedTest1(String string) &#123;</span><br><span class="line">    System.out.println(string);</span><br><span class="line">    Assertions.assertTrue(StringUtils.isNotBlank(string));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@ParameterizedTest</span><br><span class="line">@MethodSource(&quot;method&quot;)    //指定方法名</span><br><span class="line">@DisplayName(&quot;方法来源参数&quot;)</span><br><span class="line">public void testWithExplicitLocalMethodSource(String name) &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    Assertions.assertNotNull(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static Stream&lt;String&gt; method() &#123;</span><br><span class="line">    return Stream.of(&quot;apple&quot;, &quot;banana&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><strong>5、SpringBoot3-核心原理</strong></h1>
<h2 id="1-事件和监听器">1. 事件和监听器</h2>
<p><strong>1. 生命周期监听场景：监听应用的</strong>生命周期<br>
<strong>1. 监听器-SpringApplicationRunListener</strong><br>
自定义SpringApplicationRunListener来监听事件；编写SpringApplicationRunListener实现类在 META-INF/spring.factories 中配置 org.springframework.boot.SpringApplicationRunListener=自己的Listener，还可以指定一个有参构造器，接受两个参数(SpringApplication application, String[] args)springboot 在spring-boot.jar中配置了默认的 Listener，如下<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681829576654-d5e4b889-6fcf-4e65-91f1-8de8c78e98f1.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_23%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f3c9ac&amp;from=url&amp;id=kfTpf&amp;originHeight=61&amp;originWidth=792&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="">**</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Listener先要从 META-INF/spring.factories 读到</span><br><span class="line"> *</span><br><span class="line"> * 1、引导： 利用 BootstrapContext 引导整个项目启动</span><br><span class="line"> *      starting：              应用开始，SpringApplication的run方法一调用，只要有了 BootstrapContext 就执行</span><br><span class="line"> *      environmentPrepared：   环境准备好（把启动参数等绑定到环境变量中），但是ioc还没有创建；【调一次】</span><br><span class="line"> * 2、启动：</span><br><span class="line"> *      contextPrepared：       ioc容器创建并准备好，但是sources（主配置类）没加载。并关闭引导上下文；组件都没创建  【调一次】</span><br><span class="line"> *      contextLoaded：         ioc容器加载。主配置类加载进去了。但是ioc容器还没刷新（我们的bean没创建）。</span><br><span class="line"> *      =======截止以前，ioc容器里面还没造bean呢=======</span><br><span class="line"> *      started：               ioc容器刷新了（所有bean造好了），但是 runner 没调用。</span><br><span class="line"> *      ready:                  ioc容器刷新了（所有bean造好了），所有 runner 调用完了。</span><br><span class="line"> * 3、运行</span><br><span class="line"> *     以前步骤都正确执行，代表容器running。</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h3 id="2-生命周期全流程">2. 生命周期全流程</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1682322663331-25a89875-7ce3-40ae-9be7-9ea752fbab20.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_31%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23a7bd8b&amp;from=url&amp;id=Uwox4&amp;originHeight=758&amp;originWidth=1102&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在Spring Boot中，Runner是一个接口，用于在Spring应用程序启动完成后执行一些特定的任务。</span><br><span class="line">它是Spring Boot提供的一种扩展机制，允许开发人员在应用程序启动后立即执行一些代码逻辑。</span><br><span class="line">开发人员可以通过实现Runner接口并注入到Spring应用程序中，从而在应用程序启动后执行自定义的任务。</span><br><span class="line">runner是springboot底层用来感知生命周期特定阶段的一个回调。</span><br><span class="line">不同于SpringApplicationRunListener,这个是用来感知全生命周期的</span><br></pre></td></tr></table></figure>
<h2 id="2-事件触发时机">2. 事件触发时机</h2>
<h3 id="1-各种回调监听器">1. 各种回调监听器</h3>
<ul>
<li>BootstrapRegistryInitializer： ** 感知特定阶段：<strong>感知</strong>引导初始化**
<ul>
<li>META-INF/spring.factories</li>
<li>创建引导上下文bootstrapContext的时候触发。</li>
<li>application.addBootstrapRegistryInitializer();</li>
<li>场景：进行密钥校对授权。</li>
</ul>
</li>
<li>ApplicationContextInitializer： ** 感知特定阶段：** 感知ioc容器初始化
<ul>
<li>META-INF/spring.factories</li>
<li>application.addInitializers();</li>
</ul>
</li>
<li><strong>ApplicationListener： 感知全阶段：基于事件机制，感知事件。 一旦到了哪个阶段可以做别的事</strong>
<ul>
<li>@Bean或@EventListener： 事件驱动</li>
<li>SpringApplication.addListeners(…)或 SpringApplicationBuilder.listeners(…)</li>
<li>META-INF/spring.factories</li>
</ul>
</li>
<li><strong>SpringApplicationRunListener： 感知全阶段生命周期 + 各种阶段都能自定义操作； 功能更完善。</strong>
<ul>
<li>META-INF/spring.factories</li>
</ul>
</li>
<li><strong>ApplicationRunner: 感知特定阶段：感知应用就绪Ready。卡死应用，就不会就绪</strong>
<ul>
<li>@Bean</li>
</ul>
</li>
<li><strong>CommandLineRunner： 感知特定阶段：感知应用就绪Ready。卡死应用，就不会就绪</strong>
<ul>
<li>@Bean</li>
</ul>
</li>
</ul>
<p>最佳实战：</p>
<ul>
<li>如果项目启动前做事： BootstrapRegistryInitializer 和 ApplicationContextInitializer</li>
<li>如果想要在项目启动完成后做事：<strong>ApplicationRunner和 CommandLineRunner</strong></li>
<li><strong>如果要干涉生命周期做事：SpringApplicationRunListener</strong></li>
<li><strong>如果想要用事件机制：ApplicationListener</strong></li>
<li><strong>上面的都是接口，可以通过实现接口，然后在</strong>META-INF/spring.factories配置文件中填充实现上述接口的类，就可以实现在生命周期的特定阶段完成某项任务！</li>
</ul>
<h3 id="2-完整触发流程"><strong>2. 完整触发流程</strong></h3>
<p><strong>9大事件</strong>触发顺序&amp;时机</p>
<ol>
<li>ApplicationStartingEvent：应用启动但未做任何事情, 除过注册listeners and initializers.</li>
<li>ApplicationEnvironmentPreparedEvent： Environment 准备好，但context 未创建.</li>
<li>ApplicationContextInitializedEvent: ApplicationContext 准备好，ApplicationContextInitializers 调用，但是任何bean未加载</li>
<li>ApplicationPreparedEvent： 容器刷新之前，bean定义信息加载</li>
<li>ApplicationStartedEvent： 容器刷新完成， runner未调用</li>
</ol>
<p>=========以下就开始插入了<strong>探针机制</strong>============</p>
<ol>
<li>AvailabilityChangeEvent： LivenessState.CORRECT应用存活； <strong>存活探针</strong></li>
<li>ApplicationReadyEvent: 任何runner被调用</li>
<li>AvailabilityChangeEvent：ReadinessState.ACCEPTING_TRAFFIC<strong>就绪探针</strong>，可以接请求</li>
<li>ApplicationFailedEvent：启动出错</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1691887909080-a687294a-131b-4da8-9822-18298ade2f39.png#averageHue=%23c4d581&amp;clientId=uac0c1727-261a-4&amp;from=paste&amp;height=610&amp;id=ue472925a&amp;originHeight=762&amp;originWidth=1129&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=133115&amp;status=done&amp;style=none&amp;taskId=ue11d8088-eb18-4a04-ae32-ed763f0e0a8&amp;title=&amp;width=903.2" alt="image.png"><strong>应用事件发送顺序如下：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1691887919553-7c5e83d8-0a5c-4cae-bfca-bd50272bbb36.png#averageHue=%23f5eee4&amp;clientId=uac0c1727-261a-4&amp;from=paste&amp;height=157&amp;id=ufc92ec7f&amp;originHeight=196&amp;originWidth=937&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=100464&amp;status=done&amp;style=none&amp;taskId=ua7f8bbd0-7822-4907-8c9a-bd01dc2227b&amp;title=&amp;width=749.6" alt="image.png"><br>
感知应用是否存活了：可能植物状态，虽然活着但是不能处理请求。<br>
应用是否</strong>就绪**了：能响应请求，说明确实活的比较好。</p>
<h3 id="3-SpringBoot-事件驱动开发">3. SpringBoot 事件驱动开发</h3>
<p><strong>应用启动过程生命周期事件感知（9大事件）</strong>、<strong>应用运行中事件感知（无数种）</strong>。</p>
<ul>
<li><strong>事件发布</strong>：ApplicationEventPublisherAware或注入：ApplicationEventMulticaster</li>
<li><strong>事件监听</strong>：组件 + @EventListener</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1682327167479-8f634931-f8ca-48fb-9566-c914f1795ff2.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_33%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f2eeec&amp;from=url&amp;id=b4csj&amp;originHeight=387&amp;originWidth=1153&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1682341921101-aa095a84-00cc-4815-b675-f4ed81cecf3b.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_22%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23fdfcfc&amp;from=url&amp;id=dk2IM&amp;originHeight=489&amp;originWidth=780&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>
<strong>事件发布者</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class EventPublisher implements ApplicationEventPublisherAware &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 底层发送事件用的组件，SpringBoot会通过ApplicationEventPublisherAware接口自动注入给我们</span><br><span class="line">     * 事件是广播出去的。所有监听这个事件的监听器都可以收到</span><br><span class="line">     */</span><br><span class="line">    ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 所有事件都可以发</span><br><span class="line">     * @param event</span><br><span class="line">     */</span><br><span class="line">    public void sendEvent(ApplicationEvent event) &#123;</span><br><span class="line">        //调用底层API发送事件</span><br><span class="line">        applicationEventPublisher.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 会被自动调用，把真正发事件的底层组组件给我们注入进来</span><br><span class="line">     * @param applicationEventPublisher event publisher to be used by this object</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) &#123;</span><br><span class="line">        this.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>事件订阅者</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class CouponService &#123;</span><br><span class="line"></span><br><span class="line">    @Order(1)</span><br><span class="line">    @EventListener</span><br><span class="line">    public void onEvent(LoginSuccessEvent loginSuccessEvent)&#123;</span><br><span class="line">        System.out.println(&quot;===== CouponService ====感知到事件&quot;+loginSuccessEvent);</span><br><span class="line">        UserEntity source = (UserEntity) loginSuccessEvent.getSource();</span><br><span class="line">        sendCoupon(source.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sendCoupon(String username)&#123;</span><br><span class="line">        System.out.println(username + &quot; 随机得到了一张优惠券&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>**2. **自动配置原理</h1>
<h2 id="1-入门理解"><strong>1. 入门理解</strong></h2>
<p><strong>应用关注的三大核心：场景、配置、组件</strong></p>
<h3 id="1-自动配置流程"><strong>1. 自动配置流程</strong></h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681829645812-0f0cad01-66d4-42fc-8111-091e33a062c6.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_32%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23cfe1c6&amp;from=url&amp;id=B0IdI&amp;originHeight=602&amp;originWidth=1113&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="">**</p>
<ol>
<li><strong>导入starter</strong></li>
<li><strong>依赖导入autoconfigure</strong></li>
<li><strong>寻找类路径下 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件</strong></li>
<li><strong>启动，加载所有 自动配置类xxxAutoConfiguration</strong>
<ol>
<li><strong>给容器中配置功能组件</strong></li>
<li><strong>组件参数绑定到 属性类中。xxxProperties</strong></li>
<li><strong>属性类和配置文件前缀项绑定</strong></li>
<li><strong>@Contional派生的条件注解进行判断是否组件生效</strong></li>
</ol>
</li>
<li><strong>效果：</strong>
<ol>
<li><strong>修改配置文件，修改底层参数</strong></li>
<li><strong>所有场景自动配置好直接使用</strong></li>
<li><strong>可以注入SpringBoot配置好的组件随时使用</strong></li>
</ol>
</li>
</ol>
<h3 id="2-SPI机制">2. SPI机制</h3>
<ul>
<li><strong>Java中的SPI（Service Provider Interface）是一种软件设计模式，用于在应用程序中动态地发现和加载组件。SPI的思想</strong>是，定义一个接口或抽象类，然后通过在classpath中定义实现该接口的类来实现对组件的动态发现和加载。</li>
<li>SPI的主要目的是解决在应用程序中使用可插拔组件的问题。例如，一个应用程序可能需要使用不同的日志框架或数据库连接池，但是这些组件的选择可能取决于运行时的条件。通过使用SPI，应用程序可以在运行时发现并加载适当的组件，而无需在代码中硬编码这些组件的实现类。</li>
<li>在Java中，<strong>SPI</strong>的实现方式是通过在META-INF/services目录下创建一个以服务接口全限定名为名字的文件，文件中包含实现该服务接口的类的全限定名。当应用程序启动时，Java的SPI机制会自动扫描classpath中的这些文件，并根据文件中指定的类名来加载实现类。</li>
<li>通过使用SPI，应用程序可以实现更灵活、可扩展的架构，同时也可以避免硬编码依赖关系和增加代码的可维护性。</li>
</ul>
<p>以上回答来自ChatGPT-3.5<br>
在SpringBoot中，META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports<br>
作业：写一段java的spi机制代码</p>
<h3 id="3-功能开关">3. 功能开关</h3>
<ul>
<li>自动配置：全部都配置好，什么都不用管。 自动批量导入
<ul>
<li>项目一启动，spi文件中指定的所有都加载。</li>
</ul>
</li>
<li>@EnableXxxx：手动控制哪些功能的开启； 手动导入。
<ul>
<li>开启xxx功能</li>
</ul>
</li>
</ul>
<h2 id="2-进阶理解"><strong>2. 进阶理解</strong></h2>
<h3 id="1-SpringBootApplication"><strong>1. @SpringBootApplication</strong></h3>
<h4 id="SpringBootConfiguration"><strong>@SpringBootConfiguration</strong></h4>
<p><strong>就是： @Configuration ，容器中的组件，配置类。spring ioc启动就会加载创建这个类对象</strong></p>
<h4 id="EnableAutoConfiguration：开启自动配置"><strong>@EnableAutoConfiguration：开启自动配置</strong></h4>
<p><strong>开启自动配置</strong></p>
<h5 id="AutoConfigurationPackage：扫描主程序包：加载自己的组件"><strong>@AutoConfigurationPackage：扫描主程序包：加载自己的组件</strong></h5>
<ul>
<li><strong>利用 @Import(AutoConfigurationPackages.Registrar.class) 想要给容器中导入组件。</strong></li>
<li><strong>把主程序所在的包的所有组件导入进来。</strong></li>
<li><strong>为什么SpringBoot默认只扫描主程序所在的包及其子包</strong></li>
</ul>
<p>**</p>
<h5 id="Import-AutoConfigurationImportSelector-class-：加载所有自动配置类：加载starter导入的组件"><strong>@Import(AutoConfigurationImportSelector.class)：加载所有自动配置类：加载starter导入的组件</strong></h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; configurations = ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader())</span><br><span class="line">	.getCandidates();</span><br></pre></td></tr></table></figure>
<p>**扫描SPI文件：META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</p>
<p>**</p>
<h4 id="ComponentScan"><strong>@ComponentScan</strong></h4>
<p><strong>组件扫描：排除一些组件（哪些不要）</strong><br>
<strong>排除前面已经扫描进来的配置类、和自动配置类。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="2-完整启动加载流程">2. 完整启动加载流程</h3>
<p>生命周期启动加载流程<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/svg/1613913/1682569555020-b6cbc750-3171-44c6-810f-1c59e590b792.svg#from=url&amp;id=kMVFr&amp;originHeight=794&amp;originWidth=1453&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h1><strong>3. 自定义starter</strong></h1>
<p><strong>场景：抽取聊天机器人场景，它可以打招呼。</strong><br>
<strong>效果：任何项目导入此starter都具有打招呼功能，并且问候语中的人名需要可以在配置文件中修改</strong></p>
<ul>
<li>
<ol>
<li>创建自定义starter项目，引入spring-boot-starter基础依赖</li>
</ol>
</li>
<li>
<ol start="2">
<li>编写模块功能，引入模块所有需要的依赖。</li>
</ol>
</li>
<li>
<ol start="3">
<li>编写xxxAutoConfiguration自动配置类，帮其他项目导入这个模块需要的所有组件</li>
</ol>
</li>
<li>
<ol start="4">
<li>编写配置文件META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports指定启动需要加载的自动配置</li>
</ol>
</li>
</ul>
<h2 id="1-业务代码"><strong>1. 业务代码</strong></h2>
<p>自定义配置有提示。导入以下依赖重启项目，再写配置文件就有提示**</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;robot&quot;)  //此属性类和配置文件指定前缀绑定</span><br><span class="line">@Component</span><br><span class="line">@Data</span><br><span class="line">public class RobotProperties &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String age;</span><br><span class="line">    private String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        导入配置处理器，配置文件自定义的properties配置都会有提示--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-基本抽取">2. 基本抽取</h2>
<ul>
<li>创建starter项目，把公共代码需要的所有依赖导入</li>
<li>把公共代码复制进来</li>
<li>自己写一个 RobotAutoConfiguration，给容器中导入这个场景需要的所有组件
<ul>
<li>为什么这些组件默认不会扫描进去？</li>
<li><strong>starter所在的包和 引入它的项目的主程序所在的包不是父子层级</strong></li>
</ul>
</li>
<li>别人引用这个starter，直接导入这个 RobotAutoConfiguration,就能把这个场景的组件导入进来</li>
<li>功能生效。</li>
<li>测试编写配置文件</li>
</ul>
<h2 id="3-使用-EnableXxx机制"><strong>3. 使用@EnableXxx机制</strong></h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Documented</span><br><span class="line">@Import(RobotAutoConfiguration.class)</span><br><span class="line">public @interface EnableRobot &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>****别人引入starter需要使用 @EnableRobot开启功能 **</p>
<h2 id="4-完全自动配置">4. 完全自动配置</h2>
<ul>
<li>依赖SpringBoot的SPI机制</li>
<li>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 文件中编写好我们自动配置类的全类名即可</li>
<li>项目启动，自动加载我们的自动配置类</li>
</ul>
<h1>SpringBoot3-场景整合</h1>
<h2 id="0-云服务器">0. 云服务器</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://promotion.aliyun.com/ntms/act/ambassador/sharetouser.html?userCode=50sid5bu&amp;utm_source=50sid5bu"><strong>阿里云</strong></a><strong>、</strong><a target="_blank" rel="noopener" href="https://curl.qcloud.com/iyFTRSJb"><strong>腾讯云</strong></a><strong>、</strong><a target="_blank" rel="noopener" href="https://activity.huaweicloud.com/discount_area_v5/index.html?fromacct=d1a6f32e-d6d0-4702-9213-eafe022a0708&amp;utm_source=bGVpZmVuZ3lhbmc==&amp;utm_medium=cps&amp;utm_campaign=201905"><strong>华为云</strong></a>** 服务器开通； 按量付费，省钱省心**</li>
<li><strong>安装以下组件</strong></li>
<li>[ ] <strong>docker</strong></li>
<li>[ ] <strong>redis</strong></li>
<li>[ ] <strong>kafka</strong></li>
<li>[ ] <strong>prometheus</strong></li>
<li>[ ] <strong>grafana</strong></li>
<li><a target="_blank" rel="noopener" href="https://github.com/kingToolbox/WindTerm/releases/download/2.5.0/WindTerm_2.5.0_Windows_Portable_x86_64.zip"><strong>https://github.com/kingToolbox/WindTerm/releases/download/2.5.0/WindTerm_2.5.0_Windows_Portable_x86_64.zip</strong></a>** 下载windterm**</li>
</ul>
<p><strong>重要：开通云服务器以后，请一定在安全组设置规则，放行端口</strong></p>
<h2 id="1-Docker安装">1. Docker安装</h2>
<p>还不会docker的同学，参考【云原生实战（10~25集）】快速入门<br>
<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13Q4y1C7hS?p=10">https://www.bilibili.com/video/BV13Q4y1C7hS?p=10</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class="line"></span><br><span class="line">sudo systemctl enable docker --now</span><br><span class="line"></span><br><span class="line">#测试工作</span><br><span class="line">docker ps</span><br><span class="line">#  批量安装所有软件</span><br><span class="line">docker compose  </span><br></pre></td></tr></table></figure>
<p><strong>创建 /prod 文件夹，准备以下文件</strong></p>
<h2 id="2-prometheus-yml">2. prometheus.yml</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval: 15s</span><br><span class="line">  evaluation_interval: 15s</span><br><span class="line"></span><br><span class="line">scrape_configs:</span><br><span class="line">  - job_name: &#x27;prometheus&#x27;</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&#x27;localhost:9090&#x27;]</span><br><span class="line"></span><br><span class="line">  - job_name: &#x27;redis&#x27;</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&#x27;redis:6379&#x27;]</span><br><span class="line"></span><br><span class="line">  - job_name: &#x27;kafka&#x27;</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&#x27;kafka:9092&#x27;]</span><br></pre></td></tr></table></figure>
<h2 id="3-docker-compose-yml">3. docker-compose.yml</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3.9&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:latest</span><br><span class="line">    container_name: redis</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379:6379&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line"></span><br><span class="line">  zookeeper:</span><br><span class="line">    image: bitnami/zookeeper:latest</span><br><span class="line">    container_name: zookeeper</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      ZOOKEEPER_CLIENT_PORT: 2181</span><br><span class="line">      ZOOKEEPER_TICK_TIME: 2000</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line"></span><br><span class="line">  kafka:</span><br><span class="line">    image: bitnami/kafka:3.4.0</span><br><span class="line">    container_name: kafka</span><br><span class="line">    restart: always</span><br><span class="line">    depends_on:</span><br><span class="line">      - zookeeper</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;9092:9092&quot;</span><br><span class="line">    environment:</span><br><span class="line">      ALLOW_PLAINTEXT_LISTENER: yes</span><br><span class="line">      KAFKA_CFG_ZOOKEEPER_CONNECT: zookeeper:2181</span><br><span class="line">      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line">  </span><br><span class="line">  kafka-ui:</span><br><span class="line">    image: provectuslabs/kafka-ui:latest</span><br><span class="line">    container_name:  kafka-ui</span><br><span class="line">    restart: always</span><br><span class="line">    depends_on:</span><br><span class="line">      - kafka</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    environment:</span><br><span class="line">      KAFKA_CLUSTERS_0_NAME: dev</span><br><span class="line">      KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS: kafka:9092</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line"></span><br><span class="line">  prometheus:</span><br><span class="line">    image: prom/prometheus:latest</span><br><span class="line">    container_name: prometheus</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - ./prometheus.yml:/etc/prometheus/prometheus.yml</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;9090:9090&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line"></span><br><span class="line">  grafana:</span><br><span class="line">    image: grafana/grafana:latest</span><br><span class="line">    container_name: grafana</span><br><span class="line">    restart: always</span><br><span class="line">    depends_on:</span><br><span class="line">      - prometheus</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;3000:3000&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  backend:</span><br><span class="line">    name: backend</span><br></pre></td></tr></table></figure>
<h2 id="4-启动环境">4. 启动环境</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose -f docker-compose.yml up -d</span><br></pre></td></tr></table></figure>
<h2 id="5-验证">5. 验证:</h2>
<p>如果通过浏览器验证没有通过的话，原因可能是没有配置安全组：例如<strong>Kafka-ui通过浏览器无法访问！</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1692062258198-3076f00d-7f1c-4d16-b118-d5602186ac58.png#averageHue=%23fcfcfc&amp;clientId=uac0c1727-261a-4&amp;from=paste&amp;height=75&amp;id=ucb808ef1&amp;originHeight=94&amp;originWidth=1264&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=7142&amp;status=done&amp;style=none&amp;taskId=u66261308-30e0-4c55-9da2-3ed8eed8757&amp;title=&amp;width=1011.2" alt="image.png">添加安全组8080，这里的来源是：可以设置为 0.0.0.0/0，表示允许来自任何 IP 地址的流量，或者您可以指定特定的 IP 地址范围或单个 IP 地址。</p>
<ul>
<li><strong>Redis：你的ip:6379</strong>
<ul>
<li><strong>填写表单，下载官方可视化工具：</strong></li>
<li><a target="_blank" rel="noopener" href="https://redis.com/redis-enterprise/redis-insight/#insight-form"><strong>https://redis.com/redis-enterprise/redis-insight/#insight-form</strong></a></li>
</ul>
</li>
<li><strong>Kafka：你的ip:9092</strong>
<ul>
<li><strong>idea安装大数据插件</strong></li>
</ul>
</li>
<li><strong>Prometheus：你的ip:9090</strong>
<ul>
<li><strong>直接浏览器访问</strong></li>
</ul>
</li>
<li><strong>Grafana：你的ip:3000</strong>
<ul>
<li><strong>直接浏览器访问</strong></li>
</ul>
</li>
</ul>
<h2 id="Docker-10-25">Docker:(10-25)</h2>
<h3 id="Docker基本概念">Docker基本概念</h3>
<h4 id="1、解决的问题">1、解决的问题:</h4>
<p><strong>1、统一标准</strong><br>
应用构建<br>
Java、C++、JavaScript<br>
打成软件包<br>
.exe<br>
docker build … 镜像<br>
<strong>应用分享:</strong><br>
所有软件的镜像放到一个指定地方 docker hub<br>
安卓，应用市场应用运行统一标准的镜像docker run<br>
…<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1692069227456-eaaf5b70-3097-4576-b385-7518d3348588.png#averageHue=%23f0f1ed&amp;clientId=uac0c1727-261a-4&amp;from=paste&amp;height=274&amp;id=u3bdf5779&amp;originHeight=343&amp;originWidth=651&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=89111&amp;status=done&amp;style=none&amp;taskId=u3784a1e0-8b8e-4304-81c3-2a5c657fe94&amp;title=&amp;width=520.8" alt="image.png"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1692069318112-64c8ca5e-79f7-41e5-9c62-bf61b0757143.png#averageHue=%23efefe8&amp;clientId=uac0c1727-261a-4&amp;from=paste&amp;height=285&amp;id=uff9e6b90&amp;originHeight=356&amp;originWidth=671&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=83511&amp;status=done&amp;style=none&amp;taskId=ue0c0164f-30fd-418f-ad07-ab8dfe21483&amp;title=&amp;width=536.8" alt="image.png"></p>
<h4 id="2、资源隔离">2、资源隔离</h4>
<ul>
<li>cpu、memory资源隔离与限制</li>
<li>访问设备隔离与限制</li>
<li>网络隔离与限制</li>
<li>用户、用户组隔离限制</li>
<li>…</li>
</ul>
<h3 id="2、架构">2、架构</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/svg/28066124/1692064439987-d4ad84f3-0582-4676-9c49-39734e7ef6f4.svg#clientId=uac0c1727-261a-4&amp;from=paste&amp;height=422&amp;id=uc0bf46e6&amp;originHeight=527&amp;originWidth=1009&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=187350&amp;status=done&amp;style=none&amp;taskId=u62a00463-37f0-4bac-9d79-bc88a76f6e2&amp;title=&amp;width=807.2" alt="architecture.svg"></p>
<ul>
<li>Docker_Host：
<ul>
<li>安装Docker的主机</li>
</ul>
</li>
<li>Docker Daemon：
<ul>
<li>运行在Docker主机上的Docker后台进程</li>
</ul>
</li>
<li>Client：
<ul>
<li>操作Docker主机的客户端（命令行、UI等）</li>
</ul>
</li>
<li>Registry：
<ul>
<li>镜像仓库</li>
<li>Docker Hub</li>
</ul>
</li>
<li>Images：
<ul>
<li>镜像，带环境打包好的程序，可以直接启动运行</li>
</ul>
</li>
<li>Containers：
<ul>
<li>容器，由镜像启动起来正在运行中的程序</li>
</ul>
</li>
</ul>
<p>交互逻辑<br>
装好<strong>Docker</strong>，然后去 <strong>软件市场(doucker hub)</strong> 寻找<strong>镜像</strong>，下载并运行，查看<strong>容器</strong>状态日志等排错</p>
<h3 id="3、安装">3、安装</h3>
<h4 id="1、centos下安装docker">1、centos下安装docker</h4>
<p>其他系统参照如下文档<br>
<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p>
<h4 id="1、移除以前docker相关包">1、移除以前docker相关包</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>
<h4 id="2、配置yum源并且添加镜像仓库：">2、配置yum源并且添加镜像仓库：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3、安装docker">3、安装docker</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#以下是在安装k8s的时候使用</span><br><span class="line">yum install -y docker-ce-20.10.7 docker-ce-cli-20.10.7  containerd.io-1.4.6</span><br></pre></td></tr></table></figure>
<h4 id="4、启动">4、启动</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker --now</span><br></pre></td></tr></table></figure>
<h4 id="5、配置加速">5、配置加速</h4>
<p>这里额外添加了docker的生产环境核心配置cgroup：<br>
其中仓库加速镜像可以去阿里云的：容器镜像服务-&gt;	镜像加速器中选择加速地址替换下面的加速地址也就是registry-mirrors；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://82m9ar63.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;max-size&quot;: &quot;100m&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;storage-driver&quot;: &quot;overlay2&quot;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h4 id="6-镜像和容器的区别">6.镜像和容器的区别</h4>
<h3 id="Docker命令实战">Docker命令实战</h3>
<h4 id="常用命令">常用命令</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1692071527786-0d52ba68-3e36-4c18-b8eb-96a6ab5a7d03.png#averageHue=%23e3e2e1&amp;clientId=uac0c1727-261a-4&amp;from=paste&amp;height=478&amp;id=u8ac5de6b&amp;originHeight=597&amp;originWidth=1066&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=235950&amp;status=done&amp;style=none&amp;taskId=u6a7c6476-c964-4a45-bda6-bab61e7b3ce&amp;title=&amp;width=852.8" alt="image.png"></p>
<h4 id="基础实战">基础实战</h4>
<h5 id="1、找镜像">1、找镜像</h5>
<p>去<a target="_blank" rel="noopener" href="http://hub.docker.com">docker hub</a>，找到nginx镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx  #下载最新版</span><br><span class="line"></span><br><span class="line">镜像名:版本名（标签）</span><br><span class="line"></span><br><span class="line">docker pull nginx:1.20.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker pull redis  #下载最新</span><br><span class="line">docker pull redis:6.2.4</span><br><span class="line"></span><br><span class="line">## 下载来的镜像都在本地</span><br><span class="line">docker images  #查看所有镜像</span><br><span class="line">##删除镜像</span><br><span class="line">docker rmi redis</span><br><span class="line">##删除中的redis为</span><br><span class="line">redis = redis:latest</span><br><span class="line">docker rmi 镜像名:版本号/镜像id</span><br><span class="line">##每个镜像都有一个id,可以根据id删除镜像</span><br><span class="line">##如果要删除的镜像真正使用，</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Nginx（发音为 “engine-x”）是一个用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议的开源反向代理服务器，以及负载均衡器、HTTP 缓存和 Web 服务器（原始服务器）。 nginx 项目一开始就非常注重高并发、高性能和低内存占用。它是根据 2 条款 BSD 类许可证获得许可的，并且可以在 Linux、BSD 变体、Mac OS X、Solaris、AIX、HP-UX 以及其他 *nix 版本上运行。它还具有适用于 Microsoft Windows 的概念验证端口。</p>
<h5 id="docker删除：">docker删除：</h5>
<p>docker rm 和docker rmi的区别</p>
<ul>
<li>docker rm 用于删除容器，而 docker rmi 用于删除镜像。</li>
<li>docker rm 可以删除正在运行的容器，而 docker rmi 只能删除未被使用的镜像。</li>
<li>删除容器可以使用容器 ID 或容器名称，而删除镜像可以使用镜像 ID 或镜像标签。</li>
</ul>
<p>如何批量删除运行中的容器<br>
docker rm -f $(docker ps -q)这里的docker ps -q是列出正在运行的容器，$()是将括号里面执行结果当做参数传递给docker rm 命令。<br>
要删除多个镜像，可以将它们列在一个命令中<br>
docker rmi image1:tag image2:tag image3:tag<br>
要删除多个容器，你可以使用以下命令：<br>
docker rm container1 container2 container3 …</p>
<h5 id="2、启动容器">2、启动容器</h5>
<p>启动nginx应用容器，并映射88端口，测试的访问</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">【docker run  设置项   镜像名  】 镜像启动运行的命令（镜像里面默认有的</span><br><span class="line">，一般不会写）</span><br><span class="line"></span><br><span class="line"># -d：后台运行</span><br><span class="line"># --restart=always: 开机自启</span><br><span class="line">docker run --name=mynginx   -d  --restart=always -p  88:80  nginx</span><br><span class="line">##--name：给启动的镜像生成的容器起一个名字（启动后通过docker ps可以查看启动的容器</span><br><span class="line">其中有个names属性，这里的--name就是设置names属性的，</span><br><span class="line">##-d:是后台启动也就是不在当前的终端启动，而是在后台启动。如果不选择这个</span><br><span class="line">就会在当前的终端启动，且占据着当前的终端，无法在当前的终端使用其他命令。</span><br><span class="line">##88：80就是端口映射，其中的88是主机的端口，80是容器的端口。</span><br><span class="line"># 查看正在运行的容器</span><br><span class="line">docker ps</span><br><span class="line"># 查看所有，包括停止运行的容器</span><br><span class="line">docker ps -a</span><br><span class="line"># 删除停止的容器（要指定容器的id/名字）</span><br><span class="line">docker rm  容器id/名字</span><br><span class="line">docker rm -f mynginx   #强制删除正在运行中的</span><br><span class="line"></span><br><span class="line">#停止容器</span><br><span class="line">docker stop 容器id/名字</span><br><span class="line">#再次启动</span><br><span class="line">docker start 容器id/名字</span><br><span class="line"></span><br><span class="line">#应用开机自启</span><br><span class="line">docker update 容器id/名字 --restart=always</span><br></pre></td></tr></table></figure>
<h5 id="端口映射：">端口映射：</h5>
<h5 id="image-png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693661640773-7d47d1c1-5dc0-43aa-844b-46ebc764ac6e.png#averageHue=%236faab3&amp;clientId=u199a9dfb-f232-4&amp;from=paste&amp;height=270&amp;id=u0a4fc328&amp;originHeight=337&amp;originWidth=609&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=37379&amp;status=done&amp;style=none&amp;taskId=u205d8096-4b14-4c4a-8abc-bbf708f17d8&amp;title=&amp;width=487.2" alt="image.png"></h5>
<p>每个容器相当于一个小的Linux,每个容器都可以设置自己的端口，但是主机也有个端口88.端口映射就是后面我们通过公网ip访问88端口的时候实际上是访问nginx容器的80端口。其中容器启动的时候设置了端口映射可以通过docker ps命名查看到的<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693661968373-5247f323-5162-4d5b-88d6-e5a4021ff1d5.png#averageHue=%23202969&amp;clientId=u199a9dfb-f232-4&amp;from=paste&amp;height=65&amp;id=u215928cb&amp;originHeight=81&amp;originWidth=1155&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=105387&amp;status=done&amp;style=none&amp;taskId=ubeac012b-f2a1-4f31-addf-172b56a0f42&amp;title=&amp;width=924" alt="image.png"><br>
这里就可以通过公网ip，端口88(注意不要添加http)访问80的nginx.<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693662068364-ed63640f-d323-413e-b3ca-8822b1ab1c30.png#averageHue=%23f6f5f4&amp;clientId=u199a9dfb-f232-4&amp;from=paste&amp;height=286&amp;id=uad59c2ba&amp;originHeight=358&amp;originWidth=806&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=38541&amp;status=done&amp;style=none&amp;taskId=u6fedb865-c35a-4f6e-bafa-ebce95595a8&amp;title=&amp;width=644.8" alt="image.png"></p>
<h5 id="3、修改容器内容（可以去dockpub官网查看相关容器的用法）">3、修改容器内容（可以去dockpub官网查看相关容器的用法）</h5>
<p>修改默认的index.html 页面</p>
<h6 id="1、进容器内部修改">1、进容器内部修改</h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 进入容器内部的系统，修改容器内容</span><br><span class="line">docker exec -it 容器id  /bin/bash</span><br><span class="line">##容器相当于一个小的linux这里是进入小linux中的shell当然这里也可以选择</span><br><span class="line">/bin/sh，</span><br></pre></td></tr></table></figure>
<h6 id="image-png-2"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693662555584-0f50aa80-013f-4ef2-b825-2cc4e08f0746.png#averageHue=%231f2869&amp;clientId=u199a9dfb-f232-4&amp;from=paste&amp;height=54&amp;id=u3c41def4&amp;originHeight=68&amp;originWidth=1285&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=95065&amp;status=done&amp;style=none&amp;taskId=uf2b7db52-7049-40c2-8a43-6e9f0820f09&amp;title=&amp;width=1028" alt="image.png"></h6>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693664468867-2975cbcf-a97d-48d0-83a8-dfff635bd638.png#averageHue=%23223071&amp;clientId=u199a9dfb-f232-4&amp;from=paste&amp;height=233&amp;id=uc54b05ff&amp;originHeight=291&amp;originWidth=1427&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=497796&amp;status=done&amp;style=none&amp;taskId=uf5b39572-2572-4c63-b16e-7e914595699&amp;title=&amp;width=1141.6" alt="image.png"><br>
再次登录的结果：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693664502030-7539f9e6-9251-4553-9953-92cc83e59f6f.png#averageHue=%23e5e4e3&amp;clientId=u199a9dfb-f232-4&amp;from=paste&amp;height=72&amp;id=u98dda7c1&amp;originHeight=90&amp;originWidth=353&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=4561&amp;status=done&amp;style=none&amp;taskId=u58eca5aa-3888-4200-b270-af1659e196d&amp;title=&amp;width=282.4" alt="image.png"><br>
使用exit就退出容器。</p>
<h6 id="2、挂载数据到外部修改">2、挂载数据到外部修改</h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=mynginx   \</span><br><span class="line">-d  --restart=always \</span><br><span class="line">-p  88:80 -v /data/html:/usr/share/nginx/html:ro  \</span><br><span class="line">nginx</span><br><span class="line"></span><br><span class="line"># 修改页面只需要去 主机的 /data/html</span><br></pre></td></tr></table></figure>
<h6 id="4、提交改变">4、提交改变</h6>
<p>将自己修改好的镜像提交</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">docker commit -a &quot;leifengyang&quot;  -m &quot;首页变化&quot; 341d81f7504f guignginx:v1.0</span><br><span class="line">##这个命令有以下几个部分：</span><br><span class="line"></span><br><span class="line">-a &quot;leifengyang&quot;：指定作者信息为 &quot;leifengyang&quot;，表示创建镜像的作者。</span><br><span class="line">-m &quot;首页变化&quot;：指定提交消息为 &quot;首页变化&quot;，用于描述这个镜像的变化</span><br><span class="line">或修改。</span><br><span class="line">341d81f7504f：容器的 ID，表示要基于此容器创建新的镜像。</span><br><span class="line">guignginx:v1.0：新镜像的名称和标签，这里将创建一个名为 &quot;guignginx&quot;</span><br><span class="line">，标签为 &quot;v1.0&quot; 的镜像。</span><br><span class="line">执行该命令后，Docker 将根据容器的当前状态创建一个新的镜像，并将其命</span><br><span class="line">名为 &quot;guignginx:v1.0&quot;，包含了您在容器中所做的更改。</span><br></pre></td></tr></table></figure>
<p>提交改变后，如果后面删除了原来的镜像，想要运行新的镜像的时候，如果用<br>
docker run --name=mynginx   -d  --restart=always -p  88:80  nginx命令<br>
运行镜像时，运行的是默认镜像。这个时候可以运行刚刚提交的镜像<br>
docker run --name=mynginx   -d  --restart=always -p  88:80  guignginx:v1.0<br>
这样就可以运行和刚刚删除的容器一样的容器而不必重新在新的容器上修改。</p>
<h6 id="镜像保存：">镜像保存：</h6>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693666166503-76847856-5dbd-41c1-b985-d573593d50ee.png#averageHue=%2319191a&amp;clientId=u199a9dfb-f232-4&amp;from=paste&amp;height=198&amp;id=u4444ecb0&amp;originHeight=247&amp;originWidth=855&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=88985&amp;status=done&amp;style=none&amp;taskId=u432223cc-3ccb-4a43-bafa-c67f0b00a05&amp;title=&amp;width=684" alt="image.png"></p>
<h6 id="1、镜像传输">1、镜像传输</h6>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693666351488-fcc58253-ce49-485b-a0dd-b0f91e801603.png#averageHue=%231a1a1b&amp;clientId=u199a9dfb-f232-4&amp;from=paste&amp;height=387&amp;id=u19a7bd17&amp;originHeight=484&amp;originWidth=951&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=212480&amp;status=done&amp;style=none&amp;taskId=u8e036015-3d49-43b5-9c69-60df8df3dc8&amp;title=&amp;width=760.8" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 将镜像保存成压缩包</span><br><span class="line">docker save -o abc.tar guignginx:v1.0</span><br><span class="line"></span><br><span class="line"># 别的机器加载这个镜像</span><br><span class="line">docker load -i abc.tar</span><br><span class="line">#-i 表示输入文件（input file），指定要加载的镜像存储文件的路径。</span><br><span class="line">abc.tar 是一个镜像存储文件，通过该命令，Docker 将读取该文件并加载其</span><br><span class="line">中的镜像到本地 Docker 引擎中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 离线安装</span><br></pre></td></tr></table></figure>
<h6 id="5、推送远程仓库">5、推送远程仓库</h6>
<p>推送镜像到docker hub；应用市场（前提要注册，然后自己创建一个仓库）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag local-image:tagname new-repo:tagname</span><br><span class="line">docker push new-repo:tagname</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 把旧镜像的名字，改成仓库要求的新版名字</span><br><span class="line">docker tag guignginx:v1.0 leifengyang/guignginx:v1.0</span><br><span class="line">#</span><br><span class="line">通过执行该命令，Docker 将为镜像 guignginx:v1.0 创建一个新的标签</span><br><span class="line">leifengyang/guignginx:v1.0。这个操作不会创建新的镜像副本，</span><br><span class="line">只是为现有镜像添加了一个新的标签。这样，您可以通过两个不同的标签来</span><br><span class="line">引用同一个镜像。</span><br><span class="line"># 登录到docker hub，只需要登录一次，下次启动服务器的时(没有退出）不需要登录直接</span><br><span class="line">push</span><br><span class="line">docker login       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker logout（推送完成镜像后退出）</span><br><span class="line"></span><br><span class="line"># 推送</span><br><span class="line">docker push leifengyang/guignginx:v1.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 别的机器下载</span><br><span class="line"></span><br><span class="line">docker pull leifengyang/guignginx:v1.0</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693668015733-b27ce633-6a8d-4fbe-bb30-53fe273d574d.png#averageHue=%232c3d7e&amp;clientId=u199a9dfb-f232-4&amp;from=paste&amp;height=370&amp;id=u06e55159&amp;originHeight=462&amp;originWidth=1240&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=692661&amp;status=done&amp;style=none&amp;taskId=uf8fbd6a9-51b2-4511-9175-91e09c11c57&amp;title=&amp;width=992" alt="image.png"></p>
<h6 id="6、补充">6、补充</h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">docker logs 容器名/id   排错</span><br><span class="line"></span><br><span class="line">docker exec -it 容器id /bin/bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># docker 经常修改nginx配置文件</span><br><span class="line">docker run -d -p 80:80 \</span><br><span class="line">-v /data/html:/usr/share/nginx/html:ro \</span><br><span class="line">-v /data/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">--name mynginx-02 \</span><br><span class="line">nginx</span><br><span class="line">#-v /data/html:/usr/share/nginx/html:ro：将主机的 /data/html </span><br><span class="line">目录挂载到容器内的 /usr/share/nginx/html 目录，并设置为只读模式 (ro)。这样，容器内的 Nginx 将使用主机上的 HTML 文件。</span><br><span class="line">-v /data/conf/nginx.conf:/etc/nginx/nginx.conf：</span><br><span class="line">将主机的 /data/conf/nginx.conf 文件挂载到容器内的</span><br><span class="line">/etc/nginx/nginx.conf 文件，用于替换容器内的 Nginx 配置文件。</span><br><span class="line">--name mynginx-02：指定容器的名称为 mynginx-02。</span><br><span class="line">nginx：要运行的镜像名称。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#把容器指定位置的东西复制出来 </span><br><span class="line">docker cp 5eff66eec7e1:/etc/nginx/nginx.conf  /data/conf/nginx.conf</span><br><span class="line">#把外面的内容复制到容器里面</span><br><span class="line">docker cp  /data/conf/nginx.conf  5eff66eec7e1:/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>
<h3 id="进阶实战">进阶实战</h3>
<h4 id="1、编写自己的应用">1、编写自己的应用</h4>
<p>编写一个HelloWorld应用<br>
<a target="_blank" rel="noopener" href="https://start.spring.io/">https://start.spring.io/</a></p>
<p>示例代码： <a target="_blank" rel="noopener" href="https://gitee.com/leifengyang/java-demo.git">https://gitee.com/leifengyang/java-demo.git</a></p>
<h5 id="2、将应用打包成镜像">2、将应用打包成镜像</h5>
<p>编写Dockerfile将自己的应用打包镜像</p>
<h5 id="1、以前">1、以前</h5>
<p>Java为例</p>
<ul>
<li>SpringBoot打包成可执行jar</li>
<li>把jar包上传给服务</li>
<li>服务器运行java -jar</li>
</ul>
<h5 id="2、现在">2、现在</h5>
<p>所有机器都安装Docker，任何应用都是镜像，所有机器都可以运行</p>
<h5 id="3、怎么打包-Dockerfile">3、怎么打包-Dockerfile</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jdk-slim</span><br><span class="line">LABEL maintainer=leifengyang</span><br><span class="line"></span><br><span class="line">COPY target/*.jar   /app.jar</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t java-demo:v1.0 .</span><br></pre></td></tr></table></figure>
<p>思考：<br>
每个应用每次打包，都需要本地编译、再上传服务器、再进行docker构建，如果有1000个应用要打包镜像怎么办？有没有更好的方式？</p>
<h5 id="3、启动容器">3、启动容器</h5>
<p>启动应用容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:8080 --name myjava-app java-demo:v1.0 </span><br></pre></td></tr></table></figure>
<p>分享镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 登录docker hub</span><br><span class="line">docker login</span><br><span class="line"></span><br><span class="line">#给旧镜像起名</span><br><span class="line">docker tag java-demo:v1.0  leifengyang/java-demo:v1.0</span><br><span class="line"></span><br><span class="line"># 推送到docker hub</span><br><span class="line">docker push leifengyang/java-demo:v1.0</span><br><span class="line"></span><br><span class="line"># 别的机器</span><br><span class="line">docker pull leifengyang/java-demo:v1.0</span><br><span class="line"></span><br><span class="line"># 别的机器运行</span><br><span class="line">docker run -d -p 8080:8080 --name myjava-app java-demo:v1.0 </span><br></pre></td></tr></table></figure>
<h5 id="4、部署中间件">4、部署中间件</h5>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693720409476-cdc02b96-0977-43bb-8468-a5e95524479e.png#averageHue=%2382bec8&amp;clientId=ubd7ce99a-c7e7-4&amp;from=paste&amp;height=362&amp;id=XUcBO&amp;originHeight=452&amp;originWidth=909&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=112189&amp;status=done&amp;style=none&amp;taskId=u246d6b70-14f7-4ec4-86d9-7f461209255&amp;title=&amp;width=727.2" alt="image.png"><br>
部署一个Redis+应用，尝试应用操作Redis产生数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">#redis使用自定义配置文件启动</span><br><span class="line"></span><br><span class="line">docker run -v /data/redis/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-v /data/redis/data:/data \</span><br><span class="line">-d --name myredis \</span><br><span class="line">-p 6379:6379 \</span><br><span class="line">redis:latest  redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Redis配置密码：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693721336317-8222233b-4a16-424e-aa2f-c6ddb6ad2f6c.png#averageHue=%23151516&amp;clientId=ubd7ce99a-c7e7-4&amp;from=paste&amp;height=190&amp;id=u6e8c45ae&amp;originHeight=237&amp;originWidth=583&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=35158&amp;status=done&amp;style=none&amp;taskId=u26f9ab92-c709-4582-88b0-ec1e8978e04&amp;title=&amp;width=466.4" alt="image.png"><br>
连接Redis:<br>
测试使用redis:</p>
<h2 id="1、NoSQL">1、NoSQL</h2>
<h3 id="Redis整合">Redis整合</h3>
<p>**Redis不会的同学：参照 阳哥-《Redis7》 **<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13R4y1v7sP?p=1"><strong>https://www.bilibili.com/video/BV13R4y1v7sP?p=1</strong></a><br>
**HashMap： key：value</p>
<p>**</p>
<h2 id="1-场景整合"><strong>1. 场景整合</strong></h2>
<p><strong>依赖导入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.data.redis.host=192.168.200.100</span><br><span class="line">spring.data.redis.password=Lfy123!@!</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">void redisTest()&#123;</span><br><span class="line">    redisTemplate.opsForValue().set(&quot;a&quot;,&quot;1234&quot;);</span><br><span class="line">    Assertions.assertEquals(&quot;1234&quot;,redisTemplate.opsForValue().get(&quot;a&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-自动配置原理"><strong>2. 自动配置原理</strong></h2>
<ol>
<li>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports中导入了<code>RedisAutoConfiguration</code>、RedisReactiveAutoConfiguration和RedisRepositoriesAutoConfiguration。所有属性绑定在<code>RedisProperties</code>中</li>
<li>RedisReactiveAutoConfiguration属于响应式编程，不用管。RedisRepositoriesAutoConfiguration属于 JPA 操作，也不用管</li>
<li>RedisAutoConfiguration 配置了以下组件
<ol>
<li>LettuceConnectionConfiguration： 给容器中注入了连接工厂LettuceConnectionFactory，和操作 redis 的客户端DefaultClientResources。</li>
<li><code>RedisTemplate&lt;Object, Object&gt;</code>： 可给 redis 中存储任意对象，会使用 jdk 默认序列化方式。</li>
<li><code>StringRedisTemplate</code>： 给 redis 中存储字符串，如果要存对象，需要开发人员自己进行序列化。key-value都是字符串进行操作··,如果key和value中有一个是实体对象可以将对象转化为json数据（字符串）来进行操作、，</li>
</ol>
</li>
</ol>
<h2 id="3-定制化">3. 定制化</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppRedisConfiguration &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 允许Object类型的key-value，都可以被转为json进行存储。</span><br><span class="line">     * @param redisConnectionFactory 自动配置好了连接工厂</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        //把对象转为json字符串的序列化工具</span><br><span class="line">        template.setDefaultSerializer(new GenericJackson2JsonRedisSerializer());</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-redis客户端"><strong>2. redis客户端</strong></h3>
<blockquote>
<p><strong>RedisTemplate、StringRedisTemplate： 操作redis的工具类</strong></p>
<ul>
<li><strong>要从redis的连接工厂获取链接才能操作redis</strong></li>
<li><strong>Redis客户端</strong>
<ul>
<li><strong>Lettuce： 默认</strong></li>
<li><strong>Jedis：可以使用以下切换</strong></li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--        切换 jedis 作为操作redis的底层客户端--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3-配置参考"><strong>3. 配置参考</strong></h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring.data.redis.host=8.130.74.183</span><br><span class="line">spring.data.redis.port=6379</span><br><span class="line">#spring.data.redis.client-type=lettuce</span><br><span class="line"></span><br><span class="line">#设置lettuce的底层参数</span><br><span class="line">#spring.data.redis.lettuce.pool.enabled=true</span><br><span class="line">#spring.data.redis.lettuce.pool.max-active=8</span><br><span class="line"></span><br><span class="line">spring.data.redis.client-type=jedis</span><br><span class="line">spring.data.redis.jedis.pool.enabled=true</span><br><span class="line">spring.data.redis.jedis.pool.max-active=8</span><br></pre></td></tr></table></figure>
<h3 id="总结：">总结：</h3>
<p><strong>1.</strong></p>
<h2 id="消息服务：">消息服务：</h2>
<h2 id="1-docker安装kafka（没学完）">1.docker安装kafka（没学完）</h2>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/y393016244/article/details/126405864">Docker安装Kafka教程（超详细）_乾坤鸟的博客-CSDN博客</a><br>
docker network create app-tier --driver bridge</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用命令 docker network create app-tier --driver bridge 可以创建一个</span><br><span class="line">名为 &quot;app-tier&quot; 的 Docker 网络，并使用桥接（bridge）驱动程序。</span><br><span class="line"></span><br><span class="line">这个命令会创建一个桥接网络，桥接网络是 Docker 中默认的网络驱动程序。</span><br><span class="line">桥接网络用于连接运行在同一 Docker 主机上的多个容器，使它们能够使用容</span><br><span class="line">器名称作为主机名进行通信。</span><br><span class="line"></span><br><span class="line">通过创建 &quot;app-tier&quot; 网络，您可以启动容器并将它们连接到该网络，以便</span><br><span class="line">实现容器之间的通信。同一网络内的容器可以使用它们的容器名称作为主机名</span><br><span class="line">来相互访问。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name kafka-server \</span><br><span class="line">    --network app-tier \</span><br><span class="line">    -p 9092:9092 \</span><br><span class="line">    -e ALLOW_PLAINTEXT_LISTENER=yes \</span><br><span class="line">    -e KAFKA_CFG_ZOOKEEPER_CONNECT=zookeeper-server:2181 \</span><br><span class="line">    -e KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://8.130.50.249:9092\</span><br><span class="line">    bitnami/kafka:latest</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.安装kafkaUi<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42987796/article/details/129799473">【docker】docker安装带ui界面的kafka_docker ui 安装_努力的gopher的博客-CSDN博客</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;2&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  zookeeper:</span><br><span class="line">    image: docker.io/bitnami/zookeeper:3.8</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;22181:2181&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;zookeeper_data:/bitnami&quot;</span><br><span class="line">    environment:</span><br><span class="line">      - ALLOW_ANONYMOUS_LOGIN=yes</span><br><span class="line">  kafka:</span><br><span class="line">    container_name: kafka1</span><br><span class="line">    image: docker.io/bitnami/kafka:3.4</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;9192:9092&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;kafka_data:/bitnami&quot;</span><br><span class="line">    environment:</span><br><span class="line">      - KAFKA_CFG_ZOOKEEPER_CONNECT=zookeeper:2181</span><br><span class="line">      - ALLOW_PLAINTEXT_LISTENER=yes</span><br><span class="line">      - KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://8.130.50.249:9192</span><br><span class="line">      - KAFKA_CFG_AUTO_CREATE_TOPICS_ENABLE=true</span><br><span class="line">    depends_on:</span><br><span class="line">      - zookeeper</span><br><span class="line"></span><br><span class="line">  kafka-ui:</span><br><span class="line">    image: provectuslabs/kafka-ui:latest</span><br><span class="line">    container_name: kafka-ui</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">        - 10010:8080</span><br><span class="line">    volumes:</span><br><span class="line">        - /etc/localtime:/etc/localtime</span><br><span class="line">    environment:</span><br><span class="line">        - KAFKA_CLUSTERS_0_NAME=local</span><br><span class="line">        - KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=kafka1:9092</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  zookeeper_data:</span><br><span class="line">    driver: local</span><br><span class="line">  kafka_data:</span><br><span class="line">    driver: local</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://www.bojiboqi.fun">山麋一笑</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://www.bojiboqi.fun/2024/02/28/Springboot_/">http://www.bojiboqi.fun/2024/02/28/Springboot_/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.bojiboqi.fun" target="_blank">山麋一笑</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/springboot2/">springboot2</a></div><div class="post_share"><div class="social-share" data-image="https://www.dmoe.cc/random.php?2357" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/02/28/springboot2%E6%9D%82%E9%A1%B9%EF%BC%9A/" title="spring杂项"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.dmoe.cc/random.php?2502" onerror="onerror=null;src='/img/404.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">spring杂项</div></div></a></div><div class="next-post pull-right"><a href="/2024/02/28/SpirngBoot%E5%BC%80%E6%BA%90Demo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A/" title="SpirngBoot开源Demo源码分析："><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.dmoe.cc/random.php?4624" onerror="onerror=null;src='/img/404.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpirngBoot开源Demo源码分析：</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/02/28/SpirngBoot%E5%BC%80%E6%BA%90Demo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A/" title="SpirngBoot开源Demo源码分析："><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.dmoe.cc/random.php?4624" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-28</div><div class="title">SpirngBoot开源Demo源码分析：</div></div></a></div><div><a href="/2024/02/28/SpringBoot%E9%9B%86%E6%88%90%E8%BF%9E%E6%8E%A5%E6%B1%A0%EF%BC%9A/" title="SpringBoot集成连接池："><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.dmoe.cc/random.php?5358" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-28</div><div class="title">SpringBoot集成连接池：</div></div></a></div><div><a href="/2024/02/28/%E6%B1%9F%E5%8D%97%E4%B8%80%E7%82%B9%E9%9B%A8springboot%E6%95%B4%E7%90%86%EF%BC%9A/" title="springboot2江南一点雨博客总结"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.dmoe.cc/random.php?2042" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-28</div><div class="title">springboot2江南一点雨博客总结</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">1.创建第一个项目：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">1.引入依赖：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%BC%E5%85%A5%E5%9C%BA%E6%99%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text">2. 导入场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%BB%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">3. 主程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%9A%E5%8A%A1"><span class="toc-number">1.1.3.</span> <span class="toc-text">4. 业务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B5%8B%E8%AF%95"><span class="toc-number">1.1.4.</span> <span class="toc-text">5. 测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%89%93%E5%8C%85"><span class="toc-number">1.1.5.</span> <span class="toc-text">6. 打包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">3、应用分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%9C%BA%E5%88%B6"><span class="toc-number">2.1.</span> <span class="toc-text">2. 自动配置机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3"><span class="toc-number">2.1.1.</span> <span class="toc-text">1. 初步理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.2.</span> <span class="toc-text">1. 常用注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C"><span class="toc-number">2.2.1.</span> <span class="toc-text">1. 组件注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9D%A1%E4%BB%B6%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.2.2.</span> <span class="toc-text">2. 条件注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9A"><span class="toc-number">2.2.3.</span> <span class="toc-text">3. 属性绑定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%85%E5%A4%8D%E4%B9%A0%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%EF%BC%88%E8%A7%86%E9%A2%911-26%E9%9B%86%EF%BC%89%EF%BC%9A"><span class="toc-number">2.3.</span> <span class="toc-text">待复习常用注解（视频1-26集）：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%AE%B9%E5%99%A8%EF%BC%9A"><span class="toc-number">2.3.1.</span> <span class="toc-text">核心容器：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C%EF%BC%9A"><span class="toc-number">2.3.2.</span> <span class="toc-text">组件注册：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Congfiguration"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">@Congfiguration:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">2. 完整流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-YAML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">2.5.</span> <span class="toc-text">2. YAML配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">2.5.1.</span> <span class="toc-text">1. 基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.5.2.</span> <span class="toc-text">2. 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%86%E8%8A%82"><span class="toc-number">2.5.3.</span> <span class="toc-text">3. 细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%9Alombok"><span class="toc-number">2.5.4.</span> <span class="toc-text">4. 小技巧：lombok</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE"><span class="toc-number">2.6.</span> <span class="toc-text">3. 日志配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-number">2.6.1.</span> <span class="toc-text">1. 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.6.2.</span> <span class="toc-text">2. 日志格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97"><span class="toc-number">2.6.3.</span> <span class="toc-text">3. 记录日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB"><span class="toc-number">2.6.4.</span> <span class="toc-text">4. 日志级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%97%A5%E5%BF%97%E5%88%86%E7%BB%84"><span class="toc-number">2.6.5.</span> <span class="toc-text">5. 日志分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA"><span class="toc-number">2.6.6.</span> <span class="toc-text">6. 文件输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%96%87%E4%BB%B6%E5%BD%92%E6%A1%A3%E4%B8%8E%E6%BB%9A%E5%8A%A8%E5%88%87%E5%89%B2"><span class="toc-number">2.6.7.</span> <span class="toc-text">7. 文件归档与滚动切割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE"><span class="toc-number">2.6.8.</span> <span class="toc-text">8. 自定义配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%88%87%E6%8D%A2%E6%97%A5%E5%BF%97%E7%BB%84%E5%90%88"><span class="toc-number">2.6.9.</span> <span class="toc-text">9. 切换日志组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%9C%80%E4%BD%B3%E5%AE%9E%E6%88%98"><span class="toc-number">2.6.10.</span> <span class="toc-text">10. 最佳实战</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">2、SpringBoot3-Web开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Web%E5%9C%BA%E6%99%AF"><span class="toc-number">3.1.</span> <span class="toc-text">1. Web场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%BB%98%E8%AE%A4%E6%95%88%E6%9E%9C"><span class="toc-number">3.2.</span> <span class="toc-text">2. 默认效果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebMvcAutoConfiguration%E5%8E%9F%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">WebMvcAutoConfiguration原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%9F%E6%95%88%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.3.1.</span> <span class="toc-text">1. 生效条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-WebMvcAutoConfiguration%E4%BA%A7%E7%94%9F%E7%9A%84%E6%95%88%E6%9E%9C"><span class="toc-number">3.3.2.</span> <span class="toc-text">2. WebMvcAutoConfiguration产生的效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebMvcConfigurer%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.3.3.</span> <span class="toc-text">WebMvcConfigurer接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90"><span class="toc-number">3.3.4.</span> <span class="toc-text">2. 静态资源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%BB%98%E8%AE%A4%E8%A7%84%E5%88%99"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">1. 默认规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%98%A0%E5%B0%84"><span class="toc-number">3.3.4.2.</span> <span class="toc-text">1. 静态资源映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%BC%93%E5%AD%98"><span class="toc-number">3.3.4.3.</span> <span class="toc-text">2. 静态资源缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%AC%A2%E8%BF%8E%E9%A1%B5"><span class="toc-number">3.3.4.4.</span> <span class="toc-text">3. 欢迎页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Favicon"><span class="toc-number">3.3.4.5.</span> <span class="toc-text">4. Favicon</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%BC%93%E5%AD%98%E5%AE%9E%E9%AA%8C"><span class="toc-number">3.3.4.6.</span> <span class="toc-text">5. 缓存实验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%A7%84%E5%88%99"><span class="toc-number">3.3.5.</span> <span class="toc-text">2. 自定义静态资源规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.5.1.</span> <span class="toc-text">1. 配置方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.5.2.</span> <span class="toc-text">2. 代码方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-EnableWebMvcConfiguration-%E6%BA%90%E7%A0%81"><span class="toc-number">3.3.6.</span> <span class="toc-text">5. EnableWebMvcConfiguration 源码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Favicon%EF%BC%9A%E7%BD%91%E7%AB%99%E5%9B%BE%E6%A0%87"><span class="toc-number">3.3.6.1.</span> <span class="toc-text">Favicon	：网站图标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%BC%93%E5%AD%98%E5%AE%9E%E9%AA%8C-2"><span class="toc-number">3.3.6.2.</span> <span class="toc-text">5. 缓存实验</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%A7%84%E5%88%99-2"><span class="toc-number">3.4.</span> <span class="toc-text">2. 自定义静态资源规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F-2"><span class="toc-number">3.4.1.</span> <span class="toc-text">1. 配置方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E6%96%B9%E5%BC%8F-2"><span class="toc-number">3.4.2.</span> <span class="toc-text">2. 代码方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%94%BE%E4%B8%80%E4%B8%AAWebMvcConfigurer%E5%B0%B1%E8%83%BD%E9%85%8D%E7%BD%AE%E5%BA%95%E5%B1%82%E8%A1%8C%E4%B8%BA"><span class="toc-number">3.4.3.</span> <span class="toc-text">6. 为什么容器中放一个WebMvcConfigurer就能配置底层行为</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D"><span class="toc-number">3.5.</span> <span class="toc-text">3. 路径匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Ant%E9%A3%8E%E6%A0%BC%E8%B7%AF%E5%BE%84%E7%94%A8%E6%B3%95"><span class="toc-number">3.5.1.</span> <span class="toc-text">1. Ant风格路径用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2"><span class="toc-number">3.5.2.</span> <span class="toc-text">2. 模式切换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AntPathMatcher-%E4%B8%8E-PathPatternParser"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">AntPathMatcher 与 PathPatternParser</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86"><span class="toc-number">3.6.</span> <span class="toc-text">4. 内容协商</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A4%9A%E7%AB%AF%E5%86%85%E5%AE%B9%E9%80%82%E9%85%8D"><span class="toc-number">3.6.1.</span> <span class="toc-text">1. 多端内容适配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%BB%98%E8%AE%A4%E8%A7%84%E5%88%99-2"><span class="toc-number">3.6.1.1.</span> <span class="toc-text">1. 默认规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%88%E6%9E%9C%E6%BC%94%E7%A4%BA"><span class="toc-number">3.6.1.2.</span> <span class="toc-text">2. 效果演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%85%8D%E7%BD%AE%E5%8D%8F%E5%95%86%E8%A7%84%E5%88%99%E4%B8%8E%E6%94%AF%E6%8C%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.6.2.</span> <span class="toc-text">3. 配置协商规则与支持类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%86%85%E5%AE%B9%E8%BF%94%E5%9B%9E"><span class="toc-number">3.6.3.</span> <span class="toc-text">2. 自定义内容返回</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A2%9E%E5%8A%A0yaml%E8%BF%94%E5%9B%9E%E6%94%AF%E6%8C%81"><span class="toc-number">3.6.3.1.</span> <span class="toc-text">1. 增加yaml返回支持</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-HttpMessageConverter%E7%9A%84%E7%A4%BA%E4%BE%8B%E5%86%99%E6%B3%95"><span class="toc-number">3.6.4.</span> <span class="toc-text">3. HttpMessageConverter的示例写法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%80%9D%E8%80%83%EF%BC%9A%E5%A6%82%E4%BD%95%E5%A2%9E%E5%8A%A0%E5%85%B6%E4%BB%96"><span class="toc-number">3.6.4.1.</span> <span class="toc-text">2. 思考：如何增加其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86%E5%8E%9F%E7%90%86-HttpMessageConverter"><span class="toc-number">3.7.</span> <span class="toc-text">3. 内容协商原理-HttpMessageConverter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ResponseBody%E7%94%B1HttpMessageConverter%E5%A4%84%E7%90%86"><span class="toc-number">3.7.1.</span> <span class="toc-text">1. @ResponseBody由HttpMessageConverter处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-WebMvcAutoConfiguration%E6%8F%90%E4%BE%9B%E5%87%A0%E7%A7%8D%E9%BB%98%E8%AE%A4HttpMessageConverters"><span class="toc-number">3.7.2.</span> <span class="toc-text">2. WebMvcAutoConfiguration提供几种默认HttpMessageConverters</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">5. 模板引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Thymeleaf%E6%95%B4%E5%90%88%EF%BC%88%E6%98%AF%E5%89%8D%E5%90%8E%E7%AB%AF%E4%B8%80%E4%BD%93%E7%9A%84%E5%BC%80%E5%8F%91%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">1. Thymeleaf整合（是前后端一体的开发）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%88%E5%9C%A8html%E4%B8%AD%E4%BD%BF%E7%94%A8Thymeleaf%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">2. 基础语法（在html中使用Thymeleaf）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E7%94%A8%E6%B3%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">1. 核心用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.2.2.</span> <span class="toc-text">2. 语法示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE"><span class="toc-number">4.3.</span> <span class="toc-text">3. 属性设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%81%8D%E5%8E%86"><span class="toc-number">4.4.</span> <span class="toc-text">4. 遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%88%A4%E6%96%AD"><span class="toc-number">4.5.</span> <span class="toc-text">5. 判断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#th-if"><span class="toc-number">4.5.1.</span> <span class="toc-text">th:if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#th-switch"><span class="toc-number">4.5.2.</span> <span class="toc-text">th:switch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%B1%9E%E6%80%A7%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.6.</span> <span class="toc-text">6. 属性优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%A1%8C%E5%86%85%E5%86%99%E6%B3%95"><span class="toc-number">4.7.</span> <span class="toc-text">7. 行内写法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%8F%98%E9%87%8F%E9%80%89%E6%8B%A9"><span class="toc-number">4.8.</span> <span class="toc-text">8. 变量选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%A8%A1%E6%9D%BF%E5%B8%83%E5%B1%80"><span class="toc-number">4.9.</span> <span class="toc-text">9. 模板布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-devtools"><span class="toc-number">4.10.</span> <span class="toc-text">10. devtools</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">6. 国际化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">7. 错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%BB%98%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">6.1.</span> <span class="toc-text">1. 默认机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E5%93%8D%E5%BA%94"><span class="toc-number">6.2.</span> <span class="toc-text">2. 自定义错误响应</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%87%AA%E5%AE%9A%E4%B9%89json%E5%93%8D%E5%BA%94"><span class="toc-number">6.2.1.</span> <span class="toc-text">1. 自定义json响应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2%E5%93%8D%E5%BA%94"><span class="toc-number">6.2.2.</span> <span class="toc-text">2. 自定义页面响应</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9C%80%E4%BD%B3%E5%AE%9E%E6%88%98"><span class="toc-number">6.3.</span> <span class="toc-text">3. 最佳实战</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">8. 嵌入式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-number">7.1.</span> <span class="toc-text">1. 自动配置原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="toc-number">7.2.</span> <span class="toc-text">2. 自定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">7.3.</span> <span class="toc-text">3. 最佳实践</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">9. 全面接管SpringMVC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-WebMvcAutoConfiguration-%E5%88%B0%E5%BA%95%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E4%BA%86%E5%93%AA%E4%BA%9B%E8%A7%84%E5%88%99"><span class="toc-number">8.1.</span> <span class="toc-text">1. WebMvcAutoConfiguration 到底自动配置了哪些规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-EnableWebMvc-%E7%A6%81%E7%94%A8%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="toc-number">8.2.</span> <span class="toc-text">2. @EnableWebMvc 禁用默认行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-WebMvcConfigurer-%E5%8A%9F%E8%83%BD"><span class="toc-number">8.3.</span> <span class="toc-text">2. WebMvcConfigurer 功能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">10. 最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">9.1.</span> <span class="toc-text">三种方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">11. Web新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Problemdetails"><span class="toc-number">10.1.</span> <span class="toc-text">1. Problemdetails</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E5%BC%8FWeb"><span class="toc-number">10.2.</span> <span class="toc-text">2. 函数式Web</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9C%BA%E6%99%AF"><span class="toc-number">10.2.1.</span> <span class="toc-text">1. 场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%B8%E5%BF%83%E7%B1%BB"><span class="toc-number">10.2.2.</span> <span class="toc-text">2. 核心类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%A4%BA%E4%BE%8B"><span class="toc-number">10.2.3.</span> <span class="toc-text">3. 示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">3、SpringBoot3-数据访问</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-number">11.1.</span> <span class="toc-text">2. 配置数据源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%85%8D%E7%BD%AEMyBatis"><span class="toc-number">11.2.</span> <span class="toc-text">3. 配置MyBatis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-CRUD%E7%BC%96%E5%86%99"><span class="toc-number">11.3.</span> <span class="toc-text">4. CRUD编写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-number">11.4.</span> <span class="toc-text">5. 自动配置原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E7%94%9F%E6%95%88%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">11.5.</span> <span class="toc-text">6. 快速定位生效的配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%89%A9%E5%B1%95%EF%BC%9A%E6%95%B4%E5%90%88%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-number">11.6.</span> <span class="toc-text">7. 扩展：整合其他数据源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Druid-%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-number">11.6.1.</span> <span class="toc-text">1. Druid 数据源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95%EF%BC%9A%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A6%81%E5%85%88%E8%87%AA%E5%B7%B1%E5%88%9B%E5%BB%BAtest%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%89"><span class="toc-number">11.7.</span> <span class="toc-text">附录：示例数据库(要先自己创建test数据库）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">4、SpringBoot3-基础特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%87%AA%E5%AE%9A%E4%B9%89-SpringApplication"><span class="toc-number">12.1.</span> <span class="toc-text">1.2. 自定义 SpringApplication</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-FluentBuilder-API"><span class="toc-number">12.2.</span> <span class="toc-text">1.3. FluentBuilder API</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">2. Profiles</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%BD%BF%E7%94%A8"><span class="toc-number">13.1.</span> <span class="toc-text">2.1. 使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E6%8C%87%E5%AE%9A%E7%8E%AF%E5%A2%83"><span class="toc-number">13.1.1.</span> <span class="toc-text">2.1.1 指定环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E7%8E%AF%E5%A2%83%E6%BF%80%E6%B4%BB%EF%BC%88%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%8C%87%E5%AE%9A%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%9A%84%E7%89%B9%E5%AE%9A%E7%8E%AF%E5%A2%83%EF%BC%89"><span class="toc-number">13.1.2.</span> <span class="toc-text">2.1.2 环境激活（也就是指定当前系统运行的特定环境）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E7%8E%AF%E5%A2%83%E5%8C%85%E5%90%AB"><span class="toc-number">13.1.3.</span> <span class="toc-text">2.1.3 环境包含</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Profile-%E5%88%86%E7%BB%84"><span class="toc-number">13.2.</span> <span class="toc-text">2.2. Profile 分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Profile-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">13.3.</span> <span class="toc-text">2.3. Profile 配置文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">14.</span> <span class="toc-text">3. 外部化配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E9%85%8D%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">14.1.</span> <span class="toc-text">3.1. 配置优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%A4%96%E9%83%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">14.2.</span> <span class="toc-text">3.2. 外部配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%AF%BC%E5%85%A5%E9%85%8D%E7%BD%AE"><span class="toc-number">14.3.</span> <span class="toc-text">3.3. 导入配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%B1%9E%E6%80%A7%E5%8D%A0%E4%BD%8D%E7%AC%A6"><span class="toc-number">14.4.</span> <span class="toc-text">3.4. 属性占位符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">15.</span> <span class="toc-text">4. 单元测试-JUnit5</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%95%B4%E5%90%88"><span class="toc-number">15.1.</span> <span class="toc-text">4.1. 整合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%B5%8B%E8%AF%95"><span class="toc-number">15.2.</span> <span class="toc-text">4.2. 测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-0-%E7%BB%84%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="toc-number">15.2.1.</span> <span class="toc-text">4.2.0 组件测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E6%B3%A8%E8%A7%A3"><span class="toc-number">15.2.2.</span> <span class="toc-text">4.2.1 注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E6%96%AD%E8%A8%80"><span class="toc-number">15.2.3.</span> <span class="toc-text">4.2.2 断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E5%B5%8C%E5%A5%97%E6%B5%8B%E8%AF%95"><span class="toc-number">15.2.4.</span> <span class="toc-text">4.2.3 嵌套测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95"><span class="toc-number">15.2.5.</span> <span class="toc-text">4.2.4 参数化测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">16.</span> <span class="toc-text">5、SpringBoot3-核心原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">16.1.</span> <span class="toc-text">1. 事件和监听器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%85%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">16.1.1.</span> <span class="toc-text">2. 生命周期全流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA"><span class="toc-number">16.2.</span> <span class="toc-text">2. 事件触发时机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%90%84%E7%A7%8D%E5%9B%9E%E8%B0%83%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">16.2.1.</span> <span class="toc-text">1. 各种回调监听器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%8C%E6%95%B4%E8%A7%A6%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-number">16.2.2.</span> <span class="toc-text">2. 完整触发流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-SpringBoot-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91"><span class="toc-number">16.2.3.</span> <span class="toc-text">3. SpringBoot 事件驱动开发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">17.</span> <span class="toc-text">**2. **自动配置原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%85%A5%E9%97%A8%E7%90%86%E8%A7%A3"><span class="toc-number">17.1.</span> <span class="toc-text">1. 入门理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="toc-number">17.1.1.</span> <span class="toc-text">1. 自动配置流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-SPI%E6%9C%BA%E5%88%B6"><span class="toc-number">17.1.2.</span> <span class="toc-text">2. SPI机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8A%9F%E8%83%BD%E5%BC%80%E5%85%B3"><span class="toc-number">17.1.3.</span> <span class="toc-text">3. 功能开关</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BF%9B%E9%98%B6%E7%90%86%E8%A7%A3"><span class="toc-number">17.2.</span> <span class="toc-text">2. 进阶理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-SpringBootApplication"><span class="toc-number">17.2.1.</span> <span class="toc-text">1. @SpringBootApplication</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBootConfiguration"><span class="toc-number">17.2.1.1.</span> <span class="toc-text">@SpringBootConfiguration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EnableAutoConfiguration%EF%BC%9A%E5%BC%80%E5%90%AF%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">17.2.1.2.</span> <span class="toc-text">@EnableAutoConfiguration：开启自动配置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#AutoConfigurationPackage%EF%BC%9A%E6%89%AB%E6%8F%8F%E4%B8%BB%E7%A8%8B%E5%BA%8F%E5%8C%85%EF%BC%9A%E5%8A%A0%E8%BD%BD%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-number">17.2.1.2.1.</span> <span class="toc-text">@AutoConfigurationPackage：扫描主程序包：加载自己的组件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Import-AutoConfigurationImportSelector-class-%EF%BC%9A%E5%8A%A0%E8%BD%BD%E6%89%80%E6%9C%89%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%B1%BB%EF%BC%9A%E5%8A%A0%E8%BD%BDstarter%E5%AF%BC%E5%85%A5%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-number">17.2.1.2.2.</span> <span class="toc-text">@Import(AutoConfigurationImportSelector.class)：加载所有自动配置类：加载starter导入的组件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ComponentScan"><span class="toc-number">17.2.1.3.</span> <span class="toc-text">@ComponentScan</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%8C%E6%95%B4%E5%90%AF%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="toc-number">17.2.2.</span> <span class="toc-text">2. 完整启动加载流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">18.</span> <span class="toc-text">3. 自定义starter</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81"><span class="toc-number">18.1.</span> <span class="toc-text">1. 业务代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E6%8A%BD%E5%8F%96"><span class="toc-number">18.2.</span> <span class="toc-text">2. 基本抽取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8-EnableXxx%E6%9C%BA%E5%88%B6"><span class="toc-number">18.3.</span> <span class="toc-text">3. 使用@EnableXxx机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AE%8C%E5%85%A8%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">18.4.</span> <span class="toc-text">4. 完全自动配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">19.</span> <span class="toc-text">SpringBoot3-场景整合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">19.1.</span> <span class="toc-text">0. 云服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Docker%E5%AE%89%E8%A3%85"><span class="toc-number">19.2.</span> <span class="toc-text">1. Docker安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-prometheus-yml"><span class="toc-number">19.3.</span> <span class="toc-text">2. prometheus.yml</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-docker-compose-yml"><span class="toc-number">19.4.</span> <span class="toc-text">3. docker-compose.yml</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%90%AF%E5%8A%A8%E7%8E%AF%E5%A2%83"><span class="toc-number">19.5.</span> <span class="toc-text">4. 启动环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%AA%8C%E8%AF%81"><span class="toc-number">19.6.</span> <span class="toc-text">5. 验证:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-10-25"><span class="toc-number">19.7.</span> <span class="toc-text">Docker:(10-25)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">19.7.1.</span> <span class="toc-text">Docker基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">19.7.1.1.</span> <span class="toc-text">1、解决的问题:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB"><span class="toc-number">19.7.1.2.</span> <span class="toc-text">2、资源隔离</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%9E%B6%E6%9E%84"><span class="toc-number">19.7.2.</span> <span class="toc-text">2、架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AE%89%E8%A3%85"><span class="toc-number">19.7.3.</span> <span class="toc-text">3、安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81centos%E4%B8%8B%E5%AE%89%E8%A3%85docker"><span class="toc-number">19.7.3.1.</span> <span class="toc-text">1、centos下安装docker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%A7%BB%E9%99%A4%E4%BB%A5%E5%89%8Ddocker%E7%9B%B8%E5%85%B3%E5%8C%85"><span class="toc-number">19.7.3.2.</span> <span class="toc-text">1、移除以前docker相关包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%85%8D%E7%BD%AEyum%E6%BA%90%E5%B9%B6%E4%B8%94%E6%B7%BB%E5%8A%A0%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%EF%BC%9A"><span class="toc-number">19.7.3.3.</span> <span class="toc-text">2、配置yum源并且添加镜像仓库：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%AE%89%E8%A3%85docker"><span class="toc-number">19.7.3.4.</span> <span class="toc-text">3、安装docker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%90%AF%E5%8A%A8"><span class="toc-number">19.7.3.5.</span> <span class="toc-text">4、启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E9%85%8D%E7%BD%AE%E5%8A%A0%E9%80%9F"><span class="toc-number">19.7.3.6.</span> <span class="toc-text">5、配置加速</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E9%95%9C%E5%83%8F%E5%92%8C%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">19.7.3.7.</span> <span class="toc-text">6.镜像和容器的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E5%91%BD%E4%BB%A4%E5%AE%9E%E6%88%98"><span class="toc-number">19.7.4.</span> <span class="toc-text">Docker命令实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">19.7.4.1.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98"><span class="toc-number">19.7.4.2.</span> <span class="toc-text">基础实战</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%89%BE%E9%95%9C%E5%83%8F"><span class="toc-number">19.7.4.2.1.</span> <span class="toc-text">1、找镜像</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#docker%E5%88%A0%E9%99%A4%EF%BC%9A"><span class="toc-number">19.7.4.2.2.</span> <span class="toc-text">docker删除：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="toc-number">19.7.4.2.3.</span> <span class="toc-text">2、启动容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%EF%BC%9A"><span class="toc-number">19.7.4.2.4.</span> <span class="toc-text">端口映射：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#image-png"><span class="toc-number">19.7.4.2.5.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E5%86%85%E5%AE%B9%EF%BC%88%E5%8F%AF%E4%BB%A5%E5%8E%BBdockpub%E5%AE%98%E7%BD%91%E6%9F%A5%E7%9C%8B%E7%9B%B8%E5%85%B3%E5%AE%B9%E5%99%A8%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%89"><span class="toc-number">19.7.4.2.6.</span> <span class="toc-text">3、修改容器内容（可以去dockpub官网查看相关容器的用法）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81%E8%BF%9B%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E4%BF%AE%E6%94%B9"><span class="toc-number">19.7.4.2.6.1.</span> <span class="toc-text">1、进容器内部修改</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#image-png-2"><span class="toc-number">19.7.4.2.6.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E6%8C%82%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%88%B0%E5%A4%96%E9%83%A8%E4%BF%AE%E6%94%B9"><span class="toc-number">19.7.4.2.6.3.</span> <span class="toc-text">2、挂载数据到外部修改</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%E3%80%81%E6%8F%90%E4%BA%A4%E6%94%B9%E5%8F%98"><span class="toc-number">19.7.4.2.6.4.</span> <span class="toc-text">4、提交改变</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E4%BF%9D%E5%AD%98%EF%BC%9A"><span class="toc-number">19.7.4.2.6.5.</span> <span class="toc-text">镜像保存：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81%E9%95%9C%E5%83%8F%E4%BC%A0%E8%BE%93"><span class="toc-number">19.7.4.2.6.6.</span> <span class="toc-text">1、镜像传输</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5%E3%80%81%E6%8E%A8%E9%80%81%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="toc-number">19.7.4.2.6.7.</span> <span class="toc-text">5、推送远程仓库</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6%E3%80%81%E8%A1%A5%E5%85%85"><span class="toc-number">19.7.4.2.6.8.</span> <span class="toc-text">6、补充</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%E5%AE%9E%E6%88%98"><span class="toc-number">19.7.5.</span> <span class="toc-text">进阶实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">19.7.5.1.</span> <span class="toc-text">1、编写自己的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%B0%86%E5%BA%94%E7%94%A8%E6%89%93%E5%8C%85%E6%88%90%E9%95%9C%E5%83%8F"><span class="toc-number">19.7.5.1.1.</span> <span class="toc-text">2、将应用打包成镜像</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BB%A5%E5%89%8D"><span class="toc-number">19.7.5.1.2.</span> <span class="toc-text">1、以前</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E7%8E%B0%E5%9C%A8"><span class="toc-number">19.7.5.1.3.</span> <span class="toc-text">2、现在</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E6%80%8E%E4%B9%88%E6%89%93%E5%8C%85-Dockerfile"><span class="toc-number">19.7.5.1.4.</span> <span class="toc-text">3、怎么打包-Dockerfile</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="toc-number">19.7.5.1.5.</span> <span class="toc-text">3、启动容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E9%83%A8%E7%BD%B2%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">19.7.5.1.6.</span> <span class="toc-text">4、部署中间件</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81NoSQL"><span class="toc-number">19.8.</span> <span class="toc-text">1、NoSQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%95%B4%E5%90%88"><span class="toc-number">19.8.1.</span> <span class="toc-text">Redis整合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9C%BA%E6%99%AF%E6%95%B4%E5%90%88"><span class="toc-number">19.9.</span> <span class="toc-text">1. 场景整合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-number">19.10.</span> <span class="toc-text">2. 自动配置原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AE%9A%E5%88%B6%E5%8C%96"><span class="toc-number">19.11.</span> <span class="toc-text">3. 定制化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-redis%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">19.11.1.</span> <span class="toc-text">2. redis客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%85%8D%E7%BD%AE%E5%8F%82%E8%80%83"><span class="toc-number">19.11.2.</span> <span class="toc-text">3. 配置参考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">19.11.3.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1%EF%BC%9A"><span class="toc-number">19.12.</span> <span class="toc-text">消息服务：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-docker%E5%AE%89%E8%A3%85kafka%EF%BC%88%E6%B2%A1%E5%AD%A6%E5%AE%8C%EF%BC%89"><span class="toc-number">19.13.</span> <span class="toc-text">1.docker安装kafka（没学完）</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 山麋一笑</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div id="runtime"></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-teal-alpha.vercel.app/',
      region: 'ap-shanghai',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.29/dist/twikoo.all.min.js').then(init)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-teal-alpha.vercel.app/',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
      
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script  src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><div class="aplayer no-destroy" data-id="2914905159" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="auto" data-autoplay="true" muted></div><script  async data-pjax="" defer="" src="/js/fish.js"></script><script async src="/js/universe.js"></script><canvas id="universe"></canvas><script async src="/js/diytitle.js"></script><script async src="/js/runtime.js"></script><script>let tianliGPT_postSelector = '\#post \#article-container';let tianliGPT_key = '92ec679de1bc42262c48';</script><script   defer src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script><script async src="/js/leaf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div></body></html>