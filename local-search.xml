<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>IDEA使用技巧</title>
    <link href="/2024/01/23/IDEA%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A/"/>
    <url>/2024/01/23/IDEA%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id="1-IDEA视图不小心设置让设置无法显示出来？"><a href="#1-IDEA视图不小心设置让设置无法显示出来？" class="headerlink" title="1.IDEA视图不小心设置让设置无法显示出来？"></a>1.IDEA视图不小心设置让设置无法显示出来？</h2><p>其实双按shift可以打开搜索模式，这里的搜索模式输入View是可以进入View设置的<br>2.<a href="https://blog.csdn.net/xiao_yi_xiao/article/details/119142118">ERROR:JAVA: 错误: 不支持发行版本 5 解决方法_欧晨eli的博客-CSDN博客</a><br><a href="https://blog.csdn.net/df1067/article/details/106567084?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">IDEA的junit单元测试Scanner输入无效-CSDN博客</a></p><h2 id="3-maven创建spring发生版本不兼容问题："><a href="#3-maven创建spring发生版本不兼容问题：" class="headerlink" title="3.maven创建spring发生版本不兼容问题："></a>3.maven创建spring发生版本不兼容问题：</h2><p><a href="https://blog.csdn.net/angelbeautiful/article/details/131182554">解决：java: 警告: 源发行版 17 需要目标发行版 17-CSDN博客</a><a href="https://blog.csdn.net/qq_49619863/article/details/128047256">Springbot启动报错-类文件具有错误的版本 61.0, 应为 52.0_&#x2F;d:&#x2F;java&#x2F;apache-maven-3.8.6&#x2F;repository&#x2F;org&#x2F;springf-CSDN博客</a></p><h2 id="4-pom-xml问题："><a href="#4-pom-xml问题：" class="headerlink" title="4.pom.xml问题："></a>4.pom.xml问题：</h2><p><a href="https://blog.csdn.net/hkzuz/article/details/132006743?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-4-132006743-blog-114698522.235%5Ev38%5Epc_relevant_default_base&spm=1001.2101.3001.4242.3&utm_relevant_index=7">idea模块的pom.xml被划横线，不识别的解决办法_idea pom 划线_八戒，你又涨价了哎的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDEA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS改变原生样式:---改变radio,checkbox等选择框的颜色</title>
    <link href="/2024/01/23/CSS%E6%94%B9%E5%8F%98%E5%8E%9F%E7%94%9F%E6%A0%B7%E5%BC%8F_---%E6%94%B9%E5%8F%98radio,checkbox%E7%AD%89%E9%80%89%E6%8B%A9%E6%A1%86%E7%9A%84%E9%A2%9C%E8%89%B2%EF%BC%9A/"/>
    <url>/2024/01/23/CSS%E6%94%B9%E5%8F%98%E5%8E%9F%E7%94%9F%E6%A0%B7%E5%BC%8F_---%E6%94%B9%E5%8F%98radio,checkbox%E7%AD%89%E9%80%89%E6%8B%A9%E6%A1%86%E7%9A%84%E9%A2%9C%E8%89%B2%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="方法1：使用accent-color"><a href="#方法1：使用accent-color" class="headerlink" title="方法1：使用accent-color:"></a>方法1：使用accent-color:</h2><div class="code-wrapper"><pre><code class="hljs javascript">accent-color能修改 input 默认控件的颜色（也就是修改选中后的颜色）。</code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span>&gt;</span>radio    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span>checkbox<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html">input[type=radio]&#123;       accent-color: red;   &#125; input[type=checkbox]&#123;     accent-color: blue; &#125;</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697618263372-f1249af9-ea74-44c4-acf3-ddb03e00f143.png#averageHue=%23daae68&clientId=ud398c746-c1b4-4&from=paste&height=42&id=u68fb0b6e&originHeight=52&originWidth=219&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=2154&status=done&style=none&taskId=u97a645d3-6329-4e81-ac17-9a1c7948d41&title=&width=175.2" alt="image.png"></p><h2 id="方法二：通过伪元素来实现"><a href="#方法二：通过伪元素来实现" class="headerlink" title="方法二：通过伪元素来实现"></a>方法二：通过伪元素来实现</h2><div class="code-wrapper"><pre><code class="hljs javascript">&lt;body&gt;       <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myCheckbox&quot;</span>&gt;</span></span><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;myCheckbox&quot;</span>&gt;</span>checkbox<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript">&lt;style&gt;   <span class="hljs-comment">/*隐藏默认复选框  */</span>   input[type=checkbox]&#123;    <span class="hljs-attr">display</span>: none;   &#125;   <span class="hljs-comment">/*  创建自定义复选框*/</span>   input[type=checkbox]+<span class="hljs-attr">label</span>::before&#123;    <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;    <span class="hljs-attr">display</span>: inline-block;    <span class="hljs-attr">width</span>: 16px;    <span class="hljs-attr">height</span>: 16px;    <span class="hljs-attr">border</span>: 1px solid #ccc;    background-<span class="hljs-attr">color</span>: #fff;    margin-<span class="hljs-attr">right</span>: 8px;   &#125;   <span class="hljs-comment">/* 自定义选中后的效果 */</span>   input[type=checkbox]:checked+<span class="hljs-attr">label</span>::before&#123;     background-<span class="hljs-attr">color</span>: red;   &#125;    &lt;/style&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript">input后面的lable标签：&lt;label&gt; 标签为 input 元素定义标注（标记）。label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果您在 label 元素内点击文本，就会触发此控件。就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。&lt;label&gt; 标签的 <span class="hljs-keyword">for</span> 属性应当与相关元素的 id 属性相同。<span class="hljs-attr">label</span>::before是伪元素用法，并不是表示label前面的一个元素，而是在label元素之前添加内容</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript">ss的伪元素，之所以被称为伪元素，是因为他们不是真正的页面元素，html没有对应的元素，但是其所有用法和表现行为与真正的页面元素一样，可以对其使用诸如页面元素一样的css样式，表面上看上去貌似是页面的某些元素来展现，实际上是css样式展现的行为，因此被称为伪元素。伪元素:before和:after用法：这个两个伪元素在真正页面元素内部之前和之后添加新内容（当然了，可以对伪元素应用定位可以置于任何位置）伪元素:before和:after添加的内容默认是inline元素伪元素不属于文档，所以js无法操作它伪元素属于主元素的一部分，因此点击伪元素触发的是主元素的click事件</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件体系结构实验1</title>
    <link href="/2024/01/23/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%84%E4%B8%80%EF%BC%9A/"/>
    <url>/2024/01/23/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%84%E4%B8%80%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="一、-实验内容"><a href="#一、-实验内容" class="headerlink" title="一、     实验内容"></a>一、     实验内容</h1><p>噪声监测系统通常由声级计（声音传感器）、采集单元和传输单元、PC计算机等部分组成。采集单元从传感器采集声音信息并转换为数字，然后通过传输单元上传到PC端（暂定采用串口通讯方式），PC端通过技术分析后将数据上传至数据库服务器，并在PC端以合适方式展示噪声信息。<br>（1）    采集单元由单片机构成，负责数据采集，并通过串口通讯方式上传给PC端；<br>（2）    PC端软件需要使用RS232 SDK来与采集单元通讯（将来可能更换为其它通讯方式）。<br>（3）    操作员即可以实时查看当前采集到的噪声信息，也可以分析数据库服务器中保存的任意时段噪声数据并打印输出分析报告。<br>任务：<br>（1）    利用“4+1”视图建模方法对以上描述的“噪声监测系统”进行软件体系结构设计。<br>（2）    请说明当PC端与采集单元的通讯方式发生变化，你设计的体系结构如何应对？</p><h1 id="二-实验步骤："><a href="#二-实验步骤：" class="headerlink" title="二.实验步骤："></a>二.实验步骤：</h1><h3 id="UML图形工具："><a href="#UML图形工具：" class="headerlink" title="UML图形工具："></a>UML图形工具：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698159226042-a739b842-f60f-4298-82db-642960693b27.png#averageHue=%23a9b8cf&clientId=u801801c7-a9c6-4&from=paste&height=37&id=u0da0c52a&originHeight=46&originWidth=118&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=4001&status=done&style=none&taskId=ue0c9bcfd-3f49-4bf5-8a93-6a3d9ef0124&title=&width=94.4" alt="image.png"></p><h3 id="设计考虑："><a href="#设计考虑：" class="headerlink" title="设计考虑："></a>设计考虑：</h3><ul><li>可维护性：软件应该易于维护和修改。</li><li>可重用性：软件应该易于重用。</li><li>可扩展性：软件应该易于扩展。</li><li>可移植性：软件应该易于移植到不同的平台。</li><li>可靠性：软件应该具有高可靠性，即在面对各种异常情况时，仍能保持正常运行。</li><li>性能：软件应该具有良好的性能，即能够在合理的时间内完成所需的任务。</li><li>安全性：软件应该具有良好的安全性，即能够保护用户数据和系统安全。</li></ul><p>在该系统中当PC端与采集单元的通讯方式发生变化时，只修改传输单元构件就可以了。</p><h3 id="场景视图："><a href="#场景视图：" class="headerlink" title="场景视图："></a>场景视图：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698153699112-7fa93cdc-222a-4d16-874d-5e78cd61d2a3.png#averageHue=%23fbfafa&clientId=u801801c7-a9c6-4&from=paste&height=402&id=ua6eec258&originHeight=502&originWidth=1087&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=47190&status=done&style=none&taskId=u7855be2e-7411-42d6-91d1-7220a19b188&title=&width=869.6" alt="image.png"></p><h3 id="逻辑视图："><a href="#逻辑视图：" class="headerlink" title="逻辑视图："></a>逻辑视图：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698152866585-0dfa1d1a-ae1a-4d27-b982-26c93d615da4.png#averageHue=%23fbfbfb&clientId=u801801c7-a9c6-4&from=paste&height=557&id=ue708415f&originHeight=696&originWidth=836&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=60052&status=done&style=none&taskId=u328a519f-dea8-4bcb-95b1-898928bfb89&title=&width=668.8" alt="image.png"></p><h3 id="开发视图："><a href="#开发视图：" class="headerlink" title="开发视图："></a>开发视图：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698155637140-036debb3-55ce-43d1-b09c-5638bc865989.png#averageHue=%23fbfafa&clientId=u801801c7-a9c6-4&from=paste&height=369&id=u566380b8&originHeight=461&originWidth=982&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=30739&status=done&style=none&taskId=u0c7f7c31-b7e0-4240-8cb1-ad5cb429857&title=&width=785.6" alt="image.png"></p><h3 id="过程视图："><a href="#过程视图：" class="headerlink" title="过程视图："></a>过程视图：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698157462151-a983e627-1103-40d7-934b-774a9610190e.png#averageHue=%23fbfbfb&clientId=u801801c7-a9c6-4&from=paste&height=531&id=ub5b52c72&originHeight=664&originWidth=945&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=32263&status=done&style=none&taskId=u5670c9a1-a54e-437c-91f8-88b97f71786&title=&width=756" alt="image.png"></p><h3 id="物理视图："><a href="#物理视图：" class="headerlink" title="物理视图："></a>物理视图：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698158529311-9b819f7c-d9c4-4b22-9876-26fa35905f40.png#averageHue=%23fcfcfc&clientId=u801801c7-a9c6-4&from=paste&height=478&id=ueec8c875&originHeight=597&originWidth=1180&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=25775&status=done&style=none&taskId=ub53983ef-ec4a-4da0-9a8e-86748cce8e0&title=&width=944" alt="image.png"></p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>逻辑视图和开发视图描述系统的静态结构，而进程视图和物理视图描述系统的动态结构。<br>对于不同的软件系统来说，侧重的角度也有所不同。例如，对于管理信息系统来说，比较侧重于从逻辑视图和开发视图来描述系统，而对于实时控制系统来说，则比较注重于从进程视图和物理视图来描述系统。<br>“4+1”视图模型已经成功使用在几个大型项目中，无论是否在术语4中有一些本地定制和调整。它的确能使不同利益相关者找到他们想了解的软件架构信息。系统工程师使用物理视图，再到过程视图。最终用户、客户、数据专家使用逻辑视图。项目经理、软件配置人员使用开发视图。</p>]]></content>
    
    
    <categories>
      
      <category>课程作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程作业</tag>
      
      <tag>软件体系结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件体系结构实验2</title>
    <link href="/2024/01/23/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A/"/>
    <url>/2024/01/23/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="一：实验内容："><a href="#一：实验内容：" class="headerlink" title="一：实验内容："></a>一：实验内容：</h1><p>任务1：仔细阅读文献<a href="https://blog.csdn.net/weixin_43853097/article/details/110943379?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-110943379-blog-82871259.t5_download_50w&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-110943379-blog-82871259.t5_download_50w&utm_relevant_index=1">“主程序-子程序、面向对象、事件系统和管道-过滤软件体系结构实现KWIC”</a><br>任务2：实现文献中的所有程序并调试通过。<br>任务3：参考和整合以上参考文献，开发“经典软件体系结构教学软件”，用于向用户展示主程序-子程序、面向对象、事件系统和管道-过滤器等软件体系结构风格的基本原理。软件功能及界面可自由设计，但应包括如下内容：<br>（1） 用户可选择四种方法之一对指定的输入文件进行处理，结果可显示在界面上；<br>（2） 能够分别显示各种“体系结构风格”的原理图或文字说明、源程序代码结构、关键函数的程序代码等；</p><h1 id="二-软件开发："><a href="#二-软件开发：" class="headerlink" title="二.软件开发："></a>二.软件开发：</h1><h2 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h2><p>1.JDK8，maven，IDEA<br>2.springboot+thymeleaf<br>3.源代码地址：<a href="https://gitee.com/fanshanshui/architecture-experiment.git">晓晨&#x2F; Sa-experiment2</a></p><h2 id="源代码结构："><a href="#源代码结构：" class="headerlink" title="源代码结构："></a>源代码结构：</h2><p>总体上采用MVC的结构开发<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698234665556-84cbfcec-e244-4337-b7d3-d017dbb8fa5f.png#averageHue=%23536268&clientId=u877b6732-74b4-4&from=paste&height=429&id=ubb371b37&originHeight=536&originWidth=747&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=197557&status=done&style=none&taskId=uc0ca482f-3a9a-47e8-874f-9c3704d4417&title=&width=597.6" alt="image.png"></p><h2 id="运行截图："><a href="#运行截图：" class="headerlink" title="运行截图："></a>运行截图：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698234725788-c45e761c-74fb-40b3-a776-58a10a9a960d.png#averageHue=%23f8f7f6&clientId=u877b6732-74b4-4&from=paste&height=460&id=u03d42cbc&originHeight=575&originWidth=895&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=66407&status=done&style=none&taskId=uec95920a-a594-417c-81a8-de7371b3142&title=&width=716" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698234765228-25385136-a354-4f30-8362-bf9803d163b6.png#averageHue=%23f9f9f9&clientId=u877b6732-74b4-4&from=paste&height=691&id=u7455a5cd&originHeight=864&originWidth=1062&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=137092&status=done&style=none&taskId=u8b241396-23af-4f0e-81d8-d9a2bb84831&title=&width=849.6" alt="image.png"><br>查看代码功能：<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698234879261-3c23de92-5852-4e21-8ab7-99759e33561f.png#averageHue=%23f9f8f6&clientId=u877b6732-74b4-4&from=paste&height=567&id=u35382cfd&originHeight=709&originWidth=834&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=57216&status=done&style=none&taskId=ucf1ce82a-1ba7-4e1c-a51f-b64c8759f79&title=&width=667.2" alt="image.png"><br>测试其他体系结构：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698234930262-3ee8b732-4f15-4ad9-bd02-66942c85530a.png#averageHue=%23f8f7f7&clientId=u877b6732-74b4-4&from=paste&height=680&id=u796df42e&originHeight=850&originWidth=995&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=123152&status=done&style=none&taskId=ub30051ab-dee9-4c81-9c51-fcf8ba3e6bf&title=&width=796" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698234937075-62502cb5-5cb3-40ba-8f95-922195995ade.png#averageHue=%23f8f8f8&clientId=u877b6732-74b4-4&from=paste&height=690&id=u991882cc&originHeight=862&originWidth=986&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=124221&status=done&style=none&taskId=u96a57ed2-bacd-4dbc-ba27-504b792f2c7&title=&width=788.8" alt="image.png"></p><h1 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h1><p>1.IDEA文件相对路径写对了但是却找不到的问题：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698235681601-a66b317a-554e-4f0f-a750-7551025d20c3.png#averageHue=%2335445c&clientId=u877b6732-74b4-4&from=paste&height=458&id=ue394ae0a&originHeight=573&originWidth=1656&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=400404&status=done&style=none&taskId=ub7150a54-bd54-45df-8eeb-f161a7a2059&title=&width=1324.8" alt="image.png"><br>原因是：..&#x2F;表示上级目录是Linucx下的表示方法<br>解决方法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>);<span class="hljs-comment">//获取当前程序运行的目录，</span><span class="hljs-comment">// 它通常是启动 Java 程序的命令行或应用程序所在的目录。</span><span class="hljs-type">FileReader</span> <span class="hljs-variable">fileReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(root+File.separator+<span class="hljs-string">&quot;test.txt&quot;</span>);<span class="hljs-comment">//File.separator</span><span class="hljs-comment">//是产生文件分割符号，Linucx和window的文件分割符是不一样的。</span></code></pre></div><p>2.添加了devtools依赖并不能实现真正意义上的修改代码不用重新加载就可以看到变化，还需要设置IDEA自动编译<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698236724532-84392022-ec93-4264-8026-d0e9b9a0011b.png#averageHue=%23303337&clientId=u877b6732-74b4-4&from=paste&height=613&id=uc3c35123&originHeight=766&originWidth=716&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=67616&status=done&style=none&taskId=ud5c01a0c-9053-4345-9514-c3b4be91c29&title=&width=572.8" alt="image.png"></p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>主程序-子程序风格是一种结构化的软件体系结构，它从功能的角度设计系统，通过逐步分解和细化，形成整个系统的体系结构。主程序是系统的入口和控制中心，它调用各种子程序来完成具体的任务。子程序是一些独立的功能模块，它们可以被主程序或其他子程序重复调用。主程序-子程序风格的特点有：<br>•  简单：它遵循自顶向下、逐步求精的设计原则，易于理解和实现。<br>•  模块化：它将系统划分为若干相对独立的模块，提高了代码的重用性和可维护性。<br>•  局限性：它不能很好地处理数据和行为的耦合问题，也不适合处理并发和分布式的情况。<br>面向对象风格是一种封装的软件体系结构，它从数据的角度设计系统，通过抽象和多态，形成整个系统的体系结构。对象是系统的基本单位，它包含了数据和作用在数据上的操作。对象之间通过接口进行消息传递和协作。面向对象风格的特点有：<br>•  灵活：它可以通过继承和组合来实现代码的复用和扩展，也可以通过多态来实现动态绑定和行为变化。<br>•  隐蔽性：它可以通过封装来隐藏对象的内部细节，只暴露必要的接口给外界，提高了系统的安全性和稳定性。<br>•  复杂性：它需要考虑对象之间的关系和协作，以及对象生命周期和状态管理等问题，增加了系统的设计难度和开发成本。<br> 事件系统风格是一种异步的软件体系结构，它从交互的角度设计系统，通过事件驱动和回调函数，形成整个系统的体系结构。事件是系统中发生的各种情况或变化，它们可以由用户、设备或其他源产生。事件处理器是响应事件并执行相应操作的模块，它们可以注册到事件源或事件分发器上。事件系统风格的特点有：<br>•  响应性：它可以实现非阻塞式的通信和处理，提高了系统的并发性能和用户体验。<br>•  解耦性：它可以将事件源和事件处理器分离开来，降低了系统各部分之间的依赖性。<br>•  不确定性：它需要处理事件之间的时序、优先级、冲突等问题，也需要考虑事件丢失、重复、延迟等问题，增加了系统的复杂性和不可预测性。<br> 管道-过滤器风格是一种流式的软件体系结构，它从数据流的角度设计系统，通过连续处理和数据转换，形成整个系统的体系结构。过滤器是对输入数据流进行某种变换或增量计算，并产生输出数据流的模块。管道是将一个过滤器的输出传递到另一个过滤器输入的连接件。管道-过滤器风格的特点有：<br>•  可重用性：它可以将系统任务分解为若干个过滤器，每个过滤器都是一个独立的实体，可以在不同的系统中重用。<br>•  可组合性：它可以将不同的过滤器通过管道连接起来，形成不同的功能和行为。<br>•  可并行性：它可以将每个过滤器作为一个单独的任务执行，实现系统的并行处理和分布式计算。<br>•  局限性：它要求过滤器之间的数据格式和传输方式相匹配，也要求过滤器之间没有共享数据和状态信息，否则会影响系统的正确性和效率。</p>]]></content>
    
    
    <categories>
      
      <category>课程作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程作业</tag>
      
      <tag>软件体系结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件体系结构实验3</title>
    <link href="/2024/01/23/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A/"/>
    <url>/2024/01/23/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="一、-实验内容"><a href="#一、-实验内容" class="headerlink" title="一、 实验内容"></a>一、 实验内容</h2><p>个人通讯录系统的设计目标是能够轻松地管理个人的联系人信息，包括添加、修改和删除操作。联系人信息包括姓名、住址、电话。整个系统的功能图如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698393517486-f9c653d0-3e66-4310-b2b0-1db18abb2e74.png#averageHue=%23f1f1f1&clientId=u537b546b-41d6-4&from=paste&height=229&id=u7cf32b4e&originHeight=286&originWidth=469&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=20685&status=done&style=none&taskId=u25459ff4-e299-49d1-9bc7-f913de031eb&title=&width=375.2" alt="image.png"><br>任务1：采用二层C&#x2F;S结构实现“个人通讯录系统”；<br>任务2：采用三层C&#x2F;S结构实现“个人通讯录系统”；<br>任务3：采用B&#x2F;S结构实现“个人通讯录系统”。</p><h2 id="二：实验结果："><a href="#二：实验结果：" class="headerlink" title="二：实验结果："></a>二：实验结果：</h2><h3 id="实验源代码："><a href="#实验源代码：" class="headerlink" title="实验源代码："></a>实验源代码：</h3><p><a href="https://github.com/Redbiga/SA3.git">https://github.com/Redbiga/SA3.git</a><br>开发环境是：JDK:1.8，tomcat:9.0.65</p><h3 id="数据库结构："><a href="#数据库结构：" class="headerlink" title="数据库结构："></a>数据库结构：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698395792024-cc50c10e-0515-4055-bbbf-e8adf6bc3693.png#averageHue=%232d2f33&clientId=uef4eb324-706d-4&from=paste&height=194&id=uad8b6b4c&originHeight=243&originWidth=1044&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=86604&status=done&style=none&taskId=u2ce16b00-4d93-40ac-9984-3c5f8b2fc8a&title=&width=835.2" alt="image.png"></p><h3 id="两层CS体系结构："><a href="#两层CS体系结构：" class="headerlink" title="两层CS体系结构："></a>两层CS体系结构：</h3><h4 id="逻辑结构："><a href="#逻辑结构：" class="headerlink" title="逻辑结构："></a>逻辑结构：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698394568833-1263846d-20c4-494e-9131-17846d10dd43.png#averageHue=%23ebcba0&clientId=ua3da19bb-144d-4&from=paste&height=79&id=u7bd416f0&originHeight=99&originWidth=681&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=16154&status=done&style=none&taskId=ucbba3221-ee1a-4a15-a7f6-6691a4715ec&title=&width=544.8" alt="image.png"></p><h4 id="源程序代码结构："><a href="#源程序代码结构：" class="headerlink" title="源程序代码结构："></a>源程序代码结构：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698395687317-b8376a9f-5212-4081-b3a1-3b2de8231884.png#averageHue=%2339455c&clientId=uef4eb324-706d-4&from=paste&height=204&id=u12029e66&originHeight=255&originWidth=869&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=135580&status=done&style=none&taskId=u9f1e979b-c5fc-4c06-98c9-6d4dcbb683d&title=&width=695.2" alt="image.png"></p><h4 id="运行界面截图："><a href="#运行界面截图：" class="headerlink" title="运行界面截图："></a>运行界面截图：</h4><p>查询：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698395872221-73d5649f-b1e5-4803-a72d-c12cb6691834.png#averageHue=%23f6f6f6&clientId=uef4eb324-706d-4&from=paste&height=358&id=u23b91da1&originHeight=447&originWidth=1216&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=26954&status=done&style=none&taskId=udfa04e85-a36b-4696-865b-ab911626494&title=&width=972.8" alt="image.png"></p><h3 id="三层体系结构："><a href="#三层体系结构：" class="headerlink" title="三层体系结构："></a>三层体系结构：</h3><h4 id="逻辑结构：-1"><a href="#逻辑结构：-1" class="headerlink" title="逻辑结构："></a>逻辑结构：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698396423699-15d9f800-804b-4fdf-8042-4724c8d7f64b.png#averageHue=%23ead5b1&clientId=uef4eb324-706d-4&from=paste&height=114&id=u0327e6df&originHeight=143&originWidth=822&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=23537&status=done&style=none&taskId=u4f58f4b4-f848-4052-96e2-6fc8323ec91&title=&width=657.6" alt="image.png"></p><h4 id="源程序代码结构：-1"><a href="#源程序代码结构：-1" class="headerlink" title="源程序代码结构："></a>源程序代码结构：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698396611575-ad53412e-fa9a-4ecc-9723-a3dc400bf9f3.png#averageHue=%233a4865&clientId=uef4eb324-706d-4&from=paste&height=130&id=u1e77be3c&originHeight=162&originWidth=759&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=71431&status=done&style=none&taskId=u6b0a5785-41ba-4b68-ab68-72c278b9a4e&title=&width=607.2" alt="image.png"></p><h4 id="运行界面截图：运行结果同两层体系结构，只不过业务逻辑层放在服务层处理了。"><a href="#运行界面截图：运行结果同两层体系结构，只不过业务逻辑层放在服务层处理了。" class="headerlink" title="运行界面截图：运行结果同两层体系结构，只不过业务逻辑层放在服务层处理了。"></a>运行界面截图：运行结果同两层体系结构，只不过业务逻辑层放在服务层处理了。</h4><h3 id="BS结构："><a href="#BS结构：" class="headerlink" title="BS结构："></a>BS结构：</h3><h4 id="逻辑架构："><a href="#逻辑架构：" class="headerlink" title="逻辑架构："></a>逻辑架构：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698396961933-0f10f519-0bb2-460e-b39e-6350a2366c34.png#averageHue=%23f8f8f7&clientId=uef4eb324-706d-4&from=paste&height=315&id=uaf2c5d5b&originHeight=394&originWidth=896&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=77311&status=done&style=none&taskId=u2ad79267-6702-4de2-b4ca-07e5b5c48eb&title=&width=716.8" alt="image.png"></p><h4 id="源代码程序结构："><a href="#源代码程序结构：" class="headerlink" title="源代码程序结构："></a>源代码程序结构：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698397073870-0b79da1a-d207-4e59-ac44-d3b3c43105fb.png#averageHue=%233a3f46&clientId=uef4eb324-706d-4&from=paste&height=326&id=u65b19eae&originHeight=407&originWidth=1046&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=196033&status=done&style=none&taskId=u6c63aab0-a3e6-4d9d-ac4c-eed0ccf38b6&title=&width=836.8" alt="image.png"></p><h3 id="方案比较："><a href="#方案比较：" class="headerlink" title="方案比较："></a>方案比较：</h3><p>三层C&#x2F;S结构相对于二层C&#x2F;S结构更加灵活，可以更好地实现应用功能的独立性，提高系统和软件的可维护性和可扩展性； 二层C&#x2F;S结构相对于三层C&#x2F;S结构来说，缺点在于其数据处理能力较弱；B&#x2F;S架构相对于C&#x2F;S架构来说，具有以下优点：①跨平台性好；②客户端零维护；③易于维护4. B&#x2F;S架构相对于C&#x2F;S架构来说，缺点在于其个性化能力低，响应速度较慢。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>C&#x2F;S结构是一种常见的软件体系结构，它将整个系统分为客户端和服务器端。二层C&#x2F;S结构是指只有一个服务器，且以局域网为中心的结构。三层C&#x2F;S结构是指分为两类服务器（数据库服务器和应用服务器）和用户的结构。三层C&#x2F;S结构相对于二层C&#x2F;S结构更加灵活，可以更好地实现应用功能的独立性，提高系统和软件的可维护性和可扩展性； 三层C&#x2F;S结构的优点包括：①允许合理地划分三层结构的功能，使之在逻辑上保持相对独立性，能提高系统和软件的可维护性和可扩展性；②允许更灵活有效地选用相应的平台和硬件系统，使之在处理负荷能力上与处理特性上分别适应于结构清晰的三层；③应用的各层可以并行开发，可以选择各自最适合的开发语言；④利用功能层有效地隔离开表示层与数据层，未授权的用户难以绕过功能层而利用数据库工具或黑客手段去非法地访问数据层1. 二层C&#x2F;S结构相对于三层C&#x2F;S结构来说，缺点在于其数据处理能力较弱，安全性难以控制。<br>B&#x2F;S架构是指浏览器-服务器架构。B&#x2F;S架构相对于C&#x2F;S架构来说，具有以下优点：①跨平台性好；②客户端零维护；③易于维护4. B&#x2F;S架构相对于C&#x2F;S架构来说，缺点在于其个性化能力低，响应速度较慢。<br>总体而言，二层C&#x2F;S架构、三层C&#x2F;S架构、B&#x2F;S架构各有优缺点。选择何种架构需要根据实际情况进行权衡。</p>]]></content>
    
    
    <categories>
      
      <category>课程作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程作业</tag>
      
      <tag>软件体系结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件体系结构实验4</title>
    <link href="/2024/01/23/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9A/"/>
    <url>/2024/01/23/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="一、-实验内容"><a href="#一、-实验内容" class="headerlink" title="一、 实验内容"></a>一、 实验内容</h2><p>任务1：Web Service服务器端程序开发<br>        开发个人所得税计算程序，并发布为Web服务。<br>Idea参考：<a href="https://blog.csdn.net/C1041067258/article/details/86543099">idea搭建WebService HelloWorld程序_helloworld wsdl-CSDN博客</a><br>任务2：Web Servic客户端程序开发<br>    网站<a href="http://www.webxml.com.cn/">http://www.webxml.com.cn/</a>提供了诸如天气预报、航班时刻表、中英文翻译等许多公共web service功能，请利用这些web service功能开发一小型应用软件（比如：XXX天气预报系统、XXX航班查询系统等），软件名称自定。</p><h2 id="任务1："><a href="#任务1：" class="headerlink" title="任务1："></a>任务1：</h2><h3 id="源代码地址："><a href="#源代码地址：" class="headerlink" title="源代码地址："></a>源代码地址：</h3><p><a href="https://github.com/Redbiga/SA4.git">https://github.com/Redbiga/SA4.git</a></p><h3 id="源代码结构："><a href="#源代码结构：" class="headerlink" title="源代码结构："></a>源代码结构：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698500885228-956579fd-588f-43a3-b330-92ce62b2f88d.png#averageHue=%23414a52&clientId=ue18db17b-c587-4&from=paste&height=370&id=u36f606c9&originHeight=463&originWidth=928&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=266515&status=done&style=none&taskId=u4f3023b8-b940-419b-80d0-9ca87880647&title=&width=742.4" alt="image.png"></p><h3 id="运行截图："><a href="#运行截图：" class="headerlink" title="运行截图："></a>运行截图：</h3><p>web配置启动成功：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698501049454-7f1324c6-c0cc-4294-b162-4f8c842d7c58.png#averageHue=%23fefdfd&clientId=ue18db17b-c587-4&from=paste&height=364&id=uadfe4268&originHeight=455&originWidth=669&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=21136&status=done&style=none&taskId=u4a08b796-d0da-47b2-8ea5-badb0bcfa93&title=&width=535.2" alt="image.png"><br>成功发布服务截图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698501069837-2a3bec51-36d6-4503-93c5-30f57f401b31.png#averageHue=%23f8f7f6&clientId=ue18db17b-c587-4&from=paste&height=367&id=ue14fbe12&originHeight=459&originWidth=697&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=40531&status=done&style=none&taskId=u1165bf43-2945-47e4-a5fa-06bf6ad5d60&title=&width=557.6" alt="image.png"><br>使用服务截图：<br>输入不合法：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698501470365-57e3455f-adcf-481d-bba9-f6407354709f.png#averageHue=%23242427&clientId=ue18db17b-c587-4&from=paste&height=262&id=u983455a5&originHeight=327&originWidth=1054&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=171258&status=done&style=none&taskId=ude2ff205-c575-4278-9602-99fe1a71ae1&title=&width=843.2" alt="image.png"><br>输入合法：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698502063675-f92161ab-a9c7-4596-bb67-9572dba2a0bd.png#averageHue=%23242325&clientId=ue18db17b-c587-4&from=paste&height=219&id=uc60d96e8&originHeight=274&originWidth=691&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=70952&status=done&style=none&taskId=u46fef8c5-a301-4196-9adc-b82db4789f0&title=&width=552.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698502085421-43b9f5f1-fe0e-4377-ae54-4c256412d8ea.png#averageHue=%23252426&clientId=ue18db17b-c587-4&from=paste&height=171&id=u1d5041bc&originHeight=214&originWidth=617&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=51011&status=done&style=none&taskId=u4c803333-1cb0-46f4-aa76-1dd966584e1&title=&width=493.6" alt="image.png"></p><h2 id="任务2：Web-Service客户端天气查询客户端"><a href="#任务2：Web-Service客户端天气查询客户端" class="headerlink" title="任务2：Web Service客户端天气查询客户端"></a>任务2：Web Service客户端天气查询客户端</h2><h4 id="源代码地址：-1"><a href="#源代码地址：-1" class="headerlink" title="源代码地址："></a>源代码地址：</h4><p><a href="https://github.com/Redbiga/SA4Weather-inquiry.git">https://github.com/Redbiga/SA4Weather-inquiry.git</a></p><h3 id="功能需求："><a href="#功能需求：" class="headerlink" title="功能需求："></a>功能需求：</h3><p>查询天气</p><h3 id="服务介绍："><a href="#服务介绍：" class="headerlink" title="服务介绍："></a>服务介绍：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698503030903-56b2d015-24c3-44a1-9504-b8ad1fd6eb7a.png#averageHue=%23f9f8f6&clientId=ue18db17b-c587-4&from=paste&height=668&id=u01d76181&originHeight=835&originWidth=1029&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=237053&status=done&style=none&taskId=u61b7b747-a335-423c-86e2-5e7a8abbe48&title=&width=823.2" alt="image.png"></p><h4 id="源程序代码结构："><a href="#源程序代码结构：" class="headerlink" title="源程序代码结构："></a>源程序代码结构：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698503175453-56d8e332-533e-4886-be81-f36fc0f9912a.png#averageHue=%2348545b&clientId=ue18db17b-c587-4&from=paste&height=379&id=ubc0ef041&originHeight=474&originWidth=880&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=256041&status=done&style=none&taskId=u1c12743e-2544-4cdc-8bfe-b223599d06c&title=&width=704" alt="image.png"></p><h4 id="运行截图：-1"><a href="#运行截图：-1" class="headerlink" title="运行截图："></a>运行截图：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698503376791-b7a26bd4-face-4793-b956-59f6e10a2561.png#averageHue=%23f7f6f5&clientId=ue18db17b-c587-4&from=paste&height=641&id=u83035804&originHeight=801&originWidth=1031&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=112962&status=done&style=none&taskId=u1722f247-b24d-422c-9bc3-23d7f446dca&title=&width=824.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698503386868-52979d14-6f28-4091-8cb7-08160f2eb280.png#averageHue=%23ebeae9&clientId=ue18db17b-c587-4&from=paste&height=607&id=u022c6f12&originHeight=759&originWidth=927&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=135928&status=done&style=none&taskId=u0496e468-2457-40e3-99c5-1e2d6befbe6&title=&width=741.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698503407460-b6e433ca-62ad-4cf6-8d18-fa87a997ffeb.png#averageHue=%23f6f5f4&clientId=ue18db17b-c587-4&from=paste&height=595&id=u09973d0d&originHeight=744&originWidth=1017&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=86708&status=done&style=none&taskId=u11116a06-7287-4352-add0-f865de0e500&title=&width=813.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698503429291-45190d30-2d80-43de-880c-2e65c3b19041.png#averageHue=%23f8f7f7&clientId=ue18db17b-c587-4&from=paste&height=615&id=u4178433e&originHeight=769&originWidth=994&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=64801&status=done&style=none&taskId=ua18e17d6-2cca-4c2d-87b1-fd4f5bbd10e&title=&width=795.2" alt="image.png"></p><h2 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h2><p>1.<a href="https://segmentfault.com/q/1010000042900375">Maven 错误：模块的 Maven 项目配置不可用</a><br>解决方法：右键单击 pom.xml，然后单击“添加为 Maven 项目”。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><a href="https://zhuanlan.zhihu.com/p/126507013">Web Service是一种可以接收从Internet或者Intranet上的其它系统中传递过来的请求，轻量级的独立的通讯技术</a><a href="https://zhuanlan.zhihu.com/p/126507013">。它是通过SOAP在Web上提供的软件服务，使用WSDL文件进行说明，并通过UDDI进行注册</a><a href="https://zhuanlan.zhihu.com/p/126507013">。WebService是一种跨编程语言和跨操作系统平台的远程调用技术</a><a href="https://zhuanlan.zhihu.com/p/126507013">1</a><a href="https://zhuanlan.zhihu.com/p/126507013">。WebService三要素是SOAP、WSDL、UDDI</a>。<br><a href="https://zhuanlan.zhihu.com/p/126507013">SOAP是WebService通过HTTP协议发送请求和接收结果时，发送的请求内容和结果内容都采用XML格式封装，并增加了一些特定的HTTP消息头，以说明HTTP消息的内容格式，这些特定的HTTP消息头和XML内容格式就是SOAP协议</a><a href="https://zhuanlan.zhihu.com/p/126507013">。SOAP提供了标准的RPC (远程调用技术)方法来调用Web Service</a>。<br><a href="https://zhuanlan.zhihu.com/p/126507013">WSDL是WebService客户端要调用一个WebService服务，首先要有知道这个服务的地址在哪，以及这个服务里有什么方法可以调用，所以，WebService务器端首先要通过一个WSDL文件来说明自己家里有啥服务可以对外调用，服务是什么（服务中有哪些方法，方法接受的参数是什么，返回值是什么），服务的网络地址用哪个url地址表示，服务通过什么方式来调用。WSDL ( Web Services Description Language)就是这样一个基于XML的语言，用于描述Web Service及其函数、参数和返回值</a>。<br><a href="https://zhuanlan.zhihu.com/p/126507013">UDDI是一个跨产业、跨平台的开放性架构，可以帮助 Web 服务提供商在互联网上发布 Web 服务的信息。UDDI 是一种目录服务，企业可以通过 UDDI 来注册和搜索 Web 服务。简单来说，UDDI 就是一个目录，只不过在这个目录中存放的是一些关于 Web 服务的信息而已</a>。</p>]]></content>
    
    
    <categories>
      
      <category>课程作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程作业</tag>
      
      <tag>软件体系结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spirngboot3整合swagger3</title>
    <link href="/2024/01/23/springboot3%E7%BB%93%E5%90%88swagger3%E5%B9%B6%E5%AF%BC%E5%85%A5%E5%88%B0APIfox_/"/>
    <url>/2024/01/23/springboot3%E7%BB%93%E5%90%88swagger3%E5%B9%B6%E5%AF%BC%E5%85%A5%E5%88%B0APIfox_/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><p>SpringBoot3.x使用Swagger - 掘金](<a href="https://juejin.cn/post/7299800370489966630#heading-22">https://juejin.cn/post/7299800370489966630#heading-22</a>)</p><h3 id="导入依赖："><a href="#导入依赖：" class="headerlink" title="导入依赖："></a>导入依赖：</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springdoc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springdoc-openapi-starter-webmvc-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h3><ul><li><p>开发环境</p></li><li><p>开发环境通常会开启Swagger文档，方便前端查阅文档</p><div class="code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">springdoc:</span>  api-docs:<span class="hljs-symbol">    enabled:</span> true <span class="hljs-meta"># 开启OpenApi接口</span><span class="hljs-symbol">    path:</span> <span class="hljs-keyword">/user-service/</span>v3/api-docs  <span class="hljs-meta"># 自定义文档接口路径，默认为 <span class="hljs-string">&quot;/v3/api-docs&quot;</span></span>  swagger-ui:<span class="hljs-symbol">    enabled:</span> true <span class="hljs-meta"># 开启swagger界面，依赖OpenApi，需要OpenApi同时开启</span><span class="hljs-symbol">    path:</span> <span class="hljs-keyword">/user-service/</span>swagger-ui/index.html <span class="hljs-meta"># 自定义UI路径，默认为<span class="hljs-string">&quot;/swagger-ui/index.html&quot;</span></span></code></pre></div></li><li><p>生产环境</p></li><li><p>切记生产环境要关闭文档</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">springdoc:</span>  <span class="hljs-attr">api-docs:</span>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 关闭OpenApi接口</span>  <span class="hljs-attr">swagger-ui:</span>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 关闭swagger界面</span></code></pre></div></li></ul><h3 id="向spring容器中注入swagger配置类："><a href="#向spring容器中注入swagger配置类：" class="headerlink" title="向spring容器中注入swagger配置类："></a>向spring容器中注入swagger配置类：</h3><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> OpenAPI swaggerOpenApi() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">OpenAPI</span>()                .info(<span class="hljs-keyword">new</span> <span class="hljs-type">Info</span>().title(<span class="hljs-string">&quot;XXX平台YYY微服务&quot;</span>)                        .description(<span class="hljs-string">&quot;描述平台多牛逼&quot;</span>)                        .version(<span class="hljs-string">&quot;v1.0.0&quot;</span>))                .externalDocs(<span class="hljs-keyword">new</span> <span class="hljs-type">ExternalDocumentation</span>()                        .description(<span class="hljs-string">&quot;设计文档&quot;</span>)                        .url(<span class="hljs-string">&quot;https://juejin.cn/user/254742430749736/posts&quot;</span>));    &#125;&#125;</code></pre></div><p>上面配置后暂时的界面为：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705912047289-0a11942a-5e70-46ef-9578-64ee5795c1ce.png#averageHue=%23f9f9f9&clientId=u7b97a79a-fc79-4&from=paste&height=215&id=u80bf11bd&originHeight=269&originWidth=760&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=18465&status=done&style=none&taskId=u92aff4d4-0083-4091-a0e5-3df05047719&title=&width=608" alt="image.png"></p><h3 id="常用注解："><a href="#常用注解：" class="headerlink" title="常用注解："></a>常用注解：</h3><table><thead><tr><th>注解</th><th>标注位置</th><th>作用</th></tr></thead><tbody><tr><td>@Tag</td><td>controller 类</td><td>标识 controller 作用</td></tr><tr><td>@Parameter</td><td>参数</td><td>标识参数作用</td></tr><tr><td>@Parameters</td><td>参数</td><td>参数多重说明</td></tr><tr><td>@Schema</td><td>model 层的 JavaBean</td><td>描述模型作用及每个属性</td></tr><tr><td>@Operation</td><td>方法</td><td>描述方法作用</td></tr><tr><td>@ApiResponse</td><td>方法</td><td>描述响应状态码等</td></tr></tbody></table><p>@Schema: Swagger文档的注解，用于说明类&#x2F;字段 </p><ul><li>title: 类&#x2F;字段说明</li><li>example: 示例，Swagger中会将这个字段作为示例</li><li>minLength&#x2F;maxLength: 最小&#x2F;最大长度，字段为String类型时生效(仅用于文档说明，不会抛出异常)</li><li>minimum&#x2F;maximum: 最小&#x2F;最大值，字段为数字时有效(仅用于文档说明，不会抛出异常)</li><li>@Tag: 控制器说明 </li><li>name: 名称</li><li>description: 描述说明</li><li>@PostMapping: 使用post方法，一般用于新增记录</li><li>@Operation: 请求说明 </li><li>summary: 说明，Swagger页面在方法后面，不会被折叠</li><li>descirption: 描述，会被折叠到方法说明中</li></ul><h3 id="导入APIfox"><a href="#导入APIfox" class="headerlink" title="导入APIfox:"></a>导入APIfox:</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705912284460-46e461c3-dbac-46c2-bfb0-5298fde545ff.png#averageHue=%23eac493&clientId=u7b97a79a-fc79-4&from=paste&height=727&id=ua527c034&originHeight=909&originWidth=1706&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=129559&status=done&style=none&taskId=ucd65ff91-9088-4d92-9113-81cb506f766&title=&width=1364.8" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>springboot3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatisPlus</title>
    <link href="/2024/01/23/mybatis-plus/"/>
    <url>/2024/01/23/mybatis-plus/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>采用的是黑马的mybatisPlus教程!<br><a href="https://b11et3un53m.feishu.cn/wiki/PsyawI04ei2FQykqfcPcmd7Dnsc">mybatis教程！</a><br>使用的springboot3和JDK17完成的！和黑马的有点区别！</p><h2 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h2><p>1.Hutool 是一个由 Java 编写的强大、完善且易用的 Java 工具类库，它封装了很多常用的 Java 方法，包括但不限于日期时间处理、字符串处理、文件操作、网络请求、加密解密、数据验证、反射工具等。通过引入 hutool-all 依赖，开发者可以方便地在项目中使用 Hutool 提供的各种便捷工具方法，以减少重复造轮子的工作，提高开发效率<br>2.@RequiredArgsConstructor 是 Lombok 库中的一个注解，它能够自动生成构造方法。当类中包含 final 或者非 null 的不可变字段时，Lombok 会为这些字段生成一个构造器，确保在创建对象实例时必须为这些字段提供值。<br>3.接口中可以有default修饰的方法！default修饰的方法为默认方法可以不用重写！</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserService</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductBalance</span><span class="hljs-params">(Long id, Integer money)</span> &#123;        <span class="hljs-comment">// 1.查询用户</span>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.getById(id);        <span class="hljs-comment">// 2.判断用户状态</span>        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span> || user.getStatus() == UserStatus.FROZEN) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;用户状态异常&quot;</span>);        &#125;        <span class="hljs-comment">// 3.判断用户余额</span>        <span class="hljs-keyword">if</span> (user.getBalance() &lt; money) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;用户余额不足&quot;</span>);        &#125;        <span class="hljs-comment">// 4.扣减余额</span>        baseMapper.deductMoneyById(id, money);    &#125;&#125;<span class="hljs-comment">// 上面是mybatisPlus中的代码片段；其中的IUserService接口继承了IService接口，IService中</span><span class="hljs-comment">// 有一个default修饰的getById方法，我们可以super.getById(id);调用该方法实现查询效果！</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.RequiredArgsConstructor;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String username; <span class="hljs-comment">// final 字段或 @NonNull 注解的字段</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> age;    <span class="hljs-comment">// Lombok 会自动生成以下构造方法：</span>    <span class="hljs-comment">// public User(String username, int age) &#123;</span>    <span class="hljs-comment">//     this.username = username;</span>    <span class="hljs-comment">//     this.age = age;</span>    <span class="hljs-comment">// &#125;</span>&#125;</code></pre></div><p>在这个例子中，由于 username 和 age 都是 final 字段，@RequiredArgsConstructor 会生成一个构造方法，要求在创建 User 类的新实例时必须传入这两个参数的值。这样可以确保这些关键字段在对象初始化时就具有有效的值，有助于防止 NullPointerException 等问题的发生。<br>3.@RequestParam 和@PathVariable的区别：<br>@RequestParam从请求中提取查询参数，也就是从url后面的？开始的数据：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span><span class="hljs-meta">@Operation(summary = &quot;根据id集合查询用户&quot;)</span><span class="hljs-keyword">public</span> List&lt;UserVO&gt; <span class="hljs-title function_">queryUserByIds</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;ids&quot;z List&lt;Long&gt; ids)</span></span><span class="hljs-params">// <span class="hljs-meta">@RequestParam(&quot;ids&quot;)</span>注解处理的是请求路径后面的参数：</span><span class="hljs-params">// http://localhost:<span class="hljs-number">8080</span>/users?ids=<span class="hljs-number">1</span>,<span class="hljs-number">2</span></span></code></pre></div><p>@PathVariable是以路径中某段为参数：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span>    <span class="hljs-meta">@Operation(summary = &quot;根据id查询用户&quot;)</span>    <span class="hljs-keyword">public</span> UserVO <span class="hljs-title function_">queryUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long userId)</span><span class="hljs-comment">// http://localhost:8080/users/1</span></code></pre></div><p>4.主键，外键，虚拟外键：<br><a href="https://www.cnblogs.com/dgp-zjz/p/16470132.html">https://www.cnblogs.com/dgp-zjz/p/16470132.html</a></p><div class="code-wrapper"><pre><code class="hljs">主键：用来保证数据完整性 外键：用来和其他表建立联系用的 索引：是提高查询排序的速度</code></pre></div><div class="code-wrapper"><pre><code class="hljs">主键：主键只能有一个外键：一个表可以有多个外键索引：一个表可以有多个唯一索引</code></pre></div><div class="code-wrapper"><pre><code class="hljs autohotkey">PRIMARY KEY设置主键 (&#x27;设置的主键字段&#x27;),KEY `自定义KEY名` (`定义外键字段名`),CONSTRAINT限制 `自定义KEY名` FOREIGN KEY外键 (`自定外键字段名`) REFERENCES 引用 `引用表` (`引用字段设为外键`))<span class="hljs-comment">;</span></code></pre></div><p>外键和主键建立了关系，那么外键所在的表中数据和主键表有关联关系就无法删除外键中的数据的！<br>虚拟外键表示的是表之间有逻辑上的关联关系！其实际上并没有实际的强制性约束！<br>5.mybatis-plus 开启与关闭 SQL 日志打印<br><a href="https://blog.csdn.net/jiangchao858/article/details/115676371">mybatis-plus 开启与关闭 SQL 日志打印_mybatis plus 开启sql记录-CSDN博客</a><br><a href="https://so.csdn.net/so/search?q=Mybatis&spm=1001.2101.3001.7020">Mybatis</a>-plus 需要通过下面的方式开启控制台 SQL 日志打印：</p><div class="code-wrapper"><pre><code class="hljs stylus">mybatis-plus:  configuration:    log-impl: org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.ibatis</span><span class="hljs-selector-class">.logging</span><span class="hljs-selector-class">.stdout</span><span class="hljs-selector-class">.StdOutImpl</span></code></pre></div><p>6.DTO(Data Transfer Object）是数据传输对象！一般用来映射传输过程中的数据的！<br>7.@Date  :</p><div class="code-wrapper"><pre><code class="hljs less">使用<span class="hljs-variable">@Data</span>注解可以简化Java类的编写，减少样板代码，并提高代码的可读性和可维护性。当在类级别上使用<span class="hljs-variable">@Data</span>注解时，Lombok会自动为该类的所有非静态字段生成以下方法：Getter方法：自动生成所有非静态字段的对应getter方法。Setter方法：自动生成所有非静态字段的对应setter方法。<span class="hljs-built_in">toString</span>()方法：生成一个包含所有字段的字符串表示，方便调试和日志输出。<span class="hljs-built_in">equals</span>()方法：自动生成基于所有字段的相等比较方法。<span class="hljs-built_in">hashCode</span>()方法：自动生成基于所有字段的散列码计算方法。</code></pre></div><h2 id="MyBatis-Plus的特性"><a href="#MyBatis-Plus的特性" class="headerlink" title="MyBatis Plus的特性:"></a>MyBatis Plus的特性:</h2><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作.</li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门:"></a>快速入门:</h2><h4 id="引入依赖："><a href="#引入依赖：" class="headerlink" title="引入依赖："></a>引入依赖：</h4><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-spring-boot3-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--由于springboot3和mybatisplus兼容性的问题这里引入的依赖最好是这样的！  --&gt;</span></code></pre></div><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>mapper接口要继承BaseMapper<User> 这里的User对应查询结果的类型！同时要注意在启动类上添加组件@Mapper注解 不然spring扫描不到Mapper接口类就无法注入到容器中了！当然也可以在Mapper接口上添加@Mapper 注解  ；</p><div class="code-wrapper"><pre><code class="hljs xml">MybatisPlus就是根据PO实体的信息来推断出表的信息，从而生成SQL的。默认情况下：- MybatisPlus会把PO实体的类名驼峰转下划线作为表名- MybatisPlus会把PO实体的所有变量名驼峰转下划线作为表的字段名，并根据变量类型推断字段类型- MybatisPlus会把名为id的字段作为主键</code></pre></div><h4 id="常见注解："><a href="#常见注解：" class="headerlink" title="常见注解："></a>常见注解：</h4><h5 id="TableName："><a href="#TableName：" class="headerlink" title="@TableName："></a>@TableName：</h5><ul><li>描述：表名注解，标识实体类对应的表</li><li>使用位置：实体类</li></ul><p>TableName注解除了指定表名以外，还可以指定很多其它属性：</p><table><thead><tr><th><strong>属性</strong></th><th><strong>类型</strong></th><th><strong>必须指定</strong></th><th><strong>默认值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>value</td><td>String</td><td>否</td><td>“”</td><td>表名</td></tr><tr><td>schema</td><td>String</td><td>否</td><td>“”</td><td>schema</td></tr><tr><td>keepGlobalPrefix</td><td>boolean</td><td>否</td><td>false</td><td>是否保持使用全局的 tablePrefix 的值（当全局 tablePrefix 生效时）</td></tr><tr><td>resultMap</td><td>String</td><td>否</td><td>“”</td><td>xml 中 resultMap 的 id（用于满足特定类型的实体类对象绑定）</td></tr><tr><td>autoResultMap</td><td>boolean</td><td>否</td><td>false</td><td>是否自动构建 resultMap 并使用（如果设置 resultMap 则不会进行 resultMap 的自动构建与注入）</td></tr><tr><td>excludeProperty</td><td>String[]</td><td>否</td><td>{}</td><td>需要排除的属性名 @since 3.3.1</td></tr></tbody></table><h5 id="TableId："><a href="#TableId：" class="headerlink" title="@TableId："></a>@TableId：</h5><ul><li>描述：主键注解，标识实体类中的主键字段</li><li>使用位置：实体类的主键字段</li></ul><p>TableId注解支持两个属性：</p><table><thead><tr><th><strong>属性</strong></th><th><strong>类型</strong></th><th><strong>必须指定</strong></th><th><strong>默认值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>value</td><td>String</td><td>否</td><td>“”</td><td>表名</td></tr><tr><td>type</td><td>Enum</td><td>否</td><td>IdType.NONE</td><td>指定主键类型</td></tr></tbody></table><p>IdType支持的类型有：</p><table><thead><tr><th><strong>值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>AUTO</td><td>数据库 ID 自增</td></tr><tr><td>NONE</td><td>无状态，该类型为未设置主键类型（注解里等于跟随全局，全局里约等于 INPUT）</td></tr><tr><td>INPUT</td><td>insert 前自行 set 主键值</td></tr><tr><td>ASSIGN_ID</td><td>分配 ID(主键类型为 Number(Long 和 Integer)或 String)(since 3.3.0),使用接口IdentifierGenerator的方法nextId(默认实现类为DefaultIdentifierGenerator雪花算法)</td></tr><tr><td>ASSIGN_UUID</td><td>分配 UUID,主键类型为 String(since 3.3.0),使用接口IdentifierGenerator的方法nextUUID(默认 default 方法)</td></tr><tr><td><del>ID_WORKER</del></td><td>分布式全局唯一 ID 长整型类型(please use ASSIGN_ID)</td></tr><tr><td><del>UUID</del></td><td>32 位 UUID 字符串(please use ASSIGN_UUID)</td></tr><tr><td><del>ID_WORKER_STR</del></td><td>分布式全局唯一 ID 字符串类型(please use ASSIGN_ID)</td></tr></tbody></table><p>这里比较常见的有三种：</p><ul><li>AUTO：利用数据库的id自增长</li><li>INPUT：手动生成id</li><li>ASSIGN_ID：雪花算法生成Long类型的全局唯一id，这是默认的ID策略</li></ul><h5 id="TableField："><a href="#TableField：" class="headerlink" title="@TableField："></a>@TableField：</h5><p>描述：普通字段注解<br>一般情况下我们并不需要给字段添加@TableField注解，一些特殊情况除外：</p><ul><li>成员变量名与数据库字段名不一致</li><li>成员变量是以isXXX命名，按照JavaBean的规范，MybatisPlus识别字段时会把is去除，这就导致与数据库不符。</li><li>成员变量名与数据库一致，但是与数据库的关键字冲突。使用@TableField注解给字段名添加转义字符：&#96;&#96;</li></ul><h4 id="常见配置："><a href="#常见配置：" class="headerlink" title="常见配置："></a>常见配置：</h4><p>大多数的配置都有默认值，因此我们都无需配置。但还有一些是没有默认值的，例如:</p><ul><li>实体类的别名扫描包</li><li>全局id类型<div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.itheima.mp.domain.po</span>  <span class="hljs-attr">global-config:</span>    <span class="hljs-attr">db-config:</span>      <span class="hljs-attr">id-type:</span> <span class="hljs-string">auto</span> <span class="hljs-comment"># 全局id类型为自增长</span></code></pre></div>需要注意的是，MyBatisPlus也支持手写SQL的，而mapper文件的读取地址可以自己配置：<div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">mybatis-plus:</span>  mapper-locations: <span class="hljs-string">&quot;classpath*:/mapper/**/*.xml&quot;</span> <span class="hljs-comment"># Mapper.xml文件地址，当前这个是默认值。</span></code></pre></div>可以看到默认值是classpath*:&#x2F;mapper&#x2F;**&#x2F;*.xml，也就是说我们只要把mapper.xml文件放置这个目录下就一定会被加载。<br>xml书写样式：<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.itheima.mp.mapper.UserMapper&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span>        SELECT * FROM user WHERE id = #&#123;id&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div>上面的resuletType需要在spring的mybatis-plus配置中配置如下配置才能使用：<div class="code-wrapper"><pre><code class="hljs xml">mybatis-plus:  mapper-locations: &quot;classpath*:/mapper/**/*.xml&quot; # Mapper.xml文件地址，当前这个是默认值。  type-aliases-package: com.example.mp.po<span class="hljs-comment">&lt;!-- mapper-locations该配置是让resultType可以直接使用类名，而不是全类名</span><span class="hljs-comment">mapper-locations是为了定位mapper.xml文件的位置</span><span class="hljs-comment">--&gt;</span></code></pre></div></li></ul><h2 id="核心功能："><a href="#核心功能：" class="headerlink" title="核心功能："></a>核心功能：</h2><h4 id="QueryWrapper："><a href="#QueryWrapper：" class="headerlink" title="QueryWrapper："></a>QueryWrapper：</h4><p>无论是修改、删除、查询，都可以使用QueryWrapper来构建查询条件。接下来看一些例子： <strong>查询</strong>：查询出名字中带o的，存款大于等于1000元的人。代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">void</span> <span class="hljs-title function_">testQueryWrapper</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">// 1.构建查询条件 where name like &quot;%o%&quot; AND balance &gt;= 1000</span>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;()    .select(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-string">&quot;balance&quot;</span>)    .like(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>)    .ge(<span class="hljs-string">&quot;balance&quot;</span>, <span class="hljs-number">1000</span>);    <span class="hljs-comment">// 2.查询数据</span>    List&lt;User&gt; users = userMapper.selectList(wrapper);    users.forEach(System.out::println);&#125;<span class="hljs-comment">// Wrapper是包装的意思；上面使用的select表示是一个select语句的包装！上面采用的是链式编程；</span><span class="hljs-comment">// .like对应sql语句中的like关键字！ge对应的是大于和等于！</span></code></pre></div><p><strong>更新</strong>：更新用户名为jack的用户的余额为2000，代码如下：：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdateByQueryWrapper</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">// 1.构建查询条件 where name = &quot;Jack&quot;</span>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;().eq(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>);    <span class="hljs-comment">// 2.更新数据，user中非null字段都会作为set语句</span>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();    user.setBalance(<span class="hljs-number">2000</span>);    userMapper.update(user, wrapper);&#125;</code></pre></div><h4 id="UpdateWrapper："><a href="#UpdateWrapper：" class="headerlink" title="UpdateWrapper："></a>UpdateWrapper：</h4><p>基于BaseMapper中的update方法更新时只能直接赋值，对于一些复杂的需求就难以实现。 例如：更新id为1,2,4的用户的余额，扣200，对应的SQL应该是：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">UPDATE</span> user SET balance = balance - <span class="hljs-number">200</span> WHERE id in (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)</code></pre></div><p>SET的赋值结果是基于字段现有值的，这个时候就要利用UpdateWrapper中的setSql功能了：</p><div class="code-wrapper"><pre><code class="hljs pgsql">@Test<span class="hljs-type">void</span> testUpdateWrapper() &#123;    List&lt;Long&gt; ids = List.<span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>L, <span class="hljs-number">2</span>L, <span class="hljs-number">4</span>L);    // <span class="hljs-number">1.</span>生成<span class="hljs-keyword">SQL</span>    UpdateWrapper&lt;<span class="hljs-keyword">User</span>&gt; <span class="hljs-keyword">wrapper</span> = <span class="hljs-built_in">new</span> UpdateWrapper&lt;<span class="hljs-keyword">User</span>&gt;()            .setSql(&quot;balance = balance - 200&quot;) // <span class="hljs-keyword">SET</span> balance = balance - <span class="hljs-number">200</span>            .<span class="hljs-keyword">in</span>(&quot;id&quot;, ids); // <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)        // <span class="hljs-number">2.</span>更新，注意第一个参数可以给<span class="hljs-keyword">null</span>，也就是不填更新字段和数据，    // 而是基于UpdateWrapper中的setSQL来更新    userMapper.<span class="hljs-keyword">update</span>(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">wrapper</span>);&#125;</code></pre></div><h4 id="LambdaQueryWrapper："><a href="#LambdaQueryWrapper：" class="headerlink" title="LambdaQueryWrapper："></a>LambdaQueryWrapper：</h4><p>无论是QueryWrapper还是UpdateWrapper在构造条件的时候都需要写死字段名称，会出现字符串魔法值。这在编程规范中显然是不推荐的。 那怎么样才能不写字段名，又能知道字段名呢？<br>其中一种办法是基于变量的gettter方法结合反射技术。因此我们只要将条件对应的字段的getter方法传递给MybatisPlus，它就能计算出对应的变量名了。而传递方法可以使用JDK8中的方法引用和Lambda表达式。 因此MybatisPlus又提供了一套基于Lambda的Wrapper，包含两个：</p><ul><li>LambdaQueryWrapper</li><li>LambdaUpdateWrapper</li></ul><p>分别对应QueryWrapper和UpdateWrapper<br>其使用方式如下：</p><div class="code-wrapper"><pre><code class="hljs pgsql">@Test<span class="hljs-type">void</span> testLambdaQueryWrapper() &#123;    // <span class="hljs-number">1.</span>构建条件 <span class="hljs-keyword">WHERE</span> username <span class="hljs-keyword">LIKE</span> &quot;%o%&quot; <span class="hljs-keyword">AND</span> balance &gt;= <span class="hljs-number">1000</span>    QueryWrapper&lt;<span class="hljs-keyword">User</span>&gt; <span class="hljs-keyword">wrapper</span> = <span class="hljs-built_in">new</span> QueryWrapper&lt;&gt;();    <span class="hljs-keyword">wrapper</span>.lambda()            .<span class="hljs-keyword">select</span>(<span class="hljs-keyword">User</span>::getId, <span class="hljs-keyword">User</span>::getUsername, <span class="hljs-keyword">User</span>::getInfo, <span class="hljs-keyword">User</span>::getBalance)            .<span class="hljs-keyword">like</span>(<span class="hljs-keyword">User</span>::getUsername, &quot;o&quot;)            .ge(<span class="hljs-keyword">User</span>::getBalance, <span class="hljs-number">1000</span>);    // <span class="hljs-number">2.</span>查询    List&lt;<span class="hljs-keyword">User</span>&gt; users = userMapper.selectList(<span class="hljs-keyword">wrapper</span>);    users.<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>::println);&#125;</code></pre></div><h2 id="自定义SQL："><a href="#自定义SQL：" class="headerlink" title="自定义SQL："></a>自定义SQL：</h2><h4 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h4><p>以当前案例来说，我们可以这样写：</p><div class="code-wrapper"><pre><code class="hljs pgsql">@Test<span class="hljs-type">void</span> testCustomWrapper() &#123;    // <span class="hljs-number">1.</span>准备自定义查询条件    List&lt;Long&gt; ids = List.<span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>L, <span class="hljs-number">2</span>L, <span class="hljs-number">4</span>L);    QueryWrapper&lt;<span class="hljs-keyword">User</span>&gt; <span class="hljs-keyword">wrapper</span> = <span class="hljs-built_in">new</span> QueryWrapper&lt;<span class="hljs-keyword">User</span>&gt;().<span class="hljs-keyword">in</span>(&quot;id&quot;, ids);    // <span class="hljs-number">2.</span>调用mapper的自定义方法，直接传递<span class="hljs-keyword">Wrapper</span>    userMapper.deductBalanceByIds(<span class="hljs-number">200</span>, <span class="hljs-keyword">wrapper</span>);&#125;</code></pre></div><p>然后在UserMapper中自定义SQL：</p><div class="code-wrapper"><pre><code class="hljs pgsql">package com.itheima.mp.mapper;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;<span class="hljs-keyword">import</span> com.itheima.mp.<span class="hljs-keyword">domain</span>.po.<span class="hljs-keyword">User</span>;<span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Param;<span class="hljs-keyword">import</span> org.apache.ibatis.annotations.<span class="hljs-keyword">Update</span>;<span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Param;<span class="hljs-built_in">public</span> interface UserMapper extends BaseMapper&lt;<span class="hljs-keyword">User</span>&gt; &#123;    @<span class="hljs-keyword">Select</span>(&quot;UPDATE user SET balance = balance - #&#123;money&#125; $&#123;ew.customSqlSegment&#125;&quot;)    <span class="hljs-type">void</span> deductBalanceByIds(@Param(&quot;money&quot;) <span class="hljs-type">int</span> <span class="hljs-type">money</span>, @Param(&quot;ew&quot;) QueryWrapper&lt;<span class="hljs-keyword">User</span>&gt; <span class="hljs-keyword">wrapper</span>);&#125;</code></pre></div><h4 id="多表关联："><a href="#多表关联：" class="headerlink" title="多表关联："></a>多表关联：</h4><p>理论上来讲MyBatisPlus是不支持多表查询的，不过我们可以利用Wrapper中自定义条件结合自定义SQL来实现多表查询的效果。 例如，我们要查询出所有收货地址在北京的并且用户id在1、2、4之中的用户 要是自己基于mybatis实现SQL，大概是这样的：</p><div class="code-wrapper"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">select</span> id=&quot;queryUserByIdAndAddr&quot; resultType=&quot;com.itheima.mp.domain.po.User&quot;&gt;      <span class="hljs-keyword">SELECT</span> *      <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> u      <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> address a <span class="hljs-keyword">ON</span> u.id = a.user_id      <span class="hljs-keyword">WHERE</span> u.id      &lt;<span class="hljs-keyword">foreach</span> collection=&quot;ids&quot; separator=&quot;,&quot; item=&quot;id&quot; <span class="hljs-keyword">open</span>=&quot;IN (&quot; <span class="hljs-keyword">close</span>=&quot;)&quot;&gt;          #&#123;id&#125;      &lt;/<span class="hljs-keyword">foreach</span>&gt;      <span class="hljs-keyword">AND</span> a.city = #&#123;city&#125;  &lt;/<span class="hljs-keyword">select</span>&gt;</code></pre></div><p>可以看出其中最复杂的就是WHERE条件的编写，如果业务复杂一些，这里的SQL会更变态。<br>但是基于自定义SQL结合Wrapper的玩法，我们就可以利用Wrapper来构建查询条件，然后手写SELECT及FROM部分，实现多表查询。<br>查询条件这样来构建：</p><div class="code-wrapper"><pre><code class="hljs pgsql">@Test<span class="hljs-type">void</span> testCustomJoinWrapper() &#123;    // <span class="hljs-number">1.</span>准备自定义查询条件    QueryWrapper&lt;<span class="hljs-keyword">User</span>&gt; <span class="hljs-keyword">wrapper</span> = <span class="hljs-built_in">new</span> QueryWrapper&lt;<span class="hljs-keyword">User</span>&gt;()            .<span class="hljs-keyword">in</span>(&quot;u.id&quot;, List.<span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>L, <span class="hljs-number">2</span>L, <span class="hljs-number">4</span>L))            .eq(&quot;a.city&quot;, &quot;北京&quot;);    // <span class="hljs-number">2.</span>调用mapper的自定义方法    List&lt;<span class="hljs-keyword">User</span>&gt; users = userMapper.queryUserByWrapper(<span class="hljs-keyword">wrapper</span>);    users.<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>::println);&#125;</code></pre></div><p>然后在UserMapper中自定义方法：</p><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@Select</span>(<span class="hljs-string">&quot;SELECT u.* FROM user u INNER JOIN address a ON u.id = a.user_id $&#123;ew.customSqlSegment&#125;&quot;</span>)List&lt;User&gt; <span class="hljs-built_in">queryUserByWrapper</span>(<span class="hljs-variable">@Param</span>(<span class="hljs-string">&quot;ew&quot;</span>)QueryWrapper&lt;User&gt; wrapper);</code></pre></div><p>当然，也可以在UserMapper.xml中写SQL：</p><div class="code-wrapper"><pre><code class="hljs n1ql">&lt;<span class="hljs-keyword">select</span> id=<span class="hljs-string">&quot;queryUserByIdAndAddr&quot;</span> resultType=<span class="hljs-string">&quot;com.itheima.mp.domain.po.User&quot;</span>&gt;    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> u <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> address a <span class="hljs-keyword">ON</span> u.id = a.user_id $&#123;ew.customSqlSegment&#125;&lt;/<span class="hljs-keyword">select</span>&gt;</code></pre></div><h2 id="Service接口："><a href="#Service接口：" class="headerlink" title="Service接口："></a>Service接口：</h2><p>MybatisPlus不仅提供了BaseMapper，还提供了通用的Service接口及默认实现，封装了一些常用的service模板方法。 通用接口为IService，默认实现为ServiceImpl，其中封装的方法可以分为以下几类：</p><ul><li>save：新增</li><li>remove：删除</li><li>update：更新</li><li>get：查询单个结果</li><li>list：查询集合结果</li><li>count：计数</li><li>page：分页查询</li></ul><h4 id="CRUD："><a href="#CRUD：" class="headerlink" title="CRUD："></a>CRUD：</h4><p>我们先俩看下基本的CRUD接口。 <strong>新增</strong>：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705901761781-cd483668-f2f2-4e2e-9107-9b3c1e65c8f3.png#averageHue=%23f9f8f5&clientId=ue5cba3c3-0ee1-4&from=paste&id=u3498b97f&originHeight=291&originWidth=890&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u859b1b5c-be7d-4bf6-88b6-e2c4b7549cb&title="></p><ul><li>save是新增单个元素</li><li>saveBatch是批量新增</li><li>saveOrUpdate是根据id判断，如果数据存在就更新，不存在则新增</li><li>saveOrUpdateBatch是批量的新增或修改</li></ul><p><strong>删除：</strong><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705901761807-7b419342-257a-443d-a087-4178259ba765.png#averageHue=%23f9f7f2&clientId=ue5cba3c3-0ee1-4&from=paste&id=u67a1f4d5&originHeight=409&originWidth=913&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u09c5315b-cd84-42e9-a3e7-c3f07669fa8&title="></p><ul><li>removeById：根据id删除</li><li>removeByIds：根据id批量删除</li><li>removeByMap：根据Map中的键值对为条件删除</li><li>remove(Wrapper<T>)：根据Wrapper条件删除</li><li><del>removeBatchByIds</del>：暂不支持</li></ul><p><strong>修改：</strong><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705901761834-e548c4a8-f6e7-4111-a4ad-23fb41d62502.png#averageHue=%23faf6f2&clientId=ue5cba3c3-0ee1-4&from=paste&id=ua1459dfb&originHeight=444&originWidth=931&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u8a5e5127-d5df-434b-94c5-a9fdf3fe20d&title="></p><ul><li>updateById：根据id修改</li><li>update(Wrapper<T>)：根据UpdateWrapper修改，Wrapper中包含set和where部分</li><li>update(T，Wrapper<T>)：按照T内的数据修改与Wrapper匹配到的数据</li><li>updateBatchById：根据id批量修改</li></ul><p><strong>Get：</strong><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705901761918-9986dfba-97fa-4d47-9cfa-f116723710ec.png#averageHue=%23f9f3f1&clientId=ue5cba3c3-0ee1-4&from=paste&id=ua23839c7&originHeight=287&originWidth=897&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ue708b657-e910-4553-bffa-bd944058cd2&title="></p><ul><li>getById：根据id查询1条数据</li><li>getOne(Wrapper<T>)：根据Wrapper查询1条数据</li><li>getBaseMapper：获取Service内的BaseMapper实现，某些时候需要直接调用Mapper内的自定义SQL时可以用这个方法获取到Mapper</li></ul><p><strong>List：</strong><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705901761862-198d733d-3b92-46d6-8467-649a229dd802.png#averageHue=%23f9f5f2&clientId=ue5cba3c3-0ee1-4&from=paste&id=u27975eb9&originHeight=375&originWidth=919&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ud8364a94-27a9-47ab-a8d6-a24c82c60e9&title="></p><ul><li>listByIds：根据id批量查询</li><li>list(Wrapper<T>)：根据Wrapper条件查询多条数据</li><li>list()：查询所有</li></ul><p><strong>Count</strong>：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705901762451-7759b2ce-c219-4a44-bdcf-363e1d09a656.png#averageHue=%23dbc789&clientId=ue5cba3c3-0ee1-4&from=paste&id=uee4df41f&originHeight=134&originWidth=775&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ud373cd64-264c-4314-a3d2-6c85025dc95&title="></p><ul><li>count()：统计所有数量</li><li>count(Wrapper<T>)：统计符合Wrapper条件的数据数量</li></ul><p><strong>getBaseMapper</strong>： 当我们在service中要调用Mapper中自定义SQL时，就必须获取service对应的Mapper，就可以通过这个方法：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705901762655-114bb9d6-350b-492a-9c6c-b68f5224a2d2.png#averageHue=%23f4f4f1&clientId=ue5cba3c3-0ee1-4&from=paste&id=u91305962&originHeight=124&originWidth=529&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uce5abd52-11e2-436a-a76f-fae5d7bf134&title="></p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h3><p>由于Service中经常需要定义与业务有关的自定义方法，因此我们不能直接使用IService，而是自定义Service接口，然后继承IService以拓展方法。同时，让自定义的Service实现类继承ServiceImpl，这样就不用自己实现IService中的接口了。<br>首先，定义IUserService，继承IService：</p><div class="code-wrapper"><pre><code class="hljs angelscript">package com.itheima.mp.service;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;<span class="hljs-keyword">import</span> com.itheima.mp.domain.po.User;<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">IUserService</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">IService</span>&lt;<span class="hljs-symbol">User</span>&gt; &#123;    <span class="hljs-comment">// 拓展自定义方法</span>&#125;</code></pre></div><p>然后，编写UserServiceImpl类，继承ServiceImpl，实现UserService：</p><div class="code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.itheima.mp.service.impl;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.<span class="hljs-type">ServiceImpl</span>;<span class="hljs-keyword">import</span> com.itheima.mp.domain.po.<span class="hljs-type">User</span>;<span class="hljs-keyword">import</span> com.itheima.mp.domain.po.service.<span class="hljs-type">IUserService</span>;<span class="hljs-keyword">import</span> com.itheima.mp.mapper.<span class="hljs-type">UserMapper</span>;<span class="hljs-keyword">import</span> org.springframework.stereotype.<span class="hljs-type">Service</span>;<span class="hljs-meta">@Service</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceImpl&lt;UserMapper</span>, <span class="hljs-title">User&gt;</span> <span class="hljs-title">implements</span> <span class="hljs-title">IUserService</span></span>&#123;&#125;</code></pre></div><h3 id="项目结构如下："><a href="#项目结构如下：" class="headerlink" title="项目结构如下："></a>项目结构如下：</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705918523933-50ecb3ce-9a82-4e92-8af8-516cbcc11a97.png#averageHue=%23f9fbf8&clientId=uc58b97f9-a395-4&from=paste&id=u6a26501b&originHeight=558&originWidth=875&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u8ba7e3f5-2848-400a-9ab3-6115c4fc29b&title="><br>接下来，我们快速实现下面4个接口：</p><table><thead><tr><th><strong>编号</strong></th><th><strong>接口</strong></th><th><strong>请求方式</strong></th><th><strong>请求路径</strong></th><th><strong>请求参数</strong></th><th><strong>返回值</strong></th></tr></thead><tbody><tr><td>1</td><td>新增用户</td><td>POST</td><td>&#x2F;users</td><td>用户表单实体</td><td>无</td></tr><tr><td>2</td><td>删除用户</td><td>DELETE</td><td>&#x2F;users&#x2F;{id}</td><td>用户id</td><td>无</td></tr><tr><td>3</td><td>根据id查询用户</td><td>GET</td><td>&#x2F;users&#x2F;{id}</td><td>用户id</td><td>用户VO</td></tr><tr><td>4</td><td>根据id批量查询</td><td>GET</td><td>&#x2F;users</td><td>用户id集合</td><td>用户VO集合</td></tr></tbody></table><p>首先，我们在项目中引入几个依赖：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--swagger--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.xiaoymin<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>knife4j-openapi2-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--web--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>然后需要配置swagger信息：</p><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">knife4j</span><span class="hljs-punctuation">:</span>  <span class="hljs-attribute">enable</span><span class="hljs-punctuation">:</span> <span class="hljs-string">true</span>  <span class="hljs-attribute">openapi</span><span class="hljs-punctuation">:</span>    <span class="hljs-attribute">title</span><span class="hljs-punctuation">:</span> <span class="hljs-string">用户管理接口文档</span>    <span class="hljs-attribute">description</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;用户管理接口文档&quot;</span>    <span class="hljs-attribute">email</span><span class="hljs-punctuation">:</span> <span class="hljs-string">zhanghuyi@itcast.cn</span>    <span class="hljs-attribute">concat</span><span class="hljs-punctuation">:</span> <span class="hljs-string">虎哥</span>    <span class="hljs-attribute">url</span><span class="hljs-punctuation">:</span> <span class="hljs-string">https://www.itcast.cn</span>    <span class="hljs-attribute">version</span><span class="hljs-punctuation">:</span> <span class="hljs-string">v1.0.0</span>    <span class="hljs-attribute">group</span><span class="hljs-punctuation">:</span>      <span class="hljs-attribute">default</span><span class="hljs-punctuation">:</span>        <span class="hljs-attribute">group-name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">default</span>        <span class="hljs-attribute">api-rule</span><span class="hljs-punctuation">:</span> <span class="hljs-string">package</span>        <span class="hljs-attribute">api-rule-resources</span><span class="hljs-punctuation">:</span>          <span class="hljs-bullet">-</span> <span class="hljs-string">com.itheima.mp.controller</span></code></pre></div><p>然后，接口需要两个实体：</p><ul><li>UserFormDTO：代表新增时的用户表单</li><li>UserVO：代表查询的返回结果</li></ul><p>首先是UserFormDTO：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.itheima.mp.domain.dto;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.<span class="hljs-keyword">annotation</span>.TableField;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.handlers.JacksonTypeHandler;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModel;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModelProperty;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-meta">@ApiModel(description = <span class="hljs-string">&quot;用户表单实体&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserFormDTO</span> &#123;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;id&quot;</span>)</span>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> id;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;用户名&quot;</span>)</span>    <span class="hljs-keyword">private</span> String username;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;密码&quot;</span>)</span>    <span class="hljs-keyword">private</span> String password;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;注册手机号&quot;</span>)</span>    <span class="hljs-keyword">private</span> String phone;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;详细信息，JSON风格&quot;</span>)</span>    <span class="hljs-keyword">private</span> String info;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;账户余额&quot;</span>)</span>    <span class="hljs-keyword">private</span> Integer balance;&#125;</code></pre></div><p>然后是UserVO：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.itheima.mp.domain.vo;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModel;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModelProperty;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-meta">@ApiModel(description = <span class="hljs-string">&quot;用户VO实体&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserVO</span> &#123;        <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;用户id&quot;</span>)</span>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> id;        <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;用户名&quot;</span>)</span>    <span class="hljs-keyword">private</span> String username;        <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;详细信息&quot;</span>)</span>    <span class="hljs-keyword">private</span> String info;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;使用状态（1正常 2冻结）&quot;</span>)</span>    <span class="hljs-keyword">private</span> Integer status;        <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;账户余额&quot;</span>)</span>    <span class="hljs-keyword">private</span> Integer balance;&#125;</code></pre></div><p>最后，按照Restful风格编写Controller接口方法：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.itheima.mp.controller;<span class="hljs-keyword">import</span> cn.hutool.core.bean.BeanUtil;<span class="hljs-keyword">import</span> com.itheima.mp.domain.dto.UserFormDTO;<span class="hljs-keyword">import</span> com.itheima.mp.domain.po.User;<span class="hljs-keyword">import</span> com.itheima.mp.domain.vo.UserVO;<span class="hljs-keyword">import</span> com.itheima.mp.service.IUserService;<span class="hljs-keyword">import</span> io.swagger.annotations.Api;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiOperation;<span class="hljs-keyword">import</span> lombok.RequiredArgsConstructor;<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.*;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-meta">@Api(tags = <span class="hljs-string">&quot;用户管理接口&quot;</span>)</span><span class="hljs-meta">@RequiredArgsConstructor</span><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping(<span class="hljs-string">&quot;users&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IUserService userService;    <span class="hljs-meta">@PostMapping</span>    <span class="hljs-meta">@ApiOperation(<span class="hljs-string">&quot;新增用户&quot;</span>)</span>    <span class="hljs-keyword">public</span> void saveUser(<span class="hljs-meta">@RequestBody</span> UserFormDTO userFormDTO)&#123;        <span class="hljs-comment">// 1.转换DTO为PO</span>        User user = BeanUtil.copyProperties(userFormDTO, User.<span class="hljs-keyword">class</span>);        <span class="hljs-comment">// 2.新增</span>        userService.save(user);    &#125;    <span class="hljs-meta">@DeleteMapping(<span class="hljs-string">&quot;/&#123;id&#125;&quot;</span>)</span>    <span class="hljs-meta">@ApiOperation(<span class="hljs-string">&quot;删除用户&quot;</span>)</span>    <span class="hljs-keyword">public</span> void removeUserById(<span class="hljs-meta">@PathVariable(<span class="hljs-string">&quot;id&quot;</span>)</span> <span class="hljs-built_in">Long</span> userId)&#123;        userService.removeById(userId);    &#125;    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/&#123;id&#125;&quot;</span>)</span>    <span class="hljs-meta">@ApiOperation(<span class="hljs-string">&quot;根据id查询用户&quot;</span>)</span>    <span class="hljs-keyword">public</span> UserVO queryUserById(<span class="hljs-meta">@PathVariable(<span class="hljs-string">&quot;id&quot;</span>)</span> <span class="hljs-built_in">Long</span> userId)&#123;        <span class="hljs-comment">// 1.查询用户</span>        User user = userService.getById(userId);        <span class="hljs-comment">// 2.处理vo</span>        <span class="hljs-keyword">return</span> BeanUtil.copyProperties(user, UserVO.<span class="hljs-keyword">class</span>);    &#125;    <span class="hljs-meta">@GetMapping</span>    <span class="hljs-meta">@ApiOperation(<span class="hljs-string">&quot;根据id集合查询用户&quot;</span>)</span>    <span class="hljs-keyword">public</span> List&lt;UserVO&gt; queryUserByIds(<span class="hljs-meta">@RequestParam(<span class="hljs-string">&quot;ids&quot;</span>)</span> List&lt;<span class="hljs-built_in">Long</span>&gt; ids)&#123;        <span class="hljs-comment">// 1.查询用户</span>        List&lt;User&gt; users = userService.listByIds(ids);        <span class="hljs-comment">// 2.处理vo</span>        <span class="hljs-keyword">return</span> BeanUtil.copyToList(users, UserVO.<span class="hljs-keyword">class</span>);    &#125;&#125;</code></pre></div><p>可以看到上述接口都直接在controller即可实现，无需编写任何service代码，非常方便。<br>不过，一些带有业务逻辑的接口则需要在service中自定义实现了。例如下面的需求：</p><ul><li>根据id扣减用户余额</li></ul><p>这看起来是个简单修改功能，只要修改用户余额即可。但这个业务包含一些业务逻辑处理：</p><ul><li>判断用户状态是否正常</li><li>判断用户余额是否充足</li></ul><p>这些业务逻辑都要在service层来做，另外更新余额需要自定义SQL，要在mapper中来实现。因此，我们除了要编写controller以外，具体的业务还要在service和mapper中编写。<br> 首先在UserController中定义一个方法：</p><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@PutMapping</span>(<span class="hljs-string">&quot;&#123;id&#125;/deduction/&#123;money&#125;&quot;</span>)<span class="hljs-variable">@ApiOperation</span>(<span class="hljs-string">&quot;扣减用户余额&quot;</span>)public void <span class="hljs-built_in">deductBalance</span>(<span class="hljs-variable">@PathVariable</span>(<span class="hljs-string">&quot;id&quot;</span>) Long id, <span class="hljs-variable">@PathVariable</span>(<span class="hljs-string">&quot;money&quot;</span>)Integer money)&#123;    <span class="hljs-selector-tag">userService</span><span class="hljs-selector-class">.deductBalance</span>(id, money);&#125;</code></pre></div><p>然后是UserService接口：</p><div class="code-wrapper"><pre><code class="hljs pgsql">package com.itheima.mp.service;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.<span class="hljs-keyword">extension</span>.service.IService;<span class="hljs-keyword">import</span> com.itheima.mp.<span class="hljs-keyword">domain</span>.po.<span class="hljs-keyword">User</span>;<span class="hljs-built_in">public</span> interface IUserService extends IService&lt;<span class="hljs-keyword">User</span>&gt; &#123;    <span class="hljs-type">void</span> deductBalance(Long id, <span class="hljs-type">Integer</span> <span class="hljs-type">money</span>);&#125;</code></pre></div><p>最后是UserServiceImpl实现类：</p><div class="code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.itheima.mp.service.impl;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.<span class="hljs-type">ServiceImpl</span>;<span class="hljs-keyword">import</span> com.itheima.mp.domain.po.<span class="hljs-type">User</span>;<span class="hljs-keyword">import</span> com.itheima.mp.mapper.<span class="hljs-type">UserMapper</span>;<span class="hljs-keyword">import</span> com.itheima.mp.service.<span class="hljs-type">IUserService</span>;<span class="hljs-keyword">import</span> org.springframework.stereotype.<span class="hljs-type">Service</span>;<span class="hljs-meta">@Service</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceImpl&lt;UserMapper</span>, <span class="hljs-title">User&gt;</span> <span class="hljs-title">implements</span> <span class="hljs-title">IUserService</span> </span>&#123;    <span class="hljs-meta">@Override</span>    public void deductBalance(<span class="hljs-type">Long</span> id, <span class="hljs-type">Integer</span> money) &#123;        <span class="hljs-comment">// 1.查询用户</span>        <span class="hljs-type">User</span> user = getById(id);        <span class="hljs-comment">// 2.判断用户状态</span>        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span> || user.getStatus() == <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>(<span class="hljs-string">&quot;用户状态异常&quot;</span>);        &#125;        <span class="hljs-comment">// 3.判断用户余额</span>        <span class="hljs-keyword">if</span> (user.getBalance() &lt; money) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>(<span class="hljs-string">&quot;用户余额不足&quot;</span>);        &#125;        <span class="hljs-comment">// 4.扣减余额</span>        baseMapper.deductMoneyById(id, money);    &#125;&#125;</code></pre></div><p>最后是mapper：</p><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@Update</span>(<span class="hljs-string">&quot;UPDATE user SET balance = balance - #&#123;money&#125; WHERE id = #&#123;id&#125;&quot;</span>)void <span class="hljs-built_in">deductMoneyById</span>(<span class="hljs-variable">@Param</span>(<span class="hljs-string">&quot;id&quot;</span>) Long id, <span class="hljs-variable">@Param</span>(<span class="hljs-string">&quot;money&quot;</span>) Integer money);</code></pre></div><h3 id="2-3-3-Lambda"><a href="#2-3-3-Lambda" class="headerlink" title="2.3.3.Lambda"></a><strong>2.3.3.Lambda</strong></h3><p>IService中还提供了Lambda功能来简化我们的复杂查询及更新功能。我们通过两个案例来学习一下。<br>案例一：实现一个根据复杂条件查询用户的接口，查询条件如下：</p><ul><li>name：用户名关键字，可以为空</li><li>status：用户状态，可以为空</li><li>minBalance：最小余额，可以为空</li><li>maxBalance：最大余额，可以为空</li></ul><p>可以理解成一个用户的后台管理界面，管理员可以自己选择条件来筛选用户，因此上述条件不一定存在，需要做判断。<br>我们首先需要定义一个查询条件实体，UserQuery实体：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.itheima.mp.domain.query;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModel;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModelProperty;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-meta">@ApiModel(description = <span class="hljs-string">&quot;用户查询条件实体&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserQuery</span> &#123;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;用户名关键字&quot;</span>)</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;用户状态：1-正常，2-冻结&quot;</span>)</span>    <span class="hljs-keyword">private</span> Integer status;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;余额最小值&quot;</span>)</span>    <span class="hljs-keyword">private</span> Integer minBalance;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;余额最大值&quot;</span>)</span>    <span class="hljs-keyword">private</span> Integer maxBalance;&#125;</code></pre></div><p>接下来我们在UserController中定义一个controller方法：</p><div class="code-wrapper"><pre><code class="hljs pgsql">@GetMapping(&quot;/list&quot;)@ApiOperation(&quot;根据id集合查询用户&quot;)<span class="hljs-built_in">public</span> List&lt;UserVO&gt; queryUsers(UserQuery query)&#123;    // <span class="hljs-number">1.</span>组织条件    String username = query.getName();    <span class="hljs-type">Integer</span> status = query.getStatus();    <span class="hljs-type">Integer</span> minBalance = query.getMinBalance();    <span class="hljs-type">Integer</span> maxBalance = query.getMaxBalance();    LambdaQueryWrapper&lt;<span class="hljs-keyword">User</span>&gt; <span class="hljs-keyword">wrapper</span> = <span class="hljs-built_in">new</span> QueryWrapper&lt;<span class="hljs-keyword">User</span>&gt;().lambda()            .<span class="hljs-keyword">like</span>(username != <span class="hljs-keyword">null</span>, <span class="hljs-keyword">User</span>::getUsername, username)            .eq(status != <span class="hljs-keyword">null</span>, <span class="hljs-keyword">User</span>::getStatus, status)            .ge(minBalance != <span class="hljs-keyword">null</span>, <span class="hljs-keyword">User</span>::getBalance, minBalance)            .le(maxBalance != <span class="hljs-keyword">null</span>, <span class="hljs-keyword">User</span>::getBalance, maxBalance);    // <span class="hljs-number">2.</span>查询用户    List&lt;<span class="hljs-keyword">User</span>&gt; users = userService.list(<span class="hljs-keyword">wrapper</span>);    // <span class="hljs-number">3.</span>处理vo    <span class="hljs-keyword">return</span> BeanUtil.copyToList(users, UserVO.<span class="hljs-keyword">class</span>);&#125;</code></pre></div><p>在组织查询条件的时候，我们加入了 username !&#x3D; null 这样的参数，意思就是当条件成立时才会添加这个查询条件，类似Mybatis的mapper.xml文件中的<if>标签。这样就实现了动态查询条件效果了。<br>不过，上述条件构建的代码太麻烦了。 因此Service中对LambdaQueryWrapper和LambdaUpdateWrapper的用法进一步做了简化。我们无需自己通过new的方式来创建Wrapper，而是直接调用lambdaQuery和lambdaUpdate方法：<br>基于Lambda查询：</p><div class="code-wrapper"><pre><code class="hljs lasso">@GetMapping(<span class="hljs-string">&quot;/list&quot;</span>)@ApiOperation(<span class="hljs-string">&quot;根据id集合查询用户&quot;</span>)<span class="hljs-keyword">public</span> <span class="hljs-built_in">List</span>&lt;UserVO&gt; queryUsers(UserQuery query)&#123;    <span class="hljs-comment">// 1.组织条件</span>    <span class="hljs-built_in">String</span> username = query.getName();    <span class="hljs-built_in">Integer</span> status = query.getStatus();    <span class="hljs-built_in">Integer</span> minBalance = query.getMinBalance();    <span class="hljs-built_in">Integer</span> maxBalance = query.getMaxBalance();    <span class="hljs-comment">// 2.查询用户</span>    <span class="hljs-built_in">List</span>&lt;User&gt; users = userService.lambdaQuery()            .like(username != <span class="hljs-built_in">null</span>, User<span class="hljs-type">::getUsername</span>, username)            .<span class="hljs-literal">eq</span>(status != <span class="hljs-built_in">null</span>, User<span class="hljs-type">::getStatus</span>, status)            .ge(minBalance != <span class="hljs-built_in">null</span>, User<span class="hljs-type">::getBalance</span>, minBalance)            .le(maxBalance != <span class="hljs-built_in">null</span>, User<span class="hljs-type">::getBalance</span>, maxBalance)            .<span class="hljs-built_in">list</span>();    <span class="hljs-comment">// 3.处理vo</span>    <span class="hljs-keyword">return</span> BeanUtil.copyToList(users, UserVO.class);&#125;</code></pre></div><p>可以发现lambdaQuery方法中除了可以构建条件，还需要在链式编程的最后添加一个list()，这是在告诉MP我们的调用结果需要是一个list集合。这里不仅可以用list()，可选的方法有：</p><ul><li>.one()：最多1个结果</li><li>.list()：返回集合结果</li><li>.count()：返回计数结果</li></ul><p>MybatisPlus会根据链式编程的最后一个方法来判断最终的返回结果。<br>与lambdaQuery方法类似，IService中的lambdaUpdate方法可以非常方便的实现复杂更新业务。<br>例如下面的需求：<br>需求：改造根据id修改用户余额的接口，要求如下</p><ul><li>如果扣减后余额为0，则将用户status修改为冻结状态（2）</li></ul><p>也就是说我们在扣减用户余额时，需要对用户剩余余额做出判断，如果发现剩余余额为0，则应该将status修改为2，这就是说update语句的set部分是动态的。<br>实现如下：</p><div class="code-wrapper"><pre><code class="hljs pgsql">@Override@Transactional<span class="hljs-built_in">public</span> <span class="hljs-type">void</span> deductBalance(Long id, <span class="hljs-type">Integer</span> <span class="hljs-type">money</span>) &#123;    // <span class="hljs-number">1.</span>查询用户    <span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span> = getById(id);    // <span class="hljs-number">2.</span>校验用户状态    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">user</span> == <span class="hljs-keyword">null</span> || <span class="hljs-keyword">user</span>.getStatus() == <span class="hljs-number">2</span>) &#123;        throw <span class="hljs-built_in">new</span> RuntimeException(&quot;用户状态异常！&quot;);    &#125;    // <span class="hljs-number">3.</span>校验余额是否充足    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">user</span>.getBalance() &lt; <span class="hljs-type">money</span>) &#123;        throw <span class="hljs-built_in">new</span> RuntimeException(&quot;用户余额不足！&quot;);    &#125;    // <span class="hljs-number">4.</span>扣减余额 <span class="hljs-keyword">update</span> tb_user <span class="hljs-keyword">set</span> balance = balance - ?    <span class="hljs-type">int</span> remainBalance = <span class="hljs-keyword">user</span>.getBalance() - <span class="hljs-type">money</span>;    lambdaUpdate()            .<span class="hljs-keyword">set</span>(<span class="hljs-keyword">User</span>::getBalance, remainBalance) // 更新余额            .<span class="hljs-keyword">set</span>(remainBalance == <span class="hljs-number">0</span>, <span class="hljs-keyword">User</span>::getStatus, <span class="hljs-number">2</span>) // 动态判断，是否更新status            .eq(<span class="hljs-keyword">User</span>::getId, id)            .eq(<span class="hljs-keyword">User</span>::getBalance, <span class="hljs-keyword">user</span>.getBalance()) // 乐观锁            .<span class="hljs-keyword">update</span>();&#125;</code></pre></div><h3 id="2-3-4-批量新增"><a href="#2-3-4-批量新增" class="headerlink" title="2.3.4.批量新增"></a><strong>2.3.4.批量新增</strong></h3><p>IService中的批量新增功能使用起来非常方便，但有一点注意事项，我们先来测试一下。 首先我们测试逐条插入数据：</p><div class="code-wrapper"><pre><code class="hljs pgsql">@Test<span class="hljs-type">void</span> testSaveOneByOne() &#123;    long b = <span class="hljs-keyword">System</span>.currentTimeMillis();    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100000</span>; i++) &#123;        userService.save(buildUser(i));    &#125;    long e = <span class="hljs-keyword">System</span>.currentTimeMillis();    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;耗时：&quot; + (e - b));&#125;private <span class="hljs-keyword">User</span> buildUser(<span class="hljs-type">int</span> i) &#123;    <span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">User</span>();    <span class="hljs-keyword">user</span>.setUsername(&quot;user_&quot; + i);    <span class="hljs-keyword">user</span>.setPassword(&quot;123&quot;);    <span class="hljs-keyword">user</span>.setPhone(&quot;&quot; + (<span class="hljs-number">18688190000</span>L + i));    <span class="hljs-keyword">user</span>.setBalance(<span class="hljs-number">2000</span>);    <span class="hljs-keyword">user</span>.setInfo(&quot;&#123;\&quot;age\&quot;: 24, \&quot;intro\&quot;: \&quot;英文老师\&quot;, \&quot;gender\&quot;: \&quot;female\&quot;&#125;&quot;);    <span class="hljs-keyword">user</span>.setCreateTime(LocalDateTime.now());    <span class="hljs-keyword">user</span>.setUpdateTime(<span class="hljs-keyword">user</span>.getCreateTime());    <span class="hljs-keyword">return</span> <span class="hljs-keyword">user</span>;&#125;</code></pre></div><p>执行结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705918577491-79c47877-5315-47bf-986f-b40df37aea6c.png#averageHue=%23f6f8f4&clientId=uc58b97f9-a395-4&from=paste&id=u700a36e1&originHeight=303&originWidth=1525&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uc2e4f0cd-5997-4672-8194-d029834d05f&title="><br> 可以看到速度非常慢。<br>然后再试试MybatisPlus的批处理：</p><div class="code-wrapper"><pre><code class="hljs csharp">@Test<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testSaveBatch</span>()</span> &#123;    <span class="hljs-comment">// 准备10万条数据</span>    List&lt;User&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">1000</span>);    <span class="hljs-built_in">long</span> b = System.currentTimeMillis();    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100000</span>; i++) &#123;        list.<span class="hljs-keyword">add</span>(buildUser(i));        <span class="hljs-comment">// 每1000条批量插入一次</span>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>) &#123;            userService.saveBatch(list);            list.clear();        &#125;    &#125;    <span class="hljs-built_in">long</span> e = System.currentTimeMillis();    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;耗时：&quot;</span> + (e - b));&#125;</code></pre></div><p>执行最终耗时如下：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705918577541-ae31e891-bb24-4ac0-a50f-d225b65174cd.png#averageHue=%23f6f8f4&clientId=uc58b97f9-a395-4&from=paste&id=u11a679bf&originHeight=305&originWidth=1528&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u34d7fc95-cce8-4391-9aa3-cb3a5a64452&title="><br> 可以看到使用了批处理以后，比逐条新增效率提高了10倍左右，性能还是不错的。<br>不过，我们简单查看一下MybatisPlus源码：</p><div class="code-wrapper"><pre><code class="hljs livescript">@Transactional(rollbackFor = Exception.<span class="hljs-keyword">class</span>)@Overridepublic boolean saveBatch(Collection&lt;T&gt; entityList, int batchSize) &#123;    <span class="hljs-built_in">String</span> sqlStatement = getSqlStatement(SqlMethod.INSERT_ONE);    <span class="hljs-keyword">return</span> executeBatch<span class="hljs-function"><span class="hljs-params">(entityList, batchSize, (sqlSession, entity) -&gt; sqlSession.insert(sqlStatement, entity))</span>;</span><span class="hljs-function">&#125;</span><span class="hljs-function">// ...<span class="hljs-title">SqlHelper</span></span><span class="hljs-function"><span class="hljs-title">public</span> <span class="hljs-title">static</span> &lt;<span class="hljs-title">E</span>&gt; <span class="hljs-title">boolean</span> <span class="hljs-title">executeBatch</span><span class="hljs-params">(Class&lt;?&gt; entityClass, Log log, Collection&lt;E&gt; <span class="hljs-keyword">list</span>, int batchSize, BiConsumer&lt;SqlSession, E&gt; consumer)</span> &#123;</span><span class="hljs-function">    <span class="hljs-title">Assert</span>.<span class="hljs-title">isFalse</span><span class="hljs-params">(batchSize &lt; <span class="hljs-number">1</span>, <span class="hljs-string">&quot;batchSize must not be less than one&quot;</span>)</span>;</span><span class="hljs-function">    <span class="hljs-title">return</span> !<span class="hljs-title">CollectionUtils</span>.<span class="hljs-title">isEmpty</span><span class="hljs-params">(<span class="hljs-keyword">list</span>)</span> &amp;&amp; <span class="hljs-title">executeBatch</span><span class="hljs-params">(entityClass, log, sqlSession -&gt; &#123;</span></span><span class="hljs-params"><span class="hljs-function">        int size = <span class="hljs-keyword">list</span>.size();</span></span><span class="hljs-params"><span class="hljs-function">        int idxLimit = <span class="hljs-built_in">Math</span>.min(batchSize, size);</span></span><span class="hljs-params"><span class="hljs-function">        int i = <span class="hljs-number">1</span>;</span></span><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span> (E element : <span class="hljs-keyword">list</span>) &#123;</span></span><span class="hljs-params"><span class="hljs-function">            consumer.accept(sqlSession, element);</span></span><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">if</span> (i == idxLimit) &#123;</span></span><span class="hljs-params"><span class="hljs-function">                sqlSession.flushStatements();</span></span><span class="hljs-params"><span class="hljs-function">                idxLimit = <span class="hljs-built_in">Math</span>.min(idxLimit + batchSize, size);</span></span><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><span class="hljs-params"><span class="hljs-function">            i++;</span></span><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><span class="hljs-params"><span class="hljs-function">    &#125;)</span>;</span><span class="hljs-function">&#125;</span></code></pre></div><p>可以发现其实MybatisPlus的批处理是基于PrepareStatement的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。SQL类似这样：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Preparing</span>: INSERT INTO user ( username, password, phone, info, balance, create_time, update_time ) VALUES ( ?, ?, ?, ?, ?, ?, ? )<span class="hljs-attribute">Parameters</span>: user_1, <span class="hljs-number">123</span>, <span class="hljs-number">18688190001</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">2023</span>-<span class="hljs-number">07</span>-<span class="hljs-number">01</span>, <span class="hljs-number">2023</span>-<span class="hljs-number">07</span>-<span class="hljs-number">01</span><span class="hljs-attribute">Parameters</span>: user_2, <span class="hljs-number">123</span>, <span class="hljs-number">18688190002</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">2023</span>-<span class="hljs-number">07</span>-<span class="hljs-number">01</span>, <span class="hljs-number">2023</span>-<span class="hljs-number">07</span>-<span class="hljs-number">01</span><span class="hljs-attribute">Parameters</span>: user_3, <span class="hljs-number">123</span>, <span class="hljs-number">18688190003</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">2023</span>-<span class="hljs-number">07</span>-<span class="hljs-number">01</span>, <span class="hljs-number">2023</span>-<span class="hljs-number">07</span>-<span class="hljs-number">01</span></code></pre></div><p>而如果想要得到最佳性能，最好是将多条SQL合并为一条，像这样：</p><div class="code-wrapper"><pre><code class="hljs subunit">INSERT INTO user ( username, password, phone, info, balance, create_time, update_time )VALUES (user_1, 123, 18688190001, &quot;&quot;, 2000, 2023<span class="hljs-string">-07</span><span class="hljs-string">-01</span>, 2023<span class="hljs-string">-07</span><span class="hljs-string">-01</span>),(user_2, 123, 18688190002, &quot;&quot;, 2000, 2023<span class="hljs-string">-07</span><span class="hljs-string">-01</span>, 2023<span class="hljs-string">-07</span><span class="hljs-string">-01</span>),(user_3, 123, 18688190003, &quot;&quot;, 2000, 2023<span class="hljs-string">-07</span><span class="hljs-string">-01</span>, 2023<span class="hljs-string">-07</span><span class="hljs-string">-01</span>),(user_4, 123, 18688190004, &quot;&quot;, 2000, 2023<span class="hljs-string">-07</span><span class="hljs-string">-01</span>, 2023<span class="hljs-string">-07</span><span class="hljs-string">-01</span>);</code></pre></div><p>该怎么做呢？<br>MySQL的客户端连接参数中有这样的一个参数：rewriteBatchedStatements。顾名思义，就是重写批处理的statement语句。参考文档：<br><a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-performance-extensions.html#cj-conn-prop_rewriteBatchedStatements">https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-performance-extensions.html#cj-conn-prop_rewriteBatchedStatements</a><br> 这个参数的默认值是false，我们需要修改连接参数，将其配置为true<br>修改项目中的application.yml文件，在jdbc的url后面添加参数&amp;rewriteBatchedStatements&#x3D;true:</p><div class="code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span><span class="hljs-symbol">  datasource:</span><span class="hljs-symbol">    url:</span> jdbc:mysql:<span class="hljs-comment">//127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span>    driver-class-name: com.mysql.cj.jdbc.Driver<span class="hljs-symbol">    username:</span> root<span class="hljs-symbol">    password:</span> MySQL123</code></pre></div><p>再次测试插入10万条数据，可以发现速度有非常明显的提升：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705918577520-0196506b-bff1-45dc-8c7a-fac4dc56a512.png#averageHue=%23f6f9f4&clientId=uc58b97f9-a395-4&from=paste&id=u8a36e49b&originHeight=338&originWidth=1450&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ua6f0112b-2d06-4e96-bc5e-c12e199f055&title="><br>在ClientPreparedStatement的executeBatchInternal中，有判断rewriteBatchedStatements值是否为true并重写SQL的功能：<br> 最终，SQL被重写了：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705918589951-a039f0bf-7969-47b9-bae6-54aba517d7d1.png#averageHue=%23f4f4f3&clientId=uc58b97f9-a395-4&from=paste&id=ud31f44f4&originHeight=820&originWidth=1438&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uebc23129-0353-41c2-a242-d2d48624d16&title="></p><h2 id="3-扩展功能："><a href="#3-扩展功能：" class="headerlink" title="3.扩展功能："></a>3.扩展功能：</h2><p>在使用MybatisPlus以后，基础的Mapper、Service、PO代码相对固定，重复编写也比较麻烦。因此MybatisPlus官方提供了代码生成器根据数据库表结构生成PO、Mapper、Service等相关代码。只不过代码生成器同样要编码使用，也很麻烦。<br>这里推荐大家使用一款MybatisPlus的插件，它可以基于图形化界面完成MybatisPlus的代码生成，非常简单。</p><h2 id="3-1-代码生成"><a href="#3-1-代码生成" class="headerlink" title="3.1.代码生成"></a><strong>3.1.代码生成</strong></h2><p>在使用MybatisPlus以后，基础的Mapper、Service、PO代码相对固定，重复编写也比较麻烦。因此MybatisPlus官方提供了代码生成器根据数据库表结构生成PO、Mapper、Service等相关代码。只不过代码生成器同样要编码使用，也很麻烦。<br>这里推荐大家使用一款MybatisPlus的插件，它可以基于图形化界面完成MybatisPlus的代码生成，非常简单。</p><h3 id="3-1-1-安装插件"><a href="#3-1-1-安装插件" class="headerlink" title="3.1.1.安装插件"></a><strong>3.1.1.安装插件</strong></h3><p>在Idea的plugins市场中搜索并安装MyBatisPlus插件：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705925803243-c463bddd-90b6-4f00-82f9-07248f3be296.png#averageHue=%23f6f5f5&clientId=uc58b97f9-a395-4&from=paste&id=u10f22e01&originHeight=766&originWidth=1507&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u774fac4c-a63b-4b5d-b790-d376bfa45ec&title="><br> 然后重启你的Idea即可使用。</p><h3 id="3-1-2-使用"><a href="#3-1-2-使用" class="headerlink" title="3.1.2.使用"></a><strong>3.1.2.使用</strong></h3><p>刚好数据库中还有一张address表尚未生成对应的实体和mapper等基础代码。我们利用插件生成一下。 首先需要配置数据库地址，在Idea顶部菜单中，找到other，选择Config Database：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705925803207-e850f164-0ed0-424c-900f-3fedb6538a55.png#averageHue=%23d9ceb7&clientId=uc58b97f9-a395-4&from=paste&id=u1a5ced54&originHeight=236&originWidth=1221&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ue1f50f4e-facf-40db-a0b7-ba521b9bba9&title="><br> 在弹出的窗口中填写数据库连接的基本信息：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705925803342-1dfc56be-849e-4f50-bca8-ab9a57c51b8d.png#averageHue=%23f4f4f4&clientId=uc58b97f9-a395-4&from=paste&id=u901ce6ea&originHeight=393&originWidth=629&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u3bc246b2-fd70-4532-bbfc-a70f583f4fd&title="><br> 点击OK保存。<br>然后再次点击Idea顶部菜单中的other，然后选择Code Generator:<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705925803246-a0166ea0-af7e-4fcb-a752-12fe9b94dc51.png#averageHue=%23d7cbb2&clientId=uc58b97f9-a395-4&from=paste&id=u11e4b452&originHeight=190&originWidth=1109&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u82c0dc6d-49f5-4b79-9b08-722b1889191&title="><br> 在弹出的表单中填写信息：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705925803280-c0d3829d-83a0-42ce-a02e-3e145b64069f.png#averageHue=%23f3e9e8&clientId=uc58b97f9-a395-4&from=paste&id=u553b6e7b&originHeight=606&originWidth=1376&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u13c55ac9-9403-4bec-9fb6-9d460c8fffc&title="><br> 最终，代码自动生成到指定的位置了：但是要注意上面的代码生成的mapper文件缺少@Mapper注解的！</p><h2 id="3-2-静态工具"><a href="#3-2-静态工具" class="headerlink" title="3.2.静态工具"></a><strong>3.2.静态工具</strong></h2><p>有的时候Service之间也会相互调用，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：Db，其中的一些静态方法与IService中方法签名基本一致，也可以帮助我们实现CRUD功能：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705925805432-f717e42a-c354-420b-9431-ce96c43cec8f.png#averageHue=%23fbf9f8&clientId=uc58b97f9-a395-4&from=paste&id=ud46ade48&originHeight=899&originWidth=1028&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uf48cddd7-fed5-4b09-8ce7-d6e314ca6ae&title="><br>示例：</p><div class="code-wrapper"><pre><code class="hljs pgsql">@Test<span class="hljs-type">void</span> testDbGet() &#123;    <span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span> = Db.getById(<span class="hljs-number">1</span>L, <span class="hljs-keyword">User</span>.<span class="hljs-keyword">class</span>);    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">user</span>);&#125;@Test<span class="hljs-type">void</span> testDbList() &#123;    // 利用Db实现复杂条件查询    List&lt;<span class="hljs-keyword">User</span>&gt; list = Db.lambdaQuery(<span class="hljs-keyword">User</span>.<span class="hljs-keyword">class</span>)            .<span class="hljs-keyword">like</span>(<span class="hljs-keyword">User</span>::getUsername, &quot;o&quot;)            .ge(<span class="hljs-keyword">User</span>::getBalance, <span class="hljs-number">1000</span>)            .list();    list.<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>::println);&#125;@Test<span class="hljs-type">void</span> testDbUpdate() &#123;    Db.lambdaUpdate(<span class="hljs-keyword">User</span>.<span class="hljs-keyword">class</span>)            .<span class="hljs-keyword">set</span>(<span class="hljs-keyword">User</span>::getBalance, <span class="hljs-number">2000</span>)            .eq(<span class="hljs-keyword">User</span>::getUsername, &quot;Rose&quot;);&#125;</code></pre></div><p>需求：改造根据id用户查询的接口，查询用户的同时返回用户收货地址列表<br>首先，我们要添加一个收货地址的VO对象：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.itheima.mp.domain.vo;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModel;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModelProperty;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-meta">@ApiModel(description = <span class="hljs-string">&quot;收货地址VO&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AddressVO</span>&#123;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;id&quot;</span>)</span>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> id;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;用户ID&quot;</span>)</span>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> userId;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;省&quot;</span>)</span>    <span class="hljs-keyword">private</span> String province;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;市&quot;</span>)</span>    <span class="hljs-keyword">private</span> String city;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;县/区&quot;</span>)</span>    <span class="hljs-keyword">private</span> String town;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;手机&quot;</span>)</span>    <span class="hljs-keyword">private</span> String mobile;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;详细地址&quot;</span>)</span>    <span class="hljs-keyword">private</span> String street;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;联系人&quot;</span>)</span>    <span class="hljs-keyword">private</span> String contact;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;是否是默认 1默认 0否&quot;</span>)</span>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Boolean</span> isDefault;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;备注&quot;</span>)</span>    <span class="hljs-keyword">private</span> String notes;&#125;</code></pre></div><p>然后，改造原来的UserVO，添加一个地址属性：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705925806370-0ff19fa7-2686-4d7f-ba8e-449c203787f9.png#averageHue=%23f6f9f3&clientId=uc58b97f9-a395-4&from=paste&id=u9a4dd936&originHeight=804&originWidth=929&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u3f51cddc-ab65-46fc-aa76-8fe5e8c0efc&title="><br>接下来，修改UserController中根据id查询用户的业务接口：</p><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/&#123;id&#125;&quot;</span>)<span class="hljs-variable">@ApiOperation</span>(<span class="hljs-string">&quot;根据id查询用户&quot;</span>)public UserVO <span class="hljs-built_in">queryUserById</span>(<span class="hljs-variable">@PathVariable</span>(<span class="hljs-string">&quot;id&quot;</span>) Long userId)&#123;    <span class="hljs-comment">// 基于自定义service方法查询</span>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">userService</span><span class="hljs-selector-class">.queryUserAndAddressById</span>(userId);&#125;</code></pre></div><p>由于查询业务复杂，所以要在service层来实现。首先在IUserService中定义方法：</p><div class="code-wrapper"><pre><code class="hljs pgsql">package com.itheima.mp.service;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.<span class="hljs-keyword">extension</span>.service.IService;<span class="hljs-keyword">import</span> com.itheima.mp.<span class="hljs-keyword">domain</span>.po.<span class="hljs-keyword">User</span>;<span class="hljs-keyword">import</span> com.itheima.mp.<span class="hljs-keyword">domain</span>.vo.UserVO;<span class="hljs-built_in">public</span> interface IUserService extends IService&lt;<span class="hljs-keyword">User</span>&gt; &#123;    <span class="hljs-type">void</span> deduct(Long id, <span class="hljs-type">Integer</span> <span class="hljs-type">money</span>);    UserVO queryUserAndAddressById(Long userId);&#125;</code></pre></div><p>然后，在UserServiceImpl中实现该方法：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> UserVO queryUserAndAddressById(<span class="hljs-built_in">Long</span> userId) &#123;    <span class="hljs-comment">// 1.查询用户</span>    User user = getById(userId);    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-comment">// 2.查询收货地址</span>    List&lt;Address&gt; addresses = Db.lambdaQuery(Address.<span class="hljs-keyword">class</span>)            .eq(Address::getUserId, userId)            .list();    <span class="hljs-comment">// 3.处理vo</span>    UserVO userVO = BeanUtil.copyProperties(user, UserVO.<span class="hljs-keyword">class</span>);    userVO.setAddresses(BeanUtil.copyToList(addresses, AddressVO.<span class="hljs-keyword">class</span>));    <span class="hljs-keyword">return</span> userVO;&#125;</code></pre></div><p>在查询地址时，我们采用了Db的静态方法，因此避免了注入AddressService，减少了循环依赖的风险。<br>（如果AdressService需要查询User的时候，如果采用注入各自的Service就会产生循环依赖的问题了）<br>再来实现一个功能：</p><ul><li>根据id批量查询用户，并查询出用户对应的所有地址</li></ul><h2 id="3-3-逻辑删除"><a href="#3-3-逻辑删除" class="headerlink" title="3.3.逻辑删除"></a><strong>3.3.逻辑删除</strong></h2><p>对于一些比较重要的数据，我们往往会采用逻辑删除的方案，即：</p><ul><li>在表中添加一个字段标记数据是否被删除</li><li>当删除数据时把标记置为true</li><li>查询时过滤掉标记为true的数据</li></ul><p>一旦采用了逻辑删除，所有的查询和删除逻辑都要跟着变化，非常麻烦。<br>为了解决这个问题，MybatisPlus就添加了对逻辑删除的支持。<br><strong>注意</strong>，只有MybatisPlus生成的SQL语句才支持自动的逻辑删除，自定义SQL需要自己手动处理逻辑删除。<br>例如，我们给address表添加一个逻辑删除字段：</p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> address <span class="hljs-keyword">add</span> deleted <span class="hljs-type">bit</span> <span class="hljs-keyword">default</span> b<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">comment</span> <span class="hljs-string">&#x27;逻辑删除&#x27;</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">ADD</span> deleted <span class="hljs-type">bit</span>: 在表&quot;address&quot;中添加一个名为&quot;deleted&quot;的列，数据类型为<span class="hljs-type">bit</span>。<span class="hljs-type">Bit</span>数据类型用于存储<span class="hljs-number">0</span>或<span class="hljs-number">1</span>的布尔值。<span class="hljs-keyword">DEFAULT</span> b<span class="hljs-string">&#x27;0&#x27;</span>: 设置&quot;deleted&quot;列的默认值为二进制表示的<span class="hljs-number">0</span>，即<span class="hljs-keyword">false</span>。当插入新记录时，如果未提供&quot;deleted&quot;列的值，将自动使用默认值<span class="hljs-number">0</span>。<span class="hljs-keyword">NULL</span>: 指定&quot;deleted&quot;列允许为空值。这表示在插入新记录时，可以将&quot;deleted&quot;列设置为<span class="hljs-keyword">NULL</span>，表示未知或未设置。</code></pre></div><p>然后给Address实体添加deleted字段：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705929828756-e0994712-53c6-4b5a-bee4-9b834c96b6cc.png#averageHue=%23f6f8f3&clientId=uc58b97f9-a395-4&from=paste&id=u60328773&originHeight=482&originWidth=856&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u2cad5426-4646-46fd-bd0e-0af0591c6f8&title="><br>接下来，我们要在application.yml中配置逻辑删除字段：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span>  <span class="hljs-attr">global-config:</span>    <span class="hljs-attr">db-config:</span>      <span class="hljs-attr">logic-delete-field:</span> <span class="hljs-string">deleted</span> <span class="hljs-comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span>      <span class="hljs-attr">logic-delete-value:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 逻辑已删除值(默认为 1)</span>      <span class="hljs-attr">logic-not-delete-value:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 逻辑未删除值(默认为 0)</span></code></pre></div><p>测试： 首先，我们执行一个删除操作：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-meta">@Test</span><span class="hljs-built_in">void</span> <span class="hljs-title function_">testDeleteByLogic</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 删除方法与以前没有区别</span>    addressService.<span class="hljs-title function_">removeById</span>(59L);&#125;</code></pre></div><p>方法与普通删除一模一样，但是底层的SQL逻辑变了：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705929828740-fd1337a1-66af-4424-9b11-e048d081e91b.png#averageHue=%23f9fcf7&clientId=uc58b97f9-a395-4&from=paste&id=uc0061475&originHeight=387&originWidth=1347&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uc5e559a3-b475-4939-8e40-34d7b5e5a77&title="><br>查询一下试试：</p><div class="code-wrapper"><pre><code class="hljs pgsql">@Test<span class="hljs-type">void</span> testQuery() &#123;    List&lt;Address&gt; list = addressService.list();    list.<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>::println);&#125;</code></pre></div><p>会发现id为59的确实没有查询出来，而且SQL中也对逻辑删除字段做了判断：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705929828967-15c00aed-218b-4c65-87c3-00e4accf5dc6.png#averageHue=%23f9fcf7&clientId=uc58b97f9-a395-4&from=paste&id=u337c364c&originHeight=560&originWidth=1328&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u7b0c1730-31af-4f6a-9ee3-8419cf75303&title="><br>综上， 开启了逻辑删除功能以后，我们就可以像普通删除一样做CRUD，基本不用考虑代码逻辑问题。还是非常方便的。<br><strong>注意</strong>： 逻辑删除本身也有自己的问题，比如：</p><ul><li>会导致数据库表垃圾数据越来越多，从而影响查询效率</li><li>SQL中全都需要对逻辑删除字段做判断，影响查询效率</li></ul><p>因此，我不太推荐采用逻辑删除功能，如果数据不能删除，可以采用把数据迁移到其它表的办法。</p><h2 id="3-3-通用枚举"><a href="#3-3-通用枚举" class="headerlink" title="3.3.通用枚举"></a><strong>3.3.通用枚举</strong></h2><p>User类中有一个用户状态字段：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978249509-aa2d04fe-4b98-4ac9-980f-5fa85c7d6b50.png#averageHue=%23f5f7f4&clientId=uc58b97f9-a395-4&from=paste&id=ub07561b7&originHeight=432&originWidth=688&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u8666f78e-7686-4c6e-81c7-da8a49a01fc&title="><br> 像这种字段我们一般会定义一个枚举，做业务判断的时候就可以直接基于枚举做比较。但是我们数据库采用的是int类型，对应的PO也是Integer。因此业务操作时必须手动把枚举与Integer转换，非常麻烦。<br>因此，MybatisPlus提供了一个处理枚举的类型转换器，可以帮我们<strong>把枚举类型与数据库类型自动转换</strong>。</p><h3 id="3-3-1-定义枚举"><a href="#3-3-1-定义枚举" class="headerlink" title="3.3.1.定义枚举"></a><strong>3.3.1.定义枚举</strong></h3><p>我们定义一个用户状态的枚举：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978249556-e6a77e68-d8e7-4491-893d-62acee59bfe6.png#averageHue=%23f9fbf8&clientId=uc58b97f9-a395-4&from=paste&id=ufe2f95ae&originHeight=499&originWidth=915&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ub92043d0-5495-4ccf-be03-817c41feb25&title="><br> 代码如下：</p><div class="code-wrapper"><pre><code class="hljs pgsql">package com.itheima.mp.enums;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.annotation.EnumValue;<span class="hljs-keyword">import</span> lombok.Getter;@Getter<span class="hljs-built_in">public</span> enum UserStatus &#123;    NORMAL(<span class="hljs-number">1</span>, &quot;正常&quot;),    <span class="hljs-keyword">FREEZE</span>(<span class="hljs-number">2</span>, &quot;冻结&quot;)    ;    private final <span class="hljs-type">int</span> <span class="hljs-keyword">value</span>;    private final String <span class="hljs-keyword">desc</span>;    UserStatus(<span class="hljs-type">int</span> <span class="hljs-keyword">value</span>, String <span class="hljs-keyword">desc</span>) &#123;        this.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>;        this.<span class="hljs-keyword">desc</span> = <span class="hljs-keyword">desc</span>;    &#125;&#125;</code></pre></div><p>然后把User类中的status字段改为UserStatus 类型：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978249521-ed97e27c-6924-4aa2-8be3-86de331de227.png#averageHue=%23f6f7f2&clientId=uc58b97f9-a395-4&from=paste&id=u61339fb0&originHeight=422&originWidth=714&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u1c8fd25d-379b-450f-9b37-a94dd7f887e&title="><br>要让MybatisPlus处理枚举与数据库类型自动转换，我们必须告诉MybatisPlus，枚举中的哪个字段的值作为数据库值。 MybatisPlus提供了@EnumValue注解来标记枚举属性：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978322926-f9cac0e4-9432-423d-9c15-bc8e780b2ad8.png#averageHue=%23f8fbf6&clientId=uc58b97f9-a395-4&from=paste&id=u998367e5&originHeight=518&originWidth=635&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ub0d8a87b-4703-4ada-a444-3a91345589e&title="><br>上面的@Enumvalue修饰的属性，表示该属性对应的是数据库中的字段！然后数据库查询出来的值会自动转换为对应的枚举类型！<br>枚举类也是一种类，只是它是一种比较特殊的类，因此它一样可以使用属性和方法。<br>枚举类通常应该设计成不可变类，也就说它的属性值不应该允许改变，这样会更安全，而且代码更加简洁。为此，我们应该将枚举类的属性都使用private final修饰。<br>一旦为枚举类显式定义了带参数的构造器，则列出枚举值时也必须对应地传入参数。<br>上面的枚举属性是一种类似方法的值,必须含有构造方法！</p><h3 id="3-3-2-配置枚举处理器"><a href="#3-3-2-配置枚举处理器" class="headerlink" title="3.3.2.配置枚举处理器"></a><strong>3.3.2.配置枚举处理器</strong></h3><p>在application.yaml文件中添加配置：</p><div class="code-wrapper"><pre><code class="hljs stylus">mybatis-plus:  configuration:    default-enum-type-handler: com<span class="hljs-selector-class">.baomidou</span><span class="hljs-selector-class">.mybatisplus</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.handlers</span>.MybatisEnumTypeHandler</code></pre></div><h3 id="3-3-3-测试"><a href="#3-3-3-测试" class="headerlink" title="3.3.3.测试"></a><strong>3.3.3.测试</strong></h3><div class="code-wrapper"><pre><code class="hljs pgsql">@Test<span class="hljs-type">void</span> testService() &#123;    List&lt;<span class="hljs-keyword">User</span>&gt; list = userService.list();    list.<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>::println);&#125;</code></pre></div><p>最终，查询出的User类的status字段会是枚举类型：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978322948-63901170-fb58-44aa-8ead-e3f718a83e42.png#averageHue=%23f7faf3&clientId=uc58b97f9-a395-4&from=paste&id=u5b431e2c&originHeight=337&originWidth=758&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uc2b81bb7-1a6c-4d0f-8f77-81fa6d06e08&title="><br>同时，为了使页面查询结果也是枚举格式，我们需要修改UserVO中的status属性：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978322908-020fb44c-2198-4d67-838c-2dbe552d3e29.png#averageHue=%23f6f8f1&clientId=uc58b97f9-a395-4&from=paste&id=u900af5c6&originHeight=488&originWidth=1256&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u85d7767a-5cdd-43a0-8f9f-81884259c1b&title="><br>并且，在UserStatus枚举中通过@JsonValue注解标记JSON序列化时展示的字段：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978322910-47a9761a-b929-4a31-a381-e5e106aa8c46.png#averageHue=%23f6f9f4&clientId=uc58b97f9-a395-4&from=paste&id=uf8aa82ad&originHeight=491&originWidth=1199&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u254bda76-28e1-4176-9676-49b08313b9a&title="><br>最后，在页面查询，结果如下：<br>如果上面的枚举类没有用@JsonValue  修饰的话，那么前端查询的时候返回的是枚举类型的字符串，也就是返回的是NORMAL或者其他的！如果添加了该注解修饰返回给前端的值就是枚举属性中的desc部分！<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978322928-bfcd70d6-c8cb-4006-83fa-96ec1a7bfe84.png#averageHue=%23b1b0aa&clientId=uc58b97f9-a395-4&from=paste&id=ub21689de&originHeight=764&originWidth=1752&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ud60dc59f-3df9-4430-85a3-cb56404fa2f&title="></p><h2 id="3-4-JSON类型处理器"><a href="#3-4-JSON类型处理器" class="headerlink" title="3.4.JSON类型处理器"></a><strong>3.4.JSON类型处理器</strong></h2><p>数据库的user表中有一个info字段，是JSON类型：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978323486-e2b7191e-8602-4502-abc1-093453bbb30f.png#averageHue=%23f7f6f4&clientId=uc58b97f9-a395-4&from=paste&id=u634e6503&originHeight=304&originWidth=761&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u3f92d5cc-eb85-4d7e-8c03-c0ea7202ed1&title="><br> 格式像这样：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;intro&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;佛系青年&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;gender&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;male&quot;</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>而目前User实体类中却是String类型：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978323508-679d8806-0c1f-458b-b9b8-1738c6d07b55.png#averageHue=%23f5f8f4&clientId=uc58b97f9-a395-4&from=paste&id=uee0b7401&originHeight=384&originWidth=814&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u0ca78c3a-2df7-45c6-8dbc-4c28f87d205&title="><br>这样一来，我们要读取info中的属性时就非常不方便。如果要方便获取，info的类型最好是一个Map或者实体类。<br> 而一旦我们把info改为对象类型，就需要在写入数据库时手动转为String，再读取数据库时，手动转换为对象，这会非常麻烦。<br>因此MybatisPlus提供了很多特殊类型字段的类型处理器，解决特殊字段类型与数据库类型转换的问题。例如处理JSON就可以使用JacksonTypeHandler处理器。<br>接下来，我们就来看看这个处理器该如何使用。</p><h3 id="3-4-1-定义实体"><a href="#3-4-1-定义实体" class="headerlink" title="3.4.1.定义实体"></a><strong>3.4.1.定义实体</strong></h3><p>首先，我们定义一个单独实体类来与info字段的属性匹配：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978323584-9c4d490e-b0af-4e55-a95a-5c471ce3804e.png#averageHue=%23f9fbf8&clientId=uc58b97f9-a395-4&from=paste&id=u98815d56&originHeight=437&originWidth=860&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u7eb18b57-145c-478a-b26c-150b875da44&title="><br> 代码如下：</p><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> com.itheima.mp.domain.po;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> intro;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> gender;&#125;</code></pre></div><h3 id="3-4-2-使用类型处理器"><a href="#3-4-2-使用类型处理器" class="headerlink" title="3.4.2.使用类型处理器"></a><strong>3.4.2.使用类型处理器</strong></h3><p>接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978323692-de784ab0-b4d2-422d-b25c-ba041423cb52.png#averageHue=%23f6f8f4&clientId=uc58b97f9-a395-4&from=paste&id=uc328c190&originHeight=383&originWidth=978&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u0dbfe6ed-814e-4893-843e-efc5903b0e0&title="><br>测试可以发现，所有数据都正确封装到UserInfo当中了：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978324097-a9bb9dfe-60b6-4a97-92d5-aae0c01e1c9a.png#averageHue=%23f9fbf6&clientId=uc58b97f9-a395-4&from=paste&id=ue9d7303b&originHeight=345&originWidth=1034&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u94a9f33f-ce94-45f6-9d93-58f8cfa15b2&title="><br>同时，为了让页面返回的结果也以对象格式返回，我们要修改UserVO中的info字段：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978324170-549eb331-de5d-4f45-bb15-cef0f3591856.png#averageHue=%23f5f7f0&clientId=uc58b97f9-a395-4&from=paste&id=uc69a9dc2&originHeight=383&originWidth=945&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uf5214c5c-5d51-4903-b322-46aa93c75d4&title="><br>此时，在页面查询结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978324181-87b36754-e3eb-41a0-a756-52a23712e354.png#averageHue=%23b9b9b1&clientId=uc58b97f9-a395-4&from=paste&id=uccac1623&originHeight=755&originWidth=1722&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u19c62568-d3b6-4f9d-a17d-d3ce4f6642b&title="></p><h2 id="3-5-配置加密（选学）"><a href="#3-5-配置加密（选学）" class="headerlink" title="3.5.配置加密（选学）"></a><del><strong>3.5.配置加密（选学）</strong></del></h2><p>目前我们配置文件中的很多参数都是明文，如果开发人员发生流动，很容易导致敏感信息的泄露。所以MybatisPlus支持配置文件的加密和解密功能。<br>我们以数据库的用户名和密码为例。</p><h3 id="3-5-1-生成秘钥"><a href="#3-5-1-生成秘钥" class="headerlink" title="3.5.1.生成秘钥"></a><strong>3.5.1.生成秘钥</strong></h3><p>首先，我们利用AES工具生成一个随机秘钥，然后对用户名、密码加密：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.mp;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.toolkit.AES;<span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<span class="hljs-keyword">class</span> <span class="hljs-title class_">MpDemoApplicationTests</span> &#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// 生成 16 位随机 AES 密钥</span>        <span class="hljs-type">String</span> <span class="hljs-variable">randomKey</span> <span class="hljs-operator">=</span> AES.generateRandomKey();        System.out.println(<span class="hljs-string">&quot;randomKey = &quot;</span> + randomKey);        <span class="hljs-comment">// 利用密钥对用户名加密</span>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> AES.encrypt(<span class="hljs-string">&quot;root&quot;</span>, randomKey);        System.out.println(<span class="hljs-string">&quot;username = &quot;</span> + username);        <span class="hljs-comment">// 利用密钥对用户名加密</span>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> AES.encrypt(<span class="hljs-string">&quot;MySQL123&quot;</span>, randomKey);        System.out.println(<span class="hljs-string">&quot;password = &quot;</span> + password);    &#125;&#125;</code></pre></div><p>打印结果如下：</p><div class="code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">randomKey</span> <span class="hljs-operator">=</span> <span class="hljs-number">6234633</span>a66fb399f<span class="hljs-attribute">username</span> <span class="hljs-operator">=</span> px2bAbnUfiY8K/IgsKvscg<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-attribute">password</span> <span class="hljs-operator">=</span> FGvCSEaOuga3ulDAsxw68Q<span class="hljs-operator">=</span><span class="hljs-operator">=</span></code></pre></div><h3 id="3-5-2-修改配置"><a href="#3-5-2-修改配置" class="headerlink" title="3.5.2.修改配置"></a><strong>3.5.2.修改配置</strong></h3><p>修改application.yaml文件，把jdbc的用户名、密码修改为刚刚加密生成的密文：</p><div class="code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span><span class="hljs-symbol">  datasource:</span><span class="hljs-symbol">    url:</span> jdbc:mysql:<span class="hljs-comment">//127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span>    driver-class-name: com.mysql.cj.jdbc.Driver<span class="hljs-symbol">    username:</span> mpw:QWWVnk1Oal3258x5rVhaeQ== <span class="hljs-meta"># 密文要以 mpw:开头</span><span class="hljs-symbol">    password:</span> mpw:EUFmeH3cNAzdRGdOQcabWg== <span class="hljs-meta"># 密文要以 mpw:开头</span></code></pre></div><h3 id="3-5-3-测试"><a href="#3-5-3-测试" class="headerlink" title="3.5.3.测试"></a><strong>3.5.3.测试</strong></h3><p>在启动项目的时候，需要把刚才生成的秘钥添加到启动参数中，像这样：<br>–mpw.key&#x3D;6234633a66fb399f<br>单元测试的时候不能添加启动参数，所以要在测试类的注解上配置：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978324367-3cf813ab-499d-4dd1-9c88-bcd8cfbff7d7.png#averageHue=%23f5f7f3&clientId=uc58b97f9-a395-4&from=paste&id=u801e8006&originHeight=486&originWidth=1089&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ub52ae623-c40f-4e91-a659-422267810fb&title="><br>然后随意运行一个单元测试，可以发现数据库查询正常。<br>注意：如果是springboot项目启动的时候，我们需要在程序启动的时候添加程序实参：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705980172566-7324763d-c5bc-4a83-a25d-d01a67bc22f9.png#averageHue=%232f3136&clientId=uc58b97f9-a395-4&from=paste&height=486&id=uc3036a07&originHeight=608&originWidth=940&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=47414&status=done&style=none&taskId=u76007036-4392-4644-b0cc-ec8d7d6b2c7&title=&width=752" alt="image.png"></p><h1 id="4-插件功能"><a href="#4-插件功能" class="headerlink" title="4.插件功能"></a><strong>4.插件功能</strong></h1><p>MybatisPlus提供了很多的插件功能，进一步拓展其功能。目前已有的插件有：</p><ul><li>PaginationInnerInterceptor：自动分页</li><li>TenantLineInnerInterceptor：多租户</li><li>DynamicTableNameInnerInterceptor：动态表名</li><li>OptimisticLockerInnerInterceptor：乐观锁</li><li>IllegalSQLInnerInterceptor：sql 性能规范</li><li>BlockAttackInnerInterceptor：防止全表更新与删除</li></ul><p><strong>注意：</strong> 使用多个分页插件的时候需要注意插件定义顺序，建议使用顺序如下：</p><ul><li>多租户,动态表名</li><li>分页,乐观锁</li><li>sql 性能规范,防止全表更新与删除</li></ul><p>这里我们以分页插件为里来学习插件的用法。</p><h2 id="4-1-分页插件"><a href="#4-1-分页插件" class="headerlink" title="4.1.分页插件"></a><strong>4.1.分页插件</strong></h2><p>在未引入分页插件的情况下，MybatisPlus是不支持分页功能的，IService和BaseMapper中的分页方法都无法正常起效。 所以，我们必须配置分页插件。</p><h3 id="4-1-1-配置分页插件"><a href="#4-1-1-配置分页插件" class="headerlink" title="4.1.1.配置分页插件"></a><strong>4.1.1.配置分页插件</strong></h3><p>在项目中新建一个配置类：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705980258700-4c8de4e9-4dc7-455b-b608-e924034c14ac.png#averageHue=%23f9fbf8&clientId=uc58b97f9-a395-4&from=paste&id=PaeBj&originHeight=405&originWidth=896&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u367f4c69-5009-432f-9107-ad4c148b8e4&title="><br>其代码如下：<br>注意不要忘记了下面的@Configuration注解：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.itheima.mp.config;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.<span class="hljs-keyword">annotation</span>.DbType;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.<span class="hljs-keyword">inner</span>.PaginationInnerInterceptor;<span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Bean;<span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Configuration;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisConfig</span> &#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor mybatisPlusInterceptor() &#123;        <span class="hljs-comment">// 初始化核心插件</span>        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();        <span class="hljs-comment">// 添加分页插件</span>        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));        <span class="hljs-keyword">return</span> interceptor;    &#125;&#125;</code></pre></div><h3 id="4-1-2-分页API"><a href="#4-1-2-分页API" class="headerlink" title="4.1.2.分页API"></a><strong>4.1.2.分页API</strong></h3><p>编写一个分页查询的测试：</p><div class="code-wrapper"><pre><code class="hljs pgsql">@Test<span class="hljs-type">void</span> testPageQuery() &#123;    // <span class="hljs-number">1.</span>分页查询，<span class="hljs-built_in">new</span> Page()的两个参数分别是：页码、每页大小    Page&lt;<span class="hljs-keyword">User</span>&gt; p = userService.page(<span class="hljs-built_in">new</span> Page&lt;&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>));    // <span class="hljs-number">2.</span>总条数    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;total = &quot; + p.getTotal());    // <span class="hljs-number">3.</span>总页数    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;pages = &quot; + p.getPages());    // <span class="hljs-number">4.</span>数据    List&lt;<span class="hljs-keyword">User</span>&gt; records = p.getRecords();    records.<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>::println);&#125;</code></pre></div><p>运行的SQL如下：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705982335825-7802f5fa-5a4e-4d72-88d1-5e1e6dea399f.png#averageHue=%2326282c&clientId=uc58b97f9-a395-4&from=paste&height=478&id=uc760cf8c&originHeight=598&originWidth=1338&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=425307&status=done&style=none&taskId=u506701e7-7820-4a5e-bc4a-0c08fa0289f&title=&width=1070.4" alt="image.png"><br>这里用到了分页参数，Page，即可以支持分页参数，也可以支持排序参数。常见的API如下：</p><div class="code-wrapper"><pre><code class="hljs nsis">@Test    void testPageQueryOrder() &#123;        int pageNo = <span class="hljs-number">3</span>, pageSize = <span class="hljs-number">2</span><span class="hljs-comment">;</span>// 分页参数        <span class="hljs-keyword">Page</span>&lt;<span class="hljs-literal">User</span>&gt; <span class="hljs-keyword">page</span> = <span class="hljs-keyword">Page</span>.of(pageNo, pageSize)<span class="hljs-comment">;</span>// 排序参数, 通过OrderItem来指定        <span class="hljs-keyword">page</span>.addOrder(OrderItem.asc(<span class="hljs-string">&quot;balance&quot;</span>))<span class="hljs-comment">;</span>        <span class="hljs-keyword">Page</span>&lt;<span class="hljs-literal">User</span>&gt; p=userService.<span class="hljs-keyword">page</span>(<span class="hljs-keyword">page</span>)<span class="hljs-comment">;</span>        List&lt;<span class="hljs-literal">User</span>&gt; records = p.getRecords()<span class="hljs-comment">;</span>        records.forEach(<span class="hljs-params">System</span>.<span class="hljs-title function_">out::println</span>)<span class="hljs-comment">;</span>    &#125;&#125;</code></pre></div><h2 id="4-2-通用分页实体"><a href="#4-2-通用分页实体" class="headerlink" title="4.2.通用分页实体"></a><strong>4.2.通用分页实体</strong></h2><p>现在要实现一个用户分页查询的接口，接口规范如下：</p><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>请求方式</td><td>GET</td></tr><tr><td>请求路径</td><td>&#x2F;users&#x2F;page</td></tr><tr><td>请求参数</td><td>&#96;&#96;&#96;</td></tr><tr><td>{</td><td></td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs">&quot;pageNo&quot;: 1,&quot;pageSize&quot;: 5,&quot;sortBy&quot;: &quot;balance&quot;,&quot;isAsc&quot;: false,&quot;name&quot;: &quot;o&quot;,&quot;status&quot;: 1</code></pre></div><p>}</p><div class="code-wrapper"><pre><code class="hljs 1c"> <span class="hljs-string">|</span><span class="hljs-string">| 返回值 | ```</span>&#123;    <span class="hljs-string">&quot;total&quot;</span>: <span class="hljs-number">100006</span>,    <span class="hljs-string">&quot;pages&quot;</span>: <span class="hljs-number">50003</span>,    <span class="hljs-string">&quot;list&quot;</span>: [        &#123;            <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">1685100878975279298</span>,            <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;user_9****&quot;</span>,            <span class="hljs-string">&quot;info&quot;</span>: &#123;                <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">24</span>,                <span class="hljs-string">&quot;intro&quot;</span>: <span class="hljs-string">&quot;英文老师&quot;</span>,                <span class="hljs-string">&quot;gender&quot;</span>: <span class="hljs-string">&quot;female&quot;</span>            &#125;,            <span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;正常&quot;</span>,            <span class="hljs-string">&quot;balance&quot;</span>: <span class="hljs-number">2000</span>        &#125;    ]&#125;</code></pre></div><p> |<br>| 特殊说明 | </p><ul><li>如果排序字段为空，默认按照更新时间排序</li><li>排序字段不为空，则按照排序字段排序<br> |</li></ul><p>这里需要定义3个实体：</p><ul><li>UserQuery：分页查询条件的实体，包含分页、排序参数、过滤条件</li><li>PageDTO：分页结果实体，包含总条数、总页数、当前页数据</li><li>UserVO：用户页面视图实体</li></ul><h3 id="4-2-1-实体"><a href="#4-2-1-实体" class="headerlink" title="4.2.1.实体"></a><strong>4.2.1.实体</strong></h3><p>由于UserQuery之前已经定义过了，并且其中已经包含了过滤条件，具体代码如下：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.itheima.mp.domain.query;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModel;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModelProperty;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-meta">@ApiModel(description = <span class="hljs-string">&quot;用户查询条件实体&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserQuery</span> &#123;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;用户名关键字&quot;</span>)</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;用户状态：1-正常，2-冻结&quot;</span>)</span>    <span class="hljs-keyword">private</span> Integer status;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;余额最小值&quot;</span>)</span>    <span class="hljs-keyword">private</span> Integer minBalance;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;余额最大值&quot;</span>)</span>    <span class="hljs-keyword">private</span> Integer maxBalance;&#125;</code></pre></div><p>其中缺少的仅仅是分页条件，而分页条件不仅仅用户分页查询需要，以后其它业务也都有分页查询的需求。因此建议将分页查询条件单独定义为一个PageQuery实体：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705982946365-213d9c2d-1007-4676-a0f3-006903863076.png#averageHue=%23f9fbf8&clientId=uc58b97f9-a395-4&from=paste&id=ubdfd514f&originHeight=530&originWidth=842&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u97557790-4a94-4a71-80e3-e0413c41d19&title="><br>PageQuery是前端提交的查询参数，一般包含四个属性：</p><ul><li>pageNo：页码</li><li>pageSize：每页数据条数</li><li>sortBy：排序字段</li><li>isAsc：是否升序<div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ApiModel(description = <span class="hljs-string">&quot;分页查询实体&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageQuery</span> &#123;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;页码&quot;</span>)</span>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> pageNo;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;页码&quot;</span>)</span>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> pageSize;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;排序字段&quot;</span>)</span>    <span class="hljs-keyword">private</span> String sortBy;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;是否升序&quot;</span>)</span>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Boolean</span> isAsc;&#125;</code></pre></div>然后，让我们的UserQuery继承这个实体：<div class="code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.itheima.mp.domain.query;<span class="hljs-keyword">import</span> io.swagger.annotations.<span class="hljs-type">ApiModel</span>;<span class="hljs-keyword">import</span> io.swagger.annotations.<span class="hljs-type">ApiModelProperty</span>;<span class="hljs-keyword">import</span> lombok.<span class="hljs-type">Data</span>;<span class="hljs-keyword">import</span> lombok.<span class="hljs-type">EqualsAndHashCode</span>;<span class="hljs-meta">@EqualsAndHashCode</span>(callSuper = <span class="hljs-literal">true</span>)<span class="hljs-meta">@Data</span><span class="hljs-meta">@ApiModel</span>(description = <span class="hljs-string">&quot;用户查询条件实体&quot;</span>)public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserQuery</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PageQuery</span> </span>&#123;    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">&quot;用户名关键字&quot;</span>)    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> name;    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">&quot;用户状态：1-正常，2-冻结&quot;</span>)    <span class="hljs-keyword">private</span> <span class="hljs-type">Integer</span> status;    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">&quot;余额最小值&quot;</span>)    <span class="hljs-keyword">private</span> <span class="hljs-type">Integer</span> minBalance;    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">&quot;余额最大值&quot;</span>)    <span class="hljs-keyword">private</span> <span class="hljs-type">Integer</span> maxBalance;&#125;</code></pre></div>返回值的用户实体沿用之前定一个UserVO实体：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705982946305-c7813c4d-6144-4982-8eb9-7807479b450a.png#averageHue=%23f9fbf8&clientId=uc58b97f9-a395-4&from=paste&id=ubef00504&originHeight=440&originWidth=834&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ud2c5b538-2586-42eb-84af-ab2a2ddfbc8&title="><br>最后，则是分页实体PageDTO:<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705982946275-20df474d-bf03-421c-b42e-bfff8fa44fe3.png#averageHue=%23f9fbf8&clientId=uc58b97f9-a395-4&from=paste&id=u4bb1d438&originHeight=499&originWidth=900&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ub99d7679-e884-4ccd-a3f2-a09fc3b6ae7&title="><br>代码如下：<div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.itheima.mp.domain.dto;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModel;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModelProperty;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-meta">@Data</span><span class="hljs-meta">@ApiModel(description = <span class="hljs-string">&quot;分页结果&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageDTO</span>&lt;<span class="hljs-type">T</span>&gt; &#123;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;总条数&quot;</span>)</span>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> total;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;总页数&quot;</span>)</span>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> pages;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;集合&quot;</span>)</span>    <span class="hljs-keyword">private</span> List&lt;T&gt; list;&#125;</code></pre></div></li></ul><h3 id="4-2-2-开发接口"><a href="#4-2-2-开发接口" class="headerlink" title="4.2.2.开发接口"></a><strong>4.2.2.开发接口</strong></h3><p>我们在UserController中定义分页查询用户的接口：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.itheima.mp.controller;<span class="hljs-keyword">import</span> com.itheima.mp.domain.dto.PageDTO;<span class="hljs-keyword">import</span> com.itheima.mp.domain.query.PageQuery;<span class="hljs-keyword">import</span> com.itheima.mp.domain.vo.UserVO;<span class="hljs-keyword">import</span> com.itheima.mp.service.UserService;<span class="hljs-keyword">import</span> lombok.RequiredArgsConstructor;<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.GetMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestController;<span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping(<span class="hljs-string">&quot;users&quot;</span>)</span><span class="hljs-meta">@RequiredArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserService userService;    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/page&quot;</span>)</span>    <span class="hljs-keyword">public</span> PageDTO&lt;UserVO&gt; queryUsersPage(UserQuery query)&#123;        <span class="hljs-keyword">return</span> userService.queryUsersPage(query);    &#125;    <span class="hljs-comment">// 。。。 略</span>&#125;</code></pre></div><p>然后在IUserService中创建queryUsersPage方法：</p><div class="code-wrapper"><pre><code class="hljs erlang">PageDTO&lt;UserVO&gt; <span class="hljs-keyword">query</span>UsersPage(PageQuery <span class="hljs-keyword">query</span>);</code></pre></div><p>接下来，在UserServiceImpl中实现该方法：</p><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> PageDTO&lt;UserVO&gt; queryUsersPage(PageQuery query) &#123;    <span class="hljs-comment">// 1.构建条件</span>    <span class="hljs-comment">// 1.1.分页条件</span>    Page&lt;User&gt; page = Page.of(query.getPageNo(), query.getPageSize());    <span class="hljs-comment">// 1.2.排序条件</span>    <span class="hljs-keyword">if</span> (query.getSortBy() != <span class="hljs-literal">null</span>) &#123;        page.addOrder(<span class="hljs-keyword">new</span> <span class="hljs-type">OrderItem</span>(query.getSortBy(), query.getIsAsc()));    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-comment">// 默认按照更新时间排序</span>        page.addOrder(<span class="hljs-keyword">new</span> <span class="hljs-type">OrderItem</span>(<span class="hljs-string">&quot;update_time&quot;</span>, <span class="hljs-literal">false</span>));    &#125;    <span class="hljs-comment">// 2.查询</span>    page(page);    <span class="hljs-comment">// 3.数据非空校验</span>    List&lt;User&gt; records = page.getRecords();    <span class="hljs-keyword">if</span> (records == <span class="hljs-literal">null</span> || records.size() &lt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 无数据，返回空结果</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">PageDTO</span>&lt;&gt;(page.getTotal(), page.getPages(), Collections.emptyList());    &#125;    <span class="hljs-comment">// 4.有数据，转换</span>    List&lt;UserVO&gt; list = BeanUtil.copyToList(records, UserVO.class);    <span class="hljs-comment">// 5.封装返回</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">PageDTO</span>&lt;UserVO&gt;(page.getTotal(), page.getPages(), list);&#125;</code></pre></div><p> 启动项目，在页面查看：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705982946491-8d9ec7ae-8722-4dfa-84b5-ec4396913351.png#averageHue=%23f8f8fe&clientId=uc58b97f9-a395-4&from=paste&id=u72a864c9&originHeight=748&originWidth=749&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u955da69a-cdfd-4edd-9af0-c589a53b0d4&title="></p><h3 id="4-2-3-改造PageQuery实体"><a href="#4-2-3-改造PageQuery实体" class="headerlink" title="4.2.3.改造PageQuery实体"></a><strong>4.2.3.改造PageQuery实体</strong></h3><p>在刚才的代码中，从PageQuery到MybatisPlus的Page之间转换的过程还是比较麻烦的。<br> 我们完全可以在PageQuery这个实体中定义一个工具方法，简化开发。 像这样：</p><div class="code-wrapper"><pre><code class="hljs typescript">package com.<span class="hljs-property">itheima</span>.<span class="hljs-property">mp</span>.<span class="hljs-property">domain</span>.<span class="hljs-property">query</span>;<span class="hljs-keyword">import</span> com.<span class="hljs-property">baomidou</span>.<span class="hljs-property">mybatisplus</span>.<span class="hljs-property">core</span>.<span class="hljs-property">metadata</span>.<span class="hljs-property">OrderItem</span>;<span class="hljs-keyword">import</span> com.<span class="hljs-property">baomidou</span>.<span class="hljs-property">mybatisplus</span>.<span class="hljs-property">extension</span>.<span class="hljs-property">plugins</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">Page</span>;<span class="hljs-keyword">import</span> lombok.<span class="hljs-property">Data</span>;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageQuery</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Integer</span> pageNo;    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Integer</span> pageSize;    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> sortBy;    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Boolean</span> isAsc;    <span class="hljs-keyword">public</span> &lt;T&gt;  <span class="hljs-title class_">Page</span>&lt;T&gt; <span class="hljs-title function_">toMpPage</span>(<span class="hljs-params">OrderItem ... orders</span>)&#123;        <span class="hljs-comment">// 1.分页条件</span>        <span class="hljs-title class_">Page</span>&lt;T&gt; p = <span class="hljs-title class_">Page</span>.<span class="hljs-title function_">of</span>(pageNo, pageSize);        <span class="hljs-comment">// 2.排序条件</span>        <span class="hljs-comment">// 2.1.先看前端有没有传排序字段</span>        <span class="hljs-keyword">if</span> (sortBy != <span class="hljs-literal">null</span>) &#123;            p.<span class="hljs-title function_">addOrder</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderItem</span>(sortBy, isAsc));            <span class="hljs-keyword">return</span> p;        &#125;        <span class="hljs-comment">// 2.2.再看有没有手动指定排序字段</span>        <span class="hljs-keyword">if</span>(orders != <span class="hljs-literal">null</span>)&#123;            p.<span class="hljs-title function_">addOrder</span>(orders);        &#125;        <span class="hljs-keyword">return</span> p;    &#125;    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-title class_">Page</span>&lt;T&gt; <span class="hljs-title function_">toMpPage</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> defaultSortBy, <span class="hljs-built_in">boolean</span> isAsc</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toMpPage</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderItem</span>(defaultSortBy, isAsc));    &#125;    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-title class_">Page</span>&lt;T&gt; <span class="hljs-title function_">toMpPageDefaultSortByCreateTimeDesc</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-title function_">toMpPage</span>(<span class="hljs-string">&quot;create_time&quot;</span>, <span class="hljs-literal">false</span>);    &#125;    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-title class_">Page</span>&lt;T&gt; <span class="hljs-title function_">toMpPageDefaultSortByUpdateTimeDesc</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-title function_">toMpPage</span>(<span class="hljs-string">&quot;update_time&quot;</span>, <span class="hljs-literal">false</span>);    &#125;&#125;</code></pre></div><p>这样我们在开发也时就可以省去对从PageQuery到Page的的转换：</p><div class="code-wrapper"><pre><code class="hljs nsis">// <span class="hljs-number">1</span>.构建条件<span class="hljs-keyword">Page</span>&lt;<span class="hljs-literal">User</span>&gt; <span class="hljs-keyword">page</span> = query.toMpPageDefaultSortByCreateTimeDesc()<span class="hljs-comment">;</span></code></pre></div><h3 id="4-2-4-改造PageDTO实体"><a href="#4-2-4-改造PageDTO实体" class="headerlink" title="4.2.4.改造PageDTO实体"></a><strong>4.2.4.改造PageDTO实体</strong></h3><p>在查询出分页结果后，数据的非空校验，数据的vo转换都是模板代码，编写起来很麻烦。<br>我们完全可以将其封装到PageDTO的工具方法中，简化整个过程：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.mp.domain.dto;<span class="hljs-keyword">import</span> cn.hutool.core.bean.BeanUtil;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;<span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<span class="hljs-keyword">import</span> java.util.Collections;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.function.Function;<span class="hljs-keyword">import</span> java.util.stream.Collectors;<span class="hljs-meta">@Data</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageDTO</span>&lt;V&gt; &#123;    <span class="hljs-keyword">private</span> Long total;    <span class="hljs-keyword">private</span> Long pages;    <span class="hljs-keyword">private</span> List&lt;V&gt; list;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 返回空分页结果</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> p MybatisPlus的分页结果</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;V&gt; 目标VO类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;P&gt; 原始PO类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> VO的分页对象</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="hljs-title function_">empty</span><span class="hljs-params">(Page&lt;P&gt; p)</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), Collections.emptyList());    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将MybatisPlus分页结果转为 VO分页结果</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> p MybatisPlus的分页结果</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> voClass 目标VO类型的字节码</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;V&gt; 目标VO类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;P&gt; 原始PO类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> VO的分页对象</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(Page&lt;P&gt; p, Class&lt;V&gt; voClass)</span> &#123;        <span class="hljs-comment">// 1.非空校验</span>        List&lt;P&gt; records = p.getRecords();        <span class="hljs-keyword">if</span> (records == <span class="hljs-literal">null</span> || records.size() &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 无数据，返回空结果</span>            <span class="hljs-keyword">return</span> empty(p);        &#125;        <span class="hljs-comment">// 2.数据转换</span>        List&lt;V&gt; vos = BeanUtil.copyToList(records, voClass);        <span class="hljs-comment">// 3.封装返回</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), vos);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将MybatisPlus分页结果转为 VO分页结果，允许用户自定义PO到VO的转换方式</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> p MybatisPlus的分页结果</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> convertor PO到VO的转换函数</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;V&gt; 目标VO类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;P&gt; 原始PO类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> VO的分页对象</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(Page&lt;P&gt; p, Function&lt;P, V&gt; convertor)</span> &#123;        <span class="hljs-comment">// 1.非空校验</span>        List&lt;P&gt; records = p.getRecords();        <span class="hljs-keyword">if</span> (records == <span class="hljs-literal">null</span> || records.size() &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 无数据，返回空结果</span>            <span class="hljs-keyword">return</span> empty(p);        &#125;        <span class="hljs-comment">// 2.数据转换</span>        List&lt;V&gt; vos = records.stream().map(convertor).collect(Collectors.toList());        <span class="hljs-comment">// 3.封装返回</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), vos);    &#125;&#125;</code></pre></div><p>最终，业务层的代码可以简化为：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> PageDTO&lt;UserVO&gt; queryUserByPage(PageQuery query) &#123;    <span class="hljs-comment">// 1.构建条件</span>    Page&lt;User&gt; page = query.toMpPageDefaultSortByCreateTimeDesc();    <span class="hljs-comment">// 2.查询</span>    page(page);    <span class="hljs-comment">// 3.封装返回</span>    <span class="hljs-keyword">return</span> PageDTO.of(page, UserVO.<span class="hljs-keyword">class</span>);&#125;</code></pre></div><p>如果是希望自定义PO到VO的转换过程，可以这样做：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> PageDTO&lt;UserVO&gt; <span class="hljs-title function_">queryUserByPage</span><span class="hljs-params">(PageQuery query)</span> &#123;    <span class="hljs-comment">// 1.构建条件</span>    Page&lt;User&gt; page = query.toMpPageDefaultSortByCreateTimeDesc();    <span class="hljs-comment">// 2.查询</span>    page(page);    <span class="hljs-comment">// 3.封装返回</span>    <span class="hljs-keyword">return</span> PageDTO.of(page, user -&gt; &#123;        <span class="hljs-comment">// 拷贝属性到VO</span>        <span class="hljs-type">UserVO</span> <span class="hljs-variable">vo</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserVO.class);        <span class="hljs-comment">// 用户名脱敏</span>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> vo.getUsername();        vo.setUsername(username.substring(<span class="hljs-number">0</span>, username.length() - <span class="hljs-number">2</span>) + <span class="hljs-string">&quot;**&quot;</span>);        <span class="hljs-keyword">return</span> vo;    &#125;);&#125;</code></pre></div><p>最终查询的结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705982946301-b3ee830d-8b1f-4789-8e85-be8fef78530b.png#averageHue=%23f8f9fe&clientId=uc58b97f9-a395-4&from=paste&id=u0b1f8043&originHeight=761&originWidth=891&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u3925a6d3-72fc-4a78-a25a-f6ea9571e4a&title="></p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    <categories>
      
      <category>springboot3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>githubPage阿里云绑定域名</title>
    <link href="/2024/01/20/Github%20Pages%20%E7%BB%91%E5%AE%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D/"/>
    <url>/2024/01/20/Github%20Pages%20%E7%BB%91%E5%AE%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<h5 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h5><p><strong>CNAME:</strong></p><p><strong>使用场景</strong>：</p><div class="code-wrapper"><pre><code class="hljs dns">当需要将域名指向另一个域名，再由另一个域名提供 IP 地址，就需要添加 <span class="hljs-keyword">CNAME</span> 记录，最常用到 <span class="hljs-keyword">CNAME</span> 的场景包括做 CDN、企业邮箱、全局流量管理等。</code></pre></div><p><strong>设置方法</strong>:</p><div class="code-wrapper"><pre><code class="hljs dns">记录类型：选择 <span class="hljs-keyword">CNAME</span> 。主机记录：一般是指子域名的前缀（如需创建子域名为www.dns-example.com的解析, 主机记录输入 “ www” ；如需实现dns-example.com的解析，主机记录输入“@”）。解析线路：默认为必填项，否则会导致部分用户无法解析。记录值：记录值为 <span class="hljs-keyword">CNAME</span> 指向的域名，只可以填写域名。TTL：为缓存时间，数值越小，修改记录各地生效时间越快，默认为<span class="hljs-number">10</span>分钟。</code></pre></div><h5 id="Github-Pages-绑定阿里云域名："><a href="#Github-Pages-绑定阿里云域名：" class="headerlink" title="Github Pages 绑定阿里云域名："></a>Github Pages 绑定阿里云域名：</h5><p>1.阿里云购买的域名添加CNAME记录：</p><p><img src="/../images/image-20240120194744304-17058446004831.png" alt="image-20240120194744304"></p><p>2.在github page的页面添加域名：</p><p><img src="/../images/image-20240120194819452.png" alt="image-20240120194819452"></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis总结</title>
    <link href="/2024/01/16/mybits/"/>
    <url>/2024/01/16/mybits/</url>
    
    <content type="html"><![CDATA[<h1 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h1><p>1.mybatis是一款半自动的ORM框架</p><p>2.ORM是对象关系映射</p><h1 id="MyBatis的CRUD操作："><a href="#MyBatis的CRUD操作：" class="headerlink" title="MyBatis的CRUD操作："></a>MyBatis的CRUD操作：</h1><h2 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h2><p>标签：&lt; select id&#x3D;”” resultType&#x3D;”” &gt;</p><p>id与接口中的相关方法是同名的，表示该方法对应的mapper中的sql语句为上面的！</p><p>resultType是查询返回结果的类型！</p><h3 id="序号参数绑定："><a href="#序号参数绑定：" class="headerlink" title="序号参数绑定："></a>序号参数绑定：</h3><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;<span class="hljs-comment">//使用原生参数绑定</span>    <span class="hljs-keyword">public</span> User selectUserByIdAndPwd(Integer id , <span class="hljs-keyword">String</span> pwd);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserByIdAndPwd&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span></span><span class="language-xml">    SELECT * FROM t_users</span><span class="language-xml">    WHERE id = #</span><span class="hljs-template-variable">&#123;arg0&#125;</span><span class="language-xml"> AND password = #</span><span class="hljs-template-variable">&#123;arg1&#125;</span><span class="language-xml"> <span class="hljs-comment">&lt;!--arg0 arg1 arg2 ...--&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserByIdAndPwd&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span></span><span class="language-xml">SELECT * FROM t_users</span><span class="language-xml">    WHERE id = #</span><span class="hljs-template-variable">&#123;param1&#125;</span><span class="language-xml"> AND password = #</span><span class="hljs-template-variable">&#123;param2&#125;</span><span class="language-xml"> <span class="hljs-comment">&lt;!--param1 param2 param3 ...--&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span></code></pre></div><h3 id="注解参数绑定"><a href="#注解参数绑定" class="headerlink" title="注解参数绑定:"></a>注解参数绑定:</h3><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.ibatis</span><span class="hljs-selector-class">.annotations</span><span class="hljs-selector-class">.Param</span>; <span class="hljs-comment">//引入注解</span><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">interface</span> <span class="hljs-selector-tag">UserDao</span> &#123;    <span class="hljs-comment">//使用MyBatis提供的@Param进行参数绑定</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">User</span> <span class="hljs-selector-tag">selectUserByIdAndPwd</span>(<span class="hljs-variable">@Param</span>(<span class="hljs-string">&quot;id&quot;</span>) Integer id , <span class="hljs-variable">@Param</span>(<span class="hljs-string">&quot;pwd&quot;</span>) String pwd);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserByIdAndPwd&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span></span><span class="language-xml">    SELECT * FROM t_users</span><span class="language-xml">    WHERE id = #</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml"> AND password = #</span><span class="hljs-template-variable">&#123;pwd&#125;</span><span class="language-xml"> <span class="hljs-comment">&lt;!-- 使用注解值 @Param(&quot;pwd&quot;) --&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span></code></pre></div><h3 id="Map参数绑定"><a href="#Map参数绑定" class="headerlink" title="Map参数绑定:"></a>Map参数绑定:</h3><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">UserDao</span> &#123;    <span class="hljs-comment">//添加Map进行参数绑定</span><span class="hljs-keyword">public</span> User selectUserByIdAndPwd_map(Map values);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs maxima">Map <span class="hljs-built_in">values</span> = <span class="hljs-built_in">new</span> HashMap(); //测试类创建Map<span class="hljs-built_in">values</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;myId&quot;</span>,<span class="hljs-number">1</span>); //自定义<span class="hljs-built_in">key</span>，绑定参数<span class="hljs-built_in">values</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;myPwd&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);User user = userDao.selectUserByIdAndPwd_map(<span class="hljs-built_in">values</span>);</code></pre></div><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserByIdAndPwd_map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span></span><span class="language-xml">    SELECT * FROM t_users </span><span class="language-xml">  WHERE id = #</span><span class="hljs-template-variable">&#123;myId&#125;</span><span class="language-xml"> AND password = #</span><span class="hljs-template-variable">&#123;myPwd&#125;</span><span class="language-xml"> <span class="hljs-comment">&lt;!-- 通过key获得value --&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span></code></pre></div><h3 id="对象参数绑定"><a href="#对象参数绑定" class="headerlink" title="对象参数绑定:"></a>对象参数绑定:</h3><div class="code-wrapper"><pre><code class="hljs crmsh">public interface UserDao &#123;    //使用对象属性进行参数绑定    public <span class="hljs-keyword">User</span> <span class="hljs-title">selectUserByUserInfo</span>(<span class="hljs-keyword">User</span> <span class="hljs-title">user</span>);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserByUserInfo&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span></span><span class="language-xml">    SELECT * FROM t_users</span><span class="language-xml">    WHERE id = #</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml"> AND password = #</span><span class="hljs-template-variable">&#123;password&#125;</span><span class="language-xml"> <span class="hljs-comment">&lt;!-- #</span></span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml"><span class="hljs-comment">取User对象的id属性值、#</span></span><span class="hljs-template-variable">&#123;password&#125;</span><span class="language-xml"><span class="hljs-comment">同理 --&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span></code></pre></div><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询:"></a>模糊查询:</h3><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;User&gt; selectUsersByKeyword(<span class="hljs-meta">@Param</span>(<span class="hljs-string">&quot;keyword&quot;</span>) <span class="hljs-keyword">String</span> keyword);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.qf.mybatis.part1.different.UserDao&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUsersByKeyword&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span></span><span class="language-xml">        SELECT * FROM t_users </span><span class="language-xml">  WHERE name LIKE concat(&#x27;%&#x27;,#</span><span class="hljs-template-variable">&#123;keyword&#125;</span><span class="language-xml">,&#x27;%&#x27;) <span class="hljs-comment">&lt;!-- 拼接&#x27;%&#x27; --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span></code></pre></div><h2 id="删除"><a href="#删除" class="headerlink" title="删除:"></a>删除:</h2><p>标签：&lt; delete id&#x3D;”” parameterType&#x3D;”” &gt;</p><p>parameterType：指定sql语句中的参数类型</p><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span></span><span class="language-xml">    DELETE FROM t_users</span><span class="language-xml">    WHERE id = #</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml"> <span class="hljs-comment">&lt;!--只有一个参数时，#</span></span><span class="hljs-template-variable">&#123;任意书写&#125;</span><span class="language-xml"><span class="hljs-comment">--&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span></span></code></pre></div><h2 id="修改"><a href="#修改" class="headerlink" title="修改:"></a>修改:</h2><p>标签：&lt; update id&#x3D;”” parameterType&#x3D;”” &gt;</p><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span></span><span class="language-xml">    UPDATE t_users SET name=#</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml">, password=#</span><span class="hljs-template-variable">&#123;password&#125;</span><span class="language-xml">, sex=#</span><span class="hljs-template-variable">&#123;sex&#125;</span><span class="language-xml">, birthday=#</span><span class="hljs-template-variable">&#123;birthday&#125;</span><span class="language-xml"></span><span class="language-xml">    WHERE id = #</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml"> <span class="hljs-comment">&lt;!--方法参数为对象时，可直接使用#</span></span><span class="hljs-template-variable">&#123;属性名&#125;</span><span class="language-xml"><span class="hljs-comment">进行获取--&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></span></code></pre></div><h2 id="添加"><a href="#添加" class="headerlink" title="添加:"></a>添加:</h2><p>标签：&lt; insert id&#x3D;”” parameterType&#x3D;”” &gt;</p><p>这里的id和mapper相关接口同名，表示其相关方法对应！</p><div class="code-wrapper"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">insert</span> id=&quot;insertUser&quot; parameterType=&quot;user&quot;&gt;    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_users <span class="hljs-keyword">VALUES</span>(#&#123;id&#125;,#&#123;<span class="hljs-type">name</span>&#125;,#&#123;<span class="hljs-keyword">password</span>&#125;,#&#123;sex&#125;,#&#123;birthday&#125;,<span class="hljs-keyword">NULL</span>);&lt;/<span class="hljs-keyword">insert</span>&gt;</code></pre></div><h1 id="主键回填："><a href="#主键回填：" class="headerlink" title="主键回填："></a>主键回填：</h1><h2 id="通过last-insert-id-查询主键"><a href="#通过last-insert-id-查询主键" class="headerlink" title="通过last_insert_id()查询主键:"></a>通过last_insert_id()查询主键:</h2><p>标签：&lt; selectKey id&#x3D;”” parameterType&#x3D;”” order&#x3D;”AFTER|BEFORE”&gt;</p><p>一些情况下，新增一条数据信息，但其主键（id）是数据库自动在数据库生成（自增），而有些业务逻辑的处理是需要要到这个生成的主键（id）。上面的标签就是用来获取这个生成的主键（id）；</p><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;add&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.demo.pojo.User&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-comment">&lt;!--通过mybatis框架提供的selectKey标签获得自增产生的ID值--&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;AFTER&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span></span><span class="language-xml">select LAST_INSERT_ID()</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span></span><span class="language-xml">insert into user(code,name,remark,sex)</span><span class="language-xml">values</span><span class="language-xml">(#</span><span class="hljs-template-variable">&#123;code&#125;</span><span class="language-xml">,#</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml">,#</span><span class="hljs-template-variable">&#123;remark&#125;</span><span class="language-xml">,#</span><span class="hljs-template-variable">&#123;sex&#125;</span><span class="language-xml">)</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span></code></pre></div><p>1.selectKey 会将 SELECT LAST_INSERT_ID()的结果放入到传入的model的主键里面，即获取数据库里自动生成的id。</p><p>2.keyProperty：对应的model（这里的model就是User对象，这里表示User对象中的id对应数据库中的id）中的主键的属性名，跟数据库的主键对应。</p><p>3.order：AFTER 表示 SELECT LAST_INSERT_ID() 在insert执行之后执行,多用与自增主键；</p><p>4.BEFORE 表示 SELECT LAST_INSERT_ID() 在insert执行之前执行，这样的话就拿不到主键了，适合那种主键不是自增的类型<br>resultType：主键类型；</p><p>测试：</p><div class="code-wrapper"><pre><code class="hljs xquery"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;add&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.demo.pojo.User&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-comment">&lt;!--通过mybatis框架提供的selectKey标签获得自增产生的ID值；下面标签的意思是将插入后的主键值赋值给model也就是User的id--&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;AFTER&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span></span><span class="language-xml">select LAST_INSERT_ID()</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">insert into user(code,name,remark,sex)</span><span class="language-xml">values</span><span class="language-xml">(#</span><span class="language-xquery">&#123;code&#125;</span><span class="language-xml">,#</span><span class="language-xquery"><span class="hljs-built_in">&#123;name</span>&#125;</span><span class="language-xml">,#</span><span class="language-xquery">&#123;remark&#125;</span><span class="language-xml">,#</span><span class="language-xquery">&#123;sex&#125;</span><span class="language-xml">)</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span>UserServiceImpl:@Overridepublic void add(User user) &#123;//新增UserDao.add(user);Integer userId = user.getId();//其查询结果的主键值是赋值给model也就是User<span class="hljs-built_in">的id</span>的！System.out.println(<span class="hljs-string">&quot;添加信息的id为：&quot;</span> + userId);</code></pre></div><h2 id="通过uuid-查询主键："><a href="#通过uuid-查询主键：" class="headerlink" title="通过uuid()查询主键："></a>通过uuid()查询主键：</h2><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_order(  id <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">primary key</span>, # 字符型主键  <span class="hljs-type">name</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>))<span class="hljs-keyword">default</span> charset = utf8;</code></pre></div><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> id;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name;    <span class="hljs-comment">//set+get ...</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.qf.mybatis.part1.basic.OrderDao&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertOrder&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;order&quot;</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;BEFORE&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 插入之前,之所以选择插入之前是因为我们的目的是先生成UUID然后把该uuid作为主键插入到表中 --&gt;</span></span><span class="language-xml">            SELECT REPLACE(UUID(),&#x27;-&#x27;,&#x27;&#x27;) </span><span class="language-xml">            <span class="hljs-comment">&lt;!-- 适用于字符类型主键 ;</span></span><span class="hljs-comment"><span class="language-xml">            SELECT REPLACE(UUID(),&#x27;-&#x27;,&#x27;&#x27;)：这是实际的SQL语句。它使用MySQL的UUID()函数生成一个通用唯一标识符（UUID），然后使用REPLACE()函数将其中的破折号（-）替换为空字符串，从而生成一个没有破折号的字符串类型的主键。--&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span></span><span class="language-xml">        INSERT INTO t_order(id,name) VALUES(#</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml">,#</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml">)</span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span></code></pre></div><h1 id="MyBatis自动（反射-get和set）ORM失效："><a href="#MyBatis自动（反射-get和set）ORM失效：" class="headerlink" title="MyBatis自动（反射  get和set）ORM失效："></a><strong>MyBatis自动（反射  get和set）ORM失效：</strong></h1><p>MyBatis只能自动维护库表”列名“与”属性名“相同时的一一对应关系，二者不同时，无法自动ORM。</p><p><img src="/../images/image-20240121190543443-17058454788323.png" alt="image-20240121190543443"></p><h2 id="方案一：列的别名"><a href="#方案一：列的别名" class="headerlink" title="方案一：列的别名:"></a>方案一：列的别名:</h2><p>在SQL中使用 as 为查询字段添加列别名，以匹配属性名。</p><div class="code-wrapper"><pre><code class="hljs pgsql">&lt;mapper namespace=&quot;com.qf.mybatis.part2.orm.ManagerDao&quot;&gt;    &lt;<span class="hljs-keyword">select</span> id=&quot;selectManagerByIdAndPwd&quot; resultType=&quot;com.qf.mybatis.part2.orm.Manager&quot;&gt;        <span class="hljs-keyword">SELECT</span> mgr_id <span class="hljs-keyword">AS</span> id , mgr_name <span class="hljs-keyword">AS</span> username , mgr_pwd <span class="hljs-keyword">AS</span> <span class="hljs-keyword">password</span>        <span class="hljs-keyword">FROM</span> t_managers        <span class="hljs-keyword">WHERE</span> mgr_id = #&#123;id&#125; <span class="hljs-keyword">AND</span> mgr_pwd = #&#123;pwd&#125;    &lt;/<span class="hljs-keyword">select</span>&gt;&lt;/mapper&gt;</code></pre></div><h2 id="方案二：结果映射（ResultMap-查询结果的封装规则）"><a href="#方案二：结果映射（ResultMap-查询结果的封装规则）" class="headerlink" title="方案二：结果映射（ResultMap - 查询结果的封装规则）:"></a>方案二：结果映射（ResultMap - 查询结果的封装规则）:</h2><p>通过&lt; resultMap id&#x3D;”” type&#x3D;”” &gt;映射，匹配列名与属性名。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.qf.mybatis.part2.orm.ManagerDao&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!--定义resultMap标签--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;managerResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.qf.mybatis.part2.orm.Manager&quot;</span>&gt;</span>      <span class="hljs-comment">&lt;!--关联主键与列名--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;mgr_id&quot;</span> /&gt;</span>      <span class="hljs-comment">&lt;!--关联属性与列名--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;mgr_name&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;mgr_pwd&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>     <span class="hljs-comment">&lt;!--使用resultMap作为ORM映射依据--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAllManagers&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;managerResultMap&quot;</span>&gt;</span>        SELECT mgr_id , mgr_name , mgr_pwd        FROM t_managers    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><h1 id="MyBatis处理关联关系-多表连接"><a href="#MyBatis处理关联关系-多表连接" class="headerlink" title="MyBatis处理关联关系-多表连接:"></a>MyBatis处理关联关系-多表连接:</h1><h2 id="使用对象关系查询"><a href="#使用对象关系查询" class="headerlink" title="使用对象关系查询:"></a>使用对象关系查询:</h2><h3 id="OneToOne"><a href="#OneToOne" class="headerlink" title="OneToOne:"></a>OneToOne:</h3><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.qf.mybatis.part2.one2one.PassengerDao&quot;</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">  <span class="hljs-comment">&lt;!-- 结果映射（查询结果的封装规则） --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;passengerResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.qf.mybatis.part2.one2one.Passenger&quot;</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> /&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span> /&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;birthday&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;birthday&quot;</span> /&gt;</span></span><span class="language-xml"></span><span class="language-xml">      <span class="hljs-comment">&lt;!-- 关系表中数据的封装规则 --&gt;</span> <span class="hljs-comment">&lt;!-- 指定关系表的实体类型 --&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;passport&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;com.qf.mybatis.part2.one2one.Passport&quot;</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;passport_id&quot;</span> /&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;nationality&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;nationality&quot;</span> /&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;expire&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;expire&quot;</span> /&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;passenger_id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;passenger_id&quot;</span> /&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">  <span class="hljs-comment">&lt;!-- 多表连接查询 --&gt;</span>  <span class="hljs-comment">&lt;!-- 结果映射（查询结果的封装规则）--&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectPassengerById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;passengerResultMap&quot;</span>&gt;</span></span><span class="language-xml">        <span class="hljs-comment">&lt;!-- 别名（避免与p1.id冲突） --&gt;</span></span><span class="language-xml">        SELECT p1.id , p1.name , p1.sex , p1.birthday , p2.id as passport_id , p2.nationality , p2.expire , p2.passenger_id</span><span class="language-xml">        FROM t_passengers p1 LEFT JOIN t_passports p2</span><span class="language-xml">        ON p1.id = p2.passenger_id</span><span class="language-xml">        WHERE p1.id = #</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml"></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span></code></pre></div><ul><li>注意：指定“一方”关系时（对象），使用&lt; association javaType&#x3D;”” &gt;</li></ul><h3 id="OneToMany"><a href="#OneToMany" class="headerlink" title="OneToMany:"></a>OneToMany:</h3><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.qf.mybatis.part2.one2many.DepartmentDao&quot;</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">  <span class="hljs-comment">&lt;!-- 封装规则 --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;departmentResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.qf.mybatis.part2.one2many.Department&quot;</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> /&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> /&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;location&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;location&quot;</span> /&gt;</span></span><span class="language-xml">        </span><span class="language-xml">      <span class="hljs-comment">&lt;!-- 关系表中数据的封装规则 --&gt;</span><span class="hljs-comment">&lt;!-- 指定关系表的实体类型 --&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;emps&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;com.qf.mybatis.part2.one2many.Employee&quot;</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_id&quot;</span> /&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_name&quot;</span> /&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;salary&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;salary&quot;</span> /&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept_id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span> /&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></span><span class="language-xml">  <span class="hljs-comment">&lt;!-- 多表连接查询 --&gt;</span>      <span class="hljs-comment">&lt;!-- 封装规则 --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectDepartmentById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;departmentResultMap&quot;</span> &gt;</span></span><span class="language-xml">      <span class="hljs-comment">&lt;!-- 别名（避免与d.id、d.name冲突）--&gt;</span></span><span class="language-xml">        SELECT d.id , d.name , d.location , e.id AS emp_id , e.name emp_name , e.salary , e.dept_id</span><span class="language-xml">        FROM t_departments d LEFT JOIN t_employees e</span><span class="language-xml">        ON d.id = e.dept_id</span><span class="language-xml">        WHERE d.id = #</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml"></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span></code></pre></div><ul><li>注意：指定“多方”关系时（集合），使用&lt; collection ofType&#x3D;”” &gt;</li></ul><h3 id="关系总结"><a href="#关系总结" class="headerlink" title="关系总结:"></a>关系总结:</h3><h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL:"></a>动态SQL:</h1><h2 id="sql"><a href="#sql" class="headerlink" title="&lt; sql &gt;:"></a>&lt; sql &gt;:</h2><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.qf.mybatis.part2.dynamic.BookDao&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BOOKS_FIELD&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!-- 定义SQL片段 --&gt;</span>        SELECT id,name,author,publish,sort    <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectBookByCondition&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.qf.mybatis.part2.dynamic.Book&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;BOOKS_FIELD&quot;</span> /&gt;</span> <span class="hljs-comment">&lt;!-- 通过ID引用SQL片段 --&gt;</span>        FROM t_books    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><h2 id="if"><a href="#if" class="headerlink" title="&lt; if &gt;:"></a>&lt; if &gt;:</h2><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectBookByCondition&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.qf.mybatis.part2.dynamic.Book&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;BOOKS_FIELD&quot;</span> /&gt;</span> <span class="hljs-comment">&lt;!-- 通过ID引用SQL片段 --&gt;</span></span><span class="language-xml">    FROM t_books</span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name!=null&quot;</span>&gt;</span></span><span class="language-xml">        name=#</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml"></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author!=null&quot;</span>&gt;</span></span><span class="language-xml">        and author=#</span><span class="hljs-template-variable">&#123;author&#125;</span><span class="language-xml"></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span></code></pre></div><h2 id="where"><a href="#where" class="headerlink" title="&lt; where &gt;:"></a>&lt; where &gt;:</h2><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectBookByCondition&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.qf.mybatis.part2.dynamic.Book&quot;</span>&gt;</span></span><span class="language-xml">    SELECT id , name , author , publish , sort</span><span class="language-xml">    FROM t_books</span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span> </span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;id != null&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!-- WHERE，会自动忽略前后缀（如：and | or） --&gt;</span></span><span class="language-xml">            id = #</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span></span><span class="language-xml">            and name = #</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span></span><span class="language-xml">            and author = #</span><span class="hljs-template-variable">&#123;author&#125;</span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;publish != null&quot;</span>&gt;</span></span><span class="language-xml">            and publish = #</span><span class="hljs-template-variable">&#123;publish&#125;</span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sort != null&quot;</span>&gt;</span></span><span class="language-xml">            and sort = #</span><span class="hljs-template-variable">&#123;sort&#125;</span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span></code></pre></div><h2 id="set"><a href="#set" class="headerlink" title="&lt; set &gt;:"></a>&lt; set &gt;:</h2><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateBookByCondition&quot;</span>&gt;</span></span><span class="language-xml">    UPDATE t_books</span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- where子句中满足条件的if，会自动忽略后缀（如：,） --&gt;</span></span><span class="language-xml">            name = #</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml"> ,</span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span></span><span class="language-xml">            author = #</span><span class="hljs-template-variable">&#123;author&#125;</span><span class="language-xml"> ,</span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;publish != null&quot;</span>&gt;</span></span><span class="language-xml">            publish = #</span><span class="hljs-template-variable">&#123;publish&#125;</span><span class="language-xml"> ,</span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sort != null&quot;</span>&gt;</span></span><span class="language-xml">            sort = #</span><span class="hljs-template-variable">&#123;sort&#125;</span><span class="language-xml"> ,</span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span></span><span class="language-xml">    WHERE id = #</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></span></code></pre></div><h2 id="trim"><a href="#trim" class="headerlink" title="&lt; trim &gt;:"></a>&lt; trim &gt;:</h2><p>&lt; trim prefix&#x3D;”” suffix&#x3D;”” prefixOverrides&#x3D;”” suffixOverrides&#x3D;”” &gt;代替&lt; where &gt; 、&lt; set &gt;</p><p>prefix:表示该字段的前缀； suffix：表示要去除多余的前缀； suffixOverrides：表示要去除多余的后缀；</p><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectBookByCondition&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.qf.mybatis.day2.dynamic.Book&quot;</span>&gt;</span></span><span class="language-xml">SELECT id,name,author,publish,sort</span><span class="language-xml">    FROM t_books</span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;WHERE&quot;</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">&quot;AND|OR&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!-- 增加WHERE前缀，自动忽略前缀 --&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;id != null&quot;</span>&gt;</span></span><span class="language-xml">            and id = #</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span></span><span class="language-xml">            and name = #</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span></span><span class="language-xml">            and author = #</span><span class="hljs-template-variable">&#123;author&#125;</span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;publish != null&quot;</span>&gt;</span></span><span class="language-xml">            and publish = #</span><span class="hljs-template-variable">&#123;publish&#125;</span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sort != null&quot;</span>&gt;</span></span><span class="language-xml">            and sort = #</span><span class="hljs-template-variable">&#123;sort&#125;</span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateBookByCondition&quot;</span>&gt;</span></span><span class="language-xml">UPDATE t_books</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;SET&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!-- 增加SET前缀，自动忽略后缀 --&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span></span><span class="language-xml">name = #</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml"> ,</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span></span><span class="language-xml">author = #</span><span class="hljs-template-variable">&#123;author&#125;</span><span class="language-xml"> ,</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;publish != null&quot;</span>&gt;</span></span><span class="language-xml">publish = #</span><span class="hljs-template-variable">&#123;publish&#125;</span><span class="language-xml"> ,</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sort != null&quot;</span>&gt;</span></span><span class="language-xml">sort = #</span><span class="hljs-template-variable">&#123;sort&#125;</span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span></span><span class="language-xml">WHERE id = #</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></span></code></pre></div><h2 id="foreach"><a href="#foreach" class="headerlink" title="&lt; foreach &gt;:"></a>&lt; foreach &gt;:</h2><div class="code-wrapper"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">delete</span> id=&quot;deleteBookByIds&quot;&gt;<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> t_books<span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IN</span>&lt;<span class="hljs-keyword">foreach</span> collection=&quot;list&quot; <span class="hljs-keyword">open</span>=&quot;(&quot; separator=&quot;,&quot; <span class="hljs-keyword">close</span>=&quot;)&quot;  item=&quot;id&quot; <span class="hljs-keyword">index</span>=&quot;i&quot;&gt;#&#123;id&#125;&lt;/<span class="hljs-keyword">foreach</span>&gt;&lt;/<span class="hljs-keyword">delete</span>&gt;</code></pre></div><table><thead><tr><th>参数</th><th>描述</th><th>取值</th></tr></thead><tbody><tr><td>collection</td><td>容器类型</td><td>list、array、map</td></tr><tr><td>open</td><td>起始符</td><td>(</td></tr><tr><td>close</td><td>结束符</td><td>)</td></tr><tr><td>separator</td><td>分隔符</td><td>,</td></tr><tr><td>index</td><td>下标号</td><td>从0开始，依次递增</td></tr><tr><td>item</td><td>当前项</td><td>任意名称（循环中通过 #{任意名称} 表达式访问）</td></tr></tbody></table><h1 id="缓存（Cache）"><a href="#缓存（Cache）" class="headerlink" title="缓存（Cache）:"></a>缓存（Cache）:</h1><p>内存中的一块存储空间，服务于某个应用程序，旨在将频繁读取的数据临时保存在内存中，便于二次快速访问。</p><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存:"></a>一级缓存:</h2><p>SqlSession级别的缓存，同一个SqlSession的发起多次同构查询，会将数据保存在一级缓存中。</p><ul><li>注意：无需任何配置，默认开启一级缓存。</li></ul><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存:"></a>二级缓存:</h2><p>SqlSessionFactory级别的缓存，同一个SqlSessionFactory构建的SqlSession发起的多次同构查询，会将数据保存在二级缓存中。</p><ul><li>注意：在sqlSession.commit()或者sqlSession.close()之后生效。</li><li>二级缓存：没有默认开启，需要手动开启，其存储的范围是Mapper NameSpace。即，其范围是Mapper映射器的某个命名空间</li></ul><h2 id="开启全局缓存"><a href="#开启全局缓存" class="headerlink" title="开启全局缓存:"></a>开启全局缓存:</h2><p>&lt; settings &gt;是MyBatis中极为重要的调整设置，他们会改变MyBatis的运行行为，其他详细配置可参考官方文档。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">...</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 注意书写位置 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!-- mybaits-config.xml中开启全局缓存（默认开启） --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div><h1 id="八股文："><a href="#八股文：" class="headerlink" title="八股文："></a>八股文：</h1><h2 id="和-的区别是什么？："><a href="#和-的区别是什么？：" class="headerlink" title="**#{}和${}**的区别是什么？："></a>**#{}<strong>和</strong>${}**的区别是什么？：</h2><p>#{}是预编译处理，${}是字符串替换。使用#{}可以有效的防止SQL注入，提高系统安全性。</p><h2 id="模糊查询like语句该怎么写-："><a href="#模糊查询like语句该怎么写-：" class="headerlink" title="模糊查询like语句该怎么写**?**："></a>模糊查询<strong>like</strong>语句该怎么写**?**：</h2><p>1.让传递的参数为模糊处理过的：</p><p><img src="/../images/image-20240121205328569.png" alt="image-20240121205328569"></p><p>2.在mapper查询的时候使用函数：</p><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.qf.mybatis.part1.different.UserDao&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUsersByKeyword&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span></span><span class="language-xml">        SELECT * FROM t_users </span><span class="language-xml">  WHERE name LIKE concat(&#x27;%&#x27;,#</span><span class="hljs-template-variable">&#123;keyword&#125;</span><span class="language-xml">,&#x27;%&#x27;) <span class="hljs-comment">&lt;!-- 拼接&#x27;%&#x27; --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span></code></pre></div><h2 id="分页插件："><a href="#分页插件：" class="headerlink" title="分页插件："></a>分页插件：</h2><p>分页插件针对ResultSet结果集执行的内存分页，而非物理分 页。分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截 待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p><h2 id="延迟加载："><a href="#延迟加载：" class="headerlink" title="延迟加载："></a>延迟加载：</h2><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加 载lazyLoadingEnabled&#x3D;true|false。</p><p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如    调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接   着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p><p><strong>延迟加载</strong>：在真正使用数据的时候才发起查询，不用的时候不查询关联的数据，延迟加载又叫按需查询（懒加载）</p><p><strong>立即加载</strong>：不管用不用，只要一调用方法，马上发起查询。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo flouid总结</title>
    <link href="/2024/01/16/hexo%20flouid%E6%80%BB%E7%BB%93%EF%BC%9A/"/>
    <url>/2024/01/16/hexo%20flouid%E6%80%BB%E7%BB%93%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705318631263-a44e3cf7-bf2f-481e-bd67-b509b234a07d.png?x-oss-process=image/resize,w_706,limit_0#averageHue=%233e3753&from=url&id=OXEIR&originHeight=622&originWidth=706&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></h1><h1 id="常见操作："><a href="#常见操作：" class="headerlink" title="常见操作："></a>常见操作：</h1><div class="code-wrapper"><pre><code class="hljs python">语雀导出markdown然后在发布的时候！可以先不写标题！导出为markdown后在篇头就可以写标题了，不然无法写标题。</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 清除缓存文件</span>hexo clean<span class="hljs-comment">#  生成静态文件 </span> hexo g <span class="hljs-comment"># 部署网站</span>hexo d</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">---title: 文章标题categories: [分类名称]tags: [标签<span class="hljs-number">1</span>, 标签<span class="hljs-number">2</span>]---</code></pre></div><h1 id="基础教程："><a href="#基础教程：" class="headerlink" title="基础教程："></a>基础教程：</h1><p><a href="https://blog.csdn.net/weixin_51545953/article/details/128499341">【个人博客】Hexo个人博客搭建与配置详细教程 + Fluid主题 + Gitee发布_fluid文章页设置-CSDN博客</a><br>ps:想修改某些配置可以在_config.yml配置文件中根据想修改部位特征的关键字查询。</p><h1 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h1><h3 id="1-使用Valine评论无法正常评论："><a href="#1-使用Valine评论无法正常评论：" class="headerlink" title="1.使用Valine评论无法正常评论："></a>1.使用Valine评论无法正常评论：</h3><p>原因：<br>1.修改Valine配置的时候没有注意appid和后面的值要有空格。<br>2.要在LeanCloud的数据储存中创建Comment类</p> <meta name="referrer" content="no-referrer"><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705325322444-95551c58-54e5-4f30-b743-8d13d62fba77.png#averageHue=%23c5c5c5&clientId=u4f2c0d6f-91a8-4&from=paste&height=442&id=u82d94f4a&originHeight=553&originWidth=971&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=77012&status=done&style=none&taskId=ub10de5ff-5e77-48e5-a801-adfcf2cf6e9&title=&width=776.8" alt="image.png"><br><a href="https://console.leancloud.cn/apps/NkSNF5NG3Uup8tDgwIfBlJ9d-gzGzoHsz/">LeanCloud</a></p><h3 id="2-上传的md文档使用了外部图片链接导致博客页面加载不出来报403错误（特别是语雀导为md文档时照片报403）："><a href="#2-上传的md文档使用了外部图片链接导致博客页面加载不出来报403错误（特别是语雀导为md文档时照片报403）：" class="headerlink" title="2.上传的md文档使用了外部图片链接导致博客页面加载不出来报403错误（特别是语雀导为md文档时照片报403）："></a>2.上传的md文档使用了外部图片链接导致博客页面加载不出来报403错误（特别是语雀导为md文档时照片报403）：</h3><p>原因：是语雀设置防盗链策略，不允许图片被其他域名引用。<br>解决方法：<br>方法一.在不能显示的md文档前添加</p><div class="code-wrapper"><pre><code class="hljs python">&lt;meta name=<span class="hljs-string">&quot;referrer&quot;</span> content=<span class="hljs-string">&quot;no-referrer&quot;</span>&gt;</code></pre></div><p>方法二：在全局CSS或者主题的某个样式表中（如layout&#x2F;_partials&#x2F;head.ejs）设置默认的referrer策略，也就是在layout&#x2F;_partials&#x2F;head.ejs中的head标签添加如下代码：</p><div class="code-wrapper"><pre><code class="hljs python">&lt;meta name=<span class="hljs-string">&quot;referrer&quot;</span> content=<span class="hljs-string">&quot;no-referrer&quot;</span>&gt;</code></pre></div><p>上面2种方法都需要执行hexo g命令启动后才能显示！直接是无法显示的！</p><h3 id="3-代码高亮使用了highlightjs库，就不用开启行号的功能了，不然md文档中的代码无法正常换行，显示在一行。"><a href="#3-代码高亮使用了highlightjs库，就不用开启行号的功能了，不然md文档中的代码无法正常换行，显示在一行。" class="headerlink" title="3.代码高亮使用了highlightjs库，就不用开启行号的功能了，不然md文档中的代码无法正常换行，显示在一行。"></a>3.代码高亮使用了highlightjs库，就不用开启行号的功能了，不然md文档中的代码无法正常换行，显示在一行。</h3><h3 id="4-在md中设置的文档标题无法在博客中显示的，需要在文章头部添加如下信息："><a href="#4-在md中设置的文档标题无法在博客中显示的，需要在文章头部添加如下信息：" class="headerlink" title="4.在md中设置的文档标题无法在博客中显示的，需要在文章头部添加如下信息："></a>4.在md中设置的文档标题无法在博客中显示的，需要在文章头部添加如下信息：</h3><div class="code-wrapper"><pre><code class="hljs python">---title: 文章标题categories: [分类名称]tags: [标签<span class="hljs-number">1</span>, 标签<span class="hljs-number">2</span>]---</code></pre></div><h3 id="5-每次上传文章后，githubpage绑定的域名消失："><a href="#5-每次上传文章后，githubpage绑定的域名消失：" class="headerlink" title="5.每次上传文章后，githubpage绑定的域名消失："></a>5.每次上传文章后，githubpage绑定的域名消失：</h3><p>在 <code>hexo</code> 生成的博客的 <code>source</code> 目录下新建一个 <code>CNAME</code> 文件，然后在这个文件中填入你的域名</p><p><img src="/../images/70.png" alt="这里写图片描述"></p><h3 id="6-上传的长文章无法显示："><a href="#6-上传的长文章无法显示：" class="headerlink" title="6.上传的长文章无法显示："></a>6.上传的长文章无法显示：</h3><p>个人原因是上传的markdown文档中有一个表格！该表格hexo自带的markdown渲染器无法渲染导致该表格后的内容都无法显示！</p><h1 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h1> <meta name="referrer" content="no-referrer"><p><img src="https://cdn.nlark.com/yuque/0/2024/gif/28066124/1705318498223-08e05c5d-94d0-462b-a6af-740ded57795b.gif#averageHue=%2301356b&clientId=ufca4afba-4b97-4&from=paste&id=FOjx3&originHeight=280&originWidth=476&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ua55ddca9-4504-4386-bffd-3229798bd17&title="></p><h3 id="1-为了更好的管理博客可以安装：npm-install-–save-hexo-admin；"><a href="#1-为了更好的管理博客可以安装：npm-install-–save-hexo-admin；" class="headerlink" title="1.为了更好的管理博客可以安装：npm install –save hexo-admin；"></a>1.为了更好的管理博客可以安装：npm install –save hexo-admin；</h3><h3 id="2-添加网站运行时间："><a href="#2-添加网站运行时间：" class="headerlink" title="2.添加网站运行时间："></a>2.添加网站运行时间：</h3><p>页脚添加网站运行时间，只需要在主题配置中的 footer: content 添加：</p><div class="code-wrapper"><pre><code class="hljs python">footer:  content: <span class="hljs-string">&#x27;</span><span class="hljs-string">    &lt;div&gt;</span><span class="hljs-string">      &lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;</span><span class="hljs-string">      &lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;</span><span class="hljs-string">      &lt;script src=&quot;/js/duration.js&quot;&gt;&lt;/script&gt;</span><span class="hljs-string">    &lt;/div&gt;</span><span class="hljs-string">  &#x27;</span></code></pre></div><p>之后在主题目录下创建 source&#x2F;js&#x2F;duration.js，内容如下：</p><div class="code-wrapper"><pre><code class="hljs python">var now = new Date();function createtime() &#123;    var grt= new Date(<span class="hljs-string">&quot;03/03/2021 12:00:00&quot;</span>);//在此处修改你的建站时间    now.setTime(now.getTime()+<span class="hljs-number">250</span>);    days = (now - grt ) / <span class="hljs-number">1000</span> / <span class="hljs-number">60</span> / <span class="hljs-number">60</span> / <span class="hljs-number">24</span>; dnum = Math.floor(days);    hours = (now - grt ) / <span class="hljs-number">1000</span> / <span class="hljs-number">60</span> / <span class="hljs-number">60</span> - (<span class="hljs-number">24</span> * dnum); hnum = Math.floor(hours);    <span class="hljs-keyword">if</span>(String(hnum).length ==<span class="hljs-number">1</span> )&#123;hnum = <span class="hljs-string">&quot;0&quot;</span> + hnum;&#125; minutes = (now - grt ) / <span class="hljs-number">1000</span> /<span class="hljs-number">60</span> - (<span class="hljs-number">24</span> * <span class="hljs-number">60</span> * dnum) - (<span class="hljs-number">60</span> * hnum);    mnum = Math.floor(minutes); <span class="hljs-keyword">if</span>(String(mnum).length ==<span class="hljs-number">1</span> )&#123;mnum = <span class="hljs-string">&quot;0&quot;</span> + mnum;&#125;    seconds = (now - grt ) / <span class="hljs-number">1000</span> - (<span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * dnum) - (<span class="hljs-number">60</span> * <span class="hljs-number">60</span> * hnum) - (<span class="hljs-number">60</span> * mnum);    snum = Math.<span class="hljs-built_in">round</span>(seconds); <span class="hljs-keyword">if</span>(String(snum).length ==<span class="hljs-number">1</span> )&#123;snum = <span class="hljs-string">&quot;0&quot;</span> + snum;&#125;    document.getElementById(<span class="hljs-string">&quot;timeDate&quot;</span>).innerHTML = <span class="hljs-string">&quot;本站已安全运行 &quot;</span>+dnum+<span class="hljs-string">&quot; 天 &quot;</span>;    document.getElementById(<span class="hljs-string">&quot;times&quot;</span>).innerHTML = hnum + <span class="hljs-string">&quot; 小时 &quot;</span> + mnum + <span class="hljs-string">&quot; 分 &quot;</span> + snum + <span class="hljs-string">&quot; 秒&quot;</span>;&#125;setInterval(<span class="hljs-string">&quot;createtime()&quot;</span>,<span class="hljs-number">250</span>);</code></pre></div><h3 id="3-添加一言："><a href="#3-添加一言：" class="headerlink" title="3.添加一言："></a>3.添加一言：</h3><p>修改_config.yml的slogan配置为如下：</p><div class="code-wrapper"><pre><code class="hljs python">slogan:  enable: true  <span class="hljs-comment"># 为空则按 hexo config.subtitle 显示</span>  <span class="hljs-comment"># If empty, text based on `subtitle` in hexo config</span>  text: <span class="hljs-string">&quot;太阳初升之时！你会回想起曾经的自己吗？&quot;</span>  <span class="hljs-comment"># 通过 API 接口作为首页副标题的内容，必须返回的是 JSON 格式，如果请求失败则按 text 字段显示，该功能必须先开启 typing 打字机功能</span>  <span class="hljs-comment"># Subtitle of the homepage through the API, must be returned a JSON. If the request fails, it will be displayed in `text` value. This feature must first enable the typing animation</span>  api:    enable: true    <span class="hljs-comment"># 请求地址</span>    <span class="hljs-comment"># Request url</span>    url: <span class="hljs-string">&quot;https://v1.hitokoto.cn/&quot;</span>    <span class="hljs-comment"># 请求方法</span>    <span class="hljs-comment"># Request method</span>    <span class="hljs-comment"># Available: GET | POST | PUT</span>    method: <span class="hljs-string">&quot;GET&quot;</span>    <span class="hljs-comment"># 请求头</span>    <span class="hljs-comment"># Request headers</span>    headers: &#123;&#125;    <span class="hljs-comment"># 从请求结果获取字符串的取值字段，最终必须是一个字符串，例如返回结果为 &#123;&quot;data&quot;: &#123;&quot;author&quot;: &quot;fluid&quot;, &quot;content&quot;: &quot;An elegant theme&quot;&#125;&#125;, 则取值字段为 [&#x27;data&#x27;, &#x27;content&#x27;]；如果返回是列表则自动选择第一项</span>    <span class="hljs-comment"># The value field of the string obtained from the response. For example, the response content is &#123;&quot;data&quot;: &#123;&quot;author&quot;: &quot;fluid&quot;, &quot;content&quot;: &quot;An elegant theme&quot;&#125;&#125;, the expected `keys: [&#x27;data&#x27;,&#x27;content&#x27;]`; if the return is a list, the first item is automatically selected</span>    keys: [<span class="hljs-string">&#x27;hitokoto&#x27;</span>]</code></pre></div><h3 id="4-视频背景：目前是静态托管，以后再说"><a href="#4-视频背景：目前是静态托管，以后再说" class="headerlink" title="4.视频背景：目前是静态托管，以后再说:"></a>4.视频背景：目前是静态托管，以后再说:</h3><p><a href="https://www.zywvvd.com/notes/hexo/theme/fluid/fluid-video-bg-fixed/fluid-video-bg-fixed/">教程</a></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#---------------------------# 首页# Home Page#---------------------------index:  # 首页 Banner 头图，可以是相对路径或绝对路径，以下相同  # Path of Banner image, can be a relative path or an absolute path, the same on other pages  banner_img: /img/default.png   # 首页 Banner 使用随机视频  # true 开启  false 关闭  banner_video: true</span></code></pre></div><h3 id="5-添加背景黑色线条："><a href="#5-添加背景黑色线条：" class="headerlink" title="5.添加背景黑色线条："></a>5.添加背景黑色线条：</h3><div class="code-wrapper"><pre><code class="hljs python">!function()&#123;function o(w,v,i)&#123;<span class="hljs-keyword">return</span> w.getAttribute(v)||i&#125;function j(i)&#123;<span class="hljs-keyword">return</span> document.getElementsByTagName(i)&#125;function l()&#123;var i=j(<span class="hljs-string">&quot;script&quot;</span>),w=i.length,v=i[w-<span class="hljs-number">1</span>];<span class="hljs-keyword">return</span>&#123;l:w,z:o(v,<span class="hljs-string">&quot;zIndex&quot;</span>,-<span class="hljs-number">1</span>),o:o(v,<span class="hljs-string">&quot;opacity&quot;</span>,<span class="hljs-number">0.5</span>),c:o(v,<span class="hljs-string">&quot;color&quot;</span>,<span class="hljs-string">&quot;0,0,0&quot;</span>),n:o(v,<span class="hljs-string">&quot;count&quot;</span>,<span class="hljs-number">99</span>)&#125;&#125;function k()&#123;r=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,n=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight&#125;function b()&#123;e.clearRect(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,r,n);var w=[f].concat(t);var x,v,A,B,z,y;t.forEach(function(i)&#123;i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;r||i.x&lt;<span class="hljs-number">0</span>?-<span class="hljs-number">1</span>:<span class="hljs-number">1</span>,i.ya*=i.y&gt;n||i.y&lt;<span class="hljs-number">0</span>?-<span class="hljs-number">1</span>:<span class="hljs-number">1</span>,e.fillRect(i.x-<span class="hljs-number">0.5</span>,i.y-<span class="hljs-number">0.5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(v=<span class="hljs-number">0</span>;v&lt;w.length;v++)&#123;x=w[v];<span class="hljs-keyword">if</span>(i!==x&amp;&amp;null!==x.x&amp;&amp;null!==x.y)&#123;B=i.x-x.x,z=i.y-x.y,y=B*B+z*z;y&lt;x.<span class="hljs-built_in">max</span>&amp;&amp;(x===f&amp;&amp;y&gt;=x.<span class="hljs-built_in">max</span>/<span class="hljs-number">2</span>&amp;&amp;(i.x-=<span class="hljs-number">0.03</span>*B,i.y-=<span class="hljs-number">0.03</span>*z),A=(x.<span class="hljs-built_in">max</span>-y)/x.<span class="hljs-built_in">max</span>,e.beginPath(),e.lineWidth=A/<span class="hljs-number">2</span>,e.strokeStyle=<span class="hljs-string">&quot;rgba(&quot;</span>+s.c+<span class="hljs-string">&quot;,&quot;</span>+(A+<span class="hljs-number">0.2</span>)+<span class="hljs-string">&quot;)&quot;</span>,e.moveTo(i.x,i.y),e.lineTo(x.x,x.y),e.stroke())&#125;&#125;w.splice(w.indexOf(i),<span class="hljs-number">1</span>)&#125;),m(b)&#125;var u=document.createElement(<span class="hljs-string">&quot;canvas&quot;</span>),s=l(),c=<span class="hljs-string">&quot;c_n&quot;</span>+s.l,e=u.getContext(<span class="hljs-string">&quot;2d&quot;</span>),r,n,m=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(i)&#123;window.setTimeout(i,<span class="hljs-number">1000</span>/<span class="hljs-number">45</span>)&#125;,a=Math.random,f=&#123;x:null,y:null,<span class="hljs-built_in">max</span>:<span class="hljs-number">20000</span>&#125;;u.<span class="hljs-built_in">id</span>=c;u.style.cssText=<span class="hljs-string">&quot;position:fixed;top:0;left:0;z-index:&quot;</span>+s.z+<span class="hljs-string">&quot;;opacity:&quot;</span>+s.o;j(<span class="hljs-string">&quot;body&quot;</span>)[<span class="hljs-number">0</span>].appendChild(u);k(),window.onresize=k;window.onmousemove=function(i)&#123;i=i||window.event,f.x=i.clientX,f.y=i.clientY&#125;,window.onmouseout=function()&#123;f.x=null,f.y=null&#125;;<span class="hljs-keyword">for</span>(var t=[],p=<span class="hljs-number">0</span>;s.n&gt;p;p++)&#123;var h=a()*r,g=a()*n,q=<span class="hljs-number">2</span>*a()-<span class="hljs-number">1</span>,d=<span class="hljs-number">2</span>*a()-<span class="hljs-number">1</span>;t.push(&#123;x:h,y:g,xa:q,ya:d,<span class="hljs-built_in">max</span>:<span class="hljs-number">6000</span>&#125;)&#125;setTimeout(function()&#123;b()&#125;,<span class="hljs-number">100</span>)&#125;();</code></pre></div><p>将上面的代码复制，并在此目录下 themes&#x2F;fluid&#x2F;source&#x2F;js&#x2F;DynamicLine.js 创建文件，将代码全部粘贴进去。<br>然后在主题配置 _config.yml 中找到 custom_js 或者 custom_css，修改如下：</p><div class="code-wrapper"><pre><code class="hljs python">custom_js:  - /js/DynamicLine.js</code></pre></div><h3 id="6-Note美化："><a href="#6-Note美化：" class="headerlink" title="6.Note美化："></a>6.Note美化：</h3><h3 id="7-固定背景："><a href="#7-固定背景：" class="headerlink" title="7.固定背景："></a>7.固定背景：</h3><p><a href="https://asteri5m.icu/archives/0c8538e7-5b5f-4897-8e8b-0cff84320473">魔改教程</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
