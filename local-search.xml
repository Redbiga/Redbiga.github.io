<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>搜索技巧</title>
    <link href="/2024/01/26/%E6%90%9C%E7%B4%A2%E7%9A%84%E6%8A%80%E5%B7%A7%EF%BC%9A/"/>
    <url>/2024/01/26/%E6%90%9C%E7%B4%A2%E7%9A%84%E6%8A%80%E5%B7%A7%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><a href="https://www.youtube.com/watch?v=tiN6T1LewmQ">视频</a><br><a href="https://cloud.tencent.com/developer/article/2240162">Google 和 Baidu 的 16 个高级搜索技巧，干货满满！建议收藏学习！-腾讯云开发者社区-腾讯云</a></p><h2 id="搜索引擎技巧（重要）："><a href="#搜索引擎技巧（重要）：" class="headerlink" title="搜索引擎技巧（重要）："></a>搜索引擎技巧（重要）：</h2><h4 id="1-精确搜索：双引号"><a href="#1-精确搜索：双引号" class="headerlink" title="1.精确搜索：双引号"></a>1.精确搜索：双引号</h4><p>精确搜索，就是在你要搜索的词上，加上双引号，那个 Google 搜索引擎，就会完全的匹配你所要的词</p><h4 id="2-站内搜索：site"><a href="#2-站内搜索：site" class="headerlink" title="2.站内搜索：site"></a>2.站内搜索：site</h4><p>这是一个比较常用的搜索方法，site 搜索，就是在站内进行搜索.<br>语法是：site:stackoverflow.com ，其中 site:后面加上你要搜索的网站地址。<br>一般程序猿解决问题，用 site:stackoverflow.com，大部分解决不了的问题，都会有答案了。</p><h4 id="intitle-搜索范围限定在网页标题（也就是intitle后面的内容是标题的一部分）"><a href="#intitle-搜索范围限定在网页标题（也就是intitle后面的内容是标题的一部分）" class="headerlink" title="intitle - 搜索范围限定在网页标题（也就是intitle后面的内容是标题的一部分）"></a><strong>intitle - 搜索范围限定在网页标题（也就是intitle后面的内容是标题的一部分）</strong></h4><p>搜索范围限定在包含 keyword 的网页标题中，这也是最普通的搜索。<br>intitle: 和后面的关键词之间不要有空格。</p><h4 id="allintitle-限定标题多个关键字："><a href="#allintitle-限定标题多个关键字：" class="headerlink" title="allintitle 限定标题多个关键字："></a>allintitle 限定标题多个关键字：</h4><div class="code-wrapper"><pre><code class="hljs basic">allintitle:李子柒 微念上面的意思是搜索结果的标题中要出现李子柒和微念两个关键词</code></pre></div><h4 id="inurl-搜索范围限定在-url-链接中"><a href="#inurl-搜索范围限定在-url-链接中" class="headerlink" title="inurl 搜索范围限定在 url 链接中"></a><strong>inurl 搜索范围限定在 url 链接中</strong></h4><p><strong>搜索范围限定在 url 链接中</strong>.<br>网页 url 中的某些信息，常常有某种有价值的含义。您如果对搜索结果的 url 做某种限定，可以获得良好的效果。<br>例如：前端教程 inurl:video</p><h4 id="imagesize-限定图片大小"><a href="#imagesize-限定图片大小" class="headerlink" title="imagesize:限定图片大小"></a>imagesize:限定图片大小</h4><h4 id="filetype-限定文档："><a href="#filetype-限定文档：" class="headerlink" title="filetype:限定文档："></a>filetype:限定文档：</h4><h2 id="导航网站（比较重要）："><a href="#导航网站（比较重要）：" class="headerlink" title="导航网站（比较重要）："></a>导航网站（比较重要）：</h2><p>直接谷歌搜某某行业导航网站或某某岗位&#x2F;行业必逛网站。</p><h2 id="寻找相似的网站："><a href="#寻找相似的网站：" class="headerlink" title="寻找相似的网站："></a>寻找相似的网站：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1702707274512-a461297e-ad20-4d75-b773-a705963eaa7b.png#averageHue=%23363636&clientId=u3b86627d-2b3e-4&from=paste&height=337&id=ubb915741&originHeight=421&originWidth=900&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=273502&status=done&style=none&taskId=u71acd269-4266-436e-b322-392a28d79c5&title=&width=720" alt="image.png"></p><h2 id="论文搜索："><a href="#论文搜索：" class="headerlink" title="论文搜索："></a>论文搜索：</h2><p>谷歌学术和SCI-HUB，高校图书馆</p><h2 id="电子书（重要）："><a href="#电子书（重要）：" class="headerlink" title="电子书（重要）："></a>电子书（重要）：</h2><p><a href="https://www.thinkdoc.vip/">欢乐图书馆|收录最优质的电子书网站的导航网站 | 最好的zlibrary电子书网址导航网站</a></p><h2 id="百度网盘搜索引擎："><a href="#百度网盘搜索引擎：" class="headerlink" title="百度网盘搜索引擎："></a>百度网盘搜索引擎：</h2><p><a href="https://www.dalipan.com/#/main/search?restype=1">大力盘 - 网盘搜索引擎</a><br><a href="https://www.xuesousou.net/">学搜搜(酷搜kolsou) - 百度网盘搜索引擎,百度云资源搜索,网盘资源下载</a><br><a href="https://pansou.cc/">盘搜搜 - 百度网盘资源搜索神器</a><br><a href="https://www.yunpangou.com/2155351113250243?p=4">Attention Required! | Cloudflare</a><br>个人感觉网盘搜索用处较少，有点鸡肋。</p><h2 id="素材搜索："><a href="#素材搜索：" class="headerlink" title="素材搜索："></a>素材搜索：</h2><p><a href="https://www.pexels.com/zh-cn/">pexels</a><br><a href="https://pixabay.com/">pixabay</a><br><a href="https://www.videvo.net/">videvo</a><br><a href="https://mixkit.co/">mixkit</a></p><h2 id="以图搜片："><a href="#以图搜片：" class="headerlink" title="以图搜片："></a>以图搜片：</h2><p><a href="https://www.youtube.com/watch?v=tERFkMjRGaE">视频教学</a><br><a href="https://xslist.org/tw">xslist</a>（根据图片寻找女优信息）<br><a href="https://tineye.com/">老牌搜图</a><br><a href="https://trace.moe/">搜索动漫</a><br>search by image浏览器插件</p><h2 id="galgame资源："><a href="#galgame资源：" class="headerlink" title="galgame资源："></a>galgame资源：</h2>]]></content>
    
    
    
    <tags>
      
      <tag>零散知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloud</title>
    <link href="/2024/01/26/%E9%BB%91%E9%A9%AC%E6%95%99%E7%A8%8B%EF%BC%9A/"/>
    <url>/2024/01/26/%E9%BB%91%E9%A9%AC%E6%95%99%E7%A8%8B%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="基础概念："><a href="#基础概念：" class="headerlink" title="基础概念："></a>基础概念：</h1><p>1.Eureka:<br><a href="https://blog.csdn.net/Pireley/article/details/133784749">Eureka（服务注册和发现）——Eureka的简介和原理 &amp; Eureka的使用和分析 &amp; 心跳续约策略，服务的下线和剔除，自我保护 &amp; Eureka集群的搭建-CSDN博客</a></p><div class="code-wrapper"><pre><code class="hljs basic">在微服务架构中，一个应用通常被拆分成多个独立的服务，这些服务需要能够相互通信和调用。通过使用Eureka，服务提供者向Eureka服务端注册自己，并将其元数据信息（如IP地址、端口号、机群名称等）注册到Eureka服务器中。服务消费者则通过向Eureka服务端查询，获取服务提供者的地址，并通过Eureka的服务调用机制与服务提供者进行通信。</code></pre></div><p>2.@EnableEurekaServer:</p><div class="code-wrapper"><pre><code class="hljs basic">@EnableEurekaServer是Spring Cloud中用于配置一个Eureka Server的注解。使用这个注解可以将一个Spring Boot应用配置为Eureka Server，用于注册和发现其他服务提供者（Service Provider）。 被@EnableEurekaServer注解标记的类中需要包含一个基于Web的控制器（Controller），用于处理客户端的请求。Eureka Server通过这个控制器对外提供注册和发现服务的接口。</code></pre></div><p>3.RestTemplate:</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">1</span>.用于发送HTTP请求和接收HTTP响应的工具类<span class="hljs-number">2</span>.restTemplate.getForObject(url, User.class):根据url路径发送http请求，返回的数据映射到User类上</code></pre></div><p>4.@LoadBalanced</p><div class="code-wrapper"><pre><code class="hljs basic">@Bean    @LoadBalanced    public RestTemplate restTemplate() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();    &#125;让注入的 RestTemplate具有负载均衡的能力</code></pre></div><h1 id="RestTemplate结合-LoadBalanced："><a href="#RestTemplate结合-LoadBalanced：" class="headerlink" title="RestTemplate结合@LoadBalanced："></a>RestTemplate结合@LoadBalanced：</h1>]]></content>
    
    
    <categories>
      
      <category>springboot2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习</title>
    <link href="/2024/01/26/Docker%E5%AD%A6%E4%B9%A0%EF%BC%9A/"/>
    <url>/2024/01/26/Docker%E5%AD%A6%E4%B9%A0%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-Linux-ubuntu20-04-docker的镜像加速配置"><a href="#1-Linux-ubuntu20-04-docker的镜像加速配置" class="headerlink" title="1.Linux-ubuntu20.04 docker的镜像加速配置:"></a>1.Linux-ubuntu20.04 docker的镜像加速配置:</h1><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#1、 建立deamon.json 配置docker国内镜像加速地址</span>$ sudo vim /etc/docker/daemon.json<span class="hljs-comment">#添加镜像的内容如下：这行注释在添加的时候要删除的</span>&#123;<span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,<span class="hljs-string">&quot;https://hub-mirror.c.163.com/&quot;</span>,<span class="hljs-string">&quot;https://reg-mirror.qiniu.com&quot;</span>,<span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span>]&#125;<span class="hljs-comment">#2、添加完成之后重启docker服务</span>sudo systemctl reload dockersudo systemctl restart docker<span class="hljs-comment">#注意：如果重启docker服务时遇到 docker.service is not active,cannot reload问题需要重启ubuntu系统</span><span class="hljs-comment">#3、查看docker 相关信息</span>sudo docker info<span class="hljs-comment">#使用命令之后在最后几行出现一下信息代表配置成功</span> Registry Mirrors:  https://docker.mirrors.ustc.edu.cn/  https://hub-mirror.c.163.com/  https://reg-mirror.qiniu.com/  https://registry.docker-cn.com/</code></pre></div><h1 id="2-相关概念："><a href="#2-相关概念：" class="headerlink" title="2.相关概念："></a>2.相关概念：</h1><ol><li>容器（Container）：容器是Docker中运行应用程序的实例。它们是基于镜像创建的，可以独立运行，并且具有自己的文件系统、进程空间和网络接口。容器提供了一个轻量级、可移植和隔离的环境，使应用程序可以在不同的计算机或环境中一致地运行。</li><li>镜像（Image）：镜像是Docker中用于创建容器的模板。它包含了一个完整的文件系统，其中包括应用程序所需的所有文件、库和依赖项。镜像是只读的，可以从一个基础镜像构建，然后通过在其上应用更改和配置来定制。镜像是构建和分发应用程序的基本单元，可以在不同的环境中重复使用。</li><li>仓库（Repository）：仓库是用于存储和共享Docker镜像的地方。它类似于代码仓库，可以存储多个镜像，并提供版本控制和标签管理。Docker Hub是一个公共仓库，其中包含了大量的官方和社区维护的镜像。此外，你也可以创建私有仓库来存储和管理自己的镜像。</li></ol><h1 id="常用的命令："><a href="#常用的命令：" class="headerlink" title="常用的命令："></a>常用的命令：</h1><p><a href="https://cloud.tencent.com/developer/article/1772136">一张脑图整理Docker常用命令-腾讯云开发者社区-腾讯云</a><br>Docker最常见的命令就是操作镜像、容器的命令，详见官方文档： <a href="https://docs.docker.com/">https://docs.docker.com/</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701929033107-ca6aa435-7381-47eb-a12b-32fcf5ccdad2.png#averageHue=%23f9f9f8&clientId=ufdf80702-067d-4&from=paste&height=414&id=u7bc6c6c6&originHeight=518&originWidth=1256&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=74185&status=done&style=none&taskId=u897341c8-b655-4763-a87e-fff75e8ad79&title=&width=1004.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701929206068-511fc274-0834-4a9f-a6e6-fb12c892db52.png#averageHue=%23fbf9f7&clientId=ufdf80702-067d-4&from=paste&id=u4ed052f0&originHeight=958&originWidth=1942&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u6df0f28c-805a-4ad2-aa8a-52d1da7444e&title="><br>1.从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为：</p><div class="code-wrapper"><pre><code class="hljs bash">$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</code></pre></div><ol start="2"><li><div class="code-wrapper"><pre><code class="hljs bash">docker run -it --<span class="hljs-built_in">rm</span> ubuntu:18.04 bash以交互式启动一个容器，如果启动后想退出，输入<span class="hljs-built_in">exit</span>就可以了</code></pre></div></li></ol><h1 id="Docker部署Mysql"><a href="#Docker部署Mysql" class="headerlink" title="Docker部署Mysql:"></a>Docker部署Mysql:</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701934094635-162132cc-e61b-404f-9050-c64f7f54afa7.png#averageHue=%23fbf9f8&clientId=ufdf80702-067d-4&from=paste&height=462&id=ude019f64&originHeight=578&originWidth=1062&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=109651&status=done&style=none&taskId=u17d4b19a-5081-46dd-948c-972c6bd1973&title=&width=849.6" alt="image.png"><br>mysql中的数据卷是由容器运行时创建的卷，称为匿名卷<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701934330675-b5e91097-e7c4-4a6f-8938-7282969848fd.png#averageHue=%23103138&clientId=ufdf80702-067d-4&from=paste&height=303&id=ud210a64c&originHeight=379&originWidth=1408&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=266040&status=done&style=none&taskId=u98f2b8cf-b2c1-42e2-bf45-ff3c9d295ef&title=&width=1126.4" alt="image.png"><br><a href="https://www.runoob.com/docker/docker-install-mysql.html">Docker 安装 MySQL | 菜鸟教程</a></p><h1 id="Docker部署nginx"><a href="#Docker部署nginx" class="headerlink" title="Docker部署nginx:"></a>Docker部署nginx:</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701931317900-c2c44426-7cdf-4a6e-9555-b4faa6bcc1da.png#averageHue=%23fcfbfa&clientId=ufdf80702-067d-4&from=paste&height=114&id=u1b7dce6a&originHeight=142&originWidth=920&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=28641&status=done&style=none&taskId=u7c189199-7958-4b1a-86ca-1404e04900c&title=&width=736" alt="image.png"><br>nginx镜像只包括了nginx运行所需要的资源，当我们想要修改nginx中的index.html的时候，在该容器中无法用vi等编辑器修改；因为nginx镜像中没有vi等编辑器的资源。如果我们想要修改index.html的时候可以通过数据卷的方式修改；<br>挂载：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701933349995-9b5a10d5-e2c0-438b-945a-eb1764ef9a98.png#averageHue=%23f6faed&clientId=ufdf80702-067d-4&from=paste&height=76&id=u29698b62&originHeight=95&originWidth=724&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=43572&status=done&style=none&taskId=u2fb5d0cd-b8eb-40ea-8a1a-19eb95dfc5f&title=&width=579.2" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs bash">docker run -d -p 80:80 -v html:/usr/share/nginx/html --name my-nginx nginx</code></pre></div><p>这里的html是我们的数据卷，是一个虚拟目录；&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html是一个映射容器内的目录；<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701933798439-7e62346f-2dbb-4335-8993-388bb01bd37c.png#averageHue=%23e4c99a&clientId=ufdf80702-067d-4&from=paste&height=80&id=u343f946a&originHeight=100&originWidth=895&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=16538&status=done&style=none&taskId=ucb70c40d-504f-4cb1-844b-3fac0ec1c85&title=&width=716" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701933934780-a0a00d0b-540e-4162-9c3a-3b25fb257411.png#averageHue=%23201f1e&clientId=ufdf80702-067d-4&from=paste&height=230&id=ucdfedb85&originHeight=288&originWidth=872&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=36056&status=done&style=none&taskId=ue9439c90-9910-4013-b1a2-ce21646fed5&title=&width=697.6" alt="image.png"></p><h1 id="数据卷："><a href="#数据卷：" class="headerlink" title="数据卷："></a>数据卷：</h1><p>数据卷只是虚拟的目录只是当成件容器内的目录和主机目录联系起来。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701929484358-fdb371a0-d78b-40b2-b28d-2ecf5f8c23c1.png#averageHue=%23fdfcfc&clientId=ufdf80702-067d-4&from=paste&height=458&id=uf3c6aad1&originHeight=573&originWidth=1284&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=85829&status=done&style=none&taskId=u7d0e1528-b473-4a44-9d65-02187d010f8&title=&width=1027.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701929550714-d8ae9d2a-93a2-40b6-ab11-5fb7569ca287.png#averageHue=%23d1aa79&clientId=ufdf80702-067d-4&from=paste&height=433&id=u2b7f4e0e&originHeight=541&originWidth=1213&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=68371&status=done&style=none&taskId=ud1083521-c2c6-4916-a11a-927b88e4c62&title=&width=970.4" alt="image.png"></p><h1 id="自定义镜像："><a href="#自定义镜像：" class="headerlink" title="自定义镜像："></a>自定义镜像：</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701935784876-7116fc00-2913-4fd6-8168-803d0f431f63.png#averageHue=%2397ac7e&clientId=ufdf80702-067d-4&from=paste&height=308&id=uea723465&originHeight=385&originWidth=926&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=155767&status=done&style=none&taskId=u0eaa9ac7-e6f7-49da-83ac-5a37ce6b9a0&title=&width=740.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701936239863-1d3b6d89-ea56-4012-a751-76eaa9e3624b.png#averageHue=%23e0e4e9&clientId=ufdf80702-067d-4&from=paste&height=338&id=u1b938984&originHeight=423&originWidth=927&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=181885&status=done&style=none&taskId=u5a54000a-492e-4ff9-b189-59afeac0cea&title=&width=741.6" alt="image.png"></p><h1 id="网络："><a href="#网络：" class="headerlink" title="网络："></a>网络：</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701936913349-7159f054-30d3-4df8-967a-4513b9f0af98.png#averageHue=%23f8f5f3&clientId=ufdf80702-067d-4&from=paste&height=498&id=uf1ddafb6&originHeight=622&originWidth=1184&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=51900&status=done&style=none&taskId=u45c4309a-28aa-4907-beb7-d43a3bac732&title=&width=947.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701936961559-af663492-d566-40b9-b6e7-ec4e3b99a3a3.png#averageHue=%23ebe0df&clientId=ufdf80702-067d-4&from=paste&height=450&id=u258f69b9&originHeight=563&originWidth=1263&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=113035&status=done&style=none&taskId=u2e721c35-bf12-41dc-8c33-e290c18d55a&title=&width=1010.4" alt="image.png"></p><h1 id="IDEA运行Docker"><a href="#IDEA运行Docker" class="headerlink" title="IDEA运行Docker"></a>IDEA运行Docker</h1><p>入门：<br><a href="https://www.cnblogs.com/mayhot/p/15904506.html">https://www.cnblogs.com/mayhot/p/15904506.html</a><br><a href="https://blog.csdn.net/u010675669/article/details/114368037">Idea使用Docker部署SpringBoot项目_idea docker springboot-CSDN博客</a><br>1.配置pom.xml的build：</p><div class="code-wrapper"><pre><code class="hljs bash">    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;excludes&gt;                        &lt;exclude&gt;                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;                        &lt;/exclude&gt;                    &lt;/excludes&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;!--使用docker-maven-plugin插件--&gt;            &lt;plugin&gt;                &lt;groupId&gt;com.spotify&lt;/groupId&gt;                &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;1.0.0&lt;/version&gt;                &lt;!--将插件绑定在某个phase执行--&gt;                &lt;executions&gt;                    &lt;execution&gt;                        &lt;<span class="hljs-built_in">id</span>&gt;build-image&lt;/id&gt;                        &lt;!--用户只需执行mvn package ，就会自动执行mvn docker:build--&gt;                        &lt;phase&gt;package&lt;/phase&gt;                        &lt;goals&gt;                            &lt;goal&gt;build&lt;/goal&gt;                        &lt;/goals&gt;                    &lt;/execution&gt;                &lt;/executions&gt;                &lt;configuration&gt;                    &lt;!--指定生成的镜像名--&gt;          <span class="hljs-comment"># $&#123;project.artifactId&#125;是一个Maven变量，它代表项目的构件ID，即项目的唯一标识符。</span>                    &lt;imageName&gt;zrs/<span class="hljs-variable">$&#123;project.artifactId&#125;</span>&lt;/imageName&gt;                    &lt;!--指定标签--&gt;                    &lt;imageTags&gt;                        &lt;imageTag&gt;latest&lt;/imageTag&gt;                    &lt;/imageTags&gt;                    &lt;!-- 指定 Dockerfile 路径--&gt;<span class="hljs-comment">#$&#123;project.basedir&#125; 是一个Maven变量，它代表项目的根目录路径。在Maven构建过程中，</span><span class="hljs-comment"># $&#123;project.basedir&#125;会被解析为项目根目录的实际路径。</span>                    &lt;dockerDirectory&gt;<span class="hljs-variable">$&#123;project.basedir&#125;</span>&lt;/dockerDirectory&gt;&lt;!--                    指定远程 docker api地址，其中指定的ip地址是远程主机的ip地址，2375是Docker监听的端口--&gt;                    &lt;dockerHost&gt;http://192.168.44.130:2375&lt;/dockerHost&gt;                    &lt;!-- 这里是复制 jar 包到 docker 容器指定目录配置 --&gt;                    &lt;resources&gt;                        &lt;resource&gt;<span class="hljs-comment"># &lt;targetPath&gt;：这是指定资源在Docker容器中的目标路径。在这里，/表示根目录，即将资源复制到容</span><span class="hljs-comment"># 器的根目录。</span><span class="hljs-comment"># &lt;directory&gt;：这是指定资源所在的目录。$&#123;project.build.directory&#125;是一个Maven变量，它代表项</span><span class="hljs-comment"># 目构建的输出目录，通常是target目录。这意味着插件将从$&#123;project.build.directory&#125;目录中寻找资源。</span><span class="hljs-comment"># &lt;include&gt;：这是指定要包含在Docker容器中的jar包的文件名。$&#123;project.build.finalName&#125;.jar是</span><span class="hljs-comment"># 一个Maven变量，它代表项目构建的最终名称，通常是项目的名称加上版本号和构建时间。这个变量将被</span><span class="hljs-comment"># 解析为实际的jar包文件名。</span><span class="hljs-comment"># 因此，这段代码的作用是将$&#123;project.build.directory&#125;/$&#123;project.build.finalName&#125;.jar这个</span><span class="hljs-comment"># jar包复制到Docker容器的根目录(/)下。</span>                            &lt;targetPath&gt;/&lt;/targetPath&gt;                            &lt;!--jar 包所在的路径  此处配置的 即对应 target 目录--&gt;                            &lt;directory&gt;<span class="hljs-variable">$&#123;project.build.directory&#125;</span>&lt;/directory&gt;                            &lt;!-- 需要包含的 jar包 ，这里对应的是 Dockerfile中添加的文件名　--&gt;                            &lt;include&gt;<span class="hljs-variable">$&#123;project.build.finalName&#125;</span>.jar&lt;/include&gt;                        &lt;/resource&gt;                    &lt;/resources&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;</code></pre></div><p>Dockerfile的书写：位置在项目根路径下：</p><div class="code-wrapper"><pre><code class="hljs bash">FROM openjdk:17<span class="hljs-comment"># 作者信息</span>LABEL maintainer=<span class="hljs-string">&quot;reda&quot;</span><span class="hljs-comment"># 挂载临时目录</span>VOLUME /tmp<span class="hljs-comment"># 将jar包添加到容器中并更名</span>COPY ./target/DockerDome-0.0.1-SNAPSHOT.jar pms.jar<span class="hljs-comment"># 运行jar</span>RUN sh -c <span class="hljs-string">&#x27;touch /pms.jar&#x27;</span><span class="hljs-comment"># 容器启动命令</span>ENTRYPOINT [ <span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;/pms.jar&quot;</span> ]</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rabbits学习总结</title>
    <link href="/2024/01/26/Rabbits_/"/>
    <url>/2024/01/26/Rabbits_/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><a href="https://kangshitao.github.io/2021/10/26/rabbitmq/">https://kangshitao.github.io/2021/10/26/rabbitmq/</a></p><h2 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1702457198211-27a90a27-4567-449b-b17e-b869cd5adfe5.png#averageHue=%23ba9036&clientId=u4d991bf9-5f69-4&from=paste&height=463&id=u3d2c52db&originHeight=579&originWidth=1305&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=102416&status=done&style=none&taskId=u7533b0ce-ebbb-486a-a056-ada26df96a9&title=&width=1044" alt="image.png"><br>2.消息应答：**消费者在接 收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。 **</p><h2 id="1-安装："><a href="#1-安装：" class="headerlink" title="1.安装："></a>1.安装：</h2><p><a href="https://blog.csdn.net/luiluier/article/details/124167341">Ubuntu20.04安装RabbitMQ，并配置远程调用，详细教程_ubuntu20.04 rabbitmq安装使用-CSDN博客</a></p><h2 id="2-hello项目："><a href="#2-hello项目：" class="headerlink" title="2.hello项目："></a>2.hello项目：</h2><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">1</span>.生产者创建连接工厂，连接工厂创建连接<span class="hljs-number">2</span>.发送消息（创建Channel)<span class="hljs-number">3</span>.消费者创建连接工厂，连接工厂创建连接（需要提供服务器地址，端口，用户，密码）<span class="hljs-number">4</span>.接收信息（创建Channel,<span class="hljs-number">5</span>.消费者内部有消费成功的回调函数和失败的回调函数，消费者会监听生产者生成消息<span class="hljs-number">6</span>.当只有一个生产者，多个消费者的时候，消费者默认按照轮询的方式消费信息<span class="hljs-number">7</span>.</code></pre></div><h2 id="消息应答："><a href="#消息应答：" class="headerlink" title="消息应答："></a>消息应答：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1702459231088-99fb3d4c-7e08-453b-bb93-1ce513bf8742.png#averageHue=%23c5c4c4&clientId=u4d991bf9-5f69-4&from=paste&height=346&id=uf3a9aaa3&originHeight=432&originWidth=1080&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=97870&status=done&style=none&taskId=u322a182b-447f-4416-b783-10a96e6723d&title=&width=864" alt="image.png"><br>1.默认为自动应答，也就是信息发出去后队列就删除这条信息。我们可以设置为手动应答，当我们发送成功后，但是某一个消费者挂掉了，这个时候发送丢失的消息就会重写入队。</p><h2 id="持久化："><a href="#持久化：" class="headerlink" title="持久化："></a>持久化：</h2><p>1.保障当 RabbitMQ 服务停掉以后消 息生产者发送过来的消息不丢失。默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列 和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：<strong>我们需要将队列和消息都标 记为持久化。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1702460422423-363f570e-1836-4f96-a847-c9c40a4bb406.png#averageHue=%23c5c2c0&clientId=u4d991bf9-5f69-4&from=paste&height=289&id=u86632831&originHeight=361&originWidth=1319&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=170633&status=done&style=none&taskId=u1d8a6660-724c-4b92-a3af-f6407dc0da4&title=&width=1055.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1702460503297-f61a699e-7dfe-48a8-94c8-3302aed89403.png#averageHue=%23bfbebc&clientId=u4d991bf9-5f69-4&from=paste&height=405&id=uff419f1d&originHeight=506&originWidth=1330&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=243829&status=done&style=none&taskId=u652007f0-16fc-44c3-89b3-b5faedafc8c&title=&width=1064" alt="image.png"></p><h2 id="发布确认："><a href="#发布确认：" class="headerlink" title="发布确认："></a>发布确认：</h2><div class="code-wrapper"><pre><code class="hljs basic">//开启发布确认 channel.confirmSelect();</code></pre></div><div class="code-wrapper"><pre><code class="hljs basic">//服务端返回 false 或超时时间内未返回，生产者可以消息重发，等待发布的确认 boolean flag = channel.waitForConfirms();</code></pre></div><div class="code-wrapper"><pre><code class="hljs basic">import <span class="hljs-keyword">com</span>.rabbitmq.client.*;public class AsyncPublisher &#123;    private static final String EXCHANGE_NAME = <span class="hljs-string">&quot;async_exchange&quot;</span>;    private static final String ROUTING_KEY = <span class="hljs-string">&quot;async_routing_key&quot;</span>;    private static final String QUEUE_NAME = <span class="hljs-string">&quot;async_queue&quot;</span>;    public static void main(String[] args) throws Exception &#123;        // 创建连接工厂        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">&quot;localhost&quot;</span>);        // 创建连接        try (Connection connection = factory.newConnection();             Channel channel = connection.createChannel()) &#123;            // 声明交换机和队列            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT, true);            channel.queueDeclare(QUEUE_NAME, true, false, false, null);            channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ROUTING_KEY);            // 设置发布者确认模式            channel.confirmSelect();            // 异步确认发布的回调函数            ConfirmCallback confirmCallback = (deliveryTag, multiple) -&gt; &#123;                <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;消息发布成功，deliveryTag: &quot;</span> + deliveryTag);            &#125;;            // 异步确认发布失败的回调函数            ConfirmCallback nackCallback = (deliveryTag, multiple) -&gt; &#123;                <span class="hljs-keyword">System</span>.<span class="hljs-keyword">err</span>.println(<span class="hljs-string">&quot;消息发布失败，deliveryTag: &quot;</span> + deliveryTag);            &#125;;            // 设置异步确认发布的回调函数            channel.addConfirmListener(confirmCallback, nackCallback);            // 发布消息            String message = <span class="hljs-string">&quot;Hello, RabbitMQ!&quot;</span>;            channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());            // 等待回调确认            channel.waitForConfirmsOrDie();            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;消息发布完成&quot;</span>);        &#125;    &#125;&#125;</code></pre></div><h2 id="交换机："><a href="#交换机：" class="headerlink" title="交换机："></a>交换机：</h2>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rabbits</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpirngBoot开源Demo源码分析：</title>
    <link href="/2024/01/26/SpirngBoot%E5%BC%80%E6%BA%90Demo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A/"/>
    <url>/2024/01/26/SpirngBoot%E5%BC%80%E6%BA%90Demo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><p><a href="https://github.com/ityouknow/spring-boot-examples">https://github.com/ityouknow/spring-boot-examples</a></p><h1 id="dockercompose-springboot-mysql-nginx："><a href="#dockercompose-springboot-mysql-nginx：" class="headerlink" title="dockercompose-springboot-mysql-nginx："></a>dockercompose-springboot-mysql-nginx：</h1><h2 id="1，DockerCompose"><a href="#1，DockerCompose" class="headerlink" title="1，DockerCompose:"></a>1，DockerCompose:</h2><p><a href="https://yeasy.gitbook.io/docker_practice/compose/introduction">简介 - Docker — 从入门到实践</a><br><a href="https://www.runoob.com/docker/docker-compose.html">Docker Compose | 菜鸟教程</a></p><ul><li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。<div class="code-wrapper"><pre><code class="hljs bash">version: <span class="hljs-string">&#x27;3&#x27;</span>services:  nginx:   container_name: v-nginx   image: nginx:1.13   restart: always   ports:   - 80:80   - 443:443   volumes:   - ./nginx/conf.d:/etc/nginx/conf.d      mysql:   container_name: v-mysql   image: mysql/mysql-server:5.7   environment:    MYSQL_DATABASE: <span class="hljs-built_in">test</span>    MYSQL_ROOT_PASSWORD: root    MYSQL_ROOT_HOST: <span class="hljs-string">&#x27;%&#x27;</span>   ports:   - <span class="hljs-string">&quot;3306:3306&quot;</span>   restart: always      app:    restart: always    build: ./app    working_dir: /app    volumes:      - ./app:/app      - ~/.m2:/root/.m2    expose:      - <span class="hljs-string">&quot;8080&quot;</span>    depends_on:      - nginx      - mysql    <span class="hljs-built_in">command</span>: mvn clean spring-boot:run -Dspring-boot.run.profiles=docker</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash">这个docker-compose文件定义了三个服务：nginx、mysql和app。让我逐个解释每个服务的配置：nginx服务：container_name：指定容器的名称为 v-nginx。image：使用 nginx:1.13 镜像作为基础镜像。restart：设置容器在退出时总是自动重启。ports：将主机的80端口映射到容器的80端口，以及将主机的443端口映射到容器的443端口。volumes：将主机上的 ./nginx/conf.d 目录挂载到容器的 /etc/nginx/conf.d 目录，用于提供Nginx的配置文件。mysql服务：container_name：指定容器的名称为 v-mysql。image：使用 mysql/mysql-server:5.7 镜像作为基础镜像。environment：设置MySQL容器的环境变量，包括数据库名称、root用户的密码和允许访问的主机。ports：将主机的3306端口映射到容器的3306端口，以便可以通过主机访问MySQL服务。restart：设置容器在退出时总是自动重启。app服务：restart：设置容器在退出时总是自动重启。build：使用 ./app 目录中的Dockerfile构建镜像。working_dir：设置容器的工作目录为 /app。volumes：将主机上的 ./app 目录挂载到容器的 /app 目录，用于提供应用程序的代码文件。同时，将主机上的 ~/.m2 目录挂载到容器的 /root/.m2 目录，用于提供Maven的依赖文件。expose：将容器的8080端口暴露给其他容器或主机。depends_on：指定app服务依赖于nginx和mysql服务，以确保在启动app服务之前，nginx和mysql服务已经启动。<span class="hljs-built_in">command</span>：在容器内部运行命令 mvn clean spring-boot:run -Dspring-boot.run.profiles=docker，用于启动应用程序。这个docker-compose文件定义了一个多容器应用程序的架构，其中nginx负责处理HTTP和HTTPS请求，mysql负责提供数据库服务，而app服务则是一个基于Spring Boot的应用程序。</code></pre></div></li></ul><h2 id="2-在Docker容器中执行sql脚本："><a href="#2-在Docker容器中执行sql脚本：" class="headerlink" title="2.在Docker容器中执行sql脚本："></a>2.在Docker容器中执行sql脚本：</h2><p><a href="https://blog.csdn.net/Entity_G/article/details/122615009">Docker简单部署mysql并导入SQL文件_docker mysql 导入sql-CSDN博客</a><br>1.部署和运行docker:</p><div class="code-wrapper"><pre><code class="hljs bash">docker run -d --name mysql \    --restart=always \-p 3306:3306 \-v mysql:/etc/mysql/ \-v /tmp/mysql:/var/lib/mysql \-e MYSQL_ROOT_PASSWORD=12345 \    mysql:8 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci </code></pre></div><p>-v mysql:&#x2F;etc&#x2F;mysql&#x2F;:其中的mysql是虚拟目录对应容器里面的&#x2F;etc&#x2F;mysql目录；<br>上面的是在后台启动一个mysql容器，该容器的密码是12345，其中服务端采用的字符集是utf8mb4，并设置了相关的数据集mysql；</p><div class="code-wrapper"><pre><code class="hljs bash">/etc/mysql/ 储存配置信息相关文件/var/lib/mysql 储存mysql实际的数据文件</code></pre></div><p>2.运行mysql容器（方法1）：直接使用sql语句</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it mysql bash <span class="hljs-comment">#给容器打开一个新的终端</span>mysql -uroot -p123456 <span class="hljs-comment">#在新的终端中运行mysql服务器，如果是自己使用mysql语句创建sql时，可以直接</span><span class="hljs-comment">#在这后面创建数据库和表</span></code></pre></div><p>3.导入sql文件（方法2）：使用sql脚本</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 1.拷贝SQL文件到mysql容器中</span>docker <span class="hljs-built_in">cp</span> yyy.sql mysql:/yyy.sql<span class="hljs-comment"># 2. 创建数据库</span>docker <span class="hljs-built_in">exec</span> -it mysql mysql -h 192.168.6.88 -uroot -p12345  mysql&gt; create database yyy;mysql&gt; use yyy;<span class="hljs-comment"># 3.登陆控制台执行source 命令</span>mysql&gt; <span class="hljs-built_in">source</span> yyy.sql</code></pre></div><h1 id="3-Nginx"><a href="#3-Nginx" class="headerlink" title="3.Nginx:"></a>3.Nginx:</h1><p><a href="https://xuexb.github.io/learn-nginx/guide/">Nginx 简介 | Nginx 入门教程</a></p><h1 id="springboot多环境配置："><a href="#springboot多环境配置：" class="headerlink" title="springboot多环境配置："></a>springboot多环境配置：</h1><p><a href="https://www.cnblogs.com/Chenjiabing/p/13968781.html">https://www.cnblogs.com/Chenjiabing/p/13968781.html</a><br>日常开发中至少有三个环境，分别是开发环境（<strong>dev</strong>），测试环境（<strong>test</strong>），生产环境（<strong>prod</strong>）。<br>既然每个环境的配置都不相同，索性将不同环境的配置放在不同的配置文件中，因此需要创建三个不同的配置文件，分别是<strong>application-dev.properties</strong>、<strong>application-test.properties</strong>、<strong>application-prod.properties</strong>。<br><strong>「注意」</strong>：配置文件的名称一定要是<strong>application-name.properties</strong>或者<strong>application-name.yml</strong>格式。这个<strong>name</strong>可以自定义，主要用于区分。<br>指定运行的环境：1.在<strong>application.properties</strong>或者<strong>application.yml</strong>文件中指定；2.运行jar的时候指定，如：</p><div class="code-wrapper"><pre><code class="hljs bash">java -jar xxx.jar --spring.profiles.active=<span class="hljs-built_in">test</span></code></pre></div><h1 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h1><p>1.@RequestMapping：对任意类型的请求都可以进行处理的。<br>如果想要修改springboot启动的banner可以：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1702014637534-970c4ea4-b5d2-4083-b646-0f5f88b8fbc0.png#averageHue=%23394358&clientId=u0be32230-d55e-4&from=paste&height=99&id=u1067a1df&originHeight=124&originWidth=925&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=71568&status=done&style=none&taskId=u4ca5a637-481d-4fda-a134-659afadc6a4&title=&width=740" alt="image.png"></p><h1 id="Spring-boot——Actuator-详解："><a href="#Spring-boot——Actuator-详解：" class="headerlink" title="Spring boot——Actuator 详解："></a><a href="https://www.cnblogs.com/caoweixiong/p/15325382.html">Spring boot——Actuator 详解</a>：</h1><p><a href="https://cloud.tencent.com/developer/article/1489997">Springboot actuator使用详解 -腾讯云开发者社区-腾讯云</a></p><h1 id="Spring-Boot-Admin-："><a href="#Spring-Boot-Admin-：" class="headerlink" title="Spring Boot Admin ："></a>Spring Boot Admin ：</h1><p><a href="https://cloud.tencent.com/developer/article/1923688">Spring Boot Admin 2.0 详解-腾讯云开发者社区-腾讯云</a><br>Spring Boot Admin ：是一种监控技术</p><h1 id="CommandLineRunner和order注解："><a href="#CommandLineRunner和order注解：" class="headerlink" title="CommandLineRunner和order注解："></a>CommandLineRunner和order注解：</h1><p><a href="https://blog.csdn.net/weixin_45433031/article/details/126884328">ApplicationRunner、CommandLineRunner+@order注解学习-CSDN博客</a><br>1.ApplicationRunner和CommandLineRunner：<br>是一个接口，常用于项目启动后，（也就是ApringApplication.run()执行结束），立马执行某些逻辑。<br>可用于项目的准备工作，比如加载配置文件，加载执行流，<a href="https://so.csdn.net/so/search?q=%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1&spm=1001.2101.3001.7020">定时任务</a>等等。<br>2.ApplicationRunner和CommandLineRunner：接口中的run方法都是容器启动后执行的逻辑，其run方法执行的顺序和bean加载的顺序一致，可以通过order注解来实现bean加载的顺序。<br>3.ApplicationRunner中run方法的参数是：ApplicationArguments，其可以获取到当前项目执行的命令参数；而CommandLineRunner接口中run方法的参数是<a href="https://so.csdn.net/so/search?q=String%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">String数组</a>；<br>4.注入容器中的bean如果没有指定order那么默认为优先级最低的。</p><h1 id="Springboot中实现定时任务："><a href="#Springboot中实现定时任务：" class="headerlink" title="Springboot中实现定时任务："></a>Springboot中实现定时任务：</h1><p><a href="https://cloud.tencent.com/developer/article/1445905">Spring Boot 实现定时任务的 4 种方式-腾讯云开发者社区-腾讯云</a></p><h1 id="Docker整合Springboot"><a href="#Docker整合Springboot" class="headerlink" title="Docker整合Springboot:"></a>Docker整合Springboot:</h1><p>1.在pom中导入Docker依赖</p><div class="code-wrapper"><pre><code class="hljs bash">&lt;!-- Docker maven plugin --&gt;&lt;plugin&gt;&lt;groupId&gt;com.spotify&lt;/groupId&gt;&lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;&lt;version&gt;1.0.0&lt;/version&gt;&lt;configuration&gt;&lt;imageName&gt;<span class="hljs-variable">$&#123;docker.image.prefix&#125;</span>/<span class="hljs-variable">$&#123;project.artifactId&#125;</span>&lt;/imageName&gt;&lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt;&lt;resources&gt;&lt;resource&gt;&lt;targetPath&gt;/&lt;/targetPath&gt;&lt;directory&gt;<span class="hljs-variable">$&#123;project.build.directory&#125;</span>&lt;/directory&gt;&lt;include&gt;<span class="hljs-variable">$&#123;project.build.finalName&#125;</span>.jar&lt;/include&gt;&lt;/resource&gt;&lt;/resources&gt;&lt;/configuration&gt;&lt;/plugin&gt;&lt;!-- Docker</code></pre></div><p>2.编写Dockerfiler:</p><div class="code-wrapper"><pre><code class="hljs bash">FROM openjdk:8-jdk-alpineVOLUME /tmpADD spring-boot-docker-1.0.jar app.jarENTRYPOINT [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-Djava.security.egd=file:/dev/./urandom&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;/app.jar&quot;</span>]</code></pre></div><p>注意上面的spring-boot-docker-1.0.jar的位置，上面的”-Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom”,是一个Java命令行参数，用于设置Java安全随机数生成器（SecureRandom）使用的随机源。  在这个参数中，”file:&#x2F;dev&#x2F;.&#x2F;urandom”表示使用系统的随机设备文件作为随机源。”&#x2F;dev&#x2F;.&#x2F;urandom”是Linux系统中的随机设备文件，它可以提供高质量的随机数据。  这个参数的作用是确保Java应用程序在启动时使用足够的随机数据来初始化SecureRandom对象，以增强应用程序的安全性。</p><h1 id="springboot中elasticsearch："><a href="#springboot中elasticsearch：" class="headerlink" title="springboot中elasticsearch："></a>springboot中elasticsearch：</h1><p><a href="https://blog.csdn.net/qq_45297578/article/details/116273017">【SpringBoot高级篇】SpringBoot集成Elasticsearch搜索引擎_springboot集成elasticsearch 生成索引-CSDN博客</a></p><h1 id="文件上传："><a href="#文件上传：" class="headerlink" title="文件上传："></a>文件上传：</h1><p><a href="https://github.com/search?q=springboot%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0&type=repositories&s=&o=desc&p=1">https://github.com/search?q=springboot%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0&type=repositories&s=&o=desc&p=1</a>差一个项目</p><h1 id="JPA："><a href="#JPA：" class="headerlink" title="JPA："></a>JPA：</h1><p><a href="https://springdoc.cn/spring-data-jpa/">Spring Data JPA 中文文档</a><br><a href="https://blog.csdn.net/cmx1060220219/article/details/106259423">SpringBoot集成jpa 一篇就够了 超详细_springboot集成jpa切面-CSDN博客</a></p><div class="code-wrapper"><pre><code class="hljs bash">public interface UserRepository extends JpaRepository&lt;User, Long&gt; 中的JpaRepository&lt;User, Long&gt;中，User表示存储库中的实体类类型，Long表示实体类中的主键类型。因此，JpaRepository&lt;User, Long&gt;表示一个存储库，其中的实体类使用Long类型的主键.而上面的这个接口就是Dao层，在Service注入的就是上面的接口。但是上面的接口没有相关注解修饰，但是因为其继承了JpaRepository&lt;User, Long&gt;该接口被注入到容器中了。因此Service层中就可以自动注入该接口的bean。</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash">  @Query(<span class="hljs-string">&quot;select u from User u where u.emailAddress = ?1&quot;</span>)  User findByEmailAddress(String emailAddress);&#125;上面的?1表示用下面方法中的第一个参数代替。</code></pre></div><p>JPA的配置文件：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 数据库连接的配置</span>spring.datasource.url=jdbc:mysql://192.168.44.130:3306/test?serverTimezone=UTC&amp;useUnicode=<span class="hljs-literal">true</span>&amp;characterEncoding=utf-8&amp;useSSL=<span class="hljs-literal">true</span>spring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver<span class="hljs-comment"># jpa的配置，hibernate.hbm2ddl.auto：create，</span><span class="hljs-comment"># 表示每次启动时都重新创建数据库表结构（慎用，会清空原有数据）</span><span class="hljs-comment"># hibernate.dialect：org.hibernate.dialect.MySQL5InnoDBDialect，表示使用MySQL数据库的</span><span class="hljs-comment"># InnoDB方言</span><span class="hljs-comment"># show-sql：true，表示在控制台上显示生成的SQL语句</span><span class="hljs-comment"># format_sql：true，表示格式化生成的SQL语句，使其更易读</span>spring.jpa.properties.hibernate.hbm2ddl.auto=createspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect<span class="hljs-comment">#sql\u8F93\u51FA</span>spring.jpa.show-sql=<span class="hljs-literal">true</span><span class="hljs-comment">#format\u4E00\u4E0Bsql\u8FDB\u884C\u8F93\u51FA</span>spring.jpa.properties.hibernate.format_sql=<span class="hljs-literal">true</span></code></pre></div><p>JPA多数据源：<a href="https://www.cnblogs.com/daimenglaoshi/p/16953667.html">https://www.cnblogs.com/daimenglaoshi/p/16953667.html</a></p><div class="code-wrapper"><pre><code class="hljs bash">1.多数据源要可以在配置文件写多个连接数据库的连接配置2.DataSourceConfig配置类要注入2个数据源，且这2个数据源的配置文件的前缀不一样，bean的名称也不一样3.DataSourceConfig实现的是将2个根据配置文件生成的不同配置源注入到容器中4.分别写2个数据源的配置文件，表名每个数据源所关联的Dao层和实体类5.在控制层注入不同的Dao就实现了采用不同的数据源访问数据库了6.</code></pre></div><p>JPA常见的数据库关系：<a href="https://niocoder.com/2018/02/28/JPA%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84%E7%B3%BB%E5%88%97%E4%B8%80-one-to-one%E5%A4%96%E9%94%AE%E5%85%B3%E8%81%94/#%E5%87%86%E5%A4%87">JPA关系映射系列一：one-to-one外键关联</a></p><div class="code-wrapper"><pre><code class="hljs bash">@OneToOne(cascade = CascadeType.ALL)@JoinColumn(name = <span class="hljs-string">&quot;book_detail_id&quot;</span>)// @Lazy(<span class="hljs-literal">false</span>)private BookDetail bookDetail@OneToOne(cascade = CascadeType.ALL)：这是一个注解，表示这个字段与另一个实体类的字段之间建立了一对一的关联关系。CascadeType.ALL表示级联操作，即当对该实体进行操作时，也会对关联的实体进行相同的操作。@JoinColumn(name = <span class="hljs-string">&quot;book_detail_id&quot;</span>)：这是一个注解，表示指定关联的外键列的名称。在数据库中，这个字段将被用作与关联实体的主键进行关联的外键列。private BookDetail bookDetail：这个字段表示关联的另一个实体类的对象。在这个例子中，它表示与Book实体关联的BookDetail实体。</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash">@OneToOne(mappedBy = <span class="hljs-string">&quot;bookDetail&quot;</span>)    private Book book;@OneToOne(mappedBy = <span class="hljs-string">&quot;bookDetail&quot;</span>)：这是一个注解，表示这个字段与另一个实体类的字段之间建立了一对一的关联关系。通过<span class="hljs-string">&quot;mappedBy&quot;</span>属性指定了与之关联的另一个实体类的字段名，这里是<span class="hljs-string">&quot;bookDetail&quot;</span>，表示该关联关系由Book实体类中的<span class="hljs-string">&quot;bookDetail&quot;</span>字段来维护。</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash">@TableGenerator(name = <span class="hljs-string">&quot;AppSeqStore&quot;</span>,table = <span class="hljs-string">&quot;APP_SEQ_STORE&quot;</span>,pkColumnName = <span class="hljs-string">&quot;APP_SEQ_NAME&quot;</span>,pkColumnValue = <span class="hljs-string">&quot;LISTENER_PK&quot;</span>,valueColumnName = <span class="hljs-string">&quot;APP_SEQ_VALUE&quot;</span>,initialValue = 10000,allocationSize = 1 )@GeneratedValue( strategy = GenerationType.TABLE, generator = <span class="hljs-string">&quot;AppSeqStore&quot;</span> )private long <span class="hljs-built_in">id</span>;@TableGenerator：这是一个注解，用于定义一个表生成器，用于生成主键的值。它具有以下属性：name：生成器的名称，用于关联到`@GeneratedValue这段代码是用于生成实体类中的主键（ID）的配置。以下是对代码的解释：@TableGenerator：这是一个注解，用于定义一个表生成器，用于生成主键的值。它具有以下属性：name：生成器的名称，用于关联到@GeneratedValue注解中的generator属性。table：生成器使用的数据库表的名称。pkColumnName：指定存储主键名称的列的名称。pkColumnValue：指定存储主键值的列的值。valueColumnName：指定存储下一个可用主键值的列的名称。initialValue：指定生成器的初始值。allocationSize：指定每次从数据库中获取的主键值的数量。@GeneratedValue：这是一个注解，用于指定生成主键值的策略。在这个例子中，使用GenerationType.TABLE作为主键生成策略，并将生成器的名称设置为AppSeqStore，与@TableGenerator中的name属性对应。private long <span class="hljs-built_in">id</span>：这个字段表示实体类的主键（ID），通过以上配置的表生成器来生成主键值。</code></pre></div><h1 id="springboot发送邮箱："><a href="#springboot发送邮箱：" class="headerlink" title="springboot发送邮箱："></a>springboot发送邮箱：</h1><p><a href="https://blog.csdn.net/qq_26383975/article/details/121957917">Springboot实现发送邮件功能-CSDN博客</a></p><div class="code-wrapper"><pre><code class="hljs bash">1.发送邮件需要知道邮件的发送者和接收者，而发送者和接受者可以在spring项目的配置文件中配置也可以通过前端传递过来。2.邮件发送靠的是spring中的JavaMailSenderImpl实例来实现的，这个实例已经注入到容器中了；可以通过 @Autowired注解来使用 3.如果发送的邮件是复杂类型则需要借助MimeMessageHelper类来实现，这个类可以配置发送者，接受者 ，主题，内容（其中的内容可以是html，text),附件地址。MimeMessageHelper接受一个MimeMessage对象 的参数</code></pre></div><h1 id="Spring-Boot-集成-Memcached："><a href="#Spring-Boot-集成-Memcached：" class="headerlink" title="Spring Boot 集成 Memcached："></a>Spring Boot 集成 Memcached：</h1><p><a href="https://blog.csdn.net/qq_39052513/article/details/109893782">Spring Boot 集成 Memcached_springboot 继承 memcached-CSDN博客</a></p><h1 id="Spring-boot集成mongodb："><a href="#Spring-boot集成mongodb：" class="headerlink" title="Spring boot集成mongodb："></a>Spring boot集成mongodb：</h1><p><a href="https://blog.csdn.net/weixin_47343544/article/details/127175205">https://blog.csdn.net/weixin_47343544&#x2F;article&#x2F;details&#x2F;127175205</a></p><h1 id="Springboot和mybatis"><a href="#Springboot和mybatis" class="headerlink" title="Springboot和mybatis:"></a>Springboot和mybatis:</h1><p>其实mybatis可以不用写mapper.xml文件，而是直接通过注解在方法名前写sql语句</p><div class="code-wrapper"><pre><code class="hljs bash">@Select(<span class="hljs-string">&quot;SELECT * FROM users&quot;</span>)@Results(&#123;@Result(property = <span class="hljs-string">&quot;userSex&quot;</span>,  column = <span class="hljs-string">&quot;user_sex&quot;</span>, javaType = UserSexEnum.class),@Result(property = <span class="hljs-string">&quot;nickName&quot;</span>, column = <span class="hljs-string">&quot;nick_name&quot;</span>)&#125;)List&lt;User&gt; getAll(); 上面的@Results是把查询的结果集映射到那种实体上； @Result(property = <span class="hljs-string">&quot;userSex&quot;</span>,  column = <span class="hljs-string">&quot;user_sex&quot;</span>, javaType = UserSexEnum.class) 中的含义是将查询表中的user_sex列和User类的userSex属性关联，至于为什么是user类是因为该方法 的返回值是一个User的List；而后面的javaType意思是映射的属性userSex为UserSexEnum类型的</code></pre></div><p>整合多数据源：<br>1.整合数据源一定，可以设置特定的配置类来实现：</p><div class="code-wrapper"><pre><code class="hljs bash">@Configuration@MapperScan(basePackages = <span class="hljs-string">&quot;com.neo.mapper.test2&quot;</span>, sqlSessionTemplateRef  = <span class="hljs-string">&quot;test2SqlSessionTemplate&quot;</span>)上面的代码是该配置类是处理com.neo.mapper.test2接口的； sqlSessionTemplateRef表示该接口中使用的sqlSessionTemplate来源是什么；其中的sqlSessionTemplate是对sqlSsion进行封装的；其中的SqlSession是 是 MyBatis 中用于执行 SQL 语句的主要接口；sqlSessionTemplateRef  = <span class="hljs-string">&quot;test2SqlSessionTemplate”表示将容器中的test2SqlSessionTemplate实例</span><span class="hljs-string">作为com.neo.mapper.test2该接口的sqlSessionTemplate；</span><span class="hljs-string">sqlSessionTemplate的产生需要SqlSessionFactory的；所以我们需要在容器中注入SqlSessionFactory；</span><span class="hljs-string">我们在sql操作中常进行事务操作，我们应该在配置类中配置事务管理器：DataSourceTransactionManager ；</span><span class="hljs-string"></span></code></pre></div><p>2.h2数据库</p><h1 id="springboot的打包jar包和war包的区别："><a href="#springboot的打包jar包和war包的区别：" class="headerlink" title="springboot的打包jar包和war包的区别："></a>springboot的打包jar包和war包的区别：</h1><p><a href="https://cloud.tencent.com/developer/article/2081558">SpringBoot项目打成war和jar的区别「建议收藏」-腾讯云开发者社区-腾讯云</a><br>1.jar包可以直接通过java -jar 项目名.jar的方式运行，不依赖外部 Servlet 容器；而war包的必须将应用部署到传统的 Servlet 容器时，如 Tomcat、Jetty 等，才能运行。<br>2.spring项目选择打成了war包可以直接通过springboot启动，这个时候使用的是springboot项目内置的容器（常为tomcat);这个运行的端口是根据项目的配置文件来决定的；当我们把war包放进一个新的tomcat容器中时，这个时候的端口不由配置文件决定而是用新的tomcat设置的端口决定。<br>3.打成war包的方法：<br><strong>修改pom.xml文件：</strong><br>在项目的 <strong>pom.xml</strong> 文件中，确保以下配置项的存在或根据需要进行修改：</p><div class="code-wrapper"><pre><code class="hljs bash">&lt;packaging&gt;war&lt;/packaging&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;</code></pre></div><ul><li><strong><packaging>war</packaging></strong> 表示你将打包成 WAR 文件。</li><li><strong><dependency></strong> 部分中，<strong>spring-boot-starter-tomcat</strong> 的 <strong><scope></strong> 设置为 <strong>provided</strong>，表示这个依赖在编译和运行时由 Servlet 容器提供，而不是包含在 WAR 文件中。</li></ul><p><strong>修改主应用类：</strong><br>如果你的应用的主类继承了 <strong>SpringBootServletInitializer</strong>，确保它的 <strong>configure</strong> 方法被正确地重写。如果还没有重写，可以添加如下代码：</p><div class="code-wrapper"><pre><code class="hljs bash">import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;public class YourApplication extends SpringBootServletInitializer &#123;    @Override    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123;        <span class="hljs-built_in">return</span> application.sources(YourApplication.class);    &#125;&#125;</code></pre></div><h1 id="springboot和redis"><a href="#springboot和redis" class="headerlink" title="springboot和redis:"></a>springboot和redis:</h1><div class="code-wrapper"><pre><code class="hljs bash">@Beanpublic KeyGenerator <span class="hljs-function"><span class="hljs-title">keyGenerator</span></span>() &#123;        <span class="hljs-built_in">return</span> new <span class="hljs-function"><span class="hljs-title">KeyGenerator</span></span>() &#123;            @Override            public Object generate(Object target, Method method, Object... params) &#123;                StringBuilder sb = new StringBuilder();                sb.append(target.getClass().getName());                sb.append(method.getName());                <span class="hljs-keyword">for</span> (Object obj : params) &#123;                    sb.append(obj.toString());                &#125;                <span class="hljs-built_in">return</span> sb.toString();            &#125;        &#125;;    &#125;</code></pre></div><p>上面是一个缓存键的生成策略</p><div class="code-wrapper"><pre><code class="hljs bash">@Cacheable(value=<span class="hljs-string">&quot;user-key&quot;</span>)</code></pre></div><p><strong>@Cacheable</strong> 注解被用于某个方法，并指定了一个缓存的名称为 **”user-key”**。但是其缓存键不是这个，</p><h1 id="定时任务："><a href="#定时任务：" class="headerlink" title="定时任务："></a>定时任务：</h1><p><a href="https://cloud.tencent.com/developer/article/1968344">SpringBoot实现定时任务的三种方式，总有一款适合你！-腾讯云开发者社区-腾讯云</a></p><div class="code-wrapper"><pre><code class="hljs bash">@Scheduled(cron=<span class="hljs-string">&quot;*/6 * * * * ?&quot;</span>)Cron表达式参数分别表示：秒，分，时，日，月，周几，年，？表示无特定值，什么都可以</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash">@Scheduled(fixedRate = 6000)fixedRate表示固定间隔时间执行，单位为毫秒，1000毫秒为1秒</code></pre></div><h1 id="springboot-Swaager"><a href="#springboot-Swaager" class="headerlink" title="springboot+Swaager:"></a>springboot+Swaager:</h1><h1 id="Webflux"><a href="#Webflux" class="headerlink" title="Webflux:"></a>Webflux:</h1><p><a href="https://blog.csdn.net/crazymakercircle/article/details/112977951">webflux + springboot 整合（史上最全）_spring boot集成webflux-CSDN博客</a><br><a href="https://www.cnblogs.com/crazymakercircle/p/16127013.html">https://www.cnblogs.com/crazymakercircle/p/16127013.html</a></p><div class="code-wrapper"><pre><code class="hljs bash">@GetMapping(<span class="hljs-string">&quot;/hello&quot;</span>)   public Mono&lt;String&gt; <span class="hljs-function"><span class="hljs-title">hello</span></span>() &#123;       <span class="hljs-built_in">return</span> Mono.just(<span class="hljs-string">&quot;Welcome to reactive world ~&quot;</span>);</code></pre></div><ul><li>Mono：实现发布者，并返回 0 或 1 个元素，即单对象</li><li>Flux：实现发布者，并返回 N 个元素，即 List 列表对象</li></ul>]]></content>
    
    
    <categories>
      
      <category>springboot2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springboot2</tag>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/01/26/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%EF%BC%9A/"/>
    <url>/2024/01/26/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h5 id="1-网关："><a href="#1-网关：" class="headerlink" title="1.网关："></a>1.网关：</h5><p><a href="https://www.itheima.com/news/20211130/153644.html">网关是什么意思？3分钟了解网关的作用</a><br>是一种网间连接器，协议转换器，<strong>它是信息从一个网络发往另一个网络需经过的一道“关口”。</strong>仅用于两个高层协议不同的网络互联。<br>如果网络A中的主机发现数据包的目的地址不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某台主机。假设网络A的IP地址范围为“192.168.1.1<del>192.168.1.254”，子网掩码为255.255.255.0;网络B的IP地址范围为“192.168.2.1</del>192.168.2.254”,子网掩码为255.255.255.0，那么网络A向网络B发送数据包的过程如下图所示。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700194845233-5198e879-64d8-41e7-81ac-57c7f55cff70.png#averageHue=%23faf9f9&clientId=u3b084d49-ee67-4&from=paste&height=322&id=u0f6f2455&originHeight=403&originWidth=821&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=118902&status=done&style=none&taskId=u82529152-0ca1-411e-aa0c-5d460ac4ebd&title=&width=656.8" alt="image.png"><br>（上图中的255.255.255.0是掩码地址）<br>网关的IP地址是用来实现不同网络之间的通信的。网关是一种网络设备，它可以将数据包从一个网络转发到另一个网络中的设备。网关的IP地址就是它的网络接口的地址，它用于标识网关在网络中的位置。网关的IP地址可以是任意的，只要符合IP地址的分配规则就行。但是为了方便管理和区分，一般会将一个网段的第一个或最后一个IP地址作为网关的IP地址。</p><h5 id="2-域名和域名查询："><a href="#2-域名和域名查询：" class="headerlink" title="2.域名和域名查询："></a>2.域名和域名查询：</h5><p><a href="https://www.cnblogs.com/crazylqy/p/7110357.html">一张图看懂DNS域名解析全过程 - crazyYong - 博客园</a><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1700195208909-17d6aae4-083c-4957-9232-bbfc7e155bc4.jpeg#averageHue=%23dcdfb5&clientId=u3b084d49-ee67-4&from=paste&id=ua2fd401b&originHeight=713&originWidth=1029&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uec578ac1-ac87-40d2-8485-7fd5b220f9b&title="></p><h5 id="HTTP-304状态码的详细讲解："><a href="#HTTP-304状态码的详细讲解：" class="headerlink" title="HTTP 304状态码的详细讲解："></a>HTTP 304状态码的详细讲解：</h5><p>自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容（因为浏览器缓存了上次请求的内容，外加网页没有修改）。</p><h5 id="get和post的区别："><a href="#get和post的区别：" class="headerlink" title="get和post的区别："></a>get和post的区别：</h5><ul><li>GET请求是用来从服务器获取数据的，而POST请求是用来向服务器发送数据的。GET请求的参数会附加在URL后面，而POST请求的参数会放在请求体中。</li><li>GET请求的参数有长度限制，一般不能超过2048个字符，而POST请求的参数没有长度限制。GET请求的参数只能是ASCII字符，而POST请求的参数可以是任意类型的数据。</li><li>GET请求可以被缓存、收藏为书签、保存在浏览器历史记录中，而POST请求不会。GET请求在回退和刷新时不会有影响，而POST请求可能会导致数据被重复提交。</li><li>GET请求相对于POST请求更不安全，因为参数会暴露在URL中，可能会泄露敏感信息。POST请求相对于GET请求更安全，因为参数不会显示在URL中。</li><li>GET请求和POST请求的语义不同，GET请求一般用于获取资源，而POST请求一般用于创建或修改资源。</li><li>GET请求参数只支持ASCLL字符集（这也说明get只支持字符串参数，而post可以支持各种类型的参数，这同时也说明get请求中不能传递中文，如果要传递中文，需要对url进行额外的编码操作），其中URL中用?分割请求地址和参数列表，参数是键值对形式，每对键值对用&amp;分割开。</li><li></li></ul><p><a href="https://cloud.tencent.com/developer/article/1529973">GET方法传递中文参数乱码解决办法-腾讯云开发者社区-腾讯云</a></p><h5 id="servlet和servlet容器："><a href="#servlet和servlet容器：" class="headerlink" title="servlet和servlet容器："></a>servlet和servlet容器：</h5><p><a href="https://blog.csdn.net/lz233333/article/details/68065749">理解Servlet和Servlet容器、Web服务器等概念-CSDN博客</a></p><h6 id="他们之间的关系："><a href="#他们之间的关系：" class="headerlink" title="他们之间的关系："></a>他们之间的关系：</h6><p>1.servlet是运行在servlet容器中的小程序，由Servlet容器所管理，用于生成动态的内容。Servlet没有main方法，不能独立运行，它必须被部署到Servlet容器中，由容器来实例化和调用 Servlet的方法（如doGet()和doPost()），Servlet容器在Servlet的生命周期内包括生成和管理Servlet。有了servlet之后，用户通过单击某个链接或者直接在浏览器的地址栏中输入URL来访问Servlet，Web服务器接收到该请求后，并不是将 请求直接交给Servlet，而是交给Servlet容器。Servlet容器实例化Servlet，调用Servlet的一个特定方法对请求进行处理， 并产生一个响应。这个响应由Servlet容器返回给Web服务器，Web服务器包装这个响应，以HTTP响应的形式发送给Web浏览器。</p><h6 id="servlet容器的作用："><a href="#servlet容器的作用：" class="headerlink" title="servlet容器的作用："></a>servlet容器的作用：</h6><p>1.通信支持:利用容器提供的方法，你能轻松的让servlet与web服务器对话，而不用自己建立serversocket、监听某个端口、创建流等 等。</p><h6 id="2-常见的servlet容器：tomcat"><a href="#2-常见的servlet容器：tomcat" class="headerlink" title="2.常见的servlet容器：tomcat"></a>2.常见的servlet容器：tomcat</h6><p>Tomcat服务器接受客户请求并做出响应的过程如下：<br>1）客户端（通常都是浏览器）访问Web服务器，发送HTTP请求。<br>2）Web服务器接收到请求后，传递给Servlet容器。<br>3）Servlet容器加载Servlet，产生Servlet实例后，向其传递表示请求和响应的对象。<br>4）Servlet实例使用请求对象得到客户端的请求信息，然后进行相应的处理。<br>5）Servlet实例将处理结果通过响应对象发送回客户端，容器负责确保响应正确送出，同时将控制返回给Web服务器。</p><h6 id="servlet生命周期："><a href="#servlet生命周期：" class="headerlink" title="servlet生命周期："></a>servlet生命周期：</h6><p><a href="https://juejin.cn/post/7147162584137859108">Servlet 的生命周期，什么是cookie，Session的详细解析，servletContext对象的详细解析 - 掘金</a><br><img src="https://cdn.nlark.com/yuque/0/2023/webp/28066124/1700201967861-0e3bffd7-f786-40d8-bc9b-f87c6083ce7f.webp#averageHue=%23fafafa&clientId=u3b084d49-ee67-4&from=paste&id=u2d8dd9cc&originHeight=676&originWidth=1512&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u4ff7aea7-5476-4904-94b5-3a3985f3f82&title="><br>1.init()<br>init方法设计为只调用一次。如果servlet的实例不存在，则Web容器：<br>加载servlet类<br>创建servlet类的实例<br>通过调用init方法初始化它<br>init方法必须成功完成之后，servlet才能接收任何请求。如果init方法抛出ServletException或在Web服务器定义的时间段内未返回，servlet容器将无法将servlet放入服务。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException &#123;    <span class="hljs-comment">// Initialization code like set up database etc....</span>&#125;</code></pre></div><p>2.service()<br>此方法仅在servlet的init（）方法成功完成后调用。<br>Container调用service（）方法来处理来自客户端的请求，解释HTTP请求类型（GET、POST、PUT、DELETE等）并酌情调用doGet、doPost、doput、doDelete等方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span>   <span class="hljs-keyword">throws</span> ServletException, IOException &#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><ol start="3"><li>destroy()</li></ol><p>由Servlet容器调用以使Servlet退出服务。<br>此方法仅在servlet的服务方法中的所有线程都退出或超时后调用。容器调用此方法后，不会在Servlet上再次调用服务方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">// </span>&#125;</code></pre></div><h6 id="servlet实践："><a href="#servlet实践：" class="headerlink" title="servlet实践："></a>servlet实践：</h6><p><a href="https://www.cnblogs.com/xuwc/p/13991809.html">spring-Servlet&#x2F;Tomcat&#x2F;Spring - 秦羽的思考 - 博客园</a>(重要较难）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700204213622-a5f6b128-f463-463d-b576-eb9d9325baab.png#averageHue=%23e7c48d&clientId=u14ed016d-7def-4&from=paste&height=251&id=u9b4d4163&originHeight=314&originWidth=667&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=29108&status=done&style=none&taskId=u06d79a7f-58f0-4fdc-8580-d9fb2fb258c&title=&width=533.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700204216495-f638fb78-c0bd-4683-9ab1-ea6ccfbc7ea3.png#averageHue=%2321221f&clientId=u14ed016d-7def-4&from=paste&height=125&id=u769039da&originHeight=156&originWidth=384&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=19420&status=done&style=none&taskId=u0dd1e5b9-07a3-463b-ae29-b0fe157a1f9&title=&width=307.2" alt="image.png"></p><h5 id="serveltContext"><a href="#serveltContext" class="headerlink" title="serveltContext:"></a>serveltContext:</h5><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1700204599469-ffc6e277-8ddc-48c1-b916-d80d748263ce.jpeg#averageHue=%23faf9f8&clientId=u14ed016d-7def-4&from=paste&id=uf370d912&originHeight=849&originWidth=1520&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u0ab560b1-b4e5-4f98-9091-e8f8fa3192b&title="><br>你可以把它想象成一个公用的空间，可以被所有的客户访问，也就是说A客户端可以访问D，B客户端可以访问D，C客户端也可以访问D。<br>WEB容器在启动时，它会为每个Web应用程序都创建一个对应的ServletContext，它代表当前Web应用。并且它被所有客户端共享。<br>ServletContext对象可以通过ServletConfig.getServletContext()方法获得对ServletContext对象的引用，也可以通过this.getServletContext()方法获得其对象的引用。<br>由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为context域对象。公共聊天室就会用到它。<br>当web应用关闭、Tomcat关闭或者Web应用reload的时候，ServletContext对象会被销毁<br>l练习：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700204615594-2b427ada-8b10-4522-a70a-9ea5e3eb9d67.png#averageHue=%23fefdfc&clientId=u14ed016d-7def-4&from=paste&height=285&id=u87d516e9&originHeight=356&originWidth=918&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=32572&status=done&style=none&taskId=u4b13422f-df8c-4e10-8c70-86f9df1ffce&title=&width=734.4" alt="image.png"></p><h5 id="sessionStorage-、localStorage-和-cookie-之间的区别"><a href="#sessionStorage-、localStorage-和-cookie-之间的区别" class="headerlink" title="sessionStorage 、localStorage 和 cookie 之间的区别"></a>sessionStorage 、localStorage 和 cookie 之间的区别</h5><p><a href="https://juejin.cn/post/6844903713098694664">sessionStorage 、localStorage 和 cookie 之间的区别 - 掘金</a></p><h5 id="html知识点："><a href="#html知识点：" class="headerlink" title="html知识点："></a>html知识点：</h5><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700205658192-5e94b6ed-db2d-4a02-99ee-c2f3e7330d38.png#averageHue=%23fefefd&clientId=u14ed016d-7def-4&from=paste&height=272&id=u1083fb3b&originHeight=340&originWidth=416&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=14726&status=done&style=none&taskId=u0db03197-f0b5-40f0-93b2-915cc776ec3&title=&width=332.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700205776261-18a3aba0-275a-48b6-97d6-59087c3a94c7.png#averageHue=%23fefefd&clientId=u14ed016d-7def-4&from=paste&height=262&id=u80c9fc87&originHeight=327&originWidth=820&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=21516&status=done&style=none&taskId=uf4157dd9-6290-4776-8eaa-c6d1124d560&title=&width=656" alt="image.png"></p><h5 id="JS知识点："><a href="#JS知识点：" class="headerlink" title="JS知识点："></a>JS知识点：</h5><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700750535386-ebe77b78-8b6c-406a-9ec5-19c3061bbccb.png#averageHue=%23fefdfc&clientId=u31d300d4-d8fe-4&from=paste&height=593&id=u2bf67d9b&originHeight=741&originWidth=623&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=42614&status=done&style=none&taskId=uf1c5a699-758c-4b7b-a2fd-4f4ce027930&title=&width=498.4" alt="image.png"><br>这是一个闭包问题，原因是：js脚本是从上往下执行的，每次循环都会为每个elements[i]元素绑定一个click事件处理函数该函数监听click事件。当元素被点击时，该事件处理函数会被调用，并且该函数会显示一个弹窗，内容是当前的i值。 所有的事件处理函数共享同一个i变量，因此它们都会显示循环结束后的i值。<br>闭包问题：<a href="https://juejin.cn/post/6844904174077870087">理解Js的闭包问题 - 掘金</a><br><a href="https://cloud.tencent.com/developer/article/1012622?areaSource=106002.5">JavaScript学习总结(三)——闭包、IIFE、原型、函数与对象-腾讯云开发者社区-腾讯云</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700753920325-bc7ca01b-e14b-4782-8e3f-00836c428c36.png#averageHue=%23fefdfd&clientId=u31d300d4-d8fe-4&from=paste&height=277&id=uf9d98854&originHeight=346&originWidth=536&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=17820&status=done&style=none&taskId=ue1409026-7c29-4adc-8681-ebd2be42379&title=&width=428.8" alt="image.png"><br>上面的题目应该这样理解：js只有单线程，可以分为主线程和任务队列，主线程执行完后才从队列中拿出没有执行完的任务，这里的setTimeout就是把里面的任务放进任务队列中，而其他任务在主线程中。<br><a href="https://coolnuanfeng.github.io/javascriptRun">深入理解 Javascript 运行机制及原型</a></p><div class="code-wrapper"><pre><code class="hljs java">事件执行JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。因此Javascript运行机制可以简单理解成一个主线程（执行栈）和一个任务队列，脚本运行时先运行主线程，主线程运行完后，从”任务队列”中读取事件，运行任务队列的任务，这个过程是循环不断的，又称Event Loop（事件循环）。</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700754363644-c59d58a0-a651-4aa4-88dc-ee0b42f40a76.png#averageHue=%23fefefe&clientId=u31d300d4-d8fe-4&from=paste&height=488&id=ucae36bdb&originHeight=610&originWidth=817&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=42879&status=done&style=none&taskId=ub3437b14-542e-4219-97d7-e2f2e355e1a&title=&width=653.6" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>零散知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javafx</title>
    <link href="/2024/01/26/javaFX/"/>
    <url>/2024/01/26/javaFX/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><p><a href="https://openjfx.cn/">JavaFX中文官方网站</a><br><a href="https://blog.csdn.net/qq_45295475/article/details/125736509">全面详细的JavaFX国语核心教程（持续更新）_javafx教程_亻乍屯页女子白勺的博客-CSDN博客</a><br><a href="https://fxdocs.github.io/docs/html5/#_scene_graph">https://fxdocs.github.io/docs/html5/#_scene_graph</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>javafx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记</title>
    <link href="/2024/01/26/day1_/"/>
    <url>/2024/01/26/day1_/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id="1-SpringBoot项目的搭建："><a href="#1-SpringBoot项目的搭建：" class="headerlink" title="1.SpringBoot项目的搭建："></a>1.SpringBoot项目的搭建：</h2><h4 id="项目介绍："><a href="#项目介绍：" class="headerlink" title="项目介绍："></a>项目介绍：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688027568791-f55ba44c-eec5-48a2-b3da-8c38a2e16a69.png#averageHue=%23eae8e7&clientId=ucabb86a5-8dff-4&from=paste&height=562&id=u5ff7ad24&originHeight=703&originWidth=1365&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=176982&status=done&style=none&taskId=ua6f0773f-df4b-47f7-b722-6f2d9f3f02c&title=&width=1092" alt="image.png"></p><h4 id="添加依赖包的介绍："><a href="#添加依赖包的介绍：" class="headerlink" title="添加依赖包的介绍："></a>添加依赖包的介绍：</h4><p>Spring Boot DevTools依赖包的介绍<br>Spring Boot DevTools 是 Spring Boot 中一个非常实用的开发工具，它提供了许多方便开发的功能，例如自动重启、自动显示错误页面、自动刷新等。DevTools 是一个可选的依赖，可以通过在 pom.xml 文件中添加依赖来引入。<br>具体来说，添加 Spring Boot DevTools 依赖的方法如下：<br>xml<br>Copy</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>这个依赖包含了许多实用的工具类和功能，例如：</p><ul><li>自动重启：在修改代码后，可以自动重新启动应用程序，从而减少开发过程中的重复操作。</li><li>自动显示错误页面：当出现错误时，可以自动显示错误页面，便于开发人员进行排查和调试。</li><li>自动刷新：当修改了静态资源（例如 HTML、CSS、JavaScript）时，可以自动刷新页面，从而方便开发人员进行调试。</li><li>热部署：可以在运行时替换类文件，从而避免应用程序重启，提高开发效率。</li></ul><p>需要注意的是，Spring Boot DevTools 只适用于开发环境，不建议在生产环境中使用。此外，由于 DevTools 中包含了许多自动化功能，可能会影响应用程序的性能和稳定性，因此需要根据实际情况进行选择和配置。<br>Lombok依赖包<br>Lombok 是一个 Java 库，它提供了许多简化 Java 代码编写的功能，例如自动生成 getter&#x2F;setter 方法、构造函数、equals 和 hashCode 方法等。Lombok 是一个可选的依赖，可以通过在 pom.xml 文件中添加依赖来引入。<br>具体来说，添加 Lombok 依赖的方法如下：<br>xml<br>Copy</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>这个依赖包含了许多实用的注解和工具类，例如：</p><ul><li>@Getter 和 @Setter：自动生成属性的 getter&#x2F;setter 方法。</li><li>@Data：自动生成属性的 getter&#x2F;setter 方法、equals 和 hashCode 方法、toString 方法和无参构造函数。</li><li>@Builder：自动生成 Builder 模式的代码，用于构建复杂的对象。</li><li>@NoArgsConstructor 和 @AllArgsConstructor：自动生成无参和全参构造函数。</li><li>@Slf4j：自动生成日志记录器，可以使用 log 变量进行日志记录。</li></ul><p>需要注意的是，Lombok 通过注解来简化代码编写，但是这些注解并不是标准的 Java 注解，因此需要使用 Lombok 的插件来解析和编译这些注解。在使用 Lombok 时，需要在开发环境中安装 Lombok 插件，以便正确地解析和编译 Lombok 注解。<br>Spring Configuration Processor依赖包<br>Spring Configuration Processor 是一个用于处理 Spring Boot 应用程序的注解处理器，可以生成用于配置 Spring 应用程序的元数据。在使用 Spring Boot 2.2 及以上版本时，可以使用 Spring Configuration Processor 来生成配置元数据，从而提高应用程序的性能和可维护性。<br>要使用 Spring Configuration Processor，需要在项目的依赖中添加以下依赖项：<br>xml<br>Copy</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>在这个依赖中，spring-boot-configuration-processor 是 Spring Configuration Processor 的实现依赖。optional 标记表示该依赖项是可选的，因为 Spring Configuration Processor 不是必需的依赖项。如果不需要使用 Spring Configuration Processor，则可以将该依赖项从项目中删除。<br>需要注意的是，Spring Configuration Processor 只能处理使用 Spring Boot 配置注解（例如 @ConfigurationProperties、@Value 等）的类，如果没有使用这些注解，则无法从中生成配置元数据。在使用 Spring Configuration Processor 时，应该遵循以下几个最佳实践：</p><ol><li>遵循 Spring Boot 的命名约定，例如将配置类命名为 application.properties 或 application.yml 中的属性名。</li><li>使用 @ConfigurationProperties 和 @Value 注解来标记配置类和属性，以便生成配置元数据。</li><li>在配置类和属性上添加必要的注释，以便生成的配置元数据具有可读性和可维护性。</li></ol><h4 id="创建配置文件："><a href="#创建配置文件：" class="headerlink" title="创建配置文件："></a>创建配置文件：</h4><p>Spring boot 的配置文件主要用来配置项目的核心配置内容， 配置文件有两种格式一种事  .properties<br>的属性文件。  另一中是  .yml&#x2F;.yaml 为后缀的  yaml 格式文件。<br>创建好springboot项目后默认会有一个属性配置文件：    application.properties<br>注意：两种配置文件只需要存在其中一种即可。    yml 格式的文件配置更加简洁明了，相较于属性<br>配置文件。</p><h6 id="属性配置文件："><a href="#属性配置文件：" class="headerlink" title="属性配置文件："></a>属性配置文件：</h6><p>**# 修改服务器的默认端口号 **<br>server.port&#x3D;8888</p><h1 id="修改一下项目的根路径"><a href="#修改一下项目的根路径" class="headerlink" title="修改一下项目的根路径"></a>修改一下项目的根路径</h1><p>server.servlet.context-path&#x3D;&#x2F;test<br>注意： 第一个等号左边是key , 右边是值， 不要在等号两边加空格。<br><strong>6.2 yaml 配置文件</strong><br>application.yml文件，全称是 YAML Ain’t Markup Language，它是以数据为中心的标记语言，比XML和<br>JSON更适合作为配置文件</p><h1 id="端口号-注意不同层级通过缩进来识别，-同一级要对齐，-属性和值之间必须用空格来分隔，-空格不能省"><a href="#端口号-注意不同层级通过缩进来识别，-同一级要对齐，-属性和值之间必须用空格来分隔，-空格不能省" class="headerlink" title="端口号    注意不同层级通过缩进来识别，    同一级要对齐，    属性和值之间必须用空格来分隔，    空格不能省"></a>端口号    注意不同层级通过缩进来识别，    同一级要对齐，    属性和值之间必须用空格来分隔，    空格不能省</h1><p>server:<br>port: 9999<br>servlet:<br>   context-path: &#x2F;demo（这里要求在项目文件下有demo文件）<br>同一级要左对齐， key和值之间需要一个空格， 不能省略，  key 的不同级使用缩进来表示<br>对于springboot的主配置文件名称必须是  application.properties 或者<br>application.yml&#x2F;yaml .</p><h4 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC:"></a>SpringMVC:</h4><p>上面pom.xml里面导入 spring-boot-starter-web 就已经引入springmvc的环境了.<br>对应的依赖：</p><!--   springMVC 应用的依赖， 包含tomcat服务等的配置     --><dependency>   <groupId>org.springframework.boot</groupId>   <artifactId>spring-boot-starter-web</artifactId> </dependency>spring-boot-starter-web 是 Spring Boot 框架提供的一个 Starter 模块，用于构建基于 Web 的应用程序。它提供了一组常用的依赖项，例如 Spring MVC、Tomcat、Jackson 和 Spring Web 等，这些依赖项可以帮助开发人员快速构建 Web 应用程序。通过在 Maven 或 Gradle 项目中引入 spring-boot-starter-web Starter 模块，开发人员可以轻松地构建一个 Web 应用程序，并且不需要手动添加依赖项。此外，Spring Boot 还为该 Starter 模块提供了默认配置，以帮助开发人员快速启动应用程序，而无需进行复杂的配置。#### 表单提交请求流程：![image.png](https://cdn.nlark.com/yuque/0/2023/png/28066124/1688087188138-19666bb0-884c-4275-b365-c7a0c75cc802.png#averageHue=%23f2f0ef&clientId=ucabb86a5-8dff-4&from=paste&height=526&id=u1e5c2d90&originHeight=658&originWidth=1359&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=174427&status=done&style=none&taskId=ud813ea41-d14e-4d7c-b546-f4df6469bbf&title=&width=1087.2)#### 相关注解：###### @RestController@RestController 是 Spring Framework 中的一个注解，用于将一个类标记为 RESTful web 服务的控制器。与传统的 Spring MVC 控制器不同，使用 @RestController 注解的类会自动将返回值转换为 JSON 或 XML 格式，并将其写入 HTTP 响应。这意味着开发人员可以更轻松地构建 RESTful Web 服务，而无需手动编写代码来序列化和反序列化数据。当一个类使用 @RestController 注解时，Spring 会自动将其识别为一个控制器，并自动进行一些配置，例如将该类中的方法映射到相应的 URL 路径上。开发人员可以使用其他注解，例如 @GetMapping、@PostMapping、@PutMapping 和 @DeleteMapping 等来定义不同的请求方法，以及它们所处理的不同 URL。Spring Framework 的核心是 Spring IOC 容器，它是一个负责管理应用程序组件的容器。在 IOC 容器中，组件之间的依赖关系被自动注入，这使得开发人员可以更加专注于编写业务逻辑，而不需要处理组件之间的耦合度。[The Spring @Controller and @RestController Annotations | Baeldung](https://www.baeldung.com/spring-controller-vs-restcontroller)###### RESTful web 服务RESTful web 服务是一种基于 REST 架构风格的 Web 服务，它使用 HTTP 协议提供数据和功能，以便其他应用程序或客户端可以通过 HTTP 请求进行访问和使用。REST 是一种架构风格，它是 Representational State Transfer 的缩写，其中表述（Representational）指的是资源的表现形式，状态（State）指的是资源在某一时间点的状态，转移（Transfer）指的是客户端根据资源状态做出的一些行为。在 RESTful web 服务中，资源通常是通过 URL（统一资源定位符）来表示的，并且可以使用 HTTP 动词（GET、POST、PUT、DELETE 等）来定义对资源的操作。例如，可以使用 GET 请求来获取资源的状态，使用 POST 请求来创建资源，使用 PUT 请求来更新资源，使用 DELETE 请求来删除资源等。此外，RESTful web 服务通常使用 JSON 或 XML 等格式来表示数据。RESTful web 服务的优点包括可伸缩性、可重用性、可扩展性和可靠性等。它已成为构建 Web 服务的一种主流架构风格，并被广泛应用于各种 Web 应用程序和移动应用程序中。]]></content>
    
    
    
    <tags>
      
      <tag>零散知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSM学习总结</title>
    <link href="/2024/01/26/SSM%E3%80%81/"/>
    <url>/2024/01/26/SSM%E3%80%81/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h1 id="Mybits"><a href="#Mybits" class="headerlink" title="Mybits:"></a>Mybits:</h1><h4 id="mybits核心配置文件："><a href="#mybits核心配置文件：" class="headerlink" title="mybits核心配置文件："></a>mybits核心配置文件：</h4><p>用于配置 MyBatis 的各种参数和属性，以及引入映射文件（Mapper）。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><span class="hljs-comment">&lt;!--&lt;!DOCTYPE&gt; 标签：声明了XML文档类型的声明，指定了使用的DTD(文档类型定义）文件的路径和版本。--&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--configuration 标签：MyBatis的配置文件必须以这个标签作为根标签，包含了所有的配置信息。--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-comment">&lt;!--设置连接数据库的环境--&gt;</span><span class="hljs-comment">&lt;!--environments 标签：用于配置 MyBatis 的环境，通过 default 属性指定默认的环境。</span><span class="hljs-comment">environment 标签：定义了一个具体的环境，通过 id 属性指定环境的名称，id=test是测试环境，id是</span><span class="hljs-comment">唯一标识不能重复。</span><span class="hljs-comment">environments是一个复数标签，里面可以存放很多environment标签--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--transactionManager 标签：用于配置事务管理器（数据库操作的管理和实现，</span><span class="hljs-comment">数据库领域，事务管理器通常是由数据库管理系统（DBMS）提供的服务，</span><span class="hljs-comment">用于确保数据库操作的原子性、一致性、隔离性和持久性（ACID）。</span><span class="hljs-comment">事务管理器提供了一种机制，使得多个数据库操作可以作为一个整体执行，</span><span class="hljs-comment">而不是独立的操作，从而避免了数据不一致和丢失的问题。），这里使用的是 JDBC 事务管理器。--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span>            <span class="hljs-comment">&lt;!--设置数据库连接--&gt;</span><span class="hljs-comment">&lt;!--dataSource 标签：用于配置数据库连接池，这里使用的是 POOLED (mybits提供是数据池连接技术）</span><span class="hljs-comment">数据源类型。--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--property 标签：用于设置数据源的属性，包括数据库驱动、URL、用户名和密码等。--&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/myemployees?</span></span><span class="hljs-string"><span class="hljs-tag">serverTimezone=UTC&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;A86789234&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span>   <span class="hljs-comment">&lt;!--引入映射文件--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>        <span class="hljs-comment">&lt;!--本配置文件和mappers文件是平行的，默认的当前目录下的mappers下的UserMapper--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span>  <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mappers/UserMapper.xml&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div><h4 id="mapper映射文件："><a href="#mapper映射文件：" class="headerlink" title="mapper映射文件："></a>mapper映射文件：</h4><p>用于定义与用户（User）相关的数据库操作。这个映射文件使用了 MyBatis 的 XML 映射语言来定义 SQL 语句和数据库操作方法。映射文件写好后要和mybits的核心配置文件关联，通过<mapper>标签关联。当我们对数据库进行操作的时候，通过调用相关的mapper接口（与xml文件映射关联了的）中的方法，其中的方法通过xml映射文件关联，然后通过映射文件完成数据库的操作。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--mapper 标签：MyBatis的映射文件必须以这个标签作为根标签，包含了所有的映射信息。</span><span class="hljs-comment">namespace 属性：指定了映射器的命名空间，用于与其他映射器区分开来。--&gt;</span><span class="hljs-comment">&lt;!--映射器：映射器（Mapper）是 MyBatis 框架中的一个组件，用于定义数据库操作和 SQL 语句与 Java 方法之间的映射关系。</span><span class="hljs-comment">映射器将 Java 对象和数据库表之间的数据映射起来，将数据库操作封装成一个个方法，使得 Java 开发人员可以使用面向对象的方式操作数据库，</span><span class="hljs-comment">而不需要编写大量的 SQL 语句。</span><span class="hljs-comment">在 MyBatis 中，映射器通常是一个接口，其中的方法定义了对数据库的操作。映射器的具体实现由 MyBatis 框架自动生成，</span><span class="hljs-comment">可以使用 XML 或者注解的方式来描述 SQL 语句以及与 Java 方法之间的映射关系--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.demo.mapper.UserMapper&quot;</span>&gt;</span>       <span class="hljs-comment">&lt;!--int insertUser();insert 标签：定义了一个插入（Insert）操作的 SQL 语句，通过 id 属性指定操作的名称。--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;InsertUser&quot;</span>&gt;</span>         insert into t_user values(&#x27;admin&#x27;,&#x27;123456&#x27;)      <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><h4 id="测试数据库添加数据操作：在test文件中建立测试类"><a href="#测试数据库添加数据操作：在test文件中建立测试类" class="headerlink" title="测试数据库添加数据操作：在test文件中建立测试类"></a>测试数据库添加数据操作：在test文件中建立测试类</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//读取MyBatis的核心配置文件</span><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>); <span class="hljs-comment">//创建SqlSessionFactoryBuilder对象</span><span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">sqlSessionFactoryBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<span class="hljs-comment">//通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象 </span><span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> sqlSessionFactoryBuilder.build(is); <span class="hljs-comment">//创建SqlSession对象，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务 </span><span class="hljs-comment">//SqlSession sqlSession = sqlSessionFactory.openSession();</span><span class="hljs-comment">//创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交 </span><span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">true</span>); <span class="hljs-comment">//通过代理模式创建UserMapper接口的代理实现类对象</span><span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<span class="hljs-comment">//调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配 </span>映射文件中的SQL标签，并执行标签中的SQL语句<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userMapper.insertUser(); <span class="hljs-comment">//上面可以不通过创建类来实现对sql的操作：</span><span class="hljs-comment">// int result = sqlSession.insert(&quot;com.example.demo.mapper.UserMapper.InsertUser&quot;);</span>sqlSession.commit();System.out.println(<span class="hljs-string">&quot;结果：&quot;</span>+result);</code></pre></div><h4 id="添加日志功能：log4j4日志框架"><a href="#添加日志功能：log4j4日志框架" class="headerlink" title="添加日志功能：log4j4日志框架"></a>添加日志功能：log4j4日志框架</h4><p>1.在pom文件中添加相关的依赖：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> &lt;/dependency</code></pre></div><p>选择的日志级别打印出来的是大于等于当前日志级别的信息。</p><h4 id="查询操作："><a href="#查询操作：" class="headerlink" title="查询操作："></a>查询操作：</h4><p>设置程序的测试程序</p><div class="code-wrapper"><pre><code class="hljs abnf">  public  void  selectUser() throws IOException &#123;    InputStream is <span class="hljs-operator">=</span>  Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis.config.xml&quot;</span>)<span class="hljs-comment">;</span>    SqlSessionFactoryBuilder sqlSessionFactoryBuilder <span class="hljs-operator">=</span> new            SqlSessionFactoryBuilder()<span class="hljs-comment">;</span>    SqlSessionFactory sqlSessionFactory <span class="hljs-operator">=</span> sqlSessionFactoryBuilder.build(is)<span class="hljs-comment">;</span>    SqlSession sqlSession <span class="hljs-operator">=</span> sqlSessionFactory.openSession(true)<span class="hljs-comment">;</span>    UserMapper userMapper <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class)<span class="hljs-comment">;</span>    User user <span class="hljs-operator">=</span> userMapper.getUserById()<span class="hljs-comment">;</span>    System.out.println(user)<span class="hljs-comment">;</span>    sqlSession.close()<span class="hljs-comment">; </span>&#125;</code></pre></div><p>修改UserMapper.xml文件<br>添加：查询的结果放在List<user>的时候其中的resultType不变。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.example.demo.object.User&quot;</span>&gt;</span>        select  *from user where  id = 1    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-comment">&lt;!--resultType:设置结果类型，即是查询结果的类型；resultMap：自定义映射，</span><span class="hljs-comment">处理多对1或者1对多的映射关系--&gt;</span></code></pre></div><h4 id="获取参数的情况："><a href="#获取参数的情况：" class="headerlink" title="获取参数的情况："></a>获取参数的情况：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688218734317-c8b32cba-caba-4a3e-85ec-135be182b45d.png#averageHue=%23efecde&clientId=ub061bfe9-9d20-4&from=paste&height=73&id=ua6f05f43&originHeight=91&originWidth=625&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=62494&status=done&style=none&taskId=uddfba630-ba37-43b5-ba9b-b25b221df27&title=&width=500" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688219517886-1a40d78f-68af-4464-9413-c21f9674d09c.png#averageHue=%23ede9db&clientId=ub061bfe9-9d20-4&from=paste&height=85&id=u084a63b8&originHeight=106&originWidth=662&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=64138&status=done&style=none&taskId=uac3440e7-d8c8-46d1-8d53-1473464335e&title=&width=529.6" alt="image.png"><br>之所以用arg0和arg1是因为当有多个参数的时候，底层会把参数储存到一个map集合中的，arg0和arg1分别对应传递过来的第一个参数和第二个参数。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688220154533-ffb0cb74-c2c9-46c7-bdd9-b1cf09d7938d.png#averageHue=%23efebdd&clientId=ub061bfe9-9d20-4&from=paste&height=42&id=ub2775b52&originHeight=53&originWidth=647&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=38063&status=done&style=none&taskId=u5c80b38c-1536-48b6-85e3-68a114f8414&title=&width=517.6" alt="image.png"><br>相当于自己手动把数值放在map集合中了，访问的时候就用自己设置的键访问即可<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688220822207-5ee1466f-9eef-479a-9975-3a0000d923f7.png#averageHue=%23efece0&clientId=ub061bfe9-9d20-4&from=paste&height=42&id=u1fafbb68&originHeight=52&originWidth=718&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=47270&status=done&style=none&taskId=ueac6e9f7-f54a-492d-8ff9-a22dd37c639&title=&width=574.4" alt="image.png"><br>因为底层将属性（get和set方法去掉get和set后的字符转小写组成的，当成员变量没有get和set方法的时候，不能当作属性）名和属性值通过map映射的，与上面的访问类似，直接在#{}括号中添加属性名即可。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688221370849-9b9d27ff-7562-4e22-8b11-a47007648023.png#averageHue=%23e5e4df&clientId=ub061bfe9-9d20-4&from=paste&height=73&id=ue4c60bfc&originHeight=91&originWidth=484&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=46966&status=done&style=none&taskId=uac55351b-f70b-4405-8fe2-9f6dd41400a&title=&width=387.2" alt="image.png">相当于在底层的map中的键是直接设置Param注解的参数绑定的</p><h4 id="mybatis的查询："><a href="#mybatis的查询：" class="headerlink" title="mybatis的查询："></a>mybatis的查询：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688226051068-fa423388-0538-4c3f-9bae-d6573c8b6f69.png#averageHue=%23f6f4eb&clientId=ub061bfe9-9d20-4&from=paste&height=48&id=u57b2519a&originHeight=60&originWidth=535&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=31220&status=done&style=none&taskId=u3f373f8b-4593-4011-bc06-b4c795ebc60&title=&width=428" alt="image.png"><br>select count(age) user:查询的时候会把age列为null的值不算入count中。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688226539314-0e2239b3-1ea3-4496-85a8-b35048a4b1d1.png#averageHue=%23588988&clientId=ub061bfe9-9d20-4&from=paste&height=84&id=u498bfa18&originHeight=105&originWidth=498&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=13606&status=done&style=none&taskId=u034aeca4-53cc-4b04-88c9-5e57462e5d5&title=&width=398.4" alt="image.png">这里的resultType实际上是别名是不区分大小写的，mybatis已经设置了常见类型的别名，这里的int和interger都可以而且不区分大小写。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688226653051-0e5fcb54-3b4d-41b0-9206-7f28f9329264.png#averageHue=%23fbfaf6&clientId=ub061bfe9-9d20-4&from=paste&height=106&id=uf1224bc8&originHeight=132&originWidth=400&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=26785&status=done&style=none&taskId=u923a0bd8-64cc-4e12-ac29-0b5301ae0f3&title=&width=320" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688227493245-b069a3f0-4244-4ba8-b8a6-8af90d7f36a7.png#averageHue=%23f7f6f4&clientId=ub061bfe9-9d20-4&from=paste&height=179&id=uaee9cf78&originHeight=224&originWidth=657&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=97741&status=done&style=none&taskId=uf5ac061a-d8b2-444d-86c2-809e13ebc23&title=&width=525.6" alt="image.png"><br>@MapKey(“id”)<br>以id为返回map的键，其中值为查询结果（通常用在有多个返回结果的查询中），如果有多个结果就返回最后一个结果。其中的id如果无法识别就用null代替，@MapKey(“id”) 注解中的 id 表示一个属性名，表示返回结果集中以哪个属性的值作为 Map 的键。</p><h4 id="特殊sql"><a href="#特殊sql" class="headerlink" title="特殊sql:"></a>特殊sql:</h4><p>模糊查询：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688255363510-f86f1244-96dd-4d98-9027-0145bc8a7f47.png#averageHue=%23ebf0e6&clientId=ub061bfe9-9d20-4&from=paste&height=103&id=u51962662&originHeight=129&originWidth=630&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=83538&status=done&style=none&taskId=ucfe563e8-86a4-4fdc-aa5f-be8c1cc360d&title=&width=504" alt="image.png"><br>批量删除：<br>动态设置表名：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688256223477-294241c0-f767-4832-92f4-e978ccac4762.png#averageHue=%231e6123&clientId=ub061bfe9-9d20-4&from=paste&height=47&id=u59acb7a9&originHeight=59&originWidth=845&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=12730&status=done&style=none&taskId=u8ddcbc86-9942-4a7a-b93c-affdfac9470&title=&width=676" alt="image.png">这里不能用#{}是因为#{}在拼接sql语句的时候自动添加了引发。</p><h4 id="处理多对1映射：注意在映射为实体类的时候，实体类中必须要有无参构造器"><a href="#处理多对1映射：注意在映射为实体类的时候，实体类中必须要有无参构造器" class="headerlink" title="处理多对1映射：注意在映射为实体类的时候，实体类中必须要有无参构造器"></a>处理多对1映射：注意在映射为实体类的时候，实体类中必须要有无参构造器</h4><p>1.级联:<br>在核心配置文件<mapper>中添加内容为：</p><div class="code-wrapper"><pre><code class="hljs applescript">&lt;resultMap <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;empDeptMap&quot;</span> type=<span class="hljs-string">&quot;com.example.demo.object.Emp&quot;</span>&gt;       &lt;<span class="hljs-built_in">id</span> column=<span class="hljs-string">&quot;emp_id&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;empId&quot;</span>&gt;&lt;/<span class="hljs-built_in">id</span>&gt;       &lt;<span class="hljs-literal">result</span> column=<span class="hljs-string">&quot;emp_name&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;empName&quot;</span>&gt;&lt;/<span class="hljs-literal">result</span>&gt;     &lt;<span class="hljs-literal">result</span> column=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;&lt;/<span class="hljs-literal">result</span>&gt;      &lt;<span class="hljs-literal">result</span> column=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;gender&quot;</span>&gt;&lt;/<span class="hljs-literal">result</span>&gt;       &lt;<span class="hljs-literal">result</span> column=<span class="hljs-string">&quot;dept_id&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;dept.id&quot;</span>&gt;&lt;/<span class="hljs-literal">result</span>&gt;       &lt;<span class="hljs-literal">result</span> column=<span class="hljs-string">&quot;dept_name&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;dept.name&quot;</span>&gt;&lt;/<span class="hljs-literal">result</span>&gt;   &lt;/resultMap&gt;   &lt;select <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;getEmpById&quot;</span> resultMap=<span class="hljs-string">&quot;empDeptMap&quot;</span>&gt;    select  *<span class="hljs-keyword">from</span>  t_emp left join  t_dept <span class="hljs-keyword">on</span> t_emp.dept_id=t_dept.dept_id <span class="hljs-keyword">where</span>  t_emp.emp_id = <span class="hljs-comment">#&#123;empId&#125;</span>   &lt;/select&gt;</code></pre></div> <resultMap><resultMap>元素可以包含多个<result>子元素，每个<result>子元素定义了如何将查询结果中的一列映射到Java对象的一个属性中。<result>子元素通常包含以下属性：<ul><li>column：指定要映射的查询结果列的名称或别名。</li><li>property：指定要映射到Java对象的属性的名称。</li><li>jdbcType：指定查询结果列的JDBC类型。</li><li>javaType：指定要映射到Java对象属性的类型。</li><li>typeHandler：指定要使用的类型处理器，用于在Java对象和数据库类型之间进行转换。<id>子元素用于定义主键的映射，<result>子元素用于定义其他属性的映射。一旦你定义了<resultMap>元素，你可以在<select>或<selectKey>元素中使用它来指定查询结果的映射方式。</li><li>java中的无参构造器在Java中，无参构造器是指一个没有参数的构造器方法。如果你在一个Java类中没有显式地定义构造器，则编译器会自动为该类生成一个无参构造器。如果你显式地定义了一个构造器方法，但没有为其指定参数，则也会生成一个无参构造器。无参构造器通常用于创建一个新的对象实例，并初始化其状态。当你创建一个Java对象时，Java编译器会自动调用该对象的无参构造器，以便初始化对象的状态。如果你要创建一个对象，并使用默认值初始化其属性，则通常可以使用无参构造器。如果你显式地定义了一个有参数的构造器，则编译器不会自动为该类生成无参构造器。如果你需要一个无参构造器，你需要显式地定义一个。</li></ul><p>2.使用<association>标签：</p><div class="code-wrapper"><pre><code class="hljs applescript">&lt;resultMap <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;empDeptMap&quot;</span> type=<span class="hljs-string">&quot;com.example.demo.object.Emp&quot;</span>&gt;    &lt;<span class="hljs-built_in">id</span> column=<span class="hljs-string">&quot;emp_id&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;empId&quot;</span>&gt;&lt;/<span class="hljs-built_in">id</span>&gt;    &lt;<span class="hljs-literal">result</span> column=<span class="hljs-string">&quot;emp_name&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;empName&quot;</span>&gt;&lt;/<span class="hljs-literal">result</span>&gt;  &lt;<span class="hljs-literal">result</span> column=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;&lt;/<span class="hljs-literal">result</span>&gt;   &lt;<span class="hljs-literal">result</span> column=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;gender&quot;</span>&gt;&lt;/<span class="hljs-literal">result</span>&gt;    &lt;association <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;dept&quot;</span> javaType=<span class="hljs-string">&quot;com.example.demo.object.Dept&quot;</span>&gt;    &lt;<span class="hljs-built_in">id</span> column=<span class="hljs-string">&quot;dept_id&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;&lt;/<span class="hljs-built_in">id</span>&gt;    &lt;<span class="hljs-literal">result</span> column=<span class="hljs-string">&quot;dept_name&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;&lt;/<span class="hljs-literal">result</span>&gt;     &lt;/association&gt;&lt;/resultMap&gt;&lt;select <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;getEmpById&quot;</span> resultMap=<span class="hljs-string">&quot;empDeptMap&quot;</span>&gt; select  *<span class="hljs-keyword">from</span>  t_emp left join  t_dept <span class="hljs-keyword">on</span> t_emp.dept_id=t_dept.dept_id <span class="hljs-keyword">where</span>  t_emp.emp_id = <span class="hljs-comment">#&#123;empId&#125;</span>&lt;/select&gt;</code></pre></div><p><association>元素用于将两个对象之间的关联关系映射到查询结果中。</p><ul><li>property：指定要映射到Java对象的属性的名称。</li><li>javaType：指定要映射到Java对象的类型。（别名或者全类名）</li><li>select：指定关联查询的语句ID，用于查询关联对象的详细信息。</li></ul><p>4.分步查询：</p><div class="code-wrapper"><pre><code class="hljs applescript">&lt;resultMap <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;EmpAndDepByStep&quot;</span> type=<span class="hljs-string">&quot;com.example.demo.object.Emp&quot;</span>&gt;     &lt;<span class="hljs-built_in">id</span> column=<span class="hljs-string">&quot;emp_id&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;empId&quot;</span>&gt;&lt;/<span class="hljs-built_in">id</span>&gt;     &lt;<span class="hljs-literal">result</span> column=<span class="hljs-string">&quot;emp_name&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;empName&quot;</span>&gt;&lt;/<span class="hljs-literal">result</span>&gt;     &lt;<span class="hljs-literal">result</span> column=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;&lt;/<span class="hljs-literal">result</span>&gt;     &lt;<span class="hljs-literal">result</span> column=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;gender&quot;</span>&gt;&lt;/<span class="hljs-literal">result</span>&gt;     &lt;association <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;dept&quot;</span>            select=<span class="hljs-string">&quot;com.example.demo.mapper.DepMapper.getEmpTwoStep&quot;</span>                  column=<span class="hljs-string">&quot;dept_id&quot;</span>&gt;     &lt;/association&gt; &lt;/resultMap&gt; &lt;select <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;getEmpAndDepByStep&quot;</span> resultMap=<span class="hljs-string">&quot;EmpAndDepByStep&quot;</span>&gt;     select *<span class="hljs-keyword">from</span> t_emp <span class="hljs-keyword">where</span>  emp_id = <span class="hljs-comment">#&#123;empid&#125;</span> &lt;/select&gt;</code></pre></div><p>select属性指定了一个名为com.example.demo.mapper.DepMapper.getEmpTwoStep的映射语句，该语句用于查询当前员工所属的部门对象。column属性指定了查询结果中用于关联的列名（即部门ID列）。注意这里的select语句指明的映射语句后的函数没有小括号。<br>如果分步查询中的Dep类的属性和表中的属性不一致的时候，可能会导致查询的dept为null这个时候使用resultMap将属性和列名重写映射就可以了。</p><h4 id="延迟加载："><a href="#延迟加载：" class="headerlink" title="延迟加载："></a>延迟加载：</h4><p>延迟加载是一种优化数据库访问的方式，可以提高系统性能和响应速度。在MyBatis中，延迟加载主要通过基于代理的方式实现。<br>基于代理的延迟加载是指，MyBatis在查询关联对象时，不会立即查询所有关联对象的数据，而是创建一个代理对象代替关联对象，在需要访问关联对象时，再实际访问数据库加载数据。这样可以避免不必要的数据库查询，提高系统性能和响应速度。<br>例如，假设你有两个实体类Emp和Dept，其中Emp类包含一个dept属性，表示员工所在的部门：</p><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">Emp</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer empId;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> empName;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> gender;    <span class="hljs-keyword">private</span> Dept dept;    <span class="hljs-comment">// getter和setter方法</span>    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">Dept</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer deptId;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> deptName;    <span class="hljs-comment">// getter和setter方法</span>    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><p>如果你使用MyBatis查询Emp对象，并同时查询dept对象，可以使用以下的XML配置文件：</p><div class="code-wrapper"><pre><code class="hljs applescript">&lt;select <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;getEmpAndDepByStep&quot;</span> resultMap=<span class="hljs-string">&quot;empResult&quot;</span>&gt;  select e.emp_id, e.emp_name, e.age, e.gender, d.dept_id, d.dept_name  <span class="hljs-keyword">from</span> t_emp e  inner join t_dept d <span class="hljs-keyword">on</span> e.dept_id = d.dept_id  <span class="hljs-keyword">where</span> e.emp_id = <span class="hljs-comment">#&#123;empId&#125;</span>&lt;/select&gt;&lt;resultMap <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;empResult&quot;</span> type=<span class="hljs-string">&quot;Emp&quot;</span>&gt;  &lt;<span class="hljs-built_in">id</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;empId&quot;</span> column=<span class="hljs-string">&quot;emp_id&quot;</span>/&gt;  &lt;<span class="hljs-literal">result</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;empName&quot;</span> column=<span class="hljs-string">&quot;emp_name&quot;</span>/&gt;  &lt;<span class="hljs-literal">result</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;age&quot;</span> column=<span class="hljs-string">&quot;age&quot;</span>/&gt;  &lt;<span class="hljs-literal">result</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;gender&quot;</span> column=<span class="hljs-string">&quot;gender&quot;</span>/&gt;  &lt;association <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;dept&quot;</span> javaType=<span class="hljs-string">&quot;Dept&quot;</span>&gt;    &lt;<span class="hljs-built_in">id</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;deptId&quot;</span> column=<span class="hljs-string">&quot;dept_id&quot;</span>/&gt;    &lt;<span class="hljs-literal">result</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;deptName&quot;</span> column=<span class="hljs-string">&quot;dept_name&quot;</span>/&gt;  &lt;/association&gt;&lt;/resultMap&gt;</code></pre></div><p>在上述配置中，association标签用于配置dept属性，resultMap属性用于指定empResult结果映射。这样，当你查询Emp对象时，MyBatis会自动查询关联的Dept对象，并将查询结果封装到Emp对象中的dept属性中。<br>如果你使用基于代理的延迟加载方式，可以在查询Emp对象时，不立即查询关联的Dept对象，而是创建一个代理对象代替Dept对象。这样，在访问dept属性时，MyBatis会自动触发查询操作，并将查询结果封装到代理对象中。<br>例如，你可以使用以下的XML配置文件启用基于代理的延迟加载：</p><div class="code-wrapper"><pre><code class="hljs n1ql">&lt;<span class="hljs-keyword">select</span> id=<span class="hljs-string">&quot;getEmpAndDepByStep&quot;</span> resultMap=<span class="hljs-string">&quot;empResult&quot;</span>&gt;  <span class="hljs-keyword">select</span> <span class="hljs-built_in">e</span>.emp_id, <span class="hljs-built_in">e</span>.emp_name, <span class="hljs-built_in">e</span>.age, <span class="hljs-built_in">e</span>.gender, <span class="hljs-built_in">e</span>.dept_id  <span class="hljs-keyword">from</span> t_emp <span class="hljs-built_in">e</span>  <span class="hljs-keyword">where</span> <span class="hljs-built_in">e</span>.emp_id = #&#123;empId&#125;&lt;/<span class="hljs-keyword">select</span>&gt;&lt;resultMap id=<span class="hljs-string">&quot;empResult&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;  &lt;id property=<span class="hljs-string">&quot;empId&quot;</span> column=<span class="hljs-string">&quot;emp_id&quot;</span>/&gt;  &lt;result property=<span class="hljs-string">&quot;empName&quot;</span> column=<span class="hljs-string">&quot;emp_name&quot;</span>/&gt;  &lt;result property=<span class="hljs-string">&quot;age&quot;</span> column=<span class="hljs-string">&quot;age&quot;</span>/&gt;  &lt;result property=<span class="hljs-string">&quot;gender&quot;</span> column=<span class="hljs-string">&quot;gender&quot;</span>/&gt;  &lt;association property=<span class="hljs-string">&quot;dept&quot;</span> javaType=<span class="hljs-string">&quot;Dept&quot;</span> <span class="hljs-keyword">select</span>=<span class="hljs-string">&quot;getDeptById&quot;</span>&gt;  &lt;/association&gt;&lt;/resultMap&gt;&lt;<span class="hljs-keyword">select</span> id=<span class="hljs-string">&quot;getDeptById&quot;</span> resultType=<span class="hljs-string">&quot;Dept&quot;</span>&gt;  <span class="hljs-keyword">select</span> dept_id, dept_name  <span class="hljs-keyword">from</span> t_dept  <span class="hljs-keyword">where</span> dept_id = #&#123;deptId&#125;&lt;/<span class="hljs-keyword">select</span>&gt;</code></pre></div><p>在上述配置中，association标签用于配置dept属性，select属性用于指定查询关联对象的SQL语句，getDeptById为查询关联对象的ID。这样，在查询Emp对象时，MyBatis会创建一个代理对象代替Dept对象，当你访问dept属性时，MyBatis会自动触发查询操作，并将查询结果封装到代理对象中。<br>需要注意的是，使用基于代理的延迟加载方式时，需要在查询结束后手动访问关联对象的属性，以触发数据加载。例如，在上述配置中，你需要手动访问Emp对象的dept属性，以触发关联对象的查询操作，代码示例如下：</p><div class="code-wrapper"><pre><code class="hljs ceylon">Emp emp = sqlSession.selectOne(<span class="hljs-string">&quot;getEmpAndDepByStep&quot;</span>, empId);System.<span class="hljs-keyword">out</span>.println(emp.getEmpName()); <span class="hljs-comment">// 访问Emp对象的属性，不会触发关联对象的查询操作</span>System.<span class="hljs-keyword">out</span>.println(emp.getDept().getDeptName()); <span class="hljs-comment">// 访问关联对象的属性，会触发关联对象的查询操作</span></code></pre></div><p>在上述代码中，你需要先访问Emp对象的属性，例如empName，以确保Emp对象已经被查询出来。然后再访问dept属性，以触发关联对象的查询操作。<br>如果你使用基于XML配置的延迟加载方式，可以在查询Emp对象时，不立即查询关联的Dept对象，而是将查询操作延迟到访问dept属性时。这样，MyBatis会自动创建代理对象，并在访问dept属性时，触发查询操作，并将查询结果封装到代理对象中。<br>例如，你可以使用以下的XML配置文件启用基于XML配置的延迟加载：</p><div class="code-wrapper"><pre><code class="hljs n1ql">&lt;<span class="hljs-keyword">select</span> id=<span class="hljs-string">&quot;getEmpAndDepByLazyLoading&quot;</span> resultMap=<span class="hljs-string">&quot;empResult&quot;</span>&gt;  <span class="hljs-keyword">select</span> <span class="hljs-built_in">e</span>.emp_id, <span class="hljs-built_in">e</span>.emp_name, <span class="hljs-built_in">e</span>.age, <span class="hljs-built_in">e</span>.gender, <span class="hljs-built_in">e</span>.dept_id  <span class="hljs-keyword">from</span> t_emp <span class="hljs-built_in">e</span>  <span class="hljs-keyword">where</span> <span class="hljs-built_in">e</span>.emp_id = #&#123;empId&#125;&lt;/<span class="hljs-keyword">select</span>&gt;&lt;resultMap id=<span class="hljs-string">&quot;empResult&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;  &lt;id property=<span class="hljs-string">&quot;empId&quot;</span> column=<span class="hljs-string">&quot;emp_id&quot;</span>/&gt;  &lt;result property=<span class="hljs-string">&quot;empName&quot;</span> column=<span class="hljs-string">&quot;emp_name&quot;</span>/&gt;  &lt;result property=<span class="hljs-string">&quot;age&quot;</span> column=<span class="hljs-string">&quot;age&quot;</span>/&gt;  &lt;result property=<span class="hljs-string">&quot;gender&quot;</span> column=<span class="hljs-string">&quot;gender&quot;</span>/&gt;  &lt;association property=<span class="hljs-string">&quot;dept&quot;</span> javaType=<span class="hljs-string">&quot;Dept&quot;</span> <span class="hljs-keyword">select</span>=<span class="hljs-string">&quot;getDeptById&quot;</span> lazyLoadingEnabled=<span class="hljs-string">&quot;true&quot;</span>&gt;  &lt;/association&gt;&lt;/resultMap&gt;&lt;<span class="hljs-keyword">select</span> id=<span class="hljs-string">&quot;getDeptById&quot;</span> resultType=<span class="hljs-string">&quot;Dept&quot;</span>&gt;  <span class="hljs-keyword">select</span> dept_id, dept_name  <span class="hljs-keyword">from</span> t_dept  <span class="hljs-keyword">where</span> dept_id = #&#123;deptId&#125;&lt;/<span class="hljs-keyword">select</span>&gt;</code></pre></div><p>在上述配置中，lazyLoadingEnabled属性用于启用基于XML配置的延迟加载。这样，在访问dept属性时，MyBatis会自动创建代理对象，并触发查询操作。<br>需要注意的是，使用基于XML配置的延迟加载方式时，需要确保在访问关联对象的属性时，MyBatis会自动触发查询操作。如果你手动访问关联对象的属性，而没有启用基于XML配置的延迟加载，那么查询操作会立即执行，而不是延迟加载。所以，建议在使用基于XML配置的延迟加载时，不要手动访问关联对象的属性，以便MyBatis可以自动触发查询操作。</p><div class="code-wrapper"><pre><code class="hljs routeros">&lt;setting <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;        &lt;setting <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;aggressiveLazyLoading&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</code></pre></div><p>这两个设置都与MyBatis的延迟加载相关。<br>lazyLoadingEnabled设置决定是否启用延迟加载。如果设置为true，则启用延迟加载；如果设置为false，则禁用延迟加载。启用延迟加载后，MyBatis将会创建代理对象代替关联对象，在需要访问关联对象时，再实际访问数据库加载数据。这样可以减少不必要的数据库访问，提高系统性能和响应速度。<br>aggressiveLazyLoading设置决定是否启用积极的延迟加载。如果设置为true，则启用积极的延迟加载；如果设置为false，则禁用积极的延迟加载。启用积极的延迟加载后，MyBatis将会尽可能多地延迟加载关联对象的数据，包括嵌套的关联对象。这样可以进一步减少不必要的数据库访问，提高系统性能和响应速度。但需要注意，启用积极的延迟加载可能会导致一些副作用，例如N+1查询问题等。<br>一般来说，启用延迟加载可以提高系统性能和响应速度，但需要根据具体的场景和需求做出权衡和选择。如果你的数据量较小，或者关联对象的数据量较少，可以考虑禁用延迟加载，直接一次性查询所有关联对象的数据。而如果你的数据量较大，或者关联对象的数据量较大，可以考虑启用延迟加载，以减少不必要的数据库访问。<br>需要注意的是，启用延迟加载后，需要在访问关联对象的属性时，才会触发数据库查询操作。因此，如果你需要使用关联对象的数据，建议在查询时同时查询关联对象的数据，以避免不必要的延迟加载操作。另外，如果你使用了基于代理的延迟加载方式，需要在访问关联对象的属性时，手动触发数据加载操作，以确保关联对象的数据已经被加载到代理对象中。</p><h4 id="通过collection处理一对多映射关系："><a href="#通过collection处理一对多映射关系：" class="headerlink" title="通过collection处理一对多映射关系："></a>通过collection处理一对多映射关系：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688284752974-610d453d-40df-4cf7-a210-545e1ec8fd48.png#averageHue=%23fbf9f2&clientId=ub061bfe9-9d20-4&from=paste&height=59&id=u5ad784bd&originHeight=74&originWidth=316&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=11977&status=done&style=none&taskId=u00797a95-d021-4a47-9b35-71f49b75973&title=&width=252.8" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs applescript">&lt;collection <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;emps&quot;</span> ofType=<span class="hljs-string">&quot;com.example.demo.object.Emp&quot;</span>&gt;            &lt;<span class="hljs-built_in">id</span> column=<span class="hljs-string">&quot;emp_id&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;empId&quot;</span>&gt;&lt;/<span class="hljs-built_in">id</span>&gt;            &lt;<span class="hljs-literal">result</span> column=<span class="hljs-string">&quot;emp_name&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;empName&quot;</span>&gt;&lt;/<span class="hljs-literal">result</span>&gt;            &lt;<span class="hljs-literal">result</span> column=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;&lt;/<span class="hljs-literal">result</span>&gt;            &lt;<span class="hljs-literal">result</span> column=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;gender&quot;</span>&gt;&lt;/<span class="hljs-literal">result</span>&gt;        &lt;/collection&gt;</code></pre></div><p>这段XML配置代码用于配置一个集合类型的结果映射。<br><collection>标签用于指定集合属性的结果映射。其中，property属性指定集合属性的名称，ofType属性指定集合元素的类型。<br>在<collection>标签中，可以使用<id>标签和<result>标签配置集合元素的属性。<id>标签用于指定集合元素的主键属性，column属性指定数据库表中的主键列名，property属性指定Java对象中的属性名。<result>标签用于指定集合元素的普通属性，column属性指定数据库表中的列名，property属性指定Java对象中的属性名。<br>例如，上述XML配置代码中，<collection>标签配置了一个名为emps的集合属性，元素类型为com.example.demo.object.Emp。<id>标签指定了集合元素的主键属性为empId，<result>标签指定了集合元素的普通属性为empName、age和gender。当MyBatis查询结果包含多个Emp对象时，会自动将这些对象封装到emps集合中，其中每个Emp对象的属性值根据XML配置进行映射。<br>需要注意的是，如果你在查询结果中包含了集合类型的属性，需要使用<collection>标签进行结果映射。另外，如果你使用了基于代理的延迟加载方式，需要在访问集合属性时，手动触发数据加载操作，以确保集合元素的数据已经被加载到代理对象中。</p><h4 id="分步查询处理一对多的关系："><a href="#分步查询处理一对多的关系：" class="headerlink" title="分步查询处理一对多的关系："></a>分步查询处理一对多的关系：</h4><p>depMapper中的内容：</p><div class="code-wrapper"><pre><code class="hljs bash">&lt;/select&gt;  &lt;resultMap <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;DeptAndEmpStepOne&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;com.example.demo.object.Dept&quot;</span>&gt;      &lt;<span class="hljs-built_in">id</span> column=<span class="hljs-string">&quot;dept_id&quot;</span> property=<span class="hljs-string">&quot;Id&quot;</span>&gt;&lt;/id&gt;      &lt;result column=<span class="hljs-string">&quot;dept_name&quot;</span> property=<span class="hljs-string">&quot;name&quot;</span>&gt;&lt;/result&gt;      &lt;collection property=<span class="hljs-string">&quot;emps&quot;</span>                  <span class="hljs-keyword">select</span>=<span class="hljs-string">&quot;com.example.demo.mapper.EmpMapper.DeptAndDeptTwo&quot;</span>                  column=<span class="hljs-string">&quot;dept_id&quot;</span>&gt;      &lt;/collection&gt;  &lt;/resultMap&gt;  &lt;<span class="hljs-keyword">select</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;getDeptAndEmpStepOne&quot;</span> resultMap=<span class="hljs-string">&quot;DeptAndEmpStepOne&quot;</span>&gt;      <span class="hljs-keyword">select</span> *from  t_dept <span class="hljs-built_in">where</span>  dept_id = <span class="hljs-comment">#&#123;deptId&#125;</span>  &lt;/select&gt;</code></pre></div><p>employees中：</p><div class="code-wrapper"><pre><code class="hljs axapta">q &lt;<span class="hljs-keyword">select</span> id=<span class="hljs-string">&quot;DeptAndDeptTwo&quot;</span> resultType=<span class="hljs-string">&quot;com.example.demo.object.Emp&quot;</span>&gt;        <span class="hljs-keyword">select</span>  *<span class="hljs-keyword">from</span>  t_emp <span class="hljs-keyword">where</span>  dept_id=<span class="hljs-meta">#&#123;deptId&#125;</span>    &lt;/<span class="hljs-keyword">select</span>&gt;</code></pre></div><h4 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql:"></a>动态sql:</h4><p>前段没有传递某些参数，而服务器获取这些参数，器结果为null；如果前端传来的表单文本框内容没有填写，后端获取的就是空字符串。</p><h6 id="if标签："><a href="#if标签：" class="headerlink" title="if标签："></a>if标签：</h6><p>下面（代码2）是根据empName和age,gender来查找的，但是当empName为null或者空字符串的时候，会报sql语法错误（原因是拼接的时候empName那个sql片段没有拼接进去，可能拼接了后面的sql片段对了and)解决方法在在第一个if标签前面添加一个恒成立条件：方法2是用where标签</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">select</span>  *from  t_emp <span class="hljs-built_in">where</span>  1 = 1 &lt;<span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> = <span class="hljs-string">&quot;emp.empName != null and emp.empName != &#x27;&#x27;&quot;</span>&gt;    and emp_name = <span class="hljs-comment">#&#123;emp.empName&#125;</span>&lt;/if&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash">&lt;<span class="hljs-keyword">select</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;getEmpsByCondition&quot;</span> resultType=<span class="hljs-string">&quot;com.example.demo.object.Emp&quot;</span>&gt;<span class="hljs-keyword">select</span>  *from  t_emp <span class="hljs-built_in">where</span>  &lt;<span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> = <span class="hljs-string">&quot;emp.empName != null and emp.empName != &#x27;&#x27;&quot;</span>&gt;    emp_name = <span class="hljs-comment">#&#123;emp.empName&#125;</span>&lt;/if&gt;&lt;<span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span>=<span class="hljs-string">&quot;emp.age !=null and emp.age != &#x27;&#x27;&quot;</span> &gt;    and age = <span class="hljs-comment">#&#123;emp.age&#125;</span>&lt;/if&gt;&lt;<span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span>=<span class="hljs-string">&quot;emp.gender != null and emp.gender!=&#x27;&#x27;&quot;</span>&gt;    and gender = <span class="hljs-comment">#&#123;emp.gender&#125;</span>&lt;/if&gt;&lt;/select&gt;</code></pre></div><p>注意上面的if标签中的属性要添加变量名，不然会报找不到empName的错误。<br><if test = "empName != null and empName != ''"><br>emp_name &#x3D; #{empName}<br></if>（这个会报错的）</p><h6 id="where"><a href="#where" class="headerlink" title="where:"></a>where:</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688383957268-bb9ca8b7-ef7c-438d-b045-e1745a67f96f.png#averageHue=%23f7f6f3&clientId=u8aa2d897-50f1-4&from=paste&height=108&id=u55e2024c&originHeight=135&originWidth=673&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=70114&status=done&style=none&taskId=ua3be383d-c361-4141-b8dd-b3becf137d8&title=&width=538.4" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs bash">&lt;/select&gt;    &lt;<span class="hljs-keyword">select</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;getEmpsByConditionWhere&quot;</span> resultType=<span class="hljs-string">&quot;com.example.demo.object.Emp&quot;</span>&gt;        <span class="hljs-keyword">select</span>  *from  t_emp        &lt;<span class="hljs-built_in">where</span>&gt;            &lt;<span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> = <span class="hljs-string">&quot;emp.empName != null and emp.empName != &#x27;&#x27;&quot;</span>&gt;                and emp_name = <span class="hljs-comment">#&#123;emp.empName&#125;</span>            &lt;/if&gt;            &lt;<span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span>=<span class="hljs-string">&quot;emp.age !=null and emp.age != &#x27;&#x27;&quot;</span> &gt;                and age = <span class="hljs-comment">#&#123;emp.age&#125;</span>            &lt;/if&gt;            &lt;<span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span>=<span class="hljs-string">&quot;emp.gender != null and emp.gender!=&#x27;&#x27;&quot;</span>&gt;                and gender = <span class="hljs-comment">#&#123;emp.gender&#125;</span>            &lt;/if&gt;        &lt;/where&gt;    &lt;/select&gt;</code></pre></div><h6 id="trim标签："><a href="#trim标签：" class="headerlink" title="trim标签："></a>trim标签：</h6><div class="code-wrapper"><pre><code class="hljs bash">&lt;/select&gt;   &lt;<span class="hljs-keyword">select</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;getEmpsByConditionTrim&quot;</span> resultType=<span class="hljs-string">&quot;com.example.demo.object.Emp&quot;</span>&gt;       <span class="hljs-keyword">select</span>  *from  t_emp       &lt;trim prefix=<span class="hljs-string">&quot;where&quot;</span>  suffixOverrides=<span class="hljs-string">&quot;and&quot;</span>&gt;           &lt;<span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> = <span class="hljs-string">&quot;emp.empName != null and emp.empName != &#x27;&#x27;&quot;</span>&gt;                emp_name = <span class="hljs-comment">#&#123;emp.empName&#125; and</span>           &lt;/if&gt;           &lt;<span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span>=<span class="hljs-string">&quot;emp.age !=null and emp.age != &#x27;&#x27;&quot;</span> &gt;                age = <span class="hljs-comment">#&#123;emp.age&#125; and</span>           &lt;/if&gt;           &lt;<span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span>=<span class="hljs-string">&quot;emp.gender != null and emp.gender!=&#x27;&#x27;&quot;</span>&gt;                gender = <span class="hljs-comment">#&#123;emp.gender&#125;</span>           &lt;/if&gt;       &lt;/trim&gt;   &lt;/select&gt;</code></pre></div><p><trim> 标签是 MyBatis 中用于生成动态 SQL 的标签之一，它可以用于去除 SQL 语句中不必要的逗号、AND 或者 OR 等关键字，从而生成更加紧凑的 SQL 语句。<br><trim> 标签有以下属性：</p><ul><li>prefix：在 SQL 语句开头添加的字符串。</li><li>suffix：在 SQL 语句结尾添加的字符串。</li><li>prefixOverrides：需要去除的 SQL 语句开头的字符串。</li><li>suffixOverrides：需要去除的 SQL 语句结尾的字符串。</li></ul><p><trim> 标签的语法如下：</p><div class="code-wrapper"><pre><code class="hljs abnf">&lt;trim prefix<span class="hljs-operator">=</span><span class="hljs-string">&quot;&quot;</span> suffix<span class="hljs-operator">=</span><span class="hljs-string">&quot;&quot;</span> prefixOverrides<span class="hljs-operator">=</span><span class="hljs-string">&quot;&quot;</span> suffixOverrides<span class="hljs-operator">=</span><span class="hljs-string">&quot;&quot;</span>&gt;  SQL statement&lt;/trim&gt;</code></pre></div><p>其中，prefix 和 suffix 属性用于添加前缀和后缀，prefixOverrides 和 suffixOverrides 属性用于去除开头和结尾的字符串。<br>下面是一个使用 <trim> 标签的示例：</p><div class="code-wrapper"><pre><code class="hljs bash">&lt;<span class="hljs-keyword">select</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;findUsersByCondition&quot;</span> resultType=<span class="hljs-string">&quot;User&quot;</span>&gt;  SELECT * FROM user  &lt;<span class="hljs-built_in">where</span>&gt;    &lt;trim prefix=<span class="hljs-string">&quot;AND&quot;</span> prefixOverrides=<span class="hljs-string">&quot;AND (&quot;</span>&gt;      &lt;<span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span>=<span class="hljs-string">&quot;username != null&quot;</span>&gt;        username = <span class="hljs-comment">#&#123;username&#125;</span>      &lt;/if&gt;      &lt;<span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span>=<span class="hljs-string">&quot;age != null&quot;</span>&gt;        AND age = <span class="hljs-comment">#&#123;age&#125;</span>      &lt;/if&gt;    &lt;/trim&gt;  &lt;/where&gt;&lt;/select&gt;</code></pre></div><p>在这个示例中，<trim> 标签用于去除 SQL 语句中多余的 AND 关键字。如果 username 或者 age 参数不为空，则会生成类似于 AND username &#x3D; #{username} AND age &#x3D; #{age} 的 SQL 语句，否则只会生成 SELECT * FROM user 的 SQL 语句。</p><h6 id="choose-when-otherwise等标签"><a href="#choose-when-otherwise等标签" class="headerlink" title="choose,when,otherwise等标签"></a>choose,when,otherwise等标签</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688384511573-607a6751-25cb-46ca-b1f5-51cc3930e8c8.png#averageHue=%23f7f5ef&clientId=u8aa2d897-50f1-4&from=paste&height=60&id=u0073258c&originHeight=75&originWidth=360&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=25763&status=done&style=none&taskId=ucb5a20f8-c3ba-4791-91b7-5e77c316ed1&title=&width=288" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs bash">&lt;<span class="hljs-keyword">select</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;findUsers&quot;</span> resultType=<span class="hljs-string">&quot;User&quot;</span>&gt;  SELECT * FROM <span class="hljs-built_in">users</span>  &lt;<span class="hljs-built_in">where</span>&gt;    &lt;choose&gt;      &lt;when <span class="hljs-built_in">test</span>=<span class="hljs-string">&quot;username != null&quot;</span>&gt;        AND username = <span class="hljs-comment">#&#123;username&#125;</span>      &lt;/when&gt;      &lt;when <span class="hljs-built_in">test</span>=<span class="hljs-string">&quot;email != null&quot;</span>&gt;        AND email = <span class="hljs-comment">#&#123;email&#125;</span>      &lt;/when&gt;      &lt;otherwise&gt;        AND status = 1      &lt;/otherwise&gt;    &lt;/choose&gt;  &lt;/where&gt;&lt;/select&gt;</code></pre></div><p>在这个示例中，<choose> 标签用于选择一个条件分支，如果 username 参数不为空，则会生成 AND username &#x3D; #{username} 的 SQL 语句，否则如果 email 参数不为空，则会生成 AND email &#x3D; #{email} 的 SQL 语句，否则会生成 AND status &#x3D; 1 的 SQL 语句。<br><choose> 标签通常与 <when> 和 <otherwise> 标签配合使用。<when> 标签用于定义一个条件分支，<otherwise> 标签定义了一个默认的条件分支，它会在所有其他条件都不成立时执行。</p><h6 id="foreach"><a href="#foreach" class="headerlink" title="foreach:"></a>foreach:</h6><p>批量添加：注意<foreach>标签中的#{emp.empName}中的emp不能省略</p><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!--如果以List传递过来，底层仍旧是map只不过是以list为键,如果以@Parame注解的参数，传递给@Parame的参数就是底层map的键--&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertMoreEmp&quot;</span> &gt;</span></span><span class="language-xml">      insert  into  t_emp values</span><span class="language-xml">                              <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;emps&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span></span><span class="language-xml">                                  (null,#</span><span class="hljs-template-variable">&#123;emp.empName&#125;</span><span class="language-xml">,#</span><span class="hljs-template-variable">&#123;emp.age&#125;</span><span class="language-xml">,#</span><span class="hljs-template-variable">&#123;emp.gender&#125;</span><span class="language-xml">,null)</span><span class="language-xml">                              <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span></code></pre></div><h4 id="Param"><a href="#Param" class="headerlink" title="@Param"></a>@Param</h4><p>@Param 是 MyBatis 中用于指定方法参数名称的注解。在 MyBatis 中，如果一个方法有多个参数，则必须使用 @Param 注解来指定每个参数的名称，以便 MyBatis 可以正确地将参数传递给 SQL 语句。<br>@Param 注解有一个可选的 value 属性，用于指定参数的名称。例如：</p><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;  List&lt;User&gt; findUsersByUsernameAndEmail(    <span class="hljs-meta">@Param</span>(<span class="hljs-string">&quot;username&quot;</span>) <span class="hljs-keyword">String</span> username,    <span class="hljs-meta">@Param</span>(<span class="hljs-string">&quot;email&quot;</span>) <span class="hljs-keyword">String</span> email);&#125;</code></pre></div><p>在这个示例中，findUsersByUsernameAndEmail 方法有两个参数，分别是 username 和 email，并且使用 @Param 注解指定了它们的名称。在 SQL 语句中，可以使用 #{username} 和 #{email} 占位符来引用这两个参数。<br>需要注意的是，如果方法只有一个参数，并且这个参数是一个简单类型（如 int、String 等），则可以不使用 @Param 注解。在这种情况下，MyBatis 会将参数默认命名为 arg0、arg1 等。但是，为了代码的可读性和可维护性，建议在所有情况下都使用 @Param 注解来指定参数名称。<br>在 XML 映射文件中，可以使用 parameterType 属性来指定方法参数的类型，例如：</p><div class="code-wrapper"><pre><code class="hljs bash">&lt;<span class="hljs-keyword">select</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;findUsersByUsernameAndEmail&quot;</span> resultType=<span class="hljs-string">&quot;User&quot;</span>&gt;  SELECT * FROM <span class="hljs-built_in">users</span>  WHERE username = <span class="hljs-comment">#&#123;username&#125; AND email = #&#123;email&#125;</span>&lt;/select&gt;</code></pre></div><p>在这个示例中，parameterType 属性指定了方法参数的类型为 java.util.Map，并且在 SQL 语句中使用了 #{username} 和 #{email} 占位符来引用参数。如果使用了 @Param 注解，则可以省略 parameterType 属性。</p><h4 id="List-list-Arrays-asList-emp1-emp2-emp3"><a href="#List-list-Arrays-asList-emp1-emp2-emp3" class="headerlink" title="List list &#x3D; Arrays.asList(emp1,emp2,emp3);"></a>List<Emp> list &#x3D; Arrays.asList(emp1,emp2,emp3);</h4><p>这段代码使用了 Java 的 Arrays.asList() 方法将多个 Emp 对象封装成一个 List<Emp> 对象。<br>Arrays.asList() 方法是 Java 中一个常用的工具方法，它可以将一个数组转换为一个 List 对象。在这个示例中，Arrays.asList() 方法将多个 Emp 对象封装成一个 List<Emp> 对象，并将这个 List<Emp> 对象赋给了变量 list。<br>需要注意的是，Arrays.asList() 方法返回的 List 对象是一个固定大小的 List 对象，不能进行添加或删除操作。如果需要进行添加或删除操作，可以使用 ArrayList 等可变大小的 List 实现类来创建 List 对象。例如：</p><div class="code-wrapper"><pre><code class="hljs routeros">List&lt;Emp&gt; list = new ArrayList&lt;&gt;();list.<span class="hljs-built_in">add</span>(emp1);list.<span class="hljs-built_in">add</span>(emp2);list.<span class="hljs-built_in">add</span>(emp3);</code></pre></div><p>在这个示例中，使用 ArrayList 来创建 List<Emp> 对象，并分别添加了三个 Emp 对象。ArrayList 是一个可变大小的 List 实现类，可以进行添加和删除操作。</p><h4 id="foreach标签实现批量删除（通过数组）："><a href="#foreach标签实现批量删除（通过数组）：" class="headerlink" title="foreach标签实现批量删除（通过数组）："></a>foreach标签实现批量删除（通过数组）：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688389747602-947eb4c7-4bfd-4da1-a301-37291e46e86d.png#averageHue=%23f8f7f3&clientId=u8aa2d897-50f1-4&from=paste&height=109&id=ub9b07fed&originHeight=136&originWidth=495&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=50545&status=done&style=none&taskId=u814a3966-0855-45ff-951d-b2b8fbff284&title=&width=396" alt="image.png"><br>方法1:<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688389723082-9bb1dfaa-9058-436c-9232-69886af988cf.png#averageHue=%23f4e8be&clientId=u8aa2d897-50f1-4&from=paste&height=88&id=udc12c1a4&originHeight=110&originWidth=598&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=44948&status=done&style=none&taskId=uf6b698b0-12f4-479a-a3af-4344566010d&title=&width=478.4" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">delete</span> id=&quot;deleteMoreEmp&quot;&gt;     <span class="hljs-keyword">delete</span>  <span class="hljs-keyword">from</span> t_emp <span class="hljs-keyword">where</span> emp_id <span class="hljs-keyword">in</span>                             &lt;<span class="hljs-keyword">foreach</span> collection=&quot;empIds&quot; item=&quot;empId&quot; separator=&quot;,&quot; <span class="hljs-keyword">open</span>=&quot;(&quot; <span class="hljs-keyword">close</span>=&quot;)&quot;&gt;                                #&#123;empId&#125;                            &lt;/<span class="hljs-keyword">foreach</span>&gt; &lt;/<span class="hljs-keyword">delete</span>&gt;</code></pre></div><p>在 <delete> 标签中使用了 <foreach> 标签，将 empIds 集合中的多个 empId 值循环插入到 SQL 语句中。其中，collection 属性指定了要循环遍历的集合，item 属性指定了集合中的每个 empId 值在 SQL 语句中的占位符名称。，separator 属性的值为逗号 ,，表示在循环遍历 empIds 集合时，每个 empId 值之间会使用逗号作为分隔符分隔。这样，在 SQL 语句中生成的 IN 子句就会以逗号分隔 emp_id 值。open 属性的值为左括号 (，close 属性的值为右括号 )，表示在循环遍历 empIds 集合时，会在 emp_id 值的前后分别添加一个左括号和一个右括号，以便生成正确的 IN 子句。</p><h4 id="数据库中的某条数据不为空但是利用mybatis中的mapper查询的时候返回的部分属性为null的原因："><a href="#数据库中的某条数据不为空但是利用mybatis中的mapper查询的时候返回的部分属性为null的原因：" class="headerlink" title="数据库中的某条数据不为空但是利用mybatis中的mapper查询的时候返回的部分属性为null的原因："></a>数据库中的某条数据不为空但是利用mybatis中的mapper查询的时候返回的部分属性为null的原因：</h4><p>1，返回为null的属性没有正确的get和set方法或者返回的类没有无参构造方法。<br>2.数据库中的列的数据类型和类中的数据类型不一致<br>3.<strong>有get和set方法但是类中的属性和数据库列中的名字（不区分大小写）不一样（可以通过resultMap重新映射或者设置别名解决</strong><br>4。查询语句正确指定数据库列的别名（可以通过在 SQL 语句中使用 SELECT 子句并为列指定别名来指定列的别名。例如，假设要查询 employees 表中的 emp_id 和 emp_name 两列，可以使用以下 SQL 语句：</p><div class="code-wrapper"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> emp_id <span class="hljs-keyword">AS</span> empId, emp_name <span class="hljs-keyword">AS</span> empName <span class="hljs-keyword">FROM</span> employees</code></pre></div><p>在这个 SQL 语句中，使用 AS 关键字为 emp_id 和 emp_name 列指定了别名 empId 和 empName。这样，在 MyBatis 将查询结果映射为 Emp 对象时，就会将 empId 列的值映射到 Emp 对象的 empId 属性中，将 empName 列的值映射到 Emp 对象的 empName 属性中。<br>如果使用 MyBatis 提供的 Mapper XML 文件来编写 SQL 语句，可以在 <resultMap> 标签中使用 <result> 标签来指定列的别名。例如：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span>resultMap id<span class="hljs-operator">=</span>&quot;empResultMap&quot; type<span class="hljs-operator">=</span>&quot;Emp&quot;<span class="hljs-operator">&gt;</span>  <span class="hljs-operator">&lt;</span><span class="hljs-keyword">result</span> <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;emp_id&quot; property<span class="hljs-operator">=</span>&quot;empId&quot;<span class="hljs-operator">/</span><span class="hljs-operator">&gt;</span>  <span class="hljs-operator">&lt;</span><span class="hljs-keyword">result</span> <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;emp_name&quot; property<span class="hljs-operator">=</span>&quot;empName&quot;<span class="hljs-operator">/</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>resultMap<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">select</span> id<span class="hljs-operator">=</span>&quot;selectEmps&quot; resultMap<span class="hljs-operator">=</span>&quot;empResultMap&quot;<span class="hljs-operator">&gt;</span>  <span class="hljs-keyword">SELECT</span> emp_id, emp_name <span class="hljs-keyword">FROM</span> employees<span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">select</span><span class="hljs-operator">&gt;</span></code></pre></div><p>在这个示例中，使用 <result> 标签为 emp_id 和 emp_name 列指定了别名 empId 和 empName。在 <select> 标签中，使用 resultMap 属性指定了要使用的结果映射规则。这样，在 MyBatis 映射查询结果时，就会将 empId 列的值映射到 Emp 对象的 empId 属性中，将 empName 列的值映射到 Emp 对象的 empName 属性中。）</p><h4 id="sql标签："><a href="#sql标签：" class="headerlink" title="sql标签："></a>sql标签：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688389907859-50743d07-8203-4331-88fa-a19ddf64a86e.png#averageHue=%23f7f8f3&clientId=u8aa2d897-50f1-4&from=paste&height=110&id=ubc3e8d00&originHeight=137&originWidth=492&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=46143&status=done&style=none&taskId=u491a6728-31dc-42f3-80fb-0e67c23ee9c&title=&width=393.6" alt="image.png"><br>MyBatis 中的 <sql> 标签用于定义可重用的 SQL 片段，可以在 Mapper XML 文件中定义 <sql> 标签，并在需要使用这些 SQL 片段的地方引用它们。<br>例如，可以在 Mapper XML 文件中定义一个 <sql> 标签，用于定义一个可重用的 SQL 片段：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectColumns&quot;</span>&gt;</span>  emp_id, emp_name, emp_salary<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span></code></pre></div><p>在这个示例中，<sql> 标签的 id 属性指定了 SQL 片段的名称为 selectColumns，<sql> 标签的内容为 SQL 片段的内容，包括查询的列名。<br>在需要使用这个 SQL 片段的地方，可以使用 ${} 占位符来引用它。例如：</p><div class="code-wrapper"><pre><code class="hljs axapta">&lt;<span class="hljs-keyword">select</span> id=<span class="hljs-string">&quot;selectEmp&quot;</span> resultType=<span class="hljs-string">&quot;Emp&quot;</span>&gt;  <span class="hljs-keyword">select</span> &lt;include refid=<span class="hljs-string">&quot;selectColumns&quot;</span>/&gt; <span class="hljs-keyword">from</span> t_emp  <span class="hljs-keyword">where</span> emp_id = <span class="hljs-meta">#&#123;empId&#125;</span>&lt;/<span class="hljs-keyword">select</span>&gt;</code></pre></div><p>在这个示例中，使用 <include> 标签引用了之前定义的 SQL 片段，refid 属性指定了 SQL 片段的名称为 selectColumns。这样，在生成 SQL 语句时，MyBatis 会将 <include> 标签替换为 SQL 片段的内容，生成完整的 SQL 语句。<br>使用 <sql> 标签可以避免在 Mapper XML 文件中重复编写相同的 SQL 片段，提高了代码的重用性和可维护性。同时，使用 <sql> 标签还可以将复杂的 SQL 语句拆分为多个可重用的 SQL 片段，使 SQL 语句更加清晰易懂。</p><h4 id="Mybatis的一级缓存："><a href="#Mybatis的一级缓存：" class="headerlink" title="Mybatis的一级缓存："></a>Mybatis的一级缓存：</h4><p>MyBatis 的一级缓存是指在同一个 SqlSession 中，对于相同的查询语句和查询条件，MyBatis 可以将查询结果缓存起来，以便后续的查询可以直接使用缓存中的数据，而不需要再次执行 SQL 查询。<br>一级缓存是 MyBatis 默认开启的，它存储在 SqlSession 中，可以提高查询效率，减少与数据库的交互次数。在同一个 SqlSession 中，如果多次查询相同的数据，那么只有第一次查询会触发 SQL 查询，后续的查询都会从缓存中获取数据，从而提高查询效率。<br>一级缓存的实现方式是将查询结果存储在一个 Map 对象中，Map 的键值是查询语句和查询条件的组合，Map 的值是查询结果。在同一个 SqlSession 中，如果执行了更新、插入或删除操作，那么 MyBatis 会自动清空一级缓存，以保证缓存中的数据与数据库保持一致。<br>需要注意的是，一级缓存的作用范围仅限于同一个 SqlSession 中，如果使用多个 SqlSession 进行查询，那么每个 SqlSession 都会独立地维护自己的一级缓存。因此，在某些情况下，如果需要共享缓存，可以考虑使用 MyBatis 的二级缓存。<br>另外，MyBatis 还提供了一些配置选项，可以对一级缓存进行调整或禁用。例如，可以通过设置 localCacheScope 属性为 STATEMENT 来禁用一级缓存，或者通过设置 flushCache&#x3D;”true” 属性来强制清空一级缓存。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688396424415-687b36d7-e3c3-4a5f-9f23-a02fb1b58f9b.png#averageHue=%23f8f6f2&clientId=u8aa2d897-50f1-4&from=paste&height=73&id=u8026bf37&originHeight=91&originWidth=652&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=41428&status=done&style=none&taskId=uc01ff294-247e-46ce-8889-263a6b86699&title=&width=521.6" alt="image.png"></p><h4 id="一级缓存失效的方法："><a href="#一级缓存失效的方法：" class="headerlink" title="一级缓存失效的方法："></a>一级缓存失效的方法：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688396541434-1cd69218-c8aa-41cf-aaf4-5a5c0eef141d.png#averageHue=%23f3f0e3&clientId=u8aa2d897-50f1-4&from=paste&height=76&id=uefa3461d&originHeight=95&originWidth=539&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=52768&status=done&style=none&taskId=u3b11ab90-74ff-40ea-879d-d74e672b542&title=&width=431.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688396659083-f001f90c-23d1-4c6a-9a20-94fbd5b384b3.png#averageHue=%230c105a&clientId=u8aa2d897-50f1-4&from=paste&height=26&id=u1fa572bb&originHeight=33&originWidth=430&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=5630&status=done&style=none&taskId=uc3449976-cac5-4456-b241-d26d5e2d19b&title=&width=344" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688396689464-0d97e285-c710-4b7a-a84d-259467bc55ae.png#averageHue=%230a0806&clientId=u8aa2d897-50f1-4&from=paste&height=186&id=u2d7e60d4&originHeight=233&originWidth=1205&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=58398&status=done&style=none&taskId=u0dedc2b5-5b5e-4488-b223-9360949ed46&title=&width=964" alt="image.png"><br>执行结果的日志有2次sql语句，表示从数据库中进行了2次操作</p><h4 id="Mybatis的二级缓存："><a href="#Mybatis的二级缓存：" class="headerlink" title="Mybatis的二级缓存："></a>Mybatis的二级缓存：</h4><p>MyBatis 的二级缓存是指在多个 SqlSession 之间共享查询结果的缓存机制。与一级缓存不同，二级缓存的作用范围不仅限于同一个 SqlSession，而是可以跨越多个 SqlSession，甚至是多个应用程序实例。使用二级缓存可以减少与数据库的交互次数，提高应用程序的性能。<br>二级缓存的实现方式是将查询结果存储在一个可插拔的缓存实现中，可以选择使用 Ehcache、Redis 等第三方缓存框架，也可以使用 MyBatis 内置的缓存实现。在同一个应用程序实例中，多个 SqlSession 可以共享同一个缓存实现，从而实现数据的共享。<br>开启二级缓存需要在 Mapper XML 文件中配置 <cache> 标签，并在 MyBatis 配置文件中开启二级缓存功能。例如，可以在 MyBatis 配置文件中添加以下配置：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div><p>在 Mapper XML 文件中，可以添加 <cache> 标签来配置二级缓存的相关属性。例如：</p><div class="code-wrapper"><pre><code class="hljs routeros">&lt;cache    <span class="hljs-attribute">eviction</span>=<span class="hljs-string">&quot;LRU&quot;</span>    <span class="hljs-attribute">flushInterval</span>=<span class="hljs-string">&quot;60000&quot;</span>    <span class="hljs-attribute">size</span>=<span class="hljs-string">&quot;1024&quot;</span>    <span class="hljs-attribute">readOnly</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</code></pre></div><p>在这个示例中，eviction 属性指定了缓存的清除策略为 LRU（Least Recently Used），flushInterval 属性指定了缓存的自动刷新时间为 60 秒，size 属性指定了缓存的最大大小为 1024，readOnly 属性指定了缓存是否只读。这些属性的含义和配置方式可以参考 MyBatis 的官方文档。<br>需要注意的是，二级缓存有一些限制和注意事项。例如，二级缓存中存储的数据是序列化后的对象，可能会导致性能下降；同时，如果数据被频繁地更新，那么缓存的命中率会降低，甚至会出现脏数据。因此，在使用二级缓存时，需要根据具体的业务场景进行适当的配置和调整。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688397300290-7655560e-531b-452a-ac89-479a70cb3094.png#averageHue=%23f2eee3&clientId=u8aa2d897-50f1-4&from=paste&height=150&id=u7faa80f9&originHeight=187&originWidth=724&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=119020&status=done&style=none&taskId=u450db797-c8a8-4f62-abea-2d36114a7a2&title=&width=579.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688397344021-b232c95d-45e8-4f83-b402-09c4fa5359ed.png#averageHue=%23efebdc&clientId=u8aa2d897-50f1-4&from=paste&height=49&id=u2cf0333d&originHeight=61&originWidth=524&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=30065&status=done&style=none&taskId=u93b7c066-d641-44c1-9212-6c90f53913d&title=&width=419.2" alt="image.png"></p><h4 id="Mybatis缓存查询顺序："><a href="#Mybatis缓存查询顺序：" class="headerlink" title="Mybatis缓存查询顺序："></a>Mybatis缓存查询顺序：</h4><p>一级缓存只有在关闭或者提交的时候才会在二级缓存中生成数据。</p><h4 id="整合第三方缓存："><a href="#整合第三方缓存：" class="headerlink" title="整合第三方缓存："></a>整合第三方缓存：</h4><p>是在二级缓存的基础上存在的。</p><h4 id="Mybatis的逆向工程："><a href="#Mybatis的逆向工程：" class="headerlink" title="Mybatis的逆向工程："></a>Mybatis的逆向工程：</h4><p>1.在pom.xml增加插件的配置文件：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-comment">&lt;!-- 插件的依赖    --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>                <span class="hljs-comment">&lt;!-- 逆向工程的核心依赖    --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>                <span class="hljs-comment">&lt;!-- MySQL驱动    --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>               <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></code></pre></div><p>2.新增generatoeConfig.xml配置文件：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">generatorConfiguration</span></span><span class="hljs-meta">       <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span>        <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">targetRuntime: 执行生成的逆向工程的版本</span><span class="hljs-comment">MyBatis3Simple: 生成基本的CRUD（清新简洁版）</span><span class="hljs-comment">MyBatis3: 生成带条件的CRUD（奢华尊享版）</span><span class="hljs-comment"> --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;DB2Tables&quot;</span> <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">&quot;MyBatis3&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 数据库的连接信息    --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">connectionURL</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/myemployees?serverTimezone=UTC&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">userId</span>=<span class="hljs-string">&quot;root&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;A86789234&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">jdbcConnection</span>&gt;</span>        <span class="hljs-comment">&lt;!-- javaBean的生成策略targetPackage是javaBean生成的目标包，targetProject是生成的路径，.表示</span><span class="hljs-comment">        项目根目录路径，..表示上一级路径,配置这种类似的时候注意路径--&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.example.demo.pojo&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;.\src\main\java&quot;</span>&gt;</span>          <span class="hljs-comment">&lt;!--能否使用子包--&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>          <span class="hljs-comment">&lt;!--把当前字段的前后空格字符去掉生成实体类的属性--&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;trimStrings&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">javaModelGenerator</span>&gt;</span>       <span class="hljs-comment">&lt;!-- SQL映射文件的生成策略 生成在com.example.mybatis.mapper包中的.\src\main\resources路径下   --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.example.demo.mapper&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;.\src\main\resources&quot;</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">sqlMapGenerator</span>&gt;</span>       <span class="hljs-comment">&lt;!-- Mapper接口的生成策略    --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;XMLMAPPER&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.example.demo.mapper&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;.\src\main\java&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaClientGenerator</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 逆向分析的表    --&gt;</span>       <span class="hljs-comment">&lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;</span>        <span class="hljs-comment">&lt;!-- domainObjectName属性指定生成出来的实体类的类名    --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;t_emp&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;Emp&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;t_dept&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;Dept&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span></code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688456443867-c4b537bf-6dc4-4261-90a3-20cb0e92b210.png#averageHue=%23faf9f5&clientId=u378e3c4c-7292-4&from=paste&height=164&id=ue439f11f&originHeight=205&originWidth=396&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=49632&status=done&style=none&taskId=u384443b0-43f4-4288-a120-e26c7288230&title=&width=316.8" alt="image.png">insert和insertSelective的区别：如果某个属性为null的时候，insert是给改属性对应的列赋值为null,(如果该列有默认值就不会把改列赋值为默认值）,insertSelective是当某个属性为null的时候，不会把该属性对应的列插入数据，使其为默认值（如果有默认值的话）</p><h6 id="3-生成的特殊EmpExample类和EmpMapper接口的分析："><a href="#3-生成的特殊EmpExample类和EmpMapper接口的分析：" class="headerlink" title="3.生成的特殊EmpExample类和EmpMapper接口的分析："></a>3.生成的特殊EmpExample类和EmpMapper接口的分析：</h6><p>MyBatis3 逆向工程生成的 EmpExample 类是用于封装 MyBatis 查询条件的一个实例。EmpExample 类主要包含以下属性和方法：<br><strong>属性：</strong></p><ul><li>oredCriteria：一个 List<Criteria> 类型的属性，用于存放多个 Criteria 对象，每个 Criteria 对象代表一个查询条件。</li><li>orderByClause：一个 String 类型的属性，用于存放查询结果的排序方式。相当于 SQL 中的 order by 子句。</li><li>distinct：一个 boolean 类型的属性，用于指定查询结果是否去重。相当于 SQL 中的 distinct 关键字。</li></ul><p><strong>方法：</strong></p><ul><li>EmpExample()：无参构造方法，用于创建一个 EmpExample 对象。</li><li>createCriteria()：创建一个 Criteria 对象，并将该对象添加到 oredCriteria 列表中。</li><li>getOredCriteria()：获取 oredCriteria 列表，用于设置多个查询条件的情况。</li><li>setOrderByClause(String orderByClause)：设置查询结果的排序方式。</li><li>getOrderByClause()：获取查询结果的排序方式。</li><li>setDistinct(boolean distinct)：设置查询结果是否去重。</li><li>isDistinct()：获取查询结果是否去重。</li><li>clear()：清空查询条件。</li></ul><p>通过 EmpExample 类，可以方便地构建查询条件，实现更加灵活的查询操作。可以通过 createCriteria() 方法创建一个 Criteria 对象，然后通过 Criteria 对象的方法设置查询条件，例如：</p><div class="code-wrapper"><pre><code class="hljs abnf">EmpExample example <span class="hljs-operator">=</span> new EmpExample()<span class="hljs-comment">;</span>Criteria criteria <span class="hljs-operator">=</span> example.createCriteria()<span class="hljs-comment">;</span>criteria.andNameEqualTo(<span class="hljs-string">&quot;Tom&quot;</span>)<span class="hljs-comment">;</span>criteria.andAgeGreaterThan(<span class="hljs-number">20</span>)<span class="hljs-comment">;</span></code></pre></div><p>这个示例代码中，首先创建一个 EmpExample 对象，然后调用 createCriteria() 方法创建一个 Criteria 对象，使用 andNameEqualTo(“Tom”) 方法和 andAgeGreaterThan(20) 方法设置查询条件，表示查询名称为 Tom 并且年龄大于 20 的数据。其中Criteria是内部类。<br>除了设置查询条件之外，还可以通过 setOrderByClause() 方法设置查询结果的排序方式，通过 setDistinct() 方法设置查询结果是否去重。最后，可以通过调用 empMapper.selectByExample(example) 方法执行查询操作，获取查询结果列表。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688472828411-60ffd7e0-98c9-44f1-a245-fe4adad4e778.png#averageHue=%233c4144&clientId=u25015969-4d62-4&from=paste&height=362&id=ub36475a5&originHeight=453&originWidth=551&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=40207&status=done&style=none&taskId=ufcf6ef16-df2c-4ba8-a361-5f1d5ed75b9&title=&width=440.8" alt="image.png">其实还有一些内部类，在使用的时候可以通过图来快速查看。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688472719439-4c5f8b0a-b6f8-47f9-af20-38bb50934042.png#averageHue=%233c4242&clientId=u25015969-4d62-4&from=paste&height=375&id=ubc2c4168&originHeight=469&originWidth=558&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=47881&status=done&style=none&taskId=u0162f579-9579-4c01-aa03-7b36c40064f&title=&width=446.4" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-number">1.</span><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">insertSelective</span>(<span class="hljs-params">Emp <span class="hljs-keyword">record</span></span>)：选择性地插入一条记录到 Emp 表中，只插入指定属性不为 <span class="hljs-literal">null</span> 的字段。</span><span class="hljs-function"></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs abnf">EmpMapper empMapper <span class="hljs-operator">=</span> sqlSession.getMapper(EmpMapper.class)<span class="hljs-comment">;</span>// 查询操作EmpExample example <span class="hljs-operator">=</span> new EmpExample()<span class="hljs-comment">;</span>example.createCriteria().andNameEqualTo(<span class="hljs-string">&quot;Tom&quot;</span>)<span class="hljs-comment">;</span>List&lt;Emp&gt; empList <span class="hljs-operator">=</span> empMapper.selectByExample(example)<span class="hljs-comment">;</span>// 插入操作Emp emp <span class="hljs-operator">=</span> new Emp()<span class="hljs-comment">;</span>emp.setName(<span class="hljs-string">&quot;Jerry&quot;</span>)<span class="hljs-comment">;</span>emp.setAge(<span class="hljs-number">30</span>)<span class="hljs-comment">;</span>int rows <span class="hljs-operator">=</span> empMapper.insert(emp)<span class="hljs-comment">;</span>// 更新操作Emp emp <span class="hljs-operator">=</span> new Emp()<span class="hljs-comment">;</span>emp.setId(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span>emp.setName(<span class="hljs-string">&quot;Tom&quot;</span>)<span class="hljs-comment">;</span>int rows <span class="hljs-operator">=</span> empMapper.updateByPrimaryKey(emp)<span class="hljs-comment">;</span>// 删除操作int rows <span class="hljs-operator">=</span> empMapper.deleteByPrimaryKey(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span></code></pre></div><h4 id="分页功能；"><a href="#分页功能；" class="headerlink" title="分页功能；"></a>分页功能；</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688467784015-e3f4255f-74c4-4104-b1c0-4d6d725cc6af.png#averageHue=%23fbfbfa&clientId=u378e3c4c-7292-4&from=paste&height=98&id=u21bfceb8&originHeight=123&originWidth=305&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=24673&status=done&style=none&taskId=u0e79f71a-6dd2-4a0c-896c-ffe26862945&title=&width=244" alt="image.png"><br>在pom.xml中添加分页插件：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></code></pre></div><p>可以通过IDEA搜索获取插件的地址<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688468705713-fca2e56f-8e44-439f-8706-467ae1d38c42.png#averageHue=%23c1b040&clientId=u378e3c4c-7292-4&from=paste&height=98&id=ud86358a9&originHeight=122&originWidth=862&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=15158&status=done&style=none&taskId=uf8a27513-52c4-4f2b-9024-a2ac900ba32&title=&width=689.6" alt="image.png"></p><h4 id="开启分页查询：PageHelper-startPage-1-4"><a href="#开启分页查询：PageHelper-startPage-1-4" class="headerlink" title="开启分页查询：PageHelper.startPage(1,4);"></a>开启分页查询：PageHelper.startPage(1,4);</h4><p><strong>PageHelper.startPage(1,4) 是一个 Mybatis 分页插件的方法，它的作用是在执行查询之前设置分页参数，表示从第 1 页开始，每页显示 4 条记录。PageHelper 会自动拦截查询语句，添加 limit 子句，实现物理分页</strong></p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title">testPage</span>() throws IOException</span> &#123;       InputStream <span class="hljs-keyword">is</span> =  Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);       SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="hljs-keyword">new</span>               SqlSessionFactoryBuilder();       SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(<span class="hljs-keyword">is</span>);       SqlSession sqlSession = sqlSessionFactory.openSession(<span class="hljs-literal">true</span>);       EmpMapper emp = sqlSession.getMapper(EmpMapper.<span class="hljs-keyword">class</span>);       <span class="hljs-comment">//查询功能前开启分页</span>       Page&lt;Object&gt; page = PageHelper.startPage(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>);       List&lt;Emp&gt; list = emp.selectByExample(<span class="hljs-literal">null</span>);       System.<span class="hljs-keyword">out</span>.println(list);       System.<span class="hljs-keyword">out</span>.println(page);   &#125;</code></pre></div><p><strong>显示的结果为：</strong></p><div class="code-wrapper"><pre><code class="hljs axapta"><span class="hljs-number">19</span>:<span class="hljs-number">36</span>:<span class="hljs-number">56.157</span> [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - Checked out connection <span class="hljs-number">417301556</span> <span class="hljs-keyword">from</span> pool.<span class="hljs-number">19</span>:<span class="hljs-number">36</span>:<span class="hljs-number">56.159</span> [main] DEBUG com.example.demo.mapper.EmpMapper.selectByExample_COUNT - ==&gt;  Preparing: SELECT <span class="hljs-keyword">count</span>(<span class="hljs-number">0</span>) FROM t_emp<span class="hljs-number">19</span>:<span class="hljs-number">36</span>:<span class="hljs-number">56.180</span> [main] DEBUG com.example.demo.mapper.EmpMapper.selectByExample_COUNT - ==&gt; Parameters: <span class="hljs-number">19</span>:<span class="hljs-number">36</span>:<span class="hljs-number">56.197</span> [main] DEBUG com.example.demo.mapper.EmpMapper.selectByExample_COUNT - &lt;==      Total: <span class="hljs-number">1</span><span class="hljs-number">19</span>:<span class="hljs-number">36</span>:<span class="hljs-number">56.199</span> [main] DEBUG com.example.demo.mapper.EmpMapper.selectByExample - ==&gt;  Preparing: <span class="hljs-keyword">select</span> emp_id, emp_name, age, gender, dept_id <span class="hljs-keyword">from</span> t_emp LIMIT ?<span class="hljs-number">19</span>:<span class="hljs-number">36</span>:<span class="hljs-number">56.199</span> [main] DEBUG com.example.demo.mapper.EmpMapper.selectByExample - ==&gt; Parameters: <span class="hljs-number">4</span>(Integer)<span class="hljs-number">19</span>:<span class="hljs-number">36</span>:<span class="hljs-number">56.202</span> [main] DEBUG com.example.demo.mapper.EmpMapper.selectByExample - &lt;==      Total: <span class="hljs-number">4</span>Page&#123;<span class="hljs-keyword">count</span>=<span class="hljs-literal">true</span>, pageNum=<span class="hljs-number">1</span>, pageSize=<span class="hljs-number">4</span>, startRow=<span class="hljs-number">0</span>, endRow=<span class="hljs-number">4</span>, total=<span class="hljs-number">4</span>, pages=<span class="hljs-number">1</span>, reasonable=<span class="hljs-literal">false</span>, pageSizeZero=<span class="hljs-literal">false</span>&#125;[Emp&#123;empId=<span class="hljs-number">1</span>, empName=<span class="hljs-string">&#x27;张三&#x27;</span>, age=<span class="hljs-number">20</span>, gender=<span class="hljs-string">&#x27;男&#x27;</span>, deptId=<span class="hljs-number">1</span>&#125;, Emp&#123;empId=<span class="hljs-number">2</span>, empName=<span class="hljs-string">&#x27;李四&#x27;</span>, age=<span class="hljs-number">21</span>, gender=<span class="hljs-string">&#x27;女&#x27;</span>, deptId=<span class="hljs-number">2</span>&#125;, Emp&#123;empId=<span class="hljs-number">3</span>, empName=<span class="hljs-string">&#x27;王五&#x27;</span>, age=<span class="hljs-number">22</span>, gender=<span class="hljs-string">&#x27;男&#x27;</span>, deptId=<span class="hljs-number">3</span>&#125;, Emp&#123;empId=<span class="hljs-number">4</span>, empName=<span class="hljs-string">&#x27;赵六&#x27;</span>, age=<span class="hljs-number">23</span>, gender=<span class="hljs-string">&#x27;女&#x27;</span>, deptId=<span class="hljs-number">1</span>&#125;]Page&#123;<span class="hljs-keyword">count</span>=<span class="hljs-literal">true</span>, pageNum=<span class="hljs-number">1</span>, pageSize=<span class="hljs-number">4</span>, startRow=<span class="hljs-number">0</span>, endRow=<span class="hljs-number">4</span>, total=<span class="hljs-number">4</span>, pages=<span class="hljs-number">1</span>, reasonable=<span class="hljs-literal">false</span>, pageSizeZero=<span class="hljs-literal">false</span>&#125;[Emp&#123;empId=<span class="hljs-number">1</span>, empName=<span class="hljs-string">&#x27;张三&#x27;</span>, age=<span class="hljs-number">20</span>, gender=<span class="hljs-string">&#x27;男&#x27;</span>, deptId=<span class="hljs-number">1</span>&#125;, Emp&#123;empId=<span class="hljs-number">2</span>, empName=<span class="hljs-string">&#x27;李四&#x27;</span>, age=<span class="hljs-number">21</span>, gender=<span class="hljs-string">&#x27;女&#x27;</span>, deptId=<span class="hljs-number">2</span>&#125;, Emp&#123;empId=<span class="hljs-number">3</span>, empName=<span class="hljs-string">&#x27;王五&#x27;</span>, age=<span class="hljs-number">22</span>, gender=<span class="hljs-string">&#x27;男&#x27;</span>, deptId=<span class="hljs-number">3</span>&#125;, Emp&#123;empId=<span class="hljs-number">4</span>, empName=<span class="hljs-string">&#x27;赵六&#x27;</span>, age=<span class="hljs-number">23</span>, gender=<span class="hljs-string">&#x27;女&#x27;</span>, deptId=<span class="hljs-number">1</span>&#125;]进程已结束,退出代码<span class="hljs-number">0</span><span class="hljs-comment">//可以看出显示的list被分页显示了。</span><span class="hljs-comment">//查询结果通过 selectByExample() 方法获取，这个方法的参数是一个空的 Example 对象，表示查询所有数据。查询结果是一个 Emp 对象列表。</span><span class="hljs-comment">//最后，分页信息可以通过输出 Page 对象来获取。Page 是 PageHelper 插件提供的一个分页信息类，它包含了当前页码、每页数据条数、总数据条数等分页信息。在这个示例代码中，通过输出 page 对象来获取分页信息。</span></code></pre></div><p>为什么输出的list会有多余的Pagr信息<br>在这个示例代码中，输出的 list 中包含了多余的 Page 信息，是因为 PageHelper.startPage() 方法返回的是一个 Page 对象，这个 Page 对象包含了分页信息和查询结果列表。<br>因此，在查询操作完成之后，如果直接输出查询结果列表，会同时输出 Page 对象的信息和查询结果列表的信息。如果只想输出查询结果列表，可以通过调用 Page 对象的 getList() 方法来获取查询结果列表，例如：</p><div class="code-wrapper"><pre><code class="hljs sas"><span class="hljs-keyword">List</span>&lt;Emp&gt; <span class="hljs-keyword">list</span> = emp.selectByExample(<span class="hljs-keyword">null</span>);<span class="hljs-keyword">Page</span>&lt;Object&gt; <span class="hljs-keyword">page</span> = PageHelper.startPage(1, 4);<span class="hljs-keyword">List</span>&lt;Emp&gt; resultList = <span class="hljs-keyword">page</span>.getResult();System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(resultList);</code></pre></div><p>在这个示例代码中，先调用 emp.selectByExample(null) 方法获取查询结果列表，然后再调用 Page 对象的 getResult() 方法获取查询结果列表。这样就可以避免输出多余的 Page 信息。</p><h4 id="PageInfo"><a href="#PageInfo" class="headerlink" title="PageInfo&lt;&gt;"></a>PageInfo&lt;&gt;</h4><div class="code-wrapper"><pre><code class="hljs stylus">PageInfo&lt;T&gt; 是 MyBatis 分页插件 PageHelper 提供的一个分页信息类，用于封装分页信息和查询结果列表。PageInfo&lt;T&gt; 类包含以下属性：pageNum：当前页码。pageSize：每页显示的数据条数。size：当前页的实际数据条数。startRow：当前页第一条数据的行号。endRow：当前页最后一条数据的行号。total：总数据条数。pages：总页数。list：查询结果列表。prePage：上一页页码。nextPage：下一页页码。isFirstPage：是否为第一页。isLastPage：是否为最后一页。hasPreviousPage：是否有上一页。hasNextPage：是否有下一页。navigatePages：导航页码数。navigatepageNums：所有导航页号。PageInfo&lt;T&gt; 类常用的方法有：<span class="hljs-function"><span class="hljs-title">PageInfo</span><span class="hljs-params">(List&lt;T&gt; list, int navigatePages)</span></span>：构造方法，用于创建一个 PageInfo 对象。<span class="hljs-function"><span class="hljs-title">getPageNum</span><span class="hljs-params">()</span></span>：获取当前页码。<span class="hljs-function"><span class="hljs-title">getPageSize</span><span class="hljs-params">()</span></span>：获取每页显示的数据条数。<span class="hljs-function"><span class="hljs-title">getSize</span><span class="hljs-params">()</span></span>：获取当前页的实际数据条数。<span class="hljs-function"><span class="hljs-title">getStartRow</span><span class="hljs-params">()</span></span>：获取当前页第一条数据的行号。<span class="hljs-function"><span class="hljs-title">getEndRow</span><span class="hljs-params">()</span></span>：获取当前页最后一条数据的行号。<span class="hljs-function"><span class="hljs-title">getTotal</span><span class="hljs-params">()</span></span>：获取总数据条数。<span class="hljs-function"><span class="hljs-title">getPages</span><span class="hljs-params">()</span></span>：获取总页数。<span class="hljs-function"><span class="hljs-title">getList</span><span class="hljs-params">()</span></span>：获取查询结果列表。<span class="hljs-function"><span class="hljs-title">getPrePage</span><span class="hljs-params">()</span></span>：获取上一页页码。<span class="hljs-function"><span class="hljs-title">getNextPage</span><span class="hljs-params">()</span></span>：获取下一页页码。<span class="hljs-function"><span class="hljs-title">isFirstPage</span><span class="hljs-params">()</span></span>：判断是否为第一页。<span class="hljs-function"><span class="hljs-title">isLastPage</span><span class="hljs-params">()</span></span>：判断是否为最后一页。<span class="hljs-function"><span class="hljs-title">hasPreviousPage</span><span class="hljs-params">()</span></span>：判断是否有上一页。<span class="hljs-function"><span class="hljs-title">hasNextPage</span><span class="hljs-params">()</span></span>：判断是否有下一页。<span class="hljs-function"><span class="hljs-title">getNavigatePages</span><span class="hljs-params">()</span></span>：获取导航页码数。<span class="hljs-function"><span class="hljs-title">getNavigatepageNums</span><span class="hljs-params">()</span></span>：获取所有导航页号。</code></pre></div><p>输出的信息”</p><div class="code-wrapper"><pre><code class="hljs routeros">PageInfo&#123;<span class="hljs-attribute">pageNum</span>=1, <span class="hljs-attribute">pageSize</span>=4, <span class="hljs-attribute">size</span>=4, <span class="hljs-attribute">startRow</span>=1, <span class="hljs-attribute">endRow</span>=4, <span class="hljs-attribute">total</span>=4, <span class="hljs-attribute">pages</span>=1,<span class="hljs-attribute">list</span>=Page&#123;<span class="hljs-attribute">count</span>=<span class="hljs-literal">true</span>, <span class="hljs-attribute">pageNum</span>=1, <span class="hljs-attribute">pageSize</span>=4, <span class="hljs-attribute">startRow</span>=0, <span class="hljs-attribute">endRow</span>=4, <span class="hljs-attribute">total</span>=4, <span class="hljs-attribute">pages</span>=1,<span class="hljs-attribute">reasonable</span>=<span class="hljs-literal">false</span>, <span class="hljs-attribute">pageSizeZero</span>=<span class="hljs-literal">false</span>&#125;[Emp&#123;<span class="hljs-attribute">empId</span>=1, <span class="hljs-attribute">empName</span>=<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-attribute">age</span>=20, <span class="hljs-attribute">gender</span>=<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-attribute">deptId</span>=1&#125;,Emp&#123;<span class="hljs-attribute">empId</span>=2, <span class="hljs-attribute">empName</span>=<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-attribute">age</span>=21, <span class="hljs-attribute">gender</span>=<span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-attribute">deptId</span>=2&#125;, Emp&#123;<span class="hljs-attribute">empId</span>=3, <span class="hljs-attribute">empName</span>=<span class="hljs-string">&#x27;王五&#x27;</span>, <span class="hljs-attribute">age</span>=22, <span class="hljs-attribute">gender</span>=<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-attribute">deptId</span>=3&#125;, Emp&#123;<span class="hljs-attribute">empId</span>=4, <span class="hljs-attribute">empName</span>=<span class="hljs-string">&#x27;赵六&#x27;</span>,<span class="hljs-attribute">age</span>=23, <span class="hljs-attribute">gender</span>=<span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-attribute">deptId</span>=1&#125;], <span class="hljs-attribute">prePage</span>=0, <span class="hljs-attribute">nextPage</span>=0, <span class="hljs-attribute">isFirstPage</span>=<span class="hljs-literal">true</span>, <span class="hljs-attribute">isLastPage</span>=<span class="hljs-literal">true</span>, <span class="hljs-attribute">hasPreviousPage</span>=<span class="hljs-literal">false</span>, <span class="hljs-attribute">hasNextPage</span>=<span class="hljs-literal">false</span>, <span class="hljs-attribute">navigatePages</span>=5, <span class="hljs-attribute">navigateFirstPage</span>=1, <span class="hljs-attribute">navigateLastPage</span>=1, navigatepageNums=[1]&#125;</code></pre></div><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring:"></a>Spring:</h1><h4 id="spring-Framework简介："><a href="#spring-Framework简介：" class="headerlink" title="spring Framework简介："></a>spring Framework简介：</h4><p><a href="https://blog.csdn.net/weixin_46081816/article/details/123116901">SpringFramework教程_springframework的教程在官网哪里_疯了的程序员的博客-CSDN博客</a><br><a href="https://blog.csdn.net/pedro7k/article/details/115415675">Java中的面向切面编程（AOP）_切面java_pedro7k的博客-CSDN博客</a></p><h4 id="Spring-IOC简介："><a href="#Spring-IOC简介：" class="headerlink" title="Spring IOC简介："></a>Spring IOC简介：</h4><p>Spring IOC 是 Spring 框架的核心，它是一种实现了 IoC（Inversion of Control，控制反转）原则的容器，负责创建、配置、管理和装配应用程序中的对象（称为 bean）<br><a href="https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html">5. The IoC container</a><br>。IoC 原则是指将对象的依赖关系（即它们需要协作的其他对象）交由外部容器或框架来设置，而不是由对象自己控制，从而实现对象之间的松耦合和动态绑定<br><a href="https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring">Just a moment…</a><br>Spring IOC 容器有两种类型：BeanFactory 和 ApplicationContext。BeanFactory 是最基本的容器，提供了依赖注入（Dependency Injection，DI）的功能，即根据配置元数据（可以是 XML、注解或 Java 代码）来注入 bean 的属性或构造参数<br><a href="https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html">5. The IoC container</a><br>。ApplicationContext 是 BeanFactory 的子接口，提供了更多的高级功能，如 AOP 集成、消息资源处理、事件发布等<a href="https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html">5. The IoC container</a>。</p><h4 id="Spring-DI-简介："><a href="#Spring-DI-简介：" class="headerlink" title="Spring DI 简介："></a>Spring DI 简介：</h4><p><a href="https://juejin.cn/post/6959753065297608711">Spring Boot注解全攻略(四)：@Autowired - 掘金</a><br>Spring DI（Dependency Injection，依赖注入）是 Spring Framework 的核心之一，它是实现 Spring IOC 的一种方式，用于解决对象之间的依赖关系。Spring DI 通过将对象之间的依赖关系的控制权反转给容器，来解决这些问题。具体来说，它在对象中定义依赖关系的接口，容器则负责实现这些接口并将实现注入到对象中</p><h4 id="Autowired注解详解"><a href="#Autowired注解详解" class="headerlink" title="@Autowired注解详解"></a>@Autowired注解详解</h4><p><a href="https://blog.csdn.net/weixin_45755816/article/details/118654961">@Autowired注解详解——超详细易懂_子时不睡的博客-CSDN博客</a><br><a href="https://juejin.cn/post/6959753065297608711">Spring Boot注解全攻略(四)：@Autowired - 掘金</a></p><h4 id="IOC容器在Spirng中的实现："><a href="#IOC容器在Spirng中的实现：" class="headerlink" title="IOC容器在Spirng中的实现："></a>IOC容器在Spirng中的实现：</h4><p>基于XML的实现<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688519520570-48f60a06-3c87-4d24-8461-0d81d7aaded3.png#averageHue=%23faf9f6&clientId=u25015969-4d62-4&from=paste&height=108&id=uadf55962&originHeight=135&originWidth=454&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=31539&status=done&style=none&taskId=ucf41a50b-9c9b-4f1d-a0e9-16f546edf4c&title=&width=363.2" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs abnf">ClassPathXmlApplicationContext ioc <span class="hljs-operator">=</span> new ClassPathXmlApplicationContext(<span class="hljs-string">&quot;application.xml&quot;</span>)<span class="hljs-comment">;</span></code></pre></div><p>解释：<br>ClassPathXmlApplicationContext 类是 Spring 框架提供的一个实现类，它实现了 ApplicationContext 接口，用于创建和管理 Spring 容器。ClassPathXmlApplicationContext 类的构造器接受一个或多个字符串参数，表示要加载的 XML 配置文件的路径。这些路径是相对于类路径（classpath）的根目录的路径（也就是下图中的classes目录），如果以 &#x2F; 开头，则表示相对于类路径的根目录，否则表示相对于当前类所在的包。在这行代码中，传入了一个字符串参数 “application.xml”，表示要加载类路径根目录下的 application.xml 文件，该文件定义了 Spring 容器中的 bean。通过这样的方式，就可以创建一个 Spring 容器，并根据 XML 配置文件来初始化和管理 bean。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688521560666-80ac8ae4-d4a3-4d2d-8c91-334fe069e83b.png#averageHue=%23412105&clientId=u25015969-4d62-4&from=paste&height=165&id=u376387fd&originHeight=206&originWidth=334&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=8596&status=done&style=none&taskId=ub730a5b6-c25f-4fb1-9908-28be2b46f06&title=&width=267.2" alt="image.png"><br>其实上面的代码可以改成下面的也可以正常运行：</p><div class="code-wrapper"><pre><code class="hljs abnf">ClassPathXmlApplicationContext ioc <span class="hljs-operator">=</span> new ClassPathXmlApplicationContext(<span class="hljs-string">&quot;/ application.xml&quot;</span>)<span class="hljs-comment">;</span></code></pre></div><h4 id="理解相对路径："><a href="#理解相对路径：" class="headerlink" title="理解相对路径："></a>理解相对路径：</h4><p>在 Java 项目中，相对路径是指相对于某个参照点的路径，而不是绝对路径。相对路径的好处是可以避免硬编码文件的位置，使得代码更加灵活和可移植。相对路径的参照点可以有以下几种：</p><p>•  当前工作目录（working directory），即启动 Java 程序时所在的目录，或者通过 System.setProperty(“user.dir”, path) 方法设置的目录。如果使用 new File(path) 方法来访问文件，那么 path 就是相对于当前工作目录的路径。</p><p>•  当前类所在的包（package），即当前类的源文件所在的目录。如果使用 Class.getResource(path) 或 Class.getResourceAsStream(path) 方法来访问文件，那么 path 就是相对于当前类所在的包的路径，如果以 &#x2F; 开头，则表示相对于类路径（classpath）的根目录。</p><p>•  类路径（classpath）的根目录，即 Java 程序加载类和资源的根目录。如果使用 ClassLoader.getResource(path) 或 ClassLoader.getResourceAsStream(path) 方法来访问文件，那么 path 就是相对于类路径的根目录的路径。</p><p>•  web 工程（web project）的根目录，即 web 工程部署到服务器上的根目录。如果使用 ServletContext.getResource(path) 或 ServletContext.getResourceAsStream(path) 方法来访问文件，那么 path 就是相对于 web 工程的根目录的路径。<br>也就是相对路径也不一定是相对与当前类所在的目录。</p><h4 id="获取bean的三种方法："><a href="#获取bean的三种方法：" class="headerlink" title="获取bean的三种方法："></a>获取bean的三种方法：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688524352145-bbed48c4-4b9f-49fd-bc03-d572a3027197.png#averageHue=%23f9f8f4&clientId=u25015969-4d62-4&from=paste&height=129&id=uda18b195&originHeight=161&originWidth=665&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=78699&status=done&style=none&taskId=u7546ee82-c37d-4698-81dd-fac681e2239&title=&width=532" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688524508058-a35f1e6a-8385-4dc9-b2fe-35f006b386f9.png#averageHue=%23f7f4e4&clientId=u25015969-4d62-4&from=paste&height=60&id=uc187c925&originHeight=75&originWidth=510&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=45670&status=done&style=none&taskId=ue427ec23-92d3-40b9-bcc6-bd086110dbb&title=&width=408" alt="image.png">person是Student实现的接口，可以根据接口获取bean,当然这个接口只能有一个实现类。<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688524591560-ec1e07ae-2a22-40a0-beb4-3a0381331b21.png#averageHue=%23f6f5f1&clientId=u25015969-4d62-4&from=paste&height=83&id=u1459a351&originHeight=104&originWidth=678&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=63103&status=done&style=none&taskId=ua96d2c56-915b-4fc7-93b1-8eab6045021&title=&width=542.4" alt="image.png"></p><h4 id="依赖注入setter注入："><a href="#依赖注入setter注入：" class="headerlink" title="依赖注入setter注入："></a>依赖注入setter注入：</h4><h6 id="什么是依赖注入："><a href="#什么是依赖注入：" class="headerlink" title="什么是依赖注入："></a>什么是依赖注入：</h6><p><a href="https://blog.csdn.net/taijianyu/article/details/2338311">什么是依赖注入_taijianyu的博客-CSDN博客</a><br>。在 Spring 中，依赖注入是指 Spring 容器负责创建和管理 bean（即 Spring 容器中管理的对象），并根据 bean 之间的依赖关系，将依赖的 bean 注入到需要它的 bean 中，从而实现控制反转（Inversion of Control，IoC），即控制权由原来的 bean 转移到了 Spring 容器，从而降低了 bean 之间的耦合度，提高了代码的可维护性和可测试性。Spring 支持基于 XML、注解和 Java 代码的三种依赖注入方式，</p><div class="code-wrapper"><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentTwo&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.demo.pojo.Student&quot;</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1002&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;李四&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;33&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;女&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!--只有一个 &lt;constructor-arg &gt;匹配的只有一个有参构造的构造器--&gt;</span></code></pre></div><h4 id="通过属性赋值，赋值为空："><a href="#通过属性赋值，赋值为空：" class="headerlink" title="通过属性赋值，赋值为空："></a>通过属性赋值，赋值为空：</h4><p><property name="sex" value="null"></property>这给sex属性赋值为null字符串；<br><property name="sex" ><null/></property>这给sex属性赋值为空。</p><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a><array>标签</h4><p>在 Spring Framework 的 XML 配置文件中，可以使用 <array> 标签来定义一个数组类型的属性值。<array> 标签可以包含多个 <value> 或 <ref> 子标签，每个子标签表示数组中的一个元素。<br>例如，假设我们有一个 Person 类，它包含一个 hobbies 属性，表示一个人的爱好。hobbies 属性是一个字符串数组类型的属性。我们可以在 XML 配置文件中使用 <array> 标签来定义这个数组类型的属性值：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.Person&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobbies&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>篮球<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>足球<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>游泳<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p>这个配置将会创建一个 Person 实例，并将 “篮球”、”足球” 和 “游泳” 作为 hobbies 属性的值。在这个配置中，<array> 标签包含了三个 <value> 子标签，每个子标签表示一个字符串类型的数组元素。<br>除了 <value> 子标签外，<array> 标签还可以包含 <ref> 子标签，用于引用其他 Bean 的实例作为数组元素。例如：</p><div class="code-wrapper"><pre><code class="hljs applescript">&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;basketball&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;com.example.Hobby&quot;</span> /&gt;&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;football&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;com.example.Hobby&quot;</span> /&gt;&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;swimming&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;com.example.Hobby&quot;</span> /&gt;&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;com.example.Person&quot;</span>&gt;    &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;hobbies&quot;</span>&gt;        &lt;array&gt;            &lt;<span class="hljs-keyword">ref</span> bean=<span class="hljs-string">&quot;basketball&quot;</span> /&gt;            &lt;<span class="hljs-keyword">ref</span> bean=<span class="hljs-string">&quot;football&quot;</span> /&gt;            &lt;<span class="hljs-keyword">ref</span> bean=<span class="hljs-string">&quot;swimming&quot;</span> /&gt;        &lt;/array&gt;    &lt;/<span class="hljs-keyword">property</span>&gt;&lt;/bean&gt;</code></pre></div><p>这个配置定义了三个 Hobby 类型的 Bean，并将它们分别命名为 “basketball”、”football” 和 “swimming”。然后，它又在 <array> 标签中使用了三个 <ref> 子标签，分别引用了这三个 Bean 的实例，作为 Person 类的 hobbies 属性的值。</p><h4 id="集合类型的依赖注入：依赖注入中util标签的引用和List和Map集和的使用：其实所缺的命名空间的绑定可以在IDEA中自动补充的"><a href="#集合类型的依赖注入：依赖注入中util标签的引用和List和Map集和的使用：其实所缺的命名空间的绑定可以在IDEA中自动补充的" class="headerlink" title="集合类型的依赖注入：依赖注入中util标签的引用和List和Map集和的使用：其实所缺的命名空间的绑定可以在IDEA中自动补充的"></a>集合类型的依赖注入：依赖注入中util标签的引用和List和Map集和的使用：其实所缺的命名空间的绑定可以在IDEA中自动补充的</h4><p>util 是 Spring 框架提供的一个命名空间，用于提供一些常用的工具和辅助类。在 Spring 的 XML 配置文件中，我们可以使用 <a href="util:*">util:*</a> 标签来引用 util 命名空间中的定义，并将其应用到 Bean 的定义中。<br>在 Spring Framework 的 XML 配置文件中，可以使用 <list> 标签来定义一个列表类型的属性值。<list> 标签可以包含多个 <value> 或 <ref> 子标签，每个子标签表示列表中的一个元素。<br>例如，假设我们有三个 Student 类型的 Bean，分别命名为 “studentOne”、”studentTwo” 和 “studentThree”。我们可以在 XML 配置文件中使用 <a href="util:list">util:list</a> 标签来定义这三个 Bean 实例的列表：</p><div class="code-wrapper"><pre><code class="hljs applescript">&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;studentOne&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;com.example.Student&quot;</span> /&gt;&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;studentTwo&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;com.example.Student&quot;</span> /&gt;&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;studentThree&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;com.example.Student&quot;</span> /&gt;&lt;util:<span class="hljs-built_in">list</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;students&quot;</span>&gt;    &lt;<span class="hljs-keyword">ref</span> bean=<span class="hljs-string">&quot;studentOne&quot;</span> /&gt;    &lt;<span class="hljs-keyword">ref</span> bean=<span class="hljs-string">&quot;studentTwo&quot;</span> /&gt;    &lt;<span class="hljs-keyword">ref</span> bean=<span class="hljs-string">&quot;studentThree&quot;</span> /&gt;&lt;/util:<span class="hljs-built_in">list</span>&gt;</code></pre></div><p>这个配置将会创建一个列表类型的 Bean，将 “studentOne”、”studentTwo” 和 “studentThree” 作为列表元素。在这个配置中，<a href="util:list">util:list</a> 标签包含了三个 <ref> 子标签，每个子标签表示一个引用类型的列表元素。<br>除了 <ref> 子标签外，<a href="util:list">util:list</a> 标签还可以包含 <value> 子标签，用于定义值类型的列表元素。例如：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">util:list</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;numbers&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">util:list</span>&gt;</span></code></pre></div><p>这个配置将会创建一个列表类型的 Bean，将 1、2 和 3 作为列表元素，它们都是整数类型的值。在这个配置中，<a href="util:list">util:list</a> 标签包含了三个 <value> 子标签，每个子标签表示一个整数类型的值类型的列表元素。<br><a href="util:list">util:list</a> 是 Spring Framework 中的一个实用工具标签，用于定义列表类型的 Bean。为了使用 <a href="util:list">util:list</a> 标签，我们需要在 XML 配置文件中导入 Spring 的 util 命名空间。具体方法是在 XML 文件的根标签中添加xmlns:util&#x3D;”<a href="http://www.springframework.org/schema/util">http://www.springframework.org/schema/util</a>“ 命名空间声明，同时在<br>xsi:schemaLocation中添加</p><div class="code-wrapper"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>www.springframework.org<span class="hljs-regexp">/schema/u</span>til                           http:<span class="hljs-regexp">//</span>www.springframework.org<span class="hljs-regexp">/schema/u</span>til/spring-util.xsd<span class="hljs-string">&quot;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:util</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/util&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><span class="hljs-string"><span class="hljs-tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="hljs-string"><span class="hljs-tag">                           http://www.springframework.org/schema/util</span></span><span class="hljs-string"><span class="hljs-tag">                           http://www.springframework.org/schema/util/spring-util.xsd&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>&gt;</span>           <span class="hljs-comment">&lt;!-- 这里可以定义 Bean --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">util:list</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;students&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;studentOne&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;studentTwo&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;studentThree&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">util:list</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p><a href="https://blog.csdn.net/lengxiao1993/article/details/77914155?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-77914155-blog-114280229.235%5Ev38%5Epc_relevant_yljh&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-77914155-blog-114280229.235%5Ev38%5Epc_relevant_yljh&utm_relevant_index=10">详解 xml 文件头部的 xmlns:xsi_萧萧九宸的博客-CSDN博客</a><br>xml：命名空间，防止命名冲突<br>xsi是XML Schema Instance的缩写，它是一个预定义的命名空间前缀，用于引用XML Schema的实例。 xsi:schemaLocation是一个预定义的属性，用于指定XML文档所引用的XML Schema的位置。</p><div class="code-wrapper"><pre><code class="hljs csharp">@Test       <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">TestList</span>()</span> &#123;           ClassPathXmlApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;application.xml&quot;</span>);           List&lt;Student&gt; students = (List&lt;Student&gt;) context.getBean(<span class="hljs-string">&quot;students&quot;</span>);           <span class="hljs-keyword">for</span> (Student student : students) &#123;               System.<span class="hljs-keyword">out</span>.println(student);           &#125;       &#125;</code></pre></div><p>测试结果：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688540312902-5751d031-2dfb-4087-9bc5-4e3d96105748.png#averageHue=%23130f0c&clientId=ua77d9b4f-0672-4&from=paste&height=62&id=u3c89fbd3&originHeight=77&originWidth=946&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=20364&status=done&style=none&taskId=u268ab9a1-10cb-469d-b722-3809d789332&title=&width=756.8" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--map集合类型的bean--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">util:map</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;teacherMap&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">entry</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>10010<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;teacherOne&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">entry</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>10086<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;teacherTwo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">util:map</span>&gt;</span></code></pre></div><p>总结：其实<map>中的键值对还可以这样写：  <entry key="1" value="游泳"/>（当值为字符串的时候）<br>由于<value> 标签中的内容会被解析为字符串类型，当值不为字符串的时候用<ref >或者<br><value-ref/>标签， <ref bean="teacherOne"></ref>和&lt;value-ref&#x3D;”teacherOne”&#x2F;&gt;是等价的。</p><h4 id="依赖注入之p命名空间："><a href="#依赖注入之p命名空间：" class="headerlink" title="依赖注入之p命名空间："></a>依赖注入之p命名空间：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688542214770-39434523-eeeb-46d1-8208-8ddb7d9a11ec.png#averageHue=%23121923&clientId=ua77d9b4f-0672-4&from=paste&height=182&id=u43edee01&originHeight=228&originWidth=1077&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=38429&status=done&style=none&taskId=u7cb701c5-f79b-40f4-8d4b-c1bd9d68933&title=&width=861.6" alt="image.png"><br>p:前缀是一个命名空间前缀，用于简化property元素的写法，它表示该属性是一个property元素的简写形式。<br>添加后配置文件新增的内容：（红线部分）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688542371493-97cb2579-faf2-413e-ad5b-ef52d389f4b6.png#averageHue=%23121220&clientId=ua77d9b4f-0672-4&from=paste&height=214&id=u2eb14b9f&originHeight=267&originWidth=824&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=56931&status=done&style=none&taskId=u0d593b70-ed69-4948-9bf4-15d8c4918b6&title=&width=659.2" alt="image.png"><br>依赖注入：</p><div class="code-wrapper"><pre><code class="hljs stylus">&lt;bean id = <span class="hljs-string">&quot;studentSix&quot;</span> class=<span class="hljs-string">&quot;com.example.demo.pojo.Student&quot;</span> <span class="hljs-selector-tag">p</span>:id=<span class="hljs-string">&quot;1005&quot;</span> <span class="hljs-selector-tag">p</span>:name=<span class="hljs-string">&quot;小明&quot;</span>          <span class="hljs-selector-tag">p</span>:sex=<span class="hljs-string">&quot;女&quot;</span> <span class="hljs-selector-tag">p</span>:clazz-ref=<span class="hljs-string">&quot;clazzOne&quot;</span> <span class="hljs-selector-tag">p</span>:hobbies=<span class="hljs-string">&quot;游泳,跑步,阅读&quot;</span> &gt;&lt;/bean&gt;</code></pre></div><p>测试：</p><div class="code-wrapper"><pre><code class="hljs csharp">@Test   <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">TestP</span>()</span> &#123;       ClassPathXmlApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;application.xml&quot;</span>);       Student studentSix = context.getBean(<span class="hljs-string">&quot;studentSix&quot;</span>, Student.<span class="hljs-keyword">class</span>);       System.<span class="hljs-keyword">out</span>.println(studentSix);   &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs pgsql">Student&#123;id=<span class="hljs-number">1005</span>, <span class="hljs-type">name</span>=<span class="hljs-string">&#x27;小明&#x27;</span>, age=<span class="hljs-keyword">null</span>, sex=<span class="hljs-string">&#x27;女&#x27;</span>, clazz=Clazz&#123;clazzId=<span class="hljs-number">3333</span>, clazzName=<span class="hljs-string">&#x27;最强王者班&#x27;</span>, students=<span class="hljs-keyword">null</span>&#125;, hobbies=[游泳, 跑步, 阅读], teacherMap=<span class="hljs-keyword">null</span>&#125;//没有赋值的属性都是<span class="hljs-keyword">null</span></code></pre></div><h4 id="特殊情况p语法糖配置的属性为List或者Map的情况："><a href="#特殊情况p语法糖配置的属性为List或者Map的情况：" class="headerlink" title="特殊情况p语法糖配置的属性为List或者Map的情况："></a>特殊情况p语法糖配置的属性为List或者Map的情况：</h4><p>如果 p:hobbies 是一个 List 或 Map 类型的属性，我们可以使用 <a href="util:list">util:list</a> 或 <a href="util:map">util:map</a> 标签来配置它的属性值。例如，假设 com.example.demo.pojo.Student 类中的 hobbies 属性是一个 List<String> 类型的列表，我们可以将 <bean> 标签修改为以下形式：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentSix&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.demo.pojo.Student&quot;</span></span><span class="hljs-tag">      <span class="hljs-attr">p:id</span>=<span class="hljs-string">&quot;1005&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;小明&quot;</span> <span class="hljs-attr">p:sex</span>=<span class="hljs-string">&quot;女&quot;</span> <span class="hljs-attr">p:clazz-ref</span>=<span class="hljs-string">&quot;clazzOne&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobbies&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>游泳<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>跑步<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>阅读<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p>在这个例子中，我们使用了 <property> 标签来设置 Student 类中的 hobbies 属性。<property> 标签中的 name 属性指定了要设置的属性名，而 <a href="util:list">util:list</a> 标签中包含了若干个 <value> 标签，每个 <value> 标签的文本内容即为列表中的一个元素。在这个例子中，<a href="util:list">util:list</a> 标签中包含了三个 <value> 标签，分别设置了 hobbies 列表的三个元素为 “游泳”、”跑步” 和 “阅读”。<br>如果 p:hobbies 是一个 Map 类型的属性，我们可以使用 <a href="util:map">util:map</a> 标签来配置它的属性值。例如，假设 com.example.demo.pojo.Student 类中的 hobbies 属性是一个 Map&lt;String, String&gt; 类型的映射表，我们可以将 <bean> 标签修改为以下形式：<br>在这个例子中，我们同样使用了 <property> 标签来设置 Student 类中的 hobbies 属性。<a href="util:map">util:map</a> 标签中包含了若干个 <entry> 标签，每个 <entry> 标签分别表示一个键值对。在这个例子中，我们设置了 hobbies 映射表中的三个键值对，分别为 “1”-“游泳”、”2”-“跑步” 和 “3”-“阅读”。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentSix&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.demo.pojo.Student&quot;</span></span><span class="hljs-tag">      <span class="hljs-attr">p:id</span>=<span class="hljs-string">&quot;1005&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;小明&quot;</span> <span class="hljs-attr">p:sex</span>=<span class="hljs-string">&quot;女&quot;</span> <span class="hljs-attr">p:clazz-ref</span>=<span class="hljs-string">&quot;clazzOne&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobbies&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;游泳&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;跑步&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;阅读&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><h4 id="Spring管理数据源：druid事例"><a href="#Spring管理数据源：druid事例" class="headerlink" title="Spring管理数据源：druid事例"></a>Spring管理数据源：druid事例</h4><p>导入依赖：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- MySQL驱动    --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- 数据源    --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.31<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>在您提供的代码片段中，包含了两个 Maven 依赖项，分别是 mysql-connector-java 和 druid，它们用于在 Java 应用程序中使用 MySQL 数据库和数据源。<br>具体来说，mysql-connector-java 是 MySQL 官方提供的 Java JDBC 驱动程序，用于连接 MySQL 数据库。在 Maven 项目中添加该依赖项后，我们可以在 Java 代码中使用 com.mysql.cj.jdbc.Driver 类来加载 MySQL JDBC 驱动程序，从而连接到 MySQL 数据库。<br>druid 是阿里巴巴提供的一个高性能 JDBC 连接池框架，它提供了许多高级功能，例如连接池缓存、连接池监控、SQL 防火墙等。在 Maven 项目中添加该依赖项后，我们可以在 Java 代码中使用 com.alibaba.druid.pool.DruidDataSource 类来创建一个 Druid 数据源，从而在应用程序中管理 JDBC 连接池。<br>设置配置文件：</p><div class="code-wrapper"><pre><code class="hljs abnf">&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;datasource&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;driverClassName&quot;</span>  value<span class="hljs-operator">=</span><span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>&gt;&lt;/property&gt;    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;url&quot;</span>  value<span class="hljs-operator">=</span><span class="hljs-string">&quot;jdbc:mysql://localhost:3306/myemployees?serverTimezone=UTC&quot;</span>&gt;&lt;/property&gt;    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;username&quot;</span>  value<span class="hljs-operator">=</span><span class="hljs-string">&quot;root&quot;</span>&gt;&lt;/property&gt;    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;password&quot;</span>  value<span class="hljs-operator">=</span><span class="hljs-string">&quot;A86789234&quot;</span>&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre></div><p>配置文件都是关于数据库连接的文件，一般这些是放在一个数据库配置文件中的。其实可以通过jdbc资源配置文件配置：</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">jdbc.user</span>=root<span class="hljs-attr">jdbc.password</span>=A86789234<span class="hljs-attr">jdbc.url</span>=jdbc:mysql://localhost:<span class="hljs-number">3306</span>/myemployees?serverTimezone=UTC<span class="hljs-attr">jdbc.driver</span>=com.mysql.cj.jdbc.Driver</code></pre></div><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:property-placeholder</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;datasource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;jdbc.driver&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;jdbc.url&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;jdbc.user&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;jdbc.password&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs csharp">   @Test    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title">testDatasource</span>() throws SQLException</span> &#123;        ClassPathXmlApplicationContext ioc= <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;spring-datasource.xml&quot;</span>);        <span class="hljs-comment">//也可以通过其父类或者所实现的接口</span><span class="hljs-comment">//        DataSource dataSource = ioc.getBean(DataSource.class);</span>        DruidDataSource druidDataSource = ioc.getBean(DruidDataSource.<span class="hljs-keyword">class</span>);        System.<span class="hljs-keyword">out</span>.println(druidDataSource.getConnection());    &#125;<span class="hljs-comment">//输出结果：</span><span class="hljs-comment">//com.mysql.cj.jdbc.ConnectionImpl@3e694b3f</span></code></pre></div><h4 id="bean的作用域："><a href="#bean的作用域：" class="headerlink" title="bean的作用域："></a>bean的作用域：</h4><p>在 Spring 容器中，Bean 的作用域决定了 Bean 实例的生命周期和可见范围。Spring 提供了以下五种 Bean 作用域：</p><ol><li>singleton：单例模式。在整个 Spring 容器中，只会创建一个 Bean 实例，并在需要时共享该实例。默认情况下，所有未显式指定作用域的 Bean 都会使用单例模式。</li><li>prototype：原型模式。每次从容器中获取该 Bean 时，都会创建一个新的实例，并返回给调用者。</li><li>request：Web 应用程序中的请求作用域。在一次 HTTP 请求中，容器会为每个请求创建一个新的实例，并在请求结束时销毁该实例。</li><li>session：Web 应用程序中的会话作用域。在用户会话期间，容器会为每个会话创建一个新的实例，并在会话结束时销毁该实例。</li><li>global session：Web 应用程序中的全局会话作用域。与 session 作用域类似，但仅适用于 Portlet 环境。<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.MyBean&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- Bean 的配置信息 --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div></li></ol><h4 id="1-在IOC容器中默认为单例-也即是scope默认为singleton"><a href="#1-在IOC容器中默认为单例-也即是scope默认为singleton" class="headerlink" title="1.在IOC容器中默认为单例,也即是scope默认为singleton"></a>1.在IOC容器中默认为单例,也即是scope默认为singleton</h4><div class="code-wrapper"><pre><code class="hljs abnf">&lt;bean id <span class="hljs-operator">=</span> <span class="hljs-string">&quot;student&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;com.example.demo.pojo.Student&quot;</span>&gt;    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;id&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;1009&quot;</span>&gt;&lt;/property&gt;    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;name&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;钱九&quot;</span>&gt;&lt;/property&gt;    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;age&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;29&quot;</span>&gt;&lt;/property&gt;    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;sex&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;女&quot;</span>&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs pgsql">  @Test    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span>  testScope()    &#123;        ClassPathXmlApplicationContext ioc = <span class="hljs-built_in">new</span> ClassPathXmlApplicationContext(&quot;spring-scope.xml&quot;);        Student student1 = ioc.getBean(Student.<span class="hljs-keyword">class</span>);        Student student2 = ioc.getBean(Student.<span class="hljs-keyword">class</span>);        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(student1);        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;-----------&quot;);        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(student2);        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(student1==student2);    &#125;//Student&#123;id=<span class="hljs-number">1009</span>, <span class="hljs-type">name</span>=<span class="hljs-string">&#x27;钱九&#x27;</span>, age=<span class="hljs-number">29</span>, sex=<span class="hljs-string">&#x27;女&#x27;</span>, clazz=<span class="hljs-keyword">null</span>, hobbies=<span class="hljs-keyword">null</span>, teacherMap=<span class="hljs-keyword">null</span>&#125;//<span class="hljs-comment">-----------</span>//Student&#123;id=<span class="hljs-number">1009</span>, <span class="hljs-type">name</span>=<span class="hljs-string">&#x27;钱九&#x27;</span>, age=<span class="hljs-number">29</span>, sex=<span class="hljs-string">&#x27;女&#x27;</span>, clazz=<span class="hljs-keyword">null</span>, hobbies=<span class="hljs-keyword">null</span>, teacherMap=<span class="hljs-keyword">null</span>&#125;//<span class="hljs-keyword">true</span></code></pre></div><p>2.设置为scope&#x3D;”prototype”</p><div class="code-wrapper"><pre><code class="hljs abnf">&lt;bean id <span class="hljs-operator">=</span> <span class="hljs-string">&quot;student&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;com.example.demo.pojo.Student&quot;</span> scope<span class="hljs-operator">=</span><span class="hljs-string">&quot;prototype&quot;</span>&gt;    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;id&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;1009&quot;</span>&gt;&lt;/property&gt;    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;name&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;钱九&quot;</span>&gt;&lt;/property&gt;    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;age&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;29&quot;</span>&gt;&lt;/property&gt;    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;sex&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;女&quot;</span>&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs routeros">Student&#123;<span class="hljs-attribute">id</span>=1009, <span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;钱九&#x27;</span>, <span class="hljs-attribute">age</span>=29, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-attribute">clazz</span>=<span class="hljs-literal">null</span>, <span class="hljs-attribute">hobbies</span>=<span class="hljs-literal">null</span>, <span class="hljs-attribute">teacherMap</span>=<span class="hljs-literal">null</span>&#125;-----------Student&#123;<span class="hljs-attribute">id</span>=1009, <span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;钱九&#x27;</span>, <span class="hljs-attribute">age</span>=29, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-attribute">clazz</span>=<span class="hljs-literal">null</span>, <span class="hljs-attribute">hobbies</span>=<span class="hljs-literal">null</span>, <span class="hljs-attribute">teacherMap</span>=<span class="hljs-literal">null</span>&#125;<span class="hljs-literal">false</span></code></pre></div><h4 id="bean的生命周期："><a href="#bean的生命周期：" class="headerlink" title="bean的生命周期："></a>bean的生命周期：</h4><p><a href="https://juejin.cn/post/6866075598184906766">一篇文章让你彻底搞懂Bean后置处理器及执行时机 - 掘金</a></p><div class="code-wrapper"><pre><code class="hljs typescript">package com.<span class="hljs-property">example</span>.<span class="hljs-property">demo</span>.<span class="hljs-property">pojo</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;   <span class="hljs-keyword">private</span> <span class="hljs-title class_">Integer</span> id;   <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> username;   <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> password;   <span class="hljs-keyword">private</span> <span class="hljs-title class_">Integer</span> age;   <span class="hljs-keyword">public</span> <span class="hljs-title class_">User</span>() &#123;       <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;生命周期1：实例化&quot;</span>); &#125;   <span class="hljs-keyword">public</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_">Integer</span> id, <span class="hljs-title class_">String</span> username, <span class="hljs-title class_">String</span> password, <span class="hljs-title class_">Integer</span> age) &#123;       <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id;       <span class="hljs-variable language_">this</span>.<span class="hljs-property">username</span> = username;       <span class="hljs-variable language_">this</span>.<span class="hljs-property">password</span> = password;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age; &#125;   <span class="hljs-keyword">public</span> <span class="hljs-title class_">Integer</span> <span class="hljs-title function_">getId</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> id; &#125;   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setId</span>(<span class="hljs-params">Integer id</span>) &#123;       <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;生命周期2：依赖注入&quot;</span>);       <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id; &#125;   <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getUsername</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> username; &#125;   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setUsername</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> username</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">username</span> = username; &#125;   <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getPassword</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> password; &#125;   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setPassword</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> password</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">password</span> = password; &#125;   <span class="hljs-keyword">public</span> <span class="hljs-title class_">Integer</span> <span class="hljs-title function_">getAge</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> age; &#125;   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setAge</span>(<span class="hljs-params">Integer age</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age; &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +               <span class="hljs-string">&quot;id=&quot;</span> + id +               <span class="hljs-string">&quot;, username=&#x27;&quot;</span> + username + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, password=&#x27;&quot;</span> + password + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, age=&quot;</span> + age +               <span class="hljs-string">&#x27;&#125;&#x27;</span>; &#125; <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span>  <span class="hljs-title function_">initMethod</span>(<span class="hljs-params"></span>) &#123;     <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;生命周期3：初始化！&quot;</span>); &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span>  <span class="hljs-title function_">destroyMethod</span>(<span class="hljs-params"></span>)    &#123;        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;生命周期4：销毁！&quot;</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建</span><span class="hljs-comment">    对象   init-method 和destroy-method分别表示初始化和摧毁时调用的方法--&gt;</span>    <span class="hljs-comment">&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象    --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.demo.pojo.User&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;initMethod&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destroyMethod&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1009&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;钱九&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;29&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs stata">  @<span class="hljs-keyword">Test</span>    public  void  testLife()    &#123;        ClassPathXmlApplicationContext <span class="hljs-keyword">ac</span> = new ClassPathXmlApplicationContext(<span class="hljs-string">&quot;spring-lifetime.xml&quot;</span>);            User user1 = <span class="hljs-keyword">ac</span>.getBean(User.<span class="hljs-keyword">class</span>);            User user2 = <span class="hljs-keyword">ac</span>.getBean(User.<span class="hljs-keyword">class</span>);            System.<span class="hljs-keyword">out</span>.println(user1==user2);            <span class="hljs-keyword">ac</span>.<span class="hljs-keyword">close</span>();<span class="hljs-comment">//刷新关闭容器关闭刷新</span>    &#125;<span class="hljs-comment">//生命周期1：实例化</span><span class="hljs-comment">//生命周期2：依赖注入</span><span class="hljs-comment">//生命周期3：初始化！</span><span class="hljs-comment">//生命周期1：实例化</span><span class="hljs-comment">//生命周期2：依赖注入</span><span class="hljs-comment">//生命周期3：初始化！</span><span class="hljs-comment">//false</span><span class="hljs-comment">//20:52:59.913 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Closing org.springframework.context.support.ClassPathXmlApplicationContext@6b2fad11, started on Wed Jul 05 20:52:59 CST 2023</span></code></pre></div><p>那什么时候实例化呢？</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象    --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.demo.pojo.User&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;initMethod&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destroyMethod&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1009&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;钱九&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;29&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs java"> <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">testLife</span><span class="hljs-params">()</span>    &#123;        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;spring-lifetime.xml&quot;</span>);<span class="hljs-comment">//            User user1 = ac.getBean(User.class);</span>           <span class="hljs-comment">/* User user2 = ac.getBean(User.class);</span><span class="hljs-comment">            System.out.println(user1==user2);</span><span class="hljs-comment">            ac.close();*/</span>    &#125;<span class="hljs-comment">//无输出结果</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs java"> <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">testLife</span><span class="hljs-params">()</span>    &#123;        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;spring-lifetime.xml&quot;</span>);          <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> ac.getBean(User.class);           <span class="hljs-comment">/* User user2 = ac.getBean(User.class);</span><span class="hljs-comment">            System.out.println(user1==user2);</span><span class="hljs-comment">            ac.close();*/</span>    &#125;<span class="hljs-comment">//生命周期1：实例化</span><span class="hljs-comment">//生命周期2：依赖注入</span><span class="hljs-comment">//生命周期3：初始化</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs stata">  @<span class="hljs-keyword">Test</span>    public  void  testLife()    &#123;        ConfigurableApplicationContext <span class="hljs-keyword">ac</span> = new ClassPathXmlApplicationContext(<span class="hljs-string">&quot;spring-lifetime.xml&quot;</span>);          User user1 = <span class="hljs-keyword">ac</span>.getBean(User.<span class="hljs-keyword">class</span>);            User user2 = <span class="hljs-keyword">ac</span>.getBean(User.<span class="hljs-keyword">class</span>);            System.<span class="hljs-keyword">out</span>.println(user1==user2);            <span class="hljs-keyword">ac</span>.<span class="hljs-keyword">close</span>();    &#125;<span class="hljs-comment">//生命周期1：实例化</span><span class="hljs-comment">//生命周期2：依赖注入</span><span class="hljs-comment">//生命周期3：初始化！</span><span class="hljs-comment">//生命周期1：实例化</span><span class="hljs-comment">//生命周期2：依赖注入</span><span class="hljs-comment">//生命周期3：初始化！</span><span class="hljs-comment">//false</span><span class="hljs-comment">//21:51:58.077 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Closing org.springframework.context.support.ClassPathXmlApplicationContext@6b2fad11, started on Wed Jul 05 21:51:57 CST 2023</span><span class="hljs-comment">//进程已结束,退出代码0</span></code></pre></div><p>可以看出多例模式（scope&#x3D;”prototype”）是在或者bean对象时实例化</p><div class="code-wrapper"><pre><code class="hljs abnf">&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;user&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;com.example.demo.pojo.User&quot;</span> scope<span class="hljs-operator">=</span><span class="hljs-string">&quot;singleton&quot;</span> init-method<span class="hljs-operator">=</span><span class="hljs-string">&quot;initMethod&quot;</span> destroy-method<span class="hljs-operator">=</span><span class="hljs-string">&quot;destroyMethod&quot;</span>&gt;       &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;id&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;1009&quot;</span>&gt;&lt;/property&gt;       &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;username&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;钱九&quot;</span>&gt;&lt;/property&gt;        &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;age&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;29&quot;</span>&gt;&lt;/property&gt;       &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;password&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;123456&quot;</span>&gt;&lt;/property&gt;   &lt;/bean&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java">  <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">testLife</span><span class="hljs-params">()</span>    &#123;        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;spring-lifetime.xml&quot;</span>);<span class="hljs-comment">//          User user1 = ac.getBean(User.class);</span>           <span class="hljs-comment">/* User user2 = ac.getBean(User.class);</span><span class="hljs-comment">            System.out.println(user1==user2);</span><span class="hljs-comment">            ac.close();*/</span>    &#125;<span class="hljs-comment">//生命周期1：实例化</span><span class="hljs-comment">//生命周期2：依赖注入</span><span class="hljs-comment">//生命周期3：初始化！</span></code></pre></div><p>总结：这里可以看出单例为啥后面创建的类和第一个类的地址一样,单例模式在创建容器的时候实例化，依赖注入，初始化，随着容器的关闭而摧毁，多例模式在创建对象的时候实例化，依赖注入，初始化，容器关闭不会摧毁bean<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688565300195-fa73648e-ab3b-4fa5-a716-6c21979c83f1.png#averageHue=%23f2eedf&clientId=u03b8032e-d2db-4&from=paste&height=42&id=uacbe958a&originHeight=53&originWidth=637&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=36090&status=done&style=none&taskId=u94654dea-0468-4695-99d0-cfddb2aae05&title=&width=509.6" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688561711858-4f5b5480-aec5-4dc9-9308-83fc4912b1d7.png#averageHue=%23f9f8f5&clientId=u03b8032e-d2db-4&from=paste&height=93&id=u11602db8&originHeight=116&originWidth=620&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=45923&status=done&style=none&taskId=u60a7bcae-e924-4b64-a56c-5b04cbe6a6c&title=&width=496" alt="image.png"><br>在 Spring 容器中，每个 Bean 的生命周期包括以下三个阶段：</p><ol><li>实例化阶段：在这个阶段，容器会使用 Bean 的构造函数或工厂方法创建一个新的 Bean 实例。</li><li>初始化阶段：在这个阶段，容器会对 Bean 进行属性注入和其他初始化操作，例如调用 Bean 的 init-method 方法。</li><li>销毁阶段：在这个阶段，容器会销毁 Bean 实例，并在销毁前调用 Bean 的 destroy-method 方法进行清理操作。</li></ol><h4 id="bean的后置处理器："><a href="#bean的后置处理器：" class="headerlink" title="bean的后置处理器："></a>bean的后置处理器：</h4><p>bean的后置处理器可以在生命周期的初始化前后添加额外的操作，需要实现BeanPostProcessor接口（有2个默认方法），<br>且配置到IOC容器中，需要注意的是，bean后置处理器不是单独针对某一个bean生效，而是针对IOC容<br>器中所有bean都会执行<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688566339927-81ed4340-966a-4a88-bedb-26c8d44fcf24.png#averageHue=%23eeebdd&clientId=u03b8032e-d2db-4&from=paste&height=71&id=u546492a2&originHeight=89&originWidth=635&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=61617&status=done&style=none&taskId=u420ac884-47e3-4240-b82d-184ac46a1f3&title=&width=508" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">BeansException</span>;<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">config</span>.<span class="hljs-property">BeanPostProcessor</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;    <span class="hljs-comment">//初始化之前执行</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">postProcessBeforeInitialization</span>(<span class="hljs-title class_">Object</span> bean, <span class="hljs-title class_">String</span> beanName) throws <span class="hljs-title class_">BeansException</span> &#123;        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;☆☆☆&quot;</span> + beanName + <span class="hljs-string">&quot; = &quot;</span> + bean);        <span class="hljs-keyword">return</span> bean;    &#125;    <span class="hljs-comment">//初始化之后执行</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">postProcessAfterInitialization</span>(<span class="hljs-title class_">Object</span> bean, <span class="hljs-title class_">String</span> beanName) throws <span class="hljs-title class_">BeansException</span> &#123;        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;★★★&quot;</span> + beanName + <span class="hljs-string">&quot; = &quot;</span> + bean);        <span class="hljs-keyword">return</span> bean;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- bean的后置处理器要放入IOC容器才能生效    --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myBeanProcessor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.demo.pojo.MybeanPostProcessor&quot;</span>/&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs dockerfile">    @Test    public  void  testProcessor()    &#123;        ConfigurableApplicationContext ac = new ClassPathXmlApplicationContext(<span class="hljs-string">&quot;spring-lifetime.xml&quot;</span>);        <span class="hljs-keyword">User</span> user1 = ac.getBean(<span class="hljs-keyword">User</span>.class);        System.out.println(user1);        ac.close();    &#125;  /*  生命周期<span class="hljs-number">1</span>：实例化    生命周期<span class="hljs-number">2</span>：依赖注入☆☆☆<span class="hljs-keyword">user</span> = <span class="hljs-keyword">User</span>&#123;id=<span class="hljs-number">1009</span>, username=<span class="hljs-string">&#x27;钱九&#x27;</span>, password=<span class="hljs-string">&#x27;123456&#x27;</span>, age=<span class="hljs-number">29</span>&#125;    生命周期<span class="hljs-number">3</span>：初始化！        ★★★<span class="hljs-keyword">user</span> = <span class="hljs-keyword">User</span>&#123;id=<span class="hljs-number">1009</span>, username=<span class="hljs-string">&#x27;钱九&#x27;</span>, password=<span class="hljs-string">&#x27;123456&#x27;</span>, age=<span class="hljs-number">29</span>&#125;    <span class="hljs-keyword">User</span>&#123;id=<span class="hljs-number">1009</span>, username=<span class="hljs-string">&#x27;钱九&#x27;</span>, password=<span class="hljs-string">&#x27;123456&#x27;</span>, age=<span class="hljs-number">29</span>&#125;<span class="hljs-number">22</span>:<span class="hljs-number">13</span>:<span class="hljs-number">39.564</span> [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Closing org.springframework.context.support.ClassPathXmlApplicationContext@<span class="hljs-number">73</span>f792cf, started on Wed Jul <span class="hljs-number">05</span> <span class="hljs-number">22</span>:<span class="hljs-number">13</span>:<span class="hljs-number">39</span> CST <span class="hljs-number">2023</span>    进程已结束,退出代码<span class="hljs-number">0</span>*/</code></pre></div><h4 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a>接口的默认方法</h4><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface</span> &#123;    <span class="hljs-comment">// 抽象方法</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span>()</span>;    <span class="hljs-comment">// 默认方法</span>    <span class="hljs-function"><span class="hljs-literal">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myDefaultMethod</span>()</span> &#123;        <span class="hljs-comment">// 方法体</span>    &#125;&#125;</code></pre></div><p>默认方法使用default关键字进行声明， 接口的默认方法可以访问接口中的静态变量和静态方法，但是不能访问实现类中的成员变量和成员方法。当一个类实现了多个接口并且这些接口中都有相同名称的默认方法时，编译器会报错。此时需要在实现类中覆盖默认方法并指定具体的实现。接口的默认方法可以被实现类直接使用，也可以被实现类重写。  接口的默认方法可以被继承，如果一个子接口继承了一个父接口，并且重写了父接口中的默认方法，那么子接口中的默认方法会覆盖父接口中的默认方法。 接口的默认方法可以被多继承，如果一个类实现了多个接口，并且这些接口中有相同签名的默认方法，那么这个类必须重写这个默认方法，或者使用super关键字来指定使用哪个接口中的默认方法。</p><h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean:"></a>FactoryBean:</h4><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> com.example.demo.pojo;<span class="hljs-keyword">import</span> org.springframework.beans.factory.FactoryBean;<span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFactoryBean</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">FactoryBean</span></span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-keyword">public</span> User getObject() throws Exception &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">User</span>(); &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;        <span class="hljs-keyword">return</span> User.class; &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.example.demo.pojo.UserFactoryBean&quot;</span>&gt;&lt;/bean&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs pgsql">  @Test    <span class="hljs-built_in">public</span>  <span class="hljs-type">void</span>  factoryTest()    &#123;        //获取IOC容器        ApplicationContext ac = <span class="hljs-built_in">new</span> ClassPathXmlApplicationContext(&quot;spring-factory.xml&quot;);        //因为交给IOC容器管理的是<span class="hljs-keyword">user</span>对象        <span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span> = (<span class="hljs-keyword">User</span>) ac.getBean(&quot;user&quot;);        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">user</span>);    &#125;<span class="hljs-comment">/*    生命周期1：实例化</span><span class="hljs-comment">    User&#123;id=null, username=&#x27;null&#x27;, password=&#x27;null&#x27;, age=null&#125;*/</span></code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688568299407-d1351508-cd00-4d10-bf82-8f32b10b3ddd.png#averageHue=%23f8f7f4&clientId=u03b8032e-d2db-4&from=paste&height=114&id=uf226db02&originHeight=143&originWidth=713&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=75650&status=done&style=none&taskId=uf5053da9-4cfc-42d5-8eab-0f6bcf536ed&title=&width=570.4" alt="image.png"></p><h4 id="基于XML的自动装配："><a href="#基于XML的自动装配：" class="headerlink" title="基于XML的自动装配："></a>基于XML的自动装配：</h4><p><strong>简单来说就是要装配的bean的中，其中有属性为类（可以创建bean的），这个时候可以不用指定ref或者vaule，指定寻找IOC中的bean</strong></p><h6 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h6><p><a href="https://blog.csdn.net/m0_45067620/article/details/118274014">【Spring】使用xml文件实现自动装配；使用注解@Autowired和@Resource实现自动装配_StudiousTiger的博客-CSDN博客</a><br>基于xml的自动装配是Spring框架提供的一种简化Bean依赖注入的方式，它可以让Spring容器根据Bean的名称或类型自动查找并注入相应的属性值，而不需要手动指定ref或value属性。在Spring配置文件中，为需要自动装配的Bean添加autowire属性，并指定其值为byName、byType、constructor、default或no。</p><p>•  byName表示根据Bean的名称进行自动装配，要求Bean的id与被注入属性的名称相同。</p><p>•  byType表示根据Bean的类型进行自动装配，要求Bean的类型与被注入属性的类型相同，且在容器中只有一个该类型的Bean。</p><p>•  constructor表示根据构造器参数进行自动装配，要求容器中有与构造器参数类型和顺序相匹配的Bean。</p><p>•  default表示使用容器默认的自动装配策略，通常是no，即不进行自动装配。</p><p>•  no表示不进行自动装配，需要手动指定ref或value属性。</p><p>下面举一个简单的例子来说明基于xml的自动装配。假设我们有一个Person类，它有一个name属性和一个Car属性：</p><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name;<span class="hljs-keyword">private</span> Car car;<span class="hljs-comment">// 省略构造器、getter和setter</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Car</span> &#123;<span class="hljs-keyword">private</span> String brand;<span class="hljs-keyword">private</span> <span class="hljs-built_in">double</span> price;<span class="hljs-comment">// 省略构造器、getter和setter</span>&#125;</code></pre></div><p>我们想要让Spring容器自动为Person对象注入Car对象，而不需要手动指定ref属性。我们可以在Spring配置文件中，为Person Bean添加autowire属性，并设置其值为byName或byType：</p><bean id="car" class="com.example.Car"><property name="brand" value="BMW"/><property name="price" value="300000"/></bean><bean id="person" class="com.example.Person" autowire="byName"><property name="name" value="Tom"/></bean><p>或者</p><bean id="car" class="com.example.Car"><property name="brand" value="BMW"/><property name="price" value="300000"/></bean><bean id="person" class="com.example.Person" autowire="byType"><property name="name" value="Tom"/></bean>#### xml的自动装配开始：<div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;   <span class="hljs-keyword">private</span> <span class="hljs-title class_">UserService</span> userService;   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setUserService</span>(<span class="hljs-params">UserService userService</span>) &#123;       <span class="hljs-variable language_">this</span>.<span class="hljs-property">userService</span> = userService; &#125;   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">saveUser</span>(<span class="hljs-params"></span>)&#123;       userService.<span class="hljs-title function_">saveUser</span>(); &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> &#123;     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveUser</span>()</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;   <span class="hljs-keyword">private</span> <span class="hljs-title class_">UserDao</span> userDao;   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setUserDao</span>(<span class="hljs-params">UserDao userDao</span>) &#123;         <span class="hljs-variable language_">this</span>.<span class="hljs-property">userDao</span> = userDao;  &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">saveUser</span>(<span class="hljs-params"></span>) &#123;        userDao.<span class="hljs-title function_">saveUser</span>();  &#125;    &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveUser</span>()</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDao</span> &#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">saveUser</span>(<span class="hljs-params"></span>) &#123;       <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;保存成功&quot;</span>);  &#125;&#125;</code></pre></div>上面的类和接口有一环一环的依赖，controller依赖server，server依赖Dap<div class="code-wrapper"><pre><code class="hljs applescript">&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;userController&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;com.example.demo.controller.UserController&quot;</span> &gt;    &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;userService&quot;</span>&gt;&lt;/<span class="hljs-keyword">property</span>&gt;&lt;/bean&gt;    &lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;com.example.demo.service.impl.UserServiceImpl&quot;</span> &gt;        &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>&gt;&lt;/<span class="hljs-keyword">property</span>&gt;    &lt;/bean&gt;    &lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;com.example.demo.UserDao.impl.UserDaoImpl&quot;</span> &gt;    &lt;/bean&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span> <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">testAutowire</span> <span class="hljs-params">()</span> &#123;     <span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;spring-autowire.xml&quot;</span>);     <span class="hljs-type">UserController</span> <span class="hljs-variable">userController</span> <span class="hljs-operator">=</span> context.getBean(UserController.class);    userController.saveUser(); &#125; <span class="hljs-comment">//输出</span> <span class="hljs-comment">//保存成功</span></code></pre></div>###### 修改配置文件自动装配：byType使用bean标签的autowire属性设置自动装配效果 自动装配方式：byTypebyType：根据类型匹配IOC容器中的某个兼容类型的bean，为属性自动赋值若在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值 null若在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常 NoUniqueBeanDefinitionException自动装配方式：byName byName：将自动装配的属性的属性名，作为bean的id在IOC容器中匹配相对应的bean进行赋值<div class="code-wrapper"><pre><code class="hljs abnf">&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;userController&quot;</span>          class<span class="hljs-operator">=</span><span class="hljs-string">&quot;com.example.demo.controller.UserController&quot;</span> autowire<span class="hljs-operator">=</span><span class="hljs-string">&quot;byType&quot;</span>&gt;    &lt;/bean&gt;    &lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;userService&quot;</span>          class<span class="hljs-operator">=</span><span class="hljs-string">&quot;com.example.demo.service.impl.UserServiceImpl&quot;</span> autowire<span class="hljs-operator">=</span><span class="hljs-string">&quot;byType&quot;</span>&gt;    &lt;/bean&gt;    &lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;userDao&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;com.example.demo.UserDao.impl.UserDaoImpl&quot;</span>&gt;&lt;/bean&gt;</code></pre></div>###### 总结：![image.png](https://cdn.nlark.com/yuque/0/2023/png/28066124/1688572395284-7fc48f55-6850-4e8f-9b82-148eb630de6a.png#averageHue=%23ede9d9&clientId=u03b8032e-d2db-4&from=paste&height=49&id=u8f11fe5c&originHeight=61&originWidth=687&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=34049&status=done&style=none&taskId=ub921892a-9e64-42ec-bee0-6b2bc914922&title=&width=549.6)**（自动装配只能装配那些接口，类等属性，也就是要用ref标签引用的属性，其他的不能，需要手动设置属性）**![image.png](https://cdn.nlark.com/yuque/0/2023/png/28066124/1688572942220-8d320593-000c-45a1-b796-a434a5b204c4.png#averageHue=%23edeada&clientId=u03b8032e-d2db-4&from=paste&height=62&id=u7f7b0613&originHeight=77&originWidth=690&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=58220&status=done&style=none&taskId=u87b52934-0a7f-4080-a642-a755a0a4fe8&title=&width=552)![image.png](https://cdn.nlark.com/yuque/0/2023/png/28066124/1688573407060-7980193b-507e-44a1-8659-d909df492fab.png#averageHue=%23f5f4ef&clientId=u03b8032e-d2db-4&from=paste&height=93&id=u6ed64cfc&originHeight=116&originWidth=682&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=85159&status=done&style=none&taskId=u128337dc-3339-46fa-bb84-27541f90112&title=&width=545.6)###### 自动装配byName:byName自动装配它的作用是根据bean的属性名和xml中定义的bean的id进行匹配，如果匹配成功，则将对应的bean注入到属性中。#### 基于注解的bean管理：基于xml的管理常用于第三方提供的bean①注解和 XML 配置文件一样，注解本身并不能执行，注解本身仅仅只是做一个标记，具体的功能是框架检测 到注解标记的位置，然后针对这个位置按照注解标记的功能来执行具体操作。本质上：所有一切的操作都是Java代码来完成的，XML和注解只是告诉框架中的Java代码如何执行。**注意：基于注解管理bean的时候，注解是要加到实现类的，不能加到接口的**#### 相关注解：@Component：将类标识为普通组件  @Controller：将类标识为控制层组件  @Service：将类标 识为业务层组件  @Repository：将类标识为持久层组件（这4个注解功能都是将类标记为组件，只不过他们各自的含义不一样。对应spring管理ioc的时候，这4个注解是等效的，也就是说这4个注解可以替换，但是对于开发人员来说，他们是有各自不同的含义的）<div class="code-wrapper"><pre><code class="hljs html">@Component@Component注解是标记一个类为Spring管理的组件的基本注解。被@Component注解标记的类会被自动扫描并创建为Bean对象，可以通过IoC容器进行管理和使用。通常情况下，使用@Component注解被标记的类都是一些通用的Bean类，没有特别的业务逻辑。@Component还有一些扩展的注解，如@Repository, @Service, @Controller等，它们都是@Component的元注解（注解注解的注解），具有相同的功能，但是在不同的层次上有不同的含义。@Component还可以配合@PostConstruct和@PreDestroy注解来指定bean的初始化和销毁方法。@Controller@Controller注解是标记一个类为Spring MVC中的控制器的注解。被@Controller注解标记的类会被自动扫描并创建为Bean对象，并且会被Spring MVC框架用作请求处理器。@Controller注解通常用于处理用户请求，并返回相应的视图。@Service@Service注解是标记一个类为服务层组件的注解。被@Service注解标记的类会被自动扫描并创建为Bean对象，并且通常用于业务逻辑的处理，例如数据的处理、计算等。@Service注解通常被用作一个服务类的标志。@Repository@Repository注解是标记一个类为数据访问层组件的注解。被@Repository注解标记的类会被自动扫描并创建为Bean对象，并且通常用于数据的访问和持久化操作，例如数据库的访问、文件的读写等。@Autowired@Autowired注解是自动装配的注解，它可以自动将一个Bean注入到另一个Bean中。它可以用于属性、构造函数和方法上。当一个Bean需要使用其他Bean时，可以使用@Autowired注解将需要的Bean注入到当前Bean中，完成依赖注入。当用在构造器上时，Spring会自动查找与构造器参数类型匹配的Bean，并将它们注入到相应的位置。如果存在多个类型匹配的Bean，Spring会抛出一个异常。在这种情况下，我们可以使用@Qualifier注解来指定要注入的Bean。@Qualifier@Qualifier注解是用于注入特定Bean的注解。当一个接口有多个实现类时，可以使用@Qualifier注解指定需要注入的实现类，避免自动装配出现歧义。@Value@Value注解是用于注入属性值的注解，可以将配置文件中的属性值注入到Bean中。@Value注解可以用于属性、构造函数和方法上。@PostConstruct@PostConstruct注解是在Bean初始化之后执行的方法级别注解。当Bean初始化完成后，@PostConstruct注解的方法会被自动调用，可以在该方法中进行一些初始化操作。@PreDestroy@PreDestroy注解是在Bean销毁之前执行的方法级别注解。当Bean销毁之前，@PreDestroy注解的方法会被自动调用，可以在该方法中进行一些清理操作。</code></pre></div>#### 扫描组件：###### 最基本的：为了让spring能够扫描到注解，需要在spring的配置文件添加关于扫描的配置，和在pom文件中添加相关的依赖<div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.example&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span>   &lt;!-component-scan:组件扫描，base-package:通过包来扫描，包名写的越精确扫描的时间越短-&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包    --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>###### 指定排除的：<div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.atguigu&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- context:exclude-filter标签：指定排除规则    --&gt;</span>    <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">type：设置排除或包含的依据</span><span class="hljs-comment">type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名</span><span class="hljs-comment">type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名</span><span class="hljs-comment">在IDE中，可以使用快捷键或右键菜单来复制类的全类名，</span><span class="hljs-comment">例如在IDEA中，可以选中一个类名，然后右键选择Copy Reference，</span><span class="hljs-comment">  或者使用Ctrl+Alt+Shift+C快捷键。--&gt;</span>expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;        <span class="hljs-comment">&lt;!--&lt;context:exclude-filter type=&quot;assignable&quot; </span><span class="hljs-comment">expression=&quot;com.atguigu.controller.UserController&quot;/&gt;--&gt;</span>&lt;/context:component-scan</code></pre></div>###### 只扫描指定的：<div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.atguigu&quot;</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则    --&gt;</span>   <span class="hljs-comment">&lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则    --&gt;</span>   <span class="hljs-comment">&lt;!-- 此时必须设置use-default-filters=&quot;false&quot;，因为默认规则即扫描指定包下所有类    --&gt;</span>    <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">type：设置排除或包含的依据</span><span class="hljs-comment">type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名</span><span class="hljs-comment">type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名</span><span class="hljs-comment">--&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> </span><span class="hljs-tag"><span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--&lt;context:include-filter type=&quot;assignable&quot; </span><span class="hljs-comment">expression=&quot;com.atguigu.controller.UserController&quot;/&gt;--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span></code></pre></div>#### bean的id:在Spring中，Bean ID可以通过多种方式指定，包括：<ol><li><p>默认规则:扫描加注解<br>当使用@Component等注解标记一个类时，如果没有显式指定Bean ID，则默认使用类名的首字母小写作为Bean ID。例如，一个名为UserService的类，其默认的Bean ID为userService。</p></li><li><p>使用@Bean注解<br>当使用@Bean注解在配置类中定义一个Bean时，可以显式指定Bean ID。例如：</p><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">&quot;userService&quot;</span>)    <span class="hljs-keyword">public</span> UserService userService() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">UserServiceImpl</span>();    &#125;&#125;</code></pre></div><p>在这个例子中，@Bean注解用于定义一个Bean，并指定了Bean ID为userService。<br>3.使用注解的value属性自定义id：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688795689516-49cc89a8-1ca6-44a3-8e53-f23746ed1356.png#averageHue=%23141124&clientId=u2b1598f3-93fd-4&from=paste&height=163&id=u564574e3&originHeight=204&originWidth=519&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=26990&status=done&style=none&taskId=u2fc2ea09-7a87-43f5-a45b-cb706c12abf&title=&width=415.2" alt="image.png"> </p></li><li><p>使用XML配置<br>在XML配置文件中，可以使用<bean>元素来定义一个Bean，并指定Bean ID。例如：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.demo.UserService&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置其他属性 --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p>在这个例子中，使用<bean>元素定义了一个名为userService的Bean，并指定其类为com.example.demo.UserService。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688795401819-1715b01b-338a-4464-a56a-efc65c120801.png#averageHue=%23191529&clientId=u2b1598f3-93fd-4&from=paste&height=205&id=u2e8de501&originHeight=256&originWidth=823&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=49167&status=done&style=none&taskId=u46321d7e-f1a1-4c67-b479-65d93cf66c6&title=&width=658.4" alt="image.png"></p></li></ol><h4 id="基于注解的自动装配："><a href="#基于注解的自动装配：" class="headerlink" title="基于注解的自动装配："></a>基于注解的自动装配：</h4><h6 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h6><p><strong>基于注解的自动装配，不需要在本类中为该属性设置get和set方法</strong></p><h6 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired:"></a>@Autowired:</h6><p>用法：在基于注解的自动装配中用于将一个Bean注入到另一个Bean中。<br>1.可以标识在成员变量上，这个时候该成员方法可以不用在它所在的类中设置相关的get和set方法。<br>2.当我们使用@Autowired注解时，Spring会自动查找与被注入的属性或方法参数类型匹配的Bean，并将它们注入到相应的位置。例如：</p><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">UserService</span></span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserDao userDao;    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><p>在这个例子中，我们使用@Autowired注解将UserDao注入到了UserServiceImpl中的userDao属性中。当Spring容器启动时，它会自动找到一个类型为UserDao的Bean，并将它注入到userDao属性中。<br>@Autowired注解可以用在构造器、属性、方法上。当用在构造器上时，Spring会自动查找与构造器参数类型匹配的Bean，并将它们注入到相应的位置。例如：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;    <span class="hljs-keyword">private</span> UserService userService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">public</span> UserController(UserService userService) &#123;        <span class="hljs-keyword">this</span>.userService = userService;    &#125;    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><p>在这个例子中，我们使用@Autowired注解将userService注入到了构造器中。当Spring容器启动时，它会自动查找一个类型为UserService的Bean，并将它注入到构造器中。<br>需要注意的是，如果存在多个类型匹配的Bean，Spring会抛出一个异常。在这种情况下，我们可以使用@Qualifier注解来指定要注入的Bean。例如：</p><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@Component</span>public class UserServiceImpl implements UserService &#123;    <span class="hljs-variable">@Autowired</span>    <span class="hljs-variable">@Qualifier</span>(<span class="hljs-string">&quot;userDaoImpl&quot;</span>)    private UserDao userDao;    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><p>在这个例子中，我们使用@Qualifier注解指定了要注入的Bean的名称为”userDaoImpl”。这样，当存在多个类型为UserDao的Bean时，Spring会查找名称为”userDaoImpl”的Bean并将它注入到userDao属性中。<br> required: 这个属性可以指定是否必须存在一个匹配的bean。默认值是true，如果没有找到匹配的bean，会抛出异常。如果设置为false，那么当没有找到匹配的bean时，字段或者参数会被设置为null。</p><h6 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688861603142-9afafff6-f7cc-4ea5-a103-a6bdfff4f5cb.png#averageHue=%23efebdf&clientId=u581d0f14-5c03-4&from=paste&height=136&id=u7388e55c&originHeight=170&originWidth=743&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=137106&status=done&style=none&taskId=u13fb6161-b3c4-4948-aa03-ec4476286a9&title=&width=594.4" alt="image.png"></p><h4 id="代理模式的介绍："><a href="#代理模式的介绍：" class="headerlink" title="代理模式的介绍："></a>代理模式的介绍：</h4><p>二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标<br>方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑<br>的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调<br>用和打扰，同时让附加功能能够集中在一起也有利于统一维护。<strong>（简单来说就是在调用目标对象之前进行额外的操作，这个时候就需要进行代理，用代理对象来调用目标对象的操作，并且在代理对象中实现额外操作。可能是使用到代理的情况：</strong>当创建一个对象的开销很大时，可以使用代理来延迟对象的创建，只有在需要访问对象时才会创建对象，从而减少了开销。当需要控制对对象的访问时，可以使用代理来限制对对象的访问。代理可以检查调用者的权限，从而保护对象的安全性。<strong>）</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688864926855-30f62a2a-4dab-4cf2-a6ad-c34cd7061f78.png#averageHue=%23ececec&clientId=u581d0f14-5c03-4&from=paste&height=418&id=u74fd2868&originHeight=522&originWidth=733&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=128453&status=done&style=none&taskId=ub1d549b4-1699-4c3b-802d-de767a3e791&title=&width=586.4" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs html">public interface UserService &#123;    void save(User user);&#125;public class UserServiceImpl implements UserService &#123;    @Override    public void save(User user) &#123;        // 保存用户信息    &#125;&#125;public class UserProxy implements UserService &#123;    private UserService userService = new UserServiceImpl();    @Override    public void save(User user) &#123;        // 在保存用户信息之前进行一些操作，例如记录日志等        userService.save(user);        // 在保存用户信息之后进行一些操作，例如发送消息等    &#125;&#125;</code></pre></div><p>在这个示例中，UserProxy类是UserService接口的实现类，它包含一个UserService类型的成员变量userService。在UserProxy类的save方法中，我们可以在调用userService的save方法之前和之后执行其他操作。这样，我们就可以通过UserProxy类来控制对UserServiceImpl对象的访问，从而实现代理模式。</p><h4 id="静态代理："><a href="#静态代理：" class="headerlink" title="静态代理："></a>静态代理：</h4><p>静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来<br>说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代<br>码，日志功能还是分散的，没有统一管理。<br>提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理<br>类来实现。这就需要使用动态代理技术了</p><h4 id="动态代理："><a href="#动态代理：" class="headerlink" title="动态代理："></a>动态代理：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688867552440-d719ebc6-8e68-4af2-81ab-88259681a121.png#averageHue=%23faf9f7&clientId=u280da01d-7a94-4&from=paste&height=126&id=u3d72dfb1&originHeight=157&originWidth=617&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=56798&status=done&style=none&taskId=u47a084bc-7dd2-4269-a126-54af38e5a40&title=&width=493.6" alt="image.png"></p><h6 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h6><p>JDK动态代理是Java提供的一种动态代理实现方式，它基于接口实现，通过反射机制在运行时生成代理类，实现对接口方法的代理。JDK动态代理的代理对象名称是由Proxy类的静态方法newProxyInstance动态生成的，它的格式是$Proxy+数字，其中的数字是随机生成的，所以其名称是不可预测的。<br>JDK动态代理需要实现InvocationHandler接口，该接口只有一个方法invoke，该方法会在代理对象调用方法时被调用，从而实现对被代理方法的增强逻辑。<br>下面是一个简单的JDK动态代理示例，假设有一个UserService接口和一个UserServiceImpl类，我们可以使用JDK动态代理来对UserServiceImpl对象进行代理：</p><div class="code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(User user)</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(User user)</span> </span>&#123;        <span class="hljs-comment">// 保存用户信息</span>    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Object <span class="hljs-keyword">target</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyInvocationHandler</span><span class="hljs-params">(Object <span class="hljs-keyword">target</span>)</span> </span>&#123;        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">target</span> = <span class="hljs-keyword">target</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function">Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        <span class="hljs-comment">// 在调用被代理对象的方法之前执行一些操作，例如记录日志等</span>        Object result = method.invoke(<span class="hljs-keyword">target</span>, args);        <span class="hljs-comment">// 在调用被代理对象的方法之后执行一些操作，例如发送消息等</span>        <span class="hljs-keyword">return</span> result;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();        MyInvocationHandler <span class="hljs-keyword">handler</span> = <span class="hljs-keyword">new</span> MyInvocationHandler(userService);        UserService proxy = (UserService) Proxy.newProxyInstance(            userService.getClass().getClassLoader(),            userService.getClass().getInterfaces(),            <span class="hljs-keyword">handler</span>        );        proxy.save(<span class="hljs-keyword">new</span> User());    &#125;&#125;</code></pre></div><p>在这个示例中，我们创建了一个MyInvocationHandler类来实现对UserServiceImpl对象的代理。在MyInvocationHandler类中，我们通过反射调用被代理对象的方法，并在调用之前和之后执行一些操作。然后，我们使用Proxy类的静态方法newProxyInstance来创建代理对象，并将其强制转换为UserService类型。最后，我们调用代理对象的save方法来保存用户信息。</p><h4 id="AOP介绍："><a href="#AOP介绍：" class="headerlink" title="AOP介绍："></a>AOP介绍：</h4><p>简单来说就是我们要调用目标对象方法的之前或者之后，我们要进行额外的操作，我们不通过修改目标对象的方法来实现，而是通过其他方法实现这就是AOP要解决的问题。<br>见尚硅谷笔记</p><h4 id="基于注解的AOP："><a href="#基于注解的AOP：" class="headerlink" title="基于注解的AOP："></a>基于注解的AOP：</h4><h6 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h6><p>配置pom文件依赖：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 基于Maven依赖传递性，导入spring-context依赖(是IOC的依赖)即可导入当前所需所有jar包    --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- junit测试    --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688871638743-64ecae28-865e-4cac-8ce2-bcf7ea27d0e4.png#averageHue=%230e0c09&clientId=u280da01d-7a94-4&from=paste&height=209&id=u6578205b&originHeight=261&originWidth=618&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=30999&status=done&style=none&taskId=u5e2c5f5b-a607-45c4-b493-f27fd006994&title=&width=494.4" alt="image.png"><br>配置Spring配置文件：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><span class="hljs-comment"> 基于注解的AOP的实现：</span><span class="hljs-comment"> 1、将目标对象和切面交给IOC容器管理（注解+扫描）</span><span class="hljs-comment"> 2、开启AspectJ的自动代理，为目标对象自动生成代理</span><span class="hljs-comment"> 3、将切面类通过注解@Aspect标识</span><span class="hljs-comment"> &lt;context:component-scan&gt;标签用于自动扫描指定包及其子包下的类，并将其注册为bean。</span><span class="hljs-comment">     在启用基于注解的AOP时，我们需要使用该标签来扫描所有带有@Aspect注解的类，并将其转换为切面</span><span class="hljs-comment">&lt;aop:aspectj-autoproxy /&gt;元素表示开启基于AspectJ注解的AOP自动代理，</span><span class="hljs-comment">让Spring容器能够识别@Aspect注解标注的切面类，并根据切面类中的通知和切入点配置为目标对象生成</span><span class="hljs-comment">代理对象。</span><span class="hljs-comment">    --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.example&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span> /&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html">package com.example;public interface Calculator &#123;int add(int i, int j);int sub(int i, int j);int mul(int i, int j);int div(int i, int j);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html">package com.example;import org.springframework.stereotype.Component;@Componentpublic class CalculatorPureImpl implements Calculator &#123;    @Override    public int add(int i, int j) &#123;        int result = i + j;        System.out.println(&quot;方法内部    result = &quot; + result);        return result;    &#125;    @Override    public int sub(int i, int j) &#123;        int result = i - j;        System.out.println(&quot;方法内部    result = &quot; + result);        return result;    &#125;    @Override    public int mul(int i, int j) &#123;        int result = i * j;              System.out.println(&quot;方法内部    result = &quot; + result);       return result; &#125;       @Override       public int div(int i, int j) &#123;       int result = i / j;       System.out.println(&quot;方法内部    result = &quot; + result);       return result; &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html">package com.example;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import java.util.Arrays;//在切面中需要通过指定的注解，将方法标识为通知方法// @Aspect表示这个类是一个切面类@Aspect// @Component注解保证这个切面类能够放入IOC容器，切面类必须要做IOC容器中 @Componentpublic class LogAspect &#123;    //@Before前置通知，在方法执行之前执行,下面的*表示当前类中的所有方法，..表示任意参数   @Before(&quot;execution(public int  CalculatorPureImpl.* (..))&quot;)   //JoinPoint连接点               public void beforeMethod(JoinPoint joinPoint)&#123;       //joinPoint.getSignature()获取当前连接点方法的签名信息，getName()获取连接点方法的方法名       String methodName = joinPoint.getSignature().getName();       //joinPoint.getArgs()获取连接点方法的参数列表       String args = Arrays.toString(joinPoint.getArgs());       System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);                 &#125;     //@After后置通知，也就是方法返回值返回之后才直接执行。   @After(&quot;execution(*  com.example.CalculatorPureImpl.*(..))&quot;)   public void afterMethod(JoinPoint joinPoint)&#123;       String methodName = joinPoint.getSignature().getName();       System.out.println(&quot;Logger--&gt;后置通知，方法名：&quot;+methodName); &#125;    //在返回通知中若要获取目标对象的返回值，只需要通过 @AfterReturning注解的returning属性，//    returning：参数名称，用于指定返回结果的变量名。在通知方法中，可以使用该变量来访问返回结果。这里的返回结果变量名为result。//    throwing：参数名称，用于指定抛出的异常变量名。在通知方法中，可以使用该变量来访问抛出的异常。这里的异常变量名为ex。    @AfterReturning(value = &quot;execution(* com.example.CalculatorPureImpl.*(..))&quot;, returning = &quot;result&quot;)               public void afterReturningMethod(JoinPoint joinPoint, Object result)&#123;       String methodName = joinPoint.getSignature().getName();       System.out.println(&quot;Logger--&gt;返回通知，方法名：&quot;+methodName+&quot;，结 果：&quot;+result);                 &#125;//环绕通知（前面几种通知的集合）：ProceedingJoinPoint继承自JoinPoint接口。相对于JoinPoint，//ProceedingJoinPoint多了一个proceed()方法，用于手动调用目标方法并获取返回值。//环绕通知必须有返回值，返回值的类型是proceed方法返回的类型   @Around(&quot;execution(*  com.example.CalculatorPureImpl.*(..))&quot;)   public Object aroundMethod(ProceedingJoinPoint joinPoint)&#123;             String methodName = joinPoint.getSignature().getName();        String args = Arrays.toString(joinPoint.getArgs());       Object result = null;        try &#123;           System.out.println(&quot;环绕通知--&gt;目标对象方法执行之前&quot;);    //目标对象（连接点）方法的执行，只有下面这条语句执行后才能在目标对象方法中添加额外的操作           result = joinPoint.proceed();           System.out.println(&quot;环绕通知--&gt;目标对象方法返回值之后&quot;);        &#125; catch (Throwable throwable) &#123;//捕获目标对象方法的异常           throwable.printStackTrace();           System.out.println(&quot;环绕通知--&gt;目标对象方法出现异常时&quot;);        &#125; finally &#123;           System.out.println(&quot;环绕通知--&gt;目标对象方法执行完毕&quot;);      &#125;       return result;  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html">@Test   public void  test()   &#123;       ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;aop.annotation.xml&quot;);       //AOP底层是代理模式，这里我们应该获取代理对象的bean,如果获取的是目标对象会报该对象的bean不可用       //注意这里的代理对象表示LogAspect,代理对象而是AOP底层JDK动态代理生成的，名称是不可预测的       //但是它却实现了目标对象的接口，可以通过接口声明        Calculator logAspect= ioc.getBean(Calculator.class);        logAspect.add(1,1);   &#125;</code></pre></div><h4 id="切面的优先级："><a href="#切面的优先级：" class="headerlink" title="切面的优先级："></a>切面的优先级：</h4><p>@Order注解是Spring AOP中用于指定通知顺序的注解。通常情况下，多个切面的通知会按照它们定义的顺序依次执行。但是，如果我们需要显式地指定通知的执行顺序，可以使用@Order注解来实现。<br>@Order注解可以用于类级别和方法级别，它的值越小，优先级越高</p><h4 id="jdbcTemplate"><a href="#jdbcTemplate" class="headerlink" title="jdbcTemplate:"></a>jdbcTemplate:</h4><p>Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>   <span class="hljs-comment">&lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包    --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-comment">&lt;!-- Spring 持久化层支持jar包    --&gt;</span>   <span class="hljs-comment">&lt;!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个 </span><span class="hljs-comment">jar包    --&gt;</span>   <span class="hljs-comment">&lt;!-- 导入    orm 包就可以通过    Maven 的依赖传递性把其他两个也导入    --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-orm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-comment">&lt;!-- Spring 测试相关 ,后面在引入junit是为了让junit在Spring测试环境中运行   --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-comment">&lt;!-- junit测试    --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-comment">&lt;!-- MySQL驱动    --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-comment">&lt;!-- 数据源    --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.31<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>&lt;/dependencies</code></pre></div><div class="code-wrapper"><pre><code class="hljs html">jdbc.username=rootjdbc.password=A86789234jdbc.url=jdbc:mysql://localhost:3306/myemployees?serverTimezone=UTCjdbc.driver=com.mysql.cj.jdbc.Driver</code></pre></div><div class="code-wrapper"><pre><code class="hljs html"> <span class="hljs-comment">&lt;!-- 导入外部属性文件 classpath:类路径，web资源中要指定，   --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span><span class="hljs-comment">&lt;!-- 配置数据源    --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;druidDataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!-- 配置    JdbcTemplate --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span>   <span class="hljs-comment">&lt;!-- 装配数据源    --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;druidDataSource&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html">//指定当前测试类在Spring的测试环境中执行，此时就可以通过注入的方式直接获取IOC容器的bean@RunWith(SpringJUnit4ClassRunner.class)//表示通过类路径的方式配置当前Spring测试环境的配置@ContextConfiguration(&quot;classpath:springJdbc.xml&quot;)public class jdbcTest &#123;        //使用spring的测试环境进行测试，需要将测试中要使用的对象注入spring容器中，这里采用注解自动装配注入        @Autowired        private JdbcTemplate jdbcTemplate;        @Test        public  void  testInsert()        &#123;//没有insert插入，可以通过update实现            jdbcTemplate.update(&quot;insert into t_emp values(5,?,?,?,2)&quot;,&quot;赵士&quot;,29,&quot;女&quot;);        &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html">@Test//查询一条数据为一个实体类对象 public void testSelectEmpById()&#123;   String sql = &quot;select * from t_emp where id = ?&quot;;//BeanPropertyRowMapper将查询结果映射到Emp对象中。   Emp emp = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper<span class="hljs-tag">&lt;&gt;</span> (Emp.class), 1);   System.out.println(emp);&#125;</code></pre></div><p>在使用BeanPropertyRowMapper进行映射时，Emp类中的属性需要满足以下要求：</p><ol><li>Emp类必须有一个无参构造函数，否则会在映射时抛出InstantiationException异常。</li></ol><p>要映射的类必须有一个默认的或无参的构造方法，不能只有带参的构造方法。要映射的类要有公共的setter和getter方法，不能只有其中一个。 要映射的类必须是一个顶级类或静态内部类，不能是非静态的内部类。</p><ol start="2"><li>Emp类中的属性名必须与数据库表中的列名相对应，也可以可以通过使用“驼峰”大小写将用下划线分隔的部分的名称转换为相同的名称来匹配。比如：first_name可以转换为firstName</li><li>Emp类中的属性类型必须与数据库表中相应列的数据类型一致或可以自动转换。例如，如果数据库表中某个列的数据类型为VARCHAR，对应的Emp类中的属性类型可以是String或者其他类型，只要可以进行自动转换即可。</li></ol><h4 id="声明式事务："><a href="#声明式事务：" class="headerlink" title="声明式事务："></a>声明式事务：</h4><p><a href="https://blog.csdn.net/zxlyx/article/details/120446177">详解 spring 声明式事务(@Transactional)_purple.taro的博客-CSDN博客</a><br>所谓声明式事务，就是通过配置的方式，比如通过配置文件（xml）或者注解的方式，告诉spring，哪些方法需要spring帮忙管理事务，然后开发者只用关注业务代码，而事务的事情spring自动帮我们控制。</p><h6 id="基于注解的声明式事务："><a href="#基于注解的声明式事务：" class="headerlink" title="基于注解的声明式事务："></a>基于注解的声明式事务：</h6><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>   <span class="hljs-comment">&lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包    --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-comment">&lt;!-- Spring 持久化层支持jar包    --&gt;</span>   <span class="hljs-comment">&lt;!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个 </span><span class="hljs-comment">jar包    --&gt;</span>   <span class="hljs-comment">&lt;!-- 导入    orm 包就可以通过    Maven 的依赖传递性把其他两个也导入    --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-orm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-comment">&lt;!-- Spring 测试相关    --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-comment">&lt;!-- junit测试    --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-comment">&lt;!-- MySQL驱动    --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-comment">&lt;!-- 数据源    --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.31<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html">jdbc.username=rootjdbc.password=A86789234jdbc.url=jdbc:mysql://localhost:3306/myemployees?serverTimezone=UTCjdbc.driver=com.mysql.cj.jdbc.Driver</code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tool http://www.springframework.org/schema/tool/spring-tool.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 导入外部属性文件 classpath:类路径，web资源中要指定，   --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span>    <span class="hljs-comment">&lt;!-- 配置数据源    --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;druidDataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置    JdbcTemplate --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 装配数据源    --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;druidDataSource&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!--这段代码用来告诉Spring框架需要扫描哪个包下的类，并将这些类注册</span><span class="hljs-comment">          为Spring容器中的Bean对象--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.example&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span>    <span class="hljs-comment">&lt;!--配置事务管理器 这里的ref是链接数据源的id这里使用的是druidDataSource数据源--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;druidDataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!--开启事务注解驱动(annotion选择tx中的）注意此处的tx要导入的命名空间。</span><span class="hljs-comment">    &lt;tx:annotation-driven&gt;：用来开启Spring的声明式事务支持</span><span class="hljs-comment">    transaction-manager：用来指定事务管理器的bean名称。</span><span class="hljs-comment">    transaction-manager后面的值是事务管理器的id，若事务管理器的id为transactionManager</span><span class="hljs-comment">    那么transaction-manager可以省略不写·</span><span class="hljs-comment">    开启后将可以使用@Transaction注解所标识的的方法或类中的所有方法使用事务管理。</span><span class="hljs-comment">    @Transaction加到方法上，该方法就是连接点，加到类上，该类的所有方法都是连接点。</span><span class="hljs-comment">    这样可以对@Transaction注解方法或者类进行事务性管理--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html">CREATE TABLE `t_book` (`book_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `book_name` varchar(20) DEFAULT NULL COMMENT &#x27;图书名称&#x27;, `price` int(11) DEFAULT NULL COMMENT &#x27;价格&#x27;,`stock` int(10) unsigned DEFAULT NULL COMMENT &#x27;库存（无符号）&#x27;, PRIMARY KEY (`book_id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;insert  into `t_book`(`book_id`,`book_name`,`price`,`stock`) values (1,&#x27;斗破苍 穹&#x27;,80,100),(2,&#x27;斗罗大陆&#x27;,50,100);CREATE TABLE `t_user` (`user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `username` varchar(20) DEFAULT NULL COMMENT &#x27;用户名&#x27;,`balance` int(10) unsigned DEFAULT NULL COMMENT &#x27;余额（无符号）&#x27;, PRIMARY KEY (`user_id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;insert  into `t_user`(`user_id`,`username`,`balance`) values (1,&#x27;admin&#x27;,50);</code></pre></div><div class="code-wrapper"><pre><code class="hljs html"> @Controllerpublic class BookController &#123;    @Autowired   private BookService bookService;   public void buyBook(Integer bookId, Integer userId)&#123;        bookService.buyBook(bookId, userId); &#125; &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html">public interface BookService &#123;   void buyBook(Integer bookId, Integer userId); &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html">@Servicepublic class BookServiceImpl implements BookService &#123;    @Autowired @Transactional    private BookDao bookDao;    @Override   public void buyBook(Integer bookId, Integer userId) &#123;        //查询图书的价格       Integer price = bookDao.getPriceByBookId(bookId);        //更新图书的库存       bookDao.updateStock(bookId);        //更新用户的余额       bookDao.updateBalance(userId, price);  &#125; &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html">public interface BookDao &#123;   Integer getPriceByBookId(Integer bookId);    void updateStock(Integer bookId);   void updateBalance(Integer userId, Integer price); &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html">@Repositorypublic class BookDaoImpl implements BookDao &#123;    @Autowired   private JdbcTemplate jdbcTemplate;    @Override   public Integer getPriceByBookId(Integer bookId) &#123;       String sql = &quot;select price from t_book where book_id = ?&quot;;       return jdbcTemplate.queryForObject(sql, Integer.class, bookId);  &#125;   @Override   public void updateStock(Integer bookId) &#123;       String sql = &quot;update t_book set stock = stock - 1 where book_id = ?&quot;;        jdbcTemplate.update(sql, bookId); &#125;   @Override   public void updateBalance(Integer userId, Integer price) &#123;       String sql = &quot;update t_user set balance = balance - ? where user_id = ?&quot;;       jdbcTemplate.update(sql, price, userId);  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tool http://www.springframework.org/schema/tool/spring-tool.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 导入外部属性文件 classpath:类路径，web资源中要指定，   --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span>    <span class="hljs-comment">&lt;!-- 配置数据源    --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;druidDataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置    JdbcTemplate --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 装配数据源    --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;druidDataSource&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!--配置事务管理器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;druidDataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!--开启事务注解驱动(annotion选择tx中的）注意此处的tx要导入的命名空间。--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html">@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:tx-annotation.xml&quot;) public class TxByAnnotationTest &#123;   @Autowired   private BookController bookController;    @Test   public void testBuyBook()&#123;       bookController.buyBook(1, 1);  &#125;&#125;</code></pre></div><h4 id="事务的属性："><a href="#事务的属性：" class="headerlink" title="事务的属性："></a>事务的属性：</h4><p>readonly<br>未完待续。。。。</p><h1 id="SpringMvc-（只包括相关的知识点，相关程序没有走，只是结合老师给的）"><a href="#SpringMvc-（只包括相关的知识点，相关程序没有走，只是结合老师给的）" class="headerlink" title="SpringMvc:（只包括相关的知识点，相关程序没有走，只是结合老师给的）"></a>SpringMvc:（只包括相关的知识点，相关程序没有走，只是结合老师给的）</h1><h4 id="MVC介绍："><a href="#MVC介绍：" class="headerlink" title="MVC介绍："></a>MVC介绍：</h4><p>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分<br>M：Model，模型层，指工程中的JavaBean，作用是处理数据<br>JavaBean分为两类：<br>一类称为实体类Bean：专门存储业务数据的，如 Student、User 等<br>一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。<br>V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据<br>C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器<br>MVC的工作流程： 用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller<br>调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果<br>找到相应的View视图，渲染数据后最终响应给浏览器</p><h4 id="SpringMVC的特点："><a href="#SpringMVC的特点：" class="headerlink" title="SpringMVC的特点："></a>SpringMVC的特点：</h4><p>SpringMVC是Spring的一个后续产品，是Spring的一个子项目<br>SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、<br>WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目<br>表述层开发的首选方案。<br>注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台 servlet<br>Spring 家族原生产品，与 IOC 容器等基础设施无缝对接基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一 处理。表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案 。代码清新简洁，大幅度提升开发效率。内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可 。性能卓著，尤其适合现代大型、超大型互联网项目要求。</p><h4 id="入门案例：（下面方法由于IDEA是2023的有错误的，后面完全是跟着老师的源码）"><a href="#入门案例：（下面方法由于IDEA是2023的有错误的，后面完全是跟着老师的源码）" class="headerlink" title="入门案例：（下面方法由于IDEA是2023的有错误的，后面完全是跟着老师的源码）"></a>入门案例：（下面方法由于IDEA是2023的有错误的，后面完全是跟着老师的源码）</h4><h6 id="项目创建："><a href="#项目创建：" class="headerlink" title="项目创建："></a>项目创建：</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688915710064-4a470bf2-c79f-4ae8-9a17-10668f3fc10c.png#averageHue=%23050403&clientId=ub6a7cc0c-d91b-4&from=paste&height=589&id=u89facdbc&originHeight=983&originWidth=988&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=67634&status=done&style=none&taskId=ub6753472-537f-4f6e-b5e9-caef004519c&title=&width=592" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688915736077-a7d8e962-2afe-4bdb-98f3-0b9d926ef415.png#averageHue=%230b0a09&clientId=ub6a7cc0c-d91b-4&from=paste&height=710&id=u768996e3&originHeight=888&originWidth=739&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=77930&status=done&style=none&taskId=u5b648a25-7878-4c48-8c30-6dbfb8ca621&title=&width=591.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688915746620-15adf4dc-b3c5-4356-a81a-cd2e9e609314.png#averageHue=%23080605&clientId=ub6a7cc0c-d91b-4&from=paste&height=274&id=uef640c46&originHeight=343&originWidth=584&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=18968&status=done&style=none&taskId=uadfe8256-8bbf-477f-ac5d-b51f95de508&title=&width=467.2" alt="image.png">（选择Web应用程序）</p><h6 id="常见新的mvc工程：项目结构图如下"><a href="#常见新的mvc工程：项目结构图如下" class="headerlink" title="常见新的mvc工程：项目结构图如下"></a>常见新的mvc工程：项目结构图如下</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688915793967-5188083d-d94e-44f4-871e-f8e763b3343c.png#averageHue=%230a0807&clientId=ub6a7cc0c-d91b-4&from=paste&height=330&id=ub1889d38&originHeight=412&originWidth=389&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=19311&status=done&style=none&taskId=u4e091b0b-3e7d-46e4-a19e-2519f30c1c3&title=&width=311.2" alt="image.png"></p><h6 id="导入相关依赖："><a href="#导入相关依赖：" class="headerlink" title="导入相关依赖："></a>导入相关依赖：</h6><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>   <span class="hljs-comment">&lt;!-- SpringMVC --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-comment">&lt;!-- 日志    --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-comment">&lt;!-- ServletAPI --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-comment">&lt;!-- Spring5和Thymeleaf整合包    --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.12.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><p>注：由于 Maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠 传递性导入。</p><h6 id="配置web-xml"><a href="#配置web-xml" class="headerlink" title="配置web.xml"></a>配置web.xml</h6><p>注册SpringMVC的前端控制器DispatcherServlet，此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为<servlet-name>- servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC- servlet.xml</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理    --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet&lt;/servlet- class&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">       设置springMVC的核心控制器所能处理的请求的请求路径</span><span class="hljs-comment">       /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 </span><span class="hljs-comment">       但是/不能匹配.jsp请求路径的请求</span><span class="hljs-comment">   --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div><p><strong>扩展配置方式</strong><br><strong>可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置 SpringMVC前端控制器DispatcherServlet的初始化时间。</strong></p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理    --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet&lt;/servlet- class&gt;   <span class="hljs-comment">&lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称    --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>       <span class="hljs-comment">&lt;!-- contextConfigLocation为固定值    --&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>       <span class="hljs-comment">&lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的 </span><span class="hljs-comment">src/main/resources --&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>   <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">作为框架的核心组件，在启动过程中有大量的初始化操作要做 </span><span class="hljs-comment">而这些操作放在第一次请求时才执行会严重影响访问速度</span><span class="hljs-comment">因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时 </span><span class="hljs-comment">--&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">       设置springMVC的核心控制器所能处理的请求的请求路径</span><span class="hljs-comment">       /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 </span><span class="hljs-comment">       但是/不能匹配.jsp请求路径的请求</span><span class="hljs-comment">   --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div><p><url-pattern>标签中使用&#x2F;和&#x2F;*的区别：&#x2F;所匹配的请求可以是&#x2F;login或.html或.js或.css方式的请求路径，但是&#x2F;不能匹配.jsp请求路径的请 求.因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面 &#x2F;*则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用&#x2F;*的写法</p><h6 id="创建请求控制器"><a href="#创建请求控制器" class="headerlink" title="创建请求控制器"></a>创建请求控制器</h6><p>由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要 创建处理具体请求的类，即请求控制器.请求控制器中每一个处理请求的方法成为控制器方法,因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识 .为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在.</p><div class="code-wrapper"><pre><code class="hljs html">@Controllerpublic class HelloController &#123; &#125;</code></pre></div><h6 id="创建SpringMVC的配置文件"><a href="#创建SpringMVC的配置文件" class="headerlink" title="创建SpringMVC的配置文件"></a>创建SpringMVC的配置文件</h6><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 自动扫描包    --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.atguigu.mvc.controller&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!-- 配置Thymeleaf视图解析器：实现视图渲染和页面跳转    --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;viewResolver&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span>   <span class="hljs-comment">&lt;!--name属性设置为order，value属性设置为1，</span><span class="hljs-comment">  这将设置Thymeleaf视图解析器的顺序为1。在Spring MVC中，</span><span class="hljs-comment">  有多个视图解析器可用，按顺序运行，</span><span class="hljs-comment">  直到找到能够处理请求的视图解析器为止。--&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;order&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;characterEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateEngine&quot;</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateResolver&quot;</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">bean</span></span><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span>                    <span class="hljs-comment">&lt;!--配置前缀和后缀可以通过路径路径访问--&gt;</span>                 <span class="hljs-comment">&lt;!-- 视图前缀    --&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span>                   <span class="hljs-comment">&lt;!-- 视图后缀    --&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.html&quot;</span>/&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateMode&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;HTML5&quot;</span>/&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;characterEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>               <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>           <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!--</span><span class="hljs-comment">  处理静态资源，例如html、js、css、jpg</span><span class="hljs-comment"> 若只设置该标签，则只能访问静态资源，其他请求则无法访问</span><span class="hljs-comment">  此时必须设置&lt;mvc:annotation-driven/&gt;解决问题 </span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><span class="hljs-comment">&lt;!-- 开启mvc注解驱动    --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span>&gt;</span>       <span class="hljs-comment">&lt;!-- 处理响应中文内容乱码    --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span></span><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultCharset&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;supportedMediaTypes&quot;</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>text/html<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>application/json<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>               <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>           <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span></code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688948429310-fa23137f-afe9-4c6a-9852-6d02441450e4.png#averageHue=%23f8f6ef&clientId=ucdf75339-60f9-4&from=paste&height=57&id=u35dc23a1&originHeight=71&originWidth=636&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=36570&status=done&style=none&taskId=u88ce7f1e-3a7f-4d80-b16e-29191bef367&title=&width=508.8" alt="image.png"></p><h6 id="测试HelloWorld"><a href="#测试HelloWorld" class="headerlink" title="测试HelloWorld"></a>测试HelloWorld</h6><p>首先配置tomcat服务器<br>实现对首页的访问,在请求控制器中创建处理请求的方法</p><div class="code-wrapper"><pre><code class="hljs html">// @RequestMapping注解：处理请求和控制器方法之间的映射关系// @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径 // localhost:8080/springMVC/@RequestMapping(&quot;/&quot;) public String index() &#123;    //设置视图名称   return &quot;index&quot;; &#125;</code></pre></div><p>②通过超链接跳转到指定页面<br>在主页index.html中设置超链接</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/hello&#125;&quot;</span>&gt;</span>HelloWorld<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>在请求控制器中创建处理请求的方法</p><div class="code-wrapper"><pre><code class="hljs html">@RequestMapping(&quot;/hello&quot;) public String HelloWorld() &#123;    return &quot;target&quot;;&#125;</code></pre></div><h4 id="RequestMapping注解"><a href="#RequestMapping注解" class="headerlink" title="@RequestMapping注解"></a>@RequestMapping注解</h4><p><strong>位置：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688991101360-096000ef-2636-40d6-8ac6-97a2a1043b55.png#averageHue=%23111221&clientId=u2b3dc9ad-44f6-4&from=paste&height=142&id=u8fcb248b&originHeight=178&originWidth=650&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=49138&status=done&style=none&taskId=u070b129b-f8c9-4090-8e09-11b33e3afcb&title=&width=520" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs html">1、@RequestMapping注解标识的位置* @RequestMapping标识一个类：设置映射请求的请求路径的初始信息* @RequestMapping标识一个方法：设置映射请求请求路径的具体信息* 2、@RequestMapping注解value属性* 作用：通过请求的请求路径匹配请求* value属性是数组类型，即当前浏览器所发送请求的请求路径匹配value属性中的任何一个值* 则当前请求就会被注解所标识的方法进行处理* 3、@RequestMapping注解的method属性* 作用：通过请求的请求方式匹配请求* method属性是RequestMethod类型的数组，即当前浏览器所发送请求的请求方式匹配method属性中的任何一中请求方式* 则当前请求就会被注解所标识的方法进行处理* 若浏览器所发送的请求的请求路径和@RequestMapping注解value属性匹配，但是请求方式不匹配* 此时页面报错：405 - Request method &#x27;xxx&#x27; not supported* 在@RequestMapping的基础上，结合请求方式的一些派生注解：* @GetMapping,@PostMapping,@DeleteMapping,@PutMapping* 4、@RequestMapping注解的params属性* 作用：通过请求的请求参数匹配请求，即浏览器发送的请求的请求参数必须满足params属性的设置* params可以使用四种表达式：* &quot;param&quot;：表示当前所匹配请求的请求参数中必须携带param参数* &quot;!param&quot;：表示当前所匹配请求的请求参数中一定不能携带param参数* &quot;param=value&quot;：表示当前所匹配请求的请求参数中必须携带param参数且值必须为value* &quot;param!=value&quot;：表示当前所匹配请求的请求参数中可以不携带param，若携带值一定不能是value* 若浏览器所发送的请求的请求路径和@RequestMapping注解value属性匹配，但是请求参数不匹配* 此时页面报错：400 - Parameter conditions &quot;username&quot; not met for actual request parameters:* 5、@RequestMapping注解的headers属性* 作用：通过请求的请求头信息匹配请求，即浏览器发送的请求的请求头信息必须满足headers属性的设置* 若浏览器所发送的请求的请求路径和@RequestMapping注解value属性匹配，但是请求头信息不匹配* 此时页面报错：404* 6、SpringMVC支持ant风格的路径* 在@RequestMapping注解的value属性值中设置一些特殊字符* ?:任意的单个字符（不包括?）* *:任意个数的任意字符（不包括?和/）* **:任意层数的任意目录，注意使用方式只能**写在双斜线中，前后不能有任何的其他字符* 7、@RequestMapping注解使用路径中的占位符* 传统：/deleteUser?id=1* rest：/user/delete/1* 需要在@RequestMapping注解的value属性中所设置的路径中，使用&#123;xxx&#125;的方式表示路径中的数据* 在通过@PathVariable注解，将占位符所标识的值和控制器方法的形参进行绑定* 获取请求参数的方式：* 1、通过servletAPI获取* 只需要在控制器方法的形参位置设置HttpServletRequest类型的形参* 就可以在控制器方法中使用request对象获取请求参数* 2、通过控制器方法的形参获取* 只需要在控制器方法的形参位置，设置一个形参，形参的名字和请求参数的名字一致即可* 3、@RequestParam：将请求参数和控制器方法的形参绑定* @RequestParam注解的三个属性：value、required、defaultValue* value:设置和形参绑定的请求参数的名字* required:设置是否必须传输value所对应的请求参数* 默认值为true，表示value所对应的请求参数必须传输，否则页面报错：* 400 - Required String parameter &#x27;xxx&#x27; is not present* 若设置为false，则表示value所对应的请求参数不是必须传输，若为传输，则形参值为null* defaultValue:设置当没有传输value所对应的请求参数时，为形参设置的默认值，此时和required属性值无关* 4、@RequestHeader：将请求头信息和控制器方法的形参绑定* 5、@CookieValue：将cookie数据和控制器方法的形参绑定* 6、通过控制器方法的实体类类型的形参获取请求参数* 需要在控制器方法的形参位置设置实体类类型的形参，要保证实体类中的属性的属性名和请求参数的名字一致* 可以通过实体类类型的形参获取请求参数* 7、解决获取请求此参数的乱码问题* 在web.xml中配置Spring的编码过滤器CharacterEncodingFilter* 向域对象共享数据：* 1、通过ModelAndView向请求域共享数据* 使用ModelAndView时，可以使用其Model功能向请求域共享数据* 使用View功能设置逻辑视图，但是控制器方法一定要将ModelAndView作为方法的返回值* 2、使用Model向请求域共享数据* 3、使用ModelMap向请求域共享数据* 4、使用map向请求域共享数据* 5、Model和ModelMap和map的关系* 其实在底层中，这些类型的形参最终都是通过BindingAwareModelMap创建* public class BindingAwareModelMap extends ExtendedModelMap &#123;&#125;* public class ExtendedModelMap extends ModelMap implements Model &#123;&#125;* public class ModelMap extends LinkedHashMap&lt;String, Object&gt; &#123;&#125;</code></pre></div><p>表单提交和axios是post请求，超链接和地址栏输出的都是get请求。<br>请求头和响应头不区分的键不区分大小写，但是值区分。<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">HTTP Cookie - HTTP | MDN</a><br><a href="https://www.cnblogs.com/blknemo/p/13202619.html">【Web】Servlet三大作用域、JSP四大作用域 - Nemo&amp; - 博客园</a><br><a href="https://blog.csdn.net/lingxiyizhi_ljx/article/details/102514560">form表单中的enctype&#x3D;“multipart&#x2F;form-data“什么意思?_夜阑卧听风吹雨，铁马冰河入梦来的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>springboot2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识点</title>
    <link href="/2024/01/26/%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A%EF%BC%88BUG%EF%BC%89/"/>
    <url>/2024/01/26/%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A%EF%BC%88BUG%EF%BC%89/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h4 id="找不到mybatis文件：java-io-IOException-Could-not-find-resource-mybatis-config-xml"><a href="#找不到mybatis文件：java-io-IOException-Could-not-find-resource-mybatis-config-xml" class="headerlink" title="找不到mybatis文件：java.io.IOException: Could not find resource mybatis.config.xml"></a>找不到mybatis文件：java.io.IOException: Could not find resource mybatis.config.xml</h4><p>bug:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688470269608-4fd3e82c-3631-4e0b-8beb-476c4d5ecdac.png#averageHue=%23080302&clientId=u485c1c2b-dc00-4&from=paste&height=144&id=u3d173d10&originHeight=180&originWidth=824&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=28618&status=done&style=none&taskId=uaf61014d-875b-4936-b7c1-15aa27842ac&title=&width=659.2" alt="image.png"><br>原因：mybatis中的<mapper>映射不正确外加生成sqlssesion的文件引用不正确<br>修改后：这里的mybatis-config.xm;和com在同一个目录下的，EmpMapper.xml使用相对路径表示为：com&#x2F;example&#x2F;demo&#x2F;mapper&#x2F;EmpMapper<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688469950619-71023303-ad70-4420-b551-9f37823c8a45.png#averageHue=%231f5043&clientId=u485c1c2b-dc00-4&from=paste&height=214&id=uaf338d14&originHeight=268&originWidth=1191&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=57097&status=done&style=none&taskId=u9ac5034a-e989-49c8-a528-373d7d2ca32&title=&width=952.8" alt="image.png"><br>修改文件引用：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688470214376-cfb36d91-a17c-4da4-98e9-fbd48850bf9e.png#averageHue=%23141624&clientId=u485c1c2b-dc00-4&from=paste&height=160&id=u03f0c4f0&originHeight=200&originWidth=939&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=47710&status=done&style=none&taskId=u723765e0-d52d-4b36-97d7-098d7693021&title=&width=751.2" alt="image.png"></p><h4 id="复制代码出现NBSP乱码解决："><a href="#复制代码出现NBSP乱码解决：" class="headerlink" title="复制代码出现NBSP乱码解决："></a>复制代码出现NBSP乱码解决：</h4><p>现象：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688525778810-d3623e70-93ba-442d-ac3d-927546917921.png#averageHue=%23141618&clientId=uac13984f-90f3-4&from=paste&height=282&id=u8819c1e9&originHeight=352&originWidth=515&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=47152&status=done&style=none&taskId=u3db9185b-8b9b-4a40-ac2b-c41dd916243&title=&width=412" alt="image.png"><br>分析：NBSP（Non-Breaking SPace）是一个不换行的空格字符，它的 Unicode 编码是 U+00A0。有时候，当我们从其他地方复制文本到 IDEA 中，可能会出现 NBSP 字符<br>解决方法：<br>按下ctrl+shift+r打开全局替换：在全局替换中找到有问题的地方，可能直接输入\u00A0查找无法查找，这个时候可以找到有问题的内容（也就是刚刚复制过来的），选择NBSP复制后（复制后粘贴在第一个搜索框中，这个时候显示的是空格）在第二个搜索框中输入空格。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688525869991-7e4727b9-4297-412c-9bd3-fc66dcce6ae8.png#averageHue=%23628d64&clientId=uac13984f-90f3-4&from=paste&height=711&id=u9d096788&originHeight=889&originWidth=704&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=103409&status=done&style=none&taskId=u33a200ee-a893-457e-b8cd-4c945c924fd&title=&width=563.2" alt="image.png"></p><h4 id="org-springframework-beans-factory-xml-XmlBeanDefinitionStoreException-Line-6-in-XML-document-from-class-path-resource-spring-datasource-xml-is-invalid-nested-exception-is-org-xml-sax-SAXParseException-lineNumber-6-columnNumber-62-cvc-complex-type-2-4-c-通配符的匹配很全面-但无法找到元素-‘context-property-placeholder’-的声明。"><a href="#org-springframework-beans-factory-xml-XmlBeanDefinitionStoreException-Line-6-in-XML-document-from-class-path-resource-spring-datasource-xml-is-invalid-nested-exception-is-org-xml-sax-SAXParseException-lineNumber-6-columnNumber-62-cvc-complex-type-2-4-c-通配符的匹配很全面-但无法找到元素-‘context-property-placeholder’-的声明。" class="headerlink" title="org.springframework.beans.factory.xml.XmlBeanDefinitionStoreException: Line 6 in XML document from class path resource [spring-datasource.xml] is invalid; nested exception is org.xml.sax.SAXParseException; lineNumber: 6; columnNumber: 62; cvc-complex-type.2.4.c: 通配符的匹配很全面, 但无法找到元素 ‘context:property-placeholder’ 的声明。"></a>org.springframework.beans.factory.xml.XmlBeanDefinitionStoreException: Line 6 in XML document from class path resource [spring-datasource.xml] is invalid; nested exception is org.xml.sax.SAXParseException; lineNumber: 6; columnNumber: 62; cvc-complex-type.2.4.c: 通配符的匹配很全面, 但无法找到元素 ‘context:property-placeholder’ 的声明。</h4><p>原因：Spring配置文件中的xsi:schemaLocation不全，上面是差context标签的<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688547837996-e5cb89c8-82d1-4a26-9861-9ee5261fa7ec.png#averageHue=%23131317&clientId=ua2de3bac-fb89-4&from=paste&height=119&id=u5b2faab4&originHeight=149&originWidth=1170&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=36135&status=done&style=none&taskId=ud3fe35d5-0254-47d1-adb9-919a77e9882&title=&width=936" alt="image.png"><br>解决方法：添加<a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a><br><a href="http://www.springframework.org/schema/context/spring-context.xsd">http://www.springframework.org/schema/context/spring-context.xsd</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688547915036-3729279c-19a4-4b3a-9bf8-787bdd66c6fe.png#averageHue=%23102128&clientId=ua2de3bac-fb89-4&from=paste&height=218&id=ubd390c4e&originHeight=273&originWidth=1088&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=51474&status=done&style=none&taskId=ue9a6a315-d7c6-442a-9ab7-52019860091&title=&width=870.4" alt="image.png"></p><h4 id="编译失败-内部java编译器错误：打开设置对照下面图片"><a href="#编译失败-内部java编译器错误：打开设置对照下面图片" class="headerlink" title="编译失败:内部java编译器错误：打开设置对照下面图片"></a>编译失败:内部java编译器错误：打开设置对照下面图片</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688988544489-1206a90e-2389-4eba-ac69-e911b209fc40.png#averageHue=%23090808&clientId=ud1bacd7a-acda-4&from=paste&height=364&id=u68d27fb0&originHeight=455&originWidth=1192&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=46683&status=done&style=none&taskId=uee17bef8-9089-45af-9356-97ccc8ea041&title=&width=953.6" alt="image.png"></p><h4 id="ctrl点击类可以进入类内部"><a href="#ctrl点击类可以进入类内部" class="headerlink" title="ctrl点击类可以进入类内部"></a>ctrl点击类可以进入类内部</h4><p><a href="https://blog.csdn.net/BingTaiLi/article/details/109735778">解决Maven ‘parent.relativePath‘ of POM_BingTaiLi的博客-CSDN博客</a><br><parent>标签中加上<relativePath />是用来指定父级pom文件的相对路径为空的，也就是说，不会在本地文件系统中查找父级pom文件，而是直接从本地仓库或远程仓库中查找。这样可以避免一些不必要的错误或警告，</p><h4 id="class-lombok-javac-apt-LombokProcessor-in-unnamed-module-0x7be1ce6a-cannot-access-class-com-sun-tools-javac-processing-JavacProcessingEnvironment-in-module-jdk-compiler-because-module-jdk-compiler-does-not-export-com-sun-tools-javac-processing-to-unnamed-module-0x7be1ce6a"><a href="#class-lombok-javac-apt-LombokProcessor-in-unnamed-module-0x7be1ce6a-cannot-access-class-com-sun-tools-javac-processing-JavacProcessingEnvironment-in-module-jdk-compiler-because-module-jdk-compiler-does-not-export-com-sun-tools-javac-processing-to-unnamed-module-0x7be1ce6a" class="headerlink" title="class lombok.javac.apt.LombokProcessor (in unnamed module @0x7be1ce6a) cannot access class com.sun.tools.javac.processing.JavacProcessingEnvironment (in module jdk.compiler) because module jdk.compiler does not export com.sun.tools.javac.processing to unnamed module @0x7be1ce6a"></a>class lombok.javac.apt.LombokProcessor (in unnamed module @0x7be1ce6a) cannot access class com.sun.tools.javac.processing.JavacProcessingEnvironment (in module jdk.compiler) because module jdk.compiler does not export com.sun.tools.javac.processing to unnamed module @0x7be1ce6a</h4><p>原因分析：lombok的版本太低了</p><div class="code-wrapper"><pre><code class="hljs html">      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h4 id="IDEA鼠标光标变成了白色粗条，无法正常换行"><a href="#IDEA鼠标光标变成了白色粗条，无法正常换行" class="headerlink" title="IDEA鼠标光标变成了白色粗条，无法正常换行"></a>IDEA鼠标光标变成了白色粗条，无法正常换行</h4><p>原因分析：按住了insert进入覆盖模式了。再次按insert就可以变成原本的模式。</p>]]></content>
    
    
    
    <tags>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端bug</title>
    <link href="/2024/01/26/%E5%89%8D%E7%AB%AF%E8%99%AB%E5%B7%A2%EF%BC%9A/"/>
    <url>/2024/01/26/%E5%89%8D%E7%AB%AF%E8%99%AB%E5%B7%A2%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h4 id="Uncaught-TypeError-Vue-is-not-a-constructor"><a href="#Uncaught-TypeError-Vue-is-not-a-constructor" class="headerlink" title="Uncaught TypeError: Vue is not a constructor"></a>Uncaught TypeError: Vue is not a constructor</h4><p>错误描述：<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688607718270-92d49fc2-be09-47e1-be5b-d859947b381e.png#averageHue=%23ca9e64&clientId=u3fbcc324-fcac-4&from=paste&height=610&id=uc2ecf945&originHeight=762&originWidth=788&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=25150&status=done&style=none&taskId=uec197f31-8ed4-4f45-9cd4-3c059ba9b74&title=&width=630.4" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"><span class="hljs-comment">&lt;!--通过CDN引入全局的vue.js文件--&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">mess</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><span class="language-xml">        Hello, Vue!</span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">//创建Vue的实例并且绑定</span></span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span> ( &#123;</span></span><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#app&quot;</span>,</span></span><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">data</span>:&#123;</span></span><span class="language-javascript"><span class="language-xml">                <span class="hljs-attr">mes</span>:<span class="hljs-string">&quot;hello world!!&quot;</span></span></span><span class="language-javascript"><span class="language-xml">            &#125;</span></span><span class="language-javascript"><span class="language-xml">        &#125;)</span></span><span class="language-javascript"><span class="language-xml">      </span></span><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre></div><p>原因：通过CDN导入的vue3，应该导入vue2<br>修改：将</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--通过CDN引入全局的vue.js文件--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>改成：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><h4 id="启动vue项目管理显示断开连接："><a href="#启动vue项目管理显示断开连接：" class="headerlink" title="启动vue项目管理显示断开连接："></a>启动vue项目管理显示断开连接：</h4><p>输入vue ui启动项目管理遇到的问题：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688713252188-4bec1391-94c0-4841-bca0-b7f8af05a9a4.png#averageHue=%232d2d2c&clientId=u8b3834fa-4e23-4&from=paste&id=uf7c369f1&originHeight=427&originWidth=732&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=36947&status=done&style=none&taskId=u01ba1473-7c1c-46b9-aa4e-e0f94f6560b&title=" alt="image.png"><br>解决方法：添加系统环境变量：C:\Windows\System32；</p><h4 id="删除vue项目的一个自定义组件后报-error-Component-name-“elinput”-should-always-be-multi-word-vue-multi-word-component-names"><a href="#删除vue项目的一个自定义组件后报-error-Component-name-“elinput”-should-always-be-multi-word-vue-multi-word-component-names" class="headerlink" title="删除vue项目的一个自定义组件后报:error  Component name “elinput” should always be multi-word  vue&#x2F;multi-word-component-names"></a>删除vue项目的一个自定义组件后报:error  Component name “elinput” should always be multi-word  vue&#x2F;multi-word-component-names<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688782766237-782a2b10-9b07-4e14-8488-62f33a283ffd.png#averageHue=%23161617&clientId=u5cbc3a4f-bffa-4&from=paste&height=285&id=u4aeece03&originHeight=356&originWidth=1286&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=36451&status=done&style=none&taskId=u19fc7b30-183f-4f96-be81-e5e974108cc&title=&width=1028.8" alt="image.png"></h4><p>原因：可能是你没有完全卸载eslint，它可能还存在于全局安装的包中。你可以使用npm list -g命令查看全局安装的包，如果看到eslint，就可以使用npm uninstall -g eslint –save命令卸载它。</p><h4 id="Duplicate-entry-‘1’-for-key-‘t-emp-PRIMARY’"><a href="#Duplicate-entry-‘1’-for-key-‘t-emp-PRIMARY’" class="headerlink" title="Duplicate entry ‘1’ for key ‘t_emp.PRIMARY’"></a>Duplicate entry ‘1’ for key ‘t_emp.PRIMARY’</h4><p>Duplicate：重复；原因：插入sql的主键重复了</p><h4 id="Uncaught-runtime-errors-ERROR-vue-WEBPACK-IMPORTED-MODULE-0-default-is-undefined"><a href="#Uncaught-runtime-errors-ERROR-vue-WEBPACK-IMPORTED-MODULE-0-default-is-undefined" class="headerlink" title="Uncaught runtime errors:ERROR:vue__WEBPACK_IMPORTED_MODULE_0__.default is undefined"></a>Uncaught runtime errors:ERROR:vue__WEBPACK_IMPORTED_MODULE_0__.default is undefined</h4><p>错误描述：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688967384172-2dc1b1e9-349a-4014-80e1-e9e546981567.png#averageHue=%23332123&clientId=ue1e7ae7b-b956-4&from=paste&height=366&id=u9f359619&originHeight=457&originWidth=838&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=48331&status=done&style=none&taskId=u8df096df-24a2-4ec8-83c2-9f62c2077ce&title=&width=670.4" alt="Snipaste_2023-07-10_13-36-22.png"><br>原因：<br>我的项目使用的是 vue 3.3.4 版本，但是你的 main.js 文件中使用的是 vue 2 的语法。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688967460719-06ddfd72-8351-481a-bab4-7174989c78ed.png#averageHue=%23251c10&clientId=ue1e7ae7b-b956-4&from=paste&height=122&id=u0f48bdbc&originHeight=153&originWidth=550&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=14095&status=done&style=none&taskId=ucb48d7ee-32a5-422d-95d1-f443209333d&title=&width=440" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs html">import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = false Vue.use(Vuex)let store = new Vuex.Store(&#123; state:&#123;count: 100 &#125;&#125;)new Vue(&#123; store,render: h =&gt; h(App), &#125;).$mount(&#x27;#app&#x27;)</code></pre></div><p>修改方法：<br>方法1：main.js中使用vue3的语法：</p><div class="code-wrapper"><pre><code class="hljs html">import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import Vuex from &#x27;vuex&#x27;let store = new Vuex.Store(&#123; state:&#123;count: 100 &#125;&#125;)const app = createApp(App)app.use(store)app.mount(&#x27;#app&#x27;)</code></pre></div><p>方法2：重新创建一个项目，创建项目的时候注意选择vue2版本的。</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue学习笔记</title>
    <link href="/2024/01/26/Vue_/"/>
    <url>/2024/01/26/Vue_/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1698826781345-f33295d9-eb1c-4c57-bf25-a24336fbf099.jpeg"></p><h2 id="1-vuecli创建项目："><a href="#1-vuecli创建项目：" class="headerlink" title="1.vuecli创建项目："></a>1.vuecli创建项目：</h2><p><a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">创建一个项目 | Vue CLI</a><br>先安装Vue CLI:</p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install -g @vue/cli</code></pre></div><p>方法1：在要创建的项目所在的文件夹中使用：vue create 项目名，然后在选择要创建的Vue版本。<br>方法2：在要创建项目的所在位置使用: vue ui打开图形化界面来创建项目<br>2.Vue组件命令的时候，一定要使用大驼峰命名发，否则vueCli导入组<br>件的时候不成功。导入组件可以用。导入组件成功后使用导入的组件可以把大驼峰转化为小驼峰加下划线使用。<br>3.main.js进行的组件注册是全局注册。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1698624062058-a6666eeb-6f1b-4edb-bfd5-d71fafa6fd7f.jpeg"></p><ol><li><strong>全局样式</strong>: 默认组件中的样式会作用到全局，任何一个组件中都会受到此样式的影响 </li><li><strong>局部样式</strong>: 可以给组件加上<strong>scoped</strong> 属性,可以<strong>让样式只作用于当前组件</strong></li></ol><h3 id="3-scoped原理"><a href="#3-scoped原理" class="headerlink" title="3.scoped原理"></a>3.scoped原理</h3><ol><li>当前组件内标签都被添加<strong>data-v-hash值</strong> 的属性</li><li>css选择器都被添加 [<strong>data-v-hash值</strong>] 的属性选择器</li></ol><h3 id="data为什么要写成函数"><a href="#data为什么要写成函数" class="headerlink" title="data为什么要写成函数"></a>data为什么要写成函数</h3><p>一个组件的 <strong>data</strong> 选项必须<strong>是一个函数</strong>。目的是为了：保证每个组件实例，维护<strong>独立</strong>的一份<strong>数据</strong>对象。<br>每次创建新的组件实例，都会新<strong>执行一次data 函数</strong>，得到一个新对象。</p><h3 id="父子通信流程"><a href="#父子通信流程" class="headerlink" title="父子通信流程"></a>父子通信流程</h3><ol><li>父组件通过 <strong>props</strong> 将数据传递给子组件</li><li>子组件利用 <strong>$emit</strong> 通知父组件修改更新</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698626345412-e776382b-4d4e-43e4-9b59-255a383fd7c8.png#averageHue=%23e6f3ef&clientId=u95097dde-b906-4&from=paste&height=406&id=u08b5f34f&originHeight=507&originWidth=1173&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=66653&status=done&style=none&taskId=u1cece604-df11-4e22-b9bc-96faef5930a&title=&width=938.4" alt="image.png"></p><h3 id="父向子通信："><a href="#父向子通信：" class="headerlink" title="父向子通信："></a>父向子通信：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698626400257-f2d3adad-e74f-4951-80e2-55d2c762797a.png#averageHue=%2325201f&clientId=u95097dde-b906-4&from=paste&height=368&id=u1025f78c&originHeight=460&originWidth=1205&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=204825&status=done&style=none&taskId=ubed31dde-a2bc-49d7-a8e7-5ca88e6589d&title=&width=964" alt="image.png"><br>父向子传值步骤</p><ol><li>给子组件以添加属性的方式传值</li><li>子组件内部通过props接收</li><li>模板中直接使用 props接收的值<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1.</span>props是properties的缩写<span class="hljs-number">2.</span>可以理解为javaScript中给每个组件声明了一个属性，通过:属性名的方法，将属性和data绑定起来，父组件通过给属性赋值，从而达到给子组件传递信息的目的<span class="hljs-number">2.</span>组件的props可以为任意数量和任意类型<span class="hljs-number">3.</span>其属性赋值是通过外部父组件来赋值的，当父组件没有给某些属性赋值的时候为默认值</code></pre></div></li></ol><h2 id="props校验完整写法"><a href="#props校验完整写法" class="headerlink" title="props校验完整写法"></a>props校验完整写法</h2><div class="code-wrapper"><pre><code class="hljs java">props: &#123;  校验的属性名: &#123;    type: 类型,  <span class="hljs-comment">// Number String Boolean ...</span>    required: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否必填</span>    <span class="hljs-keyword">default</span>: 默认值, <span class="hljs-comment">// 默认值</span>    validator (value) &#123;      <span class="hljs-comment">// 自定义校验逻辑</span>      <span class="hljs-keyword">return</span> 是否通过校验    &#125;  &#125;&#125;,</code></pre></div><p>1.default和required一般不同时写（因为当时必填项时，肯定是有值的）<br>2.default后面如果是简单类型的值，可以直接写默认。如果是复杂类型的值，则需要以函数的形式return一个默认值</p><h2 id="props-data的区别："><a href="#props-data的区别：" class="headerlink" title="props&amp;data的区别："></a>props&amp;data的区别：</h2><ul><li>data 的数据是<strong>自己</strong>的  →   随便改</li><li>prop 的数据是<strong>外部</strong>的  →   不能直接改，要遵循 <strong>单向数据流</strong></li></ul><p>子组件向父组件传递信息：主要是通过事件冒泡来实现的<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698627545540-57bebd25-271c-46f9-965a-23c8618d8fe5.png#averageHue=%2388841b&clientId=u95097dde-b906-4&from=paste&height=509&id=u5239efe5&originHeight=636&originWidth=1491&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=380249&status=done&style=none&taskId=uede67725-b835-485b-bf05-4df2fe583a3&title=&width=1192.8" alt="image.png"><br>子向父传值步骤</p><ol><li>$emit触发事件，给父组件发送消息通知</li><li>父组件监听$emit触发的事件</li><li>提供处理函数，在函数的性参中获取传过来的参数</li><li><a href="https://cn.vuejs.org/guide/components/props.html#prop-validation">Props | Vue.js</a></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698631510086-67d49f7b-b8cc-443f-b57f-5a76a2cede7c.png#averageHue=%23212121&clientId=u95097dde-b906-4&from=paste&height=166&id=uf3fd8966&originHeight=207&originWidth=1185&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=39141&status=done&style=none&taskId=u5c86521e-ae81-4c6d-8b14-f711a9dc2a7&title=&width=948" alt="image.png"></p><h2 id="非父子通信-event-bus-事件总线"><a href="#非父子通信-event-bus-事件总线" class="headerlink" title="非父子通信-event bus 事件总线"></a>非父子通信-event bus 事件总线</h2><h3 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2.步骤"></a>2.步骤</h3><ol><li>在一个js文件中创建一个都能访问的事件总线 （空Vue实例）<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> Vue from <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-type">const</span> <span class="hljs-variable">Bus</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>()export <span class="hljs-keyword">default</span> Bus</code></pre></div>A组件（接受方），监听Bus的 $on事件<div class="code-wrapper"><pre><code class="hljs java">created () &#123;  Bus.$on(<span class="hljs-string">&#x27;sendMsg&#x27;</span>, (msg) =&gt; &#123;    <span class="hljs-built_in">this</span>.msg = msg  &#125;)&#125;</code></pre></div>B组件（发送方），触发Bus的$emit事件<div class="code-wrapper"><pre><code class="hljs java">Bus.$emit(<span class="hljs-string">&#x27;sendMsg&#x27;</span>, <span class="hljs-string">&#x27;这是一个消息&#x27;</span>)</code></pre></div><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698636317024-ed96fe9a-a0e1-4fed-a41f-9d3bc47c8f13.png#averageHue=%23f7f3f2&clientId=u95097dde-b906-4&from=paste&height=530&id=u3eab1ac4&originHeight=662&originWidth=1069&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=149416&status=done&style=none&taskId=ub9fc78d3-3b61-4635-974c-25487e8f786&title=&width=855.2" alt="image.png"><br>这种通信实际上是通过总线也就是第三方vue来实现的，接受方使用$on方法在总线中注册事件（包括事件处理函数）或者说是注册监听器，然后发送方可以使用$emit调用接收方往总线中添加的事件，使用$emit方法调用总线中的事件的时候通过$emit的第二个参数就实现了传递数据了。简单来说就是接受数据的一方将要对数据的处理写入总线Vue中，发送数据的一凡通过$emit方法传递数据并调用方法进行处理。</li></ol><h2 id="非父子通信-provide-inject："><a href="#非父子通信-provide-inject：" class="headerlink" title="非父子通信-provide&amp;inject："></a>非父子通信-provide&amp;inject：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698635901968-0cd2aa5a-e07a-4c1e-b375-bd44716e3694.png#averageHue=%237db093&clientId=u95097dde-b906-4&from=paste&height=417&id=u32c84a3f&originHeight=521&originWidth=1056&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=51141&status=done&style=none&taskId=u1770605b-da88-4f7b-bc78-b73dbe41271&title=&width=844.8" alt="image.png"></p><ol><li>父组件 provide提供数据<div class="code-wrapper"><pre><code class="hljs java">export <span class="hljs-keyword">default</span> &#123;  provide () &#123;    <span class="hljs-keyword">return</span> &#123;       <span class="hljs-comment">// 普通类型【非响应式】</span>       color: <span class="hljs-built_in">this</span>.color,        <span class="hljs-comment">// 复杂类型【响应式】</span>       userInfo: <span class="hljs-built_in">this</span>.userInfo,     &#125;  &#125;&#125;</code></pre></div>2.子&#x2F;孙组件 inject获取数据<div class="code-wrapper"><pre><code class="hljs java">export <span class="hljs-keyword">default</span> &#123;  inject: [<span class="hljs-string">&#x27;color&#x27;</span>,<span class="hljs-string">&#x27;userInfo&#x27;</span>],  created () &#123;    console.log(<span class="hljs-built_in">this</span>.color, <span class="hljs-built_in">this</span>.userInfo)  &#125;&#125;</code></pre></div></li></ol><h3 id="4-注意"><a href="#4-注意" class="headerlink" title="4.注意"></a>4.注意</h3><ul><li>provide提供的简单类型的数据不是响应式的，复杂类型数据是响应式。（推荐提供复杂类型数据）</li><li>子&#x2F;孙组件通过inject获取的数据，不能在自身组件内修改</li></ul><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model:"></a>v-model:</h2><p>提供数据的双向绑定</p><ul><li>数据变，视图跟着变 :value</li><li>视图变，数据跟着变 <a href="/input">@input </a></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698637980586-383af282-f155-4287-bcc5-aef301ea9041.png#averageHue=%23202020&clientId=u95097dde-b906-4&from=paste&height=174&id=u72bd7179&originHeight=217&originWidth=677&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=40698&status=done&style=none&taskId=uf83fb5e0-7535-4e96-8f7c-599f7e57a2a&title=&width=541.6" alt="image.png"><br><a href="https://blog.csdn.net/muzidigbig/article/details/85317387">vue中$nextTick的用法(视图渲染完，操作dom)-CSDN博客</a><br><a href="https://blog.csdn.net/zhouzuoluo/article/details/84752280">vue.nextTick()方法的使用详解（简单明了）_$nexttick-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot学习笔记</title>
    <link href="/2024/01/26/Springboot_/"/>
    <url>/2024/01/26/Springboot_/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h1 id="1-创建第一个项目："><a href="#1-创建第一个项目：" class="headerlink" title="1.创建第一个项目："></a>1.创建第一个项目：</h1><h2 id="1-引入依赖："><a href="#1-引入依赖：" class="headerlink" title="1.引入依赖："></a>1.引入依赖：</h2><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--    所有springboot项目都必须继承自 spring-boot-starter-parent ,如果报--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></code></pre></div><p>这里可能会报错：<a href="https://blog.csdn.net/BingTaiLi/article/details/109735778">解决Maven ‘parent.relativePath‘ of POM_BingTaiLi的博客-CSDN博客</a></p><h3 id="2-导入场景"><a href="#2-导入场景" class="headerlink" title="2. 导入场景"></a>2. 导入场景</h3><p>场景启动器</p><div class="code-wrapper"><pre><code class="hljs html">    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-comment">&lt;!--        web开发的场景启动器 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><h3 id="3-主程序"><a href="#3-主程序" class="headerlink" title="3. 主程序"></a>3. 主程序</h3><div class="code-wrapper"><pre><code class="hljs html">@SpringBootApplication //这是一个SpringBoot应用public class MainApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(MainApplication.class,args);    &#125;&#125;</code></pre></div><h3 id="4-业务"><a href="#4-业务" class="headerlink" title="4. 业务"></a>4. 业务</h3><div class="code-wrapper"><pre><code class="hljs html">@RestController//将返回内容写入返回体中public class HelloController &#123;    @GetMapping(&quot;/hello&quot;)    public String hello()&#123;        return &quot;Hello,Spring Boot 3!&quot;;    &#125;&#125;</code></pre></div><h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h3><p>默认启动访问： localhost:8080&#x2F;hello</p><h3 id="6-打包"><a href="#6-打包" class="headerlink" title="6. 打包"></a>6. 打包</h3><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--    SpringBoot应用打包插件--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div><p>mvn clean package把项目打成可执行的jar包<br>java -jar demo.jar启动项目<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1689254342403-1c7d5be2-59f7-4d6a-8fa3-8cdcff5aa805.png#averageHue=%233b1f02&clientId=uc9135780-ac3d-4&from=paste&height=262&id=u4bd0926f&originHeight=327&originWidth=581&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=29111&status=done&style=none&taskId=u817b6fc9-a2b3-41c6-beca-6e10804204b&title=&width=464.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1689254431253-f1db82c5-2aff-4240-bbea-b4abbaeb24aa.png#averageHue=%23fbfaf8&clientId=uc9135780-ac3d-4&from=paste&height=269&id=u27e3853e&originHeight=336&originWidth=720&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=38821&status=done&style=none&taskId=ua69cfde8-d2bd-4782-ab37-348c54090d6&title=&width=576" alt="image.png"><br>在该路径下输入cmd，然后运行jar包（命令:jva -jar demo.jar,注意这里必须要字面-jar，因为运行的是jar包）<br>但是能够成功运行要求系统java的环境变量配置的jdk17以上。</p><h1 id="3、应用分析"><a href="#3、应用分析" class="headerlink" title="3、应用分析"></a>3、应用分析</h1><p>思考：<br>1、为什么导入starter-web所有相关依赖都导入进来？</p><ul><li><p>开发什么场景，导入什么<strong>场景启动器。</strong></p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span> <span class="hljs-comment">&lt;!--● 官方提供的场景：命名为：spring-boot-starter-*</span><span class="hljs-comment">● 第三方提供场景：命名为：*-spring-boot-starter</span><span class="hljs-comment">ctrl+鼠标右键即可在IDEA查看相关场景所依赖的jar包和场景--&gt;</span></code></pre></div></li><li><p><strong>maven依赖传递原则。A-B-C： A就拥有B和C</strong></p></li><li><p>导入 场景启动器。 场景启动器 自动把这个场景的所有核心依赖全部导入进来</p></li></ul><p>2、为什么版本号都不用写？</p><ul><li>每个boot项目都有一个父项目spring-boot-starter-parent（它也是一个场景）</li><li>parent的父项目是spring-boot-dependencies（其中的<properties>标签中把所有常见的jar的依赖版本都声明好了。）</li><li>父项目 <strong>版本仲裁中心</strong>，把所有常见的jar的依赖版本都声明好了。</li><li>比如：mysql-connector-j</li><li><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1689258459738-3f6e1e17-aff8-45a2-9c3e-e5e00b943868.png#averageHue=%2312151c&clientId=uc9135780-ac3d-4&from=paste&height=410&id=u0c91b9c1&originHeight=512&originWidth=890&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=95403&status=done&style=none&taskId=ua520442b-66a3-465a-bfe4-8badcfef6af&title=&width=712" alt="image.png"></li></ul><p>3、自定义版本号</p><ul><li>利用maven的就近原则<ul><li>直接在当前项目properties标签中声明父项目用的版本属性的key</li><li>直接在<strong>导入依赖的时候声明版本</strong></li></ul></li></ul><p>4、第三方的jar包</p><ul><li>boot父项目没有管理的需要自行声明好<div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1689257659269-0968fa4d-b7a3-45a8-9fde-d2d34eb062bf.png#averageHue=%23dcb88c&clientId=uc9135780-ac3d-4&from=paste&height=343&id=u81f02c80&originHeight=429&originWidth=864&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=35824&status=done&style=none&taskId=u601e8e76-00f7-4aec-86cf-eb00c95aad8&title=&width=691.2" alt="image.png"></li></ul><h2 id="2-自动配置机制"><a href="#2-自动配置机制" class="headerlink" title="2. 自动配置机制"></a>2. 自动配置机制</h2><h3 id="1-初步理解"><a href="#1-初步理解" class="headerlink" title="1. 初步理解"></a>1. 初步理解</h3><ul><li><p><strong>自动配置</strong>的 Tomcat、SpringMVC 等</p><ul><li><strong>导入场景</strong>，容器中就会自动配置好这个场景的核心组件。</li><li>以前：DispatcherServlet、ViewResolver、CharacterEncodingFilter….</li><li>现在：自动配置好的这些组件</li><li>验证：<strong>容器中有了什么组件，就具有什么功能</strong><div class="code-wrapper"><pre><code class="hljs html">public static void main(String[] args) &#123;    //java10： 局部变量类型的自动推断（可以不用声明变量的类型，直接根据右边的表达式推断）    var ioc = SpringApplication.run(MainApplication.class, args);    //1、获取容器中所有组件的名字    String[] names = ioc.getBeanDefinitionNames();    //2、挨个遍历：    // dispatcherServlet、beanNameViewResolver、characterEncodingFilter、multipartResolver    // SpringBoot把以前配置的核心组件现在都给我们自动配置好了。    for (String name : names) &#123;        System.out.println(name);    &#125;&#125;</code></pre></div></li></ul></li><li><p><strong>默认的包扫描规则</strong></p><ul><li>@SpringBootApplication 标注的类就是主程序类</li><li><strong>SpringBoot只会扫描主程序所在的包及其下面的子包，自动的component-scan功能</strong></li><li><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1689259030746-d45575cd-4785-4951-aea6-41a141d23f5c.png#averageHue=%23267d49&clientId=uc9135780-ac3d-4&from=paste&height=202&id=x93dY&originHeight=252&originWidth=1193&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=55265&status=done&style=none&taskId=u319fb788-593b-49b5-a964-acbd641d340&title=&width=954.4" alt="image.png"></li><li><strong>自定义扫描路径</strong><ul><li>@SpringBootApplication(scanBasePackages &#x3D; “com.atguigu”)&#x2F;&#x2F;scanBasePackages指定扫描的位置</li><li>@ComponentScan(“com.atguigu”) 直接指定扫描的路径</li></ul></li></ul></li><li><p><strong>配置默认值</strong></p><ul><li><strong>配置文件</strong>的所有配置项是和某个<strong>类的对象</strong>值进行一一绑定的。</li><li>绑定了配置文件中每一项值的类： <strong>属性类</strong>。</li><li>比如：<ul><li>ServerProperties绑定了所有Tomcat服务器有关的配置</li><li>MultipartProperties绑定了所有文件上传相关的配置</li><li>….参照<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.server">官方文档</a>：或者参照 绑定的 <strong>属性类</strong>。</li></ul></li></ul></li><li><p>按需加载自动配置</p><ul><li>导入场景spring-boot-starter-web</li><li>场景启动器除了会导入相关功能依赖(ctrl+鼠标右击可以查看导入的依赖），还导入一个spring-boot-starter(每个场景ctrl点进去的配置文件都有一个的spring-boot-starter），是所有starter的starter，这个starter基础核心starter</li><li>spring-boot-starter导入了一个包 spring-boot-autoconfigure。包里面都是各种场景的AutoConfiguration<strong>自动配置类</strong></li><li>虽然全场景的自动配置都在 spring-boot-autoconfigure这个包，但是不是全都开启的。<ul><li>导入哪个场景就开启哪个自动配置</li></ul></li></ul></li></ul><p>总结： 导入场景启动器、触发 spring-boot-autoconfigure这个包的自动配置生效、容器中就会具有相关场景的功能</p><h2 id="1-常用注解"><a href="#1-常用注解" class="headerlink" title="1. 常用注解"></a>1. 常用注解</h2><p>SpringBoot摒弃XML配置方式，改为<strong>全注解驱动</strong></p><h3 id="1-组件注册"><a href="#1-组件注册" class="headerlink" title="1. 组件注册"></a>1. 组件注册</h3><p><strong>@Configuration</strong>、**@SpringBootConfiguration**<br><strong>@Bean</strong>、**@Scope**<br><strong>@Controller、 @Service、@Repository、@Component</strong><br><strong>@Import</strong><br>@ComponentScan<br>步骤：<br><strong>1、@Configuration 编写一个配置类</strong><br><strong>2、在配置类中，自定义方法给容器中注册组件。配合@Bean</strong><br><strong>3、或使用@Import 导入第三方的组件</strong></p><h3 id="2-条件注解"><a href="#2-条件注解" class="headerlink" title="2. 条件注解"></a>2. 条件注解</h3><p>如果注解指定的<strong>条件成立</strong>，则触发指定行为<br><em><strong>@ConditionalOnXxx</strong></em><br><strong>@ConditionalOnClass：如果类路径中存在这个类，则触发指定行为</strong><br><strong>@ConditionalOnMissingClass：如果类路径中不存在这个类，则触发指定行为</strong><br><strong>@ConditionalOnBean：如果容器中存在这个Bean（组件），则触发指定行为</strong><br><strong>@ConditionalOnMissingBean：如果容器中不存在这个Bean（组件），则触发指定行为</strong><br>场景：</p><ul><li>如果存在FastsqlException这个类，给容器中放一个Cat组件，名cat01，</li><li>否则，就给容器中放一个Dog组件，名dog01</li><li>如果系统中有dog01这个组件，就给容器中放一个 User组件，名zhangsan </li><li>否则，就放一个User，名叫lisi</li></ul><p><strong>@ConditionalOnBean（value&#x3D;组件类型，name&#x3D;组件名字）：判断容器中是否有这个类型的组件，并且名字是指定的值</strong></p><p>@ConditionalOnRepositoryType (org.springframework.boot.autoconfigure.data)<br>@ConditionalOnDefaultWebSecurity (org.springframework.boot.autoconfigure.security)<br>@ConditionalOnSingleCandidate (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnWebApplication (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnWarDeployment (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnJndi (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnResource (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnExpression (org.springframework.boot.autoconfigure.condition)<br><strong>@ConditionalOnClass</strong> (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnEnabledResourceChain (org.springframework.boot.autoconfigure.web)<br><strong>@ConditionalOnMissingClass</strong>(org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnNotWebApplication (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnProperty (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnCloudPlatform (org.springframework.boot.autoconfigure.condition)<br><strong>@ConditionalOnBean</strong> (org.springframework.boot.autoconfigure.condition)<br><strong>@ConditionalOnMissingBean</strong> (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnMissingFilterBean (org.springframework.boot.autoconfigure.web.servlet)<br>@Profile (org.springframework.context.annotation)<br>@ConditionalOnInitializedRestarter (org.springframework.boot.devtools.restart)<br>@ConditionalOnGraphQlSchema (org.springframework.boot.autoconfigure.graphql)<br>@ConditionalOnJava (org.springframework.boot.autoconfigure.condition)</p><h3 id="3-属性绑定"><a href="#3-属性绑定" class="headerlink" title="3. 属性绑定"></a>3. 属性绑定</h3><p><strong>@ConfigurationProperties： 声明组件的属性和配置文件哪些前缀开始项进行绑定</strong><br><strong>@EnableConfigurationProperties：快速注册注解：</strong></p><ul><li><strong>场景：</strong>SpringBoot默认只扫描自己主程序所在的包。如果导入第三方包，即使组件上标注了 @Component、@ConfigurationProperties 注解，也没用。因为组件都扫描不进来，此时使用这个注解就可以快<strong>速进行属性绑定并把组件注册进容器</strong></li></ul><p>将容器中任意<strong>组件（Bean）的属性值</strong>和<strong>配置文件</strong>的配置项的值<strong>进行绑定</strong></p><ul><li><strong>1、给容器中注册组件（@Component、@Bean）</strong></li><li><strong>2、使用@ConfigurationProperties 声明组件和配置文件的哪些配置项进行绑定</strong></li></ul><p>更多注解参照：<a href="https://www.bilibili.com/video/BV1gW411W7wy">Spring注解驱动开发</a>【1-26集】</p><h2 id="待复习常用注解（视频1-26集）："><a href="#待复习常用注解（视频1-26集）：" class="headerlink" title="待复习常用注解（视频1-26集）："></a>待复习常用注解（视频1-26集）：</h2><h3 id="核心容器："><a href="#核心容器：" class="headerlink" title="核心容器："></a>核心容器：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1689338993030-dddbdbb3-8d2a-4fb6-99df-400c6bffe713.png#averageHue=%23f6f9f6&clientId=u50cc7f0e-9aa6-4&from=paste&height=117&id=u6123668b&originHeight=146&originWidth=414&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=22183&status=done&style=none&taskId=u609bdd38-2b1f-48b5-86cc-fdde5105864&title=&width=331.2" alt="image.png"></p><h3 id="组件注册："><a href="#组件注册：" class="headerlink" title="组件注册："></a>组件注册：</h3><h4 id="Congfiguration"><a href="#Congfiguration" class="headerlink" title="@Congfiguration:"></a>@Congfiguration:</h4><p>基于xml的注入方式，需要根据<bean>标签逐渐赋值注入容器的。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1689341306219-26dac878-fe79-4a28-9b71-acf8d3693b8c.png#averageHue=%23f7fcfb&clientId=u50cc7f0e-9aa6-4&from=paste&height=21&id=u5063fa94&originHeight=26&originWidth=468&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=15894&status=done&style=none&taskId=u791ed171-4320-4022-8d64-0e763d147b7&title=&width=374.4" alt="image.png">都有注入容器的功能</p><div class="code-wrapper"><pre><code class="hljs html">package com.example.annotationstudy.config;import org.springframework.core.io.Resource;import org.springframework.core.type.AnnotationMetadata;import org.springframework.core.type.ClassMetadata;import org.springframework.core.type.classreading.MetadataReader;import org.springframework.core.type.classreading.MetadataReaderFactory;import org.springframework.core.type.filter.TypeFilter;import java.io.IOException;import java.lang.annotation.Annotation;public class MytypeFilter implements TypeFilter    &#123;    @Override//    MetadataReader读取到当前真正扫描的类，MetadataReaderFactory可以获取其他任何类的信息    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException    &#123;//        获取当前正在扫描的类的注解信息        AnnotationMetadata annotation= metadataReader.getAnnotationMetadata();        //获取当前真正扫描类的类信息，比如它的类型是什么，实现了什么接口         ClassMetadata classMetadata = metadataReader.getClassMetadata();        //获取当前类资源信息(类路径）       Resource resource =  metadataReader.getResource();       String className =classMetadata.getClassName();        System.out.println(&quot;---&gt;&quot;+className);        if(className.contains(&quot;er&quot;))        return  true;        return false;    &#125;    &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html">package com.example.annotationstudy;import com.example.annotationstudy.config.test;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;//SpringApplication.run(AnnotationStudyApplication.class, args);public class AnnotationStudyApplication&#123;    public static void main(String[] args)    &#123;        ApplicationContext applicationContext =  new AnnotationConfigApplicationContext(test.class);        System.out.println( applicationContext.getBean(Person.class));        String[] nameType = applicationContext.getBeanNamesForType(Person.class);//查看Person类的Bean数组在容器中的id数组        for (String string:nameType)        &#123;            System.out.println(string);        &#125;    &#125;//    Person&#123;name=&#x27;1&#x27;, age=1&#125;//     person1@Testpublic void  test01()&#123;    ApplicationContext applicationContext =  new AnnotationConfigApplicationContext(test.class);    String[] nameType = applicationContext.getBeanDefinitionNames();//查看Person类的Bean数组在容器中的id数组    for (String string:nameType)    &#123;        System.out.println(string);    &#125;&#125;/*没有加过滤器前的结果：test//@Configuration注入的组件,@Configuration注解有@Component修饰bookController//@Controller注入的组件bookDao//@Repository注入的组件bookService//@Service注入的组件person//  @Bean(&quot;person&quot;)注入的组件*//*加了过滤器:testbookDaobookServiceperson*//*自定义过滤规则的输出结果---&gt;com.example.annotationstudy.AnnotationStudyApplication---&gt;com.example.annotationstudy.config.MytypeFilter---&gt;com.example.annotationstudy.controller.BookController---&gt;com.example.annotationstudy.dao.BookDao---&gt;com.example.annotationstudy.Person---&gt;com.example.annotationstudy.service.bookServiceorg.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactory        testbookDao        person进程已结束,退出代码0*/&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html">package com.example.annotationstudy.config;import com.example.annotationstudy.Person;import com.example.annotationstudy.service.bookService;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.FilterType;import org.springframework.stereotype.Controller;//配置类===配置文件@Configuration//告诉spring这是一个配置类@ComponentScan(value=&quot;com.example.annotationstudy&quot;,        includeFilters = &#123;@ComponentScan.Filter(type = FilterType.CUSTOM,classes = MytypeFilter.class)&#125;)//将Controller注解过滤掉//类似xml中的包扫描标签<span class="hljs-tag">&lt;<span class="hljs-name">context:component-sacn</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>//@ComponentScan value（数组类型）指定要扫描的包， Filter[] excludeFilters();指定过滤规则；// Filter[] includeFilters()指定扫描只包含哪些注解//FilterType.ANNOTATION按照给定的注解加载（type = FilterType.ANNOTATION,classes = Controller.class)排除/只加载Contorller注解//FilterType.ASSIGNABLE_TYPE按照给定类型加载,type = FilterType.ASSIGNABLE_TYPE,classes = bookService.class排除/只加载bookService类型的bean//FilterType.REGEX按照正则表达式，//FilterType.CUSTOM;使用自定义规则；@ComponentScan.Filter(type = FilterType.CUSTOM,classes = MytypeFilter.class)//MytypeFilter.class返回ture或false决定是否排除/加载类到容器，如果为ture就加载/排除bean到容器内，其中value指定的路径下所有的类// 都会在MytypeFilter中进行判断，看能否加入到容器中public class test&#123;//    给容器中注册一个bean,类型为方法的返回值的类型，id默认为方法名作为id,其中该注解的vaule值赋值id的优先级高于方法名    @Bean(&quot;person&quot;)//也可以这样给bean赋值为person,最后这里注入bean的id是person;类似xml中的bean标签    public Person person1()    &#123;        return new Person(&quot;1&quot;,1);    &#125;&#125;</code></pre></div><h2 id="2-完整流程"><a href="#2-完整流程" class="headerlink" title="2. 完整流程"></a>2. 完整流程</h2><p>思考：<br><strong>1、SpringBoot怎么实现导一个starter、写一些简单配置，应用就能跑起来，我们无需关心整合</strong><br>2、为什么Tomcat的端口号可以配置在application.properties中，并且Tomcat能启动成功？<br>3、导入场景后哪些<strong>自动配置能生效</strong>？<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1679970508234-3c6b8ecc-6372-4eb5-8c67-563054d1a72d.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_37,text_5bCa56GF6LC3IGF0Z3VpZ3UuY29t,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#averageHue=%23b9b985&from=url&id=Xvkxy&originHeight=583&originWidth=1281&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p><p><em><strong>自动配置流程细节梳理：</strong></em><br><strong>1、</strong>导入starter-web：导入了web开发场景</p><ul><li>1、场景启动器导入了相关场景的所有依赖：starter-json、starter-tomcat、springmvc</li><li>2、每个场景启动器都引入了一个spring-boot-starter，核心场景启动器。</li><li>3、<strong>核心场景启动器</strong>引入了spring-boot-autoconfigure包。</li><li>4、spring-boot-autoconfigure里面囊括了所有场景的所有配置。</li><li>5、只要这个包下的所有类都能生效，那么相当于SpringBoot官方写好的整合功能就生效了。</li><li>6、SpringBoot默认却扫描不到 spring-boot-autoconfigure下写好的所有<strong>配置类</strong>。（这些<strong>配置类</strong>给我们做了整合操作），<strong>默认只扫描主程序所在的包</strong>。</li></ul><p><strong>2、主程序</strong>：@SpringBootApplication</p><ul><li>1、@SpringBootApplication由三个注解组成@SpringBootConfiguration、@EnableAutoConfiguratio、@ComponentScan</li><li>2、SpringBoot默认只能扫描自己主程序所在的包及其下面的子包，扫描不到 spring-boot-autoconfigure包中官方写好的<strong>配置类</strong></li><li>3、**@EnableAutoConfiguration**：SpringBoot <strong>开启自动配置的核心</strong>。<ul><li><ol><li>是由@Import(AutoConfigurationImportSelector.class){，@Import是一个注解，允许您将其他配置类导入到应用程序上下文中}提供功能：批量给容器中导入组件。</li></ol></li><li><ol start="2"><li>SpringBoot启动会默认加载 142个配置类。</li></ol></li><li><ol start="3"><li>这<strong>142个配置类</strong>来自于spring-boot-autoconfigure下 META-INF&#x2F;spring&#x2F;<strong>org.springframework.boot.autoconfigure.AutoConfiguration</strong>.imports文件指定的</li></ol></li><li>项目启动的时候利用 @Import 批量导入组件机制把 autoconfigure 包下的142 xxxxAutoConfiguration类导入进来（<strong>自动配置类</strong>）</li><li>虽然导入了142个自动配置类</li></ul></li><li>4、按需生效：<ul><li>并不是这142个自动配置类都能生效</li><li>每一个自动配置类，都有条件注解@ConditionalOnxxx，只有条件成立，才能生效</li></ul></li></ul><p><strong>3、xxxxAutoConfiguration自动配置类</strong></p><ul><li><strong>1、给容器中使用@Bean 放一堆组件。</strong></li><li>2、每个<strong>自动配置类</strong>都可能有这个注解@EnableConfigurationProperties(<strong>ServerProperties</strong>.class)，用来把配置文件中配的指定前缀的属性值封装到 xxxProperties<strong>属性类</strong>中</li><li>3、以Tomcat为例：把服务器的所有配置都是以server开头的。配置都封装到了属性类中。</li><li>4、给<strong>容器</strong>中放的所有<strong>组件</strong>的一些<strong>核心参数</strong>，都来自于<strong>xxxProperties。xxxProperties都是和配置文件绑定。</strong></li><li><strong>只需要改配置文件的值，核心组件的底层参数都能修改</strong></li></ul><p><strong>4、</strong>写业务，全程无需关心各种整合（底层这些整合写好了，而且也生效了）</p><p><strong>核心流程总结：</strong><br>1、导入starter，就会导入autoconfigure包。<br>2、autoconfigure 包里面 有一个文件 META-INF&#x2F;spring&#x2F;<strong>org.springframework.boot.autoconfigure.AutoConfiguration</strong>.imports,里面指定的所有启动要加载的自动配置类<br>3、@EnableAutoConfiguration 会自动的把上面文件里面写的所有<strong>自动配置类都导入进来。xxxAutoConfiguration 是有条件注解进行按需加载</strong><br>4、xxxAutoConfiguration给容器中导入一堆组件，组件都是从 xxxProperties中提取属性值<br>5、xxxProperties又是和<strong>配置文件</strong>进行了绑定<br><strong>效果：</strong>导入starter、修改配置文件，就能修改底层行为。</p><h2 id="2-YAML配置文件"><a href="#2-YAML配置文件" class="headerlink" title="2. YAML配置文件"></a>2. YAML配置文件</h2><p><strong>痛点</strong>：SpringBoot 集中化管理配置，application.properties<br><strong>问题</strong>：配置多以后难阅读和修改，<strong>层级结构辨识度不高</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1689294105675-0b73afd6-0887-4d7c-9d56-9e988a84a0ae.png#averageHue=%23fbfaf9&clientId=uc9135780-ac3d-4&from=paste&height=255&id=uc7eaf023&originHeight=319&originWidth=357&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=56709&status=done&style=none&taskId=u8e460c2b-84b7-458e-8da8-d7cc2244fd0&title=&width=285.6" alt="image.png"></p><p>YAML 是 “YAML Ain’t a Markup Language”（YAML 不是一种标记语言）。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（是另一种标记语言）。</p><ul><li>设计目标，就是<strong>方便人类读写</strong></li><li><strong>层次分明</strong>，更适合做配置文件</li><li>使用.yaml或 .yml作为文件后缀</li></ul><h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h3><ul><li><strong>大小写敏感</strong></li><li>使用<strong>缩进表示层级关系，k: v，使用空格分割k,v</strong></li><li>缩进时不允许使用Tab键，只允许<strong>使用空格</strong>。换行</li><li>缩进的空格数目不重要，只要<strong>相同层级</strong>的元素<strong>左侧对齐</strong>即可</li><li><strong># 表示注释</strong>，从这个字符一直到行尾，都会被解析器忽略。</li></ul><p>支持的写法：</p><ul><li><strong>对象</strong>：<strong>键值对</strong>的集合，如：映射（map）&#x2F; 哈希（hash） &#x2F; 字典（dictionary）</li><li><strong>数组</strong>：一组按次序排列的值，如：序列（sequence） &#x2F; 列表（list）</li><li><strong>纯量</strong>：单个的、不可再分的值，如：字符串、数字、bool、日期</li></ul><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><div class="code-wrapper"><pre><code class="hljs html">@Component@ConfigurationProperties(prefix = &quot;person&quot;) //和配置文件person前缀的所有配置进行绑定，//ConfigurationProperties注解可以将配置文件中的属性映射到一个Java Bean中。@Data //自动生成JavaBean属性的getter/setter//@NoArgsConstructor //自动生成无参构造器//@AllArgsConstructor //自动生成全参构造器public class Person &#123;    private String name;    private Integer age;    private Date birthDay;    private Boolean like;    private Child child; //嵌套对象    private List<span class="hljs-tag">&lt;<span class="hljs-name">Dog</span>&gt;</span> dogs; //数组（里面是对象）    private Map&lt;String,Cat&gt; cats; //表示Map&#125;@Datapublic class Dog &#123;    private String name;    private Integer age;&#125;@Datapublic class Child &#123;    private String name;    private Integer age;    private Date birthDay;    private List<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span> text; //数组&#125;@Datapublic class Cat &#123;    private String name;    private Integer age;&#125;</code></pre></div><p>properties表示法</p><div class="code-wrapper"><pre><code class="hljs routeros">person.<span class="hljs-attribute">name</span>=张三person.<span class="hljs-attribute">age</span>=18person.<span class="hljs-attribute">birthDay</span>=2010/10/12 12:12:12person.<span class="hljs-attribute">like</span>=<span class="hljs-literal">true</span>person.child.<span class="hljs-attribute">name</span>=李四person.child.<span class="hljs-attribute">age</span>=12person.child.<span class="hljs-attribute">birthDay</span>=2018/10/12person.child.text[0]=abcperson.child.text[1]=defperson.dogs[0].<span class="hljs-attribute">name</span>=小黑person.dogs[0].<span class="hljs-attribute">age</span>=3person.dogs[1].<span class="hljs-attribute">name</span>=小白person.dogs[1].<span class="hljs-attribute">age</span>=2person.cats.c1.<span class="hljs-attribute">name</span>=小蓝person.cats.c1.<span class="hljs-attribute">age</span>=3person.cats.c2.<span class="hljs-attribute">name</span>=小灰person.cats.c2.<span class="hljs-attribute">age</span>=2</code></pre></div><p>yaml表示法：注意数组的写法：text和dogs两种写法，cat是map的写法。</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">person:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">张三</span>  <span class="hljs-attr">age:</span> <span class="hljs-number">18</span>  <span class="hljs-attr">birthDay:</span> <span class="hljs-number">2010</span><span class="hljs-string">/10/10</span> <span class="hljs-number">12</span><span class="hljs-string">:12:12</span>  <span class="hljs-attr">like:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">child:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">李四</span>    <span class="hljs-attr">age:</span> <span class="hljs-number">20</span>    <span class="hljs-attr">birthDay:</span> <span class="hljs-number">2018</span><span class="hljs-string">/10/10</span>    <span class="hljs-attr">text:</span> [<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;def&quot;</span>]<span class="hljs-comment">#数组的2中写法，可以是text形式还可以是dogs的形式（每一个元素用一个-表示，下面的age是一个元素里</span><span class="hljs-comment">#面的内容，要同级并没有-表示。</span>  <span class="hljs-attr">dogs:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">小黑</span>      <span class="hljs-attr">age:</span> <span class="hljs-number">3</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">小白</span>      <span class="hljs-attr">age:</span> <span class="hljs-number">2</span>  <span class="hljs-attr">cats:</span>    <span class="hljs-attr">c1:</span>      <span class="hljs-attr">name:</span> <span class="hljs-string">小蓝</span>      <span class="hljs-attr">age:</span> <span class="hljs-number">3</span>    <span class="hljs-attr">c2:</span> &#123;<span class="hljs-attr">name:</span> <span class="hljs-string">小绿</span>,<span class="hljs-attr">age:</span> <span class="hljs-number">2</span>&#125; <span class="hljs-comment">#对象也可用&#123;&#125;表示</span></code></pre></div><h3 id="3-细节"><a href="#3-细节" class="headerlink" title="3. 细节"></a>3. 细节</h3><ul><li>birthDay 推荐写为 birth-day,@ConfigurationProperties(prefix &#x3D; “person”) &#x2F;&#x2F;和配置文件person前缀的所有配置进行绑定，</li><li><strong>文本</strong>：<ul><li><strong>单引号</strong>不会转义【\n 则为普通字符串显示】</li><li><strong>双引号</strong>会转义【\n会显示为<strong>换行符</strong>】</li></ul></li><li><strong>大文本</strong><ul><li>|开头，大文本写在下层，<strong>保留文本格式</strong>，<strong>换行符正确显示</strong></li><li><blockquote><p>开头，大文本写在下层，折叠换行符</p></blockquote></li></ul></li><li><strong>多文档合并</strong><ul><li>使用—可以把多个yaml文档合并在一个文档中，每个文档区依然认为内容独立</li></ul></li></ul><h3 id="4-小技巧：lombok"><a href="#4-小技巧：lombok" class="headerlink" title="4. 小技巧：lombok"></a>4. 小技巧：lombok</h3><p>简化JavaBean 开发。自动生成构造器、getter&#x2F;setter、自动生成Builder模式等</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>使用@Data等注解</p><h2 id="3-日志配置"><a href="#3-日志配置" class="headerlink" title="3. 日志配置"></a>3. 日志配置</h2><p>规范：项目开发不要编写System.out.println()，应该用<strong>日志</strong>记录信息<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1680232037132-d2fa8085-3847-46f2-ac62-14a6188492aa.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_29,text_5bCa56GF6LC3IGF0Z3VpZ3UuY29t,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#averageHue=%23b5c5db&from=url&id=ZTIkc&originHeight=251&originWidth=1029&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>感兴趣日志框架关系与起源可参考</strong>：<a href="https://www.bilibili.com/video/BV1gW411W76m">https://www.bilibili.com/video/BV1gW411W76m</a> 视频 21~27集</p><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><ol><li>Spring使用commons-logging作为内部日志，但底层日志实现是开放的。可对接其他日志框架。<ol><li>spring5及以后 commons-logging被spring直接自己写了。</li></ol></li><li>支持 jul，log4j2,logback。SpringBoot 提供了默认的控制台输出配置，也可以配置输出为文件。</li><li>logback是默认使用的。</li><li>虽然<strong>日志框架很多</strong>，但是我们不用担心，使用 SpringBoot 的<strong>默认配置就能工作的很好</strong>。</li></ol><p><strong>SpringBoot怎么把日志默认配置好的</strong><br>1、每个starter场景，都会导入一个核心场景spring-boot-starter<br>2、核心场景引入了日志的所用功能spring-boot-starter-logging（eg:spring-boot-starter-web-&gt;spring-boot-starter-&gt;spring-boot-starter-logging)<br>3、默认使用了logback + slf4j 组合作为默认底层日志<br>4、日志是系统一启动就要用，xxxAutoConfiguration是系统启动好了以后放好的组件，后来用的。<br>5、日志是利用<strong>监听器机制</strong>配置好的。ApplicationListener。<br>6、日志所有的配置都可以通过修改配置文件实现。以logging开始的所有配置。</p><h3 id="2-日志格式"><a href="#2-日志格式" class="headerlink" title="2. 日志格式"></a>2. 日志格式</h3><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">2023</span>-<span class="hljs-number">03</span>-<span class="hljs-number">31</span>T13:<span class="hljs-number">56</span>:<span class="hljs-number">17</span>.<span class="hljs-number">511</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span>  INFO <span class="hljs-number">4944</span> ---<span class="hljs-meta"> [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]</span><span class="hljs-attribute">2023</span>-<span class="hljs-number">03</span>-<span class="hljs-number">31</span>T13:<span class="hljs-number">56</span>:<span class="hljs-number">17</span>.<span class="hljs-number">511</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span>  INFO <span class="hljs-number">4944</span> ---<span class="hljs-meta"> [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.7]</span></code></pre></div><p>默认输出格式：</p><ul><li>时间和日期：毫秒级精度</li><li>日志级别：ERROR,WARN,INFO,DEBUG, orTRACE.</li><li>进程 ID(可以在终端使用jps列出当前java程序的进程）</li><li>—： 消息分割符</li><li>线程名： 使用[]包含</li><li>Logger 名： 通常是产生日志的<strong>类名</strong></li><li>消息： 日志记录的内容</li></ul><p>注意： logback 没有FATAL级别，对应的是ERROR<br>默认值：参照：spring-boot包additional-spring-configuration-metadata.json文件<br>默认输出格式值：%clr(%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd’T’HH:mm:ss.SSSXXX}}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(—){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}<br>可修改为：’%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level [%thread] %logger{15} &#x3D;&#x3D;&#x3D;&gt; %msg%n’</p><h3 id="3-记录日志"><a href="#3-记录日志" class="headerlink" title="3. 记录日志"></a>3. 记录日志</h3><div class="code-wrapper"><pre><code class="hljs mel">Logger logger = LoggerFactory.getLogger(getClass());<span class="hljs-comment">//使用日志工厂生成日志类</span> <span class="hljs-keyword">log</span>.info(<span class="hljs-string">&quot;info 日志..... 参数a:&#123;&#125; b:&#123;&#125;&quot;</span>,a,b);或者使用Lombok的@Slf4j注解,在该类上使用，就可以不用日志工厂生成日志类直接使用<span class="hljs-keyword">log</span></code></pre></div><h3 id="4-日志级别"><a href="#4-日志级别" class="headerlink" title="4. 日志级别"></a>4. 日志级别</h3><ul><li>由低到高：ALL,TRACE, DEBUG, INFO, WARN, ERROR,FATAL,OFF；<ul><li><strong>只会打印指定级别及以上级别的日志</strong></li><li>ALL：打印所有日志</li><li>TRACE：追踪框架详细流程日志，一般不使用</li><li>DEBUG：开发调试细节日志</li><li>INFO：关键、感兴趣信息日志</li><li>WARN：警告但不是错误的信息日志，比如：版本过时</li><li>ERROR：业务错误日志，比如出现各种异常</li><li>FATAL：致命错误日志，比如jvm系统崩溃</li><li>OFF：关闭所有日志记录</li></ul></li><li>不指定级别的所有类，都使用root指定的级别作为默认级别</li><li>SpringBoot日志<strong>默认级别是 INFO</strong></li></ul><ol><li>在application.properties&#x2F;yaml中配置logging.level.<logger-name>&#x3D;<level>指定日志级别</li><li>level可取值范围：TRACE, DEBUG, INFO, WARN, ERROR, FATAL, or OFF，定义在 LogLevel类中</li><li>root 的logger-name叫root，可以配置logging.level.root&#x3D;warn，代表所有未指定日志级别都使用 root 的 warn 级别</li></ol><h3 id="5-日志分组"><a href="#5-日志分组" class="headerlink" title="5. 日志分组"></a>5. 日志分组</h3><p>比较有用的技巧是：<br>将相关的logger分组在一起，统一配置。SpringBoot 也支持。比如：Tomcat 相关的日志统一设置</p><div class="code-wrapper"><pre><code class="hljs stylus">logging<span class="hljs-selector-class">.group</span>.tomcat=org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.catalina</span>,org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.coyote</span>,org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.tomcat</span><span class="hljs-comment">//这里是将org.apache.catalina,org.apache.coyote,org.apache.tomcat2个包当成一个组为tomcat</span>logging<span class="hljs-selector-class">.level</span>.tomcat=trace<span class="hljs-comment">//这里是将tomcat组的日志级别设置为trace级别</span></code></pre></div><p>SpringBoot 预定义两个组</p><table><thead><tr><th>Name</th><th>Loggers</th></tr></thead><tbody><tr><td>web</td><td>org.springframework.core.codec,org.springframework.http,org.springframework.web,org.springframework.boot.actuate.endpoint.web,org.springframework.boot.web.servlet.ServletContextInitializerBeans</td></tr><tr><td>sql</td><td>org.springframework.jdbc.core,org.hibernate.SQL,org.jooq.tools.LoggerListener</td></tr></tbody></table><h3 id="6-文件输出"><a href="#6-文件输出" class="headerlink" title="6. 文件输出"></a>6. 文件输出</h3><div class="code-wrapper"><pre><code class="hljs fortran"> #指定文件路径路径，日志文件默认叫spring.<span class="hljs-built_in">log</span>#logging.<span class="hljs-keyword">file</span>.path=D:\\#指定日志文件的名，只写名字就在当前项目的同位置生成相对应的日志文件。#也可以写名字+路径，就会在指定的路径下生成相应的日志文件然后把日志写进去logging.<span class="hljs-keyword">file</span>.<span class="hljs-keyword">name</span> #<span class="hljs-keyword">file</span>.<span class="hljs-keyword">name</span>和<span class="hljs-keyword">file</span>.path同时存在,只有<span class="hljs-keyword">file</span>.<span class="hljs-keyword">name</span>生效</code></pre></div><p>SpringBoot 默认只把日志写在控制台，如果想额外记录到文件，可以在application.properties中添加logging.file.name or logging.file.path配置项。</p><table><thead><tr><th>logging.file.name</th><th>logging.file.path</th><th>示例</th><th>效果</th></tr></thead><tbody><tr><td>未指定</td><td>未指定</td><td></td><td>仅控制台输出</td></tr><tr><td><strong>指定</strong></td><td>未指定</td><td>my.log</td><td>写入指定文件。可以加路径</td></tr><tr><td>未指定</td><td><strong>指定</strong></td><td>&#x2F;var&#x2F;log</td><td>写入指定目录，文件名为spring.log</td></tr><tr><td><strong>指定</strong></td><td><strong>指定</strong></td><td></td><td>以logging.file.name为准</td></tr></tbody></table><h3 id="7-文件归档与滚动切割"><a href="#7-文件归档与滚动切割" class="headerlink" title="7. 文件归档与滚动切割"></a>7. 文件归档与滚动切割</h3><p>归档：每天的日志单独存到一个文档中。<br>切割：每个文件10MB，超过大小切割成另外一个文件。</p><ol><li>每天的日志应该独立分割出来存档。如果使用logback（SpringBoot 默认整合），可以通过application.properties&#x2F;yaml文件指定日志滚动规则。</li><li>如果是其他日志系统，需要自行配置（添加log4j2.xml或log4j2-spring.xml）</li><li>不用特意配置日志，会使用默认的日志</li><li>支持的滚动规则设置如下<table><thead><tr><th>配置项</th><th>描述</th></tr></thead><tbody><tr><td>logging.logback.rollingpolicy.file-name-pattern</td><td>日志存档的文件名（类似每天产生的日志单独生成在一个文件中） 格式（默认值：${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz）</td></tr><tr><td>logging.logback.rollingpolicy.clean-history-on-start</td><td>应用启动时是否清除以前存档（默认值：false）</td></tr><tr><td>logging.logback.rollingpolicy.max-file-size</td><td>存档前，每个日志文件的最大大小（默认值：10MB）</td></tr><tr><td>logging.logback.rollingpolicy.total-size-cap</td><td>日志文件被删除之前，可以容纳的最大大小（默认值：0B）。设置1GB则磁盘存储超过 1GB 日志后就会删除旧日志文件</td></tr><tr><td>logging.logback.rollingpolicy.max-history</td><td>日志文件保存的最大天数(默认值：7).</td></tr></tbody></table></li></ol><h3 id="8-自定义配置"><a href="#8-自定义配置" class="headerlink" title="8. 自定义配置"></a>8. 自定义配置</h3><p>通常我们配置 application.properties 就够了。当然也可以自定义。比如：</p><table><thead><tr><th>日志系统</th><th>自定义</th></tr></thead><tbody><tr><td>Logback</td><td>logback-spring.xml,logback-spring.groovy,</td></tr><tr><td>logback.xml, or logback.groovy</td><td></td></tr><tr><td>Log4j2</td><td>log4j2-spring.xmlorlog4j2.xml</td></tr><tr><td>JDK (Java Util Logging)</td><td>logging.properties</td></tr></tbody></table><p>如果可能，我们建议您在日志配置中使用-spring 变量（例如，logback-spring.xml 而不是 logback.xml）。如果您使用标准配置文件，spring 无法完全控制日志初始化。<br>最佳实战：自己要写配置，配置文件名加上 xx-spring.xml</p><h3 id="9-切换日志组合"><a href="#9-切换日志组合" class="headerlink" title="9. 切换日志组合"></a>9. 切换日志组合</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>log4j2支持yaml和json格式的配置文件</p><table><thead><tr><th>格式</th><th>依赖</th><th>文件名</th></tr></thead><tbody><tr><td>YAML</td><td>com.fasterxml.jackson.core:jackson-databind+com.fasterxml.jackson.dataformat:jackson-dataformat-yaml</td><td>log4j2.yaml+log4j2.yml</td></tr><tr><td>JSON</td><td>com.fasterxml.jackson.core:jackson-databind</td><td>log4j2.json+log4j2.jsn</td></tr></tbody></table><h3 id="10-最佳实战"><a href="#10-最佳实战" class="headerlink" title="10. 最佳实战"></a>10. 最佳实战</h3><ol><li>导入任何第三方框架，先排除它的日志包，因为Boot底层控制好了日志</li><li>修改 application.properties 配置文件，就可以调整日志的所有行为。如果不够，可以编写日志框架自己的配置文件放在类路径下就行，比如logback-spring.xml，log4j2-spring.xml</li><li>如需对接<strong>专业日志系统</strong>，也只需要把 logback 记录的<strong>日志</strong>灌倒** kafka<strong>之类的中间件，这和SpringBoot没关系，都是日志框架自己的配置，</strong>修改配置文件即可**</li><li><strong>业务中使用slf4j-api记录日志。不要再 sout 了</strong></li></ol><h1 id="2、SpringBoot3-Web开发"><a href="#2、SpringBoot3-Web开发" class="headerlink" title="2、SpringBoot3-Web开发"></a>2、SpringBoot3-Web开发</h1><p>SpringBoot的Web开发能力，由<strong>SpringMVC</strong>提供。</p><h2 id="1-Web场景"><a href="#1-Web场景" class="headerlink" title="1. Web场景"></a>1. Web场景</h2><p>1、整合web场景</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>2、引入了 autoconfigure功能（是spring-boot-starter-web下的spring-boot-starter里面的一个依赖）<br>3、springboot起点的时候会加载一个@EnableAutoConfiguration注解（@SpringBootApplication注解里被@EnableAutoConfiguration注解修饰）。@EnableAutoConfiguration注解使用@Import(AutoConfigurationImportSelector.class)批量导入组件，加载 META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports 文件中配置的所有组件<br>5、所有自动配置类如下</p><div class="code-wrapper"><pre><code class="hljs abnf">org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfigurationorg.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>以下是响应式web场景和现在的没关系<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.ReactiveMultipartAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.WebSessionIdResolverAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>以上没关系<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration</code></pre></div><p>6、绑定了配置文件的一堆配置项</p><ul><li>1、SpringMVC的所有配置 spring.mvc</li><li>2、Web场景通用配置 spring.web</li><li>3、文件上传配置 spring.servlet.multipart</li><li>4、服务器的配置 server: 比如：编码方式</li></ul><h2 id="2-默认效果"><a href="#2-默认效果" class="headerlink" title="2. 默认效果"></a>2. 默认效果</h2><p>默认配置：</p><ol><li>包含了 ContentNegotiatingViewResolver 和 BeanNameViewResolver 组件，<strong>方便视图解析</strong></li><li><strong>默认的静态资源处理机制</strong>： 静态资源放在 static 文件夹下即可直接访问</li><li><strong>自动注册</strong>了 <strong>Converter</strong>,GenericConverter,<strong>Formatter</strong>组件，适配常见<strong>数据类型转换</strong>和<strong>格式化需求</strong></li><li><strong>支持 HttpMessageConverters</strong>，可以<strong>方便返回</strong>json等<strong>数据类型（比如：</strong>@RestController 注解会自动将处理方法的返回值序列化为 JSON式的响应体，并将其发送给客户端。）</li><li><strong>注册 <strong>MessageCodesResolver，方便</strong>国际化</strong>及错误消息处理</li><li><strong>支持 静态</strong>index.html</li><li><strong>自动使用</strong>ConfigurableWebBindingInitializer，实现消息处理、数据绑定（比如将前段传递过来的参数和某些bean绑定)、类型转化、数据校验等功能</li></ol><p><strong>重要：</strong></p><ul><li><em>如果想保持 <em><strong><em>boot mvc 的默认配置</em></strong><em>，并且自定义更多的 mvc 配置，如：</em><strong><em>interceptors</em></strong></em>, <em><strong><em>formatters</em></strong></em>, <em><strong><em>view controllers</em></strong></em> 等。可以使用@Configuration注解添加一个 WebMvcConfigurer 类型的配置类，并不要标注 @EnableWebMvc</em></li><li><em>如果想保持 boot mvc 的默认配置，但要自定义核心组件实例，比如：RequestMappingHandlerMapping, RequestMappingHandlerAdapter, 或ExceptionHandlerExceptionResolver，给容器中放一个 WebMvcRegistrations 组件即可</em></li><li><em>如果想全面接管 Spring MVC，@Configuration 标注一个配置类，并加上 @EnableWebMvc注解，</em></li><li><em>实现 WebMvcConfigurer 接口</em></li></ul><h2 id="WebMvcAutoConfiguration原理"><a href="#WebMvcAutoConfiguration原理" class="headerlink" title="WebMvcAutoConfiguration原理"></a>WebMvcAutoConfiguration原理</h2><p>WebMvcAutoConfiguration 是 Spring Boot 中的一个自动配置类，它负责自动配置 Spring MVC（Model-View-Controller）的相关功能。<br>在 Spring Boot 应用程序中，当您引入了 spring-boot-starter-web  依赖时，WebMvcAutoConfiguration 将自动生效。它会根据应用程序的类路径和配置属性来自动配置 Spring MVC。它是@EnableAutoConfiguration注解使用@Import(AutoConfigurationImportSelector.class)批量导入组件中的一个组件。 </p><h3 id="1-生效条件"><a href="#1-生效条件" class="headerlink" title="1. 生效条件"></a>1. 生效条件</h3><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@AutoConfiguration</span>(after = &#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,ValidationAutoConfiguration.class &#125;) <span class="hljs-comment">//在这些自动配置之后,</span><span class="hljs-variable">@ConditionalOnWebApplication</span>(type = Type.SERVLET) <span class="hljs-comment">//如果是web应用就生效，类型是SERVLETweb，其他还有、REACTIVE 响应式web</span><span class="hljs-variable">@ConditionalOnClass</span>(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)<span class="hljs-variable">@ConditionalOnMissingBean</span>(WebMvcConfigurationSupport.class) <span class="hljs-comment">//容器中没有这个Bean，才生效。默认就是没有</span><span class="hljs-variable">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE + <span class="hljs-number">10</span>)<span class="hljs-comment">//优先级</span><span class="hljs-variable">@ImportRuntimeHints</span>(WebResourcesRuntimeHints.class)public class WebMvcAutoConfiguration &#123; &#125;</code></pre></div><h3 id="2-WebMvcAutoConfiguration产生的效果"><a href="#2-WebMvcAutoConfiguration产生的效果" class="headerlink" title="2. WebMvcAutoConfiguration产生的效果"></a>2. WebMvcAutoConfiguration产生的效果</h3><ol><li>放了两个Filter：<ol><li><p>HiddenHttpMethodFilter；页面表单提交Rest请求（GET、POST、PUT、DELETE）<a href="https://blog.csdn.net/geloin/article/details/7444321">Spring MVC过滤器-HiddenHttpMethodFilter_Korbin Luo的博客-CSDN博客</a></p><div class="code-wrapper"><pre><code class="hljs typescript">某些场景下，例如 <span class="hljs-variable constant_">HTML</span> 表单只支持 <span class="hljs-variable constant_">GET</span> 和 <span class="hljs-variable constant_">POST</span> 方法，无法直接发送 <span class="hljs-variable constant_">PUT</span> 或 <span class="hljs-variable constant_">DELETE</span> 请求。为了解决这个问题，<span class="hljs-title class_">Spring</span> <span class="hljs-title class_">Framework</span> 提供了 <span class="hljs-title class_">HiddenHttpMethodFilter</span> 过滤器。<span class="hljs-title class_">HiddenHttpMethodFilter</span> 允许您在 <span class="hljs-variable constant_">HTML</span> 表单中使用一个隐藏字段（通常命名为 <span class="hljs-string">&quot;_method&quot;</span>）来指定要使用的 <span class="hljs-variable constant_">HTTP</span> 方法，例如 <span class="hljs-variable constant_">PUT</span> 或 <span class="hljs-variable constant_">DELETE</span>。当表单提交时，过滤器会检查隐藏字段的值，并将请求方法转换为相应的 <span class="hljs-variable constant_">HTTP</span> 方法。&lt;form action=<span class="hljs-string">&quot;/example&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;_method&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;put&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-comment">&lt;!-- 其他表单字段 --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>在上面的示例中，隐藏字段 _method 的值被设置为 <span class="hljs-string">&quot;put&quot;</span>，表示要使用 <span class="hljs-variable constant_">PUT</span> 方法进行请求。在您的控制器方法中，使用 <span class="hljs-meta">@RequestMapping</span> 注解或其他合适的注解来处理相应的请求方法。<span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">&quot;/example&quot;</span>, method = <span class="hljs-title class_">RequestMethod</span>.<span class="hljs-property">PUT</span>)<span class="hljs-keyword">public</span> <span class="hljs-title class_">ResponseEntity</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">updateExample</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 处理 PUT 请求</span>&#125;</code></pre></div></li><li><p>FormContentFilter： 表单内容Filter，GET（数据放URL后面）、POST（数据放请求体）请求可以携带数据，PUT、DELETE 的请求体数据会被忽略.为了让put和delete的请求体内容不会被忽略，可以加一个FormContentFilter。</p></li></ol></li><li>给容器中放了WebMvcConfigurer组件（WebMvcAutoConfigurationAdapter）；给SpringMVC添加各种定制功能<div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span>(proxyBeanMethods = false)<span class="hljs-variable">@Import</span>(EnableWebMvcConfiguration.class) <span class="hljs-comment">//额外导入了其他配置</span><span class="hljs-variable">@EnableConfigurationProperties</span>(&#123; WebMvcProperties.class, WebProperties.class &#125;)<span class="hljs-variable">@Order</span>(<span class="hljs-number">0</span>)public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer, ServletContextAware&#123;            &#125;</code></pre></div><ol><li>所有的功能最终会和配置文件进行绑定</li><li>WebMvcProperties： spring.mvc配置文件</li><li>WebProperties： spring.web配置文件</li></ol></li></ol><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@ConfigurationProperties</span>(prefix = <span class="hljs-string">&quot;spring.mvc&quot;</span>)<span class="hljs-comment">//@ConfigurationProperties 注解的 prefix 属性被设置为 &quot;spring.mvc&quot;，表示要绑定以</span><span class="hljs-string">&quot;spring.mvc&quot;</span> 开头的配置属性。使用 <span class="hljs-variable">@ConfigurationProperties</span> 注解可以将配置文件中的属性值与 Java 类中的字段或方法关联起来，从而方便地获取、设置和管理配置属性。</code></pre></div><h3 id="WebMvcConfigurer接口"><a href="#WebMvcConfigurer接口" class="headerlink" title="WebMvcConfigurer接口"></a>WebMvcConfigurer接口</h3><p>WebMvcAutoConfiguration中的WebMvcAutoConfigurationAdapter属性实现了该接口。<br>提供了配置SpringMVC底层的所有组件入口<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681093891854-26205c88-4c20-4b63-a2c3-02574778072f.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_36,text_5bCa56GF6LC3IGF0Z3VpZ3UuY29t,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#averageHue=%23faf8f6&from=url&id=zLAUH&originHeight=497&originWidth=1267&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="2-静态资源"><a href="#2-静态资源" class="headerlink" title="2. 静态资源"></a>2. 静态资源</h3><h4 id="1-默认规则"><a href="#1-默认规则" class="headerlink" title="1. 默认规则"></a>1. 默认规则</h4><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> void addResourceHandlers(ResourceHandlerRegistry registry) &#123;    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.resourceProperties.isAddMappings()) &#123;        logger.debug(<span class="hljs-string">&quot;Default resource handling disabled&quot;</span>);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">//1、</span>    addResourceHandler(registry, <span class="hljs-keyword">this</span>.mvcProperties.getWebjarsPathPattern(),            <span class="hljs-string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);    addResourceHandler(registry, <span class="hljs-keyword">this</span>.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;        registration.addResourceLocations(<span class="hljs-keyword">this</span>.resourceProperties.getStaticLocations());        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.servletContext != <span class="hljs-literal">null</span>) &#123;            ServletContextResource resource = new ServletContextResource(<span class="hljs-keyword">this</span>.servletContext, SERVLET_LOCATION);            registration.addResourceLocations(resource);        &#125;    &#125;);&#125;<span class="hljs-comment">//</span></code></pre></div><ol><li>规则一：访问： &#x2F;webjars&#x2F;**路径就去 classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;下找资源.<div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">/webjars/</span> 是一个特定的路径前缀，用于在Web应用程序中访问 WebJars 资源。WebJars 是一种将前端库以 JAR 文件的形式打包并发布到 Maven 仓库的方式。它们允许您通过 Maven 或 Gradle 等构建工具来管理和引入前端库，就像管理其他 Java 依赖项一样。当您在 Maven 项目中引入 WebJars 依赖时，它们将被下载并存储在您的项目的 Maven 依赖目录中。为了在 Web 应用程序中有效地访问这些资源，Spring Boot 提供了一个特殊的处理器来映射 <span class="hljs-regexp">/webjars/</span>路径。</code></pre></div><ol><li>maven 导入依赖</li></ol></li><li>规则二：访问： &#x2F;**路径就去 静态资源默认的四个位置找资源<ol><li>classpath:&#x2F;META-INF&#x2F;resources&#x2F;</li><li>classpath:&#x2F;resources&#x2F;</li><li>classpath:&#x2F;static&#x2F;</li><li>classpath:&#x2F;public&#x2F;</li></ol></li><li>规则三：<strong>静态资源默认都有缓存规则的设置</strong><ol><li>所有缓存的设置，直接通过<strong>配置文件</strong>： spring.web</li><li>cachePeriod： 缓存周期； 多久不用找服务器要新的。 默认没有，以s为单位</li><li>cacheControl： <strong>HTTP缓存</strong>控制；<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching#%E6%A6%82%E8%A7%88">https://develop er.mozilla.org/zh-CN/docs/Web/HTTP/Caching</a></li><li><strong>useLastModified</strong>：是否使用最后一次修改。配合HTTP Cache规则</li></ol></li></ol><p>如果浏览器访问了一个静态资源 index.js，如果服务这个资源没有发生变化，下次访问的时候就可以直接让浏览器用自己缓存中的东西，而不用给服务器发请求</p><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">registration</span><span class="hljs-selector-class">.setCachePeriod</span>(<span class="hljs-built_in">getSeconds</span>(this.resourceProperties.<span class="hljs-built_in">getCache</span>().<span class="hljs-built_in">getPeriod</span>()));<span class="hljs-selector-tag">registration</span><span class="hljs-selector-class">.setCacheControl</span>(this.resourceProperties.<span class="hljs-built_in">getCache</span>().<span class="hljs-built_in">getCachecontrol</span>().<span class="hljs-built_in">toHttpCacheControl</span>());<span class="hljs-selector-tag">registration</span><span class="hljs-selector-class">.setUseLastModified</span>(this.resourceProperties.<span class="hljs-built_in">getCache</span>().<span class="hljs-built_in">isUseLastModified</span>());</code></pre></div><h4 id="1-静态资源映射"><a href="#1-静态资源映射" class="headerlink" title="1. 静态资源映射"></a>1. 静态资源映射</h4><p>静态资源映射规则在WebMvcAutoConfiguration中进行了定义：</p><ol><li>&#x2F;webjars&#x2F;**的所有路径 资源都在classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;</li><li>&#x2F;**的所有路径 资源都在classpath:&#x2F;META-INF&#x2F;resources&#x2F;、classpath:&#x2F;resources&#x2F;、classpath:&#x2F;static&#x2F;、classpath:&#x2F;public&#x2F;</li><li>所有静态资源都定义了缓存规则。【浏览器访问过一次，就会缓存一段时间】，但此功能参数无默认值<ol><li>period： 缓存间隔。 默认 0S；</li><li>cacheControl：缓存控制。 默认无；</li><li>useLastModified：是否使用lastModified头。 默认 false；</li></ol></li></ol><h4 id="2-静态资源缓存"><a href="#2-静态资源缓存" class="headerlink" title="2. 静态资源缓存"></a>2. 静态资源缓存</h4><p>如前面所述</p><ol><li>所有静态资源都定义了缓存规则。【浏览器访问过一次，就会缓存一段时间】，但此功能参数无默认值<ol><li>period： 缓存间隔。 默认 0S；</li><li>cacheControl：缓存控制。 默认无；</li><li>useLastModified：是否使用lastModified头。 默认 false；</li></ol></li></ol><h4 id="3-欢迎页"><a href="#3-欢迎页" class="headerlink" title="3. 欢迎页"></a>3. 欢迎页</h4><p>欢迎页规则在WebMvcAutoConfiguration中进行了定义：</p><ol><li>在<strong>静态资源</strong>目录下找 index.html</li><li>没有就在 templates下找index模板页</li></ol><h4 id="4-Favicon"><a href="#4-Favicon" class="headerlink" title="4. Favicon"></a>4. Favicon</h4><ol><li>在静态资源目录下找 favicon.ico</li></ol><h4 id="5-缓存实验"><a href="#5-缓存实验" class="headerlink" title="5. 缓存实验"></a>5. 缓存实验</h4><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">9000</span><span class="hljs-comment"></span><span class="hljs-comment">#1、spring.web：</span><span class="hljs-comment"># 1.配置国际化的区域信息</span><span class="hljs-comment"># 2.静态资源策略(开启、处理链、缓存)</span><span class="hljs-comment"></span><span class="hljs-comment">#开启静态资源映射规则</span><span class="hljs-attr">spring.web.resources.add-mappings</span>=<span class="hljs-string">true</span><span class="hljs-comment"></span><span class="hljs-comment">#设置缓存</span><span class="hljs-comment">#spring.web.resources.cache.period=3600</span><span class="hljs-comment">##缓存详细合并项控制，覆盖period配置：</span><span class="hljs-comment">## 浏览器第一次请求服务器，服务器告诉浏览器此资源缓存7200秒，7200秒以内的所有此资源访问</span><span class="hljs-comment">#不用发给服务器请求，7200秒以后发请求给服务器</span><span class="hljs-attr">spring.web.resources.cache.cachecontrol.max-age</span>=<span class="hljs-string">7200</span><span class="hljs-comment">#使用资源 last-modified 时间，来对比服务器和浏览器的资源是否相同没有变化。相同返回 304,默认开启</span><span class="hljs-attr">spring.web.resources.cache.use-last-modified</span>=<span class="hljs-string">true</span></code></pre></div><h3 id="2-自定义静态资源规则"><a href="#2-自定义静态资源规则" class="headerlink" title="2. 自定义静态资源规则"></a>2. 自定义静态资源规则</h3><p>自定义静态资源路径、自定义缓存规则</p><h4 id="1-配置方式"><a href="#1-配置方式" class="headerlink" title="1. 配置方式"></a>1. 配置方式</h4><p>spring.mvc： 静态资源访问前缀路径<br>spring.web：</p><ul><li>静态资源目录</li><li>静态资源缓存策略</li></ul><h4 id="2-代码方式"><a href="#2-代码方式" class="headerlink" title="2. 代码方式"></a>2. 代码方式</h4><ul><li>容器中只要有一个 WebMvcConfigurer 组件。配置的底层行为都会生效</li><li>@EnableWebMvc &#x2F;&#x2F;禁用boot的默认配置</li></ul><h3 id="5-EnableWebMvcConfiguration-源码"><a href="#5-EnableWebMvcConfiguration-源码" class="headerlink" title="5. EnableWebMvcConfiguration 源码"></a>5. EnableWebMvcConfiguration 源码</h3><p>也是WebMvcAutoConfiguration的内部类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//SpringBoot 给容器中放 WebMvcConfigurationSupport 组件。</span><span class="hljs-comment">//我们如果自己放了 WebMvcConfigurationSupport 组件，Boot的WebMvcAutoConfiguration都会失效。</span><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><span class="hljs-meta">@EnableConfigurationProperties(WebProperties.class)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnableWebMvcConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DelegatingWebMvcConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ResourceLoaderAware</span> &#123;    &#125;</code></pre></div><ol><li>HandlerMapping： 根据请求路径  找那个handler能处理请求</li></ol><p><a href="https://www.jianshu.com/p/f04816ee2495">SpringMVC工作原理之处理映射[HandlerMapping]</a><br> SpringMVC 内部是根据 HandlerMapping 将 Request 和 Controller 里面的方法对应起来的  </p><ol><li>WelcomePageHandlerMapping(webmvcAutoConfiguration里面注入所依赖的bean)： <ol><li>访问 &#x2F;**路径下的所有请求，都在以前四个静态资源路径下找，欢迎页也一样</li><li>找index.html：只要静态资源的位置有一个 index.html页面，项目启动默认访问（意思是如果静态资源里面有index.html，那么项目启动也就是根路径默认跳转到index.html）</li></ol></li></ol><h4 id="Favicon：网站图标"><a href="#Favicon：网站图标" class="headerlink" title="Favicon：网站图标"></a>Favicon：网站图标</h4><ol><li>在静态资源目录下找 favicon.ico</li></ol><p>理解：springboot启动成功后会在静态资源文件中寻找favicon.ico文件，如果存在这个文件就把网站的图标设置为这个，当然这里的favicon.ico文件名要正确。如果删除了favicon.ico文件，但是浏览器的图标仍然存在，那是因为浏览器的缓存机制缓存了该图标。</p><h4 id="5-缓存实验-1"><a href="#5-缓存实验-1" class="headerlink" title="5. 缓存实验"></a>5. 缓存实验</h4><p>1.跟缓存有关的配置是spring.web前缀的配置属性 。<br>2.</p><div class="code-wrapper"><pre><code class="hljs d"><span class="hljs-keyword">@ConfigurationProperties</span> 是一个 Spring Boot 注解，用于将配置属性绑定到 Java 类的字段上。在 Spring Boot 应用程序中，配置属性通常存储在配置文件（如 application.properties 或 application.yml）中。<span class="hljs-keyword">@ConfigurationProperties</span> 注解可以使用在一个类上，用于将配置文件中的属性值绑定到该类的字段上，实现属性的自动注入。<span class="hljs-keyword">@ConfigurationProperties</span>(<span class="hljs-string">&quot;spring.web&quot;</span>)是将以 <span class="hljs-string">&quot;spring.web&quot;</span> 为前缀的配置属性绑定到 Java 类的字段上。使用 <span class="hljs-keyword">@ConfigurationProperties</span> 需要进行以下步骤：创建一个普通的 Java 类，该类的字段将用于存储配置属性的值。在该类上添加 <span class="hljs-keyword">@ConfigurationProperties</span> 注解，并指定要绑定的配置属性的前缀。<span class="hljs-keyword">@Configuration</span><span class="hljs-keyword">@ConfigurationProperties</span>(prefix = <span class="hljs-string">&quot;myapp&quot;</span>)<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> MyAppProperties &#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String <span class="hljs-keyword">version</span>;    <span class="hljs-comment">// 其他属性及对应的 getter 和 setter 方法</span>&#125;在上述示例中，MyAppProperties 类使用 <span class="hljs-keyword">@ConfigurationProperties</span> 注解，并指定了 prefix 属性为<span class="hljs-string">&quot;myapp&quot;</span>。这意味着该类的字段将与以 <span class="hljs-string">&quot;myapp&quot;</span> 为前缀的配置属性进行绑定。假设在配置文件中有以下属性：myapp.name=My Appmyapp.<span class="hljs-keyword">version</span>=<span class="hljs-number">1.0</span><span class="hljs-number">.0</span>通过使用 <span class="hljs-keyword">@ConfigurationProperties</span> 注解，可以将 <span class="hljs-string">&quot;My App&quot;</span> 绑定到 name 字段上，将 <span class="hljs-string">&quot;1.0.0&quot;</span> 绑定到 <span class="hljs-keyword">version</span> 字段上。</code></pre></div><p>3.spring.web可以配置国际化的区域信息，配置静态资源策略（开启，处理链，缓存），</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">server.port</span>=<span class="hljs-number">9000</span><span class="hljs-comment">#1、spring.web：</span><span class="hljs-comment"># 1.配置国际化的区域信息</span><span class="hljs-comment"># 2.静态资源策略(开启、处理链、缓存)</span><span class="hljs-comment">#开启静态资源映射规则，默认结果为true,spring.web.resources.add-mappings和Resources类</span><span class="hljs-comment">#的addMappings属性对应。</span><span class="hljs-attr">spring.web.resources.add-mappings</span>=<span class="hljs-literal">true</span><span class="hljs-comment">#设置缓存,设置了缓存时间为3600s</span><span class="hljs-comment">#spring.web.resources.cache.period=3600</span><span class="hljs-comment">##缓存详细合并项控制，覆盖period配置：</span><span class="hljs-comment">## 浏览器第一次请求服务器，服务器告诉浏览器此资源缓存7200秒，7200秒以内的所有此资源访问不用发给服务器请求，7200秒以后发请求给服务器</span><span class="hljs-attr">spring.web.resources.cache.cachecontrol.max-age</span>=<span class="hljs-number">7200</span><span class="hljs-comment">#使用资源 last-modified 时间，来对比服务器和浏览器的资源是否相同没有变化。相同返回 304</span><span class="hljs-attr">spring.web.resources.cache.use-last-modified</span>=<span class="hljs-literal">true</span></code></pre></div><h2 id="2-自定义静态资源规则-1"><a href="#2-自定义静态资源规则-1" class="headerlink" title="2. 自定义静态资源规则"></a>2. 自定义静态资源规则</h2><p>自定义静态资源路径、自定义缓存规则</p><h3 id="1-配置方式-1"><a href="#1-配置方式-1" class="headerlink" title="1. 配置方式"></a>1. 配置方式</h3><p>spring.mvc： 静态资源访问前缀路径<br>spring.web：</p><ul><li>静态资源目录</li><li>静态资源缓存策略<div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#1、spring.web：</span><span class="hljs-comment"># 1.配置国际化的区域信息</span><span class="hljs-comment"># 2.静态资源策略(开启、处理链、缓存)</span><span class="hljs-comment"></span><span class="hljs-comment">#开启静态资源映射规则</span><span class="hljs-attr">spring.web.resources.add-mappings</span>=<span class="hljs-string">true</span><span class="hljs-comment"></span><span class="hljs-comment">#设置缓存</span><span class="hljs-attr">spring.web.resources.cache.period</span>=<span class="hljs-string">3600</span><span class="hljs-comment">##缓存详细合并项控制，覆盖period配置：</span><span class="hljs-comment">## 浏览器第一次请求服务器，服务器告诉浏览器此资源缓存7200秒，7200秒以内的所有此资源访问不用发给服务器请求，7200秒以后发请求给服务器</span><span class="hljs-attr">spring.web.resources.cache.cachecontrol.max-age</span>=<span class="hljs-string">7200</span><span class="hljs-comment">## 共享缓存，只要是这个客户端其他用户都可以使用这个缓存</span><span class="hljs-attr">spring.web.resources.cache.cachecontrol.cache-public</span>=<span class="hljs-string">true</span><span class="hljs-comment">#使用资源 last-modified 时间，来对比服务器和浏览器的资源是否相同没有变化。相同返回 304</span><span class="hljs-attr">spring.web.resources.cache.use-last-modified</span>=<span class="hljs-string">true</span><span class="hljs-comment"></span><span class="hljs-comment">#自定义静态资源文件夹位置</span><span class="hljs-attr">spring.web.resources.static-locations</span>=<span class="hljs-string">classpath:/a/,classpath:/b/,classpath:/static/</span><span class="hljs-comment"></span><span class="hljs-comment">#2、 spring.mvc</span><span class="hljs-comment">## 2.1. 自定义webjars路径前缀,以后访问/wj/**路径的时候会在/wedjars/**路径下寻找 </span><span class="hljs-attr">spring.mvc.webjars-path-pattern</span>=<span class="hljs-string">/wj/**</span><span class="hljs-comment">## 2.2. 静态资源访问路径前缀常和spring.web.resources.static-locations联合使用</span><span class="hljs-attr">spring.mvc.static-path-pattern</span>=<span class="hljs-string">/static/**</span></code></pre></div></li></ul><h3 id="2-代码方式-1"><a href="#2-代码方式-1" class="headerlink" title="2. 代码方式"></a>2. 代码方式</h3><ul><li>容器中只要有一个 WebMvcConfigurer 组件。配置的底层行为都会生效</li><li>@EnableWebMvc &#x2F;&#x2F;禁用boot的默认配置<div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">//@EnableWebMvc</span> <span class="hljs-string">//禁用boot的默认配置，添加了就会禁用boot的默认配置的规则。</span><span class="hljs-attr">//，没有添加就会保留以前的规则和自己新写的规则</span><span class="hljs-attr">@Configuration</span> <span class="hljs-string">//这是一个配置类</span><span class="hljs-attr">public</span> <span class="hljs-string">class MyConfig implements WebMvcConfigurer &#123;</span>    <span class="hljs-attr">@Override</span>    <span class="hljs-attr">public</span> <span class="hljs-string">void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span>        <span class="hljs-attr">//保留以前规则</span>        <span class="hljs-attr">//自己写新的规则。</span>        <span class="hljs-attr">registry.addResourceHandler(&quot;/static/**&quot;)</span>                <span class="hljs-attr">.addResourceLocations(&quot;classpath</span>:<span class="hljs-string">/a/&quot;,&quot;classpath:/b/&quot;)</span>                <span class="hljs-attr">.setCacheControl(CacheControl.maxAge(1180,</span> <span class="hljs-string">TimeUnit.SECONDS));</span>    <span class="hljs-attr">&#125;</span><span class="hljs-attr">&#125;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">@Configuration</span> <span class="hljs-string">//这是一个配置类,给容器中放一个 WebMvcConfigurer 组件，就能自定义底层</span><span class="hljs-attr">public</span> <span class="hljs-string">class MyConfig  /*implements WebMvcConfigurer*/ &#123;</span>    <span class="hljs-attr">@Bean</span>    <span class="hljs-attr">public</span> <span class="hljs-string">WebMvcConfigurer webMvcConfigurer()&#123;</span>        <span class="hljs-attr">return</span> <span class="hljs-string">new WebMvcConfigurer() &#123;</span>            <span class="hljs-attr">@Override</span>            <span class="hljs-attr">public</span> <span class="hljs-string">void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span>                <span class="hljs-attr">registry.addResourceHandler(&quot;/static/**&quot;)</span>                        <span class="hljs-attr">.addResourceLocations(&quot;classpath</span>:<span class="hljs-string">/a/&quot;, &quot;classpath:/b/&quot;)</span>                        <span class="hljs-attr">.setCacheControl(CacheControl.maxAge(1180,</span> <span class="hljs-string">TimeUnit.SECONDS));</span>            <span class="hljs-attr">&#125;</span>        <span class="hljs-attr">&#125;;</span>    <span class="hljs-attr">&#125;</span><span class="hljs-attr">&#125;</span></code></pre></div></li></ul><h3 id="6-为什么容器中放一个WebMvcConfigurer就能配置底层行为"><a href="#6-为什么容器中放一个WebMvcConfigurer就能配置底层行为" class="headerlink" title="6. 为什么容器中放一个WebMvcConfigurer就能配置底层行为"></a>6. 为什么容器中放一个WebMvcConfigurer就能配置底层行为</h3><ol><li>WebMvcAutoConfiguration 是一个自动配置类，它里面有一个 EnableWebMvcConfiguration</li><li>EnableWebMvcConfiguration继承与 DelegatingWebMvcConfiguration，这两个都生效</li><li>DelegatingWebMvcConfiguration利用 ID 把容器中 所有 WebMvcConfigurer 注入进来</li><li>别人调用 <code>DelegatingWebMvcConfiguration</code> 的方法配置底层规则，而它调用所有 WebMvcConfigurer的配置底层方法。</li></ol><h2 id="3-路径匹配"><a href="#3-路径匹配" class="headerlink" title="3. 路径匹配"></a>3. 路径匹配</h2><p><strong>Spring5.3</strong> 之后加入了更多的请求路径匹配的实现策略；<br>以前只支持 AntPathMatcher 策略, 现在提供了 <strong>PathPatternParser</strong>策略。并且可以让我们指定到底使用那种策略。</p><h3 id="1-Ant风格路径用法"><a href="#1-Ant风格路径用法" class="headerlink" title="1. Ant风格路径用法"></a>1. Ant风格路径用法</h3><p>Ant 风格的路径模式语法具有以下规则：</p><ul><li>*：表示<strong>任意数量</strong>的字符。</li><li>?：表示任意<strong>一个字符</strong>。</li><li><strong>：表示</strong>任意数量的目录**。</li><li>{}：表示一个命名的模式<strong>占位符</strong>。</li><li>[]：表示<strong>字符集合</strong>，例如[a-z]表示小写字母。</li></ul><p>例如：</p><ul><li>*.html匹配任意名称，扩展名为.html的文件。</li><li>&#x2F;folder1&#x2F;<em>&#x2F;</em>.java匹配在folder1目录下的任意两级目录下的.java文件。</li><li>&#x2F;folder2&#x2F;**&#x2F;*.jsp匹配在folder2目录下任意目录深度的.jsp文件。</li><li>&#x2F;{type}&#x2F;{id}.html匹配任意文件名为{id}.html，在任意命名的{type}目录下的文件。</li></ul><p>注意：Ant 风格的路径模式语法中的特殊字符需要转义，如：</p><ul><li>要匹配文件路径中的星号，则需要转义为\*。</li><li>要匹配文件路径中的问号，则需要转义为\?。</li></ul><h3 id="2-模式切换"><a href="#2-模式切换" class="headerlink" title="2. 模式切换"></a>2. 模式切换</h3><h4 id="AntPathMatcher-与-PathPatternParser"><a href="#AntPathMatcher-与-PathPatternParser" class="headerlink" title="AntPathMatcher 与 PathPatternParser"></a>AntPathMatcher 与 PathPatternParser</h4><ul><li><p>PathPatternParser在 jmh 基准测试下，有 6<del>8 倍吞吐量提升，降低 30%</del>40%空间分配率</p></li><li><p>PathPatternParser 兼容 AntPathMatcher语法，并支持更多类型的路径模式</p></li><li><p>PathPatternParser “******” <strong>多段匹配</strong>的支持<strong>仅允许在模式末尾使用</strong></p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">@GetMapping(&quot;/a*/b?/&#123;p1</span>:<span class="hljs-string">[a-f]+&#125;&quot;)</span><span class="hljs-attr">public</span> <span class="hljs-string">String hello(HttpServletRequest request, </span>                    <span class="hljs-attr">@PathVariable(&quot;p1&quot;)</span> <span class="hljs-string">String path) &#123;</span>    <span class="hljs-attr">log.info(&quot;路径变量p1：</span> <span class="hljs-string">&#123;&#125;&quot;, path);</span>    <span class="hljs-attr">//获取请求路径</span>    <span class="hljs-attr">String</span> <span class="hljs-string">uri = request.getRequestURI();</span>    <span class="hljs-attr">return</span> <span class="hljs-string">uri;</span><span class="hljs-attr">&#125;</span></code></pre></div><p>总结： </p></li><li><p>使用默认的路径匹配规则，是由 PathPatternParser 提供的</p></li><li><p>如果路径中间需要有 **，替换成ant风格路径</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># 改变路径匹配策略：</span><span class="hljs-comment"># ant_path_matcher 老版策略；</span><span class="hljs-comment"># path_pattern_parser 新版策略；</span><span class="hljs-attr">spring.mvc.pathmatch.matching-strategy</span>=<span class="hljs-string">ant_path_matcher</span></code></pre></div></li></ul><h2 id="4-内容协商"><a href="#4-内容协商" class="headerlink" title="4. 内容协商"></a>4. 内容协商</h2><p>一套系统适配多端数据返回<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681217799861-dde49224-a767-489b-80b7-7d8d503e33cf.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_23,text_5bCa56GF6LC3IGF0Z3VpZ3UuY29t,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#averageHue=%23faf9f7&from=url&id=gZ4iS&originHeight=420&originWidth=797&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="1-多端内容适配"><a href="#1-多端内容适配" class="headerlink" title="1. 多端内容适配"></a>1. 多端内容适配</h3><h4 id="1-默认规则-1"><a href="#1-默认规则-1" class="headerlink" title="1. 默认规则"></a>1. 默认规则</h4><ol><li><strong>SpringBoot 多端内容适配</strong>。<ol><li><strong>基于请求头内容协商</strong>：（默认开启）<ol><li>客户端向服务端发送请求，携带HTTP标准的<strong>Accept请求头</strong>。<ol><li><strong>Accept</strong>: application&#x2F;json、text&#x2F;xml、text&#x2F;yaml</li><li>服务端根据客户端<strong>请求头期望的数据类型</strong>进行<strong>动态返回</strong></li><li>**1、默认支持把对象写为json。因为默认web场景导入了jackson处理json的包;jackson-core</li></ol></li></ol></li></ol></li></ol><ul><li>2、jackson也支持把数据写为xml。导入xml相关依赖**<ol start="2"><li><strong>基于请求参数内容协商：（需要开启）下面的?format就是要返回数据的格式。</strong><ol><li>发送请求 GET &#x2F;projects&#x2F;spring-boot?format&#x3D;json</li><li>匹配到 @GetMapping(“&#x2F;projects&#x2F;spring-boot”)</li><li>根据<strong>参数协商</strong>，优先返回 json 类型数据【<strong>需要开启参数匹配设置</strong>】</li><li>发送请求 GET &#x2F;projects&#x2F;spring-boot?format&#x3D;xml,优先返回 xml 类型数据</li></ol></li></ol></li></ul><h4 id="2-效果演示"><a href="#2-效果演示" class="headerlink" title="2. 效果演示"></a>2. 效果演示</h4><p>请求同一个接口，可以返回json和xml不同格式数据,<strong>、默认支持把对象写为json。因为默认web场景导入了jackson处理json的包;jackson-core,jackson也支持把数据写为xml。导入xml相关依赖</strong></p><ol><li><p>引入支持写出xml内容依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>标注注解</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">@JacksonXmlRootElement</span>  <span class="hljs-string">// 可以写出为xml文档</span><span class="hljs-attr">@Data</span><span class="hljs-attr">public</span> <span class="hljs-string">class Person &#123;</span>    <span class="hljs-attr">private</span> <span class="hljs-string">Long id;</span>    <span class="hljs-attr">private</span> <span class="hljs-string">String userName;</span>    <span class="hljs-attr">private</span> <span class="hljs-string">String email;</span>    <span class="hljs-attr">private</span> <span class="hljs-string">Integer age;</span><span class="hljs-attr">&#125;</span></code></pre></div></li><li><p>开启基于请求参数的内容协商</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># 开启基于请求参数的内容协商功能。 默认参数名：format。 默认此功能不开启</span><span class="hljs-attr">spring.mvc.contentnegotiation.favor-parameter</span>=<span class="hljs-string">true</span><span class="hljs-comment"># 指定内容协商时使用的参数名。默认是 format</span><span class="hljs-attr">spring.mvc.contentnegotiation.parameter-name</span>=<span class="hljs-string">type</span></code></pre></div></li><li><p>效果</p></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681220124448-e8611612-97bc-4823-9b00-20dd9d579abf.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_17,text_5bCa56GF6LC3IGF0Z3VpZ3UuY29t,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#averageHue=%23f9f8f8&from=url&id=tIIrj&originHeight=306&originWidth=594&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681220145378-86fabd90-a78c-4f60-9efa-eb2960915832.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_16,text_5bCa56GF6LC3IGF0Z3VpZ3UuY29t,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#averageHue=%23f6f5f5&from=url&id=mh0xz&originHeight=256&originWidth=575&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="3-配置协商规则与支持类型"><a href="#3-配置协商规则与支持类型" class="headerlink" title="3. 配置协商规则与支持类型"></a>3. 配置协商规则与支持类型</h3><ol><li><p>修改<strong>内容协商方式</strong></p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#使用参数进行内容协商</span><span class="hljs-attr">spring.mvc.contentnegotiation.favor-parameter</span>=<span class="hljs-string">true  </span><span class="hljs-comment">#自定义参数名，默认为format</span><span class="hljs-attr">spring.mvc.contentnegotiation.parameter-name</span>=<span class="hljs-string">myparam </span></code></pre></div></li><li><p>大多数 MediaType 都是开箱即用的。也可以<strong>自定义内容类型，如：</strong></p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">spring.mvc.contentnegotiation.media-types.yaml</span>=<span class="hljs-string">text/yaml</span></code></pre></div></li></ol><h3 id="2-自定义内容返回"><a href="#2-自定义内容返回" class="headerlink" title="2. 自定义内容返回"></a>2. 自定义内容返回</h3><h4 id="1-增加yaml返回支持"><a href="#1-增加yaml返回支持" class="headerlink" title="1. 增加yaml返回支持"></a>1. 增加yaml返回支持</h4><p>导入依赖</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">&lt;dependency&gt;</span>    <span class="hljs-attr">&lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;</span>    <span class="hljs-attr">&lt;artifactId&gt;jackson-dataformat-yaml&lt;/artifactId&gt;</span><span class="hljs-attr">&lt;/dependency&gt;</span></code></pre></div><p>把对象写出成YAML</p><div class="code-wrapper"><pre><code class="hljs properties">    <span class="hljs-attr">public</span> <span class="hljs-string">static void main(String[] args) throws JsonProcessingException &#123;</span>        <span class="hljs-attr">Person</span> <span class="hljs-string">person = new Person();</span>        <span class="hljs-attr">person.setId(1L);</span>        <span class="hljs-attr">person.setUserName(&quot;张三&quot;);</span>        <span class="hljs-attr">person.setEmail(&quot;aaa@qq.com&quot;);</span>        <span class="hljs-attr">person.setAge(18);</span><span class="hljs-attr">//禁用文档的开始标记</span>        <span class="hljs-attr">YAMLFactory</span> <span class="hljs-string">factory = new YAMLFactory().disable(YAMLGenerator.Feature.WRITE_DOC_START_MARKER);</span>        <span class="hljs-attr">ObjectMapper</span> <span class="hljs-string">mapper = new ObjectMapper(factory);</span>        <span class="hljs-attr">String</span> <span class="hljs-string">s = mapper.writeValueAsString(person);</span>        <span class="hljs-attr">System.out.println(s);</span>    <span class="hljs-attr">&#125;</span></code></pre></div><p>编写配置</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#新增一种媒体类型，</span><span class="hljs-attr">spring.mvc.contentnegotiation.media-types.yaml</span>=<span class="hljs-string">text/yaml</span></code></pre></div><p>增加HttpMessageConverter组件，专门负责把对象写出为yaml格式</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">@Bean</span><span class="hljs-attr">public</span> <span class="hljs-string">WebMvcConfigurer webMvcConfigurer()&#123;</span>    <span class="hljs-attr">return</span> <span class="hljs-string">new WebMvcConfigurer() &#123;</span>        <span class="hljs-attr">@Override</span> <span class="hljs-string">//配置一个能把对象转为yaml的messageConverter</span>        <span class="hljs-attr">public</span> <span class="hljs-string">void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;</span>            <span class="hljs-attr">converters.add(new</span> <span class="hljs-string">MyYamlHttpMessageConverter());//将新增的配置格式和配置类关联起来</span>        <span class="hljs-attr">&#125;</span>    <span class="hljs-attr">&#125;;</span><span class="hljs-attr">&#125;</span></code></pre></div><h3 id="3-HttpMessageConverter的示例写法"><a href="#3-HttpMessageConverter的示例写法" class="headerlink" title="3. HttpMessageConverter的示例写法"></a>3. HttpMessageConverter的示例写法</h3><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">public</span> <span class="hljs-string">class MyYamlHttpMessageConverter extends AbstractHttpMessageConverter&lt;Object&gt; &#123;</span><span class="hljs-attr">//或者是实现</span> <span class="hljs-string">HttpMessageConverter</span>    <span class="hljs-attr">private</span> <span class="hljs-string">ObjectMapper objectMapper = null; //把对象转成yaml</span>    <span class="hljs-attr">public</span> <span class="hljs-string">MyYamlHttpMessageConverter()&#123;</span>        <span class="hljs-attr">//告诉SpringBoot这个MessageConverter支持哪种媒体类型</span>  <span class="hljs-string">//媒体类型</span>        <span class="hljs-attr">super(new</span> <span class="hljs-string">MediaType(&quot;text&quot;, &quot;yaml&quot;, Charset.forName(&quot;UTF-8&quot;)));</span>        <span class="hljs-attr">YAMLFactory</span> <span class="hljs-string">factory = new YAMLFactory()</span>                <span class="hljs-attr">.disable(YAMLGenerator.Feature.WRITE_DOC_START_MARKER);</span>        <span class="hljs-attr">this.objectMapper</span> = <span class="hljs-string">new ObjectMapper(factory);</span>    <span class="hljs-attr">&#125;</span>    <span class="hljs-attr">@Override</span>    <span class="hljs-attr">protected</span> <span class="hljs-string">boolean supports(Class&lt;?&gt; clazz) &#123;</span>        <span class="hljs-attr">//只要是对象类型，不是基本类型</span>        <span class="hljs-attr">return</span> <span class="hljs-string">true;</span>    <span class="hljs-attr">&#125;</span>    <span class="hljs-attr">@Override</span>  <span class="hljs-string">//@RequestBody,读取请求对象 </span>    <span class="hljs-attr">protected</span> <span class="hljs-string">Object readInternal(Class&lt;?&gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException &#123;</span>        <span class="hljs-attr">return</span> <span class="hljs-string">null;</span>    <span class="hljs-attr">&#125;</span>    <span class="hljs-attr">@Override</span> <span class="hljs-string">//@ResponseBody 把对象怎么写出去</span>    <span class="hljs-attr">protected</span> <span class="hljs-string">void writeInternal(Object methodReturnValue, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException &#123;</span>        <span class="hljs-attr">//try-with写法，自动关流</span>        <span class="hljs-attr">try(OutputStream</span> <span class="hljs-string">os = outputMessage.getBody())&#123;</span>            <span class="hljs-attr">this.objectMapper.writeValue(os,methodReturnValue);</span>        <span class="hljs-attr">&#125;</span>    <span class="hljs-attr">&#125;</span><span class="hljs-attr">&#125;</span></code></pre></div><h4 id="2-思考：如何增加其他"><a href="#2-思考：如何增加其他" class="headerlink" title="2. 思考：如何增加其他"></a>2. 思考：如何增加其他</h4><ul><li>配置媒体类型支持: <ul><li>spring.mvc.contentnegotiation.media-types.yaml&#x3D;text&#x2F;yaml</li></ul></li><li>编写对应的HttpMessageConverter，要告诉Boot这个支持的媒体类型<ul><li>按照3的示例</li></ul></li><li>把MessageConverter组件加入到底层<ul><li>容器中放一个<code>WebMvcConfigurer</code> 组件，并配置底层的MessageConverter</li></ul></li></ul><h2 id="3-内容协商原理-HttpMessageConverter"><a href="#3-内容协商原理-HttpMessageConverter" class="headerlink" title="3. 内容协商原理-HttpMessageConverter"></a>3. 内容协商原理-HttpMessageConverter</h2><ul><li>HttpMessageConverter 怎么工作？合适工作？</li><li>定制 HttpMessageConverter 来实现多端内容协商</li><li>编写WebMvcConfigurer提供的configureMessageConverters底层，修改底层的MessageConverter</li></ul><h3 id="1-ResponseBody由HttpMessageConverter处理"><a href="#1-ResponseBody由HttpMessageConverter处理" class="headerlink" title="1. @ResponseBody由HttpMessageConverter处理"></a>1. @ResponseBody由HttpMessageConverter处理</h3><p>标注了@ResponseBody的返回值 将会由支持它的 HttpMessageConverter写给浏览器</p><ol><li>如果controller方法的返回值标注了 @ResponseBody 注解<ol><li><p>请求进来先来到DispatcherServlet的doDispatch()进行处理</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">doDispatch()</span> <span class="hljs-string">是 Spring MVC 中的核心方法之一，用于处理请求的分发和调度。</span><span class="hljs-attr">在</span> <span class="hljs-string">Spring MVC 中，请求的处理流程如下：</span><span class="hljs-attr">1.客户端发送一个</span> <span class="hljs-string">HTTP 请求到服务器。</span><span class="hljs-attr">2.前端控制器（Front</span> <span class="hljs-string">Controller）接收到请求，这个控制器通常是 DispatcherServlet，它是 </span><span class="hljs-attr">Spring</span> <span class="hljs-string">MVC 的核心组件。</span><span class="hljs-attr">3.DispatcherServlet</span> <span class="hljs-string">根据请求的 URL 找到相应的处理器（Handler）。</span><span class="hljs-attr">4.处理器执行相应的业务逻辑并返回一个</span> <span class="hljs-string">ModelAndView 对象。(其中执行目标方法要准备参数解析器和</span><span class="hljs-attr">返回值解析器）</span><span class="hljs-attr">5.DispatcherServlet</span> <span class="hljs-string">根据 ModelAndView 对象选择合适的视图（View）进行渲染。</span><span class="hljs-attr">最终将渲染结果返回给客户端。（</span><span class="hljs-attr">在这个处理流程中，doDispatch()</span> <span class="hljs-string">方法负责实际执行第 4 步和第 5 步的操作。</span><span class="hljs-attr">具体而言，doDispatch()</span> <span class="hljs-string">方法会执行以下主要任务：</span><span class="hljs-attr">解析请求，包括解析请求的方法、路径、参数等信息。</span><span class="hljs-attr">根据请求的方法和路径，确定匹配的处理器（Handler）。</span><span class="hljs-attr">执行处理器的业务逻辑，处理请求并返回一个</span> <span class="hljs-string">ModelAndView 对象。</span><span class="hljs-attr">根据</span> <span class="hljs-string">ModelAndView 对象中的视图名字，选择合适的视图（View）进行渲染。</span><span class="hljs-attr">渲染视图，生成最终的响应结果。</span><span class="hljs-attr">doDispatch()</span> <span class="hljs-string">方法的具体实现会涉及到请求的映射、处理器适配器、处理器拦截器、参数解析器等等。</span><span class="hljs-attr">该方法是</span> <span class="hljs-string">Spring MVC 框架的核心之一，在请求的处理过程中起到了关键的作用。</span><span class="hljs-attr">需要注意的是，doDispatch()</span> <span class="hljs-string">方法通常由 DispatcherServlet 自动调用，开发者一般不需要直接调用</span><span class="hljs-attr">该方法。开发者主要关注配置合适的请求映射、编写处理器方法以及配置视图解析器等，框架会自动根据</span><span class="hljs-attr">配置和规则来调用</span> <span class="hljs-string">doDispatch() 方法来处理请求。</span></code></pre></div></li><li><p>找到一个 HandlerAdapter 适配器。利用适配器执行目标方法</p></li><li><p>RequestMappingHandlerAdapter来执行，调用invokeHandlerMethod（）来执行目标方法</p></li><li><p>目标方法执行之前，准备好两个东西</p><ol><li>HandlerMethodArgumentResolver：参数解析器，确定目标方法每个参数值</li><li>HandlerMethodReturnValueHandler：返回值处理器，确定目标方法的返回值改怎么处理</li></ol></li><li><p>RequestMappingHandlerAdapter 里面的invokeAndHandle()真正执行目标方法</p></li><li><p>目标方法执行完成，会返回<strong>返回值对象</strong></p></li><li><p>**找到一个合适的返回值处理器 **HandlerMethodReturnValueHandler</p></li><li><p>最终找到 RequestResponseBodyMethodProcessor能处理 标注了 @ResponseBody注解的方法</p></li><li><p>RequestResponseBodyMethodProcessor 调用writeWithMessageConverters ,利用MessageConverter把返回值写出去</p></li></ol></li></ol><p>上面解释：@ResponseBody由HttpMessageConverter处理</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">HttpMessageConverter</span> <span class="hljs-string">是 Spring MVC 中的一个关键接口，用于处理 HTTP 请求和响应消息的转换。</span><span class="hljs-attr">它负责将</span> <span class="hljs-string">Java 对象与 HTTP 请求/响应的内容进行转换，使得应用程序可以方便地处理不同类型的数据格式，</span><span class="hljs-attr">如</span> <span class="hljs-string">JSON、XML、表单数据等。</span></code></pre></div><ol><li>HttpMessageConverter 会<strong>先进行内容协商</strong><ol><li>遍历所有的MessageConverter看谁支持这种<strong>内容类型的数据</strong></li><li>默认MessageConverter有以下</li><li><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681275459547-89d8d651-b52f-4d47-bff9-6db123624424.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_15,text_5bCa56GF6LC3IGF0Z3VpZ3UuY29t,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#averageHue=%23f0eeeb&from=url&id=w9v5M&originHeight=282&originWidth=532&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></li><li>最终因为要json所以MappingJackson2HttpMessageConverter支持写出json</li><li>jackson用ObjectMapper（是一个类）把对象写出去</li></ol></li></ol><h3 id="2-WebMvcAutoConfiguration提供几种默认HttpMessageConverters"><a href="#2-WebMvcAutoConfiguration提供几种默认HttpMessageConverters" class="headerlink" title="2. WebMvcAutoConfiguration提供几种默认HttpMessageConverters"></a>2. WebMvcAutoConfiguration提供几种默认HttpMessageConverters</h3><ul><li>EnableWebMvcConfiguration通过 addDefaultHttpMessageConverters添加了默认的MessageConverter；如下：<ul><li>ByteArrayHttpMessageConverter： 支持字节数据读写</li><li>StringHttpMessageConverter： 支持字符串读写</li><li>ResourceHttpMessageConverter：支持资源读写</li><li>ResourceRegionHttpMessageConverter: 支持分区资源写出</li><li>AllEncompassingFormHttpMessageConverter：支持表单xml&#x2F;json读写</li><li>MappingJackson2HttpMessageConverter： 支持请求响应体Json读写</li></ul></li></ul><p>默认8个：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681302411019-0c0425aa-6679-4b2b-a456-b31c151c6e83.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_15,text_5bCa56GF6LC3IGF0Z3VpZ3UuY29t,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#averageHue=%23f1eeec&from=url&id=WrjKA&originHeight=237&originWidth=532&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br>系统提供默认的MessageConverter 功能有限，仅用于json或者普通返回数据。额外增加新的内容协商功能，必须增加新的HttpMessageConverter</p><h1 id="5-模板引擎"><a href="#5-模板引擎" class="headerlink" title="5. 模板引擎"></a>5. 模板引擎</h1><ul><li>由于 <strong>SpringBoot</strong> 使用了<strong>嵌入式 Servlet 容器</strong>。所以 <strong>JSP</strong> 默认是<strong>不能使用</strong>的。</li><li>如果需要<strong>服务端页面渲染</strong>，优先考虑使用 模板引擎。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681354523290-b89d7e0d-b9aa-40f5-8d22-d3d09d02b136.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_28,text_5bCa56GF6LC3IGF0Z3VpZ3UuY29t,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#averageHue=%23f6f5f5&from=url&id=FMo0Z&originHeight=654&originWidth=999&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br>模板引擎页面默认放在 src&#x2F;main&#x2F;resources&#x2F;templates<br><strong>SpringBoot</strong> 包含以下模板引擎的自动配置</p><ul><li>FreeMarker</li><li>Groovy</li><li><strong>Thymeleaf</strong></li><li>Mustache</li></ul><p><strong>Thymeleaf官网</strong>：<a href="https://www.thymeleaf.org/">https://www.thymeleaf.org/</a></p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">&lt;!DOCTYPE</span> <span class="hljs-string">html&gt;</span><span class="hljs-attr">&lt;html</span> <span class="hljs-string">xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><span class="hljs-attr">&lt;head&gt;</span><span class="hljs-attr">&lt;title&gt;Good</span> <span class="hljs-string">Thymes Virtual Grocery&lt;/title&gt;</span><span class="hljs-attr">&lt;meta</span> <span class="hljs-string">http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;</span><span class="hljs-attr">&lt;link</span> <span class="hljs-string">rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot; th:href=&quot;@&#123;/css/gtvg.css&#125;&quot; /&gt;</span><span class="hljs-attr">&lt;/head&gt;</span><span class="hljs-attr">&lt;body&gt;</span><span class="hljs-attr">&lt;p</span> <span class="hljs-string">th:text=&quot;#&#123;home.welcome&#125;&quot;&gt;Welcome to our grocery store!&lt;/p&gt;</span><span class="hljs-attr">&lt;/body</span><span class="hljs-attr">&lt;/html&gt;</span></code></pre></div><h2 id="1-Thymeleaf整合（是前后端一体的开发）"><a href="#1-Thymeleaf整合（是前后端一体的开发）" class="headerlink" title="1. Thymeleaf整合（是前后端一体的开发）"></a>1. Thymeleaf整合（是前后端一体的开发）</h2><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">&lt;dependency&gt;</span>    <span class="hljs-attr">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span>    <span class="hljs-attr">&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><span class="hljs-attr">&lt;/dependency&gt;</span></code></pre></div><p>自动配置原理</p><ol><li>开启了org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration自动配置</li><li>属性绑定在 ThymeleafProperties类 中，对应配置文件 spring.thymeleaf 内容（也就是配置文件中以spring.thymeleaf开头的属性）</li><li>所有的模板页面默认在 classpath:&#x2F;templates文件夹下</li><li>默认效果<ol><li>所有的模板页面在 classpath:&#x2F;templates&#x2F;下面找</li><li>找后缀名为.html的页面</li></ol></li></ol><p>事例：<br>1.使用Thymeleaf来处理的项目其controller类用@Controller &#x2F;&#x2F;适配 服务端渲染 前后不分离模式开始;而前后端分离的项目用@Resttroller注解<br><a href="https://www.cnblogs.com/east7/p/10462279.html">Spring 注解之@RestController与@Controller的区别 - 楼兰胡杨 - 博客园</a></p><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@RestController</span>无法返回指定页面，而<span class="hljs-variable">@Controller</span>可以；前者可以直接返回数据，后者需要<span class="hljs-variable">@ResponseBody</span>辅助。如果需要返回JSON，XML或自定义mediaType内容到页面，<span class="hljs-variable">@RestController</span>自己就可以搞定，这个注解对于返回数据比较方便，因为它会自动将对象实体转换为JSON格式。而<span class="hljs-variable">@Controller</span>需要在对应的方法加上<span class="hljs-variable">@ResponseBody</span>注解。</code></pre></div><p>2.get请求其参数是写在url中的，而post请求参数是在请求体中的。<br>3.@GetMapping（）用来修饰处理get请求的方法。<br>4.&#x2F;&#x2F;模板的逻辑视图名<br>&#x2F;&#x2F;物理视图 &#x3D; 前缀 + 逻辑视图名 + 后缀<br>&#x2F;&#x2F;真实地址 &#x3D; classpath:&#x2F;templates&#x2F;welcome.html其中的前缀和后缀在ThymeleafProperties类中指定了的<br>5.其Thymeleaf还提供了一些工具类，常用#类名表示，例如：#string。这些工具类可以进行简单的运行操作。<br>6.如果html中要使用Thymeleaf语法，需要提供其命名空间</p><h2 id="2-基础语法（在html中使用Thymeleaf）"><a href="#2-基础语法（在html中使用Thymeleaf）" class="headerlink" title="2. 基础语法（在html中使用Thymeleaf）"></a>2. 基础语法（在html中使用Thymeleaf）</h2><h3 id="1-核心用法"><a href="#1-核心用法" class="headerlink" title="1. 核心用法"></a>1. 核心用法</h3><p>导入命名空间：</p><div class="code-wrapper"><pre><code class="hljs avrasm">&lt;html lang=<span class="hljs-string">&quot;en&quot;</span> xmlns:th=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;<span class="hljs-symbol">xmlns:</span>th属性，该属性是Thymeleaf命名空间（http://www.thymeleaf<span class="hljs-meta">.org</span>）的声明。这个命名空间允许您在HTML代码中使用Thymeleaf特定的属性和表达式。</code></pre></div><p><strong>th:xxx：动态渲染指定的 html 标签属性值、或者th指令（遍历、判断等）</strong></p><ul><li><p>th:text：标签体内文本值渲染</p><ul><li>th:utext：不会转义，显示为html原本的样子。也就是文本中的html元素可以被解析</li></ul></li><li><p>th:属性：标签指定属性渲染</p></li><li><p>th:attr：标签任意属性渲染</p></li><li><p>th:if  （根据后端逻辑或数据的条件来控制是否在渲染过程中包含或显示某个元素。）  th:each…：其他th指令</p></li><li><p>例如：</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">&lt;p</span> <span class="hljs-string">th:text=&quot;$&#123;content&#125;&quot;&gt;原内容&lt;/p&gt;</span><span class="hljs-attr">&lt;a</span> <span class="hljs-string">th:href=&quot;$&#123;url&#125;&quot;&gt;登录&lt;/a&gt;</span><span class="hljs-attr">&lt;img</span> <span class="hljs-string">src=&quot;../../images/gtvglogo.png&quot; </span>     <span class="hljs-attr">th</span>:<span class="hljs-string">attr=&quot;src=@&#123;/images/gtvglogo.png&#125;,title=#&#123;logo&#125;,alt=#&#123;logo&#125;&quot; /&gt;</span></code></pre></div><p><strong>表达式：用来动态取值</strong></p></li><li><p><strong>${}：变量取值；使用model共享给页面的值都直接用${}是用下面的方法实现的：</strong></p></li></ul><p>model.addAttribute(“imgUrl”<strong>,</strong>“&#x2F;4.jpg”)<strong>;imgUrl就是共享的值</strong></p><ul><li><strong>@{}：url路径；@{}是一个Thymeleaf的URL表达式，它用来在HTML文档中生成一个相对于当前应用上下文的URL路径。当然也可以直接使用{}表示，例如：src&#x3D;”{}”但是其如果在配置文件中配置了</strong>server.servlet.context-path&#x3D;&#x2F;demo那么要想配置的src路径生效需要在src的路径前添加&#x2F;demo前缀否则无法访问，如果是使用的是src&#x3D;的是@{}那么可以不用修改src仍旧可以正常访问。</li><li>**@{}路径中的内容会自动添加链接头部和尾部**</li><li>#{}：国际化消息</li><li>~{}：片段引用</li><li>*{}：变量选择：需要配合th:object绑定对象</li></ul><p><strong>系统工具&amp;内置对象：</strong><a href="https://www.thymeleaf.org/doc/tutorials/3.1/usingthymeleaf.html#appendix-a-expression-basic-objects">详细文档</a></p><ul><li>param：请求参数对象</li><li>session：session对象</li><li>application：application对象</li><li>#execInfo：模板执行信息</li><li>#messages：国际化消息</li><li>#uris：uri&#x2F;url工具</li><li>#conversions：类型转换工具</li><li>#dates：日期工具，是java.util.Date对象的工具类</li><li>#calendars：类似#dates，只不过是java.util.Calendar对象的工具类</li><li>#temporals： JDK8+ <strong>java.time</strong> API 工具类</li><li>#numbers：数字操作工具</li><li>#strings：字符串操作</li><li>#objects：对象操作</li><li>#bools：bool操作</li><li>#arrays：array工具</li><li>#lists：list工具</li><li>#sets：set工具</li><li>#maps：map工具</li><li>#aggregates：集合聚合工具（sum、avg）</li><li>#ids：id生成工具</li></ul><h3 id="2-语法示例"><a href="#2-语法示例" class="headerlink" title="2. 语法示例"></a>2. 语法示例</h3><p><strong>表达式：</strong></p><ul><li>变量取值：${…}</li><li>url 取值：@{…}</li><li>国际化消息：#{…}</li><li>变量选择：*{…}</li><li>片段引用:~{…}</li></ul><p><strong>常见：</strong></p><ul><li>文本：’one text’，’another one!’,…</li><li>数字：0,34,3.0,12.3,…</li><li>布尔：true、false</li><li>null:null</li><li>变量名：one,sometext,main…</li></ul><p><strong>文本操作：</strong></p><ul><li>拼串：+</li><li>文本替换：| The name is ${name} |</li></ul><p><strong>布尔操作：</strong></p><ul><li>二进制运算：and,or</li><li>取反：!,not</li></ul><p><strong>比较运算：</strong></p><ul><li>比较：&gt;，&lt;，&lt;&#x3D;，&gt;&#x3D;（gt，lt，ge,le）</li><li>等值运算：&#x3D;&#x3D;,!&#x3D;（eq，ne）</li></ul><p><strong>条件运算：</strong></p><ul><li>if-then：(if)?(then)</li><li>if-then-else:(if)?(then):(else)</li><li>default:(value)?:(defaultValue)</li></ul><p><strong>特殊语法：</strong></p><ul><li>无操作：_</li></ul><p><strong>所有以上都可以嵌套组合</strong></p><div class="code-wrapper"><pre><code class="hljs ada"><span class="hljs-symbol">&#x27;User</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">type</span> <span class="hljs-type">&#x27; </span>+ ($&#123;user.isAdmin()&#125; ? <span class="hljs-symbol">&#x27;Administrator</span>&#x27; : ($&#123;<span class="hljs-type">user.type</span>&#125; ?: <span class="hljs-symbol">&#x27;Unknown</span>&#x27;))</code></pre></div><h2 id="3-属性设置"><a href="#3-属性设置" class="headerlink" title="3. 属性设置"></a>3. 属性设置</h2><ol><li>th:href&#x3D;”@{&#x2F;product&#x2F;list}”</li><li>th:attr&#x3D;”class&#x3D;${active}”</li><li>th:attr&#x3D;”src&#x3D;@{&#x2F;images&#x2F;gtvglogo.png},title&#x3D;${logo},alt&#x3D;#{logo}”</li><li>th:checked&#x3D;”${user.active}”<div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;content&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>原内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;url&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../../images/gtvglogo.png&quot;</span> </span></span><span class="hljs-tag"><span class="language-xml">     <span class="hljs-attr">th:attr</span>=<span class="hljs-string">&quot;src=@</span></span></span><span class="hljs-template-tag">&#123;/<span class="hljs-name">images</span>/gtvglogo.png&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">,title=#</span></span></span><span class="hljs-template-variable">&#123;logo&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">,alt=#</span></span></span><span class="hljs-template-variable">&#123;logo&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> /&gt;</span></span></code></pre></div></li></ol><h2 id="4-遍历"><a href="#4-遍历" class="headerlink" title="4. 遍历"></a>4. 遍历</h2><p>语法： th:each&#x3D;”元素名,迭代状态 : ${集合}”</p><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;prod : $</span></span></span><span class="hljs-template-variable">&#123;prods&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;prod.name&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>Onions<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;prod.price&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>2.41<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;prod.inStock&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">? #</span></span></span><span class="hljs-template-variable">&#123;true&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string"> : #</span></span></span><span class="hljs-template-variable">&#123;false&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>yes<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;prod,iterStat : $</span></span></span><span class="hljs-template-variable">&#123;prods&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">th:class</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;iterStat.odd&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">? &#x27;odd&#x27;&quot;</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;prod.name&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>Onions<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;prod.price&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>2.41<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;prod.inStock&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">? #</span></span></span><span class="hljs-template-variable">&#123;true&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string"> : #</span></span></span><span class="hljs-template-variable">&#123;false&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>yes<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span></code></pre></div><p>iterStat 有以下属性：</p><ul><li>index：当前遍历元素的索引，从0开始</li><li>count：当前遍历元素的索引，从1开始</li><li>size：需要遍历元素的总数量</li><li>current：当前正在遍历的元素对象</li><li>even&#x2F;odd：是否偶数&#x2F;奇数行</li><li>first：是否第一个元素</li><li>last：是否最后一个元素<div class="code-wrapper"><pre><code class="hljs vim">&lt;<span class="hljs-keyword">th</span> scope=<span class="hljs-string">&quot;col&quot;</span>&gt;#&lt;/<span class="hljs-keyword">th</span>&gt;这里的<span class="hljs-keyword">th</span>标签表示是一个表头标签，scope属性指定表头单元格的范围，这里的范围是一个表头占据一个单元格。</code></pre></div></li></ul><h2 id="5-判断"><a href="#5-判断" class="headerlink" title="5. 判断"></a>5. 判断</h2><h3 id="th-if"><a href="#th-if" class="headerlink" title="th:if"></a>th:if</h3><div class="code-wrapper"><pre><code class="hljs dart">&lt;td th:text=<span class="hljs-string">&quot;| <span class="hljs-subst">$&#123;person.age&#125;</span> / <span class="hljs-subst">$&#123;person.age &gt;= <span class="hljs-number">18</span>?<span class="hljs-string">&#x27;成年&#x27;</span>:<span class="hljs-string">&#x27;未成年&#x27;</span> &#125;</span>|&quot;</span>&gt;  &lt;/td&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span></span></span><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;comments.html&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@</span></span></span><span class="hljs-template-tag">&#123;/<span class="hljs-name">product</span>/comments(prodId=$&#123;prod.id&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">)&#125;&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;not #lists.isEmpty(prod.comments)&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">  &gt;</span>view&lt;/a</span></code></pre></div><h3 id="th-switch"><a href="#th-switch" class="headerlink" title="th:switch"></a>th:switch</h3><div class="code-wrapper"><pre><code class="hljs axapta">&lt;<span class="hljs-keyword">div</span> th:<span class="hljs-keyword">switch</span>=<span class="hljs-string">&quot;$&#123;user.role&#125;&quot;</span>&gt;  &lt;p th:<span class="hljs-keyword">case</span>=<span class="hljs-string">&quot;&#x27;admin&#x27;&quot;</span>&gt;User <span class="hljs-keyword">is</span> an administrator&lt;/p&gt;<span class="hljs-comment">//这里的admin的单引号表示其为一个字符串</span><span class="hljs-comment">//，和变量区分</span>  &lt;p th:<span class="hljs-keyword">case</span>=<span class="hljs-string">&quot;#&#123;roles.manager&#125;&quot;</span>&gt;User <span class="hljs-keyword">is</span> a manager&lt;/p&gt;  &lt;p th:<span class="hljs-keyword">case</span>=<span class="hljs-string">&quot;*&quot;</span>&gt;User <span class="hljs-keyword">is</span> some other thing&lt;/p&gt;&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre></div><h2 id="6-属性优先级"><a href="#6-属性优先级" class="headerlink" title="6. 属性优先级"></a>6. 属性优先级</h2><ul><li>片段</li><li>遍历</li><li>判断<div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;item : $</span></span></span><span class="hljs-template-variable">&#123;items&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;item.description&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>Item description here...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span></code></pre></div><table><thead><tr><th>Order</th><th>Feature</th><th>Attributes</th></tr></thead><tbody><tr><td>1</td><td>片段包含</td><td>th:insertth:replace</td></tr><tr><td>2</td><td>遍历</td><td>th:each</td></tr><tr><td>3</td><td>判断</td><td>th:ifth:unlessth:switchth:case</td></tr><tr><td>4</td><td>定义本地变量</td><td>th:objectth:with</td></tr><tr><td>5</td><td>通用方式属性修改</td><td>th:attrth:attrprependth:attrappend</td></tr><tr><td>6</td><td>指定属性修改</td><td>th:valueth:hrefth:src…</td></tr><tr><td>7</td><td>文本值</td><td>th:textth:utext</td></tr><tr><td>8</td><td>片段指定</td><td>th:fragment</td></tr><tr><td>9</td><td>片段移除</td><td>th:remove</td></tr></tbody></table></li></ul><h2 id="7-行内写法"><a href="#7-行内写法" class="headerlink" title="7. 行内写法"></a>7. 行内写法</h2><p>[[…]] or [(…)]</p><div class="code-wrapper"><pre><code class="hljs lua">&lt;p&gt;Hello, <span class="hljs-string">[[$&#123;session.user.name&#125;]]</span>!&lt;/p&gt;</code></pre></div><h2 id="8-变量选择"><a href="#8-变量选择" class="headerlink" title="8. 变量选择"></a>8. 变量选择</h2><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:object</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;session.user&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Name: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*</span></span></span><span class="hljs-template-variable">&#123;firstName&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>Sebastian<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Surname: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*</span></span></span><span class="hljs-template-variable">&#123;lastName&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>Pepper<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Nationality: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*</span></span></span><span class="hljs-template-variable">&#123;nationality&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>Saturn<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></code></pre></div><p>等同于</p><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Name: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;session.user.firstName&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>Sebastian<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Surname: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;session.user.lastName&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>Pepper<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Nationality: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;session.user.nationality&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>Saturn<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml">&lt;/div</span></code></pre></div><h2 id="9-模板布局"><a href="#9-模板布局" class="headerlink" title="9. 模板布局"></a>9. 模板布局</h2><ul><li>定义模板： th:fragment</li><li>引用模板：~{templatename::selector}</li><li>插入模板：th:insert、th:replace<div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;copy&quot;</span>&gt;</span><span class="hljs-symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:insert</span>=<span class="hljs-string">&quot;~</span></span></span><span class="hljs-template-variable">&#123;footer :: copy&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:replace</span>=<span class="hljs-string">&quot;~</span></span></span><span class="hljs-template-variable">&#123;footer :: copy&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml">  结果：</span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">th</span>:<span class="hljs-keyword">insert</span>和<span class="hljs-keyword">th</span>:replace是Thymeleaf模板引擎中的两个属性，用于在模板中插入或替换其他模板片段。<span class="hljs-keyword">th</span>:<span class="hljs-keyword">insert</span>属性用于在当前模板中插入另一个模板片段。<span class="hljs-keyword">th</span>:replace属性用于在当前模板中替换自身的内容为另一个模板片段。</code></pre></div></li></ul><h2 id="10-devtools"><a href="#10-devtools" class="headerlink" title="10. devtools"></a>10. devtools</h2><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>修改页面后；ctrl+F9刷新效果（热启动）；前提是配置了devtools。<br>java代码的修改，如果devtools热启动了，可能会引起一些bug，难以排查<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1691304138965-1792688e-a546-44c5-b225-df80d9bc8562.png#averageHue=%23f2f1dc&clientId=u5acfc650-ecf6-4&from=paste&height=46&id=u926de390&originHeight=58&originWidth=223&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=12806&status=done&style=none&taskId=u16c89229-3bdc-4732-9eb3-5693e766448&title=&width=178.4" alt="image.png">（缓存机制）<br>spring.thymeleaf.check-template&#x3D;false检查模板是否存在</p><h1 id="6-国际化"><a href="#6-国际化" class="headerlink" title="6. 国际化"></a>6. 国际化</h1><p>国际化的自动配置参照MessageSourceAutoConfiguration<br><strong>实现步骤</strong>：</p><ol><li>Spring Boot 在类路径根下查找messages资源绑定文件（配置。文件名为：messages.properties</li><li>多语言可以定义多个消息文件，命名为messages_区域代码.properties。如：<ol><li>messages.properties：默认</li><li>messages_zh_CN.properties：中文环境</li><li>messages_en_US.properties：英语环境</li></ol></li><li>在<strong>程序中</strong>可以自动注入 MessageSource组件，获取国际化的配置项值</li><li>在<strong>页面中</strong>可以使用表达式  #{}获取国际化的配置项值<div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-meta">@Autowired</span>  <span class="hljs-comment">//国际化取消息用的组件</span><span class="hljs-title class_">MessageSource</span> messageSource;<span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/haha&quot;</span>)<span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">haha</span>(<span class="hljs-params">HttpServletRequest request</span>)&#123;    <span class="hljs-title class_">Locale</span> locale = request.<span class="hljs-title function_">getLocale</span>();    <span class="hljs-comment">//利用代码的方式获取国际化配置文件中指定的配置项的值</span>    <span class="hljs-title class_">String</span> login = messageSource.<span class="hljs-title function_">getMessage</span>(<span class="hljs-string">&quot;login&quot;</span>, <span class="hljs-literal">null</span>, locale);    <span class="hljs-keyword">return</span> login;&#125;</code></pre></div></li></ol><h1 id="7-错误处理"><a href="#7-错误处理" class="headerlink" title="7. 错误处理"></a>7. 错误处理</h1><h2 id="1-默认机制"><a href="#1-默认机制" class="headerlink" title="1. 默认机制"></a>1. 默认机制</h2><p><strong>错误处理的自动配置</strong>都在ErrorMvcAutoConfiguration中，两大核心机制：</p><ul><li><ol><li>SpringBoot 会<strong>自适应处理错误</strong>，<strong>响应页面</strong>或<strong>JSON数据</strong><div class="code-wrapper"><pre><code class="hljs mipsasm">Spring <span class="hljs-keyword">Boot </span>会根据请求的类型和接受的媒体类型，自适应地处理错误，返回合适的响应格式。如果请求是一个浏览器请求，Spring <span class="hljs-keyword">Boot </span>会返回一个 HTML 错误页面，这个页面也被称为白标错误页面。如果请求是一个 RESTful 请求，或者接受的媒体类型是 <span class="hljs-keyword">JSON，Spring </span><span class="hljs-keyword">Boot </span>会返回一个 <span class="hljs-keyword">JSON </span>响应，包含错误的详细信息，HTTP 状态码，和异常消息</code></pre></div></li></ol></li><li><p>2.** SpringMVC的错误处理机制<strong>依然保留，</strong>MVC处理不了<strong>，才会</strong>交给boot进行处理**</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/svg/1613913/1681723795095-828d2034-1e6c-4d98-8e47-573dd6b5463b.svg#from=url&id=ez8nQ&originHeight=842&originWidth=1047&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br>1.springMvc处理错误：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1691307013013-0d54dd7b-2189-4f1b-b63d-f880eeadd942.png#averageHue=%23fdfdfb&clientId=u8fdb1034-8532-4&from=paste&height=370&id=u8cfa0ee8&originHeight=463&originWidth=960&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=134823&status=done&style=none&taskId=ud0d4529f-dec1-4e92-8baa-78f5b60dba9&title=&width=768" alt="image.png"><br>这里如果发生了错误，会执行@ExceptionHandler修饰的方法，这里是将handleException中的方法的返回值写到返回体中，然后返回该浏览器。<br>2.<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1691307230435-8c06a2a5-20ea-423f-b5e3-cc14688b812f.png#averageHue=%23f7f4e0&clientId=u8fdb1034-8532-4&from=paste&height=66&id=ubf31b11b&originHeight=83&originWidth=571&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=36513&status=done&style=none&taskId=ua92b8fb3-30aa-4271-908a-08bf7d846ed&title=&width=456.8" alt="image.png"></p><ul><li><p>发生错误以后，转发给&#x2F;error路径，SpringBoot在底层写好一个 BasicErrorController的组件，专门处理这个请求</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-meta">@RequestMapping</span>(produces = <span class="hljs-title class_">MediaType</span>.<span class="hljs-property">TEXT_HTML_VALUE</span>) <span class="hljs-comment">//返回HTML</span><span class="hljs-keyword">public</span> <span class="hljs-title class_">ModelAndView</span> <span class="hljs-title function_">errorHtml</span>(<span class="hljs-params">HttpServletRequest request, HttpServletResponse response</span>) &#123;<span class="hljs-title class_">HttpStatus</span> status = <span class="hljs-title function_">getStatus</span>(request);<span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Object</span>&gt; model = <span class="hljs-title class_">Collections</span>.<span class="hljs-title function_">unmodifiableMap</span>(<span class="hljs-title function_">getErrorAttributes</span>(request, <span class="hljs-title function_">getErrorAttributeOptions</span>(request, <span class="hljs-title class_">MediaType</span>.<span class="hljs-property">TEXT_HTML</span>)));response.<span class="hljs-title function_">setStatus</span>(status.<span class="hljs-title function_">value</span>());<span class="hljs-title class_">ModelAndView</span> modelAndView = <span class="hljs-title function_">resolveErrorView</span>(request, response, status, model);<span class="hljs-keyword">return</span> (modelAndView != <span class="hljs-literal">null</span>) ? modelAndView : <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;error&quot;</span>, model);&#125;<span class="hljs-meta">@RequestMapping</span>  <span class="hljs-comment">//返回 ResponseEntity, JSON</span><span class="hljs-keyword">public</span> <span class="hljs-title class_">ResponseEntity</span>&lt;<span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Object</span>&gt;&gt; <span class="hljs-title function_">error</span>(<span class="hljs-params">HttpServletRequest request</span>) &#123;<span class="hljs-title class_">HttpStatus</span> status = <span class="hljs-title function_">getStatus</span>(request);<span class="hljs-keyword">if</span> (status == <span class="hljs-title class_">HttpStatus</span>.<span class="hljs-property">NO_CONTENT</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseEntity</span>&lt;&gt;(status);&#125;<span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Object</span>&gt; body = <span class="hljs-title function_">getErrorAttributes</span>(request, <span class="hljs-title function_">getErrorAttributeOptions</span>(request, <span class="hljs-title class_">MediaType</span>.<span class="hljs-property">ALL</span>));<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseEntity</span>&lt;&gt;(body, status);&#125;</code></pre></div></li><li><p>错误页面是这么解析到的</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1、解析错误的自定义视图地址</span><span class="hljs-type">ModelAndView</span> <span class="hljs-variable">modelAndView</span> <span class="hljs-operator">=</span> resolveErrorView(request, response, status, model);<span class="hljs-comment">//2、如果解析不到错误页面的地址，默认的错误页就是 error</span><span class="hljs-keyword">return</span> (modelAndView != <span class="hljs-literal">null</span>) ? modelAndView : <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;error&quot;</span>, model);</code></pre></div><p>容器中专门有一个错误视图解析器 </p><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@Bean</span><span class="hljs-variable">@ConditionalOnBean</span>(DispatcherServlet.class)<span class="hljs-variable">@ConditionalOnMissingBean</span>(ErrorViewResolver.class)DefaultErrorViewResolver <span class="hljs-built_in">conventionErrorViewResolver</span>() &#123;    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">DefaultErrorViewResolver</span>(this.applicationContext, this.resources);&#125;</code></pre></div><p>SpringBoot解析自定义错误页的默认规则</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-title class_">ModelAndView</span> <span class="hljs-title function_">resolveErrorView</span>(<span class="hljs-params">HttpServletRequest request, HttpStatus status, <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; model</span>) &#123;<span class="hljs-title class_">ModelAndView</span> modelAndView = <span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">String</span>.<span class="hljs-title function_">valueOf</span>(status.<span class="hljs-title function_">value</span>()), model);<span class="hljs-keyword">if</span> (modelAndView == <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-variable constant_">SERIES_VIEWS</span>.<span class="hljs-title function_">containsKey</span>(status.<span class="hljs-title function_">series</span>())) &#123;modelAndView = <span class="hljs-title function_">resolve</span>(<span class="hljs-variable constant_">SERIES_VIEWS</span>.<span class="hljs-title function_">get</span>(status.<span class="hljs-title function_">series</span>()), model);&#125;<span class="hljs-keyword">return</span> modelAndView;&#125;<span class="hljs-keyword">private</span> <span class="hljs-title class_">ModelAndView</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> viewName, <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; model</span>) &#123;<span class="hljs-title class_">String</span> errorViewName = <span class="hljs-string">&quot;error/&quot;</span> + viewName;<span class="hljs-title class_">TemplateAvailabilityProvider</span> provider = <span class="hljs-variable language_">this</span>.<span class="hljs-property">templateAvailabilityProviders</span>.<span class="hljs-title function_">getProvider</span>(errorViewName,<span class="hljs-variable language_">this</span>.<span class="hljs-property">applicationContext</span>);<span class="hljs-keyword">if</span> (provider != <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(errorViewName, model);&#125;<span class="hljs-keyword">return</span> <span class="hljs-title function_">resolveResource</span>(errorViewName, model);&#125;<span class="hljs-keyword">private</span> <span class="hljs-title class_">ModelAndView</span> <span class="hljs-title function_">resolveResource</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> viewName, <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; model</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-title class_">String</span> location : <span class="hljs-variable language_">this</span>.<span class="hljs-property">resources</span>.<span class="hljs-title function_">getStaticLocations</span>()) &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-title class_">Resource</span> resource = <span class="hljs-variable language_">this</span>.<span class="hljs-property">applicationContext</span>.<span class="hljs-title function_">getResource</span>(location);resource = resource.<span class="hljs-title function_">createRelative</span>(viewName + <span class="hljs-string">&quot;.html&quot;</span>);<span class="hljs-keyword">if</span> (resource.<span class="hljs-title function_">exists</span>()) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlResourceView</span>(resource), model);&#125;&#125;<span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> ex) &#123;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;</code></pre></div><p>容器中有一个默认的名为 error 的 view； 提供了默认白页功能</p><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@Bean</span>(name = <span class="hljs-string">&quot;error&quot;</span>)<span class="hljs-variable">@ConditionalOnMissingBean</span>(name = <span class="hljs-string">&quot;error&quot;</span>)public View <span class="hljs-built_in">defaultErrorView</span>() &#123;    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.defaultErrorView</span>;&#125;</code></pre></div><p>封装了JSON格式的错误信息</p><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@Bean</span><span class="hljs-variable">@ConditionalOnMissingBean</span>(value = ErrorAttributes.class, search = SearchStrategy.CURRENT)public DefaultErrorAttributes <span class="hljs-built_in">errorAttributes</span>() &#123;<span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">DefaultErrorAttributes</span>();&#125;</code></pre></div><p>规则：</p></li></ul><ol><li><strong>解析一个错误页</strong><ol><li>如果发生了500、404、503、403 这些错误<ol><li>如果有<strong>模板引擎</strong>，默认在 classpath:&#x2F;templates&#x2F;error&#x2F;<strong>精确码.html</strong></li><li>如果没有模板引擎，在静态资源文件夹下找 <strong>精确码.html</strong></li></ol></li><li>如果匹配不到精确码.html这些精确的错误页，就去找5xx.html，4xx.html<strong>模糊匹配</strong><ol><li>如果有模板引擎，默认在 classpath:&#x2F;templates&#x2F;error&#x2F;5xx.html</li><li>如果没有模板引擎，在静态资源文件夹下找 5xx.html</li></ol></li></ol></li><li>如果模板引擎路径templates下有 error.html页面，就直接渲染</li></ol><h2 id="2-自定义错误响应"><a href="#2-自定义错误响应" class="headerlink" title="2. 自定义错误响应"></a>2. 自定义错误响应</h2><h3 id="1-自定义json响应"><a href="#1-自定义json响应" class="headerlink" title="1. 自定义json响应"></a>1. 自定义json响应</h3><p>使用@ControllerAdvice + @ExceptionHandler 进行统一异常处理</p><h3 id="2-自定义页面响应"><a href="#2-自定义页面响应" class="headerlink" title="2. 自定义页面响应"></a>2. 自定义页面响应</h3><p>根据boot的错误页面规则，自定义页面模板</p><h2 id="3-最佳实战"><a href="#3-最佳实战" class="headerlink" title="3. 最佳实战"></a>3. 最佳实战</h2><ul><li><strong>前后分离</strong><ul><li>后台发生的所有错误，@ControllerAdvice + @ExceptionHandler进行统一异常处理。</li></ul></li><li><h2 id="服务端页面渲染-不可预知的一些，HTTP码表示的服务器或客户端错误-给classpath-templates-error-下面，放常用精确的错误码页面。500-html，404-html-给classpath-templates-error-下面，放通用模糊匹配的错误码页面。-5xx-html，4xx-html-发生业务错误-核心业务，每一种错误，都应该代码控制，跳转到自己定制的错误页。-通用业务，classpath-templates-error-html页面，显示错误信息（可以通过在错误页面中添加-trance-来显示错误堆栈信息）。"><a href="#服务端页面渲染-不可预知的一些，HTTP码表示的服务器或客户端错误-给classpath-templates-error-下面，放常用精确的错误码页面。500-html，404-html-给classpath-templates-error-下面，放通用模糊匹配的错误码页面。-5xx-html，4xx-html-发生业务错误-核心业务，每一种错误，都应该代码控制，跳转到自己定制的错误页。-通用业务，classpath-templates-error-html页面，显示错误信息（可以通过在错误页面中添加-trance-来显示错误堆栈信息）。" class="headerlink" title="服务端页面渲染 - 不可预知的一些，HTTP码表示的服务器或客户端错误    - 给classpath:&#x2F;templates&#x2F;error&#x2F;下面，放常用精确的错误码页面。500.html，404.html    - 给classpath:&#x2F;templates&#x2F;error&#x2F;下面，放通用模糊匹配的错误码页面。 5xx.html，4xx.html - 发生业务错误    - 核心业务，每一种错误，都应该代码控制，跳转到自己定制的错误页。    - 通用业务，classpath:&#x2F;templates&#x2F;error.html页面，显示错误信息（可以通过在错误页面中添加[[${trance}]]来显示错误堆栈信息）。"></a><strong>服务端页面渲染</strong><br> - <strong>不可预知的一些，HTTP码表示的服务器或客户端错误</strong><br>    - 给classpath:&#x2F;templates&#x2F;error&#x2F;下面，放常用精确的错误码页面。500.html，404.html<br>    - 给classpath:&#x2F;templates&#x2F;error&#x2F;下面，放通用模糊匹配的错误码页面。 5xx.html，4xx.html<br> - <strong>发生业务错误</strong><br>    - <strong>核心业务</strong>，每一种错误，都应该代码控制，<strong>跳转到自己定制的错误页</strong>。<br>    - <strong>通用业务</strong>，classpath:&#x2F;templates&#x2F;error.html页面，<strong>显示错误信息（可以通过在错误页面中添加[[${trance}]]来显示错误堆栈信息）</strong>。</h2></li></ul><p>页面，JSON，可用的Model数据如下<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681724501227-077073b7-349d-414f-8916-a822eb86c772.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_26,text_5bCa56GF6LC3IGF0Z3VpZ3UuY29t,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#averageHue=%23f5f4f3&from=url&id=PNxJP&originHeight=196&originWidth=919&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="8-嵌入式容器"><a href="#8-嵌入式容器" class="headerlink" title="8. 嵌入式容器"></a>8. 嵌入式容器</h1><p><strong>Servlet容器</strong>：管理、运行<strong>Servlet组件</strong>（Servlet、Filter、Listener）的环境，一般指<strong>服务器</strong></p><h2 id="1-自动配置原理"><a href="#1-自动配置原理" class="headerlink" title="1. 自动配置原理"></a>1. 自动配置原理</h2><ul><li>SpringBoot 默认嵌入Tomcat作为Servlet容器。</li><li><strong>自动配置类</strong>是ServletWebServerFactoryAutoConfiguration，EmbeddedWebServerFactoryCustomizerAutoConfiguration</li><li>自动配置类开始分析功能。<code>xxxxAutoConfiguration</code><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@AutoConfiguration</span><span class="hljs-variable">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE)<span class="hljs-variable">@ConditionalOnClass</span>(ServletRequest.class)<span class="hljs-comment">//@ConditionOn表示满足这些条件才将该类加载到容器中</span><span class="hljs-variable">@ConditionalOnWebApplication</span>(type = Type.SERVLET)<span class="hljs-variable">@EnableConfigurationProperties</span>(ServerProperties.class)<span class="hljs-variable">@Import</span>(&#123; ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,ServletWebServerFactoryConfiguration.EmbeddedJetty.class,ServletWebServerFactoryConfiguration.EmbeddedUndertow.class &#125;)public class ServletWebServerFactoryAutoConfiguration &#123;    &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@AutoConfiguration</span>：该注解表示这是一个自动配置类，用于自动配置应用程序的某些功能或组件。<span class="hljs-variable">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE)：该注解指定了自动配置类的优先级，使用 Ordered.HIGHEST_PRECEDENCE 表示具有最高优先级。优先级较高的自动配置类将在启动过程中优先加载和应用。<span class="hljs-variable">@ConditionalOnClass</span>(ServletRequest.class)：该注解表示只有当类路径上存在 ServletRequest 类时，才会加载和应用该自动配置类。也就是说，只有当 Servlet 相关的类存在时，该自动配置类才会生效。<span class="hljs-variable">@ConditionalOnWebApplication</span>(type = Type.SERVLET)：该注解表示只有当应用程序类型为 ServletWeb 应用时，才会加载和应用该自动配置类。这意味着该自动配置类仅适用于基于 Servlet 的 Web 应用程序，而不适用于其他类型的应用程序。web程序除了servlet外还有其他的，比如：响应式，JSP等。关于 Servlet 的特点，以下是一些主要的特点：平台无关性：Servlet 是基于 Java 技术的，可以在任何支持 Java 的平台上运行，无论是 Windows、Linux 还是其他操作系统。可移植性：Servlet 可以在不同的 Web 容器中运行，例如 Tomcat、Jetty、WebLogic 等。这使得开发人员可以在不同的容器中部署和运行 Servlet，而不需要修改代码。<span class="hljs-variable">@EnableConfigurationProperties</span>(ServerProperties.class)：用于启用配置属性的绑定并将其注入到Spring 容器中。在这种情况下，ServerProperties 类的配置属性将被绑定到该自动配置类中。其中ServerProperties 类被<span class="hljs-variable">@ConfigurationProperties</span>(    prefix = <span class="hljs-string">&quot;server&quot;</span>,    ignoreUnknownFields = true)修饰，<span class="hljs-variable">@ConfigurationProperties</span> 是一个注解，用于将配置属性绑定到一个类上。在上述代码中，它被应用在类级别上，表示将配置属性绑定到带有 prefix 前缀的属性上，并且忽略未知的字段。但是其ServerProperties 类在此时并未注入到容器中。<span class="hljs-variable">@Import</span>(&#123; ... &#125;)：该注解用于导入其他的配置类或组件。在这个例子中，它导入了与 Servlet Web服务器工厂相关的配置类，包括 Tomcat、Jetty 和 Undertow 的配置。</code></pre></div></li></ul><ol><li>ServletWebServerFactoryAutoConfiguration 自动配置了嵌入式容器场景</li><li>绑定了ServerProperties配置类，所有和服务器有关的配置 server（也就是配置文件·中以server开头的配置属性是关于服务器的）</li><li>ServletWebServerFactoryAutoConfiguration 导入了 嵌入式的三大服务器 Tomcat、Jetty、Undertow</li></ol><p>1.servlet不仅支持Tomcat服务器还支持Jetty ，Netty，Undertow服务器<br>2.</p><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@ConditionalOnClass</span>(&#123;Servlet.class, Tomcat.class, UpgradeProtocol.class&#125;)    <span class="hljs-variable">@ConditionalOnMissingBean</span>(        value = &#123;ServletWebServerFactory.class&#125;,        search = SearchStrategy.CURRENT    )    static class EmbeddedTomcat &#123;        <span class="hljs-selector-tag">EmbeddedTomcat</span>() &#123;        &#125;<span class="hljs-variable">@ConditionalOnClass</span>(&#123;Servlet.class, Tomcat.class, UpgradeProtocol.class&#125;)决定了web程序的服务器类型，而避免了其他类型的服务器。</code></pre></div><ol><li><p>导入 Tomcat、Jetty、Undertow 都有条件注解。系统中有这个类才行（也就是导了包）也是这种方式决定了web程序采用的服务器类型。</p></li><li><p>默认 Tomcat配置生效。给容器中放 TomcatServletWebServerFactory</p></li><li><p>都给容器中 ServletWebServerFactory放了一个** web服务器工厂（造web服务器的）可以在ServletWebServerFactoryAutoConfiguration类中查看到注入了不同的 ServletWebServerFactory**</p><div class="code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-meta">@Bean</span>       TomcatServletWebServerFactory tomcatServletWebServerFactory</code></pre></div></li><li><p><strong>web服务器工厂 都有一个功能，</strong>getWebServer获取web服务器。其中TomcatServletWebServerFactory 创建了tomcat而其他服务器工厂没有创建。</p></li><li><p>TomcatServletWebServerFactory 创建了 tomcat。</p></li><li><p>ServletWebServerFactory 什么时候会创建 webServer出来。</p></li><li><p>ServletWebServerApplicationContextioc容器，启动的时候会调用创建web服务器</p></li><li><p>Spring<strong>容器刷新（启动）</strong>的时候，会预留一个时机，刷新子容器。onRefresh()</p></li><li><p>refresh() 容器刷新 十二大步的刷新子容器会调用 onRefresh()；</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onRefresh</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">super</span>.<span class="hljs-title function_">onRefresh</span>();<span class="hljs-keyword">try</span> &#123;<span class="hljs-title function_">createWebServer</span>();&#125;<span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Throwable</span> ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationContextException</span>(<span class="hljs-string">&quot;Unable to start web server&quot;</span>, ex);&#125;&#125;</code></pre></div><p>Web场景的Spring容器启动，在onRefresh的时候，会调用创建web服务器的方法。<br>Web服务器的创建是通过WebServerFactory搞定的。容器中又会根据导了什么包条件注解，启动相关的 服务器配置，默认EmbeddedTomcat会给容器中放一个 TomcatServletWebServerFactory，导致项目启动，自动创建出Tomcat。<br>用法：<br>1.修改server下的相关配置就可以修改服务器的参数<br>2.通过给容器中放一个ServletWebServerFactory,来禁用掉springBoot默认配置的服务器工厂，实现自定义的嵌入式服务器。</p></li></ol><h2 id="2-自定义"><a href="#2-自定义" class="headerlink" title="2. 自定义"></a>2. 自定义</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681725850466-2ecf12f4-8b66-469f-9d5d-377a33923b3c.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_19,text_5bCa56GF6LC3IGF0Z3VpZ3UuY29t,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#averageHue=%23ceae84&from=url&id=W0Ot4&originHeight=268&originWidth=668&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-api.version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-api.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-comment">&lt;!-- Exclude the Tomcat dependency --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- Use Jetty instead --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h2 id="3-最佳实践"><a href="#3-最佳实践" class="headerlink" title="3. 最佳实践"></a>3. 最佳实践</h2><p><strong>用法：</strong></p><ul><li>修改server下的相关配置就可以修改<strong>服务器参数</strong></li><li>通过给容器中放一个<strong>ServletWebServerFactory</strong>，来禁用掉SpringBoot默认放的服务器工厂，实现自定义嵌入<strong>任意服务器</strong>。</li></ul><h1 id="9-全面接管SpringMVC"><a href="#9-全面接管SpringMVC" class="headerlink" title="9. 全面接管SpringMVC"></a>9. 全面接管SpringMVC</h1><ul><li>SpringBoot 默认配置好了 SpringMVC 的所有常用特性。</li><li>如果我们需要全面接管SpringMVC的所有配置并<strong>禁用默认配置</strong>，仅需要编写一个WebMvcConfigurer配置类，并标注 @EnableWebMvc 即可</li><li>全手动模式<ul><li>@EnableWebMvc : 禁用默认配置，该注解在@Configuration上</li><li><strong>WebMvcConfigurer</strong>组件：定义MVC的底层行为</li></ul></li></ul><h2 id="1-WebMvcAutoConfiguration-到底自动配置了哪些规则"><a href="#1-WebMvcAutoConfiguration-到底自动配置了哪些规则" class="headerlink" title="1. WebMvcAutoConfiguration 到底自动配置了哪些规则"></a>1. WebMvcAutoConfiguration 到底自动配置了哪些规则</h2><p>SpringMVC自动配置场景给我们配置了如下所有<strong>默认行为</strong></p><ol><li>WebMvcAutoConfigurationweb场景的自动配置类<ol><li>支持RESTful的filter：HiddenHttpMethodFilter(HiddenHttpMethodFilter 的作用就是检查通过 POST 请求提交的表单数据中是否包含名为 _method 的隐藏字段，并将其值作为实际的 HTTP 方法进行处理。也就是新增了delete,和patch)</li><li>支持非POST请求，请求体携带数据：FormContentFilter(FormContentFilter 的作用是解析请求体中的表单数据，并将其转换为相应的请求参数，以便后续的处理器（Handler）能够方便地获取和使用这些参数。)</li><li>导入<strong>EnableWebMvcConfiguration</strong>：<ol><li>RequestMappingHandlerAdapter</li><li>WelcomePageHandlerMapping： <strong>欢迎页功能</strong>支持（模板引擎目录、静态资源目录放index.html），项目访问&#x2F; 就默认展示这个页面.</li><li>RequestMappingHandlerMapping：找每个请求由谁处理的映射关系</li><li>ExceptionHandlerExceptionResolver：默认的异常解析器 </li><li>LocaleResolver：国际化解析器</li><li>ThemeResolver：主题解析器</li><li>FlashMapManager：临时数据共享</li><li>FormattingConversionService： 数据格式化 、类型转化</li><li>Validator： 数据校验JSR303提供的数据校验功能</li><li>WebBindingInitializer：请求参数的封装与绑定</li><li>ContentNegotiationManager：内容协商管理器</li></ol></li><li><strong>WebMvcAutoConfigurationAdapter</strong>配置生效，它是一个WebMvcConfigurer，定义mvc底层组件<ol><li>定义好 WebMvcConfigurer<strong>底层组件默认功能；所有功能详见列表</strong></li><li>视图解析器：InternalResourceViewResolver</li><li>视图解析器：BeanNameViewResolver,<strong>视图名（controller方法的返回值字符串）</strong>就是组件名</li><li>内容协商解析器：ContentNegotiatingViewResolver</li><li>请求上下文过滤器：RequestContextFilter: 任意位置直接获取当前请求</li><li>静态资源链规则</li><li>ProblemDetailsExceptionHandler：错误详情<ol><li>SpringMVC内部场景异常被它捕获：</li></ol></li></ol></li><li>定义了MVC默认的底层行为: WebMvcConfigurer</li></ol></li></ol><h2 id="2-EnableWebMvc-禁用默认行为"><a href="#2-EnableWebMvc-禁用默认行为" class="headerlink" title="2. @EnableWebMvc 禁用默认行为"></a>2. @EnableWebMvc 禁用默认行为</h2><ol><li>@EnableWebMvc给容器中导入 DelegatingWebMvcConfiguration组件，</li></ol><p>他是 WebMvcConfigurationSupport</p><ol><li>WebMvcAutoConfiguration有一个核心的条件注解, @ConditionalOnMissingBean(WebMvcConfigurationSupport.class)，容器中没有WebMvcConfigurationSupport，WebMvcAutoConfiguration才生效.</li><li>@EnableWebMvc 导入 WebMvcConfigurationSupport 导致 WebMvcAutoConfiguration 失效。导致禁用了默认行为</li></ol><ul><li>@EnableWebMVC 禁用了 Mvc的自动配置</li><li>WebMvcConfigurer 定义SpringMVC底层组件的功能类</li></ul><p></p><h2 id="2-WebMvcConfigurer-功能"><a href="#2-WebMvcConfigurer-功能" class="headerlink" title="2. WebMvcConfigurer 功能"></a>2. WebMvcConfigurer 功能</h2><p>定义扩展SpringMVC底层功能</p><table><thead><tr><th>提供方法</th><th>核心参数</th><th>功能</th><th>默认</th></tr></thead><tbody><tr><td>addFormatters</td><td>FormatterRegistry</td><td><strong>格式化器</strong>：支持属性上@NumberFormat和@DatetimeFormat的数据类型转换</td><td>GenericConversionService</td></tr><tr><td>getValidator</td><td>无</td><td><strong>数据校验</strong>：校验 Controller 上使用@Valid标注的参数合法性。需要导入starter-validator</td><td>无</td></tr><tr><td>addInterceptors</td><td>InterceptorRegistry</td><td><strong>拦截器</strong>：拦截收到的所有请求</td><td>无</td></tr><tr><td>configureContentNegotiation</td><td>ContentNegotiationConfigurer</td><td><strong>内容协商</strong>：支持多种数据格式返回。需要配合支持这种类型的HttpMessageConverter</td><td>支持 json</td></tr><tr><td>configureMessageConverters</td><td>List&lt;HttpMessageConverter&lt;?&gt;&gt;</td><td><strong>消息转换器</strong>：标注@ResponseBody的返回值会利用MessageConverter直接写出去</td><td>8 个，支持byte，string,multipart,resource，json</td></tr><tr><td>addViewControllers</td><td>ViewControllerRegistry</td><td><strong>视图映射</strong>：直接将请求路径与物理视图映射。用于无 java 业务逻辑的直接视图页渲染</td><td>无</td></tr><tr><td><a href="mvc:view-controller">mvc:view-controller</a></td><td></td><td></td><td></td></tr><tr><td>configureViewResolvers</td><td>ViewResolverRegistry</td><td><strong>视图解析器</strong>：逻辑视图转为物理视图</td><td>ViewResolverComposite</td></tr><tr><td>addResourceHandlers</td><td>ResourceHandlerRegistry</td><td><strong>静态资源处理</strong>：静态资源路径映射、缓存控制</td><td>ResourceHandlerRegistry</td></tr><tr><td>configureDefaultServletHandling</td><td>DefaultServletHandlerConfigurer</td><td><strong>默认 Servlet</strong>：可以覆盖 Tomcat 的DefaultServlet。让DispatcherServlet拦截&#x2F;</td><td>无</td></tr><tr><td>configurePathMatch</td><td>PathMatchConfigurer</td><td><strong>路径匹配</strong>：自定义 URL 路径匹配。可以自动为所有路径加上指定前缀，比如 &#x2F;api</td><td>无</td></tr><tr><td>configureAsyncSupport</td><td>AsyncSupportConfigurer</td><td><strong>异步支持</strong>：</td><td>TaskExecutionAutoConfiguration</td></tr><tr><td>addCorsMappings</td><td>CorsRegistry</td><td><strong>跨域</strong>：</td><td>无</td></tr><tr><td>addArgumentResolvers</td><td>List<HandlerMethodArgumentResolver></td><td><strong>参数解析器</strong>：</td><td>mvc 默认提供</td></tr><tr><td>addReturnValueHandlers</td><td>List<HandlerMethodReturnValueHandler></td><td><strong>返回值解析器</strong>：</td><td>mvc 默认提供</td></tr><tr><td>configureHandlerExceptionResolvers</td><td>List<HandlerExceptionResolver></td><td><strong>异常处理器</strong>：</td><td>默认 3 个</td></tr><tr><td>ExceptionHandlerExceptionResolver</td><td></td><td></td><td></td></tr><tr><td>ResponseStatusExceptionResolver</td><td></td><td></td><td></td></tr><tr><td>DefaultHandlerExceptionResolver</td><td></td><td></td><td></td></tr><tr><td>getMessageCodesResolver</td><td>无</td><td><strong>消息码解析器</strong>：国际化使用</td><td>无</td></tr></tbody></table><h1 id="10-最佳实践"><a href="#10-最佳实践" class="headerlink" title="10. 最佳实践"></a>10. 最佳实践</h1><p>SpringBoot 已经默认配置好了<strong>Web开发</strong>场景常用功能。我们直接使用即可。</p><h2 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h2><table><thead><tr><th>方式</th><th>用法</th><th></th><th>效果</th></tr></thead><tbody><tr><td><strong>全自动</strong></td><td>直接编写控制器逻辑</td><td></td><td>全部使用<strong>自动配置默认效果</strong></td></tr><tr><td><strong>手自一体</strong></td><td>@Configuration +</td><td></td><td></td></tr><tr><td>配置<strong>WebMvcConfigurer</strong>+</td><td></td><td></td><td></td></tr><tr><td><em>配置 WebMvcRegistrations</em></td><td><strong>不要标注</strong></td><td></td><td></td></tr><tr><td>@<strong>EnableWebMvc</strong></td><td><strong>保留自动配置效果</strong></td><td></td><td></td></tr><tr><td><strong>手动设置部分功能</strong></td><td></td><td></td><td></td></tr><tr><td>定义MVC底层组件</td><td></td><td></td><td></td></tr><tr><td><strong>全手动</strong></td><td>@Configuration +</td><td></td><td></td></tr><tr><td>配置<strong>WebMvcConfigurer</strong></td><td><strong>标注</strong></td><td></td><td></td></tr><tr><td>@<strong>EnableWebMvc</strong></td><td><strong>禁用自动配置效果</strong></td><td></td><td></td></tr><tr><td><strong>全手动设置</strong></td><td></td><td></td><td></td></tr></tbody></table><p>总结：<br><strong>给容器中写一个配置类@Configuration实现 WebMvcConfigurer但是不要标注 @EnableWebMvc注解，实现手自一体的效果。</strong></p><h1 id="11-Web新特性"><a href="#11-Web新特性" class="headerlink" title="11. Web新特性"></a>11. Web新特性</h1><h2 id="1-Problemdetails"><a href="#1-Problemdetails" class="headerlink" title="1. Problemdetails"></a>1. Problemdetails</h2><p>RFC 7807: <a href="https://www.rfc-editor.org/rfc/rfc7807">https://www.rfc-editor.org/rfc/rfc7807</a></p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">ProblemDetails</span> 是一种在Web API中表示错误和异常信息的规范化格式。它是根据RFC <span class="hljs-number">7807</span>规范定义的，旨在提供一种统一的方式来描述和传递错误信息。</code></pre></div><p><strong>错误信息</strong>返回新格式<br>原理：</p><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span>(proxyBeanMethods = false)<span class="hljs-comment">//配置过一个属性 spring.mvc.problemdetails.enabled=true才能让</span><span class="hljs-comment">//ProblemDetailsErrorHandlingConfiguration生效，其中spring.mvc.problemdetails.enabled</span><span class="hljs-comment">//默认是false的，也就是ProbleDetailsErroHandlingConfiguration默认是关闭的</span><span class="hljs-variable">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">&quot;spring.mvc.problemdetails&quot;</span>, name = <span class="hljs-string">&quot;enabled&quot;</span>, havingValue = <span class="hljs-string">&quot;true&quot;</span>)static class ProblemDetailsErrorHandlingConfiguration &#123;    <span class="hljs-variable">@Bean</span>    <span class="hljs-variable">@ConditionalOnMissingBean</span>(ResponseEntityExceptionHandler.class)    ProblemDetailsExceptionHandler <span class="hljs-built_in">problemDetailsExceptionHandler</span>() &#123;        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">ProblemDetailsExceptionHandler</span>();    &#125;&#125;</code></pre></div><ol><li><strong>ProblemDetailsExceptionHandler (被 @ControllerAdvice修饰的类）是一个 @ControllerAdvice集中处理系统异常,</strong></li><li><strong>ProblemDetailsExceptionHandler 继承</strong>ResponseEntityExceptionHandler ，而ResponseEntityExceptionHandler类有一个@ExceptionHandle注解用于修饰ResponseEntity<Object>类，其中@ExceptionHandle**处理以下异常。如果系统出现以下异常，会被SpringBoot支持以 **RFC 7807规范方式返回错误数据（但是该规范不是默认生效的）：</li></ol><p>使用@ExceptionHandler 注解时，您需要在方法中定义异常类型作为参数，并在方法体中编写相应的逻辑来处理该异常。当发生定义的异常时，Spring Boot将调用带有 @ExceptionHandler 注解的方法，并将异常传递给该方法进行处理。您可以在该方法中执行适当的操作，例如记录日志、返回自定义错误响应等。</p><div class="code-wrapper"><pre><code class="hljs stylus">@<span class="hljs-built_in">ExceptionHandler</span>(&#123;HttpRequestMethodNotSupportedException<span class="hljs-selector-class">.class</span>, <span class="hljs-comment">//请求方式不支持</span>HttpMediaTypeNotSupportedException<span class="hljs-selector-class">.class</span>,HttpMediaTypeNotAcceptableException<span class="hljs-selector-class">.class</span>,MissingPathVariableException<span class="hljs-selector-class">.class</span>,MissingServletRequestParameterException<span class="hljs-selector-class">.class</span>,MissingServletRequestPartException<span class="hljs-selector-class">.class</span>,ServletRequestBindingException<span class="hljs-selector-class">.class</span>,MethodArgumentNotValidException<span class="hljs-selector-class">.class</span>,NoHandlerFoundException<span class="hljs-selector-class">.class</span>,AsyncRequestTimeoutException<span class="hljs-selector-class">.class</span>,ErrorResponseException<span class="hljs-selector-class">.class</span>,ConversionNotSupportedException<span class="hljs-selector-class">.class</span>,TypeMismatchException<span class="hljs-selector-class">.class</span>,HttpMessageNotReadableException<span class="hljs-selector-class">.class</span>,HttpMessageNotWritableException<span class="hljs-selector-class">.class</span>,BindException<span class="hljs-selector-class">.class</span>&#125;)</code></pre></div><p>效果：也就是上面的ResponseEntity<Object>类处理异常的效果<br>默认响应错误的json。状态码 405</p><div class="code-wrapper"><pre><code class="hljs swift">&#123;    <span class="hljs-string">&quot;timestamp&quot;</span>: <span class="hljs-string">&quot;2023-04-18T11:13:05.515+00:00&quot;</span>,    <span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-number">405</span>,    <span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-string">&quot;Method Not Allowed&quot;</span>,    <span class="hljs-string">&quot;trace&quot;</span>: <span class="hljs-string">&quot;org.springframework.web.HttpRequestMethodNotSupportedException: Request method &#x27;POST&#x27; is not supported<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.handleNoMatch(RequestMappingInfoHandlerMapping.java:265)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.lookupHandlerMethod(AbstractHandlerMethodMapping.java:441)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.getHandlerInternal(AbstractHandlerMethodMapping.java:382)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getHandlerInternal(RequestMappingInfoHandlerMapping.java:126)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getHandlerInternal(RequestMappingInfoHandlerMapping.java:68)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.springframework.web.servlet.handler.AbstractHandlerMapping.getHandler(AbstractHandlerMapping.java:505)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.springframework.web.servlet.DispatcherServlet.getHandler(DispatcherServlet.java:1275)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:563)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:631)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:493)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:390)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1741)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>at java.base/java.lang.Thread.run(Thread.java:833)<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&quot;</span>,    <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;Method &#x27;POST&#x27; is not supported.&quot;</span>,    <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;/list&quot;</span>&#125;</code></pre></div><p>开启ProblemDetails返回, 使用新的MediaType<br><strong>Content-Type: application&#x2F;problem+json+ 额外扩展返回</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681816524680-e75cbe89-f90c-4ac4-8247-ec850308df65.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_29,text_5bCa56GF6LC3IGF0Z3VpZ3UuY29t,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#averageHue=%23fafaf9&from=url&id=xnTyF&originHeight=40&originWidth=1030&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=">**</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;about:blank&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Method Not Allowed&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">405</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;detail&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Method &#x27;POST&#x27; is not supported.&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;instance&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/list&quot;</span><span class="hljs-punctuation">&#125;</span></code></pre></div><h2 id="2-函数式Web"><a href="#2-函数式Web" class="headerlink" title="2. 函数式Web"></a><strong>2. 函数式Web</strong></h2><p><strong>SpringMVC 5.2 以后 允许我们使用函数式的方式，定义Web的请求处理流程。</strong><br><strong>函数式接口</strong><br><strong>Web请求处理的方式：</strong></p><ol><li><strong>@Controller + @RequestMapping：耦合式 （路由、业务耦合）</strong></li><li><strong>函数式Web：分离式（路由、业务分离）</strong></li></ol><h3 id="1-场景"><a href="#1-场景" class="headerlink" title="1. 场景"></a>1. 场景</h3><p>场景：User RESTful - CRUD</p><ul><li>GET &#x2F;user&#x2F;1 获取1号用户</li><li>GET &#x2F;users 获取所有用户</li><li>POST &#x2F;user ** 请求体**携带JSON，新增一个用户</li><li>PUT &#x2F;user&#x2F;1 <strong>请求体</strong>携带JSON，修改1号用户</li><li>DELETE &#x2F;user&#x2F;1** 删除**1号用户</li></ul><h3 id="2-核心类"><a href="#2-核心类" class="headerlink" title="2. 核心类"></a>2. 核心类</h3><ul><li><strong>RouterFunction</strong></li><li><strong>RequestPredicate</strong></li><li><strong>ServerRequest</strong></li><li><strong>ServerResponse</strong></li></ul><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.http.MediaType;<span class="hljs-keyword">import</span> org.springframework.web.servlet.<span class="hljs-keyword">function</span>.RequestPredicate;<span class="hljs-keyword">import</span> org.springframework.web.servlet.<span class="hljs-keyword">function</span>.RouterFunction;<span class="hljs-keyword">import</span> org.springframework.web.servlet.<span class="hljs-keyword">function</span>.ServerResponse;<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.web.servlet.<span class="hljs-keyword">function</span>.RequestPredicates.accept;<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.web.servlet.<span class="hljs-keyword">function</span>.RouterFunctions.route;<span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-literal">false</span>)<span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRoutingConfiguration</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> RequestPredicate ACCEPT_JSON = accept(MediaType.APPLICATION_JSON);    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> RouterFunction&lt;ServerResponse&gt; routerFunction(MyUserHandler userHandler) &#123;        <span class="hljs-keyword">return</span> route()                .GET(<span class="hljs-string">&quot;/&#123;user&#125;&quot;</span>, ACCEPT_JSON, userHandler:<span class="hljs-type"></span>:getUser)                .GET(<span class="hljs-string">&quot;/&#123;user&#125;/customers&quot;</span>, ACCEPT_JSON, userHandler:<span class="hljs-type"></span>:getUserCustomers)                .DELETE(<span class="hljs-string">&quot;/&#123;user&#125;&quot;</span>, ACCEPT_JSON, userHandler:<span class="hljs-type"></span>:deleteUser)                .build();    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">stereotype</span>.<span class="hljs-property">Component</span>;<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">web</span>.<span class="hljs-property">servlet</span>.<span class="hljs-property">function</span>.<span class="hljs-property">ServerRequest</span>;<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">web</span>.<span class="hljs-property">servlet</span>.<span class="hljs-property">function</span>.<span class="hljs-property">ServerResponse</span>;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyUserHandler</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ServerResponse</span> <span class="hljs-title function_">getUser</span>(<span class="hljs-params">ServerRequest request</span>) &#123;        ...        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ServerResponse</span>.<span class="hljs-title function_">ok</span>().<span class="hljs-title function_">build</span>();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ServerResponse</span> <span class="hljs-title function_">getUserCustomers</span>(<span class="hljs-params">ServerRequest request</span>) &#123;        ...        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ServerResponse</span>.<span class="hljs-title function_">ok</span>().<span class="hljs-title function_">build</span>();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ServerResponse</span> <span class="hljs-title function_">deleteUser</span>(<span class="hljs-params">ServerRequest request</span>) &#123;        ...        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ServerResponse</span>.<span class="hljs-title function_">ok</span>().<span class="hljs-title function_">build</span>();    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs pgsql">package com.atguigu.web.config;<span class="hljs-keyword">import</span> com.atguigu.web.bean.Person;<span class="hljs-keyword">import</span> com.atguigu.web.biz.UserBizHandler;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.<span class="hljs-keyword">Configuration</span>;<span class="hljs-keyword">import</span> org.springframework.http.MediaType;<span class="hljs-keyword">import</span> org.springframework.web.servlet.<span class="hljs-keyword">function</span>.RequestPredicates;<span class="hljs-keyword">import</span> org.springframework.web.servlet.<span class="hljs-keyword">function</span>.RouterFunction;<span class="hljs-keyword">import</span> org.springframework.web.servlet.<span class="hljs-keyword">function</span>.RouterFunctions;<span class="hljs-keyword">import</span> org.springframework.web.servlet.<span class="hljs-keyword">function</span>.ServerResponse;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @author lfy</span><span class="hljs-comment"> * @Description</span><span class="hljs-comment"> * @create 2023-04-18 21:46</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 场景：User RESTful - CRUD</span><span class="hljs-comment"> * ● GET /user/1  获取1号用户</span><span class="hljs-comment"> * ● GET /users   获取所有用户</span><span class="hljs-comment"> * ● POST /user  请求体携带JSON，新增一个用户</span><span class="hljs-comment"> * ● PUT /user/1 请求体携带JSON，修改1号用户</span><span class="hljs-comment"> * ● DELETE /user/1 删除1号用户</span><span class="hljs-comment"> */</span>@<span class="hljs-keyword">Configuration</span><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> WebFunctionConfig &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 函数式Web：</span><span class="hljs-comment">     * 1、给容器中放一个Bean：类型是 RouterFunction&lt;ServerResponse&gt;，集中所有路由信息</span><span class="hljs-comment">     * 2、每个业务准备一个自己的Handler</span><span class="hljs-comment">     *</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 核心四大对象</span><span class="hljs-comment">     * 1、RouterFunction： 定义路由信息。发什么请求，谁来处理</span><span class="hljs-comment">     * 2、RequestPredicate：定义请求规则：请求谓语。请求方式（GET、POST）、请求参数</span><span class="hljs-comment">     * 3、ServerRequest：  封装请求完整数据</span><span class="hljs-comment">     * 4、ServerResponse： 封装响应完整数据</span><span class="hljs-comment">     */</span>    @Bean//如果修饰在方法上，那么其方法的参数是从容器中获取的    <span class="hljs-built_in">public</span> RouterFunction&lt;ServerResponse&gt; userRoute(UserBizHandler userBizHandler<span class="hljs-comment">/*这个会被自动注入进来*/</span>)&#123;        <span class="hljs-keyword">return</span> RouterFunctions.route() //开始定义路由信息                .<span class="hljs-keyword">GET</span>(&quot;/user/&#123;id&#125;&quot;, RequestPredicates.accept(MediaType.<span class="hljs-keyword">ALL</span>), userBizHandler::getUser)                .<span class="hljs-keyword">GET</span>(&quot;/users&quot;, userBizHandler::getUsers)                .POST(&quot;/user&quot;, RequestPredicates.accept(MediaType.APPLICATION_JSON), userBizHandler::saveUser)                .PUT(&quot;/user/&#123;id&#125;&quot;, RequestPredicates.accept(MediaType.APPLICATION_JSON), userBizHandler::updateUser)                .<span class="hljs-keyword">DELETE</span>(&quot;/user/&#123;id&#125;&quot;, userBizHandler::deleteUser)                .build();    &#125;//    @Bean//    <span class="hljs-built_in">public</span> RouterFunction&lt;ServerResponse&gt; groupRoute(UserBizHandler userBizHandler<span class="hljs-comment">/*这个会被自动注入进来*/</span>)&#123;////        <span class="hljs-keyword">return</span> RouterFunctions.route() //开始定义路由信息//                .<span class="hljs-keyword">GET</span>(&quot;/user/&#123;id&#125;&quot;, RequestPredicates.accept(MediaType.<span class="hljs-keyword">ALL</span>), userBizHandler::getUser)//                .<span class="hljs-keyword">GET</span>(&quot;/users&quot;, userBizHandler::getUsers)//                .POST(&quot;/user&quot;, RequestPredicates.accept(MediaType.APPLICATION_JSON), userBizHandler::saveUser)//                .PUT(&quot;/user/&#123;id&#125;&quot;, RequestPredicates.accept(MediaType.APPLICATION_JSON), userBizHandler::updateUser)//                .<span class="hljs-keyword">DELETE</span>(&quot;/user/&#123;id&#125;&quot;, userBizHandler::deleteUser)//                .build();//    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.web.biz;<span class="hljs-keyword">import</span> com.atguigu.web.bean.Person;<span class="hljs-keyword">import</span> jakarta.servlet.ServletException;<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<span class="hljs-keyword">import</span> org.springframework.web.servlet.function.ServerRequest;<span class="hljs-keyword">import</span> org.springframework.web.servlet.function.ServerResponse;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lfy</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> 专门处理User有关的业务</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2023-04-18 21:55</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserBizHandler</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查询指定id的用户</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> ServerResponse <span class="hljs-title function_">getUser</span><span class="hljs-params">(ServerRequest request)</span> <span class="hljs-keyword">throws</span> Exception&#123;        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> request.pathVariable(<span class="hljs-string">&quot;id&quot;</span>);        log.info(<span class="hljs-string">&quot;查询 【&#123;&#125;】 用户信息，数据库正在检索&quot;</span>,id);        <span class="hljs-comment">//业务处理</span>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">1L</span>,<span class="hljs-string">&quot;哈哈&quot;</span>,<span class="hljs-string">&quot;aa@qq.com&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&quot;admin&quot;</span>);        <span class="hljs-comment">//构造响应</span>        <span class="hljs-keyword">return</span> ServerResponse                .ok()                .body(person);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取所有用户</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> ServerResponse <span class="hljs-title function_">getUsers</span><span class="hljs-params">(ServerRequest request)</span> <span class="hljs-keyword">throws</span> Exception&#123;        log.info(<span class="hljs-string">&quot;查询所有用户信息完成&quot;</span>);        <span class="hljs-comment">//业务处理</span>        List&lt;Person&gt; list = Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">1L</span>, <span class="hljs-string">&quot;哈哈&quot;</span>, <span class="hljs-string">&quot;aa@qq.com&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;admin&quot;</span>),                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">2L</span>, <span class="hljs-string">&quot;哈哈2&quot;</span>, <span class="hljs-string">&quot;aa2@qq.com&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-string">&quot;admin2&quot;</span>));        <span class="hljs-comment">//构造响应</span>        <span class="hljs-keyword">return</span> ServerResponse                .ok()                .body(list); <span class="hljs-comment">//凡是body中的对象，就是以前@ResponseBody原理。利用HttpMessageConverter 写出为json</span>    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 保存用户</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> ServerResponse <span class="hljs-title function_">saveUser</span><span class="hljs-params">(ServerRequest request)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;        <span class="hljs-comment">//提取请求体</span>        <span class="hljs-type">Person</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> request.body(Person.class);        log.info(<span class="hljs-string">&quot;保存用户信息：&#123;&#125;&quot;</span>,body);        <span class="hljs-keyword">return</span> ServerResponse.ok().build();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 更新用户</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> ServerResponse <span class="hljs-title function_">updateUser</span><span class="hljs-params">(ServerRequest request)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;        <span class="hljs-type">Person</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> request.body(Person.class);        log.info(<span class="hljs-string">&quot;保存用户信息更新: &#123;&#125;&quot;</span>,body);        <span class="hljs-keyword">return</span> ServerResponse.ok().build();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除用户</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> ServerResponse <span class="hljs-title function_">deleteUser</span><span class="hljs-params">(ServerRequest request)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> request.pathVariable(<span class="hljs-string">&quot;id&quot;</span>);        log.info(<span class="hljs-string">&quot;删除【&#123;&#125;】用户信息&quot;</span>,id);        <span class="hljs-keyword">return</span> ServerResponse.ok().build();    &#125;&#125;</code></pre></div><h1 id="3、SpringBoot3-数据访问"><a href="#3、SpringBoot3-数据访问" class="headerlink" title="3、SpringBoot3-数据访问"></a><strong>3、SpringBoot3-数据访问</strong></h1><p><strong>整合SSM场景SpringBoot 整合 Spring、SpringMVC、MyBatis 进行数据访问场景开发</strong><br>**创建SSM项目（在创建springboot的时候勾选要导入的包）：</p><p>**</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h2 id="2-配置数据源"><a href="#2-配置数据源" class="headerlink" title="2. 配置数据源"></a>2. 配置数据源</h2><div class="code-wrapper"><pre><code class="hljs stylus">spring<span class="hljs-selector-class">.datasource</span>.url=jdbc:mysql:<span class="hljs-comment">//192.168.200.100:3306/demo</span>spring<span class="hljs-selector-class">.datasource</span>.driver-class-name=com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.cj</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.Driver</span>spring<span class="hljs-selector-class">.datasource</span>.username=rootspring<span class="hljs-selector-class">.datasource</span>.password=<span class="hljs-number">123456</span>spring<span class="hljs-selector-class">.datasource</span>.type=com<span class="hljs-selector-class">.zaxxer</span><span class="hljs-selector-class">.hikari</span>.HikariDataSource</code></pre></div><p>安装MyBatisX 插件，帮我们生成Mapper接口的xml文件即可。MyBatisX的使用：<br>选中接口名-&gt;点击右键-&gt;选择显示上下文操作-&gt;选择MybatisX的功能<br>或者选中接口名Altet+Enter<br>在接口下的方法使用Alter+Enter可以生成相应的sql语句 片段</p><h2 id="3-配置MyBatis"><a href="#3-配置MyBatis" class="headerlink" title="3. 配置MyBatis"></a>3. 配置MyBatis</h2><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment">#指定mapper映射文件位置</span><span class="hljs-attr">mybatis.mapper-locations</span>=classpath:/mapper/*.xml<span class="hljs-comment">#参数项调整，也就是可以把数据库表中的下划线命名的属性转换为驼峰命名</span><span class="hljs-attr">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="hljs-literal">true</span></code></pre></div><h2 id="4-CRUD编写"><a href="#4-CRUD编写" class="headerlink" title="4. CRUD编写"></a><strong>4. CRUD编写</strong></h2><p>CRUD 是一个常用的术语，用于描述对于持久化数据的基本操作。CRUD 是 Create（创建）、Read（读取）、Update（更新）和Delete（删除）的缩写。</p><ul><li><strong>编写Bean</strong></li><li><strong>编写Mapper</strong></li><li><strong>使用mybatisx插件，快速生成MapperXML</strong></li><li><strong>测试CRUD</strong></li></ul><p><strong>总结：</strong><br><strong>1.</strong>@Data&#x2F;&#x2F;生成get和set方法<br><strong>2.controller类下的</strong><br>@Autowired&#x2F;&#x2F;下面的提示的来源是因为这个时候，UserMapper中的接口没有注入到容器中，是springboot启动利用@MapperScan才将该接口注入到容器中的<br>UserMapper userMapper**;<strong>3.mapper接口中的</strong><em>每个方法都在Mapper文件中有一个sql标签对应。所有参数都应该用@Param进行签名，以后使用指定的名字在SQL中取值</em><br>4.mapper.xml文件中的<mapper>标签namespace属性也就是全类名接口的全类名和namespace的值是一一对应的<br>5.使用mybatis对数据库进行操作的时候，在spriongboot启动类的前要添加MapperScan(basePackages &#x3D; “com.atguigu.boot3.ssm.mapper”)<br>_1、@MapperScan【批量扫描注解】； 告诉MyBatis，扫描哪个包下面的所有接口</p><ul><li><em>**</em>@MapperScan _**_是 MyBatis-Spring 框架提供的注解，用于扫描指定包下的 Mapper 接口，并将其注册为 Spring 的 Bean。</li><li>这样就可以在controller中使用自动注入</li><li>2、在配置文件中使用mybatis.mapper-locations，告诉MyBatis，每个接口的xml文件都在哪里_</li></ul><h2 id="5-自动配置原理"><a href="#5-自动配置原理" class="headerlink" title="5. 自动配置原理"></a><strong>5. 自动配置原理</strong></h2><p><strong>SSM整合总结：</strong></p><ol><li><strong>导入 mybatis-spring-boot-starter</strong></li><li><strong>配置数据源信息</strong></li><li><strong>配置mybatis的mapper接口扫描与xml映射文件扫描</strong></li><li><strong>编写bean，mapper，生成xml，编写sql 进行crud。事务等操作依然和Spring中用法一样</strong></li><li><strong>效果：</strong><ol><li><strong>所有sql写在xml中</strong></li><li><strong>所有mybatis配置写在application.properties下面</strong></li></ol></li></ol><ul><li>jdbc场景的自动配置： <ul><li><strong>mybatis-spring-boot-starter导入 spring-boot-starter-jdbc，jdbc是操作数据库的场景</strong></li><li><strong>Jdbc场景的几个自动配置()</strong><ul><li><strong>org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</strong><ul><li><strong>数据源的自动配置</strong></li><li><strong>所有和数据源有关的配置都绑定在DataSourceProperties类中</strong></li><li><strong>默认使用 HikariDataSource。</strong></li></ul></li><li><strong>org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration</strong><ul><li><strong>给容器中放了JdbcTemplate操作数据库</strong></li></ul></li><li><strong>org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration</strong></li><li><strong>org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration</strong><ul><li><strong>基于XA二阶提交协议的分布式事务数据源</strong></li></ul></li><li><strong>org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration</strong><ul><li><strong>支持事务</strong></li></ul></li></ul></li><li><strong>具有的底层能力：数据源、JdbcTemplate、事务</strong></li></ul></li><li>MyBatisAutoConfiguration：配置了MyBatis的整合流程<ul><li>mybatis-spring-boot-starter导入 mybatis-spring-boot-autoconfigure（mybatis的自动配置包），</li><li>默认加载两个自动配置类：<ul><li>org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration</li><li>org.mybatis.spring.boot.autoconfigure.<strong>MybatisAutoConfiguration</strong><ul><li><strong>必须在数据源配置好之后才配置</strong></li><li>给容器中SqlSessionFactory组件。创建和数据库的一次会话</li><li>给容器中SqlSessionTemplate组件。操作数据库</li></ul></li></ul></li><li><strong>MyBatis的所有配置绑定在</strong>MybatisProperties</li><li>每个<strong>Mapper接口</strong>的<strong>代理对象</strong>是怎么创建放到容器中。详见**@MapperScan**原理：<ul><li>利用@Import(MapperScannerRegistrar.class)批量给容器中注册组件。解析指定的包路径里面的每一个类，为每一个Mapper接口类，创建Bean定义信息，注册到容器中。</li></ul></li></ul></li></ul><p>如何分析哪个场景导入以后，开启了哪些自动配置类。<br>找：classpath:&#x2F;<strong>META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports</strong>文件中配置的所有值，就是要开启的自动配置类，但是每个类可能有条件注解，基于条件注解判断哪个自动配置类生效了。</p><h2 id="6-快速定位生效的配置"><a href="#6-快速定位生效的配置" class="headerlink" title="6. 快速定位生效的配置"></a>6. 快速定位生效的配置</h2><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment">#开启调试模式，详细打印开启了哪些自动配置</span><span class="hljs-attr">debug</span>=<span class="hljs-literal">true</span><span class="hljs-comment"># Positive（生效的自动配置）  Negative（不生效的自动配置）</span></code></pre></div><h2 id="7-扩展：整合其他数据源"><a href="#7-扩展：整合其他数据源" class="headerlink" title="7. 扩展：整合其他数据源"></a>7. 扩展：整合其他数据源</h2><h3 id="1-Druid-数据源"><a href="#1-Druid-数据源" class="headerlink" title="1. Druid 数据源"></a>1. Druid 数据源</h3><p>暂不支持 SpringBoot3</p><ul><li>导入druid-starter</li><li>写配置</li><li>分析自动配置了哪些东西，怎么用</li></ul><p>Druid官网：<a href="https://github.com/alibaba/druid">https://github.com/alibaba/druid</a></p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment">#数据源基本配置</span><span class="hljs-attr">spring.datasource.url</span>=jdbc:mysql://<span class="hljs-number">192.168</span>.<span class="hljs-number">200.100</span>:<span class="hljs-number">3306</span>/demo<span class="hljs-attr">spring.datasource.driver-class-name</span>=com.mysql.cj.jdbc.Driver<span class="hljs-attr">spring.datasource.username</span>=root<span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-number">123456</span><span class="hljs-attr">spring.datasource.type</span>=com.alibaba.druid.pool.DruidDataSource<span class="hljs-comment"># 配置StatFilter监控</span><span class="hljs-attr">spring.datasource.druid.filter.stat.enabled</span>=<span class="hljs-literal">true</span><span class="hljs-attr">spring.datasource.druid.filter.stat.db-type</span>=mysql<span class="hljs-attr">spring.datasource.druid.filter.stat.log-slow-sql</span>=<span class="hljs-literal">true</span><span class="hljs-attr">spring.datasource.druid.filter.stat.slow-sql-millis</span>=<span class="hljs-number">2000</span><span class="hljs-comment"># 配置WallFilter防火墙</span><span class="hljs-attr">spring.datasource.druid.filter.wall.enabled</span>=<span class="hljs-literal">true</span><span class="hljs-attr">spring.datasource.druid.filter.wall.db-type</span>=mysql<span class="hljs-attr">spring.datasource.druid.filter.wall.config.delete-allow</span>=<span class="hljs-literal">false</span><span class="hljs-attr">spring.datasource.druid.filter.wall.config.drop-table-allow</span>=<span class="hljs-literal">false</span><span class="hljs-comment"># 配置监控页，内置监控页面的首页是 /druid/index.html</span><span class="hljs-attr">spring.datasource.druid.stat-view-servlet.enabled</span>=<span class="hljs-literal">true</span><span class="hljs-attr">spring.datasource.druid.stat-view-servlet.login-username</span>=admin<span class="hljs-attr">spring.datasource.druid.stat-view-servlet.login-password</span>=admin<span class="hljs-attr">spring.datasource.druid.stat-view-servlet.allow</span>=*<span class="hljs-comment"># 其他 Filter 配置不再演示</span><span class="hljs-comment"># 目前为以下 Filter 提供了配置支持，请参考文档或者根据IDE提示（spring.datasource.druid.filter.*）进行配置。</span><span class="hljs-comment"># StatFilter</span><span class="hljs-comment"># WallFilter</span><span class="hljs-comment"># ConfigFilter</span><span class="hljs-comment"># EncodingConvertFilter</span><span class="hljs-comment"># Slf4jLogFilter</span><span class="hljs-comment"># Log4jFilter</span><span class="hljs-comment"># Log4j2Filter</span><span class="hljs-comment"># CommonsLogFilter</span></code></pre></div><h2 id="附录：示例数据库-要先自己创建test数据库）"><a href="#附录：示例数据库-要先自己创建test数据库）" class="headerlink" title="附录：示例数据库(要先自己创建test数据库）"></a><strong>附录：示例数据库(要先自己创建test数据库）</strong></h2><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_user`(    `id`         <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>)   <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;编号&#x27;</span>,    `login_name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;用户名称&#x27;</span> <span class="hljs-keyword">COLLATE</span> <span class="hljs-string">&#x27;utf8_general_ci&#x27;</span>,    `nick_name`  <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;用户昵称&#x27;</span> <span class="hljs-keyword">COLLATE</span> <span class="hljs-string">&#x27;utf8_general_ci&#x27;</span>,    `passwd`     <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;用户密码&#x27;</span> <span class="hljs-keyword">COLLATE</span> <span class="hljs-string">&#x27;utf8_general_ci&#x27;</span>,    <span class="hljs-keyword">PRIMARY KEY</span> (`id`));<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_user(login_name, nick_name, passwd) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-string">&#x27;123456&#x27;</span>);</code></pre></div><h1 id="4、SpringBoot3-基础特性"><a href="#4、SpringBoot3-基础特性" class="headerlink" title="4、SpringBoot3-基础特性"></a><strong>4、SpringBoot3-基础特性</strong></h1><ol><li>SpringApplication1.1. 自定义 banner类路径添加banner.txt或设置spring.banner.location就可以定制<br>这里是在配置文件中设置spring.banner.location&#x3D;classpath:banner.txt然后在banner.txt文件中填充即可。<br>banner.txt中可以存放Ascll类型的文本，当然图片生成的Ascall类型的也是可以的<br>banner推荐网站：<a href="https://www.bootschool.net/ascii"><strong>Spring Boot banner 在线生成工具，制作下载英文 banner.txt，修改替换 banner.txt 文字实现自定义，个性化启动 banner-bootschool.net</strong></a><br>**Spring Boot 中有一个名为 “Banner” 的功能，它用于在应用程序启动时显示自定义的启动横幅。横幅是一个包含 ASCII 艺术、应用程序名称和版本号等信息的文本，它可以用于个性化应用程序的启动过程。<br>上面的横幅就是启动成功的这个：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1691459425977-b78e1673-8a61-41ae-b1b0-d487510bd937.png#averageHue=%23383532&clientId=u8fdb1034-8532-4&from=paste&height=173&id=u65bf48e5&originHeight=216&originWidth=752&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=13871&status=done&style=none&taskId=u3dae8db9-32d1-451c-8898-afe829c3c40&title=&width=601.6" alt="image.png"></li></ol><h2 id="1-2-自定义-SpringApplication"><a href="#1-2-自定义-SpringApplication" class="headerlink" title="1.2. 自定义 SpringApplication"></a>1.2. 自定义 SpringApplication</h2><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">boot</span>.<span class="hljs-property">Banner</span>;<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">boot</span>.<span class="hljs-property">SpringApplication</span>;<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">boot</span>.<span class="hljs-property">autoconfigure</span>.<span class="hljs-property">SpringBootApplication</span>;<span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;        <span class="hljs-title class_">SpringApplication</span> application = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringApplication</span>(<span class="hljs-title class_">MyApplication</span>.<span class="hljs-property">class</span>);        application.<span class="hljs-title function_">setBannerMode</span>(<span class="hljs-title class_">Banner</span>.<span class="hljs-property">Mode</span>.<span class="hljs-property">OFF</span>);        application.<span class="hljs-title function_">run</span>(args);    &#125;&#125;</code></pre></div><h2 id="1-3-FluentBuilder-API"><a href="#1-3-FluentBuilder-API" class="headerlink" title="1.3. FluentBuilder API"></a>1.3. FluentBuilder API</h2><div class="code-wrapper"><pre><code class="hljs scss">new <span class="hljs-built_in">SpringApplicationBuilder</span>()    <span class="hljs-selector-class">.sources</span>(Parent.class)    <span class="hljs-selector-class">.child</span>(Application.class)    <span class="hljs-selector-class">.bannerMode</span>(Banner.Mode.OFF)    <span class="hljs-selector-class">.run</span>(args);</code></pre></div><div class="code-wrapper"><pre><code class="hljs php">@SpringBootApplication <span class="hljs-comment">//主程序类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">Boot306FeaturesApplication</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_ invoke__">main</span>(String[] args) &#123;        <span class="hljs-comment">//1、SpringApplication: Boot应用的核心API入口</span><span class="hljs-comment">//        SpringApplication.run(Boot306FeaturesApplication.class, args);</span><span class="hljs-comment">//        args是springboot应用启动的核心参数</span>        <span class="hljs-comment">//===============1、自定义 SpringApplication 的底层设置，也就是把SpringApplication.run(Boot306FeaturesApplication.class, args);</span><span class="hljs-comment">//        分开，生成SpringApplication类,然后根据SpringApplication类来自定义启动的相关设置</span><span class="hljs-comment">//        SpringApplication application = new SpringApplication(Boot306FeaturesApplication.class);</span><span class="hljs-comment">//</span><span class="hljs-comment">//        //程序化调整【SpringApplication的参数】</span><span class="hljs-comment">////        application.setDefaultProperties();</span><span class="hljs-comment">//        //这个配置不优先，作用是将banner的打印关闭。如果配置文件有类似的配置，配置文件优先</span><span class="hljs-comment">//        application.setBannerMode(Banner.Mode.OFF);</span><span class="hljs-comment">//</span><span class="hljs-comment">//</span><span class="hljs-comment">//        //【配置文件优先级高于程序化调整的优先级】</span><span class="hljs-comment">//</span><span class="hljs-comment">//        //2、SpringApplication 运行起来</span><span class="hljs-comment">//        application.run(args);</span>        <span class="hljs-comment">//================2、Builder方式构建 SpringApplication； 通过FluentAPI进行设置</span>        ConfigurableApplicationContext context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringApplicationBuilder</span>()                .<span class="hljs-title function_ invoke__">main</span>(Boot306FeaturesApplication.<span class="hljs-keyword">class</span>) <span class="hljs-comment">//各种参数均可设置</span>                .<span class="hljs-title function_ invoke__">sources</span>(Boot306FeaturesApplication.<span class="hljs-keyword">class</span>)                .<span class="hljs-title function_ invoke__">bannerMode</span>(Banner.Mode.CONSOLE)                .<span class="hljs-title function_ invoke__">properties</span>(<span class="hljs-string">&quot;server.port=8888&quot;</span>,<span class="hljs-string">&quot;aaa=bbb&quot;</span>) <span class="hljs-comment">//springboot所有配置项都可以在这里定义</span><span class="hljs-comment">//                .environment(null)</span><span class="hljs-comment">//                .listeners(null)</span>                .<span class="hljs-title function_ invoke__">run</span>(args);        <span class="hljs-keyword">try</span> &#123;            Cat cat = context.<span class="hljs-title function_ invoke__">getBean</span>(Cat.<span class="hljs-keyword">class</span>);            log.<span class="hljs-title function_ invoke__">info</span>(<span class="hljs-string">&quot;组件cat：&#123;&#125;&quot;</span>,cat);        &#125;<span class="hljs-keyword">catch</span> (<span class="hljs-built_in">Exception</span> e)&#123;        &#125;        <span class="hljs-keyword">try</span> &#123;            Dog dog = context.<span class="hljs-title function_ invoke__">getBean</span>(Dog.<span class="hljs-keyword">class</span>);            log.<span class="hljs-title function_ invoke__">info</span>(<span class="hljs-string">&quot;组件dog：&#123;&#125;&quot;</span>,dog);        &#125;<span class="hljs-keyword">catch</span> (<span class="hljs-built_in">Exception</span> e)&#123;        &#125;        <span class="hljs-keyword">try</span> &#123;            Pig pig = context.<span class="hljs-title function_ invoke__">getBean</span>(Pig.<span class="hljs-keyword">class</span>);            log.<span class="hljs-title function_ invoke__">info</span>(<span class="hljs-string">&quot;组件pig：&#123;&#125;&quot;</span>,pig);        &#125;<span class="hljs-keyword">catch</span> (<span class="hljs-built_in">Exception</span> e)&#123;        &#125;        <span class="hljs-keyword">try</span> &#123;            Sheep sheep = context.<span class="hljs-title function_ invoke__">getBean</span>(Sheep.<span class="hljs-keyword">class</span>);            log.<span class="hljs-title function_ invoke__">info</span>(<span class="hljs-string">&quot;组件sheep：&#123;&#125;&quot;</span>,sheep);        &#125;<span class="hljs-keyword">catch</span> (<span class="hljs-built_in">Exception</span> e)&#123;        &#125;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment">#指定banner文本的路径</span><span class="hljs-attr">spring.banner.location</span>=classpath:banner.txt<span class="hljs-comment">#关闭banner模式</span><span class="hljs-attr">spring.main.banner-mode</span>=<span class="hljs-literal">off</span></code></pre></div><h1 id="2-Profiles"><a href="#2-Profiles" class="headerlink" title="2. Profiles"></a>2. Profiles</h1><p>环境隔离能力；快速切换开发、测试、生产环境(最好的例子就是在开发，测试，生产所需要的数据库不一样，这个时候就需要自动切换数据库）<br>步骤：</p><ol><li><strong>标识环境</strong>：指定哪些组件、配置在哪个环境生效</li><li><strong>切换环境</strong>：这个环境对应的所有组件和配置就应该生效</li></ol><h2 id="2-1-使用"><a href="#2-1-使用" class="headerlink" title="2.1. 使用"></a>2.1. 使用</h2><h3 id="2-1-1-指定环境"><a href="#2-1-1-指定环境" class="headerlink" title="2.1.1 指定环境"></a><strong>2.1.1 指定环境</strong></h3><ul><li>Spring Profiles 提供一种<strong>隔离配置</strong>的方式，使其仅在<strong>特定环境</strong>生效；</li><li>任何@Component, @Configuration 或 @ConfigurationProperties 可以使用 @Profile 标记，来指定何时被加载。【<strong>容器中的组件</strong>都可以被 @Profile标记】</li></ul><h3 id="2-1-2-环境激活（也就是指定当前系统运行的特定环境）"><a href="#2-1-2-环境激活（也就是指定当前系统运行的特定环境）" class="headerlink" title="2.1.2 环境激活（也就是指定当前系统运行的特定环境）"></a><strong>2.1.2 环境激活（也就是指定当前系统运行的特定环境）</strong></h3><ol><li>配置激活指定环境； 配置文件</li></ol><p>spring.profiles.active&#x3D;production,hsqldb</p><ol><li>也可以使用命令行激活。–spring.profiles.active&#x3D;dev,hsqldb</li><li>还可以配置<strong>默认环境</strong>； 不标注@Profile 的组件永远都存在。<ol><li>以前默认环境叫default</li><li>spring.profiles.default&#x3D;test修改默认环境是test，变形激活了test环境</li></ol></li><li>推荐使用激活方式激活指定环境</li></ol><h3 id="2-1-3-环境包含"><a href="#2-1-3-环境包含" class="headerlink" title="2.1.3 环境包含"></a><strong>2.1.3 环境包含</strong></h3><p>注意：</p><ol><li>spring.profiles.active 和spring.profiles.default 只能用到** 无 profile 的文件<strong>中，如果在application-dev.yaml中编写就是</strong>无效的**</li><li>也可以额外添加生效文件，而不是激活替换。比如：<div class="code-wrapper"><pre><code class="hljs stylus">spring<span class="hljs-selector-class">.profiles</span><span class="hljs-selector-class">.include</span><span class="hljs-selector-attr">[0]</span>=commonspring<span class="hljs-selector-class">.profiles</span><span class="hljs-selector-class">.include</span><span class="hljs-selector-attr">[1]</span>=local</code></pre></div>最佳实战：</li></ol><ul><li>**生效的环境 **&#x3D; <strong>激活的环境&#x2F;默认环境</strong> + <strong>包含的环境</strong></li><li>项目里面这么用<ul><li>基础的配置mybatis、log、xxx：写到<strong>包含环境中</strong></li><li>需要动态切换变化的 db、redis：写到<strong>激活的环境中</strong></li></ul></li></ul><h2 id="2-2-Profile-分组"><a href="#2-2-Profile-分组" class="headerlink" title="2.2. Profile 分组"></a>2.2. Profile 分组</h2><p>创建prod组，指定包含db和mq配置</p><div class="code-wrapper"><pre><code class="hljs stylus">spring<span class="hljs-selector-class">.profiles</span><span class="hljs-selector-class">.group</span><span class="hljs-selector-class">.prod</span><span class="hljs-selector-attr">[0]</span>=dbspring<span class="hljs-selector-class">.profiles</span><span class="hljs-selector-class">.group</span><span class="hljs-selector-class">.prod</span><span class="hljs-selector-attr">[1]</span>=mq</code></pre></div><p>使用–spring.profiles.active&#x3D;prod ，就会激活prod，db，mq配置文件</p><h2 id="2-3-Profile-配置文件"><a href="#2-3-Profile-配置文件" class="headerlink" title="2.3. Profile 配置文件"></a>2.3. Profile 配置文件</h2><ul><li>application-{profile}.properties可以作为<strong>指定环境的配置文件</strong>。</li><li>激活这个环境，<strong>配置</strong>就会生效。最终生效的所有<strong>配置</strong>是<ul><li>application.properties：主配置文件，任意时候都生效</li><li>application-{profile}.properties：指定环境配置文件，激活指定环境生效</li></ul></li></ul><p>profile优先级 &gt; application </p><h1 id="3-外部化配置"><a href="#3-外部化配置" class="headerlink" title="3. 外部化配置"></a>3. 外部化配置</h1><p><strong>场景</strong>：线上应用如何<strong>快速修改配置</strong>，并应<strong>用最新配置</strong>？</p><ul><li>SpringBoot 使用 <strong>配置优先级</strong> + <strong>外部配置</strong> 简化配置更新、简化运维。</li><li>只需要给jar应用所在的文件夹放一个application.properties最新配置文件，重启项目就能自动应用最新配置</li></ul><h2 id="3-1-配置优先级"><a href="#3-1-配置优先级" class="headerlink" title="3.1. 配置优先级"></a>3.1. 配置优先级</h2><p>Spring Boot 允许将<strong>配置外部化</strong>，以便可以在不同的环境中使用相同的应用程序代码。<br>我们可以使用各种<strong>外部配置源</strong>，包括Java Properties文件、YAML文件、环境变量和命令行参数。<br>@Value可以获取值，也可以用@ConfigurationProperties将所有属性绑定到java object中<br><strong>以下是 SpringBoot 属性源加载顺序。后面的会覆盖前面的值</strong>。由低到高，高优先级配置覆盖低优先级</p><ol><li><strong>默认属性</strong>（通过SpringApplication.setDefaultProperties指定的）</li><li>@PropertySource指定加载的配置（需要写在@Configuration类上才可生效）,其中指定加载 类的文件一般是配置文件</li><li><strong>配置文件（application.properties&#x2F;yml等）</strong></li><li>RandomValuePropertySource支持的random.*配置（如：@Value(“${random.int}”)）</li><li>OS 环境变量</li><li>Java 系统属性（System.getProperties()）</li><li>JNDI 属性（来自java:comp&#x2F;env）</li><li>ServletContext初始化参数</li><li>ServletConfig初始化参数</li><li>SPRING_APPLICATION_JSON属性（内置在环境变量或系统属性中的 JSON）</li><li><strong>命令行参数</strong></li><li>测试属性。(@SpringBootTest进行测试时指定的属性)</li><li>测试类@TestPropertySource注解</li><li>Devtools 设置的全局属性。($HOME&#x2F;.config&#x2F;spring-boot)</li></ol><p>结论：配置可以写到很多位置，常见的优先级顺序：</p><ul><li>命令行&gt; 配置文件&gt; springapplication配置（可以这样理解程序运行的时候，先运行springboot启动程序的默认配置，然后读取配置文件，然后是命令行运行。相当于后面的配置信息会覆盖前面的，可以这样理解但是实际上并非是这样的）</li></ul><p><strong>配置文件优先级</strong>如下：(<strong>后面覆盖前面</strong>)</p><ol><li><strong>jar 包内</strong>的application.properties&#x2F;yml</li><li><strong>jar 包内</strong>的application-{profile}.properties&#x2F;yml</li><li><strong>jar 包外</strong>的application.properties&#x2F;yml</li><li><strong>jar 包外</strong>的application-{profile}.properties&#x2F;yml</li></ol><p><strong>建议</strong>：<strong>用一种格式的配置文件</strong>。<strong>如果.properties和.yml同时存在,则.properties优先</strong><br>结论：包外 &gt; 包内； 同级情况：profile配置 &gt; application配置<br><strong>所有参数均可由命令行传入，使用–参数项&#x3D;参数值，将会被添加到环境变量中，并优先于配置文件。</strong><br><strong>比如java -jar app.jar –name&#x3D;”Spring”,可以使用@Value(“${name}”)获取</strong></p><p>演示场景：</p><ul><li>包内： application.properties server.port&#x3D;8000</li><li>包内： application-dev.properties server.port&#x3D;9000</li><li>包外：  application.properties server.port&#x3D;8001</li><li>包外： application-dev.properties server.port&#x3D;9001</li></ul><p>启动端口？：命令行 &gt; 9001 &gt; 8001 &gt; 9000 &gt; 8000</p><h2 id="3-2-外部配置"><a href="#3-2-外部配置" class="headerlink" title="3.2. 外部配置"></a>3.2. 外部配置</h2><p>SpringBoot 应用启动时会自动寻找application.properties和application.yaml位置，进行加载。顺序如下：（<strong>后面覆盖前面</strong>）</p><ol><li>类路径: 内部<ol><li>类根路径</li><li>类下&#x2F;config包</li></ol></li><li>当前路径（项目所在的位置）<ol><li>当前路径</li><li>当前下&#x2F;config子目录</li><li>&#x2F;config目录的直接子目录</li></ol></li></ol><p>最终效果：优先级由高到低，前面覆盖后面</p><ul><li>命令行 &gt; 包外config直接子目录 &gt; 包外config目录 &gt; 包外根目录 &gt; 包内目录</li><li>同级比较： <ul><li>profile配置 &gt; 默认配置</li><li>properties配置 &gt; yaml配置</li></ul></li></ul><p> <img src="https://cdn.nlark.com/yuque/0/2023/svg/28066124/1691418639180-bac5ede2-c3e2-4a60-bf81-b015e53ea599.svg#clientId=u8fdb1034-8532-4&from=paste&height=535&id=u4b284044&originHeight=669&originWidth=694&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=91719&status=done&style=none&taskId=ue9940951-a38d-4801-9025-9879191c5cd&title=&width=555.2" alt="未命名绘图.svg"><br>**规律：最外层的最优先。</p><ul><li><strong>命令行 &gt; 所有</strong></li><li><strong>包外 &gt; 包内</strong></li><li><strong>config目录 &gt; 根目录</strong></li><li>**profile &gt; application **</li></ul><p><strong>配置不同就都生效（互补），配置相同高优先级覆盖低优先级</strong></p><h2 id="3-3-导入配置"><a href="#3-3-导入配置" class="headerlink" title="3.3. 导入配置"></a>3.3. 导入配置</h2><p>使用spring.config.import可以导入额外配置：<br>导入配置的优先级低于配置文件的优先级。</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">spring.config.import</span>=my.properties<span class="hljs-attr">my.property</span>=value</code></pre></div><p>无论以上写法的先后顺序，my.properties的值总是优先于直接在文件中编写的my.property。</p><h2 id="3-4-属性占位符"><a href="#3-4-属性占位符" class="headerlink" title="3.4. 属性占位符"></a>3.4. 属性占位符</h2><p>配置文件中可以使用 ${name:default}形式取出之前配置过的值，${name:default}这里的意思是配置文件中有name值，就采用该值，没有的换就让name的值为default的值。@Value可以获取配置文件中的值，@Value(${name：hahha}) String name表示如果配置文件没有name的配置那么name的值为haha,如果有name的值就是配置文件中的值，</p><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@Value</span>注解是Spring框架提供的一种方式，可以从外部的配置文件、系统属性或表达式中获取值，并赋给Bean中的字段或参数。<span class="hljs-variable">@Value</span>注解的参数是一个字符串，可以是一个普通的字符串，也可以是一个占位符或表达式，用$ &#123;&#125;或# &#123;&#125;包围。</code></pre></div><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">app.name</span>=MyApp<span class="hljs-attr">app.description</span>=<span class="hljs-variable">$&#123;app.name&#125;</span> is a Spring Boot application written by <span class="hljs-variable">$&#123;username:Unknown&#125;</span></code></pre></div><h1 id="4-单元测试-JUnit5"><a href="#4-单元测试-JUnit5" class="headerlink" title="4. 单元测试-JUnit5"></a><strong>4. 单元测试-JUnit5</strong></h1><h2 id="4-1-整合"><a href="#4-1-整合" class="headerlink" title="4.1. 整合"></a>4.1. 整合</h2><p>SpringBoot 提供一系列测试工具集及注解方便我们进行测试。<br>spring-boot-test提供核心测试能力，spring-boot-test-autoconfigure提供测试的一些自动配置。<br>我们只需要导入spring-boot-starter-test即可整合测试</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>spring-boot-starter-test默认提供了以下库供我们测试使用</p><ul><li><a href="https://junit.org/junit5/"><strong>JUnit 5</strong></a></li><li><a href="https://docs.spring.io/spring-framework/docs/6.0.4/reference/html/testing.html#integration-testing"><strong>Spring Test</strong></a></li><li><a href="https://assertj.github.io/doc/"><strong>AssertJ</strong></a></li><li><a href="https://github.com/hamcrest/JavaHamcrest"><strong>Hamcrest</strong></a></li><li><a href="https://site.mockito.org/"><strong>Mockito</strong></a></li><li><a href="https://github.com/skyscreamer/JSONassert"><strong>JSONassert</strong></a></li><li><a href="https://github.com/jayway/JsonPath"><strong>JsonPath</strong></a></li></ul><h2 id="4-2-测试"><a href="#4-2-测试" class="headerlink" title="4.2. 测试"></a><strong>4.2. 测试</strong></h2><div class="code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-number">1.</span><span class="hljs-meta">@SpringBootTest</span> <span class="hljs-comment">//具备测试SpringBoot应用容器中所有组件的功能,测试的时候会启动spingboot</span><span class="hljs-comment">//测试类也必须在主程序所在的包及其子包;这里的主程序是springbootApplication修饰的类，之所以</span>测试类必须在主程序所在的包及其子包的原因是：SpringBoot的默认扫描规则，只扫描自己主程序所在的包以及子包，这样测试类的注解才能被扫描到。</code></pre></div><h3 id="4-2-0-组件测试"><a href="#4-2-0-组件测试" class="headerlink" title="4.2.0 组件测试"></a><strong>4.2.0 组件测试</strong></h3><p><strong>直接@Autowired容器中的组件进行测试</strong><br>JUnit5的注解与JUnit4的注解有所变化<br><a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations"><strong>https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations</strong></a><br>@DisplayName(“测试1”)&#x2F;&#x2F;自定义测试名字<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1691632824115-17aa44c2-d941-4cf4-9275-e179fff05255.png#averageHue=%23c19757&clientId=u6136e5eb-a4ad-4&from=paste&height=159&id=u91faa989&originHeight=199&originWidth=746&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=52561&status=done&style=none&taskId=ue972d580-cb68-4f6e-babc-29509d58909&title=&width=596.8" alt="image.png"></p><h3 id="4-2-1-注解"><a href="#4-2-1-注解" class="headerlink" title="4.2.1 注解"></a><strong>4.2.1 注解</strong></h3><ul><li>**@Test :**表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试</li><li>**@ParameterizedTest :**表示方法是参数化测试，下方会有详细介绍</li><li>**@RepeatedTest :**表示方法可重复执行，下方会有详细介绍</li><li>**@DisplayName :**为测试类或者测试方法设置展示名称</li><li>**@BeforeEach :**表示在每个单元测试之前执行</li><li>**@AfterEach :**表示在每个单元测试之后执行</li><li>**@BeforeAll :**表示在所有单元测试之前执行</li><li>**@AfterAll :**表示在所有单元测试之后执行</li><li>**@Tag :**表示单元测试类别，类似于JUnit4中的@Categories</li><li>**@Disabled :**表示测试类或测试方法不执行，类似于JUnit4中的@Ignore</li><li>**@Timeout :**表示测试方法运行如果超过了指定时间将会返回错误</li><li>**@ExtendWith :**为测试类或测试方法提供扩展类引用<div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.api</span><span class="hljs-selector-class">.Assertions</span><span class="hljs-selector-class">.fail</span>;<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.api</span><span class="hljs-selector-class">.Assumptions</span><span class="hljs-selector-class">.assumeTrue</span>;<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.api</span><span class="hljs-selector-class">.AfterAll</span>;<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.api</span><span class="hljs-selector-class">.AfterEach</span>;<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.api</span><span class="hljs-selector-class">.BeforeAll</span>;<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.api</span><span class="hljs-selector-class">.BeforeEach</span>;<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.api</span><span class="hljs-selector-class">.Disabled</span>;<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.api</span><span class="hljs-selector-class">.Test</span>;<span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">StandardTests</span> &#123;    <span class="hljs-variable">@BeforeAll</span>    static void <span class="hljs-built_in">initAll</span>() &#123;    &#125;    <span class="hljs-variable">@BeforeEach</span>    void <span class="hljs-built_in">init</span>() &#123;    &#125;    <span class="hljs-variable">@DisplayName</span>(<span class="hljs-string">&quot;😱&quot;</span>)    <span class="hljs-variable">@Test</span>    void <span class="hljs-built_in">succeedingTest</span>() &#123;    &#125;    <span class="hljs-variable">@Test</span>    void <span class="hljs-built_in">failingTest</span>() &#123;        <span class="hljs-selector-tag">fail</span>(<span class="hljs-string">&quot;a failing test&quot;</span>);    &#125;    @<span class="hljs-selector-tag">Test</span>    @<span class="hljs-selector-tag">Disabled</span>(<span class="hljs-string">&quot;for demonstration purposes&quot;</span>)    <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">skippedTest</span>() &#123;        <span class="hljs-comment">// not executed</span>    &#125;    <span class="hljs-variable">@Test</span>    void <span class="hljs-built_in">abortedTest</span>() &#123;        <span class="hljs-selector-tag">assumeTrue</span>(<span class="hljs-string">&quot;abc&quot;</span>.<span class="hljs-built_in">contains</span>(<span class="hljs-string">&quot;Z&quot;</span>));        <span class="hljs-selector-tag">fail</span>(<span class="hljs-string">&quot;test should have been aborted&quot;</span>);    &#125;    @<span class="hljs-selector-tag">AfterEach</span>    <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">tearDown</span>() &#123;    &#125;    <span class="hljs-variable">@AfterAll</span>    static void <span class="hljs-built_in">tearDownAll</span>() &#123;    &#125;&#125;</code></pre></div></li></ul><h3 id="4-2-2-断言"><a href="#4-2-2-断言" class="headerlink" title="4.2.2 断言"></a><strong>4.2.2 断言</strong></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1691418910556-4050b5e8-46b0-4d5c-890a-2432fdb1491c.png#averageHue=%23fbfaf9&clientId=u8fdb1034-8532-4&from=paste&height=526&id=ue8811d01&originHeight=658&originWidth=938&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=51295&status=done&style=none&taskId=u8fbc1a6a-e039-4e45-87a7-d19b86d95c6&title=&width=750.4" alt="image.png"></p><h3 id="4-2-3-嵌套测试"><a href="#4-2-3-嵌套测试" class="headerlink" title="4.2.3 嵌套测试"></a><strong>4.2.3 嵌套测试</strong></h3><p>JUnit 5 可以通过 Java 中的内部类和@Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用@BeforeEach 和@AfterEach 注解，而且嵌套的层次没有限制</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-meta">@DisplayName</span>(<span class="hljs-string">&quot;A stack&quot;</span>)<span class="hljs-keyword">class</span> <span class="hljs-title class_">TestingAStackDemo</span> &#123;    <span class="hljs-title class_">Stack</span>&lt;<span class="hljs-title class_">Object</span>&gt; stack;    <span class="hljs-meta">@Test</span>    <span class="hljs-meta">@DisplayName</span>(<span class="hljs-string">&quot;is instantiated with new Stack()&quot;</span>)    <span class="hljs-built_in">void</span> <span class="hljs-title function_">isInstantiatedWithNew</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();    &#125;    <span class="hljs-meta">@Nested</span>    <span class="hljs-meta">@DisplayName</span>(<span class="hljs-string">&quot;when new&quot;</span>)    <span class="hljs-keyword">class</span> <span class="hljs-title class_">WhenNew</span> &#123;        <span class="hljs-meta">@BeforeEach</span>        <span class="hljs-built_in">void</span> <span class="hljs-title function_">createNewStack</span>(<span class="hljs-params"></span>) &#123;            stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();        &#125;        <span class="hljs-meta">@Test</span>        <span class="hljs-meta">@DisplayName</span>(<span class="hljs-string">&quot;is empty&quot;</span>)        <span class="hljs-built_in">void</span> <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;            <span class="hljs-title function_">assertTrue</span>(stack.<span class="hljs-title function_">isEmpty</span>());        &#125;        <span class="hljs-meta">@Test</span>        <span class="hljs-meta">@DisplayName</span>(<span class="hljs-string">&quot;throws EmptyStackException when popped&quot;</span>)        <span class="hljs-built_in">void</span> <span class="hljs-title function_">throwsExceptionWhenPopped</span>(<span class="hljs-params"></span>) &#123;            <span class="hljs-title function_">assertThrows</span>(<span class="hljs-title class_">EmptyStackException</span>.<span class="hljs-property">class</span>, <span class="hljs-attr">stack</span>::pop);        &#125;        <span class="hljs-meta">@Test</span>        <span class="hljs-meta">@DisplayName</span>(<span class="hljs-string">&quot;throws EmptyStackException when peeked&quot;</span>)        <span class="hljs-built_in">void</span> <span class="hljs-title function_">throwsExceptionWhenPeeked</span>(<span class="hljs-params"></span>) &#123;            <span class="hljs-title function_">assertThrows</span>(<span class="hljs-title class_">EmptyStackException</span>.<span class="hljs-property">class</span>, <span class="hljs-attr">stack</span>::peek);        &#125;        <span class="hljs-meta">@Nested</span>        <span class="hljs-meta">@DisplayName</span>(<span class="hljs-string">&quot;after pushing an element&quot;</span>)        <span class="hljs-keyword">class</span> <span class="hljs-title class_">AfterPushing</span> &#123;            <span class="hljs-title class_">String</span> anElement = <span class="hljs-string">&quot;an element&quot;</span>;            <span class="hljs-meta">@BeforeEach</span>            <span class="hljs-built_in">void</span> <span class="hljs-title function_">pushAnElement</span>(<span class="hljs-params"></span>) &#123;                stack.<span class="hljs-title function_">push</span>(anElement);            &#125;            <span class="hljs-meta">@Test</span>            <span class="hljs-meta">@DisplayName</span>(<span class="hljs-string">&quot;it is no longer empty&quot;</span>)            <span class="hljs-built_in">void</span> <span class="hljs-title function_">isNotEmpty</span>(<span class="hljs-params"></span>) &#123;                <span class="hljs-title function_">assertFalse</span>(stack.<span class="hljs-title function_">isEmpty</span>());            &#125;            <span class="hljs-meta">@Test</span>            <span class="hljs-meta">@DisplayName</span>(<span class="hljs-string">&quot;returns the element when popped and is empty&quot;</span>)            <span class="hljs-built_in">void</span> <span class="hljs-title function_">returnElementWhenPopped</span>(<span class="hljs-params"></span>) &#123;                <span class="hljs-title function_">assertEquals</span>(anElement, stack.<span class="hljs-title function_">pop</span>());                <span class="hljs-title function_">assertTrue</span>(stack.<span class="hljs-title function_">isEmpty</span>());            &#125;            <span class="hljs-meta">@Test</span>            <span class="hljs-meta">@DisplayName</span>(<span class="hljs-string">&quot;returns the element when peeked but remains not empty&quot;</span>)            <span class="hljs-built_in">void</span> <span class="hljs-title function_">returnElementWhenPeeked</span>(<span class="hljs-params"></span>) &#123;                <span class="hljs-title function_">assertEquals</span>(anElement, stack.<span class="hljs-title function_">peek</span>());                <span class="hljs-title function_">assertFalse</span>(stack.<span class="hljs-title function_">isEmpty</span>());            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="4-2-4-参数化测试"><a href="#4-2-4-参数化测试" class="headerlink" title="4.2.4 参数化测试"></a><strong>4.2.4 参数化测试</strong></h3><p>参数化测试是JUnit5很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。<br>**</p><p>利用**@ValueSource**等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。<br><strong>@ValueSource</strong>: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型<br><strong>@NullSource</strong>: 表示为参数化测试提供一个null的入参<br><strong>@EnumSource</strong>: 表示为参数化测试提供一个枚举入参<br><strong>@CsvFileSource</strong>：表示读取指定CSV文件内容作为参数化测试入参<br><strong>@MethodSource</strong>：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-meta">@ParameterizedTest</span><span class="hljs-meta">@ValueSource</span>(strings = &#123;<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>&#125;)<span class="hljs-meta">@DisplayName</span>(<span class="hljs-string">&quot;参数化测试1&quot;</span>)<span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">parameterizedTest1</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> <span class="hljs-built_in">string</span></span>) &#123;    <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-built_in">string</span>);    <span class="hljs-title class_">Assertions</span>.<span class="hljs-title function_">assertTrue</span>(<span class="hljs-title class_">StringUtils</span>.<span class="hljs-title function_">isNotBlank</span>(<span class="hljs-built_in">string</span>));&#125;<span class="hljs-meta">@ParameterizedTest</span><span class="hljs-meta">@MethodSource</span>(<span class="hljs-string">&quot;method&quot;</span>)    <span class="hljs-comment">//指定方法名</span><span class="hljs-meta">@DisplayName</span>(<span class="hljs-string">&quot;方法来源参数&quot;</span>)<span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">testWithExplicitLocalMethodSource</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>) &#123;    <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(name);    <span class="hljs-title class_">Assertions</span>.<span class="hljs-title function_">assertNotNull</span>(name);&#125;<span class="hljs-keyword">static</span> <span class="hljs-title class_">Stream</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Stream</span>.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>);&#125;</code></pre></div><h1 id="5、SpringBoot3-核心原理"><a href="#5、SpringBoot3-核心原理" class="headerlink" title="5、SpringBoot3-核心原理"></a><strong>5、SpringBoot3-核心原理</strong></h1><h2 id="1-事件和监听器"><a href="#1-事件和监听器" class="headerlink" title="1. 事件和监听器"></a>1. 事件和监听器</h2><p><strong>1. 生命周期监听场景：监听应用的</strong>生命周期<br><strong>1. 监听器-SpringApplicationRunListener</strong><br>自定义SpringApplicationRunListener来监听事件；编写SpringApplicationRunListener实现类在 META-INF&#x2F;spring.factories 中配置 org.springframework.boot.SpringApplicationRunListener&#x3D;自己的Listener，还可以指定一个有参构造器，接受两个参数(SpringApplication application, String[] args)springboot 在spring-boot.jar中配置了默认的 Listener，如下<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681829576654-d5e4b889-6fcf-4e65-91f1-8de8c78e98f1.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_23,text_5bCa56GF6LC3IGF0Z3VpZ3UuY29t,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#averageHue=%23f3c9ac&from=url&id=kfTpf&originHeight=61&originWidth=792&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=">**</p><div class="code-wrapper"><pre><code class="hljs markdown">/**<span class="hljs-bullet"> *</span> Listener先要从 META-INF/spring.factories 读到<span class="hljs-bullet"> *</span> * 1、引导： 利用 BootstrapContext 引导整个项目启动<span class="hljs-bullet"> *</span>      starting：              应用开始，SpringApplication的run方法一调用，只要有了 BootstrapContext 就执行<span class="hljs-bullet"> *</span>      environmentPrepared：   环境准备好（把启动参数等绑定到环境变量中），但是ioc还没有创建；【调一次】<span class="hljs-bullet"> *</span> 2、启动：<span class="hljs-bullet"> *</span>      contextPrepared：       ioc容器创建并准备好，但是sources（主配置类）没加载。并关闭引导上下文；组件都没创建  【调一次】<span class="hljs-bullet"> *</span>      contextLoaded：         ioc容器加载。主配置类加载进去了。但是ioc容器还没刷新（我们的bean没创建）。<span class="hljs-bullet"> *</span>      =======截止以前，ioc容器里面还没造bean呢=======<span class="hljs-bullet"> *</span>      started：               ioc容器刷新了（所有bean造好了），但是 runner 没调用。<span class="hljs-bullet"> *</span>      ready:                  ioc容器刷新了（所有bean造好了），所有 runner 调用完了。<span class="hljs-bullet"> *</span> 3、运行<span class="hljs-bullet"> *</span>     以前步骤都正确执行，代表容器running。 <span class="hljs-emphasis">*/</span></code></pre></div><h3 id="2-生命周期全流程"><a href="#2-生命周期全流程" class="headerlink" title="2. 生命周期全流程"></a>2. 生命周期全流程</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1682322663331-25a89875-7ce3-40ae-9be7-9ea752fbab20.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_31,text_5bCa56GF6LC3IGF0Z3VpZ3UuY29t,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#averageHue=%23a7bd8b&from=url&id=Uwox4&originHeight=758&originWidth=1102&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs mipsasm">在Spring <span class="hljs-keyword">Boot中，Runner是一个接口，用于在Spring应用程序启动完成后执行一些特定的任务。</span><span class="hljs-keyword"></span>它是Spring <span class="hljs-keyword">Boot提供的一种扩展机制，允许开发人员在应用程序启动后立即执行一些代码逻辑。</span><span class="hljs-keyword"></span>开发人员可以通过实现Runner接口并注入到Spring应用程序中，从而在应用程序启动后执行自定义的任务。runner是springboot底层用来感知生命周期特定阶段的一个回调。不同于SpringApplicationRunListener,这个是用来感知全生命周期的</code></pre></div><h2 id="2-事件触发时机"><a href="#2-事件触发时机" class="headerlink" title="2. 事件触发时机"></a>2. 事件触发时机</h2><h3 id="1-各种回调监听器"><a href="#1-各种回调监听器" class="headerlink" title="1. 各种回调监听器"></a>1. 各种回调监听器</h3><ul><li>BootstrapRegistryInitializer： ** 感知特定阶段：<strong>感知</strong>引导初始化**<ul><li>META-INF&#x2F;spring.factories</li><li>创建引导上下文bootstrapContext的时候触发。</li><li>application.addBootstrapRegistryInitializer();</li><li>场景：进行密钥校对授权。</li></ul></li><li>ApplicationContextInitializer： ** 感知特定阶段：** 感知ioc容器初始化<ul><li>META-INF&#x2F;spring.factories</li><li>application.addInitializers();</li></ul></li><li><strong>ApplicationListener： 感知全阶段：基于事件机制，感知事件。 一旦到了哪个阶段可以做别的事</strong><ul><li>@Bean或@EventListener： 事件驱动</li><li>SpringApplication.addListeners(…)或 SpringApplicationBuilder.listeners(…)</li><li>META-INF&#x2F;spring.factories</li></ul></li><li><strong>SpringApplicationRunListener： 感知全阶段生命周期 + 各种阶段都能自定义操作； 功能更完善。</strong><ul><li>META-INF&#x2F;spring.factories</li></ul></li><li><strong>ApplicationRunner: 感知特定阶段：感知应用就绪Ready。卡死应用，就不会就绪</strong><ul><li>@Bean</li></ul></li><li><strong>CommandLineRunner： 感知特定阶段：感知应用就绪Ready。卡死应用，就不会就绪</strong><ul><li>@Bean</li></ul></li></ul><p>最佳实战：</p><ul><li>如果项目启动前做事： BootstrapRegistryInitializer 和 ApplicationContextInitializer</li><li>如果想要在项目启动完成后做事：<strong>ApplicationRunner和 CommandLineRunner</strong></li><li><strong>如果要干涉生命周期做事：SpringApplicationRunListener</strong></li><li><strong>如果想要用事件机制：ApplicationListener</strong></li><li><strong>上面的都是接口，可以通过实现接口，然后在</strong>META-INF&#x2F;spring.factories配置文件中填充实现上述接口的类，就可以实现在生命周期的特定阶段完成某项任务！</li></ul><h3 id="2-完整触发流程"><a href="#2-完整触发流程" class="headerlink" title="2. 完整触发流程"></a><strong>2. 完整触发流程</strong></h3><p><strong>9大事件</strong>触发顺序&amp;时机</p><ol><li>ApplicationStartingEvent：应用启动但未做任何事情, 除过注册listeners and initializers.</li><li>ApplicationEnvironmentPreparedEvent： Environment 准备好，但context 未创建.</li><li>ApplicationContextInitializedEvent: ApplicationContext 准备好，ApplicationContextInitializers 调用，但是任何bean未加载</li><li>ApplicationPreparedEvent： 容器刷新之前，bean定义信息加载</li><li>ApplicationStartedEvent： 容器刷新完成， runner未调用</li></ol><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;以下就开始插入了<strong>探针机制</strong>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><ol><li>AvailabilityChangeEvent： LivenessState.CORRECT应用存活； <strong>存活探针</strong></li><li>ApplicationReadyEvent: 任何runner被调用</li><li>AvailabilityChangeEvent：ReadinessState.ACCEPTING_TRAFFIC<strong>就绪探针</strong>，可以接请求</li><li>ApplicationFailedEvent：启动出错</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1691887909080-a687294a-131b-4da8-9822-18298ade2f39.png#averageHue=%23c4d581&clientId=uac0c1727-261a-4&from=paste&height=610&id=ue472925a&originHeight=762&originWidth=1129&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=133115&status=done&style=none&taskId=ue11d8088-eb18-4a04-ae32-ed763f0e0a8&title=&width=903.2" alt="image.png"><strong>应用事件发送顺序如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1691887919553-7c5e83d8-0a5c-4cae-bfca-bd50272bbb36.png#averageHue=%23f5eee4&clientId=uac0c1727-261a-4&from=paste&height=157&id=ufc92ec7f&originHeight=196&originWidth=937&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=100464&status=done&style=none&taskId=ua7f8bbd0-7822-4907-8c9a-bd01dc2227b&title=&width=749.6" alt="image.png"><br>感知应用是否存活了：可能植物状态，虽然活着但是不能处理请求。<br>应用是否</strong>就绪**了：能响应请求，说明确实活的比较好。</p><h3 id="3-SpringBoot-事件驱动开发"><a href="#3-SpringBoot-事件驱动开发" class="headerlink" title="3. SpringBoot 事件驱动开发"></a>3. SpringBoot 事件驱动开发</h3><p><strong>应用启动过程生命周期事件感知（9大事件）</strong>、<strong>应用运行中事件感知（无数种）</strong>。</p><ul><li><strong>事件发布</strong>：ApplicationEventPublisherAware或注入：ApplicationEventMulticaster</li><li><strong>事件监听</strong>：组件 + @EventListener</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1682327167479-8f634931-f8ca-48fb-9566-c914f1795ff2.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_33,text_5bCa56GF6LC3IGF0Z3VpZ3UuY29t,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#averageHue=%23f2eeec&from=url&id=b4csj&originHeight=387&originWidth=1153&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1682341921101-aa095a84-00cc-4815-b675-f4ed81cecf3b.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_22,text_5bCa56GF6LC3IGF0Z3VpZ3UuY29t,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#averageHue=%23fdfcfc&from=url&id=dk2IM&originHeight=489&originWidth=780&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>事件发布者</strong></p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EventPublisher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationEventPublisherAware</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 底层发送事件用的组件，SpringBoot会通过ApplicationEventPublisherAware接口自动注入给我们</span><span class="hljs-comment">     * 事件是广播出去的。所有监听这个事件的监听器都可以收到</span><span class="hljs-comment">     */</span>    <span class="hljs-title class_">ApplicationEventPublisher</span> applicationEventPublisher;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 所有事件都可以发</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> <span class="hljs-variable">event</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">sendEvent</span>(<span class="hljs-params">ApplicationEvent event</span>) &#123;        <span class="hljs-comment">//调用底层API发送事件</span>        applicationEventPublisher.<span class="hljs-title function_">publishEvent</span>(event);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 会被自动调用，把真正发事件的底层组组件给我们注入进来</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> applicationEventPublisher event publisher to be used by this object</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setApplicationEventPublisher</span>(<span class="hljs-params">ApplicationEventPublisher applicationEventPublisher</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">applicationEventPublisher</span> = applicationEventPublisher;    &#125;&#125;</code></pre></div><p><strong>事件订阅者</strong></p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CouponService</span> &#123;    <span class="hljs-meta">@Order</span>(<span class="hljs-number">1</span>)    <span class="hljs-meta">@EventListener</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onEvent</span>(<span class="hljs-params">LoginSuccessEvent loginSuccessEvent</span>)&#123;        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;===== CouponService ====感知到事件&quot;</span>+loginSuccessEvent);        <span class="hljs-title class_">UserEntity</span> source = (<span class="hljs-title class_">UserEntity</span>) loginSuccessEvent.<span class="hljs-title function_">getSource</span>();        <span class="hljs-title function_">sendCoupon</span>(source.<span class="hljs-title function_">getUsername</span>());    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">sendCoupon</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> username</span>)&#123;        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(username + <span class="hljs-string">&quot; 随机得到了一张优惠券&quot;</span>);    &#125;&#125;</code></pre></div><h1 id="2-自动配置原理"><a href="#2-自动配置原理" class="headerlink" title="**2. **自动配置原理"></a>**2. **自动配置原理</h1><h2 id="1-入门理解"><a href="#1-入门理解" class="headerlink" title="1. 入门理解"></a><strong>1. 入门理解</strong></h2><p><strong>应用关注的三大核心：场景、配置、组件</strong></p><h3 id="1-自动配置流程"><a href="#1-自动配置流程" class="headerlink" title="1. 自动配置流程"></a><strong>1. 自动配置流程</strong></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681829645812-0f0cad01-66d4-42fc-8111-091e33a062c6.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_32,text_5bCa56GF6LC3IGF0Z3VpZ3UuY29t,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#averageHue=%23cfe1c6&from=url&id=B0IdI&originHeight=602&originWidth=1113&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=">**</p><ol><li><strong>导入starter</strong></li><li><strong>依赖导入autoconfigure</strong></li><li><strong>寻找类路径下 META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports文件</strong></li><li><strong>启动，加载所有 自动配置类xxxAutoConfiguration</strong><ol><li><strong>给容器中配置功能组件</strong></li><li><strong>组件参数绑定到 属性类中。xxxProperties</strong></li><li><strong>属性类和配置文件前缀项绑定</strong></li><li><strong>@Contional派生的条件注解进行判断是否组件生效</strong></li></ol></li><li><strong>效果：</strong><ol><li><strong>修改配置文件，修改底层参数</strong></li><li><strong>所有场景自动配置好直接使用</strong></li><li><strong>可以注入SpringBoot配置好的组件随时使用</strong></li></ol></li></ol><h3 id="2-SPI机制"><a href="#2-SPI机制" class="headerlink" title="2. SPI机制"></a>2. SPI机制</h3><ul><li><strong>Java中的SPI（Service Provider Interface）是一种软件设计模式，用于在应用程序中动态地发现和加载组件。SPI的思想</strong>是，定义一个接口或抽象类，然后通过在classpath中定义实现该接口的类来实现对组件的动态发现和加载。</li><li>SPI的主要目的是解决在应用程序中使用可插拔组件的问题。例如，一个应用程序可能需要使用不同的日志框架或数据库连接池，但是这些组件的选择可能取决于运行时的条件。通过使用SPI，应用程序可以在运行时发现并加载适当的组件，而无需在代码中硬编码这些组件的实现类。</li><li>在Java中，<strong>SPI</strong>的实现方式是通过在META-INF&#x2F;services目录下创建一个以服务接口全限定名为名字的文件，文件中包含实现该服务接口的类的全限定名。当应用程序启动时，Java的SPI机制会自动扫描classpath中的这些文件，并根据文件中指定的类名来加载实现类。</li><li>通过使用SPI，应用程序可以实现更灵活、可扩展的架构，同时也可以避免硬编码依赖关系和增加代码的可维护性。</li></ul><p>以上回答来自ChatGPT-3.5<br>在SpringBoot中，META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports<br>作业：写一段java的spi机制代码</p><h3 id="3-功能开关"><a href="#3-功能开关" class="headerlink" title="3. 功能开关"></a>3. 功能开关</h3><ul><li>自动配置：全部都配置好，什么都不用管。 自动批量导入<ul><li>项目一启动，spi文件中指定的所有都加载。</li></ul></li><li>@EnableXxxx：手动控制哪些功能的开启； 手动导入。<ul><li>开启xxx功能</li></ul></li></ul><h2 id="2-进阶理解"><a href="#2-进阶理解" class="headerlink" title="2. 进阶理解"></a><strong>2. 进阶理解</strong></h2><h3 id="1-SpringBootApplication"><a href="#1-SpringBootApplication" class="headerlink" title="1. @SpringBootApplication"></a><strong>1. @SpringBootApplication</strong></h3><h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a><strong>@SpringBootConfiguration</strong></h4><p><strong>就是： @Configuration ，容器中的组件，配置类。spring ioc启动就会加载创建这个类对象</strong></p><h4 id="EnableAutoConfiguration：开启自动配置"><a href="#EnableAutoConfiguration：开启自动配置" class="headerlink" title="@EnableAutoConfiguration：开启自动配置"></a><strong>@EnableAutoConfiguration：开启自动配置</strong></h4><p><strong>开启自动配置</strong></p><h5 id="AutoConfigurationPackage：扫描主程序包：加载自己的组件"><a href="#AutoConfigurationPackage：扫描主程序包：加载自己的组件" class="headerlink" title="@AutoConfigurationPackage：扫描主程序包：加载自己的组件"></a><strong>@AutoConfigurationPackage：扫描主程序包：加载自己的组件</strong></h5><ul><li><strong>利用 @Import(AutoConfigurationPackages.Registrar.class) 想要给容器中导入组件。</strong></li><li><strong>把主程序所在的包的所有组件导入进来。</strong></li><li><strong>为什么SpringBoot默认只扫描主程序所在的包及其子包</strong></li></ul><p>**</p><h5 id="Import-AutoConfigurationImportSelector-class-：加载所有自动配置类：加载starter导入的组件"><a href="#Import-AutoConfigurationImportSelector-class-：加载所有自动配置类：加载starter导入的组件" class="headerlink" title="@Import(AutoConfigurationImportSelector.class)：加载所有自动配置类：加载starter导入的组件"></a><strong>@Import(AutoConfigurationImportSelector.class)：加载所有自动配置类：加载starter导入的组件</strong></h5><div class="code-wrapper"><pre><code class="hljs arduino">List&lt;<span class="hljs-type">String</span>&gt; configurations = ImportCandidates.<span class="hljs-built_in">load</span>(AutoConfiguration.<span class="hljs-keyword">class</span>, <span class="hljs-built_in">getBeanClassLoader</span>()).<span class="hljs-built_in">getCandidates</span>();</code></pre></div><p>**扫描SPI文件：META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports</p><p>**</p><h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a><strong>@ComponentScan</strong></h4><p><strong>组件扫描：排除一些组件（哪些不要）</strong><br><strong>排除前面已经扫描进来的配置类、和自动配置类。</strong></p><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@ComponentScan</span>(excludeFilters = &#123; <span class="hljs-variable">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),      <span class="hljs-variable">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</code></pre></div><h3 id="2-完整启动加载流程"><a href="#2-完整启动加载流程" class="headerlink" title="2. 完整启动加载流程"></a>2. 完整启动加载流程</h3><p>生命周期启动加载流程<br><img src="https://cdn.nlark.com/yuque/0/2023/svg/1613913/1682569555020-b6cbc750-3171-44c6-810f-1c59e590b792.svg#from=url&id=kMVFr&originHeight=794&originWidth=1453&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="3-自定义starter"><a href="#3-自定义starter" class="headerlink" title="3. 自定义starter"></a><strong>3. 自定义starter</strong></h1><p><strong>场景：抽取聊天机器人场景，它可以打招呼。</strong><br><strong>效果：任何项目导入此starter都具有打招呼功能，并且问候语中的人名需要可以在配置文件中修改</strong></p><ul><li><ol><li>创建自定义starter项目，引入spring-boot-starter基础依赖</li></ol></li><li><ol start="2"><li>编写模块功能，引入模块所有需要的依赖。</li></ol></li><li><ol start="3"><li>编写xxxAutoConfiguration自动配置类，帮其他项目导入这个模块需要的所有组件</li></ol></li><li><ol start="4"><li>编写配置文件META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports指定启动需要加载的自动配置</li></ol></li></ul><h2 id="1-业务代码"><a href="#1-业务代码" class="headerlink" title="1. 业务代码"></a><strong>1. 业务代码</strong></h2><p>自定义配置有提示。导入以下依赖重启项目，再写配置文件就有提示**</p><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@ConfigurationProperties</span>(prefix = <span class="hljs-string">&quot;robot&quot;</span>)  <span class="hljs-comment">//此属性类和配置文件指定前缀绑定</span><span class="hljs-variable">@Component</span><span class="hljs-variable">@Data</span>public class RobotProperties &#123;    <span class="hljs-selector-tag">private</span> <span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">name</span>;    <span class="hljs-selector-tag">private</span> <span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">age</span>;    <span class="hljs-selector-tag">private</span> <span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">email</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--        导入配置处理器，配置文件自定义的properties配置都会有提示--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h2 id="2-基本抽取"><a href="#2-基本抽取" class="headerlink" title="2. 基本抽取"></a>2. 基本抽取</h2><ul><li>创建starter项目，把公共代码需要的所有依赖导入</li><li>把公共代码复制进来</li><li>自己写一个 RobotAutoConfiguration，给容器中导入这个场景需要的所有组件<ul><li>为什么这些组件默认不会扫描进去？</li><li><strong>starter所在的包和 引入它的项目的主程序所在的包不是父子层级</strong></li></ul></li><li>别人引用这个starter，直接导入这个 RobotAutoConfiguration,就能把这个场景的组件导入进来</li><li>功能生效。</li><li>测试编写配置文件</li></ul><h2 id="3-使用-EnableXxx机制"><a href="#3-使用-EnableXxx机制" class="headerlink" title="3. 使用@EnableXxx机制"></a><strong>3. 使用@EnableXxx机制</strong></h2><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-variable">@Target</span>(&#123;ElementType.TYPE&#125;)<span class="hljs-variable">@Documented</span><span class="hljs-variable">@Import</span>(RobotAutoConfiguration.class)public <span class="hljs-variable">@interface</span> EnableRobot &#123;&#125;</code></pre></div><p>****别人引入starter需要使用 @EnableRobot开启功能 **</p><h2 id="4-完全自动配置"><a href="#4-完全自动配置" class="headerlink" title="4. 完全自动配置"></a>4. 完全自动配置</h2><ul><li>依赖SpringBoot的SPI机制</li><li>META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports 文件中编写好我们自动配置类的全类名即可</li><li>项目启动，自动加载我们的自动配置类</li></ul><h1 id="SpringBoot3-场景整合"><a href="#SpringBoot3-场景整合" class="headerlink" title="SpringBoot3-场景整合"></a>SpringBoot3-场景整合</h1><h2 id="0-云服务器"><a href="#0-云服务器" class="headerlink" title="0. 云服务器"></a>0. 云服务器</h2><ul><li><a href="https://promotion.aliyun.com/ntms/act/ambassador/sharetouser.html?userCode=50sid5bu&utm_source=50sid5bu"><strong>阿里云</strong></a><strong>、</strong><a href="https://curl.qcloud.com/iyFTRSJb"><strong>腾讯云</strong></a><strong>、</strong><a href="https://activity.huaweicloud.com/discount_area_v5/index.html?fromacct=d1a6f32e-d6d0-4702-9213-eafe022a0708&utm_source=bGVpZmVuZ3lhbmc==&utm_medium=cps&utm_campaign=201905"><strong>华为云</strong></a>** 服务器开通； 按量付费，省钱省心**</li><li><strong>安装以下组件</strong></li><li><input disabled="" type="checkbox"> <strong>docker</strong></li><li><input disabled="" type="checkbox"> <strong>redis</strong></li><li><input disabled="" type="checkbox"> <strong>kafka</strong></li><li><input disabled="" type="checkbox"> <strong>prometheus</strong></li><li><input disabled="" type="checkbox"> <strong>grafana</strong></li><li><a href="https://github.com/kingToolbox/WindTerm/releases/download/2.5.0/WindTerm_2.5.0_Windows_Portable_x86_64.zip"><strong>https://github.com/kingToolbox/WindTerm/releases/download/2.5.0/WindTerm_2.5.0_Windows_Portable_x86_64.zip</strong></a>** 下载windterm**</li></ul><p><strong>重要：开通云服务器以后，请一定在安全组设置规则，放行端口</strong></p><h2 id="1-Docker安装"><a href="#1-Docker安装" class="headerlink" title="1. Docker安装"></a>1. Docker安装</h2><p>还不会docker的同学，参考【云原生实战（10~25集）】快速入门<br><a href="https://www.bilibili.com/video/BV13Q4y1C7hS?p=10">https://www.bilibili.com/video/BV13Q4y1C7hS?p=10</a></p><div class="code-wrapper"><pre><code class="hljs vim">sudo yum install -<span class="hljs-keyword">y</span> yum-utilssudo yum-config-manager \    --<span class="hljs-built_in">add</span>-repo \    https://download.docker.<span class="hljs-keyword">com</span>/linux/centos/docker-<span class="hljs-keyword">ce</span>.reposudo yum install docker-<span class="hljs-keyword">ce</span> docker-<span class="hljs-keyword">ce</span>-cli containerd.io docker-buildx-plugin docker-compose-pluginsudo systemctl enable docker --now#测试工作docker <span class="hljs-keyword">ps</span>#  批量安装所有软件docker compose</code></pre></div><p><strong>创建 &#x2F;prod 文件夹，准备以下文件</strong></p><h2 id="2-prometheus-yml"><a href="#2-prometheus-yml" class="headerlink" title="2. prometheus.yml"></a>2. prometheus.yml</h2><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">global</span><span class="hljs-punctuation">:</span>  <span class="hljs-attribute">scrape_interval</span><span class="hljs-punctuation">:</span> <span class="hljs-string">15s</span>  <span class="hljs-attribute">evaluation_interval</span><span class="hljs-punctuation">:</span> <span class="hljs-string">15s</span><span class="hljs-attribute">scrape_configs</span><span class="hljs-punctuation">:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">job_name: &#x27;prometheus&#x27;</span>    <span class="hljs-attribute">static_configs</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">targets: [&#x27;localhost:9090&#x27;]</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">job_name: &#x27;redis&#x27;</span>    <span class="hljs-attribute">static_configs</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">targets: [&#x27;redis:6379&#x27;]</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">job_name: &#x27;kafka&#x27;</span>    <span class="hljs-attribute">static_configs</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">targets: [&#x27;kafka:9092&#x27;]</span></code></pre></div><h2 id="3-docker-compose-yml"><a href="#3-docker-compose-yml" class="headerlink" title="3. docker-compose.yml"></a>3. docker-compose.yml</h2><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">version</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;3.9&#x27;</span><span class="hljs-attribute">services</span><span class="hljs-punctuation">:</span>  <span class="hljs-attribute">redis</span><span class="hljs-punctuation">:</span>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">redis:latest</span>    <span class="hljs-attribute">container_name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">redis</span>    <span class="hljs-attribute">restart</span><span class="hljs-punctuation">:</span> <span class="hljs-string">always</span>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;6379:6379&quot;</span>    <span class="hljs-attribute">networks</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">backend</span>  <span class="hljs-attribute">zookeeper</span><span class="hljs-punctuation">:</span>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">bitnami/zookeeper:latest</span>    <span class="hljs-attribute">container_name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">zookeeper</span>    <span class="hljs-attribute">restart</span><span class="hljs-punctuation">:</span> <span class="hljs-string">always</span>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span>      <span class="hljs-attribute">ZOOKEEPER_CLIENT_PORT</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2181</span>      <span class="hljs-attribute">ZOOKEEPER_TICK_TIME</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2000</span>    <span class="hljs-attribute">networks</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">backend</span>  <span class="hljs-attribute">kafka</span><span class="hljs-punctuation">:</span>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">bitnami/kafka:3.4.0</span>    <span class="hljs-attribute">container_name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">kafka</span>    <span class="hljs-attribute">restart</span><span class="hljs-punctuation">:</span> <span class="hljs-string">always</span>    <span class="hljs-attribute">depends_on</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">zookeeper</span>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9092:9092&quot;</span>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span>      <span class="hljs-attribute">ALLOW_PLAINTEXT_LISTENER</span><span class="hljs-punctuation">:</span> <span class="hljs-string">yes</span>      <span class="hljs-attribute">KAFKA_CFG_ZOOKEEPER_CONNECT</span><span class="hljs-punctuation">:</span> <span class="hljs-string">zookeeper:2181</span>      <span class="hljs-attribute">KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1</span>    <span class="hljs-attribute">networks</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">backend</span>    <span class="hljs-attribute">kafka-ui</span><span class="hljs-punctuation">:</span>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">provectuslabs/kafka-ui:latest</span>    <span class="hljs-attribute">container_name</span><span class="hljs-punctuation">:</span> <span class="hljs-string"> kafka-ui</span>    <span class="hljs-attribute">restart</span><span class="hljs-punctuation">:</span> <span class="hljs-string">always</span>    <span class="hljs-attribute">depends_on</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">kafka</span>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8080:8080&quot;</span>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span>      <span class="hljs-attribute">KAFKA_CLUSTERS_0_NAME</span><span class="hljs-punctuation">:</span> <span class="hljs-string">dev</span>      <span class="hljs-attribute">KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS</span><span class="hljs-punctuation">:</span> <span class="hljs-string">kafka:9092</span>    <span class="hljs-attribute">networks</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">backend</span>  <span class="hljs-attribute">prometheus</span><span class="hljs-punctuation">:</span>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">prom/prometheus:latest</span>    <span class="hljs-attribute">container_name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">prometheus</span>    <span class="hljs-attribute">restart</span><span class="hljs-punctuation">:</span> <span class="hljs-string">always</span>    <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">./prometheus.yml:/etc/prometheus/prometheus.yml</span>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9090:9090&quot;</span>    <span class="hljs-attribute">networks</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">backend</span>  <span class="hljs-attribute">grafana</span><span class="hljs-punctuation">:</span>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">grafana/grafana:latest</span>    <span class="hljs-attribute">container_name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">grafana</span>    <span class="hljs-attribute">restart</span><span class="hljs-punctuation">:</span> <span class="hljs-string">always</span>    <span class="hljs-attribute">depends_on</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">prometheus</span>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3000:3000&quot;</span>    <span class="hljs-attribute">networks</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">backend</span><span class="hljs-attribute">networks</span><span class="hljs-punctuation">:</span>  <span class="hljs-attribute">backend</span><span class="hljs-punctuation">:</span>    <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">backend</span></code></pre></div><h2 id="4-启动环境"><a href="#4-启动环境" class="headerlink" title="4. 启动环境"></a>4. 启动环境</h2><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> compose -f docker-compose.yml up -d</code></pre></div><h2 id="5-验证"><a href="#5-验证" class="headerlink" title="5. 验证:"></a>5. 验证:</h2><p>如果通过浏览器验证没有通过的话，原因可能是没有配置安全组：例如<strong>Kafka-ui通过浏览器无法访问！</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1692062258198-3076f00d-7f1c-4d16-b118-d5602186ac58.png#averageHue=%23fcfcfc&clientId=uac0c1727-261a-4&from=paste&height=75&id=ucb808ef1&originHeight=94&originWidth=1264&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=7142&status=done&style=none&taskId=u66261308-30e0-4c55-9da2-3ed8eed8757&title=&width=1011.2" alt="image.png">添加安全组8080，这里的来源是：可以设置为 0.0.0.0&#x2F;0，表示允许来自任何 IP 地址的流量，或者您可以指定特定的 IP 地址范围或单个 IP 地址。</p><ul><li><strong>Redis：你的ip:6379</strong><ul><li><strong>填写表单，下载官方可视化工具：</strong></li><li><a href="https://redis.com/redis-enterprise/redis-insight/#insight-form"><strong>https://redis.com/redis-enterprise/redis-insight/#insight-form</strong></a></li></ul></li><li><strong>Kafka：你的ip:9092</strong><ul><li><strong>idea安装大数据插件</strong></li></ul></li><li><strong>Prometheus：你的ip:9090</strong><ul><li><strong>直接浏览器访问</strong></li></ul></li><li><strong>Grafana：你的ip:3000</strong><ul><li><strong>直接浏览器访问</strong></li></ul></li></ul><h2 id="Docker-10-25"><a href="#Docker-10-25" class="headerlink" title="Docker:(10-25)"></a>Docker:(10-25)</h2><h3 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h3><h4 id="1、解决的问题"><a href="#1、解决的问题" class="headerlink" title="1、解决的问题:"></a>1、解决的问题:</h4><p><strong>1、统一标准</strong><br>应用构建<br> Java、C++、JavaScript<br>打成软件包<br>.exe<br>docker build …. 镜像<br><strong>应用分享:</strong><br>所有软件的镜像放到一个指定地方 docker hub<br>安卓，应用市场应用运行统一标准的镜像docker run<br>…….<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1692069227456-eaaf5b70-3097-4576-b385-7518d3348588.png#averageHue=%23f0f1ed&clientId=uac0c1727-261a-4&from=paste&height=274&id=u3bdf5779&originHeight=343&originWidth=651&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=89111&status=done&style=none&taskId=u3784a1e0-8b8e-4304-81c3-2a5c657fe94&title=&width=520.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1692069318112-64c8ca5e-79f7-41e5-9c62-bf61b0757143.png#averageHue=%23efefe8&clientId=uac0c1727-261a-4&from=paste&height=285&id=uff9e6b90&originHeight=356&originWidth=671&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=83511&status=done&style=none&taskId=ue0c0164f-30fd-418f-ad07-ab8dfe21483&title=&width=536.8" alt="image.png"></p><h4 id="2、资源隔离"><a href="#2、资源隔离" class="headerlink" title="2、资源隔离"></a>2、资源隔离</h4><ul><li>cpu、memory资源隔离与限制</li><li>访问设备隔离与限制</li><li>网络隔离与限制</li><li>用户、用户组隔离限制</li><li>……</li></ul><h3 id="2、架构"><a href="#2、架构" class="headerlink" title="2、架构"></a>2、架构</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/svg/28066124/1692064439987-d4ad84f3-0582-4676-9c49-39734e7ef6f4.svg#clientId=uac0c1727-261a-4&from=paste&height=422&id=uc0bf46e6&originHeight=527&originWidth=1009&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=187350&status=done&style=none&taskId=u62a00463-37f0-4bac-9d79-bc88a76f6e2&title=&width=807.2" alt="architecture.svg"></p><ul><li>Docker_Host：<ul><li>安装Docker的主机</li></ul></li><li>Docker Daemon：<ul><li>运行在Docker主机上的Docker后台进程</li></ul></li><li>Client：<ul><li>操作Docker主机的客户端（命令行、UI等）</li></ul></li><li>Registry：<ul><li>镜像仓库</li><li>Docker Hub</li></ul></li><li>Images：<ul><li>镜像，带环境打包好的程序，可以直接启动运行</li></ul></li><li>Containers：<ul><li>容器，由镜像启动起来正在运行中的程序</li></ul></li></ul><p>交互逻辑<br>装好<strong>Docker</strong>，然后去 <strong>软件市场(doucker hub)</strong> 寻找<strong>镜像</strong>，下载并运行，查看<strong>容器</strong>状态日志等排错</p><h3 id="3、安装"><a href="#3、安装" class="headerlink" title="3、安装"></a>3、安装</h3><h4 id="1、centos下安装docker"><a href="#1、centos下安装docker" class="headerlink" title="1、centos下安装docker"></a>1、centos下安装docker</h4><p>其他系统参照如下文档<br><a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p><h4 id="1、移除以前docker相关包"><a href="#1、移除以前docker相关包" class="headerlink" title="1、移除以前docker相关包"></a>1、移除以前docker相关包</h4><div class="code-wrapper"><pre><code class="hljs livescript">sudo yum remove docker <span class="hljs-string">\</span>                  docker-client <span class="hljs-string">\</span>                  docker-client-latest <span class="hljs-string">\</span>                  docker-common <span class="hljs-string">\</span>                  docker-latest <span class="hljs-string">\</span>                  docker-latest-logrotate <span class="hljs-string">\</span>                  docker-logrotate <span class="hljs-string">\</span>                  docker-engine</code></pre></div><h4 id="2、配置yum源并且添加镜像仓库："><a href="#2、配置yum源并且添加镜像仓库：" class="headerlink" title="2、配置yum源并且添加镜像仓库："></a>2、配置yum源并且添加镜像仓库：</h4><div class="code-wrapper"><pre><code class="hljs vim">sudo yum install -<span class="hljs-keyword">y</span> yum-utilssudo yum-config-manager \--<span class="hljs-built_in">add</span>-repo \http://mirrors.aliyun.<span class="hljs-keyword">com</span>/docker-<span class="hljs-keyword">ce</span>/linux/centos/docker-<span class="hljs-keyword">ce</span>.repo</code></pre></div><h4 id="3、安装docker"><a href="#3、安装docker" class="headerlink" title="3、安装docker"></a>3、安装docker</h4><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> yum install -y docker-ce docker-ce-cli containerd.io<span class="hljs-comment">#以下是在安装k8s的时候使用</span><span class="hljs-attribute">yum</span> install -y docker-ce-<span class="hljs-number">20</span>.<span class="hljs-number">10</span>.<span class="hljs-number">7</span> docker-ce-cli-<span class="hljs-number">20</span>.<span class="hljs-number">10</span>.<span class="hljs-number">7</span>  containerd.io-<span class="hljs-number">1</span>.<span class="hljs-number">4</span>.<span class="hljs-number">6</span></code></pre></div><h4 id="4、启动"><a href="#4、启动" class="headerlink" title="4、启动"></a>4、启动</h4><div class="code-wrapper"><pre><code class="hljs pgsql">systemctl <span class="hljs-keyword">enable</span> docker <span class="hljs-comment">--now</span></code></pre></div><h4 id="5、配置加速"><a href="#5、配置加速" class="headerlink" title="5、配置加速"></a>5、配置加速</h4><p>这里额外添加了docker的生产环境核心配置cgroup：<br>其中仓库加速镜像可以去阿里云的：容器镜像服务-&gt;镜像加速器中选择加速地址替换下面的加速地址也就是registry-mirrors；</p><div class="code-wrapper"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> -p /etc/dockersudo <span class="hljs-built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span>&#123;  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://82m9ar63.mirror.aliyuncs.com&quot;</span>],  <span class="hljs-string">&quot;exec-opts&quot;</span>: [<span class="hljs-string">&quot;native.cgroupdriver=systemd&quot;</span>],  <span class="hljs-string">&quot;log-driver&quot;</span>: <span class="hljs-string">&quot;json-file&quot;</span>,  <span class="hljs-string">&quot;log-opts&quot;</span>: &#123;    <span class="hljs-string">&quot;max-size&quot;</span>: <span class="hljs-string">&quot;100m&quot;</span>  &#125;,  <span class="hljs-string">&quot;storage-driver&quot;</span>: <span class="hljs-string">&quot;overlay2&quot;</span>&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker</code></pre></div><h4 id="6-镜像和容器的区别"><a href="#6-镜像和容器的区别" class="headerlink" title="6.镜像和容器的区别"></a>6.镜像和容器的区别</h4><h3 id="Docker命令实战"><a href="#Docker命令实战" class="headerlink" title="Docker命令实战"></a>Docker命令实战</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1692071527786-0d52ba68-3e36-4c18-b8eb-96a6ab5a7d03.png#averageHue=%23e3e2e1&clientId=uac0c1727-261a-4&from=paste&height=478&id=u8ac5de6b&originHeight=597&originWidth=1066&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=235950&status=done&style=none&taskId=u6a7c6476-c964-4a45-bda6-bab61e7b3ce&title=&width=852.8" alt="image.png"></p><h4 id="基础实战"><a href="#基础实战" class="headerlink" title="基础实战"></a>基础实战</h4><h5 id="1、找镜像"><a href="#1、找镜像" class="headerlink" title="1、找镜像"></a>1、找镜像</h5><p>去<a href="http://hub.docker.com/">docker hub</a>，找到nginx镜像</p><div class="code-wrapper"><pre><code class="hljs clean">docker pull nginx  #下载最新版镜像名:版本名（标签）docker pull nginx:<span class="hljs-number">1.20</span><span class="hljs-number">.1</span>docker pull redis  #下载最新docker pull redis:<span class="hljs-number">6.2</span><span class="hljs-number">.4</span>## 下载来的镜像都在本地docker images  #查看所有镜像##删除镜像docker rmi redis##删除中的redis为redis = redis:latestdocker rmi 镜像名:版本号/镜像id##每个镜像都有一个id,可以根据id删除镜像##如果要删除的镜像真正使用，</code></pre></div><p>Nginx（发音为 “engine-x”）是一个用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议的开源反向代理服务器，以及负载均衡器、HTTP 缓存和 Web 服务器（原始服务器）。 nginx 项目一开始就非常注重高并发、高性能和低内存占用。它是根据 2 条款 BSD 类许可证获得许可的，并且可以在 Linux、BSD 变体、Mac OS X、Solaris、AIX、HP-UX 以及其他 *nix 版本上运行。它还具有适用于 Microsoft Windows 的概念验证端口。</p><h5 id="docker删除："><a href="#docker删除：" class="headerlink" title="docker删除："></a>docker删除：</h5><p>docker rm 和docker rmi的区别</p><ul><li>docker rm 用于删除容器，而 docker rmi 用于删除镜像。</li><li>docker rm 可以删除正在运行的容器，而 docker rmi 只能删除未被使用的镜像。</li><li>删除容器可以使用容器 ID 或容器名称，而删除镜像可以使用镜像 ID 或镜像标签。</li></ul><p>如何批量删除运行中的容器<br>docker rm -f $(docker ps -q)这里的docker ps -q是列出正在运行的容器，$()是将括号里面执行结果当做参数传递给docker rm 命令。<br>要删除多个镜像，可以将它们列在一个命令中<br>docker rmi image1:tag image2:tag image3:tag<br>要删除多个容器，你可以使用以下命令：<br>docker rm container1 container2 container3 …</p><h5 id="2、启动容器"><a href="#2、启动容器" class="headerlink" title="2、启动容器"></a>2、启动容器</h5><p>启动nginx应用容器，并映射88端口，测试的访问</p><div class="code-wrapper"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> [OPTIONS] IMAGE [COMMAND] [ARG<span class="hljs-built_in">..</span>.]【docker <span class="hljs-built_in">run</span>  设置项   镜像名  】 镜像启动运行的命令（镜像里面默认有的，一般不会写）<span class="hljs-comment"># -d：后台运行</span><span class="hljs-comment"># --restart=always: 开机自启</span>docker <span class="hljs-built_in">run</span> <span class="hljs-attribute">--name</span>=mynginx   -d  <span class="hljs-attribute">--restart</span>=always -p  88:80  nginx<span class="hljs-comment">##--name：给启动的镜像生成的容器起一个名字（启动后通过docker ps可以查看启动的容器</span>其中有个names属性，这里的--name就是设置names属性的，<span class="hljs-comment">##-d:是后台启动也就是不在当前的终端启动，而是在后台启动。如果不选择这个</span>就会在当前的终端启动，且占据着当前的终端，无法在当前的终端使用其他命令。<span class="hljs-comment">##88：80就是端口映射，其中的88是主机的端口，80是容器的端口。</span><span class="hljs-comment"># 查看正在运行的容器</span>docker ps<span class="hljs-comment"># 查看所有，包括停止运行的容器</span>docker ps -a<span class="hljs-comment"># 删除停止的容器（要指定容器的id/名字）</span>docker rm  容器id/名字docker rm -f mynginx   #强制删除正在运行中的<span class="hljs-comment">#停止容器</span>docker stop 容器id/名字<span class="hljs-comment">#再次启动</span>docker start 容器id/名字<span class="hljs-comment">#应用开机自启</span>docker update 容器id/名字 <span class="hljs-attribute">--restart</span>=always</code></pre></div><h5 id="端口映射："><a href="#端口映射：" class="headerlink" title="端口映射："></a>端口映射：</h5><h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693661640773-7d47d1c1-5dc0-43aa-844b-46ebc764ac6e.png#averageHue=%236faab3&clientId=u199a9dfb-f232-4&from=paste&height=270&id=u0a4fc328&originHeight=337&originWidth=609&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=37379&status=done&style=none&taskId=u205d8096-4b14-4c4a-8abc-bbf708f17d8&title=&width=487.2" alt="image.png"></h5><p>每个容器相当于一个小的Linux,每个容器都可以设置自己的端口，但是主机也有个端口88.端口映射就是后面我们通过公网ip访问88端口的时候实际上是访问nginx容器的80端口。其中容器启动的时候设置了端口映射可以通过docker ps命名查看到的<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693661968373-5247f323-5162-4d5b-88d6-e5a4021ff1d5.png#averageHue=%23202969&clientId=u199a9dfb-f232-4&from=paste&height=65&id=u215928cb&originHeight=81&originWidth=1155&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=105387&status=done&style=none&taskId=ubeac012b-f2a1-4f31-addf-172b56a0f42&title=&width=924" alt="image.png"><br>这里就可以通过公网ip，端口88(注意不要添加http)访问80的nginx.<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693662068364-ed63640f-d323-413e-b3ca-8822b1ab1c30.png#averageHue=%23f6f5f4&clientId=u199a9dfb-f232-4&from=paste&height=286&id=uad59c2ba&originHeight=358&originWidth=806&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=38541&status=done&style=none&taskId=u6fedb865-c35a-4f6e-bafa-ebce95595a8&title=&width=644.8" alt="image.png"></p><h5 id="3、修改容器内容（可以去dockpub官网查看相关容器的用法）"><a href="#3、修改容器内容（可以去dockpub官网查看相关容器的用法）" class="headerlink" title="3、修改容器内容（可以去dockpub官网查看相关容器的用法）"></a>3、修改容器内容（可以去dockpub官网查看相关容器的用法）</h5><p>修改默认的index.html 页面</p><h6 id="1、进容器内部修改"><a href="#1、进容器内部修改" class="headerlink" title="1、进容器内部修改"></a>1、进容器内部修改</h6><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 进入容器内部的系统，修改容器内容</span>docker <span class="hljs-built_in">exec</span> -it 容器<span class="hljs-built_in">id</span>  /bin/bash<span class="hljs-comment">##容器相当于一个小的linux这里是进入小linux中的shell当然这里也可以选择</span>/bin/sh，</code></pre></div><h6 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693662555584-0f50aa80-013f-4ef2-b825-2cc4e08f0746.png#averageHue=%231f2869&clientId=u199a9dfb-f232-4&from=paste&height=54&id=u3c41def4&originHeight=68&originWidth=1285&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=95065&status=done&style=none&taskId=uf2b7db52-7049-40c2-8a43-6e9f0820f09&title=&width=1028" alt="image.png"></h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693664468867-2975cbcf-a97d-48d0-83a8-dfff635bd638.png#averageHue=%23223071&clientId=u199a9dfb-f232-4&from=paste&height=233&id=uc54b05ff&originHeight=291&originWidth=1427&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=497796&status=done&style=none&taskId=uf5b39572-2572-4c63-b16e-7e914595699&title=&width=1141.6" alt="image.png"><br>再次登录的结果：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693664502030-7539f9e6-9251-4553-9953-92cc83e59f6f.png#averageHue=%23e5e4e3&clientId=u199a9dfb-f232-4&from=paste&height=72&id=u98dda7c1&originHeight=90&originWidth=353&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=4561&status=done&style=none&taskId=u58eca5aa-3888-4200-b270-af1659e196d&title=&width=282.4" alt="image.png"><br>使用exit就退出容器。</p><h6 id="2、挂载数据到外部修改"><a href="#2、挂载数据到外部修改" class="headerlink" title="2、挂载数据到外部修改"></a>2、挂载数据到外部修改</h6><div class="code-wrapper"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> <span class="hljs-attribute">--name</span>=mynginx   \-d  <span class="hljs-attribute">--restart</span>=always \-p  88:80 -v /data/html:/usr/share/nginx/html:ro  \nginx<span class="hljs-comment"># 修改页面只需要去 主机的 /data/html</span></code></pre></div><h6 id="4、提交改变"><a href="#4、提交改变" class="headerlink" title="4、提交改变"></a>4、提交改变</h6><p>将自己修改好的镜像提交</p><div class="code-wrapper"><pre><code class="hljs stylus">docker commit <span class="hljs-selector-attr">[OPTIONS]</span> CONTAINER <span class="hljs-selector-attr">[REPOSITORY[:TAG]</span>]docker commit -<span class="hljs-selector-tag">a</span> <span class="hljs-string">&quot;leifengyang&quot;</span>  -m <span class="hljs-string">&quot;首页变化&quot;</span> <span class="hljs-number">341</span>d81f7504f guignginx:v1.<span class="hljs-number">0</span>##这个命令有以下几个部分：-<span class="hljs-selector-tag">a</span> <span class="hljs-string">&quot;leifengyang&quot;</span>：指定作者信息为 <span class="hljs-string">&quot;leifengyang&quot;</span>，表示创建镜像的作者。-m <span class="hljs-string">&quot;首页变化&quot;</span>：指定提交消息为 <span class="hljs-string">&quot;首页变化&quot;</span>，用于描述这个镜像的变化或修改。<span class="hljs-number">341</span>d81f7504f：容器的 ID，表示要基于此容器创建新的镜像。guignginx:v1.<span class="hljs-number">0</span>：新镜像的名称和标签，这里将创建一个名为 <span class="hljs-string">&quot;guignginx&quot;</span>，标签为 <span class="hljs-string">&quot;v1.0&quot;</span> 的镜像。执行该命令后，Docker 将根据容器的当前状态创建一个新的镜像，并将其命名为 <span class="hljs-string">&quot;guignginx:v1.0&quot;</span>，包含了您在容器中所做的更改。</code></pre></div><p>提交改变后，如果后面删除了原来的镜像，想要运行新的镜像的时候，如果用<br>docker run –name&#x3D;mynginx   -d  –restart&#x3D;always -p  88:80  nginx命令<br>运行镜像时，运行的是默认镜像。这个时候可以运行刚刚提交的镜像<br>docker run –name&#x3D;mynginx   -d  –restart&#x3D;always -p  88:80  guignginx:v1.0<br>这样就可以运行和刚刚删除的容器一样的容器而不必重新在新的容器上修改。</p><h6 id="镜像保存："><a href="#镜像保存：" class="headerlink" title="镜像保存："></a>镜像保存：</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693666166503-76847856-5dbd-41c1-b985-d573593d50ee.png#averageHue=%2319191a&clientId=u199a9dfb-f232-4&from=paste&height=198&id=u4444ecb0&originHeight=247&originWidth=855&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=88985&status=done&style=none&taskId=u432223cc-3ccb-4a43-bafa-c67f0b00a05&title=&width=684" alt="image.png"></p><h6 id="1、镜像传输"><a href="#1、镜像传输" class="headerlink" title="1、镜像传输"></a>1、镜像传输</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693666351488-fcc58253-ce49-485b-a0dd-b0f91e801603.png#averageHue=%231a1a1b&clientId=u199a9dfb-f232-4&from=paste&height=387&id=u19a7bd17&originHeight=484&originWidth=951&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=212480&status=done&style=none&taskId=u8e036015-3d49-43b5-9c69-60df8df3dc8&title=&width=760.8" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs gauss"><span class="hljs-meta"># 将镜像保存成压缩包</span>docker <span class="hljs-keyword">save</span> -o abc.tar guignginx:v1<span class="hljs-number">.0</span><span class="hljs-meta"># 别的机器加载这个镜像</span>docker <span class="hljs-keyword">load</span> -i abc.tar<span class="hljs-meta">#-i 表示输入文件（input file），指定要加载的镜像存储文件的路径。</span>abc.tar 是一个镜像存储文件，通过该命令，Docker 将读取该文件并加载其中的镜像到本地 Docker 引擎中。<span class="hljs-meta"># 离线安装</span></code></pre></div><h6 id="5、推送远程仓库"><a href="#5、推送远程仓库" class="headerlink" title="5、推送远程仓库"></a>5、推送远程仓库</h6><p>推送镜像到docker hub；应用市场（前提要注册，然后自己创建一个仓库）</p><div class="code-wrapper"><pre><code class="hljs maxima">docker tag <span class="hljs-built_in">local</span>-<span class="hljs-built_in">image</span>:tagname <span class="hljs-built_in">new</span>-repo:tagnamedocker <span class="hljs-built_in">push</span> <span class="hljs-built_in">new</span>-repo:tagname</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 把旧镜像的名字，改成仓库要求的新版名字</span>docker tag guignginx:v1.0 leifengyang/guignginx:v1.0<span class="hljs-comment">#</span>通过执行该命令，Docker 将为镜像 guignginx:v1.0 创建一个新的标签leifengyang/guignginx:v1.0。这个操作不会创建新的镜像副本，只是为现有镜像添加了一个新的标签。这样，您可以通过两个不同的标签来引用同一个镜像。<span class="hljs-comment"># 登录到docker hub，只需要登录一次，下次启动服务器的时(没有退出）不需要登录直接</span>pushdocker login       docker <span class="hljs-built_in">logout</span>（推送完成镜像后退出）<span class="hljs-comment"># 推送</span>docker push leifengyang/guignginx:v1.0<span class="hljs-comment"># 别的机器下载</span>docker pull leifengyang/guignginx:v1.0</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693668015733-b27ce633-6a8d-4fbe-bb30-53fe273d574d.png#averageHue=%232c3d7e&clientId=u199a9dfb-f232-4&from=paste&height=370&id=u06e55159&originHeight=462&originWidth=1240&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=692661&status=done&style=none&taskId=uf8fbd6a9-51b2-4511-9175-91e09c11c57&title=&width=992" alt="image.png"></p><h6 id="6、补充"><a href="#6、补充" class="headerlink" title="6、补充"></a>6、补充</h6><div class="code-wrapper"><pre><code class="hljs awk">docker logs 容器名/id   排错docker exec -it 容器id <span class="hljs-regexp">/bin/</span>bash<span class="hljs-comment"># docker 经常修改nginx配置文件</span>docker run -d -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> \-v <span class="hljs-regexp">/data/</span>html:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html:ro \-v <span class="hljs-regexp">/data/</span>conf<span class="hljs-regexp">/nginx.conf:/</span>etc<span class="hljs-regexp">/nginx/</span>nginx.conf \--name mynginx-<span class="hljs-number">02</span> \nginx<span class="hljs-comment">#-v /data/html:/usr/share/nginx/html:ro：将主机的 /data/html </span>目录挂载到容器内的 <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html 目录，并设置为只读模式 (ro)。这样，容器内的 Nginx 将使用主机上的 HTML 文件。-v <span class="hljs-regexp">/data/</span>conf<span class="hljs-regexp">/nginx.conf:/</span>etc<span class="hljs-regexp">/nginx/</span>nginx.conf：将主机的 <span class="hljs-regexp">/data/</span>conf/nginx.conf 文件挂载到容器内的<span class="hljs-regexp">/etc/</span>nginx/nginx.conf 文件，用于替换容器内的 Nginx 配置文件。--name mynginx-<span class="hljs-number">02</span>：指定容器的名称为 mynginx-<span class="hljs-number">02</span>。nginx：要运行的镜像名称。<span class="hljs-comment">#把容器指定位置的东西复制出来 </span>docker cp <span class="hljs-number">5</span>eff66eec7e1:<span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/nginx.conf  /</span>data<span class="hljs-regexp">/conf/</span>nginx.conf<span class="hljs-comment">#把外面的内容复制到容器里面</span>docker cp  <span class="hljs-regexp">/data/</span>conf<span class="hljs-regexp">/nginx.conf  5eff66eec7e1:/</span>etc<span class="hljs-regexp">/nginx/</span>nginx.conf</code></pre></div><h3 id="进阶实战"><a href="#进阶实战" class="headerlink" title="进阶实战"></a>进阶实战</h3><h4 id="1、编写自己的应用"><a href="#1、编写自己的应用" class="headerlink" title="1、编写自己的应用"></a>1、编写自己的应用</h4><p>编写一个HelloWorld应用<br><a href="https://start.spring.io/">https://start.spring.io/</a></p><p>示例代码： <a href="https://gitee.com/leifengyang/java-demo.git">https://gitee.com/leifengyang/java-demo.git</a></p><h5 id="2、将应用打包成镜像"><a href="#2、将应用打包成镜像" class="headerlink" title="2、将应用打包成镜像"></a>2、将应用打包成镜像</h5><p>编写Dockerfile将自己的应用打包镜像</p><h5 id="1、以前"><a href="#1、以前" class="headerlink" title="1、以前"></a>1、以前</h5><p>Java为例</p><ul><li>SpringBoot打包成可执行jar</li><li>把jar包上传给服务</li><li>服务器运行java -jar</li></ul><h5 id="2、现在"><a href="#2、现在" class="headerlink" title="2、现在"></a>2、现在</h5><p>所有机器都安装Docker，任何应用都是镜像，所有机器都可以运行</p><h5 id="3、怎么打包-Dockerfile"><a href="#3、怎么打包-Dockerfile" class="headerlink" title="3、怎么打包-Dockerfile"></a>3、怎么打包-Dockerfile</h5><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">8</span>-jdk-slim<span class="hljs-keyword">LABEL</span><span class="language-bash"> maintainer=leifengyang</span><span class="hljs-keyword">COPY</span><span class="language-bash"> target/*.jar   /app.jar</span><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;/app.jar&quot;</span>]</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs mipsasm">docker <span class="hljs-keyword">build </span>-t <span class="hljs-keyword">java-demo:v1.0 </span>.</code></pre></div><p>思考：<br>每个应用每次打包，都需要本地编译、再上传服务器、再进行docker构建，如果有1000个应用要打包镜像怎么办？有没有更好的方式？</p><h5 id="3、启动容器"><a href="#3、启动容器" class="headerlink" title="3、启动容器"></a>3、启动容器</h5><p>启动应用容器</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d -p <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> --name myjava-app java-demo:v1.<span class="hljs-number">0</span></code></pre></div><p>分享镜像</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># 登录docker hub</span><span class="hljs-attribute">docker</span> login<span class="hljs-comment">#给旧镜像起名</span><span class="hljs-attribute">docker</span> tag java-demo:v1.<span class="hljs-number">0</span>  leifengyang/java-demo:v1.<span class="hljs-number">0</span><span class="hljs-comment"># 推送到docker hub</span><span class="hljs-attribute">docker</span> push leifengyang/java-demo:v1.<span class="hljs-number">0</span><span class="hljs-comment"># 别的机器</span><span class="hljs-attribute">docker</span> pull leifengyang/java-demo:v1.<span class="hljs-number">0</span><span class="hljs-comment"># 别的机器运行</span><span class="hljs-attribute">docker</span> run -d -p <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> --name myjava-app java-demo:v1.<span class="hljs-number">0</span></code></pre></div><h5 id="4、部署中间件"><a href="#4、部署中间件" class="headerlink" title="4、部署中间件"></a>4、部署中间件</h5><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693720409476-cdc02b96-0977-43bb-8468-a5e95524479e.png#averageHue=%2382bec8&clientId=ubd7ce99a-c7e7-4&from=paste&height=362&id=XUcBO&originHeight=452&originWidth=909&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=112189&status=done&style=none&taskId=u246d6b70-14f7-4ec4-86d9-7f461209255&title=&width=727.2" alt="image.png"><br>部署一个Redis+应用，尝试应用操作Redis产生数据</p><div class="code-wrapper"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="language-bash"> [OPTIONS] IMAGE [COMMAND] [ARG...]</span><span class="hljs-comment">#redis使用自定义配置文件启动</span>docker <span class="hljs-keyword">run</span><span class="language-bash"> -v /data/redis/redis.conf:/etc/redis/redis.conf \</span><span class="language-bash">-v /data/redis/data:/data \</span><span class="language-bash">-d --name myredis \</span><span class="language-bash">-p 6379:6379 \</span><span class="language-bash">redis:latest  redis-server /etc/redis/redis.conf</span></code></pre></div><p>Redis配置密码：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693721336317-8222233b-4a16-424e-aa2f-c6ddb6ad2f6c.png#averageHue=%23151516&clientId=ubd7ce99a-c7e7-4&from=paste&height=190&id=u6e8c45ae&originHeight=237&originWidth=583&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=35158&status=done&style=none&taskId=u26f9ab92-c709-4582-88b0-ec1e8978e04&title=&width=466.4" alt="image.png"><br>连接Redis:<br>测试使用redis:</p><h2 id="1、NoSQL"><a href="#1、NoSQL" class="headerlink" title="1、NoSQL"></a>1、NoSQL</h2><h3 id="Redis整合"><a href="#Redis整合" class="headerlink" title="Redis整合"></a>Redis整合</h3><p>**Redis不会的同学：参照 阳哥-《Redis7》 **<a href="https://www.bilibili.com/video/BV13R4y1v7sP?p=1"><strong>https://www.bilibili.com/video/BV13R4y1v7sP?p=1</strong></a><br>**HashMap： key：value</p><p>**</p><h2 id="1-场景整合"><a href="#1-场景整合" class="headerlink" title="1. 场景整合"></a><strong>1. 场景整合</strong></h2><p><strong>依赖导入</strong></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>配置</p><div class="code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">spring</span>.<span class="hljs-class"><span class="hljs-keyword">data</span>.redis.host=192.168.200.100</span><span class="hljs-title">spring</span>.<span class="hljs-class"><span class="hljs-keyword">data</span>.redis.password=<span class="hljs-type">Lfy123</span>!@!</span></code></pre></div><p><strong>测试</strong></p><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@Autowired</span>StringRedisTemplate redisTemplate;<span class="hljs-variable">@Test</span>void <span class="hljs-built_in">redisTest</span>()&#123;    <span class="hljs-selector-tag">redisTemplate</span><span class="hljs-selector-class">.opsForValue</span>()<span class="hljs-selector-class">.set</span>(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;1234&quot;</span>);    <span class="hljs-selector-tag">Assertions</span><span class="hljs-selector-class">.assertEquals</span>(<span class="hljs-string">&quot;1234&quot;</span>,redisTemplate.<span class="hljs-built_in">opsForValue</span>().<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;a&quot;</span>));&#125;</code></pre></div><h2 id="2-自动配置原理-1"><a href="#2-自动配置原理-1" class="headerlink" title="2. 自动配置原理"></a><strong>2. 自动配置原理</strong></h2><ol><li>META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports中导入了<code>RedisAutoConfiguration</code>、RedisReactiveAutoConfiguration和RedisRepositoriesAutoConfiguration。所有属性绑定在<code>RedisProperties</code>中</li><li>RedisReactiveAutoConfiguration属于响应式编程，不用管。RedisRepositoriesAutoConfiguration属于 JPA 操作，也不用管</li><li>RedisAutoConfiguration 配置了以下组件<ol><li>LettuceConnectionConfiguration： 给容器中注入了连接工厂LettuceConnectionFactory，和操作 redis 的客户端DefaultClientResources。</li><li><code>RedisTemplate&lt;Object, Object&gt;</code>： 可给 redis 中存储任意对象，会使用 jdk 默认序列化方式。</li><li><code>StringRedisTemplate</code>： 给 redis 中存储字符串，如果要存对象，需要开发人员自己进行序列化。key-value都是字符串进行操作··,如果key和value中有一个是实体对象可以将对象转化为json数据（字符串）来进行操作、，</li></ol></li></ol><h2 id="3-定制化"><a href="#3-定制化" class="headerlink" title="3. 定制化"></a>3. 定制化</h2><div class="code-wrapper"><pre><code class="hljs pgsql">@<span class="hljs-keyword">Configuration</span><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> AppRedisConfiguration &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 允许Object类型的key-value，都可以被转为json进行存储。</span><span class="hljs-comment">     * @param redisConnectionFactory 自动配置好了连接工厂</span><span class="hljs-comment">     * @return</span><span class="hljs-comment">     */</span>    @Bean    <span class="hljs-built_in">public</span> RedisTemplate&lt;<span class="hljs-keyword">Object</span>, <span class="hljs-keyword">Object</span>&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;        RedisTemplate&lt;<span class="hljs-keyword">Object</span>, <span class="hljs-keyword">Object</span>&gt; template = <span class="hljs-built_in">new</span> RedisTemplate&lt;&gt;();        <span class="hljs-keyword">template</span>.setConnectionFactory(redisConnectionFactory);        //把对象转为<span class="hljs-type">json</span>字符串的序列化工具        <span class="hljs-keyword">template</span>.setDefaultSerializer(<span class="hljs-built_in">new</span> GenericJackson2JsonRedisSerializer());        <span class="hljs-keyword">return</span> <span class="hljs-keyword">template</span>;    &#125;&#125;</code></pre></div><h3 id="2-redis客户端"><a href="#2-redis客户端" class="headerlink" title="2. redis客户端"></a><strong>2. redis客户端</strong></h3><blockquote><p><strong>RedisTemplate、StringRedisTemplate： 操作redis的工具类</strong></p><ul><li><strong>要从redis的连接工厂获取链接才能操作redis</strong></li><li><strong>Redis客户端</strong><ul><li><strong>Lettuce： 默认</strong></li><li><strong>Jedis：可以使用以下切换</strong></li></ul></li></ul></blockquote><div class="code-wrapper"><pre><code class="hljs xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.lettuce<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lettuce-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--        切换 jedis 作为操作redis的底层客户端--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="3-配置参考"><a href="#3-配置参考" class="headerlink" title="3. 配置参考"></a><strong>3. 配置参考</strong></h3><div class="code-wrapper"><pre><code class="hljs stylus">spring<span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.redis</span>.host=<span class="hljs-number">8.130</span>.<span class="hljs-number">74.183</span>spring<span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.redis</span>.port=<span class="hljs-number">6379</span><span class="hljs-selector-id">#spring</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.redis</span>.client-type=lettuce#设置lettuce的底层参数<span class="hljs-selector-id">#spring</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.redis</span><span class="hljs-selector-class">.lettuce</span><span class="hljs-selector-class">.pool</span>.enabled=true<span class="hljs-selector-id">#spring</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.redis</span><span class="hljs-selector-class">.lettuce</span><span class="hljs-selector-class">.pool</span>.max-active=<span class="hljs-number">8</span>spring<span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.redis</span>.client-type=jedisspring<span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.redis</span><span class="hljs-selector-class">.jedis</span><span class="hljs-selector-class">.pool</span>.enabled=truespring<span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.redis</span><span class="hljs-selector-class">.jedis</span><span class="hljs-selector-class">.pool</span>.max-active=<span class="hljs-number">8</span></code></pre></div><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><strong>1.</strong></p><h2 id="消息服务："><a href="#消息服务：" class="headerlink" title="消息服务："></a>消息服务：</h2><h2 id="1-docker安装kafka（没学完）"><a href="#1-docker安装kafka（没学完）" class="headerlink" title="1.docker安装kafka（没学完）"></a>1.docker安装kafka（没学完）</h2><p><a href="https://blog.csdn.net/y393016244/article/details/126405864">Docker安装Kafka教程（超详细）_乾坤鸟的博客-CSDN博客</a><br>docker network create app-tier –driver bridge</p><div class="code-wrapper"><pre><code class="hljs livecodeserver">使用命令 docker network <span class="hljs-built_in">create</span> app-tier <span class="hljs-comment">--driver bridge 可以创建一个</span>名为 <span class="hljs-string">&quot;app-tier&quot;</span> 的 Docker 网络，并使用桥接（bridge）驱动程序。这个命令会创建一个桥接网络，桥接网络是 Docker 中默认的网络驱动程序。桥接网络用于连接运行在同一 Docker 主机上的多个容器，使它们能够使用容器名称作为主机名进行通信。通过创建 <span class="hljs-string">&quot;app-tier&quot;</span> 网络，您可以启动容器并将它们连接到该网络，以便实现容器之间的通信。同一网络内的容器可以使用它们的容器名称作为主机名来相互访问。</code></pre></div><div class="code-wrapper"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -d --name kafka-server \    --network app-tier \    -p 9092:9092 \    -e <span class="hljs-attribute">ALLOW_PLAINTEXT_LISTENER</span>=<span class="hljs-literal">yes</span> \    -e <span class="hljs-attribute">KAFKA_CFG_ZOOKEEPER_CONNECT</span>=zookeeper-server:2181 \    -e <span class="hljs-attribute">KAFKA_CFG_ADVERTISED_LISTENERS</span>=PLAINTEXT://8.130.50.249:9092\    bitnami/kafka:latest</code></pre></div><p>2.安装kafkaUi<br><a href="https://blog.csdn.net/qq_42987796/article/details/129799473">【docker】docker安装带ui界面的kafka_docker ui 安装_努力的gopher的博客-CSDN博客</a></p><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">version</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2&quot;</span><span class="hljs-attribute">services</span><span class="hljs-punctuation">:</span>  <span class="hljs-attribute">zookeeper</span><span class="hljs-punctuation">:</span>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">docker.io/bitnami/zookeeper:3.8</span>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;22181:2181&quot;</span>    <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;zookeeper_data:/bitnami&quot;</span>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">ALLOW_ANONYMOUS_LOGIN=yes</span>  <span class="hljs-attribute">kafka</span><span class="hljs-punctuation">:</span>    <span class="hljs-attribute">container_name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">kafka1</span>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">docker.io/bitnami/kafka:3.4</span>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9192:9092&quot;</span>    <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;kafka_data:/bitnami&quot;</span>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">KAFKA_CFG_ZOOKEEPER_CONNECT=zookeeper:2181</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">ALLOW_PLAINTEXT_LISTENER=yes</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://8.130.50.249:9192</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">KAFKA_CFG_AUTO_CREATE_TOPICS_ENABLE=true</span>    <span class="hljs-attribute">depends_on</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">zookeeper</span>  <span class="hljs-attribute">kafka-ui</span><span class="hljs-punctuation">:</span>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">provectuslabs/kafka-ui:latest</span>    <span class="hljs-attribute">container_name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">kafka-ui</span>    <span class="hljs-attribute">restart</span><span class="hljs-punctuation">:</span> <span class="hljs-string">always</span>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">10010:8080</span>    <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">/etc/localtime:/etc/localtime</span>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">KAFKA_CLUSTERS_0_NAME=local</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=kafka1:9092</span><span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span>  <span class="hljs-attribute">zookeeper_data</span><span class="hljs-punctuation">:</span>    <span class="hljs-attribute">driver</span><span class="hljs-punctuation">:</span> <span class="hljs-string">local</span>  <span class="hljs-attribute">kafka_data</span><span class="hljs-punctuation">:</span>    <span class="hljs-attribute">driver</span><span class="hljs-punctuation">:</span> <span class="hljs-string">local</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>springboot2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springboot2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂记</title>
    <link href="/2024/01/26/%E6%9D%82%E8%AE%B0%EF%BC%9A/"/>
    <url>/2024/01/26/%E6%9D%82%E8%AE%B0%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h4 id="云服务器的实例id可以修改吗？"><a href="#云服务器的实例id可以修改吗？" class="headerlink" title="云服务器的实例id可以修改吗？"></a>云服务器的实例id可以修改吗？</h4><p><a href="https://help.aliyun.com/zh/ecs/user-guide/modify-the-properties-of-an-instance">实例 ID 是由系统自动生成的，无法修改。但是您可以修改实例的名称、主机名和实例描述等实例属性以提高云资源的管理效率和可读性，同时也可以提高云资源的安全性和自动化运维的支持程度。</a></p><h4 id="什么是分布式存储？"><a href="#什么是分布式存储？" class="headerlink" title="什么是分布式存储？"></a>什么是分布式存储？</h4><p>分布式存储就像我们的拉货的货车（传统的集中储存），改用一节一节连接起来的火车拉货，当不能满足存储需求的时候，我们只需要添加一节一节的车厢就能满足需求了（易扩展性）。</p><h4 id="什么是流量穿透？"><a href="#什么是流量穿透？" class="headerlink" title="什么是流量穿透？"></a>什么是流量穿透？</h4><p>就是中国移动，电信等国企提供的接入互联网服务时，对中小运营企业收费高，但是对非运营企业收费低。故存在套利空间（中小运营商通过利用非运营企业空余的带宽资源从而节约成本）</p><h4 id="密匙对是什么"><a href="#密匙对是什么" class="headerlink" title="密匙对是什么?"></a>密匙对是什么?</h4><p><strong>一、概念</strong><br>1、<strong>密钥对</strong>：在非对称加密技术中，有两种密钥，分为公钥和私钥。<br>公钥是密钥对所有者持有，<strong>公布给他人的</strong>；私钥也是密钥对所有者持有，<strong>不可公布</strong>。<br>2、<strong>密钥</strong>：指公钥或私钥。<br>3、<strong>公钥</strong>：公钥用来给数据加密，用公钥加密的数据只能使用私钥解密。<br>4、<strong>私钥</strong>：如上，用来解密公钥加密的数据。<br>总结：<strong>公钥和私钥是通过一种算法得到的一个密钥对(即一个公钥和一个私钥)，将其中的一个向外界公开，称为公钥；另一个自己保留，称为私钥。通过这种算法得到的密钥对能保证在世界范围内是唯一的。</strong><br>公钥和私钥是成对的，它们互相解密（密钥指公钥或私钥，密钥对指公钥加私钥）。<br>公钥和私钥都可以加密和解密。<br>私钥数字签名，公钥验证。</p><h4 id="通过宝塔面板出现数据库连接错误的解决方法（注意搜索不到问题的答案的时候要冷静下来思考搜索的输入，不要盲目点点搜索引擎）"><a href="#通过宝塔面板出现数据库连接错误的解决方法（注意搜索不到问题的答案的时候要冷静下来思考搜索的输入，不要盲目点点搜索引擎）" class="headerlink" title="通过宝塔面板出现数据库连接错误的解决方法（注意搜索不到问题的答案的时候要冷静下来思考搜索的输入，不要盲目点点搜索引擎）"></a>通过宝塔面板出现数据库连接错误的解决方法（注意搜索不到问题的答案的时候要冷静下来思考搜索的输入，不要盲目点点搜索引擎）</h4><p><a href="https://www.bt.cn/bbs/thread-40225-1-1.html">MySQL 报 1045 错误解决方法 - Linux面板 - 宝塔面板论坛</a><br>1.通过宝塔面板查看数据库日志看看是什么原因造成的<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693650814661-d2c4920e-7035-4377-acda-109ddbdf28ce.png#averageHue=%238e8c8a&clientId=u4ccb6c37-25e4-4&from=paste&height=546&id=ud487d339&originHeight=682&originWidth=1020&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=134848&status=done&style=none&taskId=ud724d708-9279-4f0e-81eb-ce79cab50a8&title=&width=816" alt="image.png"><br>2.浏览器搜索原因（可以添加宝塔面板字样）</p><h4 id="wordpress登录忘记了密码且无法通过邮箱找回"><a href="#wordpress登录忘记了密码且无法通过邮箱找回" class="headerlink" title="wordpress登录忘记了密码且无法通过邮箱找回"></a>wordpress登录忘记了密码且无法通过邮箱找回</h4><p><a href="https://blog.csdn.net/qq_41990268/article/details/118875760">WordPress忘记密码且邮箱无法发送找回密码链接时的解决办法_wordpress忘记密码无法发送邮件_虎鲸不是鱼的博客-CSDN博客</a><br>方法1：邮箱找回：不过前提是服务器可以发送重置密码的邮件；<br>方法2：修改wordpress储存用户的数据库的密码</p><div class="code-wrapper"><pre><code class="hljs pgsql">mysql -uroot -p这里写刚查看到的root密码;<span class="hljs-keyword">show</span> databases; use wordpress;<span class="hljs-keyword">show</span> <span class="hljs-keyword">tables</span>;<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> wp_users;<span class="hljs-keyword">update</span> wp_users <span class="hljs-keyword">set</span> user_pass=md5(&quot;123456&quot;) <span class="hljs-keyword">where</span> user_login=<span class="hljs-string">&#x27;admin&#x27;</span>;##<span class="hljs-number">123456</span>是你的Wordpress新密码，<span class="hljs-keyword">admin</span>是管理员账号,wordpress采用的是md5加密，而user_pass列的内容是md5加密后的字符串</code></pre></div><p>方法3：使用重置文件(也就是自己写的脚本）<br>将下面的代码另存为 reset_pw.php ，_<strong>注意根据里面的注释修改 2-15行的相关信息</strong>_（如果你不知道数据库的信息，可以查看你网站根目录下的 wp-config.php），然后通过FTP将 reset_pw.php 上传到网站根目录，在浏览器中访问这个文件，就会提示修改成功！<strong>使用完以后，记得删除 reset_pw.php ，以免存在安全隐患！！</strong></p><div class="code-wrapper"><pre><code class="hljs php-template"><span class="language-php"><span class="hljs-meta">&lt;?php</span></span><span class="language-php"><span class="hljs-comment">/*你的数据库服务器地址，一般保持默认*/</span></span><span class="language-php"><span class="hljs-variable">$servername</span> = <span class="hljs-string">&quot;localhost:3306&quot;</span>;</span><span class="language-php"><span class="hljs-comment">/*数据库用户名*/</span></span><span class="language-php"><span class="hljs-variable">$phpMyadminUser</span> = <span class="hljs-string">&quot;root&quot;</span>;</span><span class="language-php"><span class="hljs-comment">/*数据库密码*/</span></span><span class="language-php"><span class="hljs-variable">$phpMyadminKey</span> = <span class="hljs-string">&quot;yiduqiang&quot;</span>;</span><span class="language-php"><span class="hljs-comment">/*数据库名称*/</span></span><span class="language-php"><span class="hljs-variable">$phpMyadminName</span> = <span class="hljs-string">&quot;test&quot;</span>;</span><span class="language-php"><span class="hljs-comment">/*wordpress数据表格前缀*/</span></span><span class="language-php"><span class="hljs-variable">$QZ</span> = <span class="hljs-string">&quot;wp_&quot;</span>;</span><span class="language-php"><span class="hljs-comment">/*你要设置的wordpress新密码*/</span></span><span class="language-php"><span class="hljs-variable">$NewKey</span> = <span class="hljs-string">&quot;yiduqiang&quot;</span>;</span><span class="language-php"><span class="hljs-comment">/*你要设置新密码的用户名*/</span></span><span class="language-php"><span class="hljs-variable">$wordpress_User</span> = <span class="hljs-string">&quot;yiduqiang&quot;</span>;</span><span class="language-php"><span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span> <span class="hljs-string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>wordpress密码找回工具<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"></span><span class="language-php"><span class="hljs-meta">&lt;?php</span></span><span class="language-php"><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);</span><span class="language-php"><span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">mysql_connect</span>(<span class="hljs-variable">$servername</span>,<span class="hljs-variable">$phpMyadminUser</span>,<span class="hljs-variable">$phpMyadminKey</span>))</span><span class="language-php">&#123;</span><span class="language-php">    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;对不起，数据库链接出错。</span></span><span class="hljs-string"><span class="language-php">&quot;</span>;</span><span class="language-php">&#125;</span><span class="language-php"><span class="hljs-keyword">else</span></span><span class="language-php">&#123;</span><span class="language-php">    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;数据库链接成功。</span></span><span class="hljs-string"><span class="language-php">&quot;</span>;</span><span class="language-php">    <span class="hljs-title function_ invoke__">mysql_select_db</span>(<span class="hljs-variable">$phpMyadminName</span>,<span class="hljs-title function_ invoke__">mysql_connect</span>(<span class="hljs-variable">$servername</span>,<span class="hljs-variable">$phpMyadminUser</span>,<span class="hljs-variable">$phpMyadminKey</span>));</span><span class="language-php">    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_ invoke__">mysql_query</span>(<span class="hljs-string">&quot;update &quot;</span>.<span class="hljs-variable">$QZ</span>.<span class="hljs-string">&quot;users set user_pass=&#x27;&quot;</span>.<span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$NewKey</span>).<span class="hljs-string">&quot;&#x27; where user_login=&#x27;&quot;</span>.<span class="hljs-variable">$wordpress_User</span>.<span class="hljs-string">&quot;&#x27;&quot;</span>))</span><span class="language-php">    &#123;</span><span class="language-php">        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;对不起，修改密码失败。&quot;</span>;</span><span class="language-php">    &#125;</span><span class="language-php">    <span class="hljs-keyword">else</span></span><span class="language-php">    &#123;</span><span class="language-php">        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;修改密码成功。&quot;</span>;</span><span class="language-php">    &#125;</span><span class="language-php">&#125;</span><span class="language-php"><span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre></div><h4 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h4><p>1.浏览器输入<a href="http://ip地址解析通常的是/var/www/html">http://ip地址解析通常的是/var/www/html</a> 或 &#x2F;var&#x2F;www文件下的index<br>2.nginx是反向代理，其中可以设置http服务,它和http服务占据的端口都是80,其中通过wordpress建立网站的时候要安装nginx，不然<a href="http://ip无法转到wordpress界面/">http://ip无法转到wordpress界面</a><br>3.mysql中的用户和密码放在mysql数据库中的user表中的<br>4.可以通过在mysql的配置文件中添加</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">skip</span><span class="hljs-operator">-</span><span class="hljs-keyword">grant</span><span class="hljs-operator">-</span>tables</code></pre></div><p>实现免密登录<br>5.更改mysql密码的步骤：</p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-number">1</span>.停止 MySQL 服务：sudo systemctl stop mysqld；<span class="hljs-number">2</span>.启动 MySQL 服务，并跳过权限验证：sudo mysqld_safe --skip-grant-tables &amp;<span class="hljs-number">3</span>.连接到 MySQL 服务器：mysql -u root<span class="hljs-number">4</span>.在 MySQL 提示符下，切换到 mysql 数据库：use mysql;<span class="hljs-number">5</span>.更新 root 用户的密码：update user set authentication_string=password(<span class="hljs-string">&#x27;新密码&#x27;</span>) where user=<span class="hljs-string">&#x27;root&#x27;</span>;<span class="hljs-number">6</span>.刷新权限：flush privileges;<span class="hljs-number">7</span>.退出 MySQL 提示符：<span class="hljs-keyword">exit</span>;<span class="hljs-number">8</span>.停止 MySQL 服务：sudo systemctl stop mysqld<span class="hljs-number">9</span>.启动 MySQL 服务：sudo systemctl start mysqld</code></pre></div><p>8.centos查看占用端口的进程：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> lsof -i :<span class="hljs-number">80</span>##查看占用<span class="hljs-number">80</span>端口的进程</code></pre></div><p>通常一个端口只能被一个进程占用，但是有时候会出现多个进程占据一个端口的情况：<br>1.多个进程占据不同的ip，然后占据同样一个端口<br>2.不同用户下的进程占据同一个端口<br>9.grant all privileges on wordpress.* to ‘wpadmin‘@’localhost’ identified(识别) by ‘Edualiyun@123’;</p><div class="code-wrapper"><pre><code class="hljs pgsql">这是一个授予 MySQL 数据库用户权限的 <span class="hljs-keyword">SQL</span> 语句。该语句将授予名为 <span class="hljs-string">&#x27;wpadmin&#x27;</span> 的用户在名为 <span class="hljs-string">&#x27;wordpress&#x27;</span> 的数据库上的所有权限，并使用密码 <span class="hljs-string">&#x27;Edualiyun@123&#x27;</span> 进行身份验证。解释该语句的各个部分：<span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span>: 授予所有权限。<span class="hljs-keyword">ON</span> wordpress.*: 应用权限到名为 <span class="hljs-string">&#x27;wordpress&#x27;</span> 的数据库中的所有表。<span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;wpadmin&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>: 授予用户 <span class="hljs-string">&#x27;wpadmin&#x27;</span> 权限，并限制该用户只能从本地主机（localhost）连接。IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;Edualiyun@123&#x27;</span>: 设置用户的密码为 <span class="hljs-string">&#x27;Edualiyun@123&#x27;</span>。</code></pre></div><p>10.chown -R apache.apache &#x2F;var&#x2F;www&#x2F;html&#x2F;wordpress</p><div class="code-wrapper"><pre><code class="hljs dts">chown -R apache.apache <span class="hljs-keyword">/var/</span>www<span class="hljs-keyword">/html/</span>wordpress 是一个 Linux 命令，用于更改 <span class="hljs-keyword">/var/</span>www<span class="hljs-keyword">/html/</span>wordpress 目录及其下所有文件和子目录的所有者和所属组。解释该命令的各个部分：<span class="hljs-symbol"></span><span class="hljs-symbol">chown:</span> 表示更改文件或目录的所有者和所属组。-R: 表示递归地修改目录及其下的所有文件和子目录。apache.apache: 表示将所有者设置为 apache 用户，所属组设置为 apache 组。<span class="hljs-keyword">/var/</span>www<span class="hljs-keyword">/html/</span>wordpress: 是要修改所有者和所属组的目标目录路径。</code></pre></div><p>11.更改用户的密码：</p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;username&#x27;</span>@<span class="hljs-string">&#x27;host&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;new_password&#x27;</span>;● usernam<span class="hljs-string">e&#x27;：要更改密码的用户名。</span><span class="hljs-string">● &#x27;</span>host<span class="hljs-string">&#x27;：用户的主机名。如果要更改所有主机上的密码，可以使用 &#x27;</span>%<span class="hljs-string">&#x27; 代替。</span><span class="hljs-string">● &#x27;</span>new_password<span class="hljs-string">&#x27;：要设置的新密码。</span><span class="hljs-string">DENTIFIED BY 是用于指定用户的新密码的子句。当使用 ALTER USER 命令更</span><span class="hljs-string">改用户密码时，您可以使用 IDENTIFIED BY 子句来指定新密码。</span></code></pre></div><h4 id="如何让每次创建maven项目直接使用直接甚至的maven而不是每次去修改？"><a href="#如何让每次创建maven项目直接使用直接甚至的maven而不是每次去修改？" class="headerlink" title="如何让每次创建maven项目直接使用直接甚至的maven而不是每次去修改？"></a>如何让每次创建maven项目直接使用直接甚至的maven而不是每次去修改？</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693670856318-9adb6278-35e9-4092-82c7-88bb3c3cc211.png#averageHue=%233c795f&clientId=u8360c880-6e71-4&from=paste&height=690&id=u019a597e&originHeight=863&originWidth=1329&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=177783&status=done&style=none&taskId=uc3d99e9c-a9d7-44b0-b174-28232a0e0d1&title=&width=1063.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693670901031-7f8b4645-ebb4-49e3-bff9-28be4ba7f223.png#averageHue=%23070606&clientId=u8360c880-6e71-4&from=paste&height=634&id=u436f769d&originHeight=793&originWidth=1261&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=103388&status=done&style=none&taskId=ub568af7d-ceca-4446-8760-4c124457c22&title=&width=1008.8" alt="image.png"></p><h4 id="docker-load-i-abc-tar"><a href="#docker-load-i-abc-tar" class="headerlink" title="docker load -i abc.tar"></a>docker load -i abc.tar</h4><p>docker load 命令用于从一个镜像存储文件（如 .tar 文件）加载镜像到 Docker 引擎。在您提供的命令中：<br>Copy</p><div class="code-wrapper"><pre><code class="hljs css">docker load -<span class="hljs-selector-tag">i</span> abc<span class="hljs-selector-class">.tar</span></code></pre></div><p>这个命令的作用是从名为 abc.tar 的镜像存储文件加载镜像到 Docker 引擎中。<br>-i 参数用于从标准输入（stdin）加载镜像</p><h4 id="docker-tag-guignginx-v1-0-leifengyang-guignginx-v1-0"><a href="#docker-tag-guignginx-v1-0-leifengyang-guignginx-v1-0" class="headerlink" title="docker tag guignginx:v1.0 leifengyang&#x2F;guignginx:v1.0"></a>docker tag guignginx:v1.0 leifengyang&#x2F;guignginx:v1.0</h4><p>docker tag 命令用于为现有的镜像创建一个新的标签。在您提供的命令中：<br>Copy</p><div class="code-wrapper"><pre><code class="hljs crmsh">docker <span class="hljs-keyword">tag</span> <span class="hljs-title">guignginx</span>:v1.<span class="hljs-number">0</span> leifengyang/guignginx:v1.<span class="hljs-number">0</span></code></pre></div><p>这个命令的作用是为已存在的 guignginx:v1.0 镜像创建一个新的标签 leifengyang&#x2F;guignginx:v1.0。<br>通过执行该命令，Docker 将为镜像 guignginx:v1.0 创建一个新的标签 leifengyang&#x2F;guignginx:v1.0。这个操作不会创建新的镜像副本，只是为现有镜像添加了一个新的标签。这样，您可以通过两个不同的标签来引用同一个镜像。</p><h4 id="查看redis的版本"><a href="#查看redis的版本" class="headerlink" title="查看redis的版本"></a>查看redis的版本</h4><div class="code-wrapper"><pre><code class="hljs pgsql">redis-<span class="hljs-keyword">server</span> <span class="hljs-comment">--version</span></code></pre></div><p>redis的命令是redis-server而不是一般的redis</p><h4 id="yum-install-centos-release-scl-scl-utils-build"><a href="#yum-install-centos-release-scl-scl-utils-build" class="headerlink" title="yum install centos-release-scl scl-utils-build"></a>yum install centos-release-scl scl-utils-build</h4><p>yum install -y devtoolset-8-toolchain<br>scl enable devtoolset-8 bash<br>这些命令用于在 CentOS 系统上安装和启用 Devtoolset-8 工具链。Devtoolset 是用于在 CentOS&#x2F;RHEL 系统上使用新版本编译工具的软件集合。<br>以下是对每个命令的解释：</p><ol><li><strong>yum install centos-release-scl scl-utils-build</strong>：<br>这个命令用于安装 CentOS SCL（Software Collections）存储库和 scl-utils-build 工具包。SCL 存储库提供了一组额外的软件包，包括 Devtoolset。</li><li><strong>yum install -y devtoolset-8-toolchain</strong>：<br>这个命令用于安装 Devtoolset-8 工具链。Devtoolset-8 包含了一系列编译工具，如 GCC、G++、调试器等。通过安装这个工具链，你可以在 CentOS 系统上使用更新的编译器和工具。</li><li><strong>scl enable devtoolset-8 bash</strong>：<br>这个命令启用 Devtoolset-8 工具链，使其成为当前会话中的默认编译工具。通过执行这个命令，你将在当前终端会话中使用 Devtoolset-8 提供的编译器和工具。</li></ol><p>请注意，这些命令需要以 root 或具有管理员权限的用户来执行。在执行这些命令之前，确保你的系统已连接到互联网，并且已正确配置了软件包管理器（yum）以从正确的软件源中获取软件包。</p><h4 id="tar-zxvf-redis-6-2-1-tar-gz解读选项"><a href="#tar-zxvf-redis-6-2-1-tar-gz解读选项" class="headerlink" title="tar -zxvf redis-6.2.1.tar.gz解读选项"></a>tar -zxvf redis-6.2.1.tar.gz解读选项</h4><div class="code-wrapper"><pre><code class="hljs diff">tar -zxvf redis-6.2.1.tar.gz 是一个解压缩 tar 压缩文件的命令，其中包含了一些选项。下面是对每个选项的解释：<span class="hljs-deletion">-z：表示使用 gzip 压缩算法解压缩。tar 命令通常用于创建和提取 tar </span>归档文件，但是压缩的归档文件通常会使用 gzip 进行压缩。这个选项告诉tar 命令在解压缩时使用 gzip 解压缩算法。<span class="hljs-deletion">-x：表示提取（解压缩）归档文件。这个选项告诉 tar 命令执行解压缩操作，</span>将归档文件中的内容提取到文件系统中。<span class="hljs-deletion">-v：表示详细模式（verbose mode）。这个选项告诉 tar 命令在执行操作时</span>显示详细的输出，以便用户可以看到正在进行的操作和提取的文件列表。<span class="hljs-deletion">-f：表示指定归档文件。这个选项后面需要指定要操作的归档文件的名称。</span>在这个命令中，redis-6.2.1.tar.gz 是要解压缩的归档文件的名称。</code></pre></div><h4 id="make-distclean"><a href="#make-distclean" class="headerlink" title="make distclean"></a>make distclean</h4><p>用于清理并还原由 GNU Make 构建过程生成的文件和目录。它通常用于清理构建环境，以便重新开始构建过程或将项目还原到初始状态。</p><h4 id="vi命令打开的文件搜索"><a href="#vi命令打开的文件搜索" class="headerlink" title="vi命令打开的文件搜索"></a>vi命令打开的文件搜索</h4><div class="code-wrapper"><pre><code class="hljs excel">在 Vi 编辑器中，你可以使用 / 命令来搜索打开的文件中的特定内容。以下是搜索的基本步骤：打开 Vi 编辑器：在终端中输入 vi 文件名，其中 文件名 是你要编辑的文件的名称。进入搜索模式：按下 / 键进入搜索模式。此时，你将在 Vi 编辑器的底部看到一个斜线 / 作为提示符。输入搜索内容：在斜线 / 后面输入你要搜索的内容，并按下回车键。Vi 将会定位到第一个匹配到的内容。查看搜索结果：Vi 将会高亮显示匹配到的搜索结果。按下 <span class="hljs-built_in">n</span> 键可以跳转到下一个匹配项，按下 <span class="hljs-built_in">N</span> 键可以跳转到上一个匹配项。退出搜索模式：如果你想退出搜索模式并返回正常编辑模式，按下 Esc 键。</code></pre></div><h4 id="阿里云非root用户无法远程登录："><a href="#阿里云非root用户无法远程登录：" class="headerlink" title="阿里云非root用户无法远程登录："></a>阿里云非root用户无法远程登录：</h4><p><a href="https://blog.csdn.net/weixin_42041419/article/details/104774027">阿里云 root ssh远程登录 及 普通非root用户 ssh远程登录 Ubuntu1604_ecs除了root用户_哒哒哒哒哒撞的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>零散知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis尚硅谷课件</title>
    <link href="/2024/01/26/%E5%B0%9A%E7%A1%85%E8%B0%B7_Redis6%E8%AF%BE%E4%BB%B6/"/>
    <url>/2024/01/26/%E5%B0%9A%E7%A1%85%E8%B0%B7_Redis6%E8%AF%BE%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id="框架高级课程系列之Redis6"><a href="#框架高级课程系列之Redis6" class="headerlink" title="框架高级课程系列之Redis6"></a>框架高级课程系列之Redis6</h2><p>尚硅谷JavaEE教研组</p><ol><li><strong>NoSQL数据库简介</strong><ol><li><strong>技术发展</strong></li></ol></li></ol><p>技术的分类<br>1、解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN<br>2、解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis<br>3、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</p><div class="code-wrapper"><pre><code class="hljs">  1. **Web1.0时代**</code></pre></div><p>Web1.0的时代，数据访问量很有限(数据量只是部署到一个服务器中，可是一个服务器的访问量是有上限的），用一夫当关的高性能的单点服务器可以解决大部分问题。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730024175-de0e4e42-179e-4e3b-895e-17700759e95e.png#averageHue=%23f5f5f4&id=bVpXM&originHeight=206&originWidth=625&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **Web2.0时代**</code></pre></div><p>随着Web2.0的时代的到来，用户访问量大幅度提升，同时产生了大量的用户数据。加上后来的智能移动设备的普及，所有的互联网平台都面临了巨大的性能挑战。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730024434-0ade84eb-da30-4a92-ace5-09cea2dc1024.png#averageHue=%23fbfbf9&id=QgJNI&originHeight=249&originWidth=549&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **解决CPU及内存压力**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730024678-7d3c02dc-2b5c-41d2-b8c9-b877787a94cb.jpeg#averageHue=%23fdfdfb&id=RMHWz&originHeight=412&originWidth=612&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **解决IO压力**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730024920-7b0502f1-7db6-46a2-b691-dde5d51cfec8.jpeg#averageHue=%23ecdac9&id=iztPi&originHeight=395&originWidth=534&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>NoSQL数据库</strong><ol><li><strong>NoSQL数据库概述</strong></li></ol></li></ol><p>NoSQL(NoSQL &#x3D; <strong>Not Only SQL</strong> )，意即“不仅仅是SQL”，泛指<strong>非关系型的数据库</strong>。<br>NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。</p><ul><li><p>不遵循SQL标准。</p></li><li><p>不支持ACID。</p></li><li><p>远超于SQL的性能。<br>1. **NoSQL适用场景 **</p></li><li><p>对数据高并发的读写</p></li><li><p>海量数据的读写</p></li><li><p>对数据高可扩展性的<br>1. <strong>NoSQL不适用场景</strong></p></li><li><p>需要事务支持</p></li><li><p>基于sql的结构化查询存储，处理复杂的关系,需要即席查询。</p></li><li><p><strong>（用不着sql的和用了sql也不行的情况，请考虑用NoSql）</strong><br>1. <strong>Memcache</strong><br>| <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730025094-1199db9b-a0b2-4ad7-86d8-c2d6f03e7b47.jpeg#averageHue=%237a7771&id=kcfXq&originHeight=81&originWidth=78&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="> | </p></li><li><p>很早出现的NoSql数据库</p></li><li><p>数据都在内存中，一般不持久化</p></li><li><p>支持简单的key-value模式，支持类型单一</p></li><li><p>一般是作为缓存数据库辅助持久化的数据库<br> |<br> | — | — |</p><div class="code-wrapper"><pre><code class="hljs">1. **Redis**</code></pre></div></li></ul><p> | <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730025274-325bc689-39ae-48c4-b6bc-3994276b632d.jpeg#averageHue=%23583b39&id=Kyfuz&originHeight=58&originWidth=157&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="> | </p><ul><li><p>几乎覆盖了Memcached的绝大部分功能</p></li><li><p>数据都在内存中，支持持久化，主要用作备份恢复</p></li><li><p>除了支持简单的key-value模式，还支持多种数据结构的存储，比如 list、set、hash、zset等。</p></li><li><p>一般是作为缓存数据库辅助持久化的数据库<br> |<br> | — | — |</p><div class="code-wrapper"><pre><code class="hljs">1. **MongoDB**</code></pre></div></li></ul><p> | <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730025458-d1ba96a0-c4b1-4d64-8c1b-19dfaca31068.jpeg#averageHue=%23353638&id=xvUtK&originHeight=60&originWidth=172&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>   | </p><ul><li><p>高性能、开源、模式自由(schema  free)的<strong>文档型数据库</strong></p></li><li><p>数据都在内存中， 如果内存不足，把不常用的数据保存到硬盘</p></li><li><p>虽然是key-value模式，但是对value（尤其是<strong>json</strong>）提供了丰富的查询功能</p></li><li><p>支持二进制数据及大型对象</p></li><li><p>可以根据数据的特点<strong>替代RDBMS</strong> ，成为独立的数据库。或者配合RDBMS，存储特定的数据。<br> |<br> | — | — |</p><ol><li><strong>行式存储数据库（大数据时代）</strong><ol><li><strong>行式数据库</strong></li></ol></li></ol></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730025714-33f52a5c-1350-4b6a-b103-4390136ce59a.jpeg#averageHue=%23fefefc&id=aR4FU&originHeight=294&originWidth=614&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **列式数据库**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730025979-8afc701f-d64a-4b50-b1af-29add5d7ef85.jpeg#averageHue=%23fefefc&id=To3RC&originHeight=297&originWidth=615&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">     1. **Hbase**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730026188-acabbd4f-c8b9-487d-a7c7-4c56f3e7ec94.jpeg#averageHue=%23e0bbb8&id=p0QYN&originHeight=68&originWidth=197&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>HBase是<strong>Hadoop</strong>项目中的数据库。它用于需要对大量的数据进行随机、实时的读写操作的场景中。<br>HBase的目标就是处理数据量<strong>非常庞大</strong>的表，可以用<strong>普通的计算机</strong>处理超过<strong>10亿行数据</strong>，还可处理有数百万<strong>列</strong>元素的数据表。</p><div class="code-wrapper"><pre><code class="hljs">     1. **Cassandra[kəˈsændrə]**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730026415-e41587d3-9c91-4657-a9da-ae4d12dc7b51.jpeg#averageHue=%2396be5e&id=ZYRSN&originHeight=79&originWidth=316&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>Apache Cassandra是一款免费的开源NoSQL数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的**海量数据集(数据量通常达到PB级别)**。在众多显著特性当中，Cassandra最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程。</p><p>| 计算机存储单位 计算机存储单位一般用B，KB，MB，GB，TB，EB，ZB，YB，BB来表示，它们之间的关系是：<br>位 bit (比特)(Binary Digits)：存放一位二进制数，即 0 或 1，最小的存储单位。<br>字节 byte：8个二进制位为一个字节(B)，最常用的单位。<br>1KB (Kilobyte 千字节)&#x3D;1024B，<br>1MB (Megabyte 兆字节 简称“兆”)&#x3D;1024KB，<br>1GB (Gigabyte 吉字节 又称“千兆”)&#x3D;1024MB，<br>1TB (Trillionbyte 万亿字节 太字节)&#x3D;1024GB，其中1024&#x3D;2^10 ( 2 的10次方)，<br>1PB（Petabyte 千万亿字节 拍字节）&#x3D;1024TB，<br>1EB（Exabyte 百亿亿字节 艾字节）&#x3D;1024PB，<br>1ZB (Zettabyte 十万亿亿字节 泽字节)&#x3D; 1024 EB,<br>1YB (Jottabyte 一亿亿亿字节 尧字节)&#x3D; 1024 ZB,<br>1BB (Brontobyte 一千亿亿亿字节)&#x3D; 1024 YB.</p><table><thead><tr><th>注：“兆”为百万级数量单位。</th></tr></thead></table><ol><li><strong>图关系型数据库</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730026617-54037f85-76e9-436a-a371-2025ee7eb66e.jpeg#averageHue=%23256d7e&id=lVgOG&originHeight=45&originWidth=184&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>主要应用：社会关系，公共交通网络，地图及网络拓谱(n*(n-1)&#x2F;2)<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730026840-d4e86748-4ccc-492d-bb02-a042f37e3178.jpeg#averageHue=%23fcfcfc&id=Qe1bj&originHeight=374&originWidth=614&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>DB-Engines 数据库排名</strong></li></ol><p><a href="http://db-engines.com/en/ranking"><strong>http://db-engines.com/en/ranking</strong></a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730027053-000a8467-9e14-4d82-9d9b-67acd902b0bf.png#averageHue=%23f4f1f1&id=KR0mx&originHeight=529&originWidth=1030&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>Redis概述安装</strong></li></ol><ul><li>Redis是一个开源的key-value存储系统。</li><li>和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。</li><li>这些数据类型都支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</li><li>在此基础上，Redis支持各种不同方式的排序。</li><li>与memcached一样，为了保证效率，数据都是缓存在内存中。</li><li>区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</li><li>并且在此基础上实现了master-slave(主从)同步。<ol><li><strong>应用场景</strong><ol><li><strong>配合关系型数据库做高速缓存</strong></li></ol></li></ol></li><li>高频次，热门访问的数据，降低数据库IO</li><li>分布式架构，做session共享</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730027296-d0ed1746-398d-4ad6-a069-95a13289b15e.jpeg#averageHue=%23fefefe&id=ytubD&originHeight=288&originWidth=612&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **多样的数据结构存储持久化数据**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730027552-e85a412b-f826-4aeb-90f4-3d3938f57f33.jpeg#averageHue=%23f6e1b3&id=BvZuL&originHeight=259&originWidth=589&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>Redis安装</strong><table><thead><tr><th>Redis官方网站</th><th>Redis中文官方网站</th></tr></thead><tbody><tr><td><a href="http://redis.io/"><strong>http://redis.io</strong></a></td><td><a href="http://redis.cn/">http://redis.cn/</a></td></tr></tbody></table></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730027790-fc5e341b-4503-46d1-be3d-25f94aa9768d.png#averageHue=%23d8d7d7&id=ZUvxl&originHeight=520&originWidth=904&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730028065-2e2e9d14-3fa4-4681-b917-8fb752aaec0a.png#averageHue=%23e7e6e5&id=cNR9K&originHeight=602&originWidth=868&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **安装版本**</code></pre></div><ul><li>6.2.1 for Linux（redis-6.2.1.tar.gz）</li><li>不用考虑在windows环境下对Redis的支持</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730028304-e77217ee-2e83-47d8-b3d7-113d77246779.jpeg#averageHue=%23e3e1dc&id=AXZed&originHeight=62&originWidth=618&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **安装步骤**     1. **准备工作：下载安装最新版的gcc编译器**</code></pre></div><p>安装C 语言的编译环境<br><strong>yum install centos-release-scl scl-utils-build</strong><br><strong>yum install -y devtoolset-8-toolchain</strong><br><strong>scl enable devtoolset-8 bash</strong><br>**测试 gcc版本 **<br><strong>gcc –version</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730028505-f0f903ef-6226-47d3-b2ca-0e33aaf8c6e4.png#averageHue=%23110d09&id=l2q01&originHeight=95&originWidth=724&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">     1. **下载redis-6.2.1.tar.gz放/opt目录**     2. **解压命令：tar -zxvf redis-6.2.1.tar.gz**     3. **解压完成后进入目录：cd redis-6.2.1**     4. **在redis-6.2.1目录下再次执行make命令（只是编译好）**     5. **如果没有准备好C语言编译环境，make 会报错—Jemalloc/jemalloc.h：没有那个文件**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730028763-7c216a0e-fd7c-439c-b8f4-3e83a3176204.jpeg#averageHue=%230b0908&id=qjmPY&originHeight=235&originWidth=610&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">     1. **解决方案：运行make distclean**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730029022-e087da3f-8cfa-43c0-b7ab-f21c02ebb5f6.jpeg#averageHue=%23080706&id=K3tab&originHeight=165&originWidth=613&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">     1. **在redis-6.2.1目录下再次执行make命令（只是编译好）**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730029271-b5265504-b824-449e-b6d9-9ce0cac16298.jpeg#averageHue=%230d0a06&id=ZqZ35&originHeight=234&originWidth=311&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">     1. **跳过make test 继续执行: make install**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730029545-606e6f99-0021-4103-a63b-19121e66c882.jpeg#averageHue=%23584f46&id=KtAlt&originHeight=204&originWidth=382&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **安装目录：/**usr/local/bin</code></pre></div><p>查看默认安装目录：<br>redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何<br>redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲<br>redis-check-dump：修复有问题的dump.rdb文件<br>redis-sentinel：Redis集群使用<br>redis-server：Redis服务器启动命令<br>redis-cli：客户端，操作入口</p><div class="code-wrapper"><pre><code class="hljs">  1. **前台启动（不推荐）**</code></pre></div><p>前台启动，命令行窗口不能关闭，否则服务器停止<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730029828-3bb4bd46-5323-4e46-b477-60de7a51a16f.jpeg#averageHue=%23443f39&id=pNpen&originHeight=441&originWidth=619&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **后台启动（推荐）**     1. **备份redis.conf**</code></pre></div><p>拷贝一份redis.conf到其他目录<br>cp  &#x2F;opt&#x2F;redis-3.2.5&#x2F;redis.conf  &#x2F;myredis</p><div class="code-wrapper"><pre><code class="hljs">     1. **后台启动设置daemonize no改成yes**</code></pre></div><p>修改redis.conf(128行)文件将里面的daemonize no 改成 yes，让服务在后台启动</p><div class="code-wrapper"><pre><code class="hljs vim">Redis daemonize介绍<span class="hljs-number">1</span>、daemonize介绍A、redis.<span class="hljs-keyword">conf</span>配置文件中daemonize守护线程，默认是NO。B、daemonize是用来指定redis是否要用守护线程的方式启动。<span class="hljs-number">2</span>、daemonize 设置yes或者<span class="hljs-keyword">no</span>区别daemonize:ye<span class="hljs-variable">s:redis</span>采用的是单进程多线程的模式。当redis.<span class="hljs-keyword">conf</span>中选项daemonize设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行，并将进程pid号写入至redis.<span class="hljs-keyword">conf</span>选项pidfile设置的文件中，此时redis将一直运行，除非手动kill该进程。（有时候手动杀死了redis进程但是用<span class="hljs-keyword">ps</span> -ef | <span class="hljs-keyword">grep</span> redis 发现又以新的pid重启了，那可能是有父进程自动生成了redis进程。这个时候可以使用service redis-server <span class="hljs-keyword">stop</span>命令关闭redis进程同时让父进程无法重启redis进程）。service redis-server <span class="hljs-keyword">stop</span>命令会保存内存中的数据到磁盘上，然后关闭。解决无法关闭redis的方法<span class="hljs-number">2</span>:daemonize:<span class="hljs-keyword">no</span>: 当daemonize选项设置成<span class="hljs-keyword">no</span>时，当前界面将进入redis的命令行界面，<span class="hljs-keyword">exit</span>强制退出或者关闭连接工具(putty,xshell等)都会导致redis进程退出。</code></pre></div><div class="code-wrapper"><pre><code class="hljs vim">redis中的daemonize配置为yes时，表示开启守护进程模式，redis会在后台运行，并将进程pid号写入至redis.<span class="hljs-keyword">conf</span>选项pidfile设置的文件中，此时redis将一直运行，除非手动kill该进程如果你想要杀死redis进程，你可以先用<span class="hljs-keyword">ps</span> -ef | <span class="hljs-keyword">grep</span> redis-server命令找到redis的进程号，然后用sudo kill <span class="hljs-symbol">&lt;pid&gt;</span>命令强制终止该进程如果你发现redis进程被重启了，可能是因为有其他的父进程在监控它，你可以用<span class="hljs-keyword">ps</span> -<span class="hljs-keyword">o</span> ppid= <span class="hljs-symbol">&lt;pid&gt;</span>命令查看是否有父进程存在，如果有，你也需要杀死父进程</code></pre></div><div class="code-wrapper"><pre><code class="hljs">     1. **Redis启动**</code></pre></div><p>redis-server&#x2F;myredis&#x2F;redis.conf<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730030045-794a9dd4-34b6-457a-9354-349986f54973.jpeg#averageHue=%23504a41&id=evehi&originHeight=70&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">     1. **用客户端访问：redis-cli**</code></pre></div><p>   1. </p><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730030271-7201ddb3-8d85-46f3-a8c9-cc0a74976dbd.jpeg#averageHue=%23395a32&id=C6OLI&originHeight=41&originWidth=218&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">     1. **多个端口可以：redis-cli -p6379**</code></pre></div><p><a href="https://www.cnblogs.com/kongzhongqijing/p/6867960.html">redis cli命令 - milkty - 博客园</a></p><div class="code-wrapper"><pre><code class="hljs">     2. **测试验证： ping**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730030475-37d148f6-3826-4a8e-b952-d09b8b6404ea.jpeg#averageHue=%23635a4d&id=RecC7&originHeight=38&originWidth=193&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">     1. **Redis关闭**</code></pre></div><p>单实例关闭：redis-cli shutdown<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730030719-2395f73a-ba68-46e1-b311-07705f9fc5c5.jpeg#averageHue=%234f473f&id=xhvma&originHeight=68&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>也可以进入终端后再关闭<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730030957-49053f95-1d0d-40b6-ac2f-b1c8c7941dff.jpeg#averageHue=%23676054&id=QlgGg&originHeight=41&originWidth=231&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>多实例关闭，指定端口关闭：redis-cli -p 6379 shutdown<br>也可以找到redis的进程号然后用kill -9 pid杀掉也可以。</p><div class="code-wrapper"><pre><code class="hljs">  1. **Redis介绍相关知识**</code></pre></div><p>| 端口6379从何而来<br>Alessia  Merz<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730031186-7ab5b215-6ce9-4ce7-abb8-d9cce1f5422e.jpeg#averageHue=%237c7362&id=aDfhF&originHeight=72&originWidth=136&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="> | 默认16个数据库，类似数组下标从0开始，初始默认使用0号库<br>使用命令 select   <dbid>来切换数据库。如: select 8<br>统一密码管理，所有库同样密码。<br>dbsize查看当前数据库的key的数量<br>flushdb清空当前库</p><p>flushall通杀全部库 |<br>| — | — |</p><p>Redis是单线程+多路IO复用技术<br>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）<br>串行   vs   多线程+锁（memcached） vs   单线程+多路IO复用(Redis)<br>（与Memcache三点不同: 支持多数据类型，支持持久化，单线程+多路IO复用）<br><img src="https://cdn.nlark.com/yuque/0/2023/gif/28066124/1693730031481-b7e58f7f-b4d9-4945-9a5d-ed8c0b68742a.gif#averageHue=%23f8f6f6&id=MKIQH&originHeight=119&originWidth=400&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693795465201-5ba384c5-5020-4e21-8c5b-8f44ace04a47.png#averageHue=%23fefdfa&clientId=uab116c27-7b29-4&from=paste&height=306&id=uef5e8a80&originHeight=383&originWidth=686&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=54293&status=done&style=none&taskId=u816f3de5-a661-48c5-95b1-d89f347cf1f&title=&width=548.8" alt="image.png"></p><ol><li><strong>常用五大数据类型</strong></li></ol><p>哪里去获得redis常见数据类型操作命令<a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p><ol><li><strong>Redis键(key)</strong></li></ol><p>keys *查看当前库所有key    (匹配：keys *1)<br>exists key判断某个key是否存在（返回为1就存在，返回为0就不存在）<br>type key 查看你的key是什么类型（使用set 10 10 设置的值key仍旧是string)<br>del key       删除指定的key数据<br>unlink key   根据value选择非阻塞删除(异步删除，并不是在执行命令的时候就删除了数据）<br>仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。<br>expire key 10   10秒钟：为给定的key设置过期时间（过期的 key 会被自动删除，不再可用。）<br>ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期，返回的正数表示还有多少s过期。</p><p>select命令切换数据库<br>dbsize查看当前数据库的key的数量<br>flushdb清空当前库<br>flushall通杀全部库</p><ol><li><strong>Redis字符串(String)</strong><ol><li><strong>简介</strong></li></ol></li></ol><p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。<br>String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。<br>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</p><div class="code-wrapper"><pre><code class="hljs">  1. **常用命令**</code></pre></div><p>set   <key><value>添加键值对<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730031776-944ce1d5-008e-44e0-8684-91a112c09a7a.png#averageHue=%230d0b0a&id=JGNaN&originHeight=35&originWidth=972&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>*NX：当数据库中key不存在时，可以将key-value添加数据库<br>*XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥<br>*EX：key的超时秒数<br>*PX：key的超时毫秒数，与EX互斥</p><p>get   <key>查询对应键值<br>append  <key><value>将给定的<value> 追加到原值的末尾（返回值是追加后的value字符串的长度）<br>strlen  <key>获得值的长度<br>setnx  <key><value>只有在 key 不存在时    设置 key 的值（如果key存在时，无法覆盖原来的key)</p><p>incr  <key><br>将 key 中储存的数字值增1<br>只能对数字值操作，如果为空，新增值为1<br>decr  <key><br>将 key 中储存的数字值减1<br>只能对数字值操作，如果为空，新增值为-1<br>incr和decr的返回值都是加1减1的结果。<br>incrby &#x2F; decrby  <key>&lt;步长&gt;将 key 中储存的数字值增减。自定义步长。（返回值也是增加或者减少后的值）</p><p>| 原子性<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730032028-b7a90996-a232-4807-a889-8e0c4f807ed2.jpeg#averageHue=%23f4f3f2&id=aBiOH&originHeight=138&originWidth=244&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>所谓<strong>原子</strong>操作是指不会被线程调度机制打断的操作；<br>这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。<br>（1）在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。<br>（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。<br>Redis单命令的原子性主要得益于Redis的单线程。<br><strong>案例：</strong><br>java中的i++是否是原子操作？不是<strong>不是</strong></p><table><thead><tr><th>i&#x3D;0;两个线程分别对i进行++100次,值是多少？不确定（2 -200）** 2~200**</th></tr></thead></table><p>mset  <key1><value1><key2><value2>  …..<br>同时设置一个或多个 key-value对<br>mget  <key1><key2><key3> …..<br>同时获取一个或多个 value<br>msetnx <key1><value1><key2><value2>  …..<br>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。<br><strong>原子性，有一个失败则都失败（添加key和value失败）</strong></p><p>getrange  <key>&lt;起始位置&gt;&lt;结束位置&gt;<br>获得值的范围，类似java中的substring，<strong>前包，后包（其中的value的第一个值的索引是0）</strong><br>setrange  <key>&lt;起始位置&gt;<value><br>用 <value>  覆写<key>所储存的字符串值，从&lt;起始位置&gt;开始(<strong>索引从0开始</strong>)。</p><p><strong>setex  <key>&lt;过期时间&gt;<value></strong><br>设置键值的同时，设置过期时间，单位秒。<br>getset <key><value><br>以新换旧，设置了新值同时获得旧值。（就是该命令返回值是旧key的值，同时在返回的时候覆盖key的value下次访问key的时候，value就是更改后的值了）</p><div class="code-wrapper"><pre><code class="hljs">  1. **数据结构**</code></pre></div><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730032225-8d06e5d3-1805-4a7e-b541-a20f72392afa.png#averageHue=%23fdf8f4&id=zgqOF&originHeight=121&originWidth=666&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p><ol><li><strong>Redis列表(List)</strong><ol><li><strong>简介</strong></li></ol></li></ol><p>单键多值<br>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。<br>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730032474-62d4cc76-7c20-41cb-9f95-fda5515498c1.jpeg#averageHue=%23fefefc&id=ykK7q&originHeight=92&originWidth=614&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **常用命令**</code></pre></div><p>lpush&#x2F;rpush  <key><value1><value2><value3> …. 从左边&#x2F;右边插入一个或多个值。（这里的从左右插入数据，是后面的数据在前面的数据的左边或者右边）<br>lpop&#x2F;rpop  <key>从左边&#x2F;右边吐出一个值。值在键在，值光键亡。</p><p>rpoplpush  <key1><key2>从<key1>列表右边吐出一个值，插到<key2>列表左边。</p><p>lrange <key><start><stop><br>按照索引下标获得元素(从左到右)<br>lrange mylist 0 -1   0左边第一个，-1右边第一个，（0-1表示获取所有）<br>lindex <key><index>按照索引下标获得元素(从左到右)<br>llen <key>获得列表长度 </p><p>linsert <key>  before <value><newvalue>在<value>的后面插入<newvalue>插入值<br>lrem <key><n><value>从左边删除n个value(从左到右)<br>lset<key><index><value>将列表key下标为index的值替换成value</p><div class="code-wrapper"><pre><code class="hljs">  1. **数据结构**</code></pre></div><p>List的数据结构为快速链表quickList。<br>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。<br>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。<br>当数据量比较多的时候才会改成quicklist。<br>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730032728-a57a2672-9ab9-4127-ac84-260498627670.png#averageHue=%23f1f6fa&id=gpMLd&originHeight=78&originWidth=748&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><ol><li><strong>Redis集合(Set)</strong><ol><li><strong>简介</strong></li></ol></li></ol><p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以<strong>自动排重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。<br>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的**复杂度都是O(1)**。<br>一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变</p><div class="code-wrapper"><pre><code class="hljs">  1. **常用命令**</code></pre></div><p>sadd <key><value1><value2> …..<br>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略（返回值是添加成功的个数）<br>smembers <key>取出该集合的所有值。<br>sismember <key><value>判断集合<key>是否为含有该<value>值，有1，没有0<br>scard<key>返回该集合的元素个数。<br>srem <key><value1><value2> …. 删除集合中的某个元素。（返回值是成功删除的个数）<br>spop <key><strong>随机从该集合中吐出一个值。（这里的吐出一个值表示从set集合删除一个数）</strong><br>srandmember <key><n>随机从该集合中取出n个值。不会从集合中删除 。<br>smove <source><destination>value把集合中一个值从一个集合移动到另一个集合<br>sinter <key1><key2>返回两个集合的交集元素。（但是并不会删除元素）<br>sunion <key1><key2>返回两个集合的并集元素。（也是一样不会删除颜色）<br>sdiff <key1><key2>返回两个集合的<strong>差集</strong>元素(key1中的，不包含key2中的)会改变k1中的集合。（k1的集合是查缉的元素）<br>sinter  sunion   sdiff 其实就是集合的运算而已。</p><div class="code-wrapper"><pre><code class="hljs">  1. **数据结构**</code></pre></div><p>Set数据结构是dict字典，字典是用哈希表实现的。</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">ict</span> 字典是指 Python 语言中的一种数据类型，它是一种可变的、无序的、可存储任意类型对象的容器。</code></pre></div><p>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p><div class="code-wrapper"><pre><code class="hljs livecodeserver">这里所说的所有的 <span class="hljs-built_in">value</span> 都指向同一个内部值，是指 Redis 的 <span class="hljs-built_in">set</span> 结构中，每个元素的 <span class="hljs-built_in">value</span> 都是一个特殊的常量，叫做 REDIS_SHARED_INTEGERS ，它是一个包含 <span class="hljs-number">0</span> 到 <span class="hljs-number">9999</span> 的整数数组，用于节省内存空间。<span class="hljs-keyword">https</span>://redis.io/commands/<span class="hljs-built_in">set</span>/<span class="hljs-keyword">https</span>://www.runoob.com/redis/strings-<span class="hljs-built_in">set</span>.html也就是说，Redis 的 <span class="hljs-built_in">set</span> 结构中，每个元素的 key 是实际存储的字符串值，而每个元素的 <span class="hljs-built_in">value</span> 都是 REDIS_SHARED_INTEGERS[<span class="hljs-number">0</span>] ，这个值在内存中只有一份，所有的 <span class="hljs-built_in">set</span> 元素都共享它。<span class="hljs-keyword">https</span>://redis.io/commands/<span class="hljs-built_in">set</span>/<span class="hljs-keyword">https</span>://www.runoob.com/redis/strings-<span class="hljs-built_in">set</span>.html这样做的好处是，Redis 可以用 hash 结构来实现 <span class="hljs-built_in">set</span> 的功能，而不需要额外分配内存空间来存储每个元素的 <span class="hljs-built_in">value</span></code></pre></div><ol><li><strong>Redis哈希(Hash)</strong><ol><li><strong>简介</strong></li></ol></li></ol><p>Redis hash 是一个键值对集合。<br>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。<br>类似Java里面的Map&lt;String,Object&gt;<br>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key&#x2F;value结构来存储<br>主要有以下2种存储方式：</p><p>| <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730032990-9e5593f0-4887-4ab7-ac65-8df3fd71ea0e.jpeg#averageHue=%23fcfdf9&id=K6svc&originHeight=161&originWidth=271&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>每次修改用户的某个属性需要，先反序列化改好后再序列化回去。开销较大。 | <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730033258-17c5c182-f458-4034-92ce-18cd2b9d6faa.jpeg#averageHue=%23ececec&id=VzaaA&originHeight=156&originWidth=277&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>用户ID数据冗余 |<br>| — | — |</p><p>| <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730033537-c99a4769-d614-44a1-81d9-f4bc881c84ce.jpeg#averageHue=%23f8f9f5&id=TC7nl&originHeight=151&originWidth=320&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><table><thead><tr><th><strong>通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题</strong></th></tr></thead></table><div class="code-wrapper"><pre><code class="hljs">  1. **常用命令**</code></pre></div><p>hset <key><field><value>:给<key>集合中的  <field>键赋值<value></p><div class="code-wrapper"><pre><code class="hljs bash"> hset user:10 <span class="hljs-built_in">id</span> 1给<span class="hljs-built_in">hash</span>中添加一个key为user，fild为<span class="hljs-built_in">id</span>，value为1的对象.如果存储的值为中文的话取出会有问题的</code></pre></div><p>hget <key1><field>:从<key1>集合<field>取出 value  eg: hget user:10 name<br>hmset <key1><field1><value1><field2><value2>… ：批量设置hash的值 eg:<br> hmset user:11 id 2 name lishi age 40<br>hexists<key1><field>查看哈希表 key 中，给定域 field 是否存在，存在返回1，不存在返回0。 eg: hexists user:10 id<br>判断user为10中是否存在id的field。<br>hkeys <key>列出该hash集合的所有field<br>hvals <key>列出该hash集合的所有value<br>hincrby <key><field><increment>：为哈希表 key 中的域 field 的值加上增量，返回值是fileld增加后的值。<br>hsetnx <key><field><value>将哈希表 key 中的域 中添加为 value的field ，当且仅当域 field 不存在时才能添加成功 .</p><div class="code-wrapper"><pre><code class="hljs">  1. **数据结构**</code></pre></div><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p><ol><li>**Redis有序集合Zset(sorted set) **<ol><li><strong>简介</strong></li></ol></li></ol><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。<br>不同之处是有序集合的每个成员都关联了一个<strong>评分（score）</strong>,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。<br>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。<br>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p><div class="code-wrapper"><pre><code class="hljs">  1. **常用命令**</code></pre></div><p>zadd  <key><score1><value1><score2><value2>…<br>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。<br>**zrange <key><start><stop>  [WITHSCORES]   **<br>返回有序集 key 中，下标在<start><stop>之间的元素<br>带WITHSCORES，可以让分数一起和值返回到结果集。<br>zrangebyscore key minmax [withscores] [limit offset count]<br>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。<br>zrevrangebyscore key maxmin [withscores] [limit offset count]<br>同上，改为从大到小排列。<br>zincrby <key><increment><value>      为元素的score加上增量<br>zrem  <key><value>删除该集合下，指定值的元素<br>zcount <key><min><max>统计该集合，分数区间内的元素个数<br>zrank <key><value>返回该值在集合中的排名，从0开始。<br>案例：如何利用zset实现一个文章访问量的排行榜？<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730033775-1fc94010-b543-452e-87d5-6894662bf634.jpeg#averageHue=%23060605&id=Oe0tL&originHeight=172&originWidth=451&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693831031687-92c85b21-af19-4cff-b7ed-8558e780aaf7.png#averageHue=%23323a7b&clientId=u937b6ec7-0521-4&from=paste&height=709&id=u3d405017&originHeight=886&originWidth=1549&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=1497218&status=done&style=none&taskId=u997b05f6-e2cc-4eb9-b1cf-74049528801&title=&width=1239.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693831423299-38eeba85-6ba5-49e0-a377-c4291397ccce.png#averageHue=%23383069&clientId=u937b6ec7-0521-4&from=paste&height=464&id=u0219068c&originHeight=580&originWidth=1175&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=700443&status=done&style=none&taskId=u7e67e8ec-1c7d-4a5d-8da9-990740ef1b9&title=&width=940" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs">  1. **数据结构**</code></pre></div><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。<br>zset底层使用了两个数据结构<br>（1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。<br>（2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</p><div class="code-wrapper"><pre><code class="hljs">  1. **跳跃表（跳表）**</code></pre></div><p>1、简介<br>    有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。<br>2、实例<br>    对比有序链表和跳跃表，从链表中查询出51</p><ol><li>有序链表</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730034017-e622ecb5-18ab-4430-aaed-bacc99ffdf92.png#averageHue=%23d5d5d4&id=kTuYG&originHeight=53&originWidth=737&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p><ol><li>跳跃表</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730034386-79f4163c-95b0-4766-9ffa-fe70a3da037a.png#averageHue=%23e2e1e1&id=OvSb1&originHeight=228&originWidth=778&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>从第2层开始，1节点比51节点小，向后比较。<br>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层<br>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下<br>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p><p>从此可以看出跳跃表比有序链表效率要高<br><a href="https://zhuanlan.zhihu.com/p/260075092">跳跃表详解</a></p><ol><li><strong>Redis配置文件介绍</strong></li></ol><p>自定义目录：&#x2F;myredis&#x2F;redis.conf</p><ol><li>**###Units单位### **</li></ol><p>配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit<br>大小写不敏感<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730034656-ba811a1d-4d97-402f-8c91-3c2edfcbc1a0.jpeg#averageHue=%23433e20&id=HtasJ&originHeight=297&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>###INCLUDES包含###</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730035011-c2232a6e-ac70-47b4-9c82-0dde4f477c8d.jpeg#averageHue=%23121106&id=VgJME&originHeight=250&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>类似jsp中的include，多实例的情况可以把公用的配置文件提取出来</p><ol><li><strong>###网络相关配置 ###</strong><ol><li><strong>bind</strong></li></ol></li></ol><p>默认情况bind&#x3D;127.0.0.1只能接受本机的访问请求<br>不写的情况下，无限制接受任何ip地址的访问<br>生产环境肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要将其注释掉<br>如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730035267-6c663b0c-3c59-45f4-90ab-3ce0f7fee46d.jpeg#averageHue=%23121105&id=HCbik&originHeight=324&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>保存配置，停止服务，重启启动查看进程，不再是本机访问了。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730035537-13ecade4-af50-4ba3-bffc-6db989132305.jpeg#averageHue=%230e0b0a&id=bF83z&originHeight=115&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **protected-mode**</code></pre></div><p>将本机访问保护模式设置no<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730035811-d33ade2e-e632-42e6-983a-0cda31729d0b.jpeg#averageHue=%23141408&id=iWb21&originHeight=282&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **Port**</code></pre></div><p>端口号，默认 6379<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730036042-accb83bb-44e4-4823-914f-5ce7a9d5b7d0.jpeg#averageHue=%2319190c&id=AFndT&originHeight=49&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **tcp-backlog**</code></pre></div><p>设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和&#x3D;未完成三次握手队列 + 已经完成三次握手队列。<br>在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。<br>注意Linux内核会将这个值减小到&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn的值（128），所以需要确认增大&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn和&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog（128）两个值来达到想要的效果<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730036258-460d724a-fdc6-44f4-ae8e-bf1cb61d6206.jpeg#averageHue=%23181709&id=mzQHJ&originHeight=123&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **timeout**</code></pre></div><p>一个空闲的客户端维持多少秒会关闭，0表示关闭该功能。即永不关闭。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730036579-56d82572-9069-4270-a220-c1ae349220e7.jpeg#averageHue=%233f3918&id=uJCD5&originHeight=172&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **tcp-keepalive**</code></pre></div><p>对访问客户端的一种心跳检测，每个n秒检测一次。<br>单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730036855-e756b5c6-337a-46c7-9e45-437a9e839122.jpeg#averageHue=%233b3616&id=oa00J&originHeight=238&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>###GENERAL通用###</strong><ol><li><strong>daemonize</strong></li></ol></li></ol><p>是否为后台进程，设置为yes<br>守护进程，后台启动<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730037109-0c0be9df-1f8a-415e-b6cf-a29983811cec.jpeg#averageHue=%231b1b0d&id=vJVEz&originHeight=47&originWidth=607&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **pidfile**</code></pre></div><p>存放pid文件的位置，每个实例会产生一个不同的pid文件<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730037384-bb32e365-75ec-4f41-b5c5-95960eabde47.jpeg#averageHue=%23171709&id=FE36Z&originHeight=151&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **loglevel **</code></pre></div><p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为<strong>notice</strong><br>四个级别根据使用阶段来选择，生产环境选择notice 或者warning<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730037735-a056dc8c-7e81-4f07-898b-7821baff9e59.jpeg#averageHue=%2319190a&id=ABUFP&originHeight=112&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **logfile **</code></pre></div><p>日志文件名称<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730037986-95002380-8b6a-4856-915c-e7439c59cbd2.jpeg#averageHue=%230d0e04&id=ZZEqN&originHeight=66&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **databases 16 **</code></pre></div><p>设定库的数量 默认16，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730038238-3a52dc70-2dc6-46cd-aff3-15695bf3bb31.jpeg#averageHue=%231b1a0e&id=NAV13&originHeight=60&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>###SECURITY安全###</strong><ol><li><strong>设置密码</strong></li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730038485-b721f0bf-38ca-4a40-9eaf-56f55f1e7ad1.jpeg#averageHue=%23161507&id=YZ4fD&originHeight=206&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>访问密码的查看、设置和取消<br>在命令中设置密码，只是临时的。重启redis服务器，密码就还原了。<br>永久设置，需要再配置文件中进行设置。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730038741-02fe699c-751b-4a4e-938f-7d1d4b4daf9e.jpeg#averageHue=%23f8f3f3&id=G7UGU&originHeight=356&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>#### LIMITS限制 ###</strong><ol><li><strong>maxclients</strong></li></ol></li></ol><ul><li>设置redis同时可以与多少个客户端进行连接。</li><li>默认情况下为10000个客户端。</li><li>如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730039000-f90e6ed1-eba5-4226-b9b5-50017f44ffda.jpeg#averageHue=%23111107&id=oWW5t&originHeight=151&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **maxmemory **</code></pre></div><ul><li>建议<strong>必须设置</strong>，否则，将内存占满，造成服务器宕机</li><li>设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。</li><li>如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。</li><li>但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730039266-f1e3c844-46e9-49db-9ba6-c739649153f3.jpeg#averageHue=%23070802&id=jGg2L&originHeight=350&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **maxmemory-policy**</code></pre></div><ul><li>volatile-lru：使用LRU算法移除key，只对设置了过期时间的键；（最近最少使用）</li><li>allkeys-lru：在所有集合key中，使用LRU算法移除key</li><li>volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键</li><li>allkeys-random：在所有集合key中，移除随机的key</li><li>volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key</li><li>noeviction：不进行移除。针对写操作，只是返回错误信息</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730039585-06e1a32b-282f-424b-91e0-51c8e44825d2.jpeg#averageHue=%23181707&id=BQlIS&originHeight=348&originWidth=616&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **maxmemory-samples**</code></pre></div><ul><li>设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个。</li><li>一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730039834-216147c3-2b02-488c-8c31-e35b22d07085.jpeg#averageHue=%23131206&id=tHMcu&originHeight=153&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>Redis的发布和订阅</strong><ol><li><strong>什么是发布和订阅</strong></li></ol></li></ol><p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。<br>Redis 客户端可以订阅任意数量的频道。</p><ol><li><strong>Redis的发布和订阅</strong></li></ol><p>1、客户端可以订阅频道如下图<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730040062-c5a4d2ce-fa30-4c07-ad84-6ce4421511db.png#averageHue=%23e7ebd9&id=jba6O&originHeight=214&originWidth=516&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>2、当给这个频道发布消息后，消息就会发送给订阅的客户端<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730040377-91b7001c-de87-47f5-9971-e1b500f6feaf.png#averageHue=%23eaeae9&id=CEjqK&originHeight=303&originWidth=471&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>发布订阅命令行实现</strong></li><li>打开一个客户端订阅channel1</li></ol><p>SUBSCRIBE channel1<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730040629-5d1e893c-fb8a-4320-8280-7284fb8dedac.png#averageHue=%230c0a09&id=wW3l8&originHeight=154&originWidth=541&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>2、打开另一个客户端，给channel1发布消息hello<br>publish channel1 hello<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730040869-9547417c-700c-4bef-9c9d-c650dab1b686.png#averageHue=%23110f0d&id=bv7O0&originHeight=50&originWidth=495&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>返回的1是订阅者数量<br>3、打开第一个客户端可以看到发送的消息<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730041137-08dbd908-930c-46bc-892d-c3975a44515b.png#averageHue=%230a0807&id=Opd93&originHeight=227&originWidth=552&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>注：发布的消息没有持久化，如果在订阅的客户端收不到hello，只能收到订阅后发布的消息</p><ol><li><strong>Redis新数据类型</strong><ol><li><strong>Bitmaps</strong><ol><li><strong>简介</strong></li></ol></li></ol></li></ol><p>现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730041380-1e9c0ca4-5e84-47b2-9984-4647f3a6b1a1.png#averageHue=%23e9e9e9&id=uehK8&originHeight=115&originWidth=628&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>合理地使用操作位能够有效地提高内存使用率和开发效率。<br>    Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p><ol><li>Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</li><li>Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730041676-b07a50a5-97e1-453e-9c45-420743a1144d.png#averageHue=%23cdcccc&id=DojKK&originHeight=81&originWidth=822&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **命令**</code></pre></div><p>1、setbit<br>（1）格式<br>setbit<key><offset><value>设置Bitmaps中某个偏移量的值（0或1）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730041887-6e6d1411-b201-4d9c-8da2-5e2e7512b457.png#averageHue=%23110f0d&id=za5A6&originHeight=37&originWidth=519&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>*offset:偏移量从0开始<br>（2）实例<br>每个独立用户是否访问过网站存放在Bitmaps中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的id。<br>设置键的第offset个位的值（从0算起） ， 假设现在有20个用户，userid&#x3D;1， 6， 11， 15， 19的用户对网站进行了访问， 那么当前Bitmaps初始化结果如图<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730042156-2c62c32d-62a3-45f7-854d-3bf1cf1e489f.png#averageHue=%23ececec&id=KepT0&originHeight=135&originWidth=646&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>unique:users:20201106代表2020-11-06这天的独立访问用户的Bitmaps<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730042383-9e87289b-c3fe-4884-bc89-37897d0108fe.png#averageHue=%23100e0c&id=k5Jkg&originHeight=251&originWidth=652&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>注：<br>很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。<br>在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。<br>2、getbit<br>（1）格式<br>getbit<key><offset>获取Bitmaps中某个偏移量的值<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730042647-7b0094f9-0323-4d9a-a8be-ca2552194b79.png#averageHue=%23100e0c&id=ogPG6&originHeight=35&originWidth=444&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>获取键的第offset位的值（从0开始算）<br>（2）实例<br>获取id&#x3D;8的用户是否在2020-11-06这天访问过， 返回0说明没有访问过：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730042882-62c46e10-5689-4e65-856e-a6b2ac7468be.png#averageHue=%23100e0c&id=lo73f&originHeight=154&originWidth=633&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>注：因为100根本不存在，所以也是返回0<br>3、bitcount<br>统计<strong>字符串</strong>被设置为1的bit数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。<br>（1）格式<br>bitcount<key>[start end] 统计字符串从start字节到end字节比特值为1的数量<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730043084-62a931d2-c5e0-4b31-b14a-cfe895317f1e.png#averageHue=%2315120f&id=nw0n4&originHeight=29&originWidth=526&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>（2）实例<br>计算2022-11-06这天的独立访问用户数量<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730043338-e4615ff4-d54b-4821-b778-1a9bd1824324.png#averageHue=%230c0a07&id=rcLg5&originHeight=62&originWidth=657&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>start和end代表起始和结束字节数， 下面操作计算用户id在第1个字节到第3个字节之间的独立访问用户数， 对应的用户id是11， 15， 19。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730043539-b573ced4-e2ab-463b-831e-c17c49ba60a6.png#averageHue=%23100d0c&id=VstjJ&originHeight=51&originWidth=662&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>举例： K1 【01000001 01000000  00000000 00100001】，对应【0，1，2，3】<br>bitcount K1 1 2  ： 统计下标1、2字节组中bit&#x3D;1的个数，即01000000  00000000<br>–》bitcount K1 1 2 　　–》1<br>bitcount K1 1 3  ： 统计下标1、2字节组中bit&#x3D;1的个数，即01000000  00000000 00100001<br>–》bitcount K1 1 3　　–》3<br>bitcount K1 0 -2  ： 统计下标0到下标倒数第2，字节组中bit&#x3D;1的个数，即01000001  01000000   00000000<br>–》bitcount K1 0 -2　　–》3<br> 注意：redis的setbit设置或清除的是bit位置，而bitcount计算的是byte位置。<br>4、bitop<br>(1)格式<br>bitop  and(or&#x2F;not&#x2F;xor) <destkey> [key…]<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730043743-ba80e6ed-b5da-4394-9bcf-19467d02a666.png#averageHue=%2313100e&id=j9TK6&originHeight=29&originWidth=691&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。<br>(2)实例<br>2020-11-04 日访问网站的userid&#x3D;1,2,5,9。<br>setbit unique:users:20201104 1 1<br>setbit unique:users:20201104 2 1<br>setbit unique:users:20201104 5 1<br>setbit unique:users:20201104 9 1<br>2020-11-03 日访问网站的userid&#x3D;0,1,4,9。<br>setbit unique:users:20201103 0 1<br>setbit unique:users:20201103 1 1<br>setbit unique:users:20201103 4 1<br>setbit unique:users:20201103 9 1<br>计算出两天都访问过网站的用户数量<br>bitop and unique:users:and:20201104_03<br> unique:users:20201103unique:users:20201104<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730043980-be07c887-3214-4b9d-87c3-d4df59d7233c.png#averageHue=%230a0907&id=seAnr&originHeight=129&originWidth=1181&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>bitop and操作返回值是位串中为1的个数。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730044227-82e0367b-be06-4164-88df-f1f6713b6fc5.png#averageHue=%23f0efef&id=fiQAN&originHeight=394&originWidth=617&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>计算出任意一天都访问过网站的用户数量（例如月活跃就是类似这种） ， 可以使用or求并集<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730044526-f201de03-2143-4c20-9153-9d6aa4f54b63.png#averageHue=%230a0807&id=pl4Ku&originHeight=126&originWidth=1183&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **Bitmaps与set对比**</code></pre></div><p>假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表</p><table><thead><tr><th>set和Bitmaps存储一天活跃用户对比</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据</td><td></td><td></td><td></td></tr><tr><td>类型</td><td>每个用户id占用空间</td><td>需要存储的用户量</td><td>全部内存量</td></tr><tr><td>集合</td><td></td><td></td><td></td></tr><tr><td>类型</td><td>64位</td><td>50000000</td><td>64位*50000000 &#x3D; 400MB</td></tr><tr><td>Bitmaps</td><td>1位</td><td>100000000</td><td>1位*100000000 &#x3D; 12.5MB</td></tr></tbody></table><p>很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的</p><table><thead><tr><th>set和Bitmaps存储独立用户空间对比</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据类型</td><td>一天</td><td>一个月</td><td>一年</td></tr><tr><td>集合类型</td><td>400MB</td><td>12GB</td><td>144GB</td></tr><tr><td>Bitmaps</td><td>12.5MB</td><td>375MB</td><td>4.5GB</td></tr></tbody></table><p>但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0。</p><table><thead><tr><th>set和Bitmaps存储一天活跃用户对比（独立用户比较少）</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据类型</td><td>每个userid占用空间</td><td>需要存储的用户量</td><td>全部内存量</td></tr><tr><td>集合类型</td><td>64位</td><td>100000</td><td>64位*100000 &#x3D; 800KB</td></tr><tr><td>Bitmaps</td><td>1位</td><td>100000000</td><td>1位*100000000 &#x3D; 12.5MB</td></tr></tbody></table><ol><li><strong>HyperLogLog</strong><ol><li><strong>简介</strong></li></ol></li></ol><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。<br>但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。<br>解决基数问题有很多种方案：<br>（1）数据存储在MySQL表中，使用distinct count计算不重复个数<br>（2）使用Redis提供的hash、set、bitmaps等数据结构来处理<br>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。<br>能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog<br>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。<br>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。<br>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。<br>什么是基数?<br>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p><div class="code-wrapper"><pre><code class="hljs">  1. **命令**</code></pre></div><p>1、pfadd<br>（1）格式<br>pfadd <key>&lt; element&gt; [element …]   添加指定元素到 HyperLogLog 中<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730044807-6a71eed0-0b1f-44a4-839b-e33e56882e07.png#averageHue=%23100d0c&id=Yw5RO&originHeight=31&originWidth=620&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>（2）实例<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730045083-57372cbe-5fc9-467d-b162-15c621ebaf03.png#averageHue=%23100d0c&id=RDA2W&originHeight=177&originWidth=447&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>    将所有元素添加到指定HyperLogLog数据结构中。如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0。<br>2、pfcount<br>（1）格式<br>pfcount<key> [key …] 计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730045284-0ea0a0a4-29f5-4d7a-a2d1-e1d0ff413a83.png#averageHue=%23100e0c&id=ymRaK&originHeight=32&originWidth=482&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>（2）实例<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730045569-ff64944a-93ae-4f3e-b189-25091586aa3a.png#averageHue=%230f0d0b&id=tIUfy&originHeight=375&originWidth=473&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>3、pfmerge<br>（1）格式<br>pfmerge<destkey><sourcekey> [sourcekey …]  将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730045959-ae3fb38f-f426-41e2-9abd-33317a976419.png#averageHue=%23151210&id=bQZBn&originHeight=27&originWidth=744&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>（2）实例<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730046204-9eef0e6b-7a15-410d-83bd-65d4a7d7e358.png#averageHue=%230d0b09&id=KDaCu&originHeight=182&originWidth=495&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>Geospatial</strong><ol><li><strong>简介</strong></li></ol></li></ol><p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p><div class="code-wrapper"><pre><code class="hljs">  1. **命令**</code></pre></div><p>1、geoadd<br>（1）格式<br>geoadd<key>&lt; longitude&gt;<latitude><member> [longitude latitude member…]   添加地理位置（经度，纬度，名称）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730046502-25494722-7483-4493-8757-95fb5196cbc5.png#averageHue=%230b0806&id=aAHRQ&originHeight=30&originWidth=754&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>（2）实例<br>geoadd china:city 121.47 31.23 shanghai<br>geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730046771-cd8f0b9f-c7ec-4cf4-b994-023b74e0753d.png#averageHue=%23070503&id=mzQwF&originHeight=96&originWidth=898&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。<br>有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。<br>当坐标位置超出指定范围时，该命令将会返回一个错误。<br>已经添加的数据，是无法再次往里面添加的。<br>2、geopos<br>（1）格式<br>geopos  <key><member> [member…]  获得指定地区的坐标值<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730047046-9212fba5-b8c3-4ec3-8dd7-ff0823d9c79c.png#averageHue=%230d0a07&id=ujxFG&originHeight=27&originWidth=464&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>（2）实例<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730047304-a8479a43-fdca-4b12-92a1-683084423427.png#averageHue=%23120e0a&id=N5gjj&originHeight=61&originWidth=423&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>3、geodist<br>（1）格式<br>geodist<key><member1><member2>  [m|km|ft|mi ]  获取两个位置之间的直线距离<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730047526-463fa02f-03df-488e-93ed-16c6ff5a7bdb.png#averageHue=%230c0906&id=LaFSb&originHeight=28&originWidth=564&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>（2）实例<br>获取两个位置之间的直线距离<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730047763-e55e7def-edf0-4318-8b5d-4bfb091fa53d.png#averageHue=%23090704&id=OwVHS&originHeight=50&originWidth=557&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>单位：<br>m 表示单位为米[默认值]。<br>km 表示单位为千米。<br>mi 表示单位为英里。<br>ft 表示单位为英尺。<br>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位<br>4、georadius<br>（1）格式<br>georadius<key>&lt; longitude&gt;<latitude>radius  m|km|ft|mi   以给定的经纬度为中心，找出某一半径内的元素<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730048028-db65bfe1-ddcd-4996-a673-88e25f0bfb7d.png#averageHue=%230d0a07&id=giAcC&originHeight=26&originWidth=671&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>经度 纬度 距离 单位<br>（2）实例<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730048304-448a2baf-96e7-44ec-a154-990d2526f401.png#averageHue=%23090604&id=iFc6n&originHeight=60&originWidth=519&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>Redis_Jedis_测试</strong><ol><li><strong>Jedis所需要的jar包</strong><br>| &lt;**dependency**&gt;<br>&lt;**groupId**&gt;redis.clients&lt;&#x2F;**groupId**&gt;<br>&lt;**artifactId**&gt;jedis&lt;&#x2F;**artifactId**&gt;<br>&lt;**version**&gt;3.2.0&lt;&#x2F;**version**&gt;<table><thead><tr><th>&lt;&#x2F;**dependency**&gt;</th></tr></thead></table></li></ol></li></ol><p>什么是Jedis?<br>Jedis是redis的java客户端，集成了Redis的命令操作，提供连接池操作。</p><ol><li><strong>连接Redis注意事项</strong></li></ol><p>禁用Linux的防火墙：Linux(CentOS7)里执行命令<br>**systemctl stop&#x2F;disable firewalld.service   **<br>redis.conf中注释掉bind 127.0.0.1 ,然后 protected-mode no<br>1.查看redis进程的命令： ps -ef | grep redis。<br>2.关于prptected-mode no的解释</p><div class="code-wrapper"><pre><code class="hljs awk">protected-mode no 是一个用于关闭 Redis 的保护模式的配置选项。保护模式是 Redis <span class="hljs-number">3.2</span> 版本后引入的一种安全机制，它的目的是防止 Redis 实例被外部网络访问和利用。https:<span class="hljs-regexp">//</span>www.jianshu.com<span class="hljs-regexp">/p/</span>ddd19ec819dchttps:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/zzhongcy/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">123653851</span>当保护模式开启时，如果 Redis 实例没有指定绑定地址（bind）或者没有设置访问密码（requirepass），那么它只接受来自本地回环地址（<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span> 或者 ::<span class="hljs-number">1</span>）和 Unix 域套接字的连接请求。这样可以避免 Redis 实例被暴露在公网上，造成数据泄露或者被恶意攻击。https:<span class="hljs-regexp">//</span>www.jianshu.com<span class="hljs-regexp">/p/</span>ddd19ec819dchttps:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/zzhongcy/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">123653851</span>如果你想让 Redis 实例能够接受来自外部网络的连接请求，你可以采用以下几种方法之一：•  关闭保护模式，将 protected-mode no 设置为 no ，然后重启服务器。但是这样做需要确保 Redis 实例不会被公网访问，否则会有安全风险。https:<span class="hljs-regexp">//</span>www.jianshu.com<span class="hljs-regexp">/p/</span>ddd19ec819dchttps:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/zzhongcy/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">123653851</span>•  开启保护模式，但是指定绑定地址（bind），让 Redis 实例只监听特定的网络接口。例如，如果你想让 Redis 实例只监听 <span class="hljs-number">192.168</span>.<span class="hljs-number">1.100</span> 这个地址，你可以在配置文件中设置 bind <span class="hljs-number">192.168</span>.<span class="hljs-number">1.100</span> ，然后重启服务器。https:<span class="hljs-regexp">//</span>www.jianshu.com<span class="hljs-regexp">/p/</span>ddd19ec819dchttps:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/zzhongcy/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">123653851</span>•  开启保护模式，但是设置访问密码（requirepass），让 Redis 实例要求客户端提供密码才能连接。例如，如果你想让 Redis 实例的密码为 mypass ，你可以在配置文件中设置 requirepass mypass ，然后重启服务器。https:<span class="hljs-regexp">//</span>www.jianshu.com<span class="hljs-regexp">/p/</span>ddd19ec819dchttps:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/zzhongcy/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">123653851</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs powershell">命令<span class="hljs-built_in">ps</span> <span class="hljs-literal">-ef</span>中，选项<span class="hljs-literal">-ef</span>是两个单独的选项<span class="hljs-literal">-e</span>和<span class="hljs-operator">-f</span>的组合。<span class="hljs-literal">-e</span>选项：它表示显示所有进程，而不仅仅是当前用户的进程。它会列出所有正在运行的进程，包括系统进程和其他用户的进程。<span class="hljs-operator">-f</span>选项：它表示以全格式显示进程信息。它会显示更详细的信息，如进程的PID（进程ID）、PPID（父进程ID）、CPU使用情况、内存使用情况等。</code></pre></div><ol><li><p><strong>Jedis常用操作</strong></p><ol><li><strong>创建动态的工程</strong></li><li><strong>创建测试程序</strong><br>| package com.atguigu.jedis;<br>import redis.clients.jedis.Jedis;<br>public class Demo01 {<br>public static void main(String[] args) {<br>Jedis jedis &#x3D; new Jedis(“192.168.137.3”,6379);&#x2F;&#x2F;注意这里连接的是redis-server<br>而不是redis-sentinel<br>String pong &#x3D; jedis.ping();<br>System.out.println(“连接成功：”+pong);<br>jedis.close();<br>}<table><thead><tr><th>}</th></tr></thead></table></li></ol></li><li><p><strong>测试相关数据类型</strong></p><ol><li><p><strong>Jedis-API:    Key</strong><br>| jedis.<strong>set</strong>(“k1”, “v1”);<br>jedis.set(“k2”, “v2”);<br>jedis.set(“k3”, “v3”);<br>Set<String> keys &#x3D; jedis.<strong>keys</strong>(“*”);<br>System.out.println(keys.size());<br>for (String key : keys) {<br>System.out.println(key);<br>}<br>System.out.println(jedis.<strong>exists</strong>(“k1”));<br>System.out.println(jedis.<strong>ttl</strong>(“k1”));                </p><table><thead><tr><th>System.out.println(jedis.<strong>get</strong>(“k1”));</th></tr></thead></table></li><li><p><strong>Jedis-API:    String</strong><br>| jedis.<strong>mset</strong>(“str1”,”v1”,”str2”,”v2”,”str3”,”v3”);</p><table><thead><tr><th>System.<em>out</em>.println(jedis.<strong>mget</strong>(“str1”,”str2”,”str3”));</th></tr></thead></table></li><li><p><strong>Jedis-API:    List</strong><br>| List<String> list &#x3D; jedis.<strong>lrange</strong>(“mylist”,0,-1);<br>for (String element : list) {<br>System.out.println(element);</p><table><thead><tr><th>}</th></tr></thead></table></li><li><p><strong>Jedis-API:    set</strong><br>| jedis.sadd(“orders”, “order01”);<br>jedis.sadd(“orders”, “order02”);<br>jedis.sadd(“orders”, “order03”);<br>jedis.sadd(“orders”, “order04”);<br>Set<String> smembers &#x3D; jedis.<strong>smembers</strong>(“orders”);<br>for (String order : smembers) {<br>System.out.println(order);<br>}</p><table><thead><tr><th>jedis.<strong>srem</strong>(“orders”, “order02”);</th></tr></thead></table></li><li><p><strong>Jedis-API:    hash</strong><br>| jedis.<strong>hset</strong>(“hash1”,”userName”,”lisi”);<br>System.out.println(jedis.<strong>hget</strong>(“hash1”,”userName”));<br>Map&lt;String,String&gt; map &#x3D; new HashMap&lt;String,String&gt;();<br>map.put(“telphone”,”13810169999”);<br>map.put(“address”,”atguigu”);<br>map.put(“email”,”<a href="mailto:&#x61;&#x62;&#99;&#x40;&#x31;&#x36;&#51;&#46;&#x63;&#x6f;&#109;">&#x61;&#x62;&#99;&#x40;&#x31;&#x36;&#51;&#46;&#x63;&#x6f;&#109;</a>“);<br>jedis.<strong>hmset</strong>(“hash2”,map);<br>List<String> result &#x3D; jedis.<strong>hmget</strong>(“hash2”, “telphone”,”email”);<br>for (String element : result) {<br>System.out.println(element);</p><table><thead><tr><th>}</th></tr></thead></table></li><li><p><strong>Jedis-API:    zset</strong><br>| jedis.<strong>zadd</strong>(“zset01”, 100d, “z3”);<br>jedis.zadd(“zset01”, 90d, “l4”);<br>jedis.zadd(“zset01”, 80d, “w5”);<br>jedis.zadd(“zset01”, 70d, “z6”);</p></li></ol></li></ol><p>Set<String> zrange &#x3D; jedis.<strong>zrange</strong>(“zset01”, 0, -1);<br>for (String e : zrange) {<br>System.out.println(e);</p><table><thead><tr><th>}</th></tr></thead></table><ol><li><strong>Redis_Jedis_实例</strong><ol><li><strong>完成一个手机验证码功能</strong></li></ol></li></ol><p>要求：<br>1、输入手机号，点击发送后随机生成6位数字码，2分钟有效<br>2、输入验证码，点击验证，返回成功或失败<br>3、每个手机号每天只能输入3次<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730048567-6aa26936-21dc-4110-8bba-d0bea1ab89f0.jpeg#averageHue=%23eae8e0&id=sLE5A&originHeight=165&originWidth=516&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>Redis与Spring Boot整合</strong></li></ol><p>Spring Boot整合Redis非常简单，只需要按如下步骤整合即可</p><ol><li><p><strong>整合步骤</strong></p></li><li><p>在pom.xml文件中引入redis相关依赖<br>| <em><!-- redis --></em>&lt;**dependency**&gt;<br>&lt;**groupId**&gt;org.springframework.boot&lt;&#x2F;**groupId**&gt;<br>&lt;**artifactId**&gt;spring-boot-starter-data-redis&lt;&#x2F;**artifactId**&gt;<br>&lt;&#x2F;**dependency**&gt;<br><em><!-- spring2.X集成redis所需common-pool2--></em>&lt;**dependency**&gt;<br>&lt;**groupId**&gt;org.apache.commons&lt;&#x2F;**groupId**&gt;<br>&lt;**artifactId**&gt;commons-pool2&lt;&#x2F;**artifactId**&gt;<br>&lt;**version**&gt;2.6.0&lt;&#x2F;**version**&gt;</p><table><thead><tr><th>&lt;&#x2F;**dependency**&gt;</th></tr></thead></table></li><li><p>application.properties配置redis配置<br>| #Redis服务器地址<br>spring.data.redis.host&#x3D;8.130.50.249</p></li></ol><p>#Redis服务器连接端口<br>spring.data.redis.port&#x3D;**6379<br>**#Redis数据库索引（默认为0）<br>spring.data.redis.database&#x3D; **0<br>**#连接超时时间（毫秒）<br>spring.data.redis.timeout&#x3D;1800000<br>#连接池最大连接数（使用负值表示没有限制）<br>spring.data.redis.jedis.pool.max-active&#x3D;**20<br>**#最大阻塞等待时间(负数表示没限制)<br>spring.data.redis.jedis.pool.max-wait&#x3D;-1<br>#连接池中的最大空闲连接<br>spring.data.redis.jedis.pool.max-idle&#x3D;**5<br>**#连接池中的最小空闲连接</p><table><thead><tr><th>spring.data.redis.jedis.pool.min-idle&#x3D;<strong>0</strong></th></tr></thead></table><ol><li><p>添加redis配置类<br>| @EnableCaching<br>@Configuration<br>**public class **RedisConfig **extends **CachingConfigurerSupport {</p><p> @Bean<br> **public **RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) {<br> RedisTemplate&lt;String, Object&gt; template &#x3D; **new **RedisTemplate&lt;&gt;();<br> RedisSerializer<String> redisSerializer &#x3D; <strong>new <strong>StringRedisSerializer();<br> Jackson2JsonRedisSerializer jackson2JsonRedisSerializer &#x3D; <strong>new <strong>Jackson2JsonRedisSerializer(Object.<strong>class</strong>);<br> ObjectMapper om &#x3D; <strong>new <strong>ObjectMapper();<br> om.setVisibility(PropertyAccessor.</strong><em>ALL</em></strong>, JsonAutoDetect.Visibility.</strong><em>ANY</em></strong>);<br> om.enableDefaultTyping(ObjectMapper.DefaultTyping.</strong><em>NON_FINAL</em></strong>);<br> jackson2JsonRedisSerializer.setObjectMapper(om);<br> template.setConnectionFactory(factory);_&#x2F;&#x2F;key序列化方式<br> <em>template.setKeySerializer(redisSerializer);</em>&#x2F;&#x2F;value序列化<br> <em>template.setValueSerializer(jackson2JsonRedisSerializer);</em>&#x2F;&#x2F;value hashmap序列化<br> _template.setHashValueSerializer(jackson2JsonRedisSerializer);<br> **return **template;<br> }</p><p> @Bean<br> **public **CacheManager cacheManager(RedisConnectionFactory factory) {<br> RedisSerializer<String> redisSerializer &#x3D; <strong>new <strong>StringRedisSerializer();<br> Jackson2JsonRedisSerializer jackson2JsonRedisSerializer &#x3D; <strong>new <strong>Jackson2JsonRedisSerializer(Object.<strong>class</strong>);_&#x2F;&#x2F;解决查询缓存转换异常的问题<br> _ObjectMapper om &#x3D; <strong>new <strong>ObjectMapper();<br> om.setVisibility(PropertyAccessor.</strong><em>ALL</em></strong>, JsonAutoDetect.Visibility.</strong><em>ANY</em></strong>);<br> om.enableDefaultTyping(ObjectMapper.DefaultTyping.</strong><em>NON_FINAL</em></strong>);<br> jackson2JsonRedisSerializer.setObjectMapper(om);_&#x2F;&#x2F; 配置序列化（解决乱码的问题）,过期时间600秒<br> _RedisCacheConfiguration config &#x3D; RedisCacheConfiguration.<em>defaultCacheConfig</em>()<br>         .entryTtl(Duration.<em>ofSeconds</em>(600))<br>         .serializeKeysWith(RedisSerializationContext.SerializationPair.<em>fromSerializer</em>(redisSerializer))<br>         .serializeValuesWith(RedisSerializationContext.SerializationPair.<em>fromSerializer</em>(jackson2JsonRedisSerializer))<br>         .disableCachingNullValues();<br> RedisCacheManager cacheManager &#x3D; RedisCacheManager.<em>builder</em>(factory)<br>         .cacheDefaults(config)<br>         .build();<br> **return **cacheManager;<br> }</p></li></ol><table><thead><tr><th>}</th></tr></thead><tbody><tr><td></td></tr><tr><td></td></tr></tbody></table><p>4、测试一下<br>RedisTestController中添加测试方法</p><p>| @RestController<br>@RequestMapping(<strong>“&#x2F;redisTest”</strong>)<br><strong>public class <strong>RedisTestController {<br>    @Autowired<br>    <strong>private <strong>RedisTemplate <strong>redisTemplate</strong>;<br>    @GetMapping<br>    <strong>public <strong>String testRedis() {<br>        _&#x2F;&#x2F;设置值到redis<br>        _<strong>redisTemplate</strong>.opsForValue().set(</strong>“name”</strong>,</strong>“lucy”</strong>);<br>        _&#x2F;&#x2F;从redis获取值<br>        _String name &#x3D; (String)<strong>redisTemplate</strong>.opsForValue().get(</strong>“name”</strong>);<br>        **return **name;<br>    }</p><table><thead><tr><th>}</th></tr></thead></table><ol><li><strong>Redis_事务_锁机制_秒杀</strong><ol><li><strong>Redis的事务定义</strong></li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730048825-54893261-bf10-4de3-a66c-f7b8b69c7a63.jpeg#averageHue=%23e0dfdb&id=jmvjN&originHeight=66&originWidth=625&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>Redis事务的主要作用就是串联多个命令防止别的命令插队。</p><ol><li><strong>Multi、Exec、discard</strong></li></ol><p>从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。<br>组队的过程中可以通过discard来放弃组队。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730049147-dc3307d8-1793-4200-9f46-8d71c8175710.png#averageHue=%23fdfbfb&id=ITVQ2&originHeight=309&originWidth=693&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>案例：</strong></p><p>| <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730049420-5fee2564-1c4f-4b27-9f0d-5081fa588321.jpeg#averageHue=%23615c55&id=u9oHB&originHeight=117&originWidth=159&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><table><thead><tr><th>组队成功，提交成功</th></tr></thead><tbody><tr><td><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730049688-69b9a09e-c48f-48d0-95d8-2f3368017f39.jpeg#averageHue=%23060605&id=PqyhT&originHeight=122&originWidth=389&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></td></tr><tr><td>组队阶段报错，提交失败</td></tr><tr><td><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730049917-4a5ea3be-4561-417e-8316-cd2266f3a8b2.jpeg#averageHue=%23080707&id=BLVOz&originHeight=152&originWidth=330&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></td></tr><tr><td>组队成功，提交有成功有失败情况</td></tr></tbody></table><ol><li><strong>事务的错误处理</strong></li></ol><p>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730050175-662baba3-e42b-4d7e-97a5-fbaf395b7141.jpeg#averageHue=%23f6f5f5&id=tNetC&originHeight=270&originWidth=617&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730050447-d9680bf2-fda6-4551-b0eb-ba707f216ac3.jpeg#averageHue=%23ebebe3&id=JAArc&originHeight=269&originWidth=614&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>为什么要做成事务</strong></li></ol><p>想想一个场景：有很多人有你的账户,同时去参加双十一抢购</p><ol><li><strong>事务冲突的问题</strong><ol><li><strong>例子</strong></li></ol></li></ol><p>一个请求想给金额减8000<br>一个请求想给金额减5000<br>一个请求想给金额减1000<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730050721-2562fa91-e6be-4801-bec9-b54b906cddf4.jpeg#averageHue=%23fac47d&id=oYHnE&originHeight=215&originWidth=616&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **悲观锁**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730050986-995b2faa-d872-406f-9ba7-cdca0f1a0d29.jpeg#averageHue=%23f1c084&id=w0mhj&originHeight=169&originWidth=613&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>悲观锁(Pessimistic Lock)</strong>, 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。<strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。</p><div class="code-wrapper"><pre><code class="hljs">  1. **乐观锁**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730051248-472694bb-fce1-419f-b8b8-ee0b46349fac.jpeg#averageHue=%23f9e5d3&id=pMR6f&originHeight=195&originWidth=613&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>乐观锁(Optimistic Lock), <strong>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。</strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis就是利用这种check-and-set机制实现事务的。</p><div class="code-wrapper"><pre><code class="hljs">  1. **WATCH key [key ...]**</code></pre></div><p>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务<strong>执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730051584-c6030859-5595-4dd5-af27-cd9f93ef166e.jpeg#averageHue=%23f5edec&id=jXO1L&originHeight=180&originWidth=314&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **unwatch**</code></pre></div><p>取消 WATCH 命令对所有 key 的监视。<br>如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了。<br><a href="http://doc.redisfans.com/transaction/exec.html">http://doc.redisfans.com/transaction/exec.html</a></p><ol><li><strong>Redis事务三特性</strong></li></ol><ul><li>单独的隔离操作 <ul><li>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li></ul></li><li>没有隔离级别的概念 <ul><li>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</li></ul></li><li>不保证原子性 <ul><li>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li></ul></li></ul><ol><li><strong>Redis_事务_秒杀案例</strong><ol><li><strong>解决计数器和人员记录的事务操作</strong></li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730051888-55bb4789-36fb-4865-ac03-920446cb6b8d.jpeg#averageHue=%23fdfefd&id=cx1Bh&originHeight=189&originWidth=614&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>Redis事务–秒杀并发模拟</strong></li></ol><p>使用工具ab模拟测试<br>CentOS6 默认安装<br>CentOS7需要手动安装</p><div class="code-wrapper"><pre><code class="hljs">  1. **联网：yum install httpd-tools**  2. **无网络**</code></pre></div><p>（1） 进入cd  &#x2F;run&#x2F;media&#x2F;root&#x2F;CentOS 7 x86_64&#x2F;Packages（路径跟centos6不同）<br>（2） 顺序安装<br>apr-1.4.8-3.el7.x86_64.rpm<br>apr-util-1.5.2-6.el7.x86_64.rpm<br>httpd-tools-2.4.6-67.el7.centos.x86_64.rpm  </p><div class="code-wrapper"><pre><code class="hljs">  1. **测试及结果**     1. **通过ab测试**</code></pre></div><p>vim postfile 模拟表单提交参数,以&amp;符号结尾;存放当前目录。<br>内容：prodid&#x3D;0101&amp;<br>ab -n 2000 -c 200 -k -p ~&#x2F;postfile -T application&#x2F;x-www-form-urlencoded <a href="http://192.168.2.115:8081/Seckill/doseckill">http://192.168.2.115:8081/Seckill/doseckill</a></p><div class="code-wrapper"><pre><code class="hljs">     1. **超卖**</code></pre></div><p>| <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730052159-72c632b8-c258-476c-ab16-ba02e679e609.jpeg#averageHue=%23efefe9&id=e0BcE&originHeight=320&originWidth=117&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="> | <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730052444-7f1821af-9326-4c5b-8ff9-3a55c795e243.jpeg#averageHue=%230e0908&id=RzNKd&originHeight=138&originWidth=360&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>  |<br>| — | — |</p><ol><li><strong>超卖问题</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730052742-4e563233-bb89-48ce-9b0d-a6d4836dd0f9.jpeg#averageHue=%23f8e5db&id=VNTTo&originHeight=348&originWidth=547&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>利用乐观锁淘汰用户，解决超卖问题。</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730053044-acd5fa54-be05-4269-b369-47acf2f2a3e9.jpeg#averageHue=%23f6ddd3&id=wpIeY&originHeight=289&originWidth=613&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>| &#x2F;&#x2F;增加乐观锁<br>jedis.watch(qtkey);</p><p>&#x2F;&#x2F;3.判断库存<br>String qtkeystr &#x3D; jedis.get(qtkey);<br>if(qtkeystr&#x3D;&#x3D;null &#124;&#124; “”.equals(qtkeystr.trim())) {<br>System.out.println(“未初始化库存”);<br>jedis.close();<br>return false ;<br>}</p><p>int qt &#x3D; Integer.parseInt(qtkeystr);<br>if(qt&lt;&#x3D;0) {<br>System.err.println(“已经秒光”);<br>jedis.close();<br>return false;<br>}</p><p>&#x2F;&#x2F;增加事务<br>Transaction <strong>multi</strong> &#x3D; jedis.multi();</p><p>&#x2F;&#x2F;4.减少库存<br>&#x2F;&#x2F;jedis.decr(qtkey);<br><strong>multi</strong>.decr(qtkey);</p><p>&#x2F;&#x2F;5.加人<br>&#x2F;&#x2F;jedis.sadd(usrkey, uid);<br><strong>multi</strong>.sadd(usrkey, uid);</p><p>&#x2F;&#x2F;执行事务<br>List<Object> list &#x3D; <strong>multi</strong>.exec();</p><p>&#x2F;&#x2F;判断事务提交是否失败<br>if(list&#x3D;&#x3D;null &#124;&#124; list.size()&#x3D;&#x3D;0) {<br>System.out.println(“秒杀失败”);<br>jedis.close();<br>return false;<br>}<br>System.err.print<strong>ln(“秒杀成</strong>功”);<br>jedis.close(); | <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730053362-ccd953c7-236d-448b-8ad2-5a5b050b2997.jpeg#averageHue=%23080606&id=Rhbmv&originHeight=311&originWidth=331&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730053594-7a639b97-8a83-49f7-9005-c3a535b71ec4.jpeg#averageHue=%23e6e4dd&id=jeZiO&originHeight=319&originWidth=127&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="> |<br>| — | — |</p><ol><li><strong>继续增加并发测试</strong><ol><li><strong>连接有限制</strong></li></ol></li></ol><p>ab -n 2000 -c 200 -k -p postfile -T ‘application&#x2F;x-www-form-urlencoded’ <a href="http://192.168.140.1:8080/seckill/doseckill">http://192.168.140.1:8080/seckill/doseckill</a><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730053896-5957fed5-aab7-4802-bbbb-f886c8d8c83e.jpeg#averageHue=%230f0c0c&id=oPqVJ&originHeight=83&originWidth=626&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>增加-r参数，-r   Don’t exit on socket receive errors.<br>**ab -n 2000 -c 100 -r -p postfile -T ‘application&#x2F;x-www-form-urlencoded’ **<a href="http://192.168.140.1:8080/seckill/doseckill"><strong>http://192.168.140.1:8080/seckill/doseckill</strong></a></p><div class="code-wrapper"><pre><code class="hljs">  1. **已经秒光，可是还有库存**</code></pre></div><p>ab -n 2000 -c 100 -p postfile -T ‘application&#x2F;x-www-form-urlencoded’ <a href="http://192.168.137.1:8080/seckill/doseckill">http://192.168.137.1:8080/seckill/doseckill</a><br>已经秒光，可是还有库存。原因，就是乐观锁导致很多请求都失败。先点的没秒到，后点的可能秒到了。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730054113-9d5a6de0-5d17-45bd-97b9-874049d61baf.jpeg#averageHue=%23797269&id=d14LS&originHeight=108&originWidth=302&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **连接超时，通过连接池解决**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730054288-27c5b05f-a94c-4b63-a525-e6d16c0375a3.jpeg#averageHue=%2393bbe1&id=VLdEy&originHeight=86&originWidth=619&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **连接池**</code></pre></div><p>节省每次连接redis服务带来的消耗，把连接好的实例反复利用。<br>通过参数管理连接的行为<br>代码见项目中</p><ul><li>链接池参数<ul><li>MaxTotal：控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；如果赋值为-1，则表示不限制；如果pool已经分配了MaxTotal个jedis实例，则此时pool的状态为exhausted。</li><li>maxIdle：控制一个pool最多有多少个状态为idle(空闲)的jedis实例；</li><li>MaxWaitMillis：表示当borrow一个jedis实例时，最大的等待毫秒数，如果超过等待时间，则直接抛JedisConnectionException；</li><li>testOnBorrow：获得一个jedis实例的时候是否检查连接可用性（ping()）；如果为true，则得到的jedis实例均是可用的；</li></ul><ol><li><strong>解决库存遗留问题</strong><ol><li><strong>LUA脚本</strong></li></ol></li></ol></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730054477-cae19266-6238-4723-8a4c-c28305a736d8.jpeg#averageHue=%23e8e9e7&id=D7HPy&originHeight=129&originWidth=138&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>Lua 是一个小巧的<a href="http://baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80">脚本语言</a>，Lua脚本可以很容易的被C&#x2F;C++ 代码调用，也可以反过来调用C&#x2F;C++的函数，Lua并没有提供强大的库，一个完整的Lua解释器不过200k，所以Lua不适合作为开发独立应用程序的语言，而是作为嵌入式脚本语言。<br>很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。<br>这其中包括魔兽争霸地图、魔兽世界、博德之门、愤怒的小鸟等众多游戏插件或外挂。<br><a href="https://www.w3cschool.cn/lua/">https://www.w3cschool.cn/lua/</a></p><div class="code-wrapper"><pre><code class="hljs">  1. **LUA脚本在Redis中的优势**</code></pre></div><p>将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连接redis的次数。提升性能。<br>LUA脚本是类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作。<br>但是注意redis的lua脚本功能，只有在Redis 2.6以上的版本才可以使用。<br>利用lua脚本淘汰用户，解决超卖问题。<br>redis 2.6版本以后，通过lua脚本解决<strong>争抢问题</strong>，实际上是<strong>redis 利用其单线程的特性，用任务队列的方式解决多任务并发问题</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730054720-4b5108cf-836f-454d-8d3a-5e6610f33167.jpeg#averageHue=%23fae0be&id=Iy2sW&originHeight=225&originWidth=600&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>Redis_事务_秒杀案例_代码</strong><ol><li><strong>项目结构</strong></li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730054907-f204ef93-9675-4e13-97f0-f9c305933a1f.png#averageHue=%23faf7f2&id=clsqt&originHeight=209&originWidth=215&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **第一版：简单版 **</code></pre></div><p>老师点10次，正常秒杀<br>同学一起点试一试，秒杀也是正常的。这是因为还达不到并发的效果。<br>使用工具ab模拟并发测试，会出现超卖情况。查看库存会出现负数。</p><div class="code-wrapper"><pre><code class="hljs">  1. **第二版：加事务-乐观锁(解决超卖),但出现遗留库存和连接超时**  2. **第三版：连接池解决超时问题 **  3. **第四版：解决库存依赖问题，LUA脚本**</code></pre></div><p>| local userid&#x3D;KEYS[1];<br>local prodid&#x3D;KEYS[2];<br>local qtkey&#x3D;”sk:”..prodid..”:qt”;<br>local usersKey&#x3D;”sk:”..prodid.”:usr’;<br>local userExists&#x3D;redis.call(“sismember”,usersKey,userid);<br>if tonumber(userExists)&#x3D;&#x3D;1 then<br>  return 2;<br>end<br>local num&#x3D; redis.call(“get” ,qtkey);<br>if tonumber(num)&lt;&#x3D;0 then<br>  return 0;<br>else<br>  redis.call(“decr”,qtkey);<br>  redis.call(“sadd”,usersKey,userid);<br>end</p><table><thead><tr><th>return 1;</th></tr></thead></table><ol><li><strong>Redis持久化之RDB</strong><ol><li><strong>总体介绍</strong></li></ol></li></ol><p>官网介绍：<a href="http://www.redis.io/">http://www.redis.io</a><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730055181-21b42629-abdb-408d-8139-72b3db4826e7.jpeg#averageHue=%23dddcd8&id=LuJfp&originHeight=240&originWidth=612&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>Redis 提供了2个不同形式的持久化方式。</p><ul><li>RDB（Redis DataBase）</li><li>AOF（Append Of File）<ol><li><strong>RDB（Redis DataBase）</strong><ol><li><strong>官网介绍</strong></li></ol></li></ol></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730055430-a04d534c-6813-404e-afa9-ad374a47ae7f.jpeg#averageHue=%23e1dfdc&id=L2nnI&originHeight=389&originWidth=606&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **是什么**</code></pre></div><p>在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里</p><div class="code-wrapper"><pre><code class="hljs">  1. **备份是如何执行的**</code></pre></div><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。<strong>RDB的缺点是最后一次持久化后的数据可能丢失</strong>。</p><div class="code-wrapper"><pre><code class="hljs">  1. **Fork**</code></pre></div><ul><li><p>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p></li><li><p>在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“<strong>写时复制技术</strong>”</p></li><li><p><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p><div class="code-wrapper"><pre><code class="hljs">1. **RDB持久化流程**</code></pre></div></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730055601-d03945eb-508f-499e-acde-dd485a30138d.png#averageHue=%23eeeded&id=mZlnw&originHeight=330&originWidth=475&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **dump.rdb文件**</code></pre></div><p>在redis.conf中配置文件名称，默认为dump.rdb<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730055806-a8519103-df9a-4e33-98b1-320aca70fbcd.png#averageHue=%23160606&id=F2yMJ&originHeight=84&originWidth=473&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **配置位置**</code></pre></div><p>rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下<br>dir “&#x2F;myredis&#x2F;“<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730056042-a0f2e26f-c64f-4e30-b801-e772b0abaf58.png#averageHue=%230b0808&id=LxeNT&originHeight=200&originWidth=719&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **如何触发RDB快照；保持策略**     1. **配置文件中默认的快照配置**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730056324-6811ad3a-8f85-4229-9f2b-a4345a12125f.png#averageHue=%23160808&id=ikta5&originHeight=220&originWidth=699&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">     1. **命令save VS bgsave**</code></pre></div><p>save ：save时只管保存，其它不管，全部阻塞。手动保存。不建议。<br><strong>bgsave：Redis会在后台异步进行快照操作， 快照同时还可以响应客户端请求。</strong><br>可以通过lastsave 命令获取最后一次成功执行快照的时间</p><div class="code-wrapper"><pre><code class="hljs">     1. **flushall命令**</code></pre></div><p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</p><div class="code-wrapper"><pre><code class="hljs">     1. **###SNAPSHOTTING快照###**     2. **Save**</code></pre></div><p>格式：save 秒钟 写操作次数<br>RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，<br><strong>默认是1分钟内改了1万次，或5分钟内改了10次，或15分钟内改了1次。</strong><br>禁用<br>不设置save指令，或者给save传入空字符串</p><div class="code-wrapper"><pre><code class="hljs">     1. **stop-writes-on-bgsave-error**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730056566-b7477281-0ae2-4042-ae1d-7fb4ad566669.png#averageHue=%23130a0a&id=uEi7h&originHeight=134&originWidth=725&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes.</p><div class="code-wrapper"><pre><code class="hljs">     1. **rdbcompression 压缩文件**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730056786-cf02a974-a051-438d-b27e-6c6acbc7b15e.png#averageHue=%23120c0c&id=AnH3A&originHeight=129&originWidth=724&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。<br>如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes.</p><div class="code-wrapper"><pre><code class="hljs">     1. **rdbchecksum 检查完整性**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730057060-2dd5e796-841a-4e7a-8f95-8fbf34cc5eda.png#averageHue=%230e0707&id=vfML2&originHeight=105&originWidth=724&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>在存储快照后，还可以让redis使用CRC64算法来进行数据校验，<br>但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能<br>推荐yes.</p><div class="code-wrapper"><pre><code class="hljs">     1. **rdb的备份**</code></pre></div><p>先通过config get dir  查询rdb文件的目录<br>将*.rdb的文件拷贝到别的地方<br>rdb的恢复</p><div class="code-wrapper"><pre><code class="hljs">  - 关闭Redis  - 先把备份的文件拷贝到工作目录下 cp dump2.rdb dump.rdb  - 启动Redis, 备份数据会直接加载  1. **优势**</code></pre></div><ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高更适合使用</li><li>节省磁盘空间</li><li>恢复速度快</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730057328-1a1bd3cf-aa53-4fa3-99a7-8766afb7f633.jpeg#averageHue=%23a6d477&id=bdgqK&originHeight=202&originWidth=479&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **劣势**</code></pre></div><ul><li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li><li>虽然Redis在fork时使用了<strong>写时拷贝技术</strong>,但是如果数据庞大时还是比较消耗性能。</li><li>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。<br>1. <strong>如何停止</strong></li></ul><p>动态停止RDB：redis-cli config set save “”#save后给空值，表示禁用保存策略</p><div class="code-wrapper"><pre><code class="hljs">  1. **小总结**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730057646-f8b197f6-79c1-4fc4-acc6-f7bec75f94eb.jpeg#averageHue=%23f9f9f9&id=Dm0u6&originHeight=403&originWidth=613&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>Redis持久化之AOF</strong><ol><li><strong>AOF（Append Only File）</strong><ol><li><strong>是什么</strong></li></ol></li></ol></li></ol><p>以<strong>日志</strong>的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(<strong>读操作不记录</strong>)， <strong>只许追加文件但不可以改写文件</strong>，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p><div class="code-wrapper"><pre><code class="hljs">  1. **AOF持久化流程**</code></pre></div><p>（1）客户端的请求写命令会被append追加到AOF缓冲区内；<br>（2）AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；<br>（3）AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；<br>（4）Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的；<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730057886-6d5c494b-e7a7-4115-9575-2e78ef90c48d.png#averageHue=%23edecec&id=DNPfE&originHeight=383&originWidth=233&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **AOF默认不开启**</code></pre></div><p>可以在redis.conf中配置文件名称，默认为 appendonly.aof<br>AOF文件的保存路径，同RDB的路径一致。</p><div class="code-wrapper"><pre><code class="hljs">  1. **AOF和RDB同时开启，redis听谁的？**</code></pre></div><p>AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）</p><div class="code-wrapper"><pre><code class="hljs">  1. **AOF启动/修复/恢复**</code></pre></div><ul><li>AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</li><li>正常恢复</li><li>修改默认的appendonly no，改为yes</li><li>将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir)</li><li>恢复：重启redis然后重新加载</li><li>异常恢复</li><li>修改默认的appendonly no，改为yes</li><li>如遇到<strong>AOF文件损坏</strong>，通过&#x2F;usr&#x2F;local&#x2F;bin&#x2F;<strong>redis-check-aof–fix appendonly.aof</strong>进行恢复</li><li>备份被写坏的AOF文件</li><li>恢复：重启redis，然后重新加载<br>1. <strong>AOF同步频率设置</strong></li></ul><p>appendfsync always<br>始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好<br>appendfsync everysec<br>每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。<br>appendfsync no<br>redis不主动进行同步，把同步时机交给操作系统。</p><div class="code-wrapper"><pre><code class="hljs">  1. **Rewrite压缩**</code></pre></div><p>1是什么：<br>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof<br>2重写原理，如何实现重写<br>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。<br>no-appendfsync-on-rewrite：<br>如果 no-appendfsync-on-rewrite&#x3D;yes ,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）<br>    如果 no-appendfsync-on-rewrite&#x3D;no,  还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）<br>触发机制，何时重写<br>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发<br>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。<br>auto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）<br>auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。<br>例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB<br>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,<br>如果Redis的AOF当前大小&gt;&#x3D; base_size +base_size*100% (默认)且当前大小&gt;&#x3D;64mb(默认)的情况下，Redis会对AOF进行重写。<br>3、重写流程<br>（1）bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。<br>（2）主进程fork出子进程执行重写操作，保证主进程不会阻塞。<br>（3）子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。<br>（4）1).子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。2).主进程把aof_rewrite_buf中的数据写入到新的AOF文件。<br>（5）使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730058156-e7a60505-1151-4537-8a78-0ea8a294fccd.png#averageHue=%23f6f6f6&id=DnxVL&originHeight=638&originWidth=701&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **优势**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730058439-66ee9250-8f65-48b6-bc41-58850a528e74.jpeg#averageHue=%23cad496&id=f4Efc&originHeight=106&originWidth=536&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li>备份机制更稳健，丢失数据概率更低。</li><li>可读的日志文本，通过操作AOF稳健，可以处理误操作。<br>1. <strong>劣势</strong></li><li>比起RDB占用更多的磁盘空间。</li><li>恢复备份速度要慢。</li><li>每次读写都同步的话，有一定的性能压力。</li><li>存在个别Bug，造成恢复不能。<br>1. **  小总结**</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730058786-ed4e3683-45aa-4285-8764-3d48c440bd73.jpeg#averageHue=%23faf9f8&id=yjMkA&originHeight=326&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>总结(Which one)</strong><ol><li><strong>用哪个好</strong></li></ol></li></ol><p>官方推荐两个都启用。<br>如果对数据不敏感，可以选单独用RDB。<br>不建议单独用 AOF，因为可能会出现Bug。<br>如果只是做纯内存缓存，可以都不用。</p><div class="code-wrapper"><pre><code class="hljs">  1. **官网建议**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730059011-3a34fc84-6548-4124-8b48-303d3df871d0.jpeg#averageHue=%23faf9f9&id=MvDwj&originHeight=341&originWidth=610&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</li><li>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾. </li><li>Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大</li><li>只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</li><li>同时开启两种持久化方式</li><li>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据, 因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</li><li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ </li><li>建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)， 快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</li><li>性能建议<br>| 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。</li></ul><p>如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。<br>代价,一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。<br>只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。</p><table><thead><tr><th>默认超过原大小100%大小时重写可以改到适当的数值。</th></tr></thead></table><ol><li><strong>Redis_主从复制</strong><ol><li><strong>是什么</strong></li></ol></li></ol><p>主机数据更新后根据配置和策略， 自动同步到备机的master&#x2F;slaver机制，<strong>Master以写为主，Slave以读为主</strong></p><ol><li><strong>能干嘛</strong></li></ol><ul><li>读写分离，性能扩展</li><li>容灾快速恢复</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730059288-8136969e-2728-44c0-92f1-403eaab1bc16.jpeg#averageHue=%23fefcf2&id=KK85J&originHeight=206&originWidth=324&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>怎么玩：主从复制</strong></li></ol><p>拷贝多个redis.conf文件include(写绝对路径)<br>开启daemonize yes<br>Pid文件名字pidfile<br>指定端口port<br>Log文件名字<br>dump.rdb名字dbfilename<br>Appendonly 关掉或者换名字</p><div class="code-wrapper"><pre><code class="hljs">  1. **新建redis6379.conf，填写以下内容**</code></pre></div><p>include &#x2F;myredis&#x2F;redis.conf<br>pidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid<br>port 6379<br>dbfilename dump6379.rdb<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730059500-a043faca-b0c8-4ca1-bea2-ca501c4ee043.jpeg#averageHue=%23686259&id=b4oWf&originHeight=70&originWidth=265&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **新建redis6380.conf，填写以下内容**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730059753-1adb8e30-94f0-436c-85a5-5267413c6a65.jpeg#averageHue=%23696359&id=Q5Svi&originHeight=76&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **新建redis6381.conf，填写以下内容**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730060016-2ceaeb23-5896-4990-848e-f5bfdfae8f67.jpeg#averageHue=%23827b73&id=wdYqu&originHeight=79&originWidth=270&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>slave-priority 10<br>设置从机的优先级，值越小，优先级越高，用于选举主机时使用。默认100</p><div class="code-wrapper"><pre><code class="hljs">  1. **启动三台redis服务器**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730060260-b04a3052-e6b0-487b-aec1-3a3290ccc001.jpeg#averageHue=%239a9589&id=yy6Ru&originHeight=68&originWidth=428&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **查看系统进程，看看三台服务器是否启动**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730060610-89904f51-3b40-46ca-848b-6a81c80c9cda.jpeg#averageHue=%235e5951&id=U3EWV&originHeight=100&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **查看三台主机运行情况**</code></pre></div><p>info replication<br>打印主从复制的相关信息</p><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730060901-a0b333aa-8379-4a88-a487-9ec66fbc18bd.jpeg#averageHue=%235a5853&id=dElMA&originHeight=180&originWidth=612&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **配从(库)不配主(库) **</code></pre></div><p>slaveof  <ip><port><br>成为某个实例的从服务器<br>1、在6380和6381上执行: slaveof 127.0.0.1 6379<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730061199-cc3e0dca-3cc4-4183-bec2-31ac0c33d1d7.jpeg#averageHue=%231f1d1d&id=yKo9V&originHeight=191&originWidth=611&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>2、在主机上写，在从机上可以读取数据<br>在从机上写数据报错<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730061424-10f974eb-e268-4ed3-970a-58624217171e.jpeg#averageHue=%23625b51&id=NxioL&originHeight=38&originWidth=513&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>3、主机挂掉，重启就行，一切如初<br>4、从机重启需重设：slaveof 127.0.0.1 6379<br>可以将配置增加到文件中。永久生效。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730061676-2e200633-8bbd-4339-8cfa-12e606c17002.jpeg#averageHue=%230b0a09&id=SapCx&originHeight=248&originWidth=538&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>常用3招</strong><ol><li><strong>一主二仆</strong></li></ol></li></ol><p>切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的k1,k2,k3是否也可以复制？<br>从机是否可以写？set可否？<br>主机shutdown后情况如何？从机是上位还是原地待命？<br>主机又回来了后，主机新增记录，从机还能否顺利复制？<br>其中一台从机down后情况如何？依照原有它能跟上大部队吗？</p><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730061938-227d99d9-6b81-481e-863e-528691c14421.jpeg#averageHue=%23fbfbf8&id=xOZvU&originHeight=109&originWidth=284&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **薪火相传**</code></pre></div><p>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。<br>用 slaveof  <ip><port><br>中途变更转向:会清除之前的数据，重新建立拷贝最新的<br>风险是一旦某个slave宕机，后面的slave都没法备份<br>主机挂了，从机还是从机，无法写数据了<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730062220-2562dda9-6423-4298-81e7-2579ef008c95.jpeg#averageHue=%23fafaf7&id=I2xJV&originHeight=89&originWidth=407&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730062487-6c6e8c25-d0b8-446f-bcdc-36fab2a44a0e.jpeg#averageHue=%23191616&id=R9Lra&originHeight=153&originWidth=625&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **反客为主**</code></pre></div><p>当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。<br>用 slaveof  no one  将从机变为主机。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730062734-bb999b61-30d6-4f9b-8428-f7718dd62b06.jpeg#averageHue=%237c766e&id=DfAOO&originHeight=145&originWidth=616&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>复制原理</strong></li></ol><ul><li>Slave启动成功连接到master后会发送一个sync命令</li><li>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步</li><li>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li><li>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</li><li>但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730062965-da099463-4551-4b5f-948b-90d3dd45f71c.jpeg#averageHue=%23fbfbf9&id=iFoVd&originHeight=157&originWidth=397&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>哨兵模式(sentinel)</strong><ol><li><strong>是什么</strong></li></ol></li></ol><p><strong>反客为主的自动版</strong>，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730063255-4b1a1df6-440e-404a-9038-9dcd704a13f8.jpeg#averageHue=%23fdfdfa&id=yTMO9&originHeight=200&originWidth=305&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **怎么玩(使用步骤)**     1. **调整为一主二仆模式，6379带着6380、6381**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730063529-6128db26-5298-4980-bb0b-aa20b60715d1.jpeg#averageHue=%231e1c1b&id=O9Zhq&originHeight=192&originWidth=615&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">     1. **自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错**     2. **配置哨兵,填写内容**</code></pre></div><p>sentinel monitor mymaster 127.0.0.1 6379 1<br>其中mymaster为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量。 </p><div class="code-wrapper"><pre><code class="hljs">     1. **启动哨兵**</code></pre></div><p>&#x2F;usr&#x2F;local&#x2F;bin<br>redis做压测可以用自带的redis-benchmark工具<br>执行redis-sentinel  &#x2F;myredis&#x2F;sentinel.conf<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730063836-22f7cd8d-4279-494b-8bdb-60758c46aa30.jpeg#averageHue=%230a0605&id=K9J6x&originHeight=517&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">     1. **当主机挂掉，从机选举中产生新的主机**</code></pre></div><p>(大概10秒左右可以看到哨兵窗口日志，切换了新的主机)<br>哪个从机会被选举为主机呢？根据优先级别：slave-priority<br>原主机重启后会变为从机。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730064132-98b85c71-677b-42f0-8e44-79623a2d24c9.jpeg#averageHue=%235a564f&id=pV7en&originHeight=496&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">     1. **复制延时**</code></pre></div><p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p><div class="code-wrapper"><pre><code class="hljs">  1. **故障恢复**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730064417-c797bdf6-42f1-4a57-9584-25f699de26fe.jpeg#averageHue=%23ececec&id=LHDIf&originHeight=301&originWidth=553&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>优先级在redis.conf中默认：slave-priority 100，值越小优先级越高<br>偏移量是指获得原主机数据最全的<br>每个redis实例启动后都会随机生成一个40位的runid</p><div class="code-wrapper"><pre><code class="hljs">  1. **主从复制**</code></pre></div><p>| **private static **JedisSentinelPool <em>jedisSentinelPool</em>&#x3D;<strong>null</strong>;<br>**public static  **Jedis getJedisFromSentinel(){<strong>if</strong>(<em>jedisSentinelPool</em>&#x3D;&#x3D;<strong>null</strong>){<br>            Set<String> sentinelSet&#x3D;<strong>new <strong>HashSet&lt;&gt;();<br>            sentinelSet.add(</strong>“192.168.11.103:26379”</strong>);</p><div class="code-wrapper"><pre><code class="hljs">        JedisPoolConfig jedisPoolConfig =**new **JedisPoolConfig();        jedisPoolConfig.setMaxTotal(10); _//最大可用连接数_jedisPoolConfig.setMaxIdle(5); _//最大闲置连接数_jedisPoolConfig.setMinIdle(5); _//最小闲置连接数_jedisPoolConfig.setBlockWhenExhausted(**true**); _//连接耗尽是否等待_jedisPoolConfig.setMaxWaitMillis(2000); _//等待时间_jedisPoolConfig.setTestOnBorrow(**true**); _//取连接的时候进行一下测试 ping pong</code></pre></div><p>jedisSentinelPool_&#x3D;<strong>new <strong>JedisSentinelPool(</strong>“mymaster”</strong>,sentinelSet,jedisPoolConfig);**return **<em>jedisSentinelPool</em>.getResource();<br>        }<strong>else</strong>{**return **<em>jedisSentinelPool</em>.getResource();<br>        }</p><table><thead><tr><th>}</th></tr></thead></table><ol><li><strong>Redis集群</strong><ol><li><strong>问题</strong></li></ol></li></ol><p>容量不够，redis如何进行扩容？<br>并发写操作， redis如何分摊？<br>另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。<br>之前通过代理主机来解决，但是redis3.0中提供了解决方案。就是无中心化集群配置。</p><ol><li><strong>什么是集群</strong></li></ol><p>Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1&#x2F;N。<br>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p><ol><li><strong>删除持久化数据</strong></li></ol><p>将rdb,aof文件都删除掉。</p><ol><li><strong>制作6个实例，6379,6380,6381,6389,6390,6391</strong><ol><li><strong>配置基本信息</strong></li></ol></li></ol><p>开启daemonize yes<br>Pid文件名字<br>指定端口<br>Log文件名字<br>Dump.rdb名字<br>Appendonly 关掉或者换名字</p><div class="code-wrapper"><pre><code class="hljs">  1. **redis cluster配置修改**</code></pre></div><p>cluster-enabled yes    打开集群模式<br>cluster-config-file nodes-6379.conf  设定节点配置文件名<br>cluster-node-timeout 15000   设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。</p><p>| include &#x2F;home&#x2F;bigdata&#x2F;redis.conf<br>port 6379<br>pidfile “&#x2F;var&#x2F;run&#x2F;redis_6379.pid”<br>dbfilename “dump6379.rdb”<br>dir “&#x2F;home&#x2F;bigdata&#x2F;redis_cluster”<br>logfile “&#x2F;home&#x2F;bigdata&#x2F;redis_cluster&#x2F;redis_err_6379.log”<br>cluster-enabled yes<br>cluster-config-file nodes-6379.conf</p><table><thead><tr><th>cluster-node-timeout 15000</th></tr></thead></table><div class="code-wrapper"><pre><code class="hljs">  1. **修改好redis6379.conf文件，拷贝多个redis.conf文件**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730064711-25ff6879-8c94-4ff2-912e-19dc08501733.jpeg#averageHue=%2352524a&id=uCbvU&originHeight=122&originWidth=146&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **使用查找替换修改另外5个文件**</code></pre></div><p>例如：:%s&#x2F;6379&#x2F;6380  </p><div class="code-wrapper"><pre><code class="hljs">  1. **启动6个redis服务**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730065009-ba59696d-4822-48c4-93e0-816f06495ae3.jpeg#averageHue=%2358534d&id=aum7N&originHeight=390&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>将六个节点合成一个集群</strong></li></ol><p>组合之前，请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730065368-75e6de27-eeb8-4e87-a5ab-aad76a30ab41.jpeg#averageHue=%239a9488&id=LnPSN&originHeight=325&originWidth=551&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li>合体：</li></ul><p>cd  &#x2F;opt&#x2F;redis-6.2.1&#x2F;src</p><table><thead><tr><th>redis-cli –cluster create –cluster-replicas 1 192.168.11.101:6379 192.168.11.101:6380 192.168.11.101:6381 192.168.11.101:6389 192.168.11.101:6390 192.168.11.101:6391</th></tr></thead></table><p>此处不要用127.0.0.1， 请用真实IP地址<br>–replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730065713-2362c661-8190-45e5-af40-b67d53a1a702.jpeg#averageHue=%23090505&id=BB1yK&originHeight=229&originWidth=613&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730066034-314aefd9-6dbd-44ce-aaaa-235bdb11969b.jpeg#averageHue=%23656059&id=upEEw&originHeight=400&originWidth=453&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li>普通方式登录</li></ul><p>可能直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，应该以集群方式登录。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730066308-ffcffe03-91f5-486f-a8d4-ab6fd5acd1e3.jpeg#averageHue=%2390887c&id=cKQ0P&originHeight=96&originWidth=352&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>-c 采用集群策略连接，设置数据会自动切换到相应的写主机</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730066592-57524d74-ea9c-4c77-a0be-922f9b6fa646.jpeg#averageHue=%23110908&id=HUIXr&originHeight=136&originWidth=545&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>通过 cluster nodes 命令查看集群信息</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730067892-bcf1e26e-d09d-49e7-ab1d-30c7e1bcd569.jpeg#averageHue=%23373734&id=ZEIAM&originHeight=70&originWidth=619&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>redis cluster 如何分配这六个节点?</strong></li></ol><p>一个集群至少要有三个主节点。<br>选项 –cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。<br>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。</p><ol><li><strong>什么是slots</strong></li></ol><p><strong>[OK] All nodes agree about slots configuration.</strong><br><strong>&gt;&gt;&gt; Check for open slots…</strong><br><strong>&gt;&gt;&gt; Check slots coverage…</strong><br><strong>[OK] All 16384 slots covered.</strong><br>一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个，<br>集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。<br>集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点， 其中：<br>节点 A 负责处理 0 号至 5460 号插槽。<br>节点 B 负责处理 5461 号至 10922 号插槽。<br>节点 C 负责处理 10923 号至 16383 号插槽。</p><ol><li><strong>在集群中录入值</strong></li></ol><p>在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。<br>redis-cli客户端提供了 –c 参数实现自动重定向。<br>如 redis-cli  -c –p 6379 登入后，再录入、查询键值对可以自动重定向。<br>不在一个slot下的键值，是不能使用mget,mset等多键操作。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730068169-f49380f0-681e-41d7-8b82-32c7a26bc5f6.jpeg#averageHue=%235d5850&id=ovTRs&originHeight=38&originWidth=477&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730068454-8358ba48-2f36-4d66-8cb6-1c760ec33013.jpeg#averageHue=%23635d54&id=tiyJ9&originHeight=51&originWidth=477&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>查询集群中的值</strong></li></ol><p>CLUSTER GETKEYSINSLOT <slot><count> 返回 count 个 slot 槽中的键。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730068715-d5089a9d-586c-4755-85ab-2f07e10e337e.jpeg#averageHue=%230b0a09&id=trh58&originHeight=159&originWidth=458&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>故障恢复</strong></li></ol><p>如果主节点下线？从节点能否自动升为主节点？注意：<strong>15秒超时</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730069111-379b6de7-4859-4afe-b479-807245c3400a.jpeg#averageHue=%233e3e3b&id=nO7l1&originHeight=69&originWidth=612&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>主节点恢复后，主从关系会如何？主节点回来变成从机。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730069586-dc99921d-5a48-491a-bb57-67c66f78919f.jpeg#averageHue=%233c3c39&id=E6CJd&originHeight=69&originWidth=611&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?<br>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉<br>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。<br>redis.conf中的参数  cluster-require-full-coverage</p><ol><li><strong>集群的Jedis开发</strong></li></ol><p>即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。<br>无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。</p><p>| public class JedisClusterTest {<br>  public static void main(String[] args) { <br>     Set<HostAndPort>set &#x3D;new HashSet<HostAndPort>();<br>     set.add(new HostAndPort(“192.168.31.211”,6379));<br>     JedisCluster jedisCluster&#x3D;new JedisCluster(set);<br>     jedisCluster.set(“k1”, “v1”);<br>     System.<em>out.println(jedisCluster.get(“k1”));</em><br>  }</p><table><thead><tr><th>}</th></tr></thead></table><ol><li><strong>Redis 集群提供了以下好处</strong></li></ol><p>实现扩容<br>分摊压力<br>无中心配置相对简单</p><ol><li><strong>Redis 集群的不足</strong></li></ol><p>多键操作是不被支持的<br>多键的Redis事务是不被支持的。lua脚本不被支持<br>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</p><ol><li><strong>Redis应用问题解决</strong><ol><li><strong>缓存穿透</strong><ol><li><strong>问题描述</strong></li></ol></li></ol></li></ol><p>key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730069953-275cddcd-e44c-40e5-9b9f-d46ded46ad78.png#averageHue=%23faf4f3&id=TrOEm&originHeight=329&originWidth=677&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **解决方案**</code></pre></div><p>一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。<br>解决方案：</p><ol><li><strong>对空值缓存：</strong>如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟</li><li><strong>设置可访问的名单（白名单）：</strong></li></ol><p>使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</p><ol><li><strong>采用布隆过滤器</strong>：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。</li></ol><p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)<br>将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。</p><ol><li><strong>进行实时监控：</strong>当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务<ol><li><strong>缓存击穿</strong><ol><li><strong>问题描述</strong></li></ol></li></ol></li></ol><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730070215-e34d05fd-bf8e-40e6-af86-88ae9eb44e95.png#averageHue=%23faf6f5&id=xAfbW&originHeight=343&originWidth=723&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **解决方案**</code></pre></div><p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。<br>解决问题：<br><strong>（1）预先设置热门数据：</strong>在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长<br><strong>（2）实时调整：</strong>现场监控哪些数据热门，实时调整key的过期时长<br><strong>（3）使用锁：</strong></p><ol><li>就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。</li><li>先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key</li><li>当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；</li><li>当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730070470-f8183b79-bf14-4a22-9fbc-3cc4835cb2af.png#averageHue=%23fbfbfb&id=VBlaP&originHeight=411&originWidth=448&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>缓存雪崩</strong><ol><li><strong>问题描述</strong></li></ol></li></ol><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。<br>缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key<br>正常访问<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730070765-88efeeb3-4ea4-4960-ae38-84aa60eb556d.png#averageHue=%23faf8f7&id=LHa9y&originHeight=484&originWidth=826&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>缓存失效瞬间<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730071077-28e3b97a-2cdc-4f8a-a415-8e0ec739bfbe.png#averageHue=%23faf8f7&id=qyRBl&originHeight=473&originWidth=826&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><div class="code-wrapper"><pre><code class="hljs">  1. **解决方案**</code></pre></div><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕！<br>解决方案：</p><ol><li><strong>构建多级缓存架构：</strong>nginx缓存 + redis缓存 +其他缓存（ehcache等）</li><li><strong>使用锁或队列：</strong></li></ol><p>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况</p><ol><li><strong>设置过期标志更新缓存：</strong></li></ol><p>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</p><ol><li><strong>将缓存失效时间分散开：</strong></li></ol><p>比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><ol><li><strong>分布式锁</strong><ol><li><strong>问题描述</strong></li></ol></li></ol><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！<br>分布式锁主流的实现方案：</p><ol><li><p>基于数据库实现分布式锁</p></li><li><p>基于缓存（Redis等）</p></li><li><p>基于Zookeeper<br>每一种分布式锁解决方案都有各自的优缺点：</p></li><li><p>性能：redis最高</p></li><li><p>可靠性：zookeeper最高<br>这里，我们就基于redis实现分布式锁。</p><ol><li><strong>解决方案：使用redis实现分布式锁</strong></li></ol></li></ol><p>redis:命令</p><h1 id="set-sku-1-info-“OK”-NX-PX-10000"><a href="#set-sku-1-info-“OK”-NX-PX-10000" class="headerlink" title="set sku:1:info “OK” NX PX 10000"></a>set sku:1:info “OK” NX PX 10000</h1><p>EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。<br>PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。<br>NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。<br>XX ：只在键已经存在时，才对键进行设置操作。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730071356-417caa2a-c06b-40b6-a1a1-57e0999e745e.png#averageHue=%23f7ebda&id=QibzD&originHeight=413&originWidth=516&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><p>多个客户端同时获取锁（setnx）</p></li><li><p>获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</p></li><li><p>其他客户端等待重试</p><ol><li><strong>编写代码</strong></li></ol></li></ol><p>Redis: set num 0</p><p>| @GetMapping(<strong>“testLock”</strong>)<strong>public void <strong>testLock(){<br>    _&#x2F;&#x2F;1获取锁，setne<br>    _Boolean lock &#x3D; <strong>redisTemplate</strong>.opsForValue().setIfAbsent(</strong>“lock”</strong>, <strong>“111”</strong>);<br>    _&#x2F;&#x2F;2获取锁成功、查询num的值<br>    _<strong>if</strong>(lock){<br>        Object value &#x3D; <strong>redisTemplate</strong>.opsForValue().get(<strong>“num”</strong>);<br>        _&#x2F;&#x2F;2.1判断num为空return<br>        _<strong>if</strong>(StringUtils.<em>isEmpty</em>(value)){<br>            <strong>return</strong>;<br>        }<br>        _&#x2F;&#x2F;2.2有值就转成成int<br>        _<strong>int <strong>num &#x3D; Integer.<em>parseInt</em>(value+</strong>“”</strong>);<br>        _&#x2F;&#x2F;2.3把redis的num加1<br>        _<strong>redisTemplate</strong>.opsForValue().set(<strong>“num”</strong>, ++num);<br>        _&#x2F;&#x2F;2.4释放锁，del<br>        _<strong>redisTemplate</strong>.delete(<strong>“lock”</strong>);</p><div class="code-wrapper"><pre><code class="hljs">&#125;**else**&#123;    _//3获取锁失败、每隔0.1秒再获取    _**try **&#123;        Thread._sleep_(100);        testLock();    &#125; **catch **(InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre></div><table><thead><tr><th>}</th></tr></thead></table><p>重启，服务集群，通过网关压力测试：<br>ab -n 1000 -c 100 <a href="http://192.168.140.1:8080/test/testLock">http://192.168.140.1:8080/test/testLock</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730071601-fe3ab0bd-e460-4b8b-849a-182bb9e26043.png#averageHue=%23080604&id=gLlai&originHeight=339&originWidth=675&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>查看redis中num的值：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730071805-569a0a60-558e-439f-bb0f-003547344d5b.png#averageHue=%23070503&id=cqeJ7&originHeight=79&originWidth=254&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>基本实现。<br>问题：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放<br>解决：设置过期时间，自动释放锁。</p><div class="code-wrapper"><pre><code class="hljs">  1. **优化之设置锁的过期时间**</code></pre></div><p>设置过期时间有两种方式：</p><ol><li>首先想到通过expire设置过期时间（缺乏原子性：如果在setnx和expire之间出现异常，锁也无法释放）</li><li>在set时指定过期时间（推荐）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730072097-a77ddcab-ed0e-4a5b-b5f2-4c8880d8f329.png#averageHue=%23e5ba99&id=Rzw5k&originHeight=469&originWidth=535&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>设置过期时间：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730072368-07cc7a51-aa40-4613-9e55-361b8f4a67f5.png#averageHue=%23f9f9f9&id=dn0YL&originHeight=366&originWidth=938&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>压力测试肯定也没有问题。自行测试<br>问题：可能会释放其他服务器的锁。</li></ol><p>场景：如果业务逻辑的执行时间是7s。执行流程如下</p><ol><li>index1业务逻辑没执行完，3秒后锁被自动释放。</li><li>index2获取到锁，执行业务逻辑，3秒后锁被自动释放。</li><li>index3获取到锁，执行业务逻辑</li><li>index1业务逻辑执行完成，开始调用del释放锁，这时释放的是index3的锁，导致index3的业务只执行1s就被别人释放。</li></ol><p>最终等于没锁的情况。</p><p>解决：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁</p><div class="code-wrapper"><pre><code class="hljs">  1. **优化之UUID防误删**</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730072580-28c79e0f-3450-45e9-82d6-fa412efc8ee4.png#averageHue=%23eac79d&id=OZwju&originHeight=477&originWidth=535&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730072856-6390182a-5813-4629-a70c-f663a2a33437.png#averageHue=%23fcf5f3&id=Z1TwL&originHeight=464&originWidth=682&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>问题：删除操作缺乏原子性。<br>场景：</p><ol><li>index1执行删除时，查询到的lock值确实和uuid相等</li></ol><p>uuid&#x3D;v1<br>set(lock,uuid)；<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730073160-2aaca9d4-f781-484d-ba52-a8ff40078ed7.png#averageHue=%23d6c0a0&id=ufXoz&originHeight=28&originWidth=590&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li>index1执行删除前，lock刚好过期时间已到，被redis自动释放</li></ol><p>在redis中没有了lock，没有了锁。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730073432-cd41f3c8-78eb-4eb5-a00b-364c584de07b.png#averageHue=%23d5cca5&id=z7cRe&originHeight=24&originWidth=379&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li>index2获取了lock</li></ol><p>index2线程获取到了cpu的资源，开始执行方法<br>uuid&#x3D;v2<br>set(lock,uuid)；</p><ol><li>index1执行删除，此时会把index2的lock删除</li></ol><p>index1 因为已经在方法中了，所以不需要重新上锁。index1有执行的权限。index1已经比较完成了，这个时候，开始执行<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730073672-4a90d87b-fc4d-4c89-bcfb-94163aed807f.png#averageHue=%23d5cca5&id=v1xgD&originHeight=24&originWidth=379&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>删除的index2的锁！</p><div class="code-wrapper"><pre><code class="hljs">  1. **优化之LUA脚本保证删除的原子性**</code></pre></div><p>| @GetMapping(<strong>“testLockLua”</strong>)**public void **testLockLua() {_    &#x2F;&#x2F;1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中<br>    _String uuid &#x3D; UUID.<em>randomUUID</em>().toString();<br>    _&#x2F;&#x2F;2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！<br>    _String skuId &#x3D; <strong>“25”</strong>; _&#x2F;&#x2F; 访问skuId 为25号的商品 100008348542<br>    _String locKey &#x3D; **”lock:” **+ skuId; _&#x2F;&#x2F; 锁住的是每个商品的数据</p><div class="code-wrapper"><pre><code class="hljs">// 3 获取锁_Boolean lock = **redisTemplate**.opsForValue().setIfAbsent(locKey, uuid, 3, TimeUnit.**_SECONDS_**);_// 第一种： lock 与过期时间中间不写任何的代码。// redisTemplate.expire(&quot;lock&quot;,10, TimeUnit.SECONDS);//设置过期时间// 如果true_**if **(lock) &#123;    _// 执行的业务逻辑开始    // 获取缓存中的num 数据    _Object value = **redisTemplate**.opsForValue().get(**&quot;num&quot;**);    _// 如果是空直接返回    _**if **(StringUtils._isEmpty_(value)) &#123;        **return**;    &#125;    _// 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！    _**int **num = Integer._parseInt_(value + **&quot;&quot;**);    _// 使num 每次+1 放入缓存    _**redisTemplate**.opsForValue().set(**&quot;num&quot;**, String._valueOf_(++num));    _/*使用lua脚本来锁*/    // 定义lua 脚本    _String script = **&quot;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end&quot;**;    _// 使用redis执行lua执行    _DefaultRedisScript&lt;Long&gt; redisScript = **new **DefaultRedisScript&lt;&gt;();    redisScript.setScriptText(script);    _// 设置一下返回值类型 为Long    // 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型，    // 那么返回字符串与0 会有发生错误。    _redisScript.setResultType(Long.**class**);    _// 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。    _**redisTemplate**.execute(redisScript, Arrays._asList_(locKey), uuid);&#125; **else **&#123;    _// 其他线程等待    _**try **&#123;        _// 睡眠        _Thread._sleep_(1000);        _// 睡醒了之后，调用方法。        _testLockLua();    &#125; **catch **(InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre></div><table><thead><tr><th>}</th></tr></thead></table><p>Lua 脚本详解：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730073899-6d3141e9-8519-4cdb-8541-2dd6e8bdc18d.png#averageHue=%23fdfcfb&id=ETVfk&originHeight=480&originWidth=1028&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>项目中正确使用：</p><p>| </p><ol><li>定义key，key应该是为每个sku定义的，也就是每个sku有一把锁。</li></ol><p>String locKey &#x3D;<strong>“lock:”</strong>+skuId; <em>&#x2F;&#x2F; 锁住的是每个商品的数据</em></p><table><thead><tr><th>Boolean lock &#x3D; <strong>redisTemplate</strong>.opsForValue().setIfAbsent(locKey, uuid,3,TimeUnit.<strong><em>SECONDS</em></strong>);</th></tr></thead><tbody><tr><td><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730074191-2c9f99ec-d32f-48b3-b315-1ff9b4ca3aaf.png#averageHue=%23fcf8f6&id=zrxML&originHeight=403&originWidth=1234&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs">  1. **总结**</code></pre></div><p>1、加锁</p><p>| _&#x2F;&#x2F; 1. 从redis中获取锁,set k1 v1 px 20000 nx_String uuid &#x3D; UUID.<em>randomUUID</em>().toString();<br>Boolean lock &#x3D; <strong>this</strong>.<strong>redisTemplate</strong>.opsForValue()<br>  .setIfAbsent(<strong>“lock”</strong>, uuid, 2, TimeUnit.<strong><em>SECONDS</em></strong>); |</p><p>| — |</p><ol><li><p>使用lua释放锁<br>| <em>&#x2F;&#x2F; 2. 释放锁 del_String script &#x3D; <strong>“if redis.call(‘get’, KEYS[1]) &#x3D;&#x3D; ARGV[1] then return redis.call(‘del’, KEYS[1]) else return 0 end”</strong>;</em>&#x2F;&#x2F; 设置lua脚本返回的数据类型_DefaultRedisScript<Long> redisScript &#x3D; **new **DefaultRedisScript&lt;&gt;();_&#x2F;&#x2F; 设置lua脚本返回类型为Long_redisScript.setResultType(Long.<strong>class</strong>);</p><table><thead><tr><th>redisScript.setScriptText(script);<strong>redisTemplate</strong>.execute(redisScript, Arrays.<em>asList</em>(<strong>“lock”</strong>),uuid);</th></tr></thead></table></li><li><p>重试<br>| Thread.<em>sleep</em>(500);</p><table><thead><tr><th>testLock();</th></tr></thead></table></li></ol><p>为了确保分布式锁可用，我们至少要确保锁的实现同时<strong>满足以下四个条件</strong>：</p><ul><li>互斥性。在任意时刻，只有一个客户端能持有锁。</li><li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li><li>加锁和解锁必须具有原子性。</li></ul><ol><li><strong>Redis6.0新功能</strong><ol><li><strong>ACL</strong><ol><li><strong>简介</strong></li></ol></li></ol></li></ol><p>Redis ACL是Access Control List（访问控制列表）的缩写，该功能允许根据可以执行的命令和可以访问的键来限制某些连接。<br>在Redis 5版本之前，Redis 安全规则只有密码控制 还有通过rename 来调整高危命令比如 flushdb ， KEYS* ， shutdown 等。Redis 6 则提供ACL的功能对用户进行更细粒度的权限控制 ：<br>（1）接入权限:用户名和密码<br>（2）可以执行的命令<br>（3）可以操作的 KEY<br>参考官网：<a href="https://redis.io/topics/acl">https://redis.io/topics/acl</a></p><div class="code-wrapper"><pre><code class="hljs">  1. **命令**</code></pre></div><p>1、使用acl list命令展现用户权限列表<br>（1）数据说明<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730074431-05b634e8-61c0-434c-a443-98aa75f7c092.png#averageHue=%23b0adab&id=FB9YM&originHeight=179&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>2、使用acl cat命令<br>（1）查看添加权限指令类别<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730074718-a4d67980-3dbd-460a-b8bc-5cf765f8f8b4.png#averageHue=%230a0705&id=WeuV7&originHeight=353&originWidth=201&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>（2）加参数类型名可以查看类型下具体命令<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730074979-70b85580-5a5c-4cdd-b862-5e4e55a68541.png#averageHue=%23070503&id=ixrMP&originHeight=336&originWidth=257&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>3、使用acl whoami命令查看当前用户<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730075281-c2b829f3-ef21-4de1-b410-f92965d4e1b1.png#averageHue=%230f0b08&id=TpN1o&originHeight=34&originWidth=212&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>4、使用aclsetuser命令创建和编辑用户ACL<br>（1）ACL规则<br>下面是有效ACL规则的列表。某些规则只是用于激活或删除标志，或对用户ACL执行给定更改的单个单词。其他规则是字符前缀，它们与命令或类别名称、键模式等连接在一起。</p><table><thead><tr><th>ACL规则</th><th></th><th></th></tr></thead><tbody><tr><td>类型</td><td>参数</td><td>说明</td></tr><tr><td>启动和禁用用户</td><td><strong>on</strong></td><td>激活某用户账号</td></tr><tr><td></td><td><strong>off</strong></td><td>禁用某用户账号。注意，已验证的连接仍然可以工作。如果默认用户被标记为off，则新连接将在未进行身份验证的情况下启动，并要求用户使用AUTH选项发送AUTH或HELLO，以便以某种方式进行身份验证。</td></tr><tr><td>权限的添加删除</td><td><strong>+<command></strong></td><td>将指令添加到用户可以调用的指令列表中</td></tr><tr><td></td><td><strong>-<command></strong></td><td>从用户可执行指令列表移除指令</td></tr><tr><td></td><td><strong>+@<category></strong></td><td>添加该类别中用户要调用的所有指令，有效类别为@admin、@set、@sortedset…等，通过调用ACL CAT命令查看完整列表。特殊类别@all表示所有命令，包括当前存在于服务器中的命令，以及将来将通过模块加载的命令。</td></tr><tr><td></td><td>-@<actegory></td><td>从用户可调用指令中移除类别</td></tr><tr><td></td><td><strong>allcommands</strong></td><td>+@all的别名</td></tr><tr><td></td><td><strong>nocommand</strong></td><td>-@all的别名</td></tr><tr><td>可操作键的添加或删除</td><td><strong>~<pattern></strong></td><td>添加可作为用户可操作的键的模式。例如~*允许所有的键</td></tr></tbody></table><p>（2）通过命令创建新用户默认权限<br>acl setuser user1<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730075555-fb2539f0-9a30-41cf-a945-db4f7b570a59.png#averageHue=%230c0906&id=hG7rS&originHeight=82&originWidth=295&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>在上面的示例中，我根本没有指定任何规则。如果用户不存在，这将使用just created的默认属性来创建用户。如果用户已经存在，则上面的命令将不执行任何操作。<br>（3）设置有用户名、密码、ACL权限、并启用的用户<br>acl setuser user2 on &gt;password ~cached:* +get<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730075866-dd1a0cfb-2d9d-4c28-9b53-ed1a51a031b1.png#averageHue=%23090604&id=R4oZ1&originHeight=127&originWidth=669&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>(4)切换用户，验证权限<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730076093-e51c4181-36eb-4d57-9f5a-f0eafdd9b50d.png#averageHue=%23070503&id=yITh8&originHeight=242&originWidth=673&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>IO多线程</strong><ol><li><strong>简介</strong></li></ol></li></ol><p>Redis6终于支撑多线程了，告别单线程了吗？<br>IO多线程其实指<strong>客户端交互部分</strong>的<strong>网络IO</strong>交互处理模块<strong>多线程</strong>，而非<strong>执行命令多线程</strong>。Redis6执行命令依然是单线程。</p><div class="code-wrapper"><pre><code class="hljs">  1. **原理架构**</code></pre></div><p>Redis 6 加入多线程,但跟 Memcached 这种从 IO处理到数据访问多线程的实现模式有些差异。Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH&#x2F;LPOP 等等的并发问题。整体的设计大体如下:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730076372-2cc09b37-398c-4e0c-87c5-b4aca4d719ba.png#averageHue=%2397a72b&id=zmIJm&originHeight=411&originWidth=656&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>另外，多线程IO默认也是不开启的，需要再配置文件中配置<br>io-threads-do-reads  yes<br>io-threads 4</p><ol><li><strong>工具支持 Cluster</strong></li></ol><p>之前老版Redis想要搭集群需要单独安装ruby环境，Redis 5 将 redis-trib.rb 的功能集成到 redis-cli 。另外官方 redis-benchmark 工具开始支持 cluster 模式了，通过多线程的方式对多个分片进行压测。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730076655-3a897056-f7ac-4c50-bd1b-ce082189a699.png#averageHue=%230d0a07&id=Phaot&originHeight=290&originWidth=673&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ol><li><strong>Redis新功能持续关注</strong></li></ol><p>Redis6新功能还有：<br>1、RESP3新的 Redis 通信协议：优化服务端与客户端之间通信<br>2、Client side caching客户端缓存：基于 RESP3 协议实现的客户端缓存功能。为了进一步提升缓存的性能，将客户端经常访问的数据cache到客户端。减少TCP网络交互。<br>3、Proxy集群代理模式：Proxy 功能，让 Cluster 拥有像单实例一样的接入方式，降低大家使用cluster的门槛。不过需要注意的是代理不改变 Cluster 的功能限制，不支持的命令还是不会支持，比如跨 slot 的多Key操作。<br>4、Modules API<br>Redis 6中模块API开发进展非常大，因为Redis Labs为了开发复杂的功能，从一开始就用上Redis模块。Redis可以变成一个框架，利用Modules来构建不同系统，而不需要从头开始写然后还要BSD许可。Redis一开始就是一个向编写各种系统开放的平台。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器那些事</title>
    <link href="/2024/01/26/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85%EF%BC%9F/"/>
    <url>/2024/01/26/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h1 id="1-服务器遭遇到挖矿程序！"><a href="#1-服务器遭遇到挖矿程序！" class="headerlink" title="1.服务器遭遇到挖矿程序！"></a>1.服务器遭遇到挖矿程序！</h1><p><a href="https://blog.csdn.net/qq_28513801/article/details/127890305">服务器遭到newinit.sh木马挖矿攻击记录_抛物线.的博客-CSDN博客</a><br><a href="https://blog.csdn.net/qq_47464056/article/details/125970479">阿里云服务器被挖矿的解决方法_阿里云被挖矿_Daryl179的博客-CSDN博客</a><br><a href="https://www.renfei.net/posts/1003501">Redis 未授权访问漏洞分析 cleanfda 脚本复现漏洞挖矿</a><br><a href="https://blog.51cto.com/u_13540373/4861152">redis如何设置密码_51CTO博客_redis设置账号密码</a><br>总结：<br>1.原因可能是没有设置redis的密码，并且注释了bind让其他人都可以随便连接redis<br>2.主要是ZZH和zzhs文件造成的，他们在&#x2F;etc目录下<br>3.lsattr用来显示文件属性，<a href="http://www.ha97.com/5172.html">（总结）Linux的chattr与lsattr命令详解</a>chattr可以改变文件属性<br>4.查看redis靠哪个配置文件启动：<br>a.启动redis-cli；b.输入info c.在server模块下查看config_flie,后面的就是启动的redis所依靠的配置文件</p><h1 id="2-Linux不小心用cat打开二进制文件显示乱码的解决方法？"><a href="#2-Linux不小心用cat打开二进制文件显示乱码的解决方法？" class="headerlink" title="2.Linux不小心用cat打开二进制文件显示乱码的解决方法？"></a>2.Linux不小心用cat打开二进制文件显示乱码的解决方法？</h1><p>1，直接输入reset就可以了</p><h1 id="修改host文件访问被DNS污染的网站："><a href="#修改host文件访问被DNS污染的网站：" class="headerlink" title="修改host文件访问被DNS污染的网站："></a>修改host文件访问被DNS污染的网站：</h1><p><a href="https://www.cnblogs.com/wangmaoling/p/6646460.html">修改host文件浏览国外网站 - 小兔额乖乖 - 博客园</a><a href="https://zhuanlan.zhihu.com/p/32234805">修改hosts访问外网</a></p><h1 id="3-ping"><a href="#3-ping" class="headerlink" title="3.ping"></a>3.ping</h1><p>ping后面跟的是域名，而域名不需要加http,https等协议了，不然会ping不出的。通过ping可以得知该域名的网站，但是如果ping的是被屏蔽的网站的话！那么ping出来的ip地址是错误的。</p>]]></content>
    
    
    <categories>
      
      <category>搞基</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web前端</title>
    <link href="/2024/01/26/web%E5%89%8D%E7%AB%AF%EF%BC%9A/"/>
    <url>/2024/01/26/web%E5%89%8D%E7%AB%AF%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h1 id="1-VScode的使用："><a href="#1-VScode的使用：" class="headerlink" title="1.VScode的使用："></a>1.VScode的使用：</h1><h2 id="如何快速生成HTML模板"><a href="#如何快速生成HTML模板" class="headerlink" title="如何快速生成HTML模板"></a>如何快速生成HTML模板</h2><p>输入！然后tab就可以快速生成html模板了</p><h1 id="绘制三角形："><a href="#绘制三角形：" class="headerlink" title="绘制三角形："></a>绘制三角形：</h1><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>1.<a href="https://blog.csdn.net/qq_44537625/article/details/100040169">display:flex(弹性盒子布局)详解_display: flex_羡阳公子的博客-CSDN博客</a><br>2.<a href="https://blog.csdn.net/weixin_44015669/article/details/115663156">CSS：N种使用CSS 绘制三角形的方法_三角形css_打瞌睡的兔兔小姐的博客-CSDN博客</a><a href="https://blog.csdn.net/hhhhhhhssss/article/details/119177898">【前端怪谈】两个行内块元素之间的间距问题_行内块元素间距问题_hhhhhhhssss的博客-CSDN博客</a><a href="https://zhuanlan.zhihu.com/p/160929003">css之div盒子居中常用方法大全</a></p><h1 id="2-如何在输入框前设置图片："><a href="#2-如何在输入框前设置图片：" class="headerlink" title="2.如何在输入框前设置图片："></a>2.如何在输入框前设置图片：</h1><p><a href="https://blog.csdn.net/heromps/article/details/112576867">input里面添加图片_input输入框添加图片_heromps的博客-CSDN博客</a></p><h2 id="输入框文本缩进的方法："><a href="#输入框文本缩进的方法：" class="headerlink" title="输入框文本缩进的方法："></a>输入框文本缩进的方法：</h2><p><strong>CSS中的text-indent属性可以实现：</strong>text-indent 属性规定文本块中首行文本的缩进。可以给改属性赋值px,百分比等，默认是0；<br>注释：允许使用负值。如果使用负值，那么首行会被缩进到左边。<br><a href="https://worktile.com/kb/p/24580">html的缩进属性介绍 • Worktile社区</a><br>3.Live Server是一款在vscode上面修改编码刷新界面就可以反馈在浏览器的插件</p><h1 id="第3次实验总结："><a href="#第3次实验总结：" class="headerlink" title="第3次实验总结："></a>第3次实验总结：</h1><h4 id="1-如何在无序列表的列表项下边生成下划线"><a href="#1-如何在无序列表的列表项下边生成下划线" class="headerlink" title="1.如何在无序列表的列表项下边生成下划线"></a>1.如何在无序列表的列表项下边生成下划线</h4><p>只需要设置无序列表项的下边框就可以了</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> &#123;<span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid black; <span class="hljs-comment">/* 设置下划线的宽度、样式和颜色 */</span>&#125;</code></pre></div><h4 id="2-js中动态生成的元素也受css的影响"><a href="#2-js中动态生成的元素也受css的影响" class="headerlink" title="2.js中动态生成的元素也受css的影响"></a>2.js中动态生成的元素也受css的影响</h4><h4 id="3-行内块元素，块元素，行元素的区别："><a href="#3-行内块元素，块元素，行元素的区别：" class="headerlink" title="3.行内块元素，块元素，行元素的区别："></a>3.行内块元素，块元素，行元素的区别：</h4><div class="code-wrapper"><pre><code class="hljs css">每个块级元素都是独自占一行；高度，行高，外边距（<span class="hljs-attribute">margin</span>）以及内边距（<span class="hljs-attribute">padding</span>）都可以控制；元素的宽度如果不设置的话，默认为父元素的宽度（父元素宽度<span class="hljs-number">100%</span>；多个块状元素标签写在一起，默认排列方式为从上至下一般作为容器使用</code></pre></div><div class="code-wrapper"><pre><code class="hljs stata">&lt;address&gt;  <span class="hljs-comment">// 定义地址 </span>&lt;caption&gt;  <span class="hljs-comment">// 定义表格标题 </span>&lt;dd&gt;      <span class="hljs-comment">// 定义列表中定义条目 </span>&lt;div&gt;     <span class="hljs-comment">// 定义文档中的分区或节 </span>&lt;dl&gt;    <span class="hljs-comment">// 定义列表 </span>&lt;dt&gt;     <span class="hljs-comment">// 定义列表中的项目 </span>&lt;fieldset&gt;  <span class="hljs-comment">// 定义一个框架集 </span>&lt;<span class="hljs-keyword">form</span>&gt;  <span class="hljs-comment">// 创建 HTML 表单 </span>&lt;h1&gt;    <span class="hljs-comment">// 定义最大的标题</span>&lt;h2&gt;    <span class="hljs-comment">// 定义副标题</span>&lt;h3&gt;     <span class="hljs-comment">// 定义标题</span>&lt;h4&gt;     <span class="hljs-comment">// 定义标题</span>&lt;h5&gt;     <span class="hljs-comment">// 定义标题</span>&lt;h6&gt;     <span class="hljs-comment">// 定义最小的标题</span>&lt;hr&gt;     <span class="hljs-comment">// 创建一条水平线</span>&lt;legend&gt;    <span class="hljs-comment">// 元素为 fieldset 元素定义标题</span>&lt;<span class="hljs-keyword">li</span>&gt;     <span class="hljs-comment">// 标签定义列表项目</span>&lt;noframes&gt;    <span class="hljs-comment">// 为那些不支持框架的浏览器显示文本，于 frameset 元素内部</span>&lt;noscript&gt;    <span class="hljs-comment">// 定义在脚本未被执行时的替代内容</span>&lt;ol&gt;     <span class="hljs-comment">// 定义有序列表</span>&lt;ul&gt;    <span class="hljs-comment">// 定义无序列表</span>&lt;p&gt;     <span class="hljs-comment">// 标签定义段落</span>&lt;pre&gt;     <span class="hljs-comment">// 定义预格式化的文本</span>&lt;<span class="hljs-keyword">table</span>&gt;     <span class="hljs-comment">// 标签定义 HTML 表格</span>&lt;tbody&gt;     <span class="hljs-comment">// 标签表格主体（正文）</span>&lt;td&gt;    <span class="hljs-comment">// 表格中的标准单元格</span>&lt;tfoot&gt;     <span class="hljs-comment">// 定义表格的页脚（脚注或表注）</span>&lt;th&gt;    <span class="hljs-comment">// 定义表头单元格</span>&lt;thead&gt;    <span class="hljs-comment">// 标签定义表格的表头</span>&lt;tr&gt;     <span class="hljs-comment">// 定义表格中的行</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs css">行内元素不可以设置宽（<span class="hljs-attribute">width</span>）和高（<span class="hljs-attribute">height</span>）,或者说设置了高宽无效不会独占一行，相邻的行内元素会排列在同一行里，直到一行排不下才会自动换行，其宽度随元素的内容而变化；高宽无效，对外边距（<span class="hljs-attribute">margin</span>）和内边距（<span class="hljs-attribute">padding</span>）仅设置左右方向有效 上下无效；设置行高有效，等同于给父级元素设置行高；元素的宽度就是它包含的文字或图片的宽度，不可改变；行内元素中不能放块级元素，<span class="hljs-selector-tag">a</span> 链接里面不能再放链接；</code></pre></div><div class="code-wrapper"><pre><code class="hljs oxygene">&lt;a&gt;     <span class="hljs-comment">// 标签可定义锚 </span>&lt;abbr&gt;     <span class="hljs-comment">// 表示一个缩写形式 </span>&lt;acronym&gt;     <span class="hljs-comment">// 定义只取首字母缩写 </span>&lt;b&gt;     <span class="hljs-comment">// 字体加粗 </span>&lt;bdo&gt;     <span class="hljs-comment">// 可覆盖默认的文本方向 </span>&lt;big&gt;     <span class="hljs-comment">// 大号字体加粗 </span>&lt;br&gt;     <span class="hljs-comment">// 换行 </span>&lt;cite&gt;     <span class="hljs-comment">// 引用进行定义 </span>&lt;code&gt;    <span class="hljs-comment">// 定义计算机代码文本</span>&lt;dfn&gt;     <span class="hljs-comment">// 定义一个定义项目</span>&lt;em&gt;     <span class="hljs-comment">// 定义为强调的内容</span>&lt;i&gt;     <span class="hljs-comment">// 斜体文本效果</span>&lt;kbd&gt;     <span class="hljs-comment">// 定义键盘文本</span>&lt;label&gt;     <span class="hljs-comment">// 标签为 input 元素定义标注（标记）</span>&lt;q&gt;     <span class="hljs-comment">// 定义短的引用</span>&lt;samp&gt;     <span class="hljs-comment">// 定义样本文本</span>&lt;<span class="hljs-keyword">select</span>&gt; <span class="hljs-comment">// 创建单选或多选菜单</span>&lt;small&gt;     <span class="hljs-comment">// 呈现小号字体效果</span>&lt;span&gt;     <span class="hljs-comment">// 组合文档中的行内元素</span>&lt;<span class="hljs-keyword">strong</span>&gt; <span class="hljs-comment">// 加粗</span>&lt;sub&gt;     <span class="hljs-comment">// 定义下标文本</span>&lt;sup&gt;     <span class="hljs-comment">// 定义上标文本</span>&lt;textarea&gt;     <span class="hljs-comment">// 多行的文本输入控件</span>&lt;tt&gt;     <span class="hljs-comment">// 打字机或者等宽的文本效果</span>&lt;<span class="hljs-keyword">var</span>&gt;    <span class="hljs-comment">// 定义变量</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs qml">高度、行高、外边距以及内边距都可以控制；默认宽度就是它本身内容的宽度，不独占一行，但是之间会有空白缝隙，设置它上一级的 <span class="hljs-built_in">font</span>-<span class="hljs-built_in">size</span> 为 <span class="hljs-number">0</span>，才会消除间隙；</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-section">&lt;button&gt;</span> <span class="hljs-section">&lt;input&gt;</span>   <span class="hljs-section">&lt;textarea&gt;</span> <span class="hljs-section">&lt;select&gt;</span> <span class="hljs-section">&lt;img&gt;</span></code></pre></div><h4 id="4-ul元素和li元素之间是有一定的间隔的，去掉他们之间间隙的方法："><a href="#4-ul元素和li元素之间是有一定的间隔的，去掉他们之间间隙的方法：" class="headerlink" title="4.ul元素和li元素之间是有一定的间隔的，去掉他们之间间隙的方法："></a>4.ul元素和li元素之间是有一定的间隔的，去掉他们之间间隙的方法：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695973720293-633d2c10-4755-4ea9-b58e-4a3a872fd229.png#averageHue=%23fcf9f6&clientId=u09562b73-ac0f-4&from=paste&height=268&id=u231ef2a4&originHeight=335&originWidth=506&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=13386&status=done&style=none&taskId=ua14eb321-7cef-4b76-9cd2-d8935def6ae&title=&width=404.8" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span>&#123;<span class="hljs-attribute">margin-left</span>:-<span class="hljs-number">50px</span>;&#125;//利用<span class="hljs-attribute">margin</span>负数左移原理对齐，但是不建议。</code></pre></div><div class="code-wrapper"><pre><code class="hljs css">//其实这里的<span class="hljs-selector-tag">li</span>可以看出是<span class="hljs-selector-tag">ul</span>元素中的内容，浏览器默认设置了它与<span class="hljs-selector-tag">li</span>之间的左<span class="hljs-attribute">padding</span>;只有我们手动把<span class="hljs-attribute">padding</span>设置为<span class="hljs-number">0</span>就可以解决你。<span class="hljs-selector-tag">ul</span>&#123;<span class="hljs-attribute">padding</span>:<span class="hljs-number">0px</span>;&#125;</code></pre></div><h4 id="5-去除行内块元素之间的空格："><a href="#5-去除行内块元素之间的空格：" class="headerlink" title="5.去除行内块元素之间的空格："></a>5.去除行内块元素之间的空格：</h4><p>浏览器处理空格的规则：文字的前部和后部的空格都会忽略，内部的连续空格只会算作一个。浏览器会自动把换行符号转成普通的空格键。<br>white-space ：是css针对浏览器对应空格处理的方法。<br>产生原因：html文档中标签与标签之间有换行符和空格，而这些会被解析为文本节点，其中换行符被解析为1个空格，多个连续的空格会被解析为1个空格。这些空格的文本节点在行之间会占据一定的空间的，因此在行内元素和行内块元素之间会有空格，这空格的参数是因为这些标签之间的换行符和空格产生的。<br>消除方法：<br>例子：</p><div class="code-wrapper"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">child1</span>&quot;&gt;<span class="hljs-symbol">child1</span>&lt;/<span class="hljs-symbol">div</span>&gt;    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">child2</span>&quot;&gt;<span class="hljs-symbol">child2</span>&lt;/<span class="hljs-symbol">div</span>&gt;&lt;/<span class="hljs-symbol">div</span>&gt;</code></pre></div><p>方法1：把这些标签紧密书写，让其中没有换行符号和空格</p><div class="code-wrapper"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">child1</span>&quot;&gt;<span class="hljs-symbol">child1</span>&lt;/<span class="hljs-symbol">div</span>&gt;&lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">child2</span>&quot;&gt;<span class="hljs-symbol">child2</span>&lt;/<span class="hljs-symbol">div</span>&gt;&lt;/<span class="hljs-symbol">div</span>&gt;</code></pre></div><p>方法2：使用margin为负值移动特定的元素（不建议）</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.child2</span> &#123;    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">5px</span>;&#125;</code></pre></div><p>方法3：空格也是文本的一种可以在其父节点设置font-size: 0,这样就会让子元素中的文字不会显示，同理想要在标签当中的文本也不会显示，这个时候我们在额外设置子标签中的文本大小就可以了</p><div class="code-wrapper"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;    font-size: <span class="hljs-number">0</span>;&#125;.child1, .child2 &#123;    font-size: <span class="hljs-number">14</span>px;&#125;</code></pre></div><p>方法4：既然是有标签之间的换行符和空格产生的，我们可以在这之间添加一个不会显示在浏览器上的内容占据换行符和空格就好了。没错这种内容就是注释。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;Resolve Resolve5&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>左侧行内元素<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-comment">&lt;!-- 消除行内元素换行导致的空白</span><span class="hljs-comment"></span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>右侧行内元素<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>方法5：使用负的文字间距（letter-spacing）。通过将行内元素和行内块元素之间的文字间距设为负值，同样可以达到移除空白间距的效果。<br>方法6：使用float</p><h4 id="CSS中的float属性："><a href="#CSS中的float属性：" class="headerlink" title="CSS中的float属性："></a>CSS中的float属性：</h4><p><a href="https://juejin.cn/post/6844903616155746312">CSS 深入理解之 float 浮动 - 掘金</a><br><a href="https://segmentfault.com/a/1190000016153055">滑动验证页面</a><br>1.浮动的概念：就是一个元素脱离了标准流，然后在原本的位置浮起来了（第一个浮起来的元素在本行，后面的可能会紧跟前面浮动元素的行）。其后的块级元素会移动占据浮动元素原来的位置，其中块级元素里面的内容不会占据浮动元素原来的位置，而是环绕它<br>2.特性：包裹性：包裹指的是一个浮动元素，如果子元素宽度足够小，则浮动元素的宽度就是该子元素的宽度。<br>自适应指的是如果浮动元素的父元素有设置宽度，并且浮动元素的子元素宽度超出了父元素，则浮动元素的宽度最终表现为父元素的宽度；<br>破坏性：浮动元素会让父元素发生高度塌陷。也就是父元素的高度为0（父元素没有边框的情况，有边框的话高度在边框的1~2倍之间）<br>块状化：一旦元素float的属性不为none，则其display计算值就是block或者table。这里的块状化意思是可以像block元素一样设置宽和高，并不是真正的块元素。<br>没有任何的margin重叠：也就是说上下左右两个浮动元素之间的大小是其各自元素设置的margin之和。</p><h4 id="清除浮动："><a href="#清除浮动：" class="headerlink" title="清除浮动："></a>清除浮动：</h4><p>1.清除元素只是清除元素自身的浮动效果，没有浮动的元素也可以清除浮动。清除浮动是让<strong>元素盒子的边不能和前面的浮动元素相邻。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695989142535-5930cc04-db98-4143-80f3-e74d6b566892.png#averageHue=%23edece6&clientId=u09562b73-ac0f-4&from=paste&height=381&id=u3ede46a3&originHeight=476&originWidth=1091&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=295486&status=done&style=none&taskId=ued3eb689-8ac2-45a3-b9ef-19cf61840b3&title=&width=872.8" alt="image.png"><br>上面的clear:left表示该元素的左边不能有浮动元素存在。clear:right表示该元素右边不能有浮动元素，clear:both表示该元素的左右都不能有浮动元素。<br>2.使用伪类元素清除：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695989985378-4fde44d2-ee10-42e9-8367-6af06fe74cfd.png#averageHue=%23f6f5f4&clientId=u09562b73-ac0f-4&from=paste&height=171&id=u37b1cdc3&originHeight=214&originWidth=470&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=11705&status=done&style=none&taskId=ubc4bfcc2-ac48-4a6b-853a-61e19481582&title=&width=376" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695989991357-02c5c0d3-447d-493c-b92b-3b99576ce4fc.png#averageHue=%23f4f3f3&clientId=u09562b73-ac0f-4&from=paste&height=211&id=ub857d9f9&originHeight=264&originWidth=323&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=7547&status=done&style=none&taskId=ud2261c90-d4e4-45c6-b997-3d9b84e41ef&title=&width=258.4" alt="image.png"><br>这里的.clearfix:after::after 是 CSS 中的一种特殊选择器，它可以在选中的元素的末尾插入一个虚拟的子元素。这个虚拟的子元素可以用于添加样式、内容或进行其他操作。</p><h4 id="导航栏的书写："><a href="#导航栏的书写：" class="headerlink" title="导航栏的书写："></a>导航栏的书写：</h4><p>给每一个导航栏设置一个index属性，然后获取所有相应的div元素，利用排他算法，想把其他设置为空，然后在设置特定的结果。</p><div class="code-wrapper"><pre><code class="hljs css">&lt;!DOCTYPE <span class="hljs-selector-tag">html</span>&gt;&lt;<span class="hljs-selector-tag">html</span> lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-<span class="hljs-number">8</span>&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; <span class="hljs-attribute">content</span>=&quot;IE=edge&quot;&gt;&lt;meta name=&quot;viewport&quot; <span class="hljs-attribute">content</span>=&quot;<span class="hljs-attribute">width</span>=device-<span class="hljs-attribute">width</span>, initial-scale=<span class="hljs-number">1.0</span>&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;style&gt;* &#123;<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">box-sizing</span>: border-box;&#125;<span class="hljs-selector-class">.table</span> &#123;<span class="hljs-attribute">width</span>: <span class="hljs-number">600px</span>;<span class="hljs-attribute">height</span>: <span class="hljs-number">600px</span>;<span class="hljs-attribute">margin</span>: <span class="hljs-number">100px</span> auto;&#125;<span class="hljs-selector-class">.table_title</span> &#123;<span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#000</span>;&#125;<span class="hljs-selector-class">.table_title</span> <span class="hljs-selector-tag">ul</span> &#123;<span class="hljs-attribute">display</span>: flex;<span class="hljs-attribute">text-align</span>: center;<span class="hljs-attribute">color</span>:<span class="hljs-number">#fff</span>;&#125;<span class="hljs-selector-class">.table_title</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> &#123;<span class="hljs-attribute">list-style</span>: none;<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>;<span class="hljs-attribute">line-height</span>: <span class="hljs-number">30px</span>;&#125;<span class="hljs-selector-class">.p1</span> <span class="hljs-selector-tag">ul</span>&#123;    <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">list-style</span>: none;&#125;<span class="hljs-selector-class">.p1</span> <span class="hljs-selector-tag">li</span>&#123;    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> dashed gray;    <span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>;    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">30px</span>;&#125;<span class="hljs-selector-class">.hong</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#aaa</span>;&#125;&lt;/style&gt;&lt;/head&gt;&lt;<span class="hljs-selector-tag">body</span>&gt;&lt;<span class="hljs-selector-tag">div</span> class=&quot;<span class="hljs-selector-tag">table</span>&quot;&gt;    &lt;<span class="hljs-selector-tag">div</span> class=&quot;table_title&quot;&gt;        &lt;<span class="hljs-selector-tag">ul</span>&gt;            &lt;<span class="hljs-selector-tag">li</span> class=&quot;hong&quot; &gt;热门排行&lt;/<span class="hljs-selector-tag">li</span>&gt;            &lt;<span class="hljs-selector-tag">li</span> &gt;美图速递&lt;/<span class="hljs-selector-tag">li</span>&gt;            &lt;<span class="hljs-selector-tag">li</span>&gt;前沿科技&lt;/<span class="hljs-selector-tag">li</span>&gt;        &lt;/<span class="hljs-selector-tag">ul</span>&gt;    &lt;/<span class="hljs-selector-tag">div</span>&gt;    &lt;<span class="hljs-selector-tag">div</span> class=&quot;table_content&quot;&gt;        &lt;<span class="hljs-selector-tag">div</span> style=&quot;<span class="hljs-attribute">display</span>:block;&quot; class=&quot;p1&quot;&gt;            &lt;<span class="hljs-selector-tag">ul</span>&gt;                &lt;<span class="hljs-selector-tag">li</span>&gt;习近平出席推进“一带一路”建设工作<span class="hljs-number">5</span>周年座谈会&lt;/<span class="hljs-selector-tag">li</span>&gt;                &lt;<span class="hljs-selector-tag">li</span>&gt;中共时隔接近三年再修党纪条例子&amp;nbsp;这些高压线不能碰&lt;/<span class="hljs-selector-tag">li</span>&gt;                &lt;<span class="hljs-selector-tag">li</span>&gt;全国高中<span class="hljs-number">2019</span>年秋季起分步实施新课程使用新教材&lt;/<span class="hljs-selector-tag">li</span>&gt;                &lt;<span class="hljs-selector-tag">li</span>&gt;个税法修正草案将二申&amp;nbsp;起征点会否超<span class="hljs-number">5000</span>元?&lt;/<span class="hljs-selector-tag">li</span>&gt;                &lt;/<span class="hljs-selector-tag">ul</span>&gt;        &lt;/<span class="hljs-selector-tag">div</span>&gt;        &lt;<span class="hljs-selector-tag">div</span> class=&quot;p1&quot; hidden&gt;            &lt;<span class="hljs-selector-tag">ul</span>&gt;                &lt;<span class="hljs-selector-tag">li</span>&gt;鹅教官,羊陪练......这所中学养的动物成了“网红”&lt;/<span class="hljs-selector-tag">li</span>&gt;                &lt;<span class="hljs-selector-tag">li</span>&gt;最伤身体的<span class="hljs-number">10</span>个生活习惯,一定要避开&lt;/<span class="hljs-selector-tag">li</span>&gt;                &lt;<span class="hljs-selector-tag">li</span>&gt;<span class="hljs-number">12</span>岁孩子带着父亲去西藏&amp;nbsp;吃住行自己拿主义&lt;/<span class="hljs-selector-tag">li</span>&gt;                &lt;<span class="hljs-selector-tag">li</span>&gt;<span class="hljs-number">16</span>岁男孩暑假干了俩月工地,练出满是肌肉,只为赚学费&lt;/<span class="hljs-selector-tag">li</span>&gt;                &lt;/<span class="hljs-selector-tag">ul</span>&gt;        &lt;/<span class="hljs-selector-tag">div</span>&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;&lt;script&gt;        <span class="hljs-selector-tag">var</span> lis = document<span class="hljs-selector-class">.querySelector</span>(&#x27;<span class="hljs-selector-class">.table_title</span>&#x27;)<span class="hljs-selector-class">.querySelectorAll</span>(&#x27;<span class="hljs-selector-tag">li</span>&#x27;);        <span class="hljs-selector-tag">var</span> divs = document<span class="hljs-selector-class">.querySelector</span>(&#x27;<span class="hljs-selector-class">.table_content</span>&#x27;)<span class="hljs-selector-class">.querySelectorAll</span>(&#x27;<span class="hljs-selector-tag">div</span>&#x27;);        for(<span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">i</span> = <span class="hljs-number">0</span>; <span class="hljs-selector-tag">i</span> &lt; lis<span class="hljs-selector-class">.length</span>; <span class="hljs-selector-tag">i</span>++) &#123;        lis<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.setAttribute</span>(&#x27;index&#x27;,<span class="hljs-selector-tag">i</span>);        lis<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.onmouseover</span> = function() &#123;        for(<span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">i</span> = <span class="hljs-number">0</span>; <span class="hljs-selector-tag">i</span> &lt; lis<span class="hljs-selector-class">.length</span>; <span class="hljs-selector-tag">i</span>++) &#123;        lis<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.className</span> = &#x27;&#x27;;        &#125;        <span class="hljs-selector-tag">var</span> index = this<span class="hljs-selector-class">.getAttribute</span>(&#x27;index&#x27;);        this<span class="hljs-selector-class">.className</span> = &#x27;hong&#x27;;        for(<span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">i</span> = <span class="hljs-number">0</span>;<span class="hljs-selector-tag">i</span> &lt; divs<span class="hljs-selector-class">.length</span>; <span class="hljs-selector-tag">i</span>++)&#123;        divs<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.style</span><span class="hljs-selector-class">.display</span> = &#x27;<span class="hljs-attribute">none</span>&#x27;;        &#125;        divs<span class="hljs-selector-attr">[index]</span><span class="hljs-selector-class">.style</span><span class="hljs-selector-class">.display</span> = &#x27;block&#x27;;        &#125;        &#125;&lt;/script&gt;&lt;/<span class="hljs-selector-tag">body</span>&gt;&lt;/<span class="hljs-selector-tag">html</span>&gt;</code></pre></div><p>localstory:<br><a href="https://juejin.cn/post/7149380173027573767">前端本地存储之LocalStorage - 掘金</a><br><a href="https://so.csdn.net/so/search?q=localStorage&spm=1001.2101.3001.7020">localStorage</a>存取数组和对象不像存取字符串那样，<strong>需要序列化和反序列化</strong></p><div class="code-wrapper"><pre><code class="hljs java">rolePower=[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]存：localStorage.setItem(<span class="hljs-string">&#x27;rolePower&#x27;</span>,JSON.stringify(rolePower))取：JSON.parse(localStorage.getItem(<span class="hljs-string">&quot;rolePower&quot;</span>))<span class="hljs-keyword">var</span> userNews=&#123;id: <span class="hljs-string">&quot;aa&quot;</span>, userId: <span class="hljs-string">&quot;1234&quot;</span>, loginName: <span class="hljs-string">&quot;test&quot;</span>, name: <span class="hljs-string">&quot;测试&quot;</span>, orgId: <span class="hljs-string">&quot;1001&quot;</span>&#125;存：localStorage.setItem(<span class="hljs-string">&#x27;user&#x27;</span>,JSON.stringify(userNews))取：JSON.parse(localStorage.getItem(<span class="hljs-string">&quot;user&quot;</span>))</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>课程作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Curl用法</title>
    <link href="/2024/01/26/SpringSecurity/"/>
    <url>/2024/01/26/SpringSecurity/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-curl"><a href="#1-curl" class="headerlink" title="1.curl::"></a>1.curl::</h1><p><a href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html">curl 的用法指南 - 阮一峰的网络日志</a><br>1.用curl访问本地的请求的时候要加上请求协议（本地window的命令行访问的时候）：<br>例子：其中的http：&#x2F;&#x2F;不能省略<br> curl <a href="http://localhost:8080/student/query">http://localhost:8080/student/query</a><br>但是在git的命令行访问可以不用添加请求协议。<br>2.gitBash中的curl和window命令行的区别：</p><div class="code-wrapper"><pre><code class="hljs powershell">在 Windows 上，<span class="hljs-built_in">curl</span> 命令实际上是 PowerShell的一个别名，它调用的是 <span class="hljs-built_in">Invoke-WebRequest</span> 命令，而不是真正的 <span class="hljs-built_in">curl</span> 程序。<span class="hljs-built_in">Invoke-WebRequest</span> 命令的语法和参数与 <span class="hljs-built_in">curl</span> 不完全相同，所以您的命令会报错。•  在 Git Bash 上，<span class="hljs-built_in">curl</span> 命令是真正的 <span class="hljs-built_in">curl</span> 程序，它是一个跨平台的命令行工具，用于传输数据。<span class="hljs-built_in">curl</span> 程序的语法和参数与您的命令相匹配，所以您的命令可以正常运行。</code></pre></div><p>-XPOST和-XGET指定请求的方式。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694611548130-acaa0438-e465-43cf-9d6e-b35ddf3d401b.png#averageHue=%23728c79&clientId=ucef60b48-7be3-4&from=paste&height=656&id=u2eb4139f&originHeight=820&originWidth=1485&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=952125&status=done&style=none&taskId=u21b5a8d2-b91a-45e1-a58e-d3200307ccb&title=&width=1188" alt="image.png"><br>UUID:</p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-type">UUID</span>是指通用唯一标识符（Universally <span class="hljs-keyword">Unique</span> Identifier）或称为GUID（Globally <span class="hljs-keyword">Unique</span> Identifier）。它是一个标准化的标识符，用于在计算系统中唯一地标识实体或对象。<span class="hljs-type">UUID</span>是由<span class="hljs-number">128</span>位数字组成的字符串，通常以<span class="hljs-number">32</span>个十六进制数字的形式表示，按照特定的格式进行排列。每个<span class="hljs-type">UUID</span>都可以被认为是在全球范围内唯一的，尽管实际上存在极其低的碰撞概率。<span class="hljs-type">UUID</span>的生成过程基于一组算法和标识符来源，以确保生成的标识符在理论上是唯一的。它不依赖于中央机构的注册或分配过程，因此可以在分布式系统中独立地生成。<span class="hljs-type">UUID</span>的主要用途是在分布式系统中唯一标识对象。例如，在数据库中，可以使用<span class="hljs-type">UUID</span>作为主键来确保每个实体具有唯一的标识符。它还广泛用于各种应用程序和领域，如软件开发、网络通信、数据同步等。</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694611975024-e22777d3-736b-42d1-a1b0-b8f23abbf6c9.png#averageHue=%233b3b46&clientId=ucef60b48-7be3-4&from=paste&height=93&id=u778f921a&originHeight=116&originWidth=1317&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=162042&status=done&style=none&taskId=ue348014f-836a-4523-a40e-7febda6c3a9&title=&width=1053.6" alt="image.png"><br>加入了spring-security安全框架，访问页面就被保护起来了。<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694612139027-475c4264-3b91-41c9-beec-21517b5bb4e9.png#averageHue=%23030405&clientId=ucef60b48-7be3-4&from=paste&height=281&id=uc6d4130a&originHeight=351&originWidth=1527&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=231037&status=done&style=none&taskId=u63bc6ef0-4af5-4138-9991-8767d6c69d8&title=&width=1221.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694612446560-8eada2e0-cef8-47e5-94ae-d08b6f6d42c7.png#averageHue=%23282c35&clientId=ucef60b48-7be3-4&from=paste&height=280&id=ufc7c12f3&originHeight=350&originWidth=652&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=152507&status=done&style=none&taskId=u062b6340-befd-4f79-a366-c0d53cfa94c&title=&width=521.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694612865502-c58620f8-c264-4197-9d34-8a49b0df53a0.png#averageHue=%233d5456&clientId=ucef60b48-7be3-4&from=paste&height=708&id=u9b6f0a37&originHeight=885&originWidth=1558&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=1029390&status=done&style=none&taskId=u11084b65-c03f-4c9a-90f3-4e4be8a1a97&title=&width=1246.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694616557090-266184b9-b2ef-4375-be84-574f9b54383e.png#averageHue=%232e343e&clientId=ucef60b48-7be3-4&from=paste&height=126&id=ud95cc5fe&originHeight=157&originWidth=775&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=131346&status=done&style=none&taskId=u8ead350c-a6f1-40dd-b8a0-162b08df9f2&title=&width=620" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694614826396-0d55c071-9b60-4b15-bbe7-ede5250a0147.png#averageHue=%232c3039&clientId=ucef60b48-7be3-4&from=paste&height=122&id=u626669b0&originHeight=153&originWidth=1034&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=169538&status=done&style=none&taskId=u1873c44d-b5b8-411b-9b4a-ec31fcf5062&title=&width=827.2" alt="image.png"><br>（上图最终返回的是一个user对象，如果没有使用UserDetails的方法，就会更加默认或者配置文件来创建user.这种方法创建的user不需要加密器。如果是使用UserDetails注入依赖的方式创建user的时候，创建user的方法要传入一个加密器，这个时候就需要往容器中注入加密器Bean）<br>选中一个类或者接口按住ctrl+H可以查看该类或接口的层次结构。<br>2.<br>InMemoryUserDetailsManager manager&#x3D;new InMemoryUserDetailsManager();<br>manager.createUser(user1);<br>上面的代码是在内存中创建一个user1新用户</p><div class="code-wrapper"><pre><code class="hljs">通过InMemoryUserDetailsManager对象可以在内存中添加、删除和查询用户的身份验证和授权信息。该方法常用于演示和测试中。并非持久性的实现。</code></pre></div><p>MD5等一些加密算法是单向的，也就是无法通过密文解析出明文。同样的明文经过MD5的加密得到的密文是不一样的。但是可以通过passwordEncoder.matches方法匹配成功。<br>@Slf4j<br>@Slf4j 是一个 Lombok 的注解，它用于为类生成一个日志对象，通常命名为 log 。这个日志对象是使用 SLF4J 接口创建的，可以与不同的日志框架（例如 Log4j、Logback 等）兼容。使用 @Slf4j 注解可以省去手动声明和初始化日志对象的代码，简化了日志输出的操作。例如，您可以在类上添加 @Slf4j 注解，然后在方法中使用 log.info(“Hello World”) 来输出日志信息。<a href="http://www.slf4j.org/https://www.baeldung.com/slf4j-with-log4j2-logback">http://www.slf4j.org/https://www.baeldung.com/slf4j-with-log4j2-logback</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694666072395-fb1b672c-32a4-4c6e-ba76-7e85592ab3ee.png#averageHue=%23728666&clientId=ub7726463-2cc9-4&from=paste&height=278&id=uf5ecd589&originHeight=347&originWidth=1062&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=339701&status=done&style=none&taskId=ub3f3b95e-bccb-4304-8ba3-b67365677d1&title=&width=849.6" alt="image.png"><br>•  当您同时使用 roles() 和 authorities() 方法来为用户分配角色和权限时，Spring Security 会将它们合并成一个 GrantedAuthority 的集合，并赋值给用户的 authorities 属性。但是，如果您在 authorities() 方法中指定了一个以 ROLE_ 开头的权限，那么它会与 roles() 方法中指定的角色发生冲突，导致后者被覆盖。<a href="https://howtodoinjava.com/spring-security/spring-boot-role-based-authorization/https://dev.inherency.net/2020/01/spring-security-authority-vs-role.html">https://howtodoinjava.com/spring-security/spring-boot-role-based-authorization/https://dev.inherency.net/2020/01/spring-security-authority-vs-role.html</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694669694506-0d890d45-2575-4224-bd23-5b1c2616c45d.png#averageHue=%23faf9f9&clientId=ub7726463-2cc9-4&from=paste&height=350&id=u97e2f114&originHeight=437&originWidth=1412&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=50266&status=done&style=none&taskId=uc5125ea6-8de9-4b59-b7a4-c0f6b9d3b2d&title=&width=1129.6" alt="image.png"><br> @EnableGlobalMethodSecurity(prePostEnabled &#x3D; true) 是一个 Spring Security 的注解，它用于开启全局的方法级别的安全控制。这个注解的 prePostEnabled 属性表示是否启用 Spring Security 的 pre post 注解，例如 @PreAuthorize 和 @PostAuthorize，这些注解可以在方法执行前后进行权限检查和决策。<a href="https://www.baeldung.com/spring-enablemethodsecurityhttps://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/config/annotation/method/configuration/EnableGlobalMethodSecurity.html">https://www.baeldung.com/spring-enablemethodsecurityhttps://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/config/annotation/method/configuration/EnableGlobalMethodSecurity.html</a></p><p>例如，您可以在您的 Controller 类上添加 @EnableGlobalMethodSecurity(prePostEnabled &#x3D; true) 注解，然后在您的方法上添加 @PreAuthorize(“hasAuthority(‘admin’)”) 注解，这样就可以限制只有拥有 admin 权限的用户才能访问该方法。<a href="https://stackoverflow.com/questions/74910066/enableglobalmethodsecurity-is-deprecated-in-the-new-spring-boot-3-0">https://stackoverflow.com/questions/74910066/enableglobalmethodsecurity-is-deprecated-in-the-new-spring-boot-3-0</a></p><p>需要注意的是，@EnableGlobalMethodSecurity 注解已经在 Spring Security 5.6 版本中被废弃，取而代之的是 @EnableMethodSecurity 注解，它提供了更灵活的方式来配置不同类型的方法安全控制。<a href="https://blog.csdn.net/niugang0920/article/details/90516898">https://blog.csdn.net/niugang0920/article/details/90516898</a></p><h2 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h2><h2 id="private-ObjectMapper-objectMapper"><a href="#private-ObjectMapper-objectMapper" class="headerlink" title="private ObjectMapper objectMapper;"></a>private ObjectMapper objectMapper;</h2><p>ObjectMapper 是一个 Jackson 库中的类，它用于读写 JSON 数据，可以将 Java 对象和 JSON 字符串相互转换。@Resource 注解是一个 Java EE 标准的注解，它用于指定要注入的资源的名称或类型，可以与 Spring 框架的自动装配功能配合使用</p><h2 id="Builder"><a href="#Builder" class="headerlink" title="@Builder:"></a>@Builder:</h2><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-meta">@Builder 是一个 Lombok 注解，用于自动生成构建器模式的代码。通过在类上添加 @Builder 注解，可以自动生成一个内部静态类（Builder 类），该类提供了一种更简洁的方式来创建类的实例。</span>使用 <span class="hljs-meta">@Builder 注解后，Lombok 会自动生成以下内容：</span>内部静态类（Builder 类）：生成一个内部静态类，该类具有与目标类相同的字段，并提供链式调用的方法来设置这些字段的值。构建器方法：在目标类中生成一个静态方法，该方法返回 Builder 类的实例，用于创建目标类的对象。链式调用方法：在 Builder 类中生成用于设置字段值的方法，这些方法返回 Builder 类的实例本身，以支持链式调用。使用 <span class="hljs-meta">@Builder 注解可以简化创建对象的过程，不再需要手动编写繁琐的构造方法或使用大量的 setXxx</span>() 方法来设置字段的值。以下是一个示例：<span class="hljs-keyword">import</span> lombok.Builder;<span class="hljs-keyword">import</span> lombok.Getter;<span class="hljs-meta">@Getter</span><span class="hljs-meta">@Builder</span><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name;    <span class="hljs-keyword">private</span> int age;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> address;&#125;<span class="hljs-comment">// 在其他地方使用</span>Person person = Person.builder()    .name(<span class="hljs-string">&quot;John&quot;</span>)    .age(<span class="hljs-number">25</span>)    .address(<span class="hljs-string">&quot;123 Main St&quot;</span>)    .build();在上述示例中，<span class="hljs-meta">@Builder 注解为 Person 类生成了一个内部的 Builder 类。然后，通过链式调用的方式</span>设置字段的值，并使用 build() 方法创建了一个 Person 对象。总结：<span class="hljs-meta">@Builder 是一个 Lombok 注解，用于自动生成构建器模式的代码，简化创建对象的过程。它生</span>成一个内部静态的 Builder 类，提供了链式调用的方式来设置字段的值，并最终创建目标类的对象。</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694680461972-efed5e42-bcf1-443a-aacc-f4c26162c6fd.png#averageHue=%23675237&clientId=ub7726463-2cc9-4&from=paste&height=309&id=u41ceb554&originHeight=386&originWidth=1094&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=304835&status=done&style=none&taskId=u5d30fe76-3db5-4cf0-97fe-8ce3b230223&title=&width=875.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694680761541-17242a60-0ef6-4325-b203-d106f2f52611.png#averageHue=%23d6e2e2&clientId=ub7726463-2cc9-4&from=paste&height=69&id=ua6cf48e5&originHeight=86&originWidth=760&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=40420&status=done&style=none&taskId=ua74bd619-4dee-4ce9-a721-3e06127c0f7&title=&width=608" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-comment">//这里使用@SpringBootTest的原因是：该注解会</span><span class="hljs-comment">//    启动整个应用程序上下文：@SpringBootTest 注解会加载完整的 Spring 应用程序上下文，包括所有的配置、组件和依赖。</span><span class="hljs-comment">//    这样就不用自己去解决相关依赖问题了，比如下面的测试：就需要 SysUser对象，如果没有在springboot的环境下测试</span><span class="hljs-comment">//    那么SysUserServiceImpl类下的SysUserDao无法在整个测试环境中创建，自然就会报空指针异常了。如果在springboot</span><span class="hljs-comment">//    环境下测试，那SysUserDao的实例管理就交给了IOC了</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">SysUserServiceImplTest</span> &#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> SysUserService sysUserService;    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">getByUserName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">SysUser</span> <span class="hljs-variable">sysUser</span> <span class="hljs-operator">=</span> sysUserService.getByUserName(<span class="hljs-string">&quot;dddd&quot;</span>);        assertNull(sysUser);    &#125;&#125;</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694684945700-15b02ed7-5cfe-4952-8feb-89c47d9c5f3d.png#averageHue=%234d5e53&clientId=ub7726463-2cc9-4&from=paste&height=337&id=ud23eaca0&originHeight=421&originWidth=1297&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=439342&status=done&style=none&taskId=u9e8f1480-cce6-4a1f-9de5-b6e82df3513&title=&width=1037.6" alt="image.png">安全上下文获取的认证信息是实现了UserDetails接口的类，如果自己没有覆盖就是系统默认的User类，否则为自己配置的实现类。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694685496426-558cb20c-72f8-44d9-b6fe-4a8dc0b90acc.png#averageHue=%233c4657&clientId=ub7726463-2cc9-4&from=paste&height=150&id=ub30cdf13&originHeight=188&originWidth=406&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=75636&status=done&style=none&taskId=u19e048ed-406f-4170-bf53-87c57bee712&title=&width=324.8" alt="image.png"><br>10开始看源码<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694687888251-384842e9-9568-4b64-a3c9-a825cc17eb1c.png#averageHue=%23654a36&clientId=ub7726463-2cc9-4&from=paste&height=134&id=ua894d2d6&originHeight=167&originWidth=1125&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=135532&status=done&style=none&taskId=u4945c0dd-addd-4efc-9d89-25c21c714c4&title=&width=900" alt="image.png"><br>验证码的好处：一定程度上防止别人利用for循环脚本破解密码。<br>@ConfigurationProperties(prefix &#x3D; “spring.security”) 是一个 Spring Boot 的注解，它用于将配置文件中的属性绑定到一个 Java 类中的字段。这个注解的 prefix 属性指定了属性的前缀，也就是配置文件中的键的公共部分。<br>@EnableGlobalMethodSecurity(prePostEnabled &#x3D; true)用于开启全局的方法级别的安全控制。这个注解的 prePostEnabled 属性表示是否启用 Spring Security 的 pre post 注解，例如 @PreAuthorize 和 @PostAuthorize，这些注解可以在方法执行前后进行权限检查和决策。在 Spring Security 5.6 版本中被废弃，取而代之的是 @EnableMethodSecurity 注解<br>ObjectMapper 是一个 Jackson 库中的类，它用于读写 JSON 数据，可以将 Java 对象和 JSON 字符串相互转换。<br> map-underscore-to-camel-case: true 这个键用于指定 MyBatis 是否开启驼峰命名法的转换<br><a href="https://zhuanlan.zhihu.com/p/112244547">MyBatis中 #{} 和 ${} 区别</a><br>安全上下文（SecurityContext）是一个接口，它定义了与当前执行线程关联的最小安全信息。安全上下文存储在SecurityContextHolder中，可以通过SecurityContextHolder.getContext()方法获取。安全上下文包含了当前经过身份验证的用户的Authentication对象，以及一些其他的安全相关的信息。Authentication对象又包含了用户的主体（Principal）、凭证（Credentials）、权限（Authorities）等信息。Spring Security在认证和授权的过程中，会使用安全上下文中的信息来进行判断和处理。<a href="https://blog.csdn.net/qq_41071876/article/details/122290308">Spring Security核心组件之安全上下文_这是一条海鱼的博客-CSDN博客</a><br><a href="https://cloud.tencent.com/developer/article/1838816">Spring Security 实战干货：如何获取当前用户信息-腾讯云开发者社区-腾讯云</a><br>@Controller是用于处理普通的HTTP请求，而@RestController是用于处理RESTful风格的HTTP请求。@RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用，它会自动将返回值序列化为JSON或XML格式的数据，而@Controller则需要手动进行序列化或者配合视图解析器来返回指定页面。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694738995817-85859cfd-11c0-408b-8b12-0149e29b4606.png#averageHue=%235b614c&clientId=ub7726463-2cc9-4&from=paste&height=446&id=u8bc5bdad&originHeight=557&originWidth=1293&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=195200&status=done&style=none&taskId=ucaf3d586-0e40-46b3-b816-8e2474de109&title=&width=1034.4" alt="image.png"><br>session<br>Session（会话）是在Web开发中用于跟踪用户状态和存储用户数据的一种机制。它是建立在HTTP协议之上的一种状态管理方式。<br>在Web应用中，每个用户与服务器之间的交互都是通过HTTP请求和响应进行的。由于HTTP协议的无状态性，服务器无法直接识别不同的用户或跟踪用户的状态。这就需要使用会话来解决这个问题。<br>会话通过在服务器端存储用户的状态信息，并为每个用户分配一个唯一的标识符（Session ID）来跟踪用户。当用户首次访问服务器时，服务器会为该用户创建一个新的会话，并将会话ID发送给客户端，通常是通过Cookie或URL重写的方式。<br>客户端在随后的请求中会携带会话ID，服务器根据会话ID识别用户，并根据需要读取或修改会话中存储的数据。这样就可以实现在多个请求之间共享用户状态和数据的功能。</p><div class="code-wrapper"><pre><code class="hljs livecodeserver">Base64URL是Base64编码的一种变体，它可以安全地用于<span class="hljs-built_in">URL</span>和其他一些特殊字符可能有特殊含义的场合。它与标准的Base64有以下几点不同：•  它用<span class="hljs-string">&#x27;-&#x27;</span>和<span class="hljs-string">&#x27;_&#x27;</span>分别替换了<span class="hljs-string">&#x27;+&#x27;</span>和<span class="hljs-string">&#x27;/&#x27;</span>字符，以避免<span class="hljs-built_in">URL</span>编码或解码的需要。•  它省略了末尾的填充<span class="hljs-string">&#x27;=&#x27;</span>字符，以使编码后的字符串更短，也避免与查询参数或分隔符混淆。•  它使用与Base64相同的字母表，由A-Z, <span class="hljs-keyword">a</span>-z, <span class="hljs-number">0</span><span class="hljs-number">-9</span>, -, 和 _ 组成。Base64URL通常用于以紧凑和便携的方式编码二进制数据，如加密密钥、令牌或标识符。例如，JSON Web Tokens (JWTs)使用Base64URL来编码它们的头部、有效载荷和签名部分。</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694746646263-7ea77d1f-1f2c-4cee-8f62-c62ecde18275.png#averageHue=%23f9f9f9&clientId=ub7726463-2cc9-4&from=paste&height=286&id=u2c6346e0&originHeight=357&originWidth=963&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=39212&status=done&style=none&taskId=ucbced83c-e82f-4756-ad51-792239d639f&title=&width=770.4" alt="image.png"><br>token非法或者过期后都会验证不通过。<br><a href="https://www.cnblogs.com/longfurcat/p/9417912.html">核心组件之SecurityContextHolder - 猫毛·波拿巴 - 博客园</a><br>spting security从前端传来的用户名和密码储存在哪个变量中？<br>在Spring Security中，从前端传来的用户名和密码通常存储在UsernamePasswordAuthenticationToken对象中。<br>http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);<br>http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) 是Spring Security中用于配置会话管理的一行代码。<br>这行代码的作用是设置会话创建策略为STATELESS，也就是无状态会话。在无状态会话中，服务器不会在后端存储任何与会话相关的信息，也不会分配会话ID给客户端。<br>具体地说，这行代码的含义是：</p><ol><li>http.sessionManagement()：获取HttpSecurity对象的会话管理配置。</li><li>.sessionCreationPolicy(SessionCreationPolicy.STATELESS)：设置会话创建策略为STATELESS，即无状态会话。</li></ol><p>设置会话创建策略为STATELESS的主要目的是在构建基于令牌（Token）的身份验证机制时使用。在无状态会话中，服务器不维护任何会话状态，所有的认证信息都包含在每个请求的令牌中。这使得应用程序可以更轻松地进行横向扩展，因为服务器不需要存储会话状态。<br>需要注意的是，在使用无状态会话时，通常需要使用其他机制（如JWT）来存储和传递身份验证信息，以便每个请求都能够进行身份验证。<br>总结：http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) 是Spring Security中用于配置会话管理的代码，将会话创建策略设置为无状态会话，适用于构建基于令牌的身份验证机制。</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件测试</title>
    <link href="/2024/01/26/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/01/26/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1-Junit单元测试教程"><a href="#1-Junit单元测试教程" class="headerlink" title="1.Junit单元测试教程:"></a>1.Junit单元测试教程:</h1><h2 id="基础测试："><a href="#基础测试：" class="headerlink" title="基础测试："></a>基础测试：</h2><p>官方文档：<a href="https://junit.org/junit5/docs/current/user-guide/index.html#migrating-from-junit4">JUnit 5 User Guide</a><br>教学链接：<a href="https://blog.csdn.net/weixin_44170221/article/details/106463482">超级详细的Junit单元测试教程_何学长在奔跑的博客-CSDN博客</a><br>注意：<br>1.Junit4中的断言是Assert.assertEquals这种样式的（也就是教学链接里面的样子）<br>但是Junit5中的断言是直接使用assertEquals。<br>2.</p><div class="code-wrapper"><pre><code class="hljs haxe">method.invoke(junitClass.<span class="hljs-keyword">new</span><span class="hljs-type">Instance</span>()); invoke是调用反射类的方法</code></pre></div><p><a href="https://www.cnblogs.com/wyx1990/p/12732902.html">Eclipse搭建selenium环境 - 景月 - 博客园</a><br>超时测试：”@Test (timeout&#x3D;”规定的时间） </p><h2 id="参数测试："><a href="#参数测试：" class="headerlink" title="参数测试："></a>参数测试：</h2><p><a href="https://blog.csdn.net/w605283073/article/details/80051229">JUnit4 参数化测试（ Parameterized tests）_junit参数化测试_明明如月学长的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>课程作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式总结</title>
    <link href="/2024/01/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A/"/>
    <url>/2024/01/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><a href="https://blog.csdn.net/No_Game_No_Life_/article/details/107629644#:~:text=%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95UML%E7%B1%BB%E5%9B%BE%E6%B3%9B%E5%8C%96%20%28generalize%29%E4%B8%8E%E5%AE%9E%E7%8E%B0%20%28realize%29%E8%81%9A%E5%90%88%20%28aggregation%29%E4%B8%8E%E7%BB%84%E5%90%88,%28composition%29%E5%85%B3%E8%81%94%20%28association%29%E4%B8%8E%E4%BE%9D%E8%B5%96%20%28dependency%2923%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8FUML%E7%B1%BB%E5%9B%BE%E4%BB%8E%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B%E5%BC%80%E5%A7%8B%EF%BC%8C%E8%AF%B7%E7%9C%8B%E4%BB%A5%E4%B8%8B%E8%BF%99%E4%B8%AA%E7%B1%BB%E5%9B%BE%EF%BC%8C%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E5%85%B3%E6%B3%A8%E7%9A%84%EF%BC%9A%E6%B3%9B%E5%8C%96%20%28generalize%29%E4%B8%8E%E5%AE%9E%E7%8E%B0%20%28realize%29%E6%B3%9B%E5%8C%96%EF%BC%9ASUV%E6%89%A9%E5%B1%95%E5%92%8C%E7%BB%A7%E6%89%BF%E5%B0%8F%E6%B1%BD%E8%BD%A6%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%9B%E5%AE%9E%E7%8E%B0%EF%BC%9A%E5%B0%8F%E6%B1%BD%E8%BD%A6%E5%AE%9E%E7%8E%B0%E8%BD%A6%E8%BF%99%E4%B8%AA%E6%A6%82%E5%BF%B5%E3%80%82">Java设计之道——通过UML理解23种设计模式_下面的javaiouml类图体现了哪种设计模式思想-CSDN博客</a>（有图最好的）</p><h1 id="13-工厂方法设计模式-掘金"><a href="#13-工厂方法设计模式-掘金" class="headerlink" title="13.工厂方法设计模式 - 掘金"></a><a href="https://juejin.cn/post/6975032627128614949#heading-1">13.工厂方法设计模式 - 掘金</a></h1><p><a href="https://blog.csdn.net/weixin_53202763/article/details/118579427">基于Java的XML操作（XML使用、解析、生成）_javaxml islabel-CSDN博客</a></p><h2 id="XML操作："><a href="#XML操作：" class="headerlink" title="XML操作："></a>XML操作：</h2><p><a href="https://blog.csdn.net/weixin_53202763/article/details/118579427">基于Java的XML操作（XML使用、解析、生成）_javaxml islabel-CSDN博客</a><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1697863973548-aa627bbf-3fd5-4fb1-94b9-bd3a93d8e82c.jpeg"></p><h3 id="DOM4j解析XML："><a href="#DOM4j解析XML：" class="headerlink" title="DOM4j解析XML："></a>DOM4j解析XML：</h3><p><a href="https://blog.csdn.net/qq_51447436/article/details/124754572">【精选】Dom4j解析XML（详解）_dom4j解析xml文件_散一世繁华，颠半世琉璃的博客-CSDN博客</a><br>1.导入依赖</p><div class="code-wrapper"><pre><code class="hljs javascript">&lt;dependencies&gt;            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.dom4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dom4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span>    &lt;/dependencies&gt;</code></pre></div><p>2.准备的XML:</p><div class="code-wrapper"><pre><code class="hljs javascript">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">books</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">book</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>鬼谷子<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">info</span>&gt;</span>教你如何识人，谋略，管理。。。<span class="hljs-tag">&lt;/<span class="hljs-name">info</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">book</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>白雪公主<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">info</span>&gt;</span>白雪公主与七个小矮人的故事<span class="hljs-tag">&lt;/<span class="hljs-name">info</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">books</span>&gt;</span></span></code></pre></div><p>3.测试：</p><div class="code-wrapper"><pre><code class="hljs javascript">package <span class="hljs-variable constant_">XML</span>;<span class="hljs-keyword">import</span> org.<span class="hljs-property">dom4j</span>.<span class="hljs-property">Document</span>;<span class="hljs-keyword">import</span> org.<span class="hljs-property">dom4j</span>.<span class="hljs-property">DocumentException</span>;<span class="hljs-keyword">import</span> org.<span class="hljs-property">dom4j</span>.<span class="hljs-property">Element</span>;<span class="hljs-keyword">import</span> org.<span class="hljs-property">dom4j</span>.<span class="hljs-property">io</span>.<span class="hljs-property">SAXReader</span>;<span class="hljs-keyword">import</span> java.<span class="hljs-property">io</span>.<span class="hljs-property">FileInputStream</span>;<span class="hljs-keyword">import</span> java.<span class="hljs-property">io</span>.<span class="hljs-property">IOException</span>;<span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">List</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> <span class="hljs-variable">redA</span></span><span class="hljs-comment"> * @时间: 2023年10月21日 12:46</span><span class="hljs-comment"> * DOM4J解析XML</span><span class="hljs-comment"> */</span>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> &#123;    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-title class_">String</span>[] args) throws <span class="hljs-title class_">IOException</span>,  <span class="hljs-title class_">DocumentException</span> &#123;        <span class="hljs-comment">//1、获取输入流</span>        <span class="hljs-title class_">FileInputStream</span> fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test/src/test/java/XML/demo.xml&quot;</span>);        <span class="hljs-comment">//2、创建xml读取对象</span>        <span class="hljs-title class_">SAXReader</span> sr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();        <span class="hljs-comment">//3、读取并获得文档</span>        <span class="hljs-title class_">Document</span> doc = sr.<span class="hljs-title function_">read</span>(fis);        <span class="hljs-comment">//4、通过文档获取根元素</span>        <span class="hljs-title class_">Element</span> root = ((org.<span class="hljs-property">dom4j</span>.<span class="hljs-property">Document</span>) doc).<span class="hljs-title function_">getRootElement</span>();        <span class="hljs-comment">//5、开始解析元素</span>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(root.<span class="hljs-title function_">getName</span>());        <span class="hljs-comment">//常见操作</span>        <span class="hljs-comment">/*Element book = root.element(&quot;book&quot;);</span><span class="hljs-comment">        Element name = book.element(&quot;name&quot;);</span><span class="hljs-comment">        System.out.println(name.getText());*/</span>        <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Element</span>&gt; list = root.<span class="hljs-title function_">elements</span>();        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; list.<span class="hljs-title function_">size</span>(); i++) &#123;            <span class="hljs-title class_">Element</span> element = list.<span class="hljs-title function_">get</span>(i);            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(element.<span class="hljs-title function_">attributeValue</span>(<span class="hljs-string">&quot;id&quot;</span>));            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(element.<span class="hljs-title function_">elementText</span>(<span class="hljs-string">&quot;name&quot;</span>));            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(element.<span class="hljs-title function_">elementText</span>(<span class="hljs-string">&quot;info&quot;</span>));            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;-------------------&quot;</span>);        &#125;        fis.<span class="hljs-title function_">close</span>();    &#125;&#125;</code></pre></div><h3 id="dom4j结合XPath解析XML"><a href="#dom4j结合XPath解析XML" class="headerlink" title="dom4j结合XPath解析XML"></a>dom4j结合XPath解析XML</h3><p>1.导入依赖：<br>上面的dom4j依赖还需要额外的依赖：在pom.xml导入Xpath对应的依赖即可，具体如下所示：</p><div class="code-wrapper"><pre><code class="hljs javascript">&lt;dependency&gt;            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jaxen<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxen<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span>&lt;/dependency&gt;</code></pre></div><p>测试：</p><div class="code-wrapper"><pre><code class="hljs javascript">package <span class="hljs-variable constant_">XML</span>;<span class="hljs-keyword">import</span> org.<span class="hljs-property">dom4j</span>.<span class="hljs-property">Document</span>;<span class="hljs-keyword">import</span> org.<span class="hljs-property">dom4j</span>.<span class="hljs-property">DocumentException</span>;<span class="hljs-keyword">import</span> org.<span class="hljs-property">dom4j</span>.<span class="hljs-property">Node</span>;<span class="hljs-keyword">import</span> org.<span class="hljs-property">dom4j</span>.<span class="hljs-property">io</span>.<span class="hljs-property">SAXReader</span>;<span class="hljs-keyword">import</span> java.<span class="hljs-property">io</span>.<span class="hljs-property">FileInputStream</span>;<span class="hljs-keyword">import</span> java.<span class="hljs-property">io</span>.<span class="hljs-property">IOException</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> <span class="hljs-variable">redA</span></span><span class="hljs-comment"> * @时间: 2023年10月21日 13:09</span><span class="hljs-comment"> */</span>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03</span> &#123;    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-title class_">String</span>[] args) throws  <span class="hljs-title class_">DocumentException</span>, <span class="hljs-title class_">IOException</span> &#123;        <span class="hljs-comment">//1、获取输入流</span>        <span class="hljs-title class_">FileInputStream</span> fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test/src/test/java/XML/demo.xml&quot;</span>);        <span class="hljs-comment">//2、创建xml读取对象</span>        <span class="hljs-title class_">SAXReader</span> sr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();        <span class="hljs-comment">//3、读取并获得文档</span>        <span class="hljs-title class_">Document</span> doc = sr.<span class="hljs-title function_">read</span>(fis);        <span class="hljs-title class_">Node</span> node = doc.<span class="hljs-title function_">selectSingleNode</span>(<span class="hljs-string">&quot;//book[@id=&#x27;1&#x27;]//name&quot;</span>);        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(node.<span class="hljs-title function_">getName</span>()+<span class="hljs-string">&quot;:&quot;</span>+node.<span class="hljs-title function_">getText</span>());        fis.<span class="hljs-title function_">close</span>();    &#125;&#125;</code></pre></div><h3 id="DEMO4J生成XML文件"><a href="#DEMO4J生成XML文件" class="headerlink" title="DEMO4J生成XML文件:"></a>DEMO4J生成XML文件:</h3><div class="code-wrapper"><pre><code class="hljs javascript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">SaveGrandpa</span> &#123;    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-title class_">String</span>[] args) throws <span class="hljs-title class_">IOException</span> &#123;        <span class="hljs-comment">//1、通过文档助手，创建一个文档对象</span>        <span class="hljs-title class_">Document</span> <span class="hljs-variable language_">document</span> = <span class="hljs-title class_">DocumentHelper</span>.<span class="hljs-title function_">createDocument</span>();        <span class="hljs-comment">//2、给文档添加第一个节点（根节点）</span>        <span class="hljs-title class_">Element</span> books = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addElement</span>(<span class="hljs-string">&quot;books&quot;</span>);        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;            <span class="hljs-title class_">Element</span> book = books.<span class="hljs-title function_">addElement</span>(<span class="hljs-string">&quot;book&quot;</span>);<span class="hljs-comment">//添加books节点下的节点book</span>            <span class="hljs-title class_">Element</span> name = book.<span class="hljs-title function_">addElement</span>(<span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-comment">//添加book节点下的节点name</span>            name.<span class="hljs-title function_">setText</span>(<span class="hljs-string">&quot;葫芦娃救爷爷第（&quot;</span>+i+<span class="hljs-string">&quot;）集&quot;</span>);            <span class="hljs-title class_">Element</span> info = book.<span class="hljs-title function_">addElement</span>(<span class="hljs-string">&quot;info&quot;</span>);<span class="hljs-comment">//添加book节点下的节点info</span>            info.<span class="hljs-title function_">setText</span>(<span class="hljs-string">&quot;爷爷第&quot;</span>+i+<span class="hljs-string">&quot;次被抓走后，葫芦兄弟们，开始了他们第&quot;</span>+i+<span class="hljs-string">&quot;次的行动计划&quot;</span>);            book.<span class="hljs-title function_">addAttribute</span>(<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-number">100</span>+i+<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//给定book一个id属性，还有其对应的值</span>        &#125;        <span class="hljs-comment">//4、创建一个文件输出流</span>        <span class="hljs-title class_">FileOutputStream</span> fos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;test/src/test/java/XML/book.xml&quot;</span>);        <span class="hljs-comment">//5、将输出流转换为XML输出流</span>        <span class="hljs-title class_">XMLWriter</span> xw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLWriter</span>(fos);        <span class="hljs-comment">//6、写出文档</span>        xw.<span class="hljs-title function_">write</span>(<span class="hljs-variable language_">document</span>);        <span class="hljs-comment">//释放资源</span>        xw.<span class="hljs-title function_">close</span>();        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;执行完毕&quot;</span>);    &#125;&#125;</code></pre></div><h3 id="XML解析之DOM解析"><a href="#XML解析之DOM解析" class="headerlink" title="XML解析之DOM解析"></a>XML解析之DOM解析</h3><p><a href="https://blog.csdn.net/a1353206432/article/details/80583302">XML解析之DOM解析详解_dom xml-CSDN博客</a></p><div class="code-wrapper"><pre><code class="hljs javascript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">DOMDemo01</span> &#123;    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-title class_">String</span>[] args) throws <span class="hljs-title class_">ParserConfigurationException</span>, <span class="hljs-title class_">SAXException</span>, <span class="hljs-title class_">IOException</span>, <span class="hljs-title class_">IOException</span>, <span class="hljs-title class_">SAXException</span> &#123;        <span class="hljs-comment">//建立DocumentBuilderFactor，用于获得DocumentBuilder对象：</span>        <span class="hljs-title class_">DocumentBuilderFactory</span> factory = <span class="hljs-title class_">DocumentBuilderFactory</span>.<span class="hljs-title function_">newInstance</span>();        <span class="hljs-comment">//2.建立DocumentBuidler：</span>        <span class="hljs-title class_">DocumentBuilder</span> builder = factory.<span class="hljs-title function_">newDocumentBuilder</span>();        <span class="hljs-comment">//3.建立Document对象，获取树的入口：</span>        <span class="hljs-title class_">Document</span> doc = builder.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&quot;test/src/test/java/XML/demo.xml&quot;</span>);        <span class="hljs-comment">//4.建立NodeList：</span>        <span class="hljs-title class_">NodeList</span> node = doc.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;book&quot;</span>);        <span class="hljs-comment">//5.进行xml信息获取</span>        <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>;i&lt;node.<span class="hljs-title function_">getLength</span>();i++)&#123;            <span class="hljs-title class_">Element</span> e = (<span class="hljs-title class_">Element</span>)node.<span class="hljs-title function_">item</span>(i);            <span class="hljs-comment">// e.getElementsByTagName(&quot;name&quot;)返回name标签下所有名为name的标签集合；.item(0)获取</span><span class="hljs-comment">//            索引为0的标签集合；.getFirstChild()获取该标签下的第一个子节点（和前端的DOM树一个概念，文本信息也是节点）</span>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;书名：&quot;</span>+                    e.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;name&quot;</span>).<span class="hljs-title function_">item</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">getFirstChild</span>().<span class="hljs-title function_">getNodeValue</span>());            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;信息：&quot;</span>+                    e.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;info&quot;</span>).<span class="hljs-title function_">item</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">getFirstChild</span>().<span class="hljs-title function_">getNodeValue</span>());        &#125;    &#125;&#125;</code></pre></div><p>运行结果：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697866671687-9e4c0662-f7ab-4b9f-9dc7-e93ec193e3d7.png#averageHue=%23adb9a3&clientId=u8e7046c2-c39f-4&from=paste&height=150&id=u4520cb1f&originHeight=188&originWidth=454&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=36584&status=done&style=none&taskId=u19d0c24d-f0fa-4b58-be1f-a74d420b0e6&title=&width=363.2" alt="image.png"></p><h2 id="反射："><a href="#反射：" class="headerlink" title="反射："></a>反射：</h2><p><a href="https://blog.csdn.net/qq_44715943/article/details/120587716">Java反射（超详细！）_一个快乐的野指针~的博客-CSDN博客</a>（最好）<br><a href="https://blog.csdn.net/HO1_K/article/details/81210947">深入理解Java反射机制原理、使用方法_反射获取 hashmap 成员_涝山道士的博客-CSDN博客</a><br><a href="https://www.cnblogs.com/mikechenshare/p/15796381.html">Java反射详解：入门+使用+原理+应用场景 - mikechen的互联网架构 - 博客园</a>（原理）<br><a href="https://blog.csdn.net/peng_zhanxuan/article/details/104028236">一篇图文彻底弄懂Class文件是如何被加载进JVM的_classloader加载class之后,class内容放在那里-CSDN博客</a>(类加载原理）<br><a href="https://frank909.blog.csdn.net/article/details/54973413?spm=1001.2101.3001.6650.11&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-11-54973413-blog-104028236.235%5Ev38%5Epc_relevant_default_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-11-54973413-blog-104028236.235%5Ev38%5Epc_relevant_default_base&utm_relevant_index=17">一看你就懂，超详细java中的ClassLoader详解-CSDN博客</a>（详细较难）</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable constant_">JVM</span>加载<span class="hljs-keyword">class</span>要经历加载连接和初始化阶段。</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1697940589429-088280d5-a2cc-4b32-81f0-93cd5b35cec2.jpeg"></p><h2 id="设计模式七大准则："><a href="#设计模式七大准则：" class="headerlink" title="设计模式七大准则："></a>设计模式七大准则：</h2><p><a href="https://juejin.cn/post/6844904065806106632#heading-29">万字总结之设计模式七大原则 - 掘金</a><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1697936886662-ef323251-e37d-422c-b580-235f030a00bf.jpeg"></p><h2 id="工厂设计模式："><a href="#工厂设计模式：" class="headerlink" title="工厂设计模式："></a>工厂设计模式：</h2><p>简单工厂模式：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700697406061-8636a8ba-7342-4643-9005-2f897a1bfac6.png#averageHue=%23f8f7f6&clientId=uddc4e6af-e41a-4&from=paste&id=u1fb7a595&originHeight=289&originWidth=584&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ufc53946e-54cb-4024-9dbf-b422147fdf2&title="><br>工厂方法模式：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700697454837-e517f62c-1e75-4467-a454-6bb033ddf680.png#averageHue=%23f7f6f3&clientId=uddc4e6af-e41a-4&from=paste&id=u3f4ab352&originHeight=351&originWidth=836&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ude09a469-8938-4008-afb5-fe790f8c2e6&title="><br>抽象工厂：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700697477558-74711338-f414-4540-ad39-fceee78a2145.png#averageHue=%23f8f7f5&clientId=uddc4e6af-e41a-4&from=paste&id=u2254c91a&originHeight=575&originWidth=859&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u69b08de9-ad59-4c37-ac79-90ce36f4e33&title="><br><a href="https://juejin.cn/post/7290157103673573430">设计模式学习笔记（三）简单工厂、工厂方法和抽象工厂之间的区别 - 掘金</a>（较难）<br><a href="https://juejin.cn/post/6966429276438528037#heading-10">1.简单工厂设计模式 - 掘金</a><br><a href="https://juejin.cn/post/6975032627128614949#heading-1">13.工厂方法设计模式 - 掘金</a><br><a href="https://blog.csdn.net/qq_42804736/article/details/115168313">java工厂模式：简单工厂、工厂方法、抽象工厂（通俗易懂）_Mitsuha三葉的博客-CSDN博客</a><br>简单工厂是一个工厂方法承担多个产品制造方法。工厂方法是每个产品有一个公共的工厂类，各个工厂类抽象了一个接口，供上层模块使用。抽象工厂有多个工厂（抽象工厂+多个具体工厂），多个产品接口&#x2F;抽象类，对产品子类进行分组，根据继承抽象工厂中的方法多态创建同组的不同具体产品对象。适用于多个类型的多个产品。抽象工厂：比如有多个产品，这多个产品中每种产品有多种特性，我们把其中的一些特性抽取出来为多个接口，让这些产品实现这些接口；然后把部分特性放在工厂类中，工厂类在制造这些产品的时候给这些产品附加一些特性，然后把各个工厂类抽象为一个抽象工厂类供上层模块使用。</p><h2 id="适配器模式："><a href="#适配器模式：" class="headerlink" title="适配器模式："></a>适配器模式：</h2><p><a href="https://zhuanlan.zhihu.com/p/369272002">秒懂设计模式之适配器模式（Adapter Pattern）</a><br><a href="https://hyper18.github.io/2022/01/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/">设计模式之结构型模式的设计与实现（一）</a><br>分为对象适配器模式和类适配器模式。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697950230938-1654fb7f-2d58-485f-9ccb-21a2c5019685.png#averageHue=%23fafafa&clientId=ucf7aa35b-d6e3-4&from=paste&height=403&id=ued1d1656&originHeight=504&originWidth=886&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=65828&status=done&style=none&taskId=u553f38d0-c706-4715-bf5a-7c368d7327c&title=&width=708.8" alt="image.png"></p><h2 id="桥接模式："><a href="#桥接模式：" class="headerlink" title="桥接模式："></a>桥接模式：</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700643857216-22c6ede3-a69c-4582-b7b4-dc420db3c313.png#averageHue=%23f5f1f1&clientId=u94ee9845-25a0-4&from=paste&id=u2d9da7d3&originHeight=260&originWidth=532&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uece6c55d-7a24-4109-b361-4ec7dd1992c&title="></h2><p><a href="https://blog.csdn.net/bueke/article/details/115640512">桥接模式实例与解析 实例一：模拟毛笔_桥接模式 毛笔-CSDN博客</a><br><a href="https://cloud.tencent.com/developer/article/2183989">详解设计模式：桥接模式-腾讯云开发者社区-腾讯云</a></p><h2 id="外观模式："><a href="#外观模式：" class="headerlink" title="外观模式："></a>外观模式：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700645512075-be1a2562-87cb-4e82-b6fb-0e8b0f872401.png#averageHue=%23f9f8f0&clientId=u94ee9845-25a0-4&from=paste&id=u6215c5c2&originHeight=294&originWidth=544&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u472e0d03-bda0-4737-8761-51c9e87c2db&title="><br>（简单来说就是将多个类的功能集中到一个外观类中，让这个外观类去调用各个类的方法）<br><a href="https://blog.csdn.net/shulianghan/article/details/105339213">【设计模式】外观模式 ( 概念 | 适用场景 | 优缺点 | 代码示例 )_外观模式的优缺点-CSDN博客</a><br><a href="https://blog.csdn.net/qq_44302255/article/details/119026220">外观模式 ——模拟电脑主机调用其他硬件和软件_模拟连接计算机硬件_寻常w的博客-CSDN博客</a><br><a href="https://blog.csdn.net/Altitude_/article/details/103870191">外观模式_使用外观模式,描述cpu、memory、disk、电脑几个对象-CSDN博客</a></p><h2 id="代理模式："><a href="#代理模式：" class="headerlink" title="代理模式："></a>代理模式：</h2><p>静态代理：需要实现接口的原因是为了可以用接口来代替代理类。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700664251988-75270825-7b75-4837-9b78-4146146ce972.png#averageHue=%23f5f4ea&clientId=u94ee9845-25a0-4&from=paste&id=u01f30944&originHeight=335&originWidth=482&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u93e65a83-3817-4b39-8d92-cec01b034e8&title="><br>动态代理：不需要实现接口但是因为利用了反射机制；AOP编程使用的就是动态代理<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700664285010-f34cffcf-b65b-46cc-8455-7112589d1a40.png#averageHue=%23f1f0e2&clientId=u94ee9845-25a0-4&from=paste&id=uc7c14baf&originHeight=262&originWidth=457&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u24a8a8fd-3770-4776-b05c-4504b9e919e&title="><br><a href="https://it-blog-cn.com/blogs/design_mode/proxy.html#%E4%BA%8C%E3%80%81%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86">设计模式——代理模式 | 程序员进阶</a><br><a href="https://blog.csdn.net/will130/article/details/50707527">代理模式（二）：代理模式应用实例（收费商务信息查询系统）-CSDN博客</a><br><a href="https://juejin.cn/post/7218559384450924604#heading-5">Java代理模式：如何优雅地控制对象访问？ - 掘金</a></p><h2 id="命令模式："><a href="#命令模式：" class="headerlink" title="命令模式："></a>命令模式：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700724055355-ef8d51e9-1fab-4334-9b71-42d85ef56cbd.png#averageHue=%23fcfcfc&clientId=uddc4e6af-e41a-4&from=paste&height=210&id=uae146fd5&originHeight=263&originWidth=684&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=18687&status=done&style=none&taskId=u139dd4da-ec93-44c7-b429-62a364db76d&title=&width=547.2" alt="image.png"><br><a href="https://www.cnblogs.com/xuwendong/p/9814421.html#_label2">深入理解设计模式（十）：命令模式 - 一指流砂~ - 博客园</a><br><a href="https://blog.csdn.net/qq_45703570/article/details/123814016">【精选】命令模式模拟房间开关_房间中的开关就是命令模式的一个实现_水木 清华的博客-CSDN博客</a></p><h2 id="迭代器模式："><a href="#迭代器模式：" class="headerlink" title="迭代器模式："></a>迭代器模式：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700666053595-7efa2537-a417-4c87-98f6-7f4be9a255e6.png#averageHue=%23f4f3e5&clientId=u94ee9845-25a0-4&from=paste&id=u95811787&originHeight=200&originWidth=821&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u635b5f51-1766-4fae-a0d3-40d732a25d6&title="><br><a href="https://blog.csdn.net/sheng0113/article/details/122712947">【精选】Java迭代器详解，看这一篇就够了-CSDN博客</a><br><a href="https://blog.csdn.net/shulianghan/article/details/119777612">【设计模式】迭代器模式 ( 简介 | 适用场景 | 优缺点 | 代码示例 )_迭代器模式优缺点-CSDN博客</a><br><a href="https://cloud.tencent.com/developer/article/2342495">设计模式学习笔记（十六）迭代器模式及其在Java 容器中的应用-腾讯云开发者社区-腾讯云</a></p><h2 id="观察者模式："><a href="#观察者模式：" class="headerlink" title="观察者模式："></a>观察者模式：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700667035824-c8744e25-b87c-4475-ae49-cda5965d90f6.png#averageHue=%23f2f1ed&clientId=u94ee9845-25a0-4&from=paste&id=udb284363&originHeight=306&originWidth=479&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u3794665b-2aa4-4b05-b30b-8318b1a6cb4&title="><br><a href="https://www.cnblogs.com/xuwendong/p/9814417.html">深入理解设计模式（八）：观察者模式 - 一指流砂~ - 博客园</a><br><a href="https://juejin.cn/post/7203310104010162237">设计模式之《观察者模式》 - 掘金</a><br><a href="https://www.cnblogs.com/binyao/p/4898144.html">观察者模式－猫叫了,老鼠跑了,主人醒了… - Binyao - 博客园</a></p><h2 id="策略模式："><a href="#策略模式：" class="headerlink" title="策略模式："></a>策略模式：</h2><p><a href="https://www.cnblogs.com/ysocean/p/15635852.html#_label4">Java设计模式之（十四）——策略模式 - YSOcean - 博客园</a><br><a href="https://blog.csdn.net/yuanmayuzhou/article/details/131430435?spm=1001.2101.3001.6650.15&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-15-131430435-blog-90601469.235%5Ev38%5Epc_relevant_default_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-15-131430435-blog-90601469.235%5Ev38%5Epc_relevant_default_base&utm_relevant_index=20">【设计模式】用Java实现策略模式_java策略模式实现_卷帘的博客-CSDN博客</a><br><a href="https://www.cnblogs.com/wangyongwen/p/11255563.html">Java的设计模式（5）– 策略模式 - 扁豆一号 - 博客园</a></p><h2 id="访问者模式："><a href="#访问者模式：" class="headerlink" title="访问者模式："></a>访问者模式：</h2><p><a href="https://www.jianshu.com/p/1f1049d0a0f4">访问者模式一篇就够了</a><br>访问者模式是一种将数据操作和数据结构分离的设计模式。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698587841234-71706cf7-5ba2-4433-9cca-a7f0b4a65494.png#averageHue=%23474b49&clientId=u72c71db7-a8bd-4&from=paste&height=472&id=u89dc5bda&originHeight=590&originWidth=900&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=170983&status=done&style=none&taskId=u7d9cfec2-6d57-4594-993b-e6e81078010&title=&width=720" alt="image.png"></p><h2 id="复习："><a href="#复习：" class="headerlink" title="复习："></a>复习：</h2><h3 id="建造者模式："><a href="#建造者模式：" class="headerlink" title="建造者模式："></a>建造者模式：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700630270327-4bbf82a4-2e03-44e8-aa17-bd7d19d4be9e.png#averageHue=%23fcfcfc&clientId=u94ee9845-25a0-4&from=paste&height=193&id=ufc6e7925&originHeight=241&originWidth=613&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=31108&status=done&style=none&taskId=u487d60f2-39ab-4f4e-9448-52d1a1f43b4&title=&width=490.4" alt="image.png"><br>建造者模式在创建产品的时候使用的是Director中的创造产品方法，而该方法的参数是Builder接口的具体实现类，而这个具体实现类的作用是产生一个具体的产品（该产品的属性赋值了的）；这样做就可以把产品的生成和赋值分离开来。比如当一个产品融合到一个模块中了，如果该产品是用new生成在赋值的，那么我们想修改该产品的属性就需要修改这个模块；如果我们使用了构造者模式，我们就把该产品赋值分离了该模块也就是是把赋值的功能交给了Builder具体实现类，我们只需要修改这个具体实现类而不用修改原模块了。<br><a href="https://blog.csdn.net/qq_43652327/article/details/115856402">23种设计模式全解析（JAVA实现）_23种设计模式 java实现、-CSDN博客</a></p><h3 id="原型模式："><a href="#原型模式：" class="headerlink" title="原型模式："></a>原型模式：</h3><p><a href="https://it-blog-cn.com/blogs/design_mode/prototype.html#%E4%BA%8C%E3%80%81%E7%B1%BB%E5%9B%BE">设计模式——原型模式 | 程序员进阶</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700631075062-27757752-d23e-4d1d-ba50-93bbba153667.png#averageHue=%23fefcfa&clientId=u94ee9845-25a0-4&from=paste&height=94&id=u43dee661&originHeight=117&originWidth=811&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=19556&status=done&style=none&taskId=u95340d35-0c0f-4df4-a491-ca502a0f6b5&title=&width=648.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700630981440-697e4124-aaaa-4e92-b7fd-3481177500fc.png#averageHue=%23f5f5ea&clientId=u94ee9845-25a0-4&from=paste&id=u432a964e&originHeight=206&originWidth=415&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u42667948-7c60-4a9b-9cc6-c76fbd74400&title="></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yintong.principle.singleresponsibility;<span class="hljs-comment">//写一个手机的克隆类</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcretePrototype</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;    <span class="hljs-comment">// 这里的Cloneable是一个空接口，起着标记的作用</span><span class="hljs-comment">//名称</span><span class="hljs-keyword">private</span> String name;<span class="hljs-comment">//号码</span><span class="hljs-keyword">private</span> Long number;<span class="hljs-comment">//构造器</span><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcretePrototype</span><span class="hljs-params">(String name, Long number)</span> &#123;<span class="hljs-built_in">super</span>();<span class="hljs-built_in">this</span>.name = name;<span class="hljs-built_in">this</span>.number = number;&#125;<span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ConcretePrototype [name=&quot;</span> + name + <span class="hljs-string">&quot;, number=&quot;</span> + number + <span class="hljs-string">&quot;]&quot;</span>;&#125;        <span class="hljs-comment">// 克隆用到的主要部分，重写的clone方法是object中的方法，Object</span>    <span class="hljs-comment">// 中的clone方法用于创建并返回当前对象的副本。如果当前对象的类实现了Cloneable接口，</span>    <span class="hljs-comment">// 则返回新的对象，否则抛出CloneNotSupportedException异常。</span>    <span class="hljs-comment">// </span><span class="hljs-meta">@Override</span><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<span class="hljs-type">ConcretePrototype</span> <span class="hljs-variable">ConcretePrototype</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-keyword">try</span> &#123;ConcretePrototype = (ConcretePrototype) <span class="hljs-built_in">super</span>.clone();&#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;System.out.println(e.getMessage());&#125;<span class="hljs-keyword">return</span> ConcretePrototype;&#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<span class="hljs-comment">//创建一个对象</span><span class="hljs-type">ConcretePrototype</span> <span class="hljs-variable">prototype</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcretePrototype</span>(<span class="hljs-string">&quot;华为&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>(<span class="hljs-number">1568889932</span>));<span class="hljs-comment">//通过原型模式完成对象的创建  克隆</span><span class="hljs-type">ConcretePrototype</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> (ConcretePrototype)prototype.clone();&#125;&#125;<span class="hljs-comment">// 这里的p2和 prototype创建对象的地址不一样</span></code></pre></div><h3 id="单例模式："><a href="#单例模式：" class="headerlink" title="单例模式："></a>单例模式：</h3><p>通过构造方法私有化，在类中实例该对象，从而达到单例的效果。</p><h3 id="组合模式："><a href="#组合模式：" class="headerlink" title="组合模式："></a>组合模式：</h3><p>主要表现的是类的层次结构<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700644275717-97906ff7-9846-4e93-8c1a-e1595e768205.png#averageHue=%23fefdfb&clientId=u94ee9845-25a0-4&from=paste&height=82&id=u20fb80ad&originHeight=103&originWidth=1423&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=21853&status=done&style=none&taskId=u74b954aa-6664-49d2-b737-bca4f370332&title=&width=1138.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700644282629-e626acda-0a8d-4749-b4b5-cdc0020df8ec.png#averageHue=%23f7f5e2&clientId=u94ee9845-25a0-4&from=paste&id=u28275542&originHeight=370&originWidth=1040&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u1517a201-b125-4bbf-a0cf-42949b1dd0a&title="></p><h3 id="装饰者模式："><a href="#装饰者模式：" class="headerlink" title="装饰者模式："></a>装饰者模式：</h3><p><a href="https://blog.csdn.net/No_Game_No_Life_/article/details/85777928">Java设计模式——装饰模式_装饰模式代码-CSDN博客</a><br>动态地给一个对象添加一些额外的职责的同时不修改原对象；这里的原对象是ConcreteComponent的实例，在不修改原对象添加额外的操作说白了就是新创建一个类，这个类属性为原对象，把这个类的实例当作原对象的实例，通过往该类中添加额外的操作来实现。这里之所以抽出一个接口是为了让类依赖于接口而不是具体的类。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700644479601-17954813-9f04-478d-88c8-f53aa6188058.png#averageHue=%23f4f1ec&clientId=u94ee9845-25a0-4&from=paste&id=ub241c7e9&originHeight=326&originWidth=629&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ue45997b2-9927-4b34-ad0f-561b3e06ec3&title="></p><p>Component:对象的接口类，定义装饰对象和被装饰对象的共同接口；<br>ConcreteComponent:被装饰对象的类定义；<br>Decorator:装饰对象的抽象类，持有一个具体的被修饰对象，并实现接口类继承的公共接口；<br>ConcreteDecorator:具体的装饰器，负责往被装饰对象添加额外的功能；</p><h3 id="享元模式："><a href="#享元模式：" class="headerlink" title="享元模式："></a>享元模式：</h3><p><a href="https://it-blog-cn.com/blogs/design_mode/flyweight.html#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">设计模式——享元模式 | 程序员进阶</a></p><h3 id="职责链模式："><a href="#职责链模式：" class="headerlink" title="职责链模式："></a>职责链模式：</h3><p>就是客户端将请求request包装为一个request该request发给一个抽象的handler类，该handler有多个实现类；<br>这种模式深刻体现了依赖倒置原则。</p><h3 id="访问者模式：-1"><a href="#访问者模式：-1" class="headerlink" title="访问者模式："></a>访问者模式：</h3><p>将数据结构的操作和数据结构分离开来。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700665871732-75c0dc46-cbf9-4fa5-beb2-f90889708341.png#averageHue=%23ededed&clientId=u94ee9845-25a0-4&from=paste&id=u64abde58&originHeight=413&originWidth=560&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ubd72810e-3d94-4898-95d0-07a56fff11c&title="></p><h3 id="中介模式："><a href="#中介模式：" class="headerlink" title="中介模式："></a>中介模式：</h3><p>当一个类依赖一个类是，不直接使用依赖而是通过中介来实现这种依赖关系。迪米特法则当传递过来的参数是数组的时候，该类中对该数组参数的处理可能会new一个该参数的类，这个时候就破坏了迪米特法则；利用中介模式可以很好的维护迪米特法则。</p><h3 id="备忘录模式："><a href="#备忘录模式：" class="headerlink" title="备忘录模式："></a>备忘录模式：</h3><p>在不破坏一个对象封装性的前提下，获取该对象内部状态。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700667536762-faa27152-74cd-4dbd-bbf0-684dbea671a9.png#averageHue=%23f5f4df&clientId=uddc4e6af-e41a-4&from=paste&id=ub9a423cd&originHeight=465&originWidth=787&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u1593eead-e344-4d86-ab33-43642c750d0&title="></p><h3 id="状态模式："><a href="#状态模式：" class="headerlink" title="状态模式："></a>状态模式：</h3><p><strong>当对象的状态改变时，同时改变其行为。也就是行为由其状态决定。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700667692599-12166ee9-ce23-466e-b2f0-9f9dce5477b2.png#averageHue=%23f3f2f0&clientId=uddc4e6af-e41a-4&from=paste&id=ud8564ead&originHeight=178&originWidth=565&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ue45ccb5d-d8a8-4585-b7e2-c2b258424ce&title="></p><h3 id="策略模式：-1"><a href="#策略模式：-1" class="headerlink" title="策略模式："></a>策略模式：</h3><p>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700667742848-e1d3c5a5-1519-4f06-8668-25fb848e1b86.png#averageHue=%23f3ddb0&clientId=uddc4e6af-e41a-4&from=paste&id=u525c08b7&originHeight=166&originWidth=587&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uf8642269-9d65-49b3-a7ad-935ba0a4dab&title="></p><h3 id="模板模型："><a href="#模板模型：" class="headerlink" title="模板模型："></a>模板模型：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700667785713-b6abf372-a615-40bd-810f-0efb71a7abff.png#averageHue=%23f7f6ea&clientId=uddc4e6af-e41a-4&from=paste&id=u166614fb&originHeight=205&originWidth=478&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uc1cc0514-74c8-48e9-8c99-96ca63a4f1e&title="></p><h2 id="习题："><a href="#习题：" class="headerlink" title="习题："></a>习题：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700700546719-46ba9e6a-def3-4b46-8da8-1fb663b94486.png#averageHue=%23fefefe&clientId=uddc4e6af-e41a-4&from=paste&height=349&id=u4b4d0897&originHeight=436&originWidth=787&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=50689&status=done&style=none&taskId=u48aeff43-ae67-400f-81f1-6dee8246b03&title=&width=629.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700702555642-2fc0ff08-e896-496e-81a4-deeb27aae9f9.png#averageHue=%23fdfcfb&clientId=uddc4e6af-e41a-4&from=paste&height=358&id=u95106190&originHeight=447&originWidth=1079&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=109650&status=done&style=none&taskId=u045c5d8a-41da-4c40-bda9-0349f0bca79&title=&width=863.2" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs java">合成复用实际上更倾向于<span class="hljs-string">&quot;黑箱&quot;</span>复用，而不是<span class="hljs-string">&quot;白箱&quot;</span>复用。在合成复用中，包含对象的容器对象并不需要了解或暴露被包含对象的实现细节，因此称为<span class="hljs-string">&quot;黑箱&quot;</span>复用。这种方式降低了对象之间的耦合度，并且使得容器对象可以独立于被包含对象进行变化。另外，合成复用是可以在运行时动态实现的，通过组合对象，可以在运行时灵活地改变对象之间的关系。这使得合成复用比继承复用更加灵活和可扩展。因此，选项B的说法是错误的。</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700705175603-e347f492-cdcb-4d2f-8d39-2be451a99610.png#averageHue=%23fefefe&clientId=uddc4e6af-e41a-4&from=paste&height=308&id=u796366bd&originHeight=385&originWidth=1114&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=19941&status=done&style=none&taskId=ue649576a-cbc7-4bfe-9576-2514815b6d9&title=&width=891.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700705229399-8222eeda-e8db-4e1b-b106-b984e8df6973.png#averageHue=%23f7f7f6&clientId=uddc4e6af-e41a-4&from=paste&height=538&id=u8b79214f&originHeight=672&originWidth=1114&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=162923&status=done&style=none&taskId=u5f783264-a802-44fb-ba5b-e24fb5b1ebf&title=&width=891.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700705570296-3e97e4b7-37de-4550-a026-dfeb41107bf5.png#averageHue=%23fefdfd&clientId=uddc4e6af-e41a-4&from=paste&height=274&id=ub059b76c&originHeight=342&originWidth=1070&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=21448&status=done&style=none&taskId=uf29fdab3-a95a-4d87-8ad8-3c754ab7727&title=&width=856" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs java">桥接模式将对象的抽象部分与它的实现部分分离，以使得它们都可以独立地变化。在桥接模式中，一个对象被划分成两个部分，即抽象部分和实现部分，然后两者通过桥进行关联。这样，抽象部分和实现部分可以分别独立地变化，而不会影响到它们之间的耦合关系。 状态模式则是一种行为型模式，用于模拟对象的各种状态，并且方便在不同状态之间进行转换。状态模式包含状态接口、具体状态以及上下文三个部分。其中，状态接口定义了各个具体状态的共同行为，具体状态则实现了这些行为，而上下文则包含了状态接口，并且通过引用具体状态来实现状态的切换。因此，桥接模式和状态模式的作用和实现方式是不同的。桥接模式主要用于对象的抽象和实现的分离，而状态模式主要用于模拟对象的不同状态和状态之间的切换。</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700705765398-6eeeb26a-826c-4872-bae3-e89727c85631.png#averageHue=%23fefefd&clientId=uddc4e6af-e41a-4&from=paste&height=302&id=u84e8af58&originHeight=377&originWidth=766&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=37020&status=done&style=none&taskId=uadc62e4e-3cbf-4a63-b48e-5ceaa950b19&title=&width=612.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700705959590-c5e35bef-c6bc-4b75-9192-4b67e49f8caf.png#averageHue=%23fefdfd&clientId=uddc4e6af-e41a-4&from=paste&height=194&id=u907da4bd&originHeight=243&originWidth=548&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=12804&status=done&style=none&taskId=u309240ad-7912-4467-b26c-99f323456a5&title=&width=438.4" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs java">封装不仅仅包括数据，还包括一些方法</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700706074307-d0d19e0e-0a68-424c-beb9-677d6f157781.png#averageHue=%23fdfdfd&clientId=uddc4e6af-e41a-4&from=paste&height=208&id=u71109ad4&originHeight=260&originWidth=502&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=12657&status=done&style=none&taskId=u0698ef60-bc90-4ccc-b4c8-8475d7887c3&title=&width=401.6" alt="image.png"><br>简单工厂模式的类图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700697406061-8636a8ba-7342-4643-9005-2f897a1bfac6.png#averageHue=%23f8f7f6&from=url&id=vW0gT&originHeight=289&originWidth=584&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br>可以看到如果新增一个具体产品的话，就需要修改Factory中的构造方法，明显不符合开闭原则。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700706283790-70c49687-2ce9-49cd-b390-f02c5d2b6a93.png#averageHue=%23fdfdfc&clientId=uddc4e6af-e41a-4&from=paste&height=193&id=u577e6c38&originHeight=241&originWidth=461&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=12506&status=done&style=none&taskId=u65a8e59e-37e0-4425-b6d8-325753c624f&title=&width=368.8" alt="image.png">（这个题应该有点争议）<br>原型模式clone的对象不一样，但是类型一样。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700706553905-28c708c7-5a6f-470c-9fe4-659ee5314f92.png#averageHue=%23fdfdfc&clientId=uddc4e6af-e41a-4&from=paste&height=215&id=u5b7b3681&originHeight=269&originWidth=625&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=14356&status=done&style=none&taskId=u1af2d06f-cf74-4a7a-ac48-b2d583164e9&title=&width=500" alt="image.png"><br>这个说的应该是桥接模式，抽象工厂针对的是多个产品等级结构。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700706608794-6d3f696c-e0e2-44e2-b624-06dceef08a87.png#averageHue=%23f8f7f5&clientId=uddc4e6af-e41a-4&from=paste&id=u11821bd5&originHeight=575&originWidth=859&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u81538e04-0d95-4c68-8511-59e8cb9ceca&title="><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700706639063-ac936d77-5a84-4056-8ecc-abb1a67a37ee.png#averageHue=%23fdfdfd&clientId=uddc4e6af-e41a-4&from=paste&height=200&id=ue686e415&originHeight=250&originWidth=647&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=14283&status=done&style=none&taskId=ue5221bbc-2eca-4250-8470-8de04ef9d90&title=&width=517.6" alt="image.png"><br>饿汉式是随着类加载的时候创建实例，懒汉式是需要使用的时候加载实例，其存在线程安全问题。<br>单例模型的作用就是保证一个类仅有一个实例，并提供一个访问他的全局访问点。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700706716676-6ab8a3ef-5861-4ce4-91f6-245fd1b27351.png#averageHue=%23fdfdfc&clientId=uddc4e6af-e41a-4&from=paste&height=193&id=u637d648b&originHeight=241&originWidth=767&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=15665&status=done&style=none&taskId=u5e56101d-81d2-48ef-b7fd-856c9ec0435&title=&width=613.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700706849042-6c007611-1c2b-4f52-90da-a9c94fffc78c.png#averageHue=%23fdfdfd&clientId=uddc4e6af-e41a-4&from=paste&height=205&id=u9640da3d&originHeight=256&originWidth=782&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=19105&status=done&style=none&taskId=u78b2a3d3-bee2-403e-aaf9-be4b91f2aa6&title=&width=625.6" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs java">正确。如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。这是因为Cloneable接口的clone()方法会创建一个与原始对象相同的对象，并返回该对象。然后，通过调用equals()方法比较两个对象是否相等。在这种情况下，x.clone().equals(x)应该返回<span class="hljs-literal">true</span>，表示两个对象相等。</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700706972111-6c8fdd16-03a9-418e-a82b-f88896cfe570.png#averageHue=%23fbfbfa&clientId=uddc4e6af-e41a-4&from=paste&height=597&id=u058c683a&originHeight=746&originWidth=773&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=92700&status=done&style=none&taskId=u6bb57ea5-cdf7-4d8d-961f-c308eae3c5c&title=&width=618.4" alt="image.png"><br>建造者模式是将对象的创建和赋值给分离开的模式，这里汽车的反向盘等是可以用其他来替换的；</p><div class="code-wrapper"><pre><code class="hljs java">组合模式是一种用于组合对象以形成树形结构的模式。它允许动态地添加和删除对象，同时保持了对象的层次结构。组合模式使用分层的结构来表示整体和部分的关系，部分可以是另一个整体。组合模式适用于需要对对象进行遍历和访问的情况。  建造者模式是一种用于将对象的不同部分组合成一个完整对象的模式。它将对象的构造过程分离出来，以便可以单独管理和改变这个过程。建造者模式适用于当需要创建复杂对象时，这些对象的构建过程很复杂，很难通过简单的赋值来实现。  总之，组合模式是用于组合对象以形成树形结构的模式，而建造者模式是用于将对象的不同部分组合成一个完整对象的模式</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1700707528174-3bda3c28-db60-4c2a-906a-a15947beb8c4.jpeg#averageHue=%23f3f3f3&clientId=uddc4e6af-e41a-4&from=paste&id=u20d69d63&originHeight=353&originWidth=578&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u50d3bb9d-4cc9-40da-9119-a6f68faafa0&title="><br>上面的题如果选中组合模式，那么发动机和方向盘都需要实现统一的接口，这在现实世界中是不现实的。<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700708049412-e9aa5ac2-79a7-4e95-baf9-7deef9497438.png#averageHue=%23fefdfb&clientId=uddc4e6af-e41a-4&from=paste&height=276&id=u136816e8&originHeight=345&originWidth=979&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=41507&status=done&style=none&taskId=ubc532f6a-64e2-4297-850e-4e31ec32579&title=&width=783.2" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs java">在原型模式中，每个具体原型类都需要实现一个克隆方法（Clone Method），该方法用于创建并返回当前对象的副本。因此，对于每个类都需要配置一个克隆方法，以便实现原型对象的复制。</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700711119870-5a3ce7c3-1de7-45ef-86e2-37f3c23956d2.png#averageHue=%23fdfcfc&clientId=uddc4e6af-e41a-4&from=paste&height=320&id=u87a8c6a6&originHeight=400&originWidth=874&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=29265&status=done&style=none&taskId=u22a581eb-63bb-4eb6-a436-3adcdbb388e&title=&width=699.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700711144922-260b7cb3-d4ec-49d9-b7f6-24bdb127bea9.png#averageHue=%23fdfcfa&clientId=uddc4e6af-e41a-4&from=paste&height=93&id=u0d504d5d&originHeight=116&originWidth=1312&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=37184&status=done&style=none&taskId=u4a000895-c1ba-424b-a761-4f8f9808ed7&title=&width=1049.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700712968147-f962f318-8936-40cb-8ff5-dc293d8562cf.png#averageHue=%23fdfdfc&clientId=uddc4e6af-e41a-4&from=paste&height=288&id=uef8844d5&originHeight=360&originWidth=1089&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=25596&status=done&style=none&taskId=u97971418-71f0-466f-a172-a3a047a8fb1&title=&width=871.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700713803230-7141e0d6-6324-4181-94f8-2e54d2a28308.png#averageHue=%23fefdfd&clientId=uddc4e6af-e41a-4&from=paste&height=380&id=u0572a858&originHeight=475&originWidth=1118&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=44761&status=done&style=none&taskId=udf9de837-6905-418e-96f4-ef5f2e32ca9&title=&width=894.4" alt="image.png"><br>职责链模式是将处理请求传递给下一个处理者。如果上面使用的是职责链模式，那么系统会在判断教师是否满足科研奖后自动继续判断是否教师满足成绩优秀奖；这明显是不符合题目需求的：判断是否符合某个奖项而不是判断能拿哪些奖项。因此这里该使用访问者模式，将某种具体的奖项当成一种数据结构，而判断是否满足当成访问者（数据的操作）。</p><div class="code-wrapper"><pre><code class="hljs java">模板方法模式（Template Method Pattern）是一种行为型模式，它定义了一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义算法的某些特定步骤。</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700723525624-0ab100c2-2171-49af-ade9-5f22667a30d0.png#averageHue=%23f8f8f7&clientId=uddc4e6af-e41a-4&from=paste&height=229&id=ub8f36951&originHeight=286&originWidth=666&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=21412&status=done&style=none&taskId=u3f86c948-cb95-4f48-86ff-0b6d789c296&title=&width=532.8" alt="image.png"><br>A</p><div class="code-wrapper"><pre><code class="hljs java">职责链模式是一种行为型设计模式，用于解决一组对象对同一消息做出响应的问题。职责链模式通过创建一个对象链，使得多个对象都有机会处理请求，从而避免了传统的多分支处理请求的模式。其中，每个对象都有机会处理请求，而客户端只需知道最终处理请求的对象，而不需要了解链上的其他对象。</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 职责链模式示例代码</span><span class="hljs-comment">// 职责接口</span><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Handler</span> &#123;    <span class="hljs-type">boolean</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> request)</span>;&#125;<span class="hljs-comment">// 具体职责类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteHandler1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Handler</span> &#123;    <span class="hljs-keyword">private</span> Handler nextHandler;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> request)</span> &#123;        <span class="hljs-keyword">if</span> (request &gt;= <span class="hljs-number">10</span> &amp;&amp; request &lt;= <span class="hljs-number">15</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">if</span> (nextHandler != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> nextHandler.handleRequest(request);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNext</span><span class="hljs-params">(Handler nextHandler)</span> &#123;        <span class="hljs-built_in">this</span>.nextHandler = nextHandler;    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteHandler2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Handler</span> &#123;    <span class="hljs-keyword">private</span> Handler nextHandler;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> request)</span> &#123;        <span class="hljs-keyword">if</span> (request &gt;= <span class="hljs-number">5</span> &amp;&amp; request &lt;= <span class="hljs-number">10</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">if</span> (nextHandler != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> nextHandler.handleRequest(request);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNext</span><span class="hljs-params">(Handler nextHandler)</span> &#123;        <span class="hljs-built_in">this</span>.nextHandler = nextHandler;    &#125;&#125;<span class="hljs-comment">// 客户端代码</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Handler</span> <span class="hljs-variable">handler1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteHandler1</span>();        <span class="hljs-type">Handler</span> <span class="hljs-variable">handler2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteHandler2</span>();        handler1.setNext(handler2);        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> handler1.handleRequest(<span class="hljs-number">7</span>);        System.out.println(result);  <span class="hljs-comment">// 输出 true</span>    &#125;&#125;</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700723581069-98dd4ecd-3509-450f-879f-23b935828141.png#averageHue=%23faf8f6&clientId=uddc4e6af-e41a-4&from=paste&height=183&id=ud7a18ef8&originHeight=229&originWidth=742&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=31915&status=done&style=none&taskId=ue7ac542e-d83f-4d75-8218-709107a1920&title=&width=593.6" alt="image.png"><br>A</p><div class="code-wrapper"><pre><code class="hljs java">产品等级是同一产品族之间的划分，主要是由产品构造类决定的</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>课程作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git</title>
    <link href="/2024/01/26/git%E5%AD%A6%E4%B9%A0_/"/>
    <url>/2024/01/26/git%E5%AD%A6%E4%B9%A0_/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><a href="https://git-scm.com/book/zh/v2">Git - Book</a><br>复习网站：<a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a><br>学习了2章，3章，5章节，7.7，10章节<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694851764121-4931152c-89b8-41b1-8772-27908a44bfc4.png#averageHue=%231b1a18&clientId=u81092788-658c-4&from=paste&height=253&id=uf2543904&originHeight=316&originWidth=778&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=61054&status=done&style=none&taskId=u0d25545a-7255-43e8-8353-acb932da1e9&title=&width=622.4" alt="image.png"><br>1.移除git追踪的文件时用命令git rm，这样不仅删除了文件，还解除了git对文件的追踪。如果文件是修改后被存在暂存区的，或者是已经存在暂存区的文件又被修改了的文件，在删除的时候要加上f选项。用rm命令或者手动删除的，虽然可以删除文件但是无法解除git对文件的追踪，会在后续的提交一直显示该文件已经被删除了，而git rm命令会在下次提交的时候不在显示该文件被删除了。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694856856723-1319af73-7170-4b23-99cc-86fc1f8be641.png#averageHue=%231b1917&clientId=u81092788-658c-4&from=paste&height=248&id=u0e8e064c&originHeight=310&originWidth=718&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=57204&status=done&style=none&taskId=uafc22be3-7e18-4bd0-90d6-91078523be0&title=&width=574.4" alt="image.png"><br>git追踪的名字改名字，要使用git mv命令。如果直接使用mv命令，是无法成功的，会显示改名后的文件是git没有追踪的文件。因为git跟踪的文件改名会更改元数据的，而元数据是无法反馈在界面或者说是无法反馈出来的。<br>所有需求在改名的时候，需要把要改名的文件的内容复制到新文件（你要更改的名字），然后删除原文件，跟踪原文件。<br>如果直接手动更改了原文件的名字，那么git将无法识别更改后的文件。<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694867151569-eef3cc98-beed-419b-ada5-f55fed1e5227.png#averageHue=%23f5f3ef&clientId=u81092788-658c-4&from=paste&height=224&id=ub18a2340&originHeight=280&originWidth=967&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=106734&status=done&style=none&taskId=u944e3f20-a11b-4d6c-9040-3705b8d4ac1&title=&width=773.6" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs pgsql">git <span class="hljs-keyword">commit</span> <span class="hljs-comment">--amend//amend是修订的意思，这里的含义是修改上次的提交，修改前的提交并不会出现在</span>仓库历史版本中。</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694867688042-83d27e59-588b-49cf-ae1e-fef44a053ea7.png#averageHue=%23a9a8a5&clientId=u81092788-658c-4&from=paste&height=372&id=uf28d5379&originHeight=465&originWidth=1331&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=107932&status=done&style=none&taskId=ufa17b119-0801-4ce5-9403-b0f40cb4346&title=&width=1064.8" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git checkout -- CONTRIBUTING.md<span class="hljs-comment">//该命令会撤销你的修改，如果你修改的文件在本次提交内（还未提交）</span>但是已经放在暂存区了，这个时候是把文件恢复到暂存区的样子；如果修改的文件还没有放在暂存区那么文件恢复到上次提交的样子。或者这样说是恢复到上次跟踪到的地方（放在暂存区还未提交，git刚刚跟踪到那个地方，会恢复到那个地方；没有放在暂存区git跟踪到上次提交的地方，恢复到上次提交的地方）</code></pre></div><p><a href="https://www.modb.pro/db/225709">【Git】第九章：深度图解分支内部原理-远程分支 - 墨天轮</a><br>git pull 实际上是git fetch加上git merge是同步远程分支然后在合并。<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694934522691-71df53be-98f6-40ea-85bc-9b2b4792739b.png#averageHue=%23f1eee8&clientId=udb0f25dd-435c-4&from=paste&height=231&id=ue71102fc&originHeight=289&originWidth=964&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=88277&status=done&style=none&taskId=u93b8d9ab-5842-4e77-9907-5a6dcac1f1a&title=&width=771.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694934700477-3cfa417f-0b3c-4320-b83f-c46bbcadb0c9.png#averageHue=%23f6f5eb&clientId=udb0f25dd-435c-4&from=paste&height=322&id=u9284581e&originHeight=402&originWidth=1029&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=129142&status=done&style=none&taskId=ufbd4d8c8-0c7d-46a0-b8da-74c0ac394e0&title=&width=823.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694958358452-2b6e61f5-beac-4512-9bf1-4f236f4e7138.png#averageHue=%2313110e&clientId=udb0f25dd-435c-4&from=paste&height=122&id=u4ec6ea93&originHeight=153&originWidth=757&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=37733&status=done&style=none&taskId=u3929d3e9-ee84-4544-aaaa-7737fd77856&title=&width=605.6" alt="image.png"></p><h2 id="IDEA中使用git"><a href="#IDEA中使用git" class="headerlink" title="IDEA中使用git"></a>IDEA中使用git</h2><p><a href="https://www.jetbrains.com/help/idea/using-git-integration.html">Git | IntelliJ IDEA</a><br>VCS是版本控制器的缩写。<br>1.只能忽略未版本化的文件，即您在未版本化文件更改列表中看到的文件。如果文件已添加到Git但未提交，您可以在本地更改视图中右键单击它并选择回滚。<br>2.要想把某个文件忽视其变更，可以右击该文件选中git-&gt;加入忽略文件中（**.gitignore或者.git&#x2F;info&#x2F;exclude),已经添加到暂缓区的可以回滚然后在添加到忽视文件中**<br><strong>3.</strong></p><h1 id="git总结："><a href="#git总结：" class="headerlink" title="git总结："></a>git总结：</h1><h2 id="基础："><a href="#基础：" class="headerlink" title="基础："></a>基础：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695093648434-40903160-f629-416f-8bb7-cad177336ee6.png#averageHue=%231797a0&clientId=u0acf05c0-4016-4&from=paste&id=uafc3becb&originHeight=330&originWidth=800&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u34fb8e1e-a061-40e5-b77f-93c24f4195a&title="><br>2.查看当前文件状态：<br>git status命令；<br>git status -s显示的是简洁信息；输出的例子有：</p><div class="code-wrapper"><pre><code class="hljs 1c">MM Rakefile<span class="hljs-comment">//左栏指明了暂存区的状态，右栏指明了工作区的状态。</span></code></pre></div><p>git add命令不仅有把文件添加到暂存区的功能还有，把未追踪的文件添加到暂存区然后追踪的功能。<br>3.忽略文件的格式：</p><div class="code-wrapper"><pre><code class="hljs perl">所有空行或者以 <span class="hljs-comment"># 开头的行都会被 Git 忽略。</span>可以使用标准的 <span class="hljs-keyword">glob</span> 模式匹配，它会递归地应用在整个工作区中。匹配模式可以以（/）开头防止递归。匹配模式可以以（/）结尾指定目录。要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。</code></pre></div><p>4.移除文件不仅移除该文件还要移除git对它的跟踪：git rm;<br>5.移动文件:git mv<br>6.查看提交历史：git log<br>7.撤销上次提交：git commit –amend<br>8.取消暂缓文件：git restore –staged 文件名(要从暂缓区移除的文件）<br>9.撤销文件修改：git checkout – 文件名；将该文件的内容回滚到上个阶段（暂存区-&gt;仓库的历史）<br>10.</p><h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><h2 id="记Git报错-refusing-to-merge-unrelated-histories"><a href="#记Git报错-refusing-to-merge-unrelated-histories" class="headerlink" title="记Git报错-refusing to merge unrelated histories"></a>记Git报错-refusing to merge unrelated histories</h2><p>场景：我在远程创建了一个空仓库，在本地创建了一个新项目（没有创建本地仓库），这个时候在该项目下创建本地仓库和远程仓库关联起来。这里有个问题是：本地仓库和远程仓库的历史版本是不相干的，这个时候使用pull命令再push会报上面的错误，原因是当你pull远程的命令的时候它并没有合并远程分支到当前分支上。这个时候使用git pull origin master –allow-unrelated-histories允许不相干的分支合并就可以解决了。<br>1.git brach是创建一个新分支，这个时候提交的话！如果没有利用git checkout 切换分支的话，那么仍然是main指针前进指向新提交内容，但是新分支的指针不前进。</p><h2 id="合并分支和变基分支的变化："><a href="#合并分支和变基分支的变化：" class="headerlink" title="合并分支和变基分支的变化："></a>合并分支和变基分支的变化：</h2><div class="code-wrapper"><pre><code class="hljs css">Git合并两个分支的时候，合并的版本是包含两个分支的共同变化的。Git会使用一种叫做三向合并的算法，来比较两个分支和它们的最近共同祖先的差异，并尝试自动地合并这些差异。如果两个分支对同一个文件的同一部分做了不同的修改，那么就会产生合并冲突，需要手动解决。Git也提供了一些选项和工具来帮助解决合并冲突，比如忽略空白改动，或者使用图形化的合并工具。具体地说，git rebase <span class="hljs-selector-tag">main</span>的过程是这样的：•  首先，git会找到当前分支和<span class="hljs-selector-tag">main</span>分支的最近共同祖先版本，也就是两个分支开始分叉的地方。•  然后，git会计算出当前分支从最近共同祖先版本到最新版本之间的每一个提交所引入的差异，并将这些差异保存到临时文件中。•  接着，git会将当前分支重置到<span class="hljs-selector-tag">main</span>分支的最新版本，也就是将当前分支指向<span class="hljs-selector-tag">main</span>分支。•  最后，git会依次将临时文件中保存的差异应用到当前分支上，从而创建出一系列新的提交。这些新的提交和原来的提交在内容上是一样的，但在历史上是不同的。</code></pre></div><p>1.HEAD是一个指针，指向当前分支的指针，可以使用git checkout ID把head的指向改变为指向ID这个版本<br>2.<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695776264317-5bb81b57-a245-4e6b-85c2-da08b545ac11.png#averageHue=%234b4949&clientId=ua1e39512-de6b-4&from=paste&height=44&id=u0c55deb5&originHeight=55&originWidth=252&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=2706&status=done&style=none&taskId=u3d797991-a01d-4882-b36a-3326594b0b9&title=&width=201.6" alt="image.png">这里是是使用了相对引用，是把pushed分支的前一个版本添加到当前HEAD指向分支的后面，注意这里是添加到HEAD指向的后面，不一定是pushed指向的后面。<br>3.git branch -f loacl HEAD^如果当前工作的指针也就是HEAD和loacl指向的是同一个版本，那么使用改命令，不仅loacl会移动，HEAD也会移动。<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695781332439-26a6a4f2-08b8-4b09-bbad-b368e60e66ae.png#averageHue=%235cbafa&clientId=ua1e39512-de6b-4&from=paste&height=510&id=ufe787cba&originHeight=638&originWidth=773&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=62017&status=done&style=none&taskId=ua3403ebe-e957-40f0-8c0d-7a745a4f08c&title=&width=618.4" alt="image.png"><br>2，git commit –amend是把当前工作的分支也就是HEAD指向的版本 从仓库拿出来放在暂存区，然后将上次提交的内容和暂存区的内容合并后自动提交，不用在执行git commit提交；这次提交后的HEAD执行的内容是新提交的版本，原先的版本被新版的替换了，不留存于版本库中。一般该命令用来修改提交注释或者是本版本忘记了其他文件的提交（这个时候要先把其他文件放在暂存区中，然后之前提交的版本就会和暂存区合并提交）。<br>注意它和git checkout –文件名，它的作用是撤销已经修改的文件。<br>3.git checkout v1;可以将HEAD指向v1标签所指向的提交。<br>4.本地新建的分支如果没有往远程仓库push过，那么远程就没有创建与之对应的origon&#x2F;新分支，也就无法pull，特别是像master分支一样可以pull合并。<br>5.本地仓库能push成功的条件是origon&#x2F;master和远程仓库的master是指向同一个版本。<br>6.本地仓库新建了一个分支这个时候pull是会失败的，原因是远程没有对应的新分支，这个时候要先push（别人没有更改远程的仓库）一下，或者只能fetch.<br>7.git fetch和git pull的区别是：git fetch是拉取分支，但是当前的HEAD不会移动，追踪远程master分支的origion&#x2F;master会移动。而git pull 是拉取远程的分支然后在合并，合并后HEAD会向前移动<br>8.<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695822776381-490c9ff6-c940-446e-940a-c77b5ae91782.png#averageHue=%234f4d4b&clientId=ue1b5eac7-b8a3-4&from=paste&height=34&id=ud425af4e&originHeight=42&originWidth=339&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=3422&status=done&style=none&taskId=uf23a11c4-f91f-4ff7-9e67-132f9637d81&title=&width=271.2" alt="image.png">o&#x2F;main是一个指针，它是一个跟踪远程main分支而生的。当我们git fetch的时候它会检查o&#x2F;main 和远程的main是否是有关联的（o&#x2F;main对应远程的main,或者远程的main的前面的版本）如果o&#x2F;main指向的是远程main的历史版本，那么就会把远程的差的版本拉取到本地，o&#x2F;main指向拉取到分支的末端，但是main（拉取时所在版本的其他指针）不会移动；如果o&#x2F;main领先远程的main就会提示本地的已经是最新的了。git checkout -b side o&#x2F;main 这里的意思是生成新分支side，其side追踪o&#x2F;main，也就是追踪远程仓库的main;如果side分支没有追踪远程的o&#x2F;main那么下次提交的时候会自动生成o&#x2F;main，远程仓库生成side,本地的o&#x2F;side追踪远程仓库的side.<br>9.<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695824475594-a24c8184-71b5-4632-830d-634a6d29f8c5.png#averageHue=%232fe83c&clientId=ue1b5eac7-b8a3-4&from=paste&height=350&id=u5ce064a4&originHeight=437&originWidth=1089&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=66675&status=done&style=none&taskId=ucb12b909-4dad-44f4-b7fd-8d66a690611&title=&width=871.2" alt="image.png">(c0也就是HEAD指向的版本，该版本和其祖先版本没有任何分支追踪远程仓库，无法同步到远程。）<br>10.<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695825391151-927128f6-ba70-4472-8af2-bf8399dbb690.png#averageHue=%23494949&clientId=ue1b5eac7-b8a3-4&from=paste&height=349&id=uc3fbd5bc&originHeight=436&originWidth=1129&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=106871&status=done&style=none&taskId=u9c39a310-f7f3-4baf-9cd2-d0d77d0f24d&title=&width=903.2" alt="image.png"><br>git origin main：切换到本地的main分支然后寻找本地的origin&#x2F;main映射，将origin&#x2F;main和main之间的内容同步到远程仓库。<br>11.远程跟踪分支的理解：</p><div class="code-wrapper"><pre><code class="hljs css">git 中的 origin/<span class="hljs-selector-tag">main</span> 是一个远程跟踪分支，它表示 origin 远程仓库的 <span class="hljs-selector-tag">main</span> 分支在本地的映射。它可以让您知道 origin 远程仓库的 <span class="hljs-selector-tag">main</span> 分支的状态和进度，但是它不是一个真正的分支，您不能在它上面进行开发或提交。git 中的 origin/<span class="hljs-selector-tag">main</span> 和 <span class="hljs-selector-tag">main</span> 的区别是：•  origin/<span class="hljs-selector-tag">main</span> 是远程跟踪分支，<span class="hljs-selector-tag">main</span> 是本地分支。•  origin/<span class="hljs-selector-tag">main</span> 是只读的，<span class="hljs-selector-tag">main</span> 是可读写的。•  origin/<span class="hljs-selector-tag">main</span> 是 origin 远程仓库的 <span class="hljs-selector-tag">main</span> 分支在本地的映射，<span class="hljs-selector-tag">main</span> 是本地仓库的一个分支。</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>尚硅谷mysql复习</title>
    <link href="/2024/01/26/mysql%E5%A4%8D%E4%B9%A0_/"/>
    <url>/2024/01/26/mysql%E5%A4%8D%E4%B9%A0_/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h1 id="1-概述："><a href="#1-概述：" class="headerlink" title="1.概述："></a>1.概述：</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695250700734-5c65b24d-8115-4a2e-b034-03dddcc3ad6d.png#averageHue=%23fbfbfa&clientId=uabc25cb5-41c6-4&from=paste&height=578&id=ubccc0a00&originHeight=723&originWidth=1093&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=191108&status=done&style=none&taskId=u563057fa-c3f2-4a7c-a433-746a3006796&title=&width=874.4" alt="image.png"><br>2.一对一关系：<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695250726047-ac4cf78b-fd1b-49a8-a71e-117395ada39c.png#averageHue=%23fefefe&clientId=uabc25cb5-41c6-4&from=paste&height=98&id=u7a40bca6&originHeight=123&originWidth=811&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=30202&status=done&style=none&taskId=ue52e3810-8b6f-47e1-a55a-ab46e295007&title=&width=648.8" alt="image.png"><br>3.一对多关系：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695250811988-d6ecf026-5dd2-4364-9084-d74d759489a0.png#averageHue=%23fbfbfb&clientId=uabc25cb5-41c6-4&from=paste&height=274&id=u65e41a03&originHeight=342&originWidth=873&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=55998&status=done&style=none&taskId=u2d33b632-05ae-46f5-9ee5-352ffb1bd8f&title=&width=698.4" alt="image.png"><br>4.多对多关系：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695250851159-7206dab2-edd0-4d95-b3c3-f48051321198.png#averageHue=%23fefefe&clientId=uabc25cb5-41c6-4&from=paste&height=53&id=n6xD6&originHeight=66&originWidth=978&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=28803&status=done&style=none&taskId=uf0ffcec8-db8b-4f98-a6b4-5b2512fea7c&title=&width=782.4" alt="image.png">5.自我引用：</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>2.mysql的安装：</p><h2 id="1-查看mysql的版本："><a href="#1-查看mysql的版本：" class="headerlink" title="1.查看mysql的版本："></a>1.查看mysql的版本：</h2><p>方法一：mysql –version<br>方法二：select version();</p><h2 id="2-5-7的mysql安装后会有字符集的问题的解决："><a href="#2-5-7的mysql安装后会有字符集的问题的解决：" class="headerlink" title="2.5.7的mysql安装后会有字符集的问题的解决："></a>2.5.7的mysql安装后会有字符集的问题的解决：</h2><p>1.查看表的创建信息：show create table 表名词；可以发现使用的是latin1字符集<br>2.查看数据库的创建信息：show create table 数据库名；发现也是使用的拉丁字符集<br>3.修改mysql中的my.ini配置文件：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695251335723-0489211f-43b1-4367-ba4f-b6dcfbb3e3d0.png#averageHue=%23f8f7f7&clientId=uabc25cb5-41c6-4&from=paste&height=152&id=u9061f8ad&originHeight=190&originWidth=620&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=27468&status=done&style=none&taskId=u757058d7-5953-4558-a571-37059d34ca9&title=&width=496" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695251425060-c3a0aed1-8290-477a-87a7-d7248cba67dd.png#averageHue=%23e1ece7&clientId=uabc25cb5-41c6-4&from=paste&height=92&id=u375f73ec&originHeight=115&originWidth=952&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=40467&status=done&style=none&taskId=ucf6c9d99-08cf-41aa-8a31-26d58db22b0&title=&width=761.6" alt="image.png"><br>BOM头：</p><div class="code-wrapper"><pre><code class="hljs vbnet">BOM（<span class="hljs-type">byte</span>-<span class="hljs-keyword">order</span> mark），即字节顺序标记，它是插入到以UTF-<span class="hljs-number">8</span>、UTF16或UTF-<span class="hljs-number">32</span>编码<span class="hljs-keyword">Unicode</span>文件开头的特殊标记，用来识别<span class="hljs-keyword">Unicode</span>文件的编码类型BOM的作用是告诉文本处理程序，这个文件是用哪种<span class="hljs-keyword">Unicode</span>编码方式保存的，以及字节的顺序是怎样的BOM的存在有利有弊。有利的一面是，它可以帮助文本处理程序正确地识别<span class="hljs-keyword">Unicode</span>文件的编码方式，避免乱码或错误的解释。有弊的一面是，它可能会被一些不支持BOM的程序误认为是普通字符，导致出现多余的字符或者破坏文件格式</code></pre></div><p>4.重启服务；<br>5：查看编码命令<br>show variables like ‘character_%’;<br>show variables like ‘collation_%’;</p><div class="code-wrapper"><pre><code class="hljs xquery"><span class="hljs-keyword">collation</span><span class="hljs-number">_</span>开头的系统变量是与排序规则相关的，排序规则是一种规定字符如何比较和排序的规则</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695251958132-c2fb9a7a-595e-433f-a4b3-b10ad009e04c.png#averageHue=%23fefefe&clientId=uabc25cb5-41c6-4&from=paste&height=65&id=u8e9a89f2&originHeight=81&originWidth=944&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=31519&status=done&style=none&taskId=uba349976-9a12-41b3-8b65-c38ab2a1781&title=&width=755.2" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> student charset utf8; #修改表字符编码为UTF8 <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> student modify <span class="hljs-type">name</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) charset utf8; #修改字段字符编码为UTF8，<span class="hljs-meta">#alter table student 表示要对student表进行修改。</span>#•  modify <span class="hljs-type">name</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) 表示要将<span class="hljs-type">name</span>列的数据类型修改为<span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)，#即可变长字符串，最大长度为<span class="hljs-number">20</span>个字符。<span class="hljs-keyword">alter</span> <span class="hljs-keyword">database</span> <span class="hljs-number">0728</span>db charset utf8; #修改数据库的字符编码为utf8</code></pre></div><h2 id="root用户密码忘记，重置的操作"><a href="#root用户密码忘记，重置的操作" class="headerlink" title="root用户密码忘记，重置的操作"></a>root用户密码忘记，重置的操作</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695251879983-e5885394-8320-4725-9b6a-c12927a5457b.png#averageHue=%23fefefe&clientId=uabc25cb5-41c6-4&from=paste&height=193&id=udfc7bbea&originHeight=241&originWidth=1070&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=126370&status=done&style=none&taskId=ufa199b19-c272-4673-98d0-d97eded05ca&title=&width=856" alt="image.png"></p><h1 id="基本的select语句："><a href="#基本的select语句：" class="headerlink" title="基本的select语句："></a>基本的select语句：</h1><h2 id="1-注-释"><a href="#1-注-释" class="headerlink" title="1.注 释"></a>1.注 释</h2><div class="code-wrapper"><pre><code class="hljs livecodeserver">单行注释：<span class="hljs-comment">#注释文字(MySQL特有的方式)</span>单行注释：<span class="hljs-comment">-- 注释文字(--后面必须包含一个空格。) </span>多行注释：<span class="hljs-comment">/* 注释文字         */</span></code></pre></div><p>2.数据库或者表命名的时候：如果是使用了系统的保留字体，在使用SQL语句的时候，要对该库或者表用<code>（着重号）引起来; #其中order使用``飘号，因为order和系统关键字或系统函数名等预定义标识符重名了  CREATE TABLE </code>order&#96;(<br>3.数据导入：<br>在命令行客户端登录mysql，使用source指令导入：<br>mysql&gt; source d:\mysqldb.sql；只有命令行可以怎样，图形化界面这个命令不行；图像化界面使用运行sql脚本的方式导入；<br>4.别名不是一定要使用引号，但是当别名有空格的时候必须要用双引号引起来。<br>5.在SELECT语句中使用关键字DISTINCT去除重复行</p><div class="code-wrapper"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> department_id <span class="hljs-keyword">FROM</span>   employees;</code></pre></div><p>DISTINCT 其实是对后面所有列名的组合进行去重；你能看到最后的结果是 74 条，因为这 74 个部<br>门id不同，都有 salary 这个属性值。如果你想要看都有哪些不同的部门（department_id），只需<br>要写 DISTINCT department_id 即可，后面不需要再加其他的列名了。<br>6.空值参与运算<br>所有运算符或列值遇到null值，运算的结果都为null；空值不等于空字符串。一个空字符串的长度是  0，而一个空值的长 度是空。而且，在 MySQL 里面，空值是占用空间的。<br>7.SQL 中的 SELECT 语法的确提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个<br>固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。<br>比如说，我们想对 employees 数据表中的员工姓名进行查询，同时增加一列字段  corporation ，这个<br>字段固定值为“尚硅谷”，可以这样写：</p><div class="code-wrapper"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;尚硅谷&#x27;</span> <span class="hljs-keyword">as</span> corporation, last_name <span class="hljs-keyword">FROM</span> employees;</code></pre></div><p>8.显示表结构：</p><div class="code-wrapper"><pre><code class="hljs abnf">DESCRIBE employees<span class="hljs-comment">; </span>或DESC employees<span class="hljs-comment">;</span></code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695252873557-bfbf9f43-c47b-443a-bd23-c28a7a610dfa.png#averageHue=%23fafafa&clientId=uabc25cb5-41c6-4&from=paste&height=620&id=u012482f9&originHeight=775&originWidth=1003&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=209714&status=done&style=none&taskId=u360f8b85-4401-4f2c-8c22-9ae4140782f&title=&width=802.4" alt="image.png"><br>1.select，from之前的语句后跟的是要查询的列（列的名字常以,分割开来，列运行有空格），也就是后面跟是结果集中的列。</p><h1 id="运算符："><a href="#运算符：" class="headerlink" title="运算符："></a>运算符：</h1><p>1.在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数<br>值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（补充：MySQL<br>中字符串拼接要使用字符串函数CONCAT()实现）<br>2.在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL。<br>3.．等号运算符<br>等号运算符（&#x3D;）判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回<br>0。<br>在使用等号运算符时，遵循如下规则：<br>如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的<br>是每个字符串中字符的ANSI编码是否相等。<br>如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。<br>如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。<br>如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。<br>对比：SQL中赋值符号使用 :&#x3D;<br>使用安全等于运算符时，两边的操作数的值都为NULL时，返回的结果为1而不是NULL，其他<br>返回结果与等于运算符相同（与普通等于运算符的区别是：在比较NULL&#x3D;&#x3D;NULL的时候，普通等于运算符返回结果为NULL,但是安全运算符返回的是1）<br>4.。不等于运算符不能判断NULL值。如果两边的值有任意一个为NULL，<br>或两边都为NULL，则结果为NULL。<br>5.<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695269424521-6801e70f-6310-4c36-9c99-1cadace1e66d.png#averageHue=%23efefef&clientId=uabc25cb5-41c6-4&from=paste&height=618&id=ua63851ab&originHeight=772&originWidth=1277&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=409465&status=done&style=none&taskId=u06ca05ca-9f7f-4ad6-bbec-318aa41aeb1&title=&width=1021.6" alt="image.png"><br>6.XOR异或运算符号：</p><div class="code-wrapper"><pre><code class="hljs gauss"><span class="hljs-keyword">XOR</span>是逻辑异或运算符，它用来判断两个操作数是否不同。它的语法规则如下：•  如果两个操作数都是<span class="hljs-built_in">NULL</span>，那么返回<span class="hljs-built_in">NULL</span>。•  如果一个操作数是<span class="hljs-built_in">NULL</span>，另一个不是<span class="hljs-built_in">NULL</span>，那么返回<span class="hljs-built_in">NULL</span>。•  如果两个操作数都不是<span class="hljs-built_in">NULL</span>，那么如果它们的逻辑真假值相异，则返回<span class="hljs-number">1</span>，否则返回<span class="hljs-number">0</span>。<span class="hljs-keyword">XOR</span>的作用是用来进行条件判断或者数据加密等场景。例如：•  如果要查询满足A或B条件，但不能同时满足的数据，可以使用 <span class="hljs-built_in">WHERE</span> A <span class="hljs-keyword">XOR</span> B。•  如果要对明文和密钥进行异或运算，得到密文，可以使用 text <span class="hljs-keyword">XOR</span> <span class="hljs-built_in">key</span>。•  如果要对两个变量进行交换值，不需要额外的空间，可以使用x = x <span class="hljs-keyword">XOR</span> y; y = x <span class="hljs-keyword">XOR</span> y; x = x <span class="hljs-keyword">XOR</span> y;。</code></pre></div><h1 id="时间："><a href="#时间：" class="headerlink" title="时间："></a>时间：</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695287986568-9a06409d-7eed-4fcd-9987-9c63e519fe8e.png#averageHue=%23efece1&clientId=uabc25cb5-41c6-4&from=paste&height=268&id=ue0297931&originHeight=335&originWidth=484&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=91386&status=done&style=none&taskId=u3a870e80-b827-419b-80e5-4532a53c04c&title=&width=387.2" alt="image.png"><br><a href="https://www.cnblogs.com/hider/p/11726690.html">MySQL学习笔记：count(1)、count(*)、count（字段）的区别 - Hider1214 - 博客园</a><br><a href="https://www.cnblogs.com/birdy-silhouette/p/14011817.html">【MySQL】连接查询 以及 on、where、Having的区别 - 至安 - 博客园</a></p><h1 id="子查询："><a href="#子查询：" class="headerlink" title="子查询："></a>子查询：</h1><ol><li><div class="code-wrapper"><pre><code class="hljs markdown">子查询（内查询）在主查询之前一次执行完成。<span class="hljs-bullet">-</span> 子查询的结果被主查询（外查询）使用 。<span class="hljs-bullet">-</span> 注意事项<span class="hljs-bullet">  -</span> 子查询要包含在括号内<span class="hljs-bullet">  -</span> 将子查询放在比较条件的右侧<span class="hljs-bullet">  -</span> 单行操作符对应单行子查询，多行操作符对应多行子查询</code></pre></div><div class="code-wrapper"><pre><code class="hljs routeros">3. 子查询的分类角度1：从内查询返回的结果的条目数   单行子查询  vs  多行子查询角度2：内查询是否被执行多次   相关子查询  vs  不相关子查询，一般相关子查询返回的是多行数据，而不相干子查询返回的是一行数据    比如：相关子查询的需求：查询工资大于本部门平均工资的员工信息。       不相关子查询的需求：查询工资大于本公司平均工资的员工信息。 */<span class="hljs-comment">#子查询的编写技巧（或步骤）：① 从里往外写  ② 从外往里写</span><span class="hljs-comment">#4. 单行子查询</span><span class="hljs-comment">#4.1 单行操作符： =  !=  &gt;   &gt;=  &lt;  &lt;= </span>子查询返回值的结果为空的时候，子查询不返回任何行，相应的外查询也不返回任何行。查询某一行为空的条件的写法：where xxx IS <span class="hljs-literal">NULL</span>而不是<span class="hljs-attribute">xxx</span>=<span class="hljs-literal">NULL</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> department_id<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<span class="hljs-keyword">HAVING</span> AVG(salary) = (<span class="hljs-keyword">SELECT</span> MIN(avg_sal)<span class="hljs-keyword">FROM</span>(<span class="hljs-keyword">SELECT</span> AVG(salary) avg_sal<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id) t_dept_avg_sal);#上面的t_dept_avg_sal是子查询结果集表的别名#<span class="hljs-keyword">SELECT</span> department_id<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">where</span> salary = (<span class="hljs-keyword">SELECT</span> MIN(avg_sal)<span class="hljs-keyword">FROM</span>(<span class="hljs-keyword">SELECT</span> AVG(salary) avg_sal<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id) t_dept_avg_sal);#这个查询和上面那个查询的区别：子查询是样的，都是返回部门平均工资最低的平均工资，下面这个是拿原先中的表的所有行去去和子查询# 的结果对比，而上面那个是把原先中的行进行分组后，在计算每组的AVG，生成新列AVG(salary)和新的结果集，然后让AVG和子查询的结果比较。#后面的查询是大于最低部门平均工资的部门的员工他所属的部门ID</code></pre></div><div class="code-wrapper"><pre><code class="hljs n1ql">1.子查询使用到了外表的数据2.执行步骤：a.先把外边的要查询的一条数据放进子查询中；b.然后根据子查询的条件决定是否返回该行和返回什么c.重复上述步骤3.在<span class="hljs-keyword">SELECT</span>中，除了<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 和 <span class="hljs-keyword">LIMIT</span>之外，其他位置都可以声明子查询！</code></pre></div></li></ol><h1 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h1><p><a href="https://zhuanlan.zhihu.com/p/144120579">MySQL 数据类型之浮点</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695351637833-1d4dea3d-4647-47ec-9199-ce173dcf69d6.png#averageHue=%23fbfafa&clientId=uc4f803c3-2d17-4&from=paste&height=198&id=ue3fa01fe&originHeight=247&originWidth=1161&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=73113&status=done&style=none&taskId=u8cfa6b61-b05f-4804-870e-43fa1186040&title=&width=928.8" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs sql">代码运行 （MySQL）：<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t3 (d1 <span class="hljs-type">decimal</span>(<span class="hljs-number">5</span>,<span class="hljs-number">2</span>),d2 <span class="hljs-keyword">double</span>(<span class="hljs-number">5</span>,<span class="hljs-number">2</span>),d3 <span class="hljs-type">float</span>(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>),d4 <span class="hljs-keyword">double</span>, d5 <span class="hljs-type">float</span>,d6 <span class="hljs-type">decimal</span>)<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t3<span class="hljs-keyword">values</span>(<span class="hljs-number">23.432</span>,<span class="hljs-number">23.432</span>,<span class="hljs-number">23.432</span>,<span class="hljs-number">23.432</span>,<span class="hljs-number">23.432</span>,<span class="hljs-number">23.432</span>)<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t3;运行结果：<span class="hljs-number">23.43</span>(后面变成两位小数) <span class="hljs-number">23.43</span>（后面变成两位小数）<span class="hljs-number">23.432</span> （浮点，后面三位）<span class="hljs-number">23.432</span>（<span class="hljs-keyword">double</span> 不变），<span class="hljs-number">23.432</span>（<span class="hljs-type">float</span> 不变），<span class="hljs-number">23</span> （<span class="hljs-type">decimal</span> 没有设定小数点，直接没有小数点后面的数值了）</code></pre></div><div class="code-wrapper"><pre><code class="hljs pgsql">IFNULL(note,<span class="hljs-string">&#x27;合计总量&#x27;</span>)：使用 IFNULL 函数，如果 note 字段为 <span class="hljs-keyword">NULL</span>，将其替换为 <span class="hljs-string">&#x27;合计总量&#x27;</span>。<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">ROLLUP</span> 子句生成包括汇总行的结果，就是新增一行，这一行是统计该列的和，<span class="hljs-keyword">with</span> pollup不能和<span class="hljs-keyword">order</span><span class="hljs-keyword">by</span> 同时使用<span class="hljs-keyword">SELECT</span> IFNULL(note,<span class="hljs-string">&#x27;合计总量&#x27;</span>) <span class="hljs-keyword">AS</span> note,COUNT(*)<span class="hljs-keyword">FROM</span> books<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> note <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">ROLLUP</span>;</code></pre></div><p>枚举：<br>约束：</p><div class="code-wrapper"><pre><code class="hljs sas"><span class="hljs-comment">/*</span><span class="hljs-comment">1. 基础知识</span><span class="hljs-comment">1.1 为什么需要约束？ 为了保证数据的完整性！</span><span class="hljs-comment"></span><span class="hljs-comment">1.2 什么叫约束？对表中字段的限制。</span><span class="hljs-comment"></span><span class="hljs-comment">1.3 约束的分类：</span><span class="hljs-comment"></span><span class="hljs-comment">角度1：约束的字段的个数</span><span class="hljs-comment">单列约束 vs 多列约束</span><span class="hljs-comment"></span><span class="hljs-comment">角度2：约束的作用范围</span><span class="hljs-comment"></span><span class="hljs-comment">列级约束：将此约束声明在对应字段的后面</span><span class="hljs-comment">表级约束：在表中所有字段都声明完，在所有字段的后面声明的约束</span><span class="hljs-comment"></span><span class="hljs-comment">角度3：约束的作用（或功能）</span><span class="hljs-comment"></span><span class="hljs-comment">① not null (非空约束)</span><span class="hljs-comment">② unique  (唯一性约束)</span><span class="hljs-comment">③ primary key (主键约束)</span><span class="hljs-comment">④ foreign key (外键约束)</span><span class="hljs-comment">⑤ check (检查约束)</span><span class="hljs-comment">⑥ default (默认值约束)</span><span class="hljs-comment"></span><span class="hljs-comment">1.4 如何添加/删除约束？</span><span class="hljs-comment"></span><span class="hljs-comment">CREATE TABLE时添加约束</span><span class="hljs-comment"></span><span class="hljs-comment">ALTER TABLE 时增加约束、删除约束</span><span class="hljs-comment"></span><span class="hljs-comment"></span><span class="hljs-comment">*/</span>可以向声明为<span class="hljs-keyword">unique</span>的字段上添加<span class="hljs-keyword">null</span>值。而且可以多次添加<span class="hljs-keyword">null</span>#4.4 删除唯一性约束-- 添加唯一性约束的列上也会自动创建唯一索引。-- 删除唯一约束只能通过删除唯一索引的方式删除。-- 删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。-- 如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名。# 主键约束特征：非空且唯一，用于唯一的标识表中的一条记录。#MySQL的主键名总是<span class="hljs-keyword">PRIMARY</span>，就算自己命名了主键约束名也没用。#如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。#开发中，一旦主键作用的字段上声明有AUTO_INCREMENT，则我们在添加数据时，就不要给主键#对应的字段去赋值了。#当我们向主键（含AUTO_INCREMENT）的字段上添加0 或 <span class="hljs-keyword">null</span>时，实际上会自动的往上添加指定的字段的数值#7.4 ###  约束等级-- `<span class="hljs-keyword">Cascade</span>方式`：在父表上<span class="hljs-keyword">update</span>/<span class="hljs-keyword">delete</span>记录时，同步<span class="hljs-keyword">update</span>/<span class="hljs-keyword">delete</span>掉子表的匹配记录 -- `<span class="hljs-keyword">Set</span> <span class="hljs-keyword">null</span>方式`：在父表上<span class="hljs-keyword">update</span>/<span class="hljs-keyword">delete</span>记录时，将子表上匹配记录的列设为<span class="hljs-keyword">null</span>，但是要注意子表的外键列不能为<span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>  -- `No action方式`：如果子表中有匹配的记录，则不允许对父表对应候选键进行<span class="hljs-keyword">update</span>/<span class="hljs-keyword">delete</span>操作  -- `<span class="hljs-keyword">Restrict</span>方式`：同no action， 都是立即检查外键约束-- `<span class="hljs-keyword">Set</span> default方式`（在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别结论：对于外键约束，最好是采用: `<span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">CASCADE</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">RESTRICT</span>` 的方式。# MySQL5.7 不支持<span class="hljs-keyword">CHECK</span>约束，MySQL8.0支持<span class="hljs-keyword">CHECK</span>约束。</code></pre></div><h1 id="视图："><a href="#视图：" class="headerlink" title="视图："></a>视图：</h1><div class="code-wrapper"><pre><code class="hljs ada">/*<span class="hljs-number">1</span>. 视图的理解① 视图，可以看做是一个虚拟表，本身是不存储数据的。  视图的本质，就可以看做是存储起来的<span class="hljs-keyword">SELECT</span>语句  ② 视图中<span class="hljs-keyword">SELECT</span>语句中涉及到的表，称为基表③ 针对视图做DML操作，会影响到对应的基表中的数据。反之亦然。④ 视图本身的删除，不会导致基表中数据的删除。⑤ 视图的应用场景：针对于小型项目，不推荐使用视图。针对于大型项目，可以考虑使用视图。⑥ 视图的优点：简化查询; 控制数据的访问*/</code></pre></div><p>2个@@是系统变量，一个@是用户变量</p><div class="code-wrapper"><pre><code class="hljs vbnet">/*① 用户变量 ： 会话用户变量 vs 局部变量② 会话用户变量：使用<span class="hljs-string">&quot;@&quot;</span>开头，作用域为当前会话。③ 局部变量：只能使用在存储过程和存储函数中的。*/#<span class="hljs-number">1.6</span> 会话用户变量/*① 变量的声明和赋值：#方式<span class="hljs-number">1</span>：“=”或“:=”<span class="hljs-keyword">SET</span> @用户变量 = 值;<span class="hljs-keyword">SET</span> @用户变量 := 值;#方式<span class="hljs-number">2</span>：“:=” 或 <span class="hljs-keyword">INTO</span>关键字<span class="hljs-keyword">SELECT</span> @用户变量 := 表达式 [<span class="hljs-keyword">FROM</span> 等子句];<span class="hljs-keyword">SELECT</span> 表达式 <span class="hljs-keyword">INTO</span> @用户变量  [<span class="hljs-keyword">FROM</span> 等子句];② 使用<span class="hljs-keyword">SELECT</span> @变量名/*<span class="hljs-number">1</span>、局部变量必须满足：① 使用<span class="hljs-keyword">DECLARE</span>声明 ② 声明并使用在BEGIN ... <span class="hljs-keyword">END</span> 中 （使用在存储过程、函数中）③ <span class="hljs-keyword">DECLARE</span>的方式声明的局部变量必须声明在BEGIN中的首行的位置。<span class="hljs-number">2</span>、声明格式：<span class="hljs-keyword">DECLARE</span> 变量名 类型 [<span class="hljs-keyword">default</span> 值];  # 如果没有<span class="hljs-keyword">DEFAULT</span>子句，初始值为NULL<span class="hljs-number">3</span>、赋值：方式<span class="hljs-number">1</span>：<span class="hljs-keyword">SET</span> 变量名=值;<span class="hljs-keyword">SET</span> 变量名:=值;方式<span class="hljs-number">2</span>：<span class="hljs-keyword">SELECT</span> 字段名或表达式 <span class="hljs-keyword">INTO</span> 变量名 <span class="hljs-keyword">FROM</span> 表;<span class="hljs-number">4</span>、使用<span class="hljs-keyword">SELECT</span> 局部变量名;*/</code></pre></div><h1 id="mysql远程："><a href="#mysql远程：" class="headerlink" title="mysql远程："></a>mysql远程：</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695475958779-ce97c299-ccec-4afb-b6bb-ad83511fafed.png#averageHue=%23a0c284&clientId=uc25bbb35-aed9-4&from=paste&height=114&id=u7ee81ce7&originHeight=143&originWidth=918&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=34004&status=done&style=none&taskId=u937db34e-8f96-4f01-80ea-34403ed05e8&title=&width=734.4" alt="image.png"><br>这个输出的意思是，firewalld.service这个服务被屏蔽了，所以无法启动或运行。屏蔽一个服务的目的是阻止它被其他服务或用户启动。如果你想要使用firewalld.service这个服务，你需要先解除屏蔽，然后启用和启动它。后面一个命令的意思是：输出的意思是，firewalld服务没有运行，所以你无法查看它的配置。</p><h1 id="数据目录："><a href="#数据目录：" class="headerlink" title="数据目录："></a>数据目录：</h1><p>1.<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695485049682-167f3447-ea3d-4fe5-b180-342edad4b404.png#averageHue=%230d1012&clientId=uc25bbb35-aed9-4&from=paste&height=152&id=u84be0c5a&originHeight=190&originWidth=876&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=164221&status=done&style=none&taskId=ua4f37e4a-837f-4270-8c96-a8199591f0a&title=&width=700.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695485253678-5745236f-5c11-4070-9051-cb6eda65a3b4.png#averageHue=%23090a0c&clientId=uc25bbb35-aed9-4&from=paste&height=112&id=u98905650&originHeight=140&originWidth=1030&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=145763&status=done&style=none&taskId=u72e9d4ff-534a-4711-9f67-bde4445cb11&title=&width=824" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695485343294-960552d8-02fa-47c0-b138-4f38ace80fb0.png#averageHue=%23070b0e&clientId=uc25bbb35-aed9-4&from=paste&height=126&id=ubc09aaa5&originHeight=158&originWidth=532&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=38327&status=done&style=none&taskId=u769fe93b-33cc-4615-ba7b-f5ee4745f0f&title=&width=425.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695485427668-acd85df3-0f42-45b3-98d8-938bbb24da99.png#averageHue=%23040506&clientId=uc25bbb35-aed9-4&from=paste&height=109&id=u03c6d356&originHeight=136&originWidth=356&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=34784&status=done&style=none&taskId=uc56b1974-bd1b-459b-afa4-7795c536e98&title=&width=284.8" alt="image.png">（默认大小是12M，，5.7版本表的内容数据存放在“表.ibd”当中了，表.ibd”可以叫做独立表空间。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695485737884-e14cfbc4-115b-43ce-a950-88104d5678b4.png#averageHue=%230b0d0f&clientId=uc25bbb35-aed9-4&from=paste&height=48&id=uc8b1668e&originHeight=60&originWidth=174&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=9433&status=done&style=none&taskId=u0d8a9a42-c2dd-4368-b96a-d0ebec7b296&title=&width=139.2" alt="image.png">（8.0后的mysql每个表只有一个表文件，将前面的.frm和ibd文件合并了）</p><h1 id="用户权限："><a href="#用户权限：" class="headerlink" title="用户权限："></a>用户权限：</h1><p>（该用户的权限有限，只能查看该数据库）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695510619147-3157e0b2-3bac-422b-97be-b8b5028605fd.png#averageHue=%2333383b&clientId=uc25bbb35-aed9-4&from=paste&height=206&id=rmBxc&originHeight=257&originWidth=592&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=98998&status=done&style=none&taskId=u3a37fe76-0f6d-4330-a383-144915655d4&title=&width=473.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695511591693-ca4f020d-bb2b-432d-af3b-ac9320b6c662.png#averageHue=%23363a3d&clientId=uc25bbb35-aed9-4&from=paste&height=119&id=u30cb15ec&originHeight=149&originWidth=1220&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=99712&status=done&style=none&taskId=ufd2028ba-91a7-4fa1-b994-07dc774c2c0&title=&width=976" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695511722212-87df0dcd-8e1e-4e51-9f57-dd7969216181.png#averageHue=%23020203&clientId=uc25bbb35-aed9-4&from=paste&height=78&id=uc1490962&originHeight=98&originWidth=915&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=38097&status=done&style=none&taskId=u2d3cb507-e026-4d2b-b8c0-0e46246cfde&title=&width=732" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695516648577-740d5db3-c1c9-432b-867f-9449e5c0ce34.png#averageHue=%23fcfdfa&clientId=uc25bbb35-aed9-4&from=paste&height=145&id=u0e149afb&originHeight=181&originWidth=1223&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=190345&status=done&style=none&taskId=u343019a8-1a15-4bdd-ab96-e4dd41e07e1&title=&width=978.4" alt="image.png"> <img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695517501742-accebb7b-0fbe-42d2-8295-8cbb31639624.png#averageHue=%2317181a&clientId=uc25bbb35-aed9-4&from=paste&height=160&id=u8cd86cbe&originHeight=200&originWidth=761&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=49557&status=done&style=none&taskId=ud5d51f9a-8eec-44bd-8cb5-47684771e20&title=&width=608.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695520665257-b3ef02e0-6329-4839-8f68-e0c72c145fa0.png#averageHue=%23222327&clientId=uc25bbb35-aed9-4&from=paste&height=134&id=u9df42bbe&originHeight=167&originWidth=821&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=72415&status=done&style=none&taskId=u1597b197-9714-4ad8-9fae-f625ebebf8b&title=&width=656.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695521008305-96cb7cf4-51c4-4eb8-96dc-0aefd78acd32.png#averageHue=%23393c3f&clientId=uc25bbb35-aed9-4&from=paste&height=44&id=ue03d49e2&originHeight=55&originWidth=595&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=30473&status=done&style=none&taskId=u4f127de5-ddbd-46c0-9dda-b043fe48337&title=&width=476" alt="image.png">(把manager角色赋予给wang5)<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695521110554-4e5f378b-142c-481c-9296-d5b662b5fb38.png#averageHue=%23020203&clientId=uc25bbb35-aed9-4&from=paste&height=120&id=u2efd7bcb&originHeight=150&originWidth=654&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=40154&status=done&style=none&taskId=ubf06bdbe-268c-4f00-8498-346f6b73bcc&title=&width=523.2" alt="image.png"><br>(current_role() is a function that returns the name of the primary role in use for the current session;)</p><h1 id="配置文件的使用和系统环境变量："><a href="#配置文件的使用和系统环境变量：" class="headerlink" title="配置文件的使用和系统环境变量："></a>配置文件的使用和系统环境变量：</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695531192563-a72e7669-f3d1-4866-bdf5-e5fa3c11b8af.png#averageHue=%23d0d9e0&clientId=uc25bbb35-aed9-4&from=paste&height=593&id=u7a6cfadc&originHeight=741&originWidth=1280&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=189448&status=done&style=none&taskId=u123977fc-dc86-4b2b-bd7f-d31ab1907fc&title=&width=1024" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695531270532-01a4152e-b54b-49c3-9e34-8443ce5b7e85.png#averageHue=%23f1f4f1&clientId=uc25bbb35-aed9-4&from=paste&height=232&id=u994106ff&originHeight=290&originWidth=1334&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=181144&status=done&style=none&taskId=ubc9d88bc-850f-4f24-bf2c-8d4f0bcda88&title=&width=1067.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695531308728-85f8dd6e-5bc5-4075-9c1b-c534e58e4c7f.png#averageHue=%23f5ebe5&clientId=uc25bbb35-aed9-4&from=paste&height=385&id=u0e43911a&originHeight=481&originWidth=1227&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=327172&status=done&style=none&taskId=u9bac0982-12c4-42ee-927d-b243ca841b7&title=&width=981.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695531320649-21c1e187-d936-4a7c-a7ae-d3296156ba7f.png#averageHue=%23d9dfe0&clientId=uc25bbb35-aed9-4&from=paste&height=303&id=u69b046b0&originHeight=379&originWidth=1054&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=227900&status=done&style=none&taskId=u50de92e2-890e-4b5a-95f0-dd1cf367564&title=&width=843.2" alt="image.png"><br>这里的意思是使用前面的启动命令可以读取到配置文件中的哪些组，例子：上面的mysqld启动命令读取的是配置文件中[mysqld]和[server]组中的配置信息。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695531434796-a21d1a75-956c-4f7e-b10b-84a319543c26.png#averageHue=%23f4f6f4&clientId=uc25bbb35-aed9-4&from=paste&height=384&id=u4b2a5cce&originHeight=480&originWidth=1240&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=291465&status=done&style=none&taskId=u1d1232db-c403-4a58-be0e-bf00b152116&title=&width=992" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695531465339-b3cd382a-8857-4b2d-b72b-de3e569e32a3.png#averageHue=%23f3e6dd&clientId=uc25bbb35-aed9-4&from=paste&height=166&id=u0f9118e6&originHeight=208&originWidth=1227&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=152240&status=done&style=none&taskId=ud354512f-98c1-4b36-b110-93b13aba80a&title=&width=981.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695531621843-c9eb57c6-e802-4539-a1de-c1704e01109a.png#averageHue=%23f5f7f5&clientId=uc25bbb35-aed9-4&from=paste&height=374&id=u3a47bb47&originHeight=468&originWidth=1314&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=316557&status=done&style=none&taskId=u71511587-e9d2-45f2-84c2-c53a4059b97&title=&width=1051.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695531647857-fc7b01b5-32a0-4874-b5dd-3871f7e1feed.png#averageHue=%23f3f1e8&clientId=uc25bbb35-aed9-4&from=paste&height=451&id=ub9136320&originHeight=564&originWidth=1324&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=319158&status=done&style=none&taskId=u36d638d5-f3b7-4bd9-aa2d-7306d0d3485&title=&width=1059.2" alt="image.png"></p><h1 id="设置系统变量："><a href="#设置系统变量：" class="headerlink" title="设置系统变量："></a>设置系统变量：</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695531721950-ce99ac5b-0fab-4201-8029-0b57562fda6d.png#averageHue=%23e9e6db&clientId=uc25bbb35-aed9-4&from=paste&height=513&id=u962111a5&originHeight=641&originWidth=1302&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=279316&status=done&style=none&taskId=u39c78abc-9212-40b8-85ad-e31a09319d3&title=&width=1041.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695531742674-d94d1864-74f9-44c6-8f9a-cfd4b09a2a57.png#averageHue=%23e9e9eb&clientId=uc25bbb35-aed9-4&from=paste&height=386&id=u7a6b5313&originHeight=482&originWidth=935&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=190166&status=done&style=none&taskId=u3d08ea24-5ecd-41f1-9835-5acc25c2fd9&title=&width=748" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695531753502-4fbb8713-6036-4341-9dec-0ec114855c39.png#averageHue=%23dfe1df&clientId=uc25bbb35-aed9-4&from=paste&height=116&id=u30502c6c&originHeight=145&originWidth=1224&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=152346&status=done&style=none&taskId=ud42e6640-1a02-4eb9-beb5-724338bb069&title=&width=979.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695532234397-1f3b0410-404c-46f5-9c4e-e7998a944061.png#averageHue=%239e9d9a&clientId=uc25bbb35-aed9-4&from=paste&height=503&id=uf7ed4141&originHeight=629&originWidth=922&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=485330&status=done&style=none&taskId=u539dc3ca-22eb-4f14-a22f-15de886a2d0&title=&width=737.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695531964096-f7132bd2-c98c-4c2f-89f4-c14368908bcb.png#averageHue=%23fcfcf7&clientId=uc25bbb35-aed9-4&from=paste&height=394&id=uc944a2bd&originHeight=492&originWidth=1322&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=410883&status=done&style=none&taskId=ue3d49d4d-4074-41cf-bdd1-962418e5dd3&title=&width=1057.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695531983127-036263a7-89b3-4a29-a6af-b49d22938d2e.png#averageHue=%23e3e8ea&clientId=uc25bbb35-aed9-4&from=paste&height=283&id=u4ddc6826&originHeight=354&originWidth=1269&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=221876&status=done&style=none&taskId=ue9624dcb-8da9-4f70-9171-d351d74d4c3&title=&width=1015.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695532021643-e20de38a-3028-4ffb-91e9-9e2a5fb396ae.png#averageHue=%23d6d8d7&clientId=uc25bbb35-aed9-4&from=paste&height=642&id=ub38fa3a8&originHeight=802&originWidth=1259&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=443721&status=done&style=none&taskId=ud7bebb0e-bbae-4ea1-8cf6-07da818ca34&title=&width=1007.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695532037994-bdd2eff8-43b0-417f-b05f-98d5b8d10af4.png#averageHue=%23ecedef&clientId=uc25bbb35-aed9-4&from=paste&height=686&id=ude3406a5&originHeight=858&originWidth=956&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=332753&status=done&style=none&taskId=ue2a197b3-9048-4705-994f-07c6eaff29e&title=&width=764.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695532063057-fa7a5c0d-a168-4743-842e-9510f7934d26.png#averageHue=%23e9e7e2&clientId=uc25bbb35-aed9-4&from=paste&height=642&id=u1fd4f74e&originHeight=803&originWidth=1278&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=645880&status=done&style=none&taskId=u6fe4dc70-1c81-429b-8a9d-c77c59fb11b&title=&width=1022.4" alt="image.png"></p><h1 id="逻辑架构："><a href="#逻辑架构：" class="headerlink" title="逻辑架构："></a>逻辑架构：</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695532666974-882c54b5-a898-4f6d-a3cf-7c3f9b29be0d.png#averageHue=%23b1bbb6&clientId=uc25bbb35-aed9-4&from=paste&height=606&id=u9429f388&originHeight=758&originWidth=1163&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=742062&status=done&style=none&taskId=u8976cd4f-4780-43e8-b52a-690804cb28e&title=&width=930.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695532790372-df10fc94-eea5-4008-b407-b193d51ca0e7.png#averageHue=%23b2bcb8&clientId=uc25bbb35-aed9-4&from=paste&height=613&id=ueaeeb056&originHeight=766&originWidth=1127&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=762884&status=done&style=none&taskId=u3f76b7a5-55ff-400a-89f9-1a3a9244404&title=&width=901.6" alt="image.png"><br>（5.7的运行顺序图）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695533043385-c5341532-9e35-4c29-82d8-75497a821161.png#averageHue=%23bec6c0&clientId=uc25bbb35-aed9-4&from=paste&height=505&id=ubee03a33&originHeight=631&originWidth=1642&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=739411&status=done&style=none&taskId=ud400c951-61da-48b4-8c40-626985131d6&title=&width=1313.6" alt="image.png"></p><h2 id="1-Connectors"><a href="#1-Connectors" class="headerlink" title="1.Connectors:"></a>1.Connectors:</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695533125741-25f32233-b010-4221-83cd-e35e3d73670f.png#averageHue=%23d8dad6&clientId=uc25bbb35-aed9-4&from=paste&height=183&id=u349e7dfc&originHeight=229&originWidth=1212&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=272871&status=done&style=none&taskId=uea703a4d-d51f-4693-9aaf-3c855f3044c&title=&width=969.6" alt="image.png"></p><h3 id="第一层：连接层"><a href="#第一层：连接层" class="headerlink" title="第一层：连接层"></a>第一层：连接层</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695533168415-9a197062-016e-4e63-b8ed-8cbd72e14976.png#averageHue=%23fefefb&clientId=uc25bbb35-aed9-4&from=paste&height=198&id=ua8c0f09e&originHeight=248&originWidth=1264&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=224376&status=done&style=none&taskId=u0db9bd0c-7436-48e2-916d-df5a6cf8131&title=&width=1011.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695533279349-4f378722-2523-4843-8d81-1e2f424b60ad.png#averageHue=%23fefdf9&clientId=uc25bbb35-aed9-4&from=paste&height=139&id=ua98deef6&originHeight=174&originWidth=1234&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=192129&status=done&style=none&taskId=u412c05d7-b3c5-4e5f-ab46-85e167f5078&title=&width=987.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695533311041-89a433be-ae8f-4703-a4b3-c0027521b5e4.png#averageHue=%23f5f5e9&clientId=uc25bbb35-aed9-4&from=paste&height=529&id=ue07c345a&originHeight=661&originWidth=892&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=142106&status=done&style=none&taskId=uc48444d3-e15b-4e36-879a-1e2dc564bc7&title=&width=713.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695533324262-727b8435-346f-4953-ac47-17ffe247140a.png#averageHue=%23e7cdc5&clientId=uc25bbb35-aed9-4&from=paste&height=170&id=ue24308b5&originHeight=212&originWidth=1317&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=146648&status=done&style=none&taskId=udc1f396a-ff52-44a5-8a7c-ddde99b2564&title=&width=1053.6" alt="image.png"></p><h3 id="服务层："><a href="#服务层：" class="headerlink" title="服务层："></a>服务层：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695533461695-9ba846db-98b3-4e43-87cd-662d58f08c1f.png#averageHue=%23ecdad5&clientId=uc25bbb35-aed9-4&from=paste&height=380&id=udf5c54c3&originHeight=475&originWidth=1218&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=362936&status=done&style=none&taskId=u1b4ab259-d8f9-4fb1-9641-a8e51cb0104&title=&width=974.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695533474337-0e287c73-6c4a-44a4-8314-0ccdf25ba1ed.png#averageHue=%23f8efe9&clientId=uc25bbb35-aed9-4&from=paste&height=229&id=u6bacac12&originHeight=286&originWidth=1253&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=243810&status=done&style=none&taskId=u97fa9678-9dc4-40d5-8507-cd115a37460&title=&width=1002.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695533717427-bbbaa66b-eab4-4fe1-aaa5-9fd5bc319742.png#averageHue=%23fdfcf8&clientId=uc25bbb35-aed9-4&from=paste&height=347&id=u5547e26a&originHeight=434&originWidth=1290&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=325607&status=done&style=none&taskId=ua0ccd8ce-d032-4fec-96b8-44d3812aef6&title=&width=1032" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695533777613-da55bd80-c466-4b09-85d6-e798f695fa73.png#averageHue=%23f0e0da&clientId=uc25bbb35-aed9-4&from=paste&height=278&id=ue12477c7&originHeight=348&originWidth=1231&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=221720&status=done&style=none&taskId=u0c916c07-5d2c-4696-9dae-774c3173db9&title=&width=984.8" alt="image.png"><br>当第二次查询的内容和第一次是一样的，那么可以直接拿取Caches&amp;Buffers中之前缓存的结果。</p><h3 id="引擎层："><a href="#引擎层：" class="headerlink" title="引擎层："></a>引擎层：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695533989256-a0ead012-66a1-4161-8af9-acfe43731754.png#averageHue=%23fdfdf9&clientId=uc25bbb35-aed9-4&from=paste&height=278&id=u639b3c3d&originHeight=347&originWidth=1407&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=401287&status=done&style=none&taskId=udd027507-9c67-4eed-9ae5-bdcbf457080&title=&width=1125.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695535983838-9cf5ceab-02f3-4961-84c4-8b12ec31e7b7.png#averageHue=%23414342&clientId=uc25bbb35-aed9-4&from=paste&height=287&id=u9e980abe&originHeight=359&originWidth=1252&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=210927&status=done&style=none&taskId=u4642a613-210d-4fda-b0ec-730844886cd&title=&width=1001.6" alt="image.png"></p><h2 id="存储层："><a href="#存储层：" class="headerlink" title="存储层："></a>存储层：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695536034841-cc1b5749-33e7-47e4-9fe3-8bbb035485b0.png#averageHue=%23fdfcf9&clientId=uc25bbb35-aed9-4&from=paste&height=137&id=u1c9973ca&originHeight=171&originWidth=1222&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=176624&status=done&style=none&taskId=ud1c78a94-4050-4fda-9b18-464fbe4c97c&title=&width=977.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695536074579-1781fba0-5458-4315-80fa-3b41ca8a6de7.png#averageHue=%23daddc8&clientId=uc25bbb35-aed9-4&from=paste&height=287&id=uaa168cbc&originHeight=359&originWidth=797&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=85625&status=done&style=none&taskId=u83504fa4-f62e-4de8-b019-c63cf37c820&title=&width=637.6" alt="image.png"></p><h3 id="查询缓存（8-0已经抛弃了）："><a href="#查询缓存（8-0已经抛弃了）：" class="headerlink" title="查询缓存（8.0已经抛弃了）："></a>查询缓存（8.0已经抛弃了）：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695537160021-7581bf57-d895-47c6-8015-67661a16fb8e.png#averageHue=%23f3f5f2&clientId=uc25bbb35-aed9-4&from=paste&height=374&id=ud17d877f&originHeight=467&originWidth=1236&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=329084&status=done&style=none&taskId=u461afe0d-2407-4b07-934b-b32183ac9e8&title=&width=988.8" alt="image.png"></p><h3 id="解析器："><a href="#解析器：" class="headerlink" title="解析器："></a>解析器：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695537283207-798e47c8-2eaa-483d-86de-29803291ea7f.png#averageHue=%23fdfefa&clientId=uc25bbb35-aed9-4&from=paste&height=43&id=u95d797b4&originHeight=54&originWidth=719&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=37402&status=done&style=none&taskId=ue18f61cc-5566-49bd-bff5-1b277bdeb46&title=&width=575.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695537294499-2568aa85-727a-4663-bd88-142fc3814cb0.png#averageHue=%23f2f2ed&clientId=uc25bbb35-aed9-4&from=paste&height=501&id=u93f7768d&originHeight=626&originWidth=907&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=155238&status=done&style=none&taskId=ufd4c45da-52b5-4760-933b-2708a35d199&title=&width=725.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695537315509-dd08611f-61b0-46f7-8074-a2fad9d06941.png#averageHue=%23f4e9e1&clientId=uc25bbb35-aed9-4&from=paste&height=353&id=u1ff20daa&originHeight=441&originWidth=1265&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=342985&status=done&style=none&taskId=u83fe7746-a139-419f-b2fc-3cfa96745f3&title=&width=1012" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695537364740-d61ee476-a572-4df5-976a-fe21f3ba00da.png#averageHue=%23f3f3f5&clientId=uc25bbb35-aed9-4&from=paste&height=167&id=u989fce05&originHeight=209&originWidth=1208&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=107934&status=done&style=none&taskId=u334997be-e929-4da6-b307-8a94c982fcc&title=&width=966.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695537378528-24bbf69d-c9fc-4094-af32-3b66dc5c3e90.png#averageHue=%23f9f9f9&clientId=uc25bbb35-aed9-4&from=paste&height=414&id=u0d6f191f&originHeight=518&originWidth=1159&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=156364&status=done&style=none&taskId=uc900233b-f473-4cc2-9657-8e2a718f569&title=&width=927.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695537397825-52c04449-0965-4208-9410-129e1948e822.png#averageHue=%23fbfaf9&clientId=uc25bbb35-aed9-4&from=paste&height=542&id=u67de5c4c&originHeight=678&originWidth=1066&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=157563&status=done&style=none&taskId=u3bbc90bd-ab25-4106-9d98-1f910b69f27&title=&width=852.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695537421528-561a7903-e21a-4d19-a030-770b2517baa1.png#averageHue=%23dadad9&clientId=uc25bbb35-aed9-4&from=paste&height=41&id=u9a0fa5e6&originHeight=51&originWidth=766&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=33973&status=done&style=none&taskId=ucfdf125c-4d71-4efe-ab9d-291d477e093&title=&width=612.8" alt="image.png"></p><h3 id="优化器："><a href="#优化器：" class="headerlink" title="优化器："></a>优化器：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695537459979-f7541de2-b4f4-402a-b57f-1106fb0b7bce.png#averageHue=%23fdfdf9&clientId=uc25bbb35-aed9-4&from=paste&height=130&id=uc5ba9497&originHeight=162&originWidth=1188&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=177047&status=done&style=none&taskId=u42140001-5c10-4d1f-97df-61e96a37579&title=&width=950.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695537494869-c73720fc-6810-42e7-95a7-229d13bf38ea.png#averageHue=%23f5ebe3&clientId=uc25bbb35-aed9-4&from=paste&height=494&id=u67304ea9&originHeight=618&originWidth=944&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=182916&status=done&style=none&taskId=uc4c000b6-8025-4d49-94d1-784ae02b3ed&title=&width=755.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695537511851-19c0e1af-ffd9-4c3a-b879-0a56b3913ff0.png#averageHue=%23fbfbf9&clientId=uc25bbb35-aed9-4&from=paste&height=73&id=u418bce6e&originHeight=91&originWidth=1183&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=100427&status=done&style=none&taskId=ud11f4624-1032-4f73-ad44-13a3d63cf5b&title=&width=946.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695537544689-2b0a6cbb-6d94-4187-ae44-522e6456ef67.png#averageHue=%23e3e8ea&clientId=uc25bbb35-aed9-4&from=paste&height=395&id=u0a2dcc34&originHeight=494&originWidth=1241&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=315302&status=done&style=none&taskId=u4387fedd-5699-460f-a5cb-7287c9fcac3&title=&width=992.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695537616338-1af9f03e-130f-4fc9-bcb0-5bf4b8c5250f.png#averageHue=%23fcfaf4&clientId=uc25bbb35-aed9-4&from=paste&height=289&id=u55f9cf9b&originHeight=361&originWidth=1251&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=364997&status=done&style=none&taskId=uf030c0f2-c63e-48df-8d27-527d492819b&title=&width=1000.8" alt="image.png"></p><h3 id="执行器："><a href="#执行器：" class="headerlink" title="执行器："></a>执行器：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695537699936-f096e273-c956-4ad4-bcf4-60fa3b8d9642.png#averageHue=%23fcfcf5&clientId=uc25bbb35-aed9-4&from=paste&height=29&id=ua0baf511&originHeight=36&originWidth=1107&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=49797&status=done&style=none&taskId=u5585e352-77eb-467e-aad9-9dd55fde201&title=&width=885.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695537708770-b336c23c-d97c-45a7-baf2-2c0fb1bdaa42.png#averageHue=%23e7d9bf&clientId=uc25bbb35-aed9-4&from=paste&height=488&id=u938f6df8&originHeight=610&originWidth=1032&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=197415&status=done&style=none&taskId=ued569309-b091-4825-98bb-672b22ce8ff&title=&width=825.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695537719519-1bff0ac6-012a-4f88-9679-a8bda01ff272.png#averageHue=%23f6f6f3&clientId=uc25bbb35-aed9-4&from=paste&height=64&id=uefdeb8be&originHeight=80&originWidth=1211&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=101883&status=done&style=none&taskId=u43fdf0c8-01fa-4df1-a539-dad9fba05ff&title=&width=968.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695537735734-cb43740f-b44a-42b4-925c-0df2a0fe06c9.png#averageHue=%23ececef&clientId=uc25bbb35-aed9-4&from=paste&height=34&id=ua2831003&originHeight=43&originWidth=439&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=13684&status=done&style=none&taskId=u45d9c425-bc26-44a5-9a70-c9a3a4eae64&title=&width=351.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695537751350-9a671289-a6a3-439c-8844-c1eb02b2e9c5.png#averageHue=%23fcfdf9&clientId=uc25bbb35-aed9-4&from=paste&height=63&id=u7e1b2f36&originHeight=79&originWidth=1203&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=105933&status=done&style=none&taskId=uee945322-173d-41ba-869f-0406ddb1afa&title=&width=962.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695537770199-ae54743d-dd6c-4a3d-af73-c4974665d01b.png#averageHue=%23e4e4db&clientId=uc25bbb35-aed9-4&from=paste&height=670&id=u48f21000&originHeight=838&originWidth=1268&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=318598&status=done&style=none&taskId=u19b1471c-ddc2-48f9-a912-bf744bac144&title=&width=1014.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695537781808-5e7882b2-cd22-4a31-aefb-667ad37c97a8.png#averageHue=%23efebd8&clientId=uc25bbb35-aed9-4&from=paste&height=318&id=u3c6f28ff&originHeight=398&originWidth=763&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=128391&status=done&style=none&taskId=uab961ff8-5e2c-4ad4-be5f-c5c6f295945&title=&width=610.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695537821348-f96fe019-9d17-4549-9db8-7361c9303c49.png#averageHue=%23e6eae8&clientId=uc25bbb35-aed9-4&from=paste&height=286&id=u3888bab4&originHeight=358&originWidth=1164&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=221834&status=done&style=none&taskId=ude536d73-97f4-4e54-bf4e-f634263a7ce&title=&width=931.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695537849620-42e4c452-46c7-4b63-a964-c1606a063b7b.png#averageHue=%23efefea&clientId=uc25bbb35-aed9-4&from=paste&height=134&id=u9fd3632c&originHeight=167&originWidth=1253&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=77277&status=done&style=none&taskId=ud1ab882b-599c-474e-9ea8-91e06113ba0&title=&width=1002.4" alt="image.png"></p><h1 id="MySQL8的执行原理："><a href="#MySQL8的执行原理：" class="headerlink" title="MySQL8的执行原理："></a>MySQL8的执行原理：</h1><h1 id="存储引擎："><a href="#存储引擎：" class="headerlink" title="存储引擎："></a>存储引擎：</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695538912244-bf3c69f6-aef9-40bc-952f-7c39b6f5e6e4.png#averageHue=%23fcfcf9&clientId=uc25bbb35-aed9-4&from=paste&height=194&id=udd03ed0d&originHeight=242&originWidth=1235&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=255941&status=done&style=none&taskId=u988e36ef-d90b-45f6-8076-98c26231d12&title=&width=988" alt="image.png"></p><h1 id="索引："><a href="#索引：" class="headerlink" title="索引："></a>索引：</h1><h2 id="1-为什么要用索引？"><a href="#1-为什么要用索引？" class="headerlink" title="1.为什么要用索引？"></a>1.为什么要用索引？</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695543166988-dce08a70-2bda-4247-a73d-5d1af1c0e7d0.png#averageHue=%23fefdfa&clientId=uc25bbb35-aed9-4&from=paste&height=131&id=u701e426e&originHeight=164&originWidth=1178&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=172677&status=done&style=none&taskId=ud57fbb18-6898-4010-a7df-a6692512530&title=&width=942.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695543285930-a871675e-7c6c-4ba9-9bde-b72ee23c7120.png#averageHue=%23f5f4f6&clientId=uc25bbb35-aed9-4&from=paste&height=306&id=u97f4df57&originHeight=383&originWidth=1164&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=220345&status=done&style=none&taskId=u9f9dc5c7-a72a-4367-92e8-80618f0f834&title=&width=931.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695543298510-d8d108ed-774a-4249-95a5-121208985db1.png#averageHue=%23f4f5f4&clientId=uc25bbb35-aed9-4&from=paste&height=210&id=ubfbc3b09&originHeight=263&originWidth=1299&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=378287&status=done&style=none&taskId=u5ad26008-1b61-4980-bdbc-0c3705f60cd&title=&width=1039.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695543309259-53b28c7b-ec4f-43af-981a-32c3b83fc23f.png#averageHue=%23d3d5d7&clientId=uc25bbb35-aed9-4&from=paste&height=614&id=uc4012244&originHeight=767&originWidth=1291&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=327458&status=done&style=none&taskId=u95d92bdd-322e-4aec-acf6-7ba5f44f001&title=&width=1032.8" alt="Snipaste_2023-09-24_16-15-07.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695543413584-80fa9345-b917-432e-8c4a-0db6cdd63fdf.png#averageHue=%23fdfdf9&clientId=uc25bbb35-aed9-4&from=paste&height=238&id=ub1218521&originHeight=297&originWidth=1208&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=315543&status=done&style=none&taskId=u30eb5dfc-baec-4c23-9a73-c172cb72f90&title=&width=966.4" alt="image.png"></p><h2 id="索引的优缺点："><a href="#索引的优缺点：" class="headerlink" title="索引的优缺点："></a>索引的优缺点：</h2><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695543537783-f875d939-e047-4a4d-a611-83d68b75ce06.png#averageHue=%23fefdf9&clientId=uc25bbb35-aed9-4&from=paste&height=227&id=uefe54be4&originHeight=284&originWidth=1228&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=294413&status=done&style=none&taskId=u7a610cfe-5b2a-4f29-80ed-00303eecab5&title=&width=982.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695543617546-d152e5f2-8c92-405a-bb03-18888d842f3c.png#averageHue=%23eddcd4&clientId=uc25bbb35-aed9-4&from=paste&height=234&id=u1ba6ce90&originHeight=292&originWidth=1233&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=225510&status=done&style=none&taskId=u6e7a3ef4-f1ba-4056-b2ee-25532dfaef2&title=&width=986.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695543665023-637bbd48-f939-4da9-a503-cfe7c9cbcbed.png#averageHue=%23f2e6df&clientId=uc25bbb35-aed9-4&from=paste&height=293&id=u2d86d252&originHeight=366&originWidth=1216&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=278713&status=done&style=none&taskId=u4024e471-8420-40c9-874e-3287f1353ec&title=&width=972.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695543800241-4741328c-3bcc-4c83-b4de-eb1408e3a456.png#averageHue=%23e9eeea&clientId=uc25bbb35-aed9-4&from=paste&height=113&id=u22027ac8&originHeight=141&originWidth=1211&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=96653&status=done&style=none&taskId=u648a694e-324f-4116-987c-72286a4b931&title=&width=968.8" alt="image.png"></p><h3 id="InnODB索引："><a href="#InnODB索引：" class="headerlink" title="InnODB索引："></a>InnODB索引：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695543946082-99ca990a-71f3-4020-be5a-4d0852667bec.png#averageHue=%23edded8&clientId=uc25bbb35-aed9-4&from=paste&height=529&id=uec686c8b&originHeight=661&originWidth=1306&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=343513&status=done&style=none&taskId=u9c30901f-70d5-4dec-be03-269a3c239b6&title=&width=1044.8" alt="image.png"><br>（当数据大的时候，存储就会按照页来存储，一个数据页的数据大小默认是16KB；以主键为搜索条件使用二分法查找的条件是主键是按自增的顺序储存在表中的； 上面的最小记录是说的主键的最小记录，也就是第一条记录；多条记录在物理上不一定是连续的，但是在逻辑上是连续的；）</p><div class="code-wrapper"><pre><code class="hljs">对于使用InnoDB存储引擎的表：InnoDB使用聚集索引的方式来组织数据，主键的顺序决定了数据在磁盘上的存储顺序。当你插入新数据时，如果新插入的数据的主键值小于上一个插入的数据，那么在磁盘上，新数据的存储位置将在上一个插入的数据之前。在链表结构中，上一个插入数据的下一个地址将是新插入数据的地址。</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695544333287-373592b4-6465-4a5f-816c-438e2aaafab4.png#averageHue=%23ebdbd4&clientId=uc25bbb35-aed9-4&from=paste&height=323&id=ube697662&originHeight=404&originWidth=1282&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=276931&status=done&style=none&taskId=u933c5932-5d6c-4075-a5f7-7bf762689ab&title=&width=1025.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695544626006-38acbcb6-c3a4-4ed1-8900-4aaf25d78c08.png#averageHue=%23f7f9f9&clientId=uc25bbb35-aed9-4&from=paste&height=726&id=u8155a152&originHeight=907&originWidth=1253&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=277893&status=done&style=none&taskId=u7092f4aa-5968-48d9-9e90-87e5bab04b4&title=&width=1002.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695544713867-781693f1-0d46-462f-be91-72b5faefaca1.png#averageHue=%23ecdad1&clientId=uc25bbb35-aed9-4&from=paste&height=339&id=u80cbb2d6&originHeight=424&originWidth=1265&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=277131&status=done&style=none&taskId=u417ac636-830e-470c-be6d-adedf6db896&title=&width=1012" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695544722654-ed0cedd4-110b-47ae-bc5a-a7104d89a1a5.png#averageHue=%23f3f3f7&clientId=uc25bbb35-aed9-4&from=paste&height=436&id=uaedfa555&originHeight=545&originWidth=757&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=110770&status=done&style=none&taskId=u994b67fd-f1aa-408d-ab24-cdd4855480f&title=&width=605.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695544840467-6618cd72-8d28-42a3-9571-469301f4a8e5.png#averageHue=%23c0d6de&clientId=uc25bbb35-aed9-4&from=paste&height=565&id=ua4f993e1&originHeight=706&originWidth=1239&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=255457&status=done&style=none&taskId=uda954dae-fd66-419a-84d1-d3533a97e49&title=&width=991.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695544884498-ddaf990b-eb87-4a29-ba8a-f673c8cf50f2.png#averageHue=%23eff0ec&clientId=uc25bbb35-aed9-4&from=paste&height=465&id=ubc2696ba&originHeight=581&originWidth=1276&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=442640&status=done&style=none&taskId=uf1a6f9e0-8c8b-489a-846e-f5c37956707&title=&width=1020.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695544963031-914c42f5-abb2-4c88-a6d2-22c8d78c7a30.png#averageHue=%23c1cfe1&clientId=uc25bbb35-aed9-4&from=paste&height=376&id=ubc0abe92&originHeight=470&originWidth=682&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=115568&status=done&style=none&taskId=u036771c1-96eb-4a28-aea6-ea9a9e8b696&title=&width=545.6" alt="image.png"><br>（添加数据的时候一定会保证主键是自增的，如果新添加的数据校园前面的，会让前面的换）<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695545070780-a0c3d1cc-c932-498a-866d-2f35dd2f5961.png#averageHue=%23f6f6f4&clientId=uc25bbb35-aed9-4&from=paste&height=132&id=u3f7f5a59&originHeight=165&originWidth=1251&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=80672&status=done&style=none&taskId=u01150c8d-e133-4e07-b5d0-f90a9cd7442&title=&width=1000.8" alt="Snipaste_2023-09-24_16-44-29.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695545124286-9874524c-c301-41d6-8178-3761c7cc32e5.png#averageHue=%23c7d2db&clientId=uc25bbb35-aed9-4&from=paste&height=359&id=uc2d04c05&originHeight=449&originWidth=1210&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=132827&status=done&style=none&taskId=u00c87a0e-acd3-4107-a0db-3c06e1567eb&title=&width=968" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695545262092-c122ad34-bb18-4f68-bcfc-17d3f9d89f72.png#averageHue=%23fefefa&clientId=uc25bbb35-aed9-4&from=paste&height=162&id=u94a7711f&originHeight=202&originWidth=1153&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=225644&status=done&style=none&taskId=uce02a084-617b-4d17-a5a2-d96bf1377fa&title=&width=922.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695545289823-fd769c12-ba54-48cd-8a20-1149eb09fe3a.png#averageHue=%23d4dce6&clientId=uc25bbb35-aed9-4&from=paste&height=442&id=ua3da5e34&originHeight=552&originWidth=1141&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=220638&status=done&style=none&taskId=ubc750830-9eff-4be4-943e-abbe2a009f0&title=&width=912.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695545304736-831efcbf-0a17-47e2-a89c-cab103cf606c.png#averageHue=%23f9f8f4&clientId=uc25bbb35-aed9-4&from=paste&height=112&id=ue0bffc57&originHeight=140&originWidth=1154&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=115461&status=done&style=none&taskId=u80052f3d-d716-4f1f-9e92-0160c49685d&title=&width=923.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695545368089-0896fd3a-0533-483e-9a05-e17060dad9a1.png#averageHue=%23d7dace&clientId=uc25bbb35-aed9-4&from=paste&height=394&id=ue026efb0&originHeight=493&originWidth=1224&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=357004&status=done&style=none&taskId=u2c32acb5-a798-4f4e-8ac5-0da8d3221a4&title=&width=979.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695545437087-3fb4d1a2-908b-4531-8b41-e5786f844c82.png#averageHue=%23d1d8e0&clientId=uc25bbb35-aed9-4&from=paste&height=410&id=u96379c1d&originHeight=512&originWidth=1195&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=226947&status=done&style=none&taskId=u5e79e988-ea5c-407f-9658-1ecc42d6a7d&title=&width=956" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695549982737-a0b3e5dd-54aa-4779-8642-f42b1fa12dd5.png#averageHue=%23f7f7f3&clientId=uc25bbb35-aed9-4&from=paste&height=202&id=ub0e0bf6f&originHeight=252&originWidth=1233&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=241697&status=done&style=none&taskId=u94105ad9-968b-497f-ae37-c49fa6c9378&title=&width=986.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695550087643-0b9170e8-386c-4086-bc25-d315a7ffc9f0.png#averageHue=%23fefefd&clientId=uc25bbb35-aed9-4&from=paste&height=47&id=u1e1422ae&originHeight=59&originWidth=875&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=23654&status=done&style=none&taskId=u5a040131-be27-4b47-ac82-29a54cd2f3a&title=&width=700" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695550108808-3eefc1b1-c54d-44ed-ade4-3fd1aa11d5dc.png#averageHue=%23f5f4f1&clientId=uc25bbb35-aed9-4&from=paste&height=600&id=u5e4928a8&originHeight=750&originWidth=1220&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=157713&status=done&style=none&taskId=udc2d82cb-770b-45c8-9f3d-1a81ad1cf58&title=&width=976" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695550153192-d9cc36a5-fe53-449d-8a53-012584b3b528.png#averageHue=%23fdfbf9&clientId=uc25bbb35-aed9-4&from=paste&height=526&id=u20de19ce&originHeight=658&originWidth=1168&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=310894&status=done&style=none&taskId=uc367418b-99b9-442a-a5ab-aa1b4cb9f26&title=&width=934.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695550587837-d33ed234-1e3c-445c-8e3c-91499906a7a0.png#averageHue=%23fcf9f3&clientId=uc25bbb35-aed9-4&from=paste&height=198&id=u3f0d2ba4&originHeight=247&originWidth=1228&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=235255&status=done&style=none&taskId=u98046bda-3e19-4e56-9a32-103e0bc01e4&title=&width=982.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695550325722-12619e16-de61-4139-bf03-b8c186b57623.png#averageHue=%23f8f8f5&clientId=uc25bbb35-aed9-4&from=paste&height=610&id=ue98be3c2&originHeight=763&originWidth=1312&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=241566&status=done&style=none&taskId=u739dd242-797c-415f-a02c-c4d501ead73&title=&width=1049.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695550712899-3aeea503-af35-4e74-9424-b469a4fb4171.png#averageHue=%23fbf8f1&clientId=uc25bbb35-aed9-4&from=paste&height=231&id=u2f6e9964&originHeight=289&originWidth=1222&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=226464&status=done&style=none&taskId=uc77138fd-e88c-47fb-a197-576c447a41b&title=&width=977.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695550739285-d10cc433-c035-45f1-a7d3-ff3070780b34.png#averageHue=%23fdfaf3&clientId=uc25bbb35-aed9-4&from=paste&height=181&id=ue4e74d39&originHeight=226&originWidth=1250&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=247265&status=done&style=none&taskId=uc3fa2e05-66a9-4b67-9005-faf0fcced79&title=&width=1000" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695550915971-c47272aa-039f-413a-8bb4-30f37f776b2c.png#averageHue=%23ececee&clientId=uc25bbb35-aed9-4&from=paste&height=550&id=u812b45b6&originHeight=687&originWidth=1156&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=463106&status=done&style=none&taskId=u6067ffd4-1f97-449b-b5fb-db4a7b6384e&title=&width=924.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695550926970-3c9f6ad2-4e8e-4da8-ac28-0aa8463e9def.png#averageHue=%23fcfcf9&clientId=uc25bbb35-aed9-4&from=paste&height=170&id=u159cc771&originHeight=212&originWidth=1253&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=176195&status=done&style=none&taskId=u71299842-0e36-4373-896b-88e5cda138d&title=&width=1002.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695550941235-98de6f39-9a8f-4784-90b7-e9bc3fb260fb.png#averageHue=%23f8f7f9&clientId=uc25bbb35-aed9-4&from=paste&height=414&id=u087a1e46&originHeight=518&originWidth=1136&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=129189&status=done&style=none&taskId=u78bb7e6c-6961-4324-8701-a11c72ba342&title=&width=908.8" alt="image.png"></p><h1 id="mysql数据结构选择的合理性："><a href="#mysql数据结构选择的合理性：" class="headerlink" title="mysql数据结构选择的合理性："></a>mysql数据结构选择的合理性：</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695556584252-f516de48-25ae-4e1c-9b83-c2270d221abb.png#averageHue=%23f5f5f2&clientId=uc25bbb35-aed9-4&from=paste&height=213&id=uf4853f6c&originHeight=266&originWidth=1248&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=289363&status=done&style=none&taskId=u33094b78-5525-47c8-8405-70c7df3d5d3&title=&width=998.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695556678821-b2d119e6-6c60-4e6f-a1a5-07c4fd4c0851.png#averageHue=%23e7d3cd&clientId=uc25bbb35-aed9-4&from=paste&height=439&id=u3328f724&originHeight=549&originWidth=1250&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=380747&status=done&style=none&taskId=uf8564945-6102-4c79-91c4-4dfaca82c49&title=&width=1000" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695556715548-8180693e-0bd8-4fb0-8461-3f5b20d69475.png#averageHue=%23d6ba73&clientId=uc25bbb35-aed9-4&from=paste&height=494&id=ue6e2ee2f&originHeight=617&originWidth=1203&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=307673&status=done&style=none&taskId=u900309a4-32fe-4392-950d-267eb94bf05&title=&width=962.4" alt="image.png"></p><h1 id="InnoDB的数据存储结构："><a href="#InnoDB的数据存储结构：" class="headerlink" title="InnoDB的数据存储结构："></a>InnoDB的数据存储结构：</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695561732337-5e222954-aacb-42ae-a165-e471fbdfe883.png#averageHue=%23fefdfb&clientId=uc25bbb35-aed9-4&from=paste&height=498&id=ue61f49d3&originHeight=623&originWidth=1348&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=615477&status=done&style=none&taskId=ua513795a-1d7d-480c-8fc3-d0818bb7425&title=&width=1078.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695561891701-2faa98b5-c4c8-4c6d-9907-832681b5e5b6.png#averageHue=%23e5e9e5&clientId=uc25bbb35-aed9-4&from=paste&height=82&id=u4cc927d0&originHeight=102&originWidth=1163&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=93061&status=done&style=none&taskId=u7fa7cbd0-a2e1-4aef-b59b-2485f143239&title=&width=930.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695561985274-c50aac98-861b-4d7f-b91b-9c2744ecf35d.png#averageHue=%23e1e2dd&clientId=uc25bbb35-aed9-4&from=paste&height=265&id=ue93aeda8&originHeight=331&originWidth=1187&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=310446&status=done&style=none&taskId=u07c2e406-4785-429d-8a61-774fe7f265e&title=&width=949.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695561999962-498ac7ea-d1e8-4771-9866-acc30b7a1451.png#averageHue=%23f7f7f4&clientId=uc25bbb35-aed9-4&from=paste&height=181&id=u65f0b71e&originHeight=226&originWidth=1219&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=263067&status=done&style=none&taskId=u8673aafa-ae7a-4f94-bd28-9de5096c45d&title=&width=975.2" alt="image.png"><br> <img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695562040629-0a3ac011-ad39-479a-8f25-c21404dc7cab.png#averageHue=%23696a69&clientId=uc25bbb35-aed9-4&from=paste&height=404&id=u23ab81f7&originHeight=505&originWidth=1260&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=317434&status=done&style=none&taskId=u99227983-0440-4a2f-9c29-a7fab70b5c9&title=&width=1008" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695563123718-93432c38-798f-4520-b4b3-93f093827bbe.png#averageHue=%23d3d6c4&clientId=uc25bbb35-aed9-4&from=paste&height=717&id=u49838cc0&originHeight=896&originWidth=1238&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=680890&status=done&style=none&taskId=ub69453a4-8f3d-4249-8bf8-b9019fbfa2a&title=&width=990.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695563141863-626c1618-449e-4e66-88e7-503cdcf21345.png#averageHue=%23d3d3d2&clientId=uc25bbb35-aed9-4&from=paste&height=93&id=u7b212365&originHeight=116&originWidth=1196&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=174312&status=done&style=none&taskId=udab66b4f-ead5-4b35-b65e-8d63ced3db6&title=&width=956.8" alt="image.png"></p><h2 id="页的内部结构："><a href="#页的内部结构：" class="headerlink" title="页的内部结构："></a>页的内部结构：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695563381093-9ed1375d-c067-431e-adc6-56e52910e1fe.png#averageHue=%23eed1ca&clientId=uc25bbb35-aed9-4&from=paste&height=236&id=udbfb7bab&originHeight=295&originWidth=1244&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=236108&status=done&style=none&taskId=u7b1e2b71-d021-4dab-9a41-3181dad4306&title=&width=995.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695564566443-52013107-d49e-4db3-944b-d8de292e74f5.png#averageHue=%23f9f9f8&clientId=uc25bbb35-aed9-4&from=paste&height=439&id=u19ef1b9d&originHeight=549&originWidth=955&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=138067&status=done&style=none&taskId=u1fa6ae2e-e68d-4717-a819-9284e1e2b7a&title=&width=764" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695564575606-ad03f25f-f8de-4a00-962f-443d383cc4c1.png#averageHue=%23ccc9b4&clientId=uc25bbb35-aed9-4&from=paste&height=423&id=uf657b6eb&originHeight=529&originWidth=1226&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=441145&status=done&style=none&taskId=u5c52b6fb-1e9f-4c5d-97fa-ff1637eda46&title=&width=980.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695564618726-1f5182f8-5696-4399-8cec-09a78dca602d.png#averageHue=%23fdf9f4&clientId=uc25bbb35-aed9-4&from=paste&height=150&id=ue5bb460f&originHeight=187&originWidth=940&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=114018&status=done&style=none&taskId=uc019ea99-54e1-46cd-a147-a03881b8bae&title=&width=752" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>尚硅谷mysql习题</title>
    <link href="/2024/01/26/mysql%E5%B0%9A%E7%A1%85%E8%B0%B7%E4%B9%A0%E9%A2%98%EF%BC%9A/"/>
    <url>/2024/01/26/mysql%E5%B0%9A%E7%A1%85%E8%B0%B7%E4%B9%A0%E9%A2%98%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"> <meta name="referrer" content="no-referrer"><p>1.查看一个数据库的所有表：</p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span>  <span class="hljs-keyword">tables</span>  <span class="hljs-keyword">from</span> atguigudb;</code></pre></div><p>2.select查询语句起别名，注意如果别名有空格要用用引号引起来；<br>3.mysql中字符拼接函数：</p><div class="code-wrapper"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">CONCAT</span>(<span class="hljs-params">str1, str2, ...</span>)</span>：将多个字符串按照参数的顺序进行拼接，并返回拼接后的结果。可以接受多个参数，参数之间用逗号分隔。</code></pre></div><p>4，<strong>1.查询员工12个月的工资总和，并起别名为ANNUAL SALARY</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id,last_name,salary <span class="hljs-operator">*</span> <span class="hljs-number">12</span> <span class="hljs-operator">*</span> (<span class="hljs-number">1</span> <span class="hljs-operator">+</span> IFNULL(commission_pct,<span class="hljs-number">0</span>)) &quot;ANNUALSALARY&quot;<span class="hljs-keyword">FROM</span> employees;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>上面的IFNULL函数明显考虑更加周到，ifnull(参数<span class="hljs-number">1</span>，参数<span class="hljs-number">2</span>）判断参数<span class="hljs-number">1</span>是否为<span class="hljs-keyword">NULL</span>如果是<span class="hljs-keyword">NULL</span>就返回参数<span class="hljs-number">2</span>，否则返回参数<span class="hljs-number">1</span></code></pre></div><p>5.分页查询中：limtit 参数1，参数2；其中的参数1是开始的行数减去1，参数2是要显示的行数。<br>6.</p><div class="code-wrapper"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> job_id, location_id<span class="hljs-keyword">FROM</span> employees <span class="hljs-built_in">e</span>, departments d<span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">e</span>.<span class="hljs-symbol">`department_id`</span> = d.<span class="hljs-symbol">`department_id`</span><span class="hljs-keyword">AND</span> <span class="hljs-built_in">e</span>.<span class="hljs-symbol">`department_id`</span> = <span class="hljs-number">90</span>;//上面是一个隐式的内连接，显示的内连接是join连接，on指定连接条件。内连接和外连接的区别：在同等连接条件下连接同样的2张表，外连接产生的数据可能比内连接多。当连接条件的一个列是null或者这个列在另外一张表找不到的时候，这行不会在结构集显示，而外连接则是可以的。</code></pre></div><ol start="7"><li><div class="code-wrapper"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">CHAR_LENGTH</span>(<span class="hljs-variable">last_name</span>)和 <span class="hljs-title"><span class="hljs-built_in">LENGTH</span></span>(<span class="hljs-variable">last_name</span>)的区别是，<span class="hljs-title">CHAR_LENGTH</span>(<span class="hljs-variable">last_name</span>)返回的是</span><span class="hljs-function"><span class="hljs-variable">last_name</span>中的字符数，而<span class="hljs-title"><span class="hljs-built_in">LENGTH</span></span>(<span class="hljs-variable">last_name</span>)返回的是<span class="hljs-variable">last_name</span>中的字节数。这两个函数在处理单字节</span><span class="hljs-function">字符时没有差别，但是在处理多字节字符时，比如中文、日文、韩文等，它们的结果可能会不同。例如，</span><span class="hljs-function">如果<span class="hljs-variable">last_name</span>是<span class="hljs-string">&#x27;张三&#x27;</span>，那么<span class="hljs-title">CHAR_LENGTH</span>(<span class="hljs-variable">last_name</span>)的结果是<span class="hljs-number">2</span>，而<span class="hljs-title"><span class="hljs-built_in">LENGTH</span></span>(<span class="hljs-variable">last_name</span>)的结果根据</span><span class="hljs-function">编码方式的不同，</span><span class="hljs-function">可能是<span class="hljs-number">4</span>（如果是<span class="hljs-variable">utf8</span>编码）或者<span class="hljs-number">6</span>（如果是<span class="hljs-variable">gbk</span>编码）。</span></code></pre></div>8.<strong>查询公司各员工工作的年数、工作的天数，并按工作年数的降序排序</strong><div class="code-wrapper"><pre><code class="hljs sas"><span class="hljs-keyword">SELECT</span> last_name,        <span class="hljs-meta">FLOOR</span>(DATEDIFF(CUR<span class="hljs-meta">DATE</span>(), hire_date) / 365) <span class="hljs-keyword">AS</span> <span class="hljs-string">&quot;工作的年数&quot;</span>,       DATEDIFF(CUR<span class="hljs-meta">DATE</span>(), hire_date) <span class="hljs-keyword">AS</span> <span class="hljs-string">&quot;工作的天数&quot;</span><span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-string">&quot;工作的天数&quot;</span> DESC;//DATEDIFF()函数是MySQL中用于计算两个日期之间的天数差异的函数。它接受两个日期参数，并返回这两个日期之间的天数差（第一个参数减去第二个参数）。像DATEDIFF()类似的日期操作函数，当其中参数的日期格式不一样的时候，会隐式转换为其中的一种。</code></pre></div>9.extract(year_mouth,参数1）返回参数1的6位数日期，前4位代表的是年份，后面2位是日期。<br>10.可以利用日期格式转换方式提取年份，eg:DATE_FORMAT(hire_date,’%Y’) &gt;&#x3D; ‘1997’;<br>11.hire_date &gt;&#x3D; ‘1997-01-01’MySQL在进行日期比较时，会将字符串转换为日期类型，并按照日期的大小进行比较。<br>12.TRUNCATE()函数用于截断数值的小数部分，返回指定精度的整数值。它接受两个参数：要截断的数值和要保留的小数位数。<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> TRUNCATE(<span class="hljs-number">3</span>.<span class="hljs-number">14159</span>, <span class="hljs-number">2</span>);  -- 返回：<span class="hljs-number">3</span>.<span class="hljs-number">14</span>，保留两位小数，截断后的值为<span class="hljs-number">3</span>.<span class="hljs-number">14</span></code></pre></div></li></ol><h1 id="聚合函数："><a href="#聚合函数：" class="headerlink" title="聚合函数："></a>聚合函数：</h1><p>1.在SELECT列表中所有未包含在组函数中的列都应该包含在 GROUP BY子句中；这里可以思考这种情况：当我们select中有AVG聚合函数而且还有其他一个没有group by的字段，这个时候该字段会选择哪个就难以确定了。<br>2.<strong>选择具有各个job_id的员工人数</strong></p><div class="code-wrapper"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> job_id, <span class="hljs-built_in">COUNT</span>(*)<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job_id;</code></pre></div><p>3.**6.查询各个管理者手下员工的最低工资，其中最低工资不能低于6000，没 **<br><strong>有管理者的员工不计算在内</strong></p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> manager_id, MIN(salary)<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> manager_id <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> manager_id<span class="hljs-keyword">HAVING</span> MIN(salary) &gt; <span class="hljs-number">6000</span>;//<span class="hljs-keyword">where</span>判断条件是在<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">by</span>之前，也就是说<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 是更加筛选后的数据进行分组的，//<span class="hljs-keyword">having</span>是对分组后的表进行过滤</code></pre></div><p>4.count(*)是也是聚合函数，也就是说它返回的是一个组的行数，返回的数据也包括null;<br>count(列）不会统计该列为null；<br>5.子查询遇到一对多的情况下，可以用关键字any或者in选取多条查询记录中的一条。<br>6.where子句里面不能利用聚合函数，但是这个时候可以选择用子查询求取多条记录。<br>7.<strong>查询平均工资最低的部门信息</strong></p><div class="code-wrapper"><pre><code class="hljs n1ql">#方式一：<span class="hljs-keyword">SELECT</span> *<span class="hljs-keyword">FROM</span> departments<span class="hljs-keyword">WHERE</span> department_id = (<span class="hljs-keyword">SELECT</span> department_id<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(salary) = (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(dept_avgsal)<span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) dept_avgsal<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id) avg_sal));</code></pre></div><p>2.清空一个表的内容：TRUNCATE TABLE detail_dept;；其中truncate 语句不能回滚，而delete语句可以回滚。<br>3.. 将表emp02重命名为emp01<br>#ALTER TABLE emp02 RENAME TO emp01;<br>RENAME TABLE emp02 TO emp01;<br>4.直接删除表emp01中的列 department_id<br>ALTER TABLE emp01<br>DROP COLUMN department_id;注意这里删除的时候不要忘记了column关键字<br>5.、增加c_gender字段到c_name后面，数据类型为char(1)<br>ALTER TABLE customers ADD c_gender CHAR(1) AFTER c_name;<br>6.列的重命名：</p><div class="code-wrapper"><pre><code class="hljs sql">将c_contact字段改名为c_phone<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> customers CHANGE c_contact c_phone <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>);</code></pre></div><p>7.ALTER TABLE employees<br>MODIFY mobile VARCHAR(20) AFTER <code>code</code>;这里是将mobile列移动到code列的后面<br>8.delimiter是分界符的意思，最后delimiter ;中间有空格，而且insert into admin(c1,c2)是值得要插入的列</p><div class="code-wrapper"><pre><code class="hljs oxygene">DELIMITER <span class="hljs-comment">//</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title function_">insert_user</span><span class="hljs-params">(<span class="hljs-keyword">IN</span> username VARCHAR(20)</span>,<span class="hljs-title function_">IN</span> <span class="hljs-title function_">loginPwd</span> <span class="hljs-title function_">VARCHAR</span><span class="hljs-params">(20)</span>)<span class="hljs-title function_">BEGIN</span><span class="hljs-title function_">INSERT</span> <span class="hljs-title function_">INTO</span> <span class="hljs-title function_">admin</span><span class="hljs-params">(user_name,pwd)</span><span class="hljs-title function_">VALUES</span><span class="hljs-params">(username,loginpwd)</span>;<span class="hljs-keyword">END</span> <span class="hljs-comment">//</span>DELIMITER <span class="hljs-punctuation">;</span></code></pre></div><p>9.如果返回的是多个列的信息可以使用into对应列，把对应的信息传递给变量</p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> get_phone(<span class="hljs-keyword">IN</span> id <span class="hljs-type">INT</span>,<span class="hljs-keyword">OUT</span> <span class="hljs-type">NAME</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<span class="hljs-keyword">OUT</span> phone <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>))<span class="hljs-keyword">BEGIN</span><span class="hljs-keyword">SELECT</span> b.name ,b.phone <span class="hljs-keyword">INTO</span> <span class="hljs-type">NAME</span>,phone<span class="hljs-keyword">FROM</span> beauty b<span class="hljs-keyword">WHERE</span> b.id = id;<span class="hljs-keyword">END</span></code></pre></div><p>10.存储函数和存储过程在传参上的参数是：存储过程有in,out等；但是存储过程却没有in,out标识。<br>11.注意这里的if 和then if 还有end if</p><div class="code-wrapper"><pre><code class="hljs routeros">CREATE FUNCTION test_if_case1(score DOUBLE)RETURNS CHARBEGINDECLARE ch CHAR;<span class="hljs-keyword">IF</span> score&gt;90THEN <span class="hljs-built_in">SET</span> <span class="hljs-attribute">ch</span>=<span class="hljs-string">&#x27;A&#x27;</span>;ELSEIF score&gt;80THEN <span class="hljs-built_in">SET</span> <span class="hljs-attribute">ch</span>=<span class="hljs-string">&#x27;B&#x27;</span>;ELSEIF score&gt;60THEN <span class="hljs-built_in">SET</span> <span class="hljs-attribute">ch</span>=<span class="hljs-string">&#x27;C&#x27;</span>;<span class="hljs-keyword">ELSE</span> <span class="hljs-built_in">SET</span> <span class="hljs-attribute">ch</span>=<span class="hljs-string">&#x27;D&#x27;</span>;END <span class="hljs-keyword">IF</span>;RETURN ch;END //</code></pre></div><p>12.赋值一个表结构：用一个永假条件过滤掉全部数据就OK了</p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> emps_back<span class="hljs-keyword">AS</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> emps<span class="hljs-keyword">WHERE</span> <span class="hljs-number">1</span>=<span class="hljs-number">2</span>;</code></pre></div><p>13.触发器中常用NEW关键字代表新插入的数据形成的单行表格。OLD代表被修改（删，改）的单行表。</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS复习</title>
    <link href="/2024/01/26/javascipt%E5%A4%8D%E4%B9%A0%EF%BC%9A/"/>
    <url>/2024/01/26/javascipt%E5%A4%8D%E4%B9%A0%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><p><a href="https://zh.javascript.info/">现代 JavaScript 教程</a>（目前最全的教程）<br><a href="https://es6.ruanyifeng.com/#docs/intro">ES6 入门教程</a>（相关教程）</p><h1 id="JS对DOM的操作："><a href="#JS对DOM的操作：" class="headerlink" title="JS对DOM的操作："></a>JS对DOM的操作：</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695899617829-fd1fa0a2-b229-4b16-9cd3-e0e5715e11d0.png#averageHue=%23faf7f1&clientId=ub402322a-3775-4&from=paste&height=674&id=uf627e84f&originHeight=842&originWidth=968&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=62804&status=done&style=none&taskId=ufd3cada0-7f82-4a9b-a1c7-0aa43b5fdc1&title=&width=774.4" alt="image.png"><br>HTML空白符处理：<br>1.就 HTML 而言，空白符基本上是被忽略的——单词之间的空白被视为一个字符，而元素的开始和结束以及元素之外的空白则被忽略。</p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-variable">$0</span>.style.background = <span class="hljs-string">&#x27;red&#x27;</span> <span class="hljs-regexp">//</span>这里的<span class="hljs-variable">$0</span>表示当前选中的元素。</code></pre></div><p>2.<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695903368351-b4bdf22c-5697-4321-bde8-a7af2b74f42a.png#averageHue=%23faf8f8&clientId=u61d4b238-37a7-4&from=paste&height=153&id=u0025a173&originHeight=191&originWidth=913&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=20219&status=done&style=none&taskId=u45c16035-e1ae-4317-b3fd-91711968e61&title=&width=730.4" alt="image.png"><br>注意元素和节点之间的关系：元素注意是html的标签；而节点还包括document和标签前面的空格（也就是文本节点）</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>苍穹外卖项目</title>
    <link href="/2024/01/26/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%EF%BC%9A/"/>
    <url>/2024/01/26/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id="登录和相关的CRUD"><a href="#登录和相关的CRUD" class="headerlink" title="登录和相关的CRUD:"></a>登录和相关的CRUD:</h2><p><a href="https://www.54benniao.com/nginx/">Nginx教程_54笨鸟</a><br><a href="https://xie.infoq.cn/article/2051e9a2e76e80393353d826a">Nginx 从入门到实践，万字详解！_nginx_前端下午茶_InfoQ写作社区</a></p><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念:"></a>相关概念:</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696409163321-2cc73f8c-954d-43e5-9054-a61e380237c1.png#averageHue=%23e0ccd5&clientId=uf56011de-eac3-4&from=paste&height=143&id=u67c7cf82&originHeight=179&originWidth=574&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=76437&status=done&style=none&taskId=uc0d357a1-e23a-4b5f-bf87-bcd2e713d04&title=&width=459.2" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-number">1</span><span class="hljs-selector-class">.DTO</span>是数据传输对象是一种用于封装数据并将其从应用程序的一个子系统发送到另一个子系统的对象。<span class="hljs-number">2</span><span class="hljs-selector-class">.N</span> 层应用程序中的服务层最常使用 DTO 在其自身和 UI 层之间传输数据。这里的主要好处是它减少了分布式应用程序中需要通过线路发送的数据量。他们还在 MVC 模式中制作了很棒的模型。<span class="hljs-number">3</span><span class="hljs-selector-class">.DTO</span> 的另一个用途是封装方法调用的参数。如果方法采用四个或五个以上参数（把这些参数封装为一个DTO对象），这可能很有用。java这种单值返回对象，可以将多个不同的对象封装在一个DTO对象里面，然后返回该对象，并把该对象传递给其他应用程序。<span class="hljs-number">4</span><span class="hljs-selector-class">.DTO</span>类型的对象, 不应该掺杂任何业务逻辑; 只包含获取和设置属性的方法, 以及用于序列化或反序列化的解析器。<span class="hljs-number">5</span>.如果想从数据库传输一些信息，但其中包含一些敏感信息，那么我们可以使用 DTO，只传输必要的信息。<span class="hljs-number">6</span><span class="hljs-selector-class">.DTO</span>的好处之一：用于在服务器和客户端进程通信的时候，可以一次性传递更多的信息。节省了通信成本</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-number">1</span>.是表现层状态转换，<span class="hljs-number">2</span><span class="hljs-selector-class">.REST</span> API通过使用HTTP协议中的不同方法（如GET、POST、PUT、DELETE等）来对资源进行操作。<span class="hljs-number">3</span>.以下是<span class="hljs-attribute">REST</span> API的一些关键特点：资源（Resources）：<span class="hljs-attribute">REST</span> API通过URL（统一资源定位符）来表示资源。每个资源都有唯一的URL，用于标识和访问该资源。例如，/users可以表示用户资源。HTTP方法（HTTP Methods）：<span class="hljs-attribute">REST</span> API使用HTTP协议的不同方法来表示对资源的操作。常用的方法包括GET（获取资源）、POST（创建资源）、PUT（更新资源）和DELETE（删除资源）等。状态无关性（Statelessness）：<span class="hljs-attribute">REST</span> API是无状态的，意味着每个请求应该包含足够的信息来理解和处理该请求，而不依赖于之前的请求。服务器不会保留客户端的状态，每个请求都是独立的。表征性（Representation）：<span class="hljs-attribute">REST</span> API使用不同的表示形式来传输资源的状态。常见的表示形式包括JSON（JavaScript <span class="hljs-selector-tag">Object</span> Notation）和XML（eXtensible Markup Language）等。超媒体驱动（HATEOAS）：<span class="hljs-attribute">REST</span> API可以通过在响应中提供超媒体链接来支持自描述性。这些链接可以指导客户端在资源之间进行导航和操作。通过使用<span class="hljs-attribute">REST</span> API，客户端可以通过发送HTTP请求来与服务器进行通信，并执行对资源的操作。服务器根据请求的方法和URL来确定要执行的操作，并返回相应的响应。</code></pre></div><p><a href="https://zh.wikipedia.org/zh-tw/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2">REST</a><br>VO:展示用的数据，会更加业务要求把DTO的数据进行删除和业务解释。<br>PO：PO就是数据库中的记录<br>BO：多个PO组成的业务对象<br>DAO：通常是一个接口或类，用来操作数据库的<br><img src="https://cdn.nlark.com/yuque/0/2023/webp/28066124/1696409881882-187b1730-bbee-4628-8a80-b0bb2896274c.webp#averageHue=%23ebebeb&clientId=uf56011de-eac3-4&from=paste&id=u5e94b9ef&originHeight=843&originWidth=603&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u13e32b46-1e8a-4c98-b2a5-3d3cd0ef7a0&title="><br>Java 8 Streams ：<br><a href="https://juejin.cn/post/6844903830254010381">[译] 一文带你玩转 Java8 Stream 流，从此操作集合 So Easy - 掘金</a><br><a href="https://www.exception.site/java8/java8-new-features">Java8 新特性教程 - 异常教程</a><br><a href="https://blog.csdn.net/bluuusea/article/details/79967039">JAVA8新特性–集合流操作Stream_stream().maptolong-CSDN博客</a></p><div class="code-wrapper"><pre><code class="hljs css"> List&lt;String&gt; myList =                Arrays<span class="hljs-selector-class">.asList</span>(&quot;a1&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;c2&quot;, &quot;c1&quot;);        myList                <span class="hljs-selector-class">.stream</span>() // 创建流                <span class="hljs-selector-class">.filter</span>(s -&gt; s<span class="hljs-selector-class">.startsWith</span>(&quot;c&quot;)) // 执行过滤，过滤出以 c 为前缀的字符串                <span class="hljs-selector-class">.map</span>(String::toUpperCase) // 转换成大写                .<span class="hljs-built_in">sorted</span>() // 排序                .<span class="hljs-built_in">forEach</span>(System.out::println); // for 循环打印// C1// C2</code></pre></div><p><a href="https://www.cnblogs.com/xuwenjin/p/8830850.html">JPA之@Entity、@Table、@Column、@Id - 仅此而已-远方 - 博客园</a><br>@Enity是将该对象和数据库的表联系起来（类名是表名的驼峰转换，eg：**@Entity** 表明该类 (UserEntity) 为一个实体类，它默认对应数据库中的表名是user_entity。），@Table是当@Enity注解的对象和数据库的表名不匹配的时候手动添加其对象联系的表。<br>@Mapper注解详解：<br><a href="https://blog.csdn.net/u012060033/article/details/128040322">Mapper层注解讲解_爱吃牛肉的大老虎的博客-CSDN博客</a></p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-number">1</span>.<span class="hljs-keyword">@Mapper</span>: 这个注解一般使用在Dao层接口上，它的作用就是将接口生成一个动态代理类。使用@mapper后，不需要在spring配置中设置扫描地址，通过mapper.xml里面的namespace属性对应相关的mapper类，spring将动态的生成Bean后注入到ServiceImpl中。@Mapper注解写在每个Dao接口层的接口类上，@MapperScan注解写在SpringBoot的启动类上。当我们的一个项目中存在多个Dao层接口的时候，此时我们需要对每个接口类都写上@Mapper注解，非常的麻烦，此时可以使用@MapperScan注解来解决这个问题。</code></pre></div><p>源码浅析：<br><a href="https://blog.csdn.net/a23452/article/details/122353919">框架技术 — Mybatis动态_object.class.equals(method.getdeclaringclass()_码农C风的博客-CSDN博客</a><br>1.Mybatis会利用动态代理生成一个Dao接口的实例并注入到容器中，不需要自己创建对象了。而查询数据库的操作是通过SqlSession接口实现的。<br>JWT是在客户端发送登录信息，判断登录成功后在返回token.<br>JWT生成toke的方式：</p><div class="code-wrapper"><pre><code class="hljs css">try &#123;            // 设置过期时间，System<span class="hljs-selector-class">.currentTimeMillis</span>() 是 Java 中的一个静态方法，  //它返回当前系统时间的毫秒数，也称为时间戳;java中的Date对象本身的构造方法传递的是一个  //long的数值，它表示Date对象存储的是一个long形的时间戳，它的toring方法会将它转化为字符串  //格式的日期。            Date date = new Date(System<span class="hljs-selector-class">.currentTimeMillis</span>() + EXPIRE_TIME);            // 私钥和加密算法            Algorithm algorithm = Algorithm<span class="hljs-selector-class">.HMAC256</span>(TOKEN_SECRET);            // 设置头部信息            Map&lt;String, <span class="hljs-selector-tag">Object</span>&gt; <span class="hljs-selector-tag">header</span> = new HashMap&lt;&gt;(<span class="hljs-number">2</span>);            <span class="hljs-selector-tag">header</span><span class="hljs-selector-class">.put</span>(&quot;Type&quot;, &quot;Jwt&quot;);            <span class="hljs-selector-tag">header</span><span class="hljs-selector-class">.put</span>(&quot;alg&quot;, &quot;HS256&quot;);            // 返回token字符串            return JWT<span class="hljs-selector-class">.create</span>()                    <span class="hljs-selector-class">.withHeader</span>(<span class="hljs-selector-tag">header</span>)                    <span class="hljs-selector-class">.withClaim</span>(&quot;loginName&quot;, username)                    <span class="hljs-selector-class">.withClaim</span>(&quot;loginTime&quot;, loginTime)                    <span class="hljs-selector-class">.withExpiresAt</span>(date)                    <span class="hljs-selector-class">.sign</span>(algorithm);        &#125; catch (Exception e) &#123;            e<span class="hljs-selector-class">.printStackTrace</span>();            return null;        &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs css">  // 设置过期时间为 <span class="hljs-number">1</span> 天        long expirationTime = System<span class="hljs-selector-class">.currentTimeMillis</span>() + <span class="hljs-number">86400000</span>;//        String token = Jwts<span class="hljs-selector-class">.builder</span>()                <span class="hljs-selector-class">.setSubject</span>(&quot;user123&quot;) // 设置 subject                <span class="hljs-selector-class">.setExpiration</span>(new Date(expirationTime)) // 设置过期时间                <span class="hljs-selector-class">.signWith</span>(SignatureAlgorithm<span class="hljs-selector-class">.HS256</span>, &quot;secret&quot;) // 设置签名                <span class="hljs-selector-class">.compact</span>();//构建并获取最终的 JWT 字符串,没有这一步返回的是一个 JwtBuilder 对象        System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(token);//上面也可以使用setClaims(claims)方法设置playload</code></pre></div><p>上面2种生成token的方式不一样，一个使用Jwt生成token一个使用Jwts生成token，也就是使用生成jwt的库不一样，导入的依赖不一样。第一个是使用Auth0 java-jwt库生成的，第二个是使用JJWT库生成的。<br><a href="https://howtodoinjava.com/java/java-security/jwt-json-web-token/">JWTS</a><br><a href="https://www.baeldung.com/java-auth0-jwt">Managing JWT With Auth0 java-jwt | Baeldung</a></p><div class="code-wrapper"><pre><code class="hljs css">logging:  level:    com:      sky:        mapper: debug        service: info        controller: info//上面的代码分别是设置com包下的sky下的mapper和service和controller个包的日志级别</code></pre></div><p>@<strong>RestControllerAdvice：</strong><br>    @RestControllerAdvice是一个组合注解，由@ControllerAdvice、@ResponseBody等组成。其作用是将控制层的全局的错误俘获，然后将返回结果写进返回体中。@ExceptionHandler(value &#x3D; Exception.class) ExceptionHandler的作用是用来捕获指定的异常，其中的value指定当某种异常发送后做什么处理，该注解常标记在方法上，标记的方法代表对某一具体的异常进行处理。当有多个@ExceptionHandler注解标识的类时，对于异常的处理是就近原则（优先按照该异常的类，没有找到就按照最近的父类处理）。<a href="https://blog.csdn.net/lkforce/article/details/98494922">Spring的@ExceptionHandler注解使用方法-CSDN博客</a>该注解修饰的方法，如果在该注解之下方法之上添加，@ResponseBody<br><a href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247512022&idx=3&sn=bb53d67af6799b71eb57989d393d434a&chksm=fa4ad067cd3d59713cde18ab64dc4230436c15a809c751e874e63c28b6d83cbaf71434c53d4d&scene=27&poc_token=HDqAHWWjGBUxJqZJSpKne8JW6U992SEqHHb-3r1d">看看人家 SpringBoot 的全局异常处理，多么优雅。。。</a><br>spring中的错误处理：<br><a href="https://blog.csdn.net/weixin_45503796/article/details/119246584">Springboot核心功能：高级特性、原理解析-CSDN博客</a><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696468145165-abe54739-e721-4a0c-aa86-ec31162c6239.png#averageHue=%23fefefe&clientId=uf56011de-eac3-4&from=paste&height=427&id=u2124a994&originHeight=534&originWidth=1001&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=215896&status=done&style=none&taskId=u3dc7ddf4-1714-4e6e-930a-8ffc38e1700&title=&width=800.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696468246891-8fa6fba4-b44b-4b1c-82b1-818c09f548da.png#averageHue=%23fcf8f2&clientId=uf56011de-eac3-4&from=paste&height=406&id=u118afe69&originHeight=508&originWidth=996&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=142930&status=done&style=none&taskId=uaabf2c91-00c5-49e8-966d-455f8183295&title=&width=796.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696468472665-e4d83cd9-5242-4894-8943-caa2a4064f56.png#averageHue=%23faf4e9&clientId=uf56011de-eac3-4&from=paste&height=370&id=ub8575eef&originHeight=462&originWidth=859&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=121041&status=done&style=none&taskId=u07214a89-8913-47cd-96f8-69699b957db&title=&width=687.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696468545858-89aff1c9-c410-44cf-aadb-a5edfad08949.png#averageHue=%23e7e8e9&clientId=uf56011de-eac3-4&from=paste&height=276&id=uace24f9f&originHeight=345&originWidth=829&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=157034&status=done&style=none&taskId=u1ad5023a-9c95-4ed3-9507-325db630959&title=&width=663.2" alt="image.png"><br>springsecurity的复习：<br><a href="https://juejin.cn/post/6999952004990631949">Spring Security核心接口用户权限获取，鉴权流程执行原理｜8月更文挑战 - 掘金</a>（暂时还不是很理解）</p><div class="code-wrapper"><pre><code class="hljs css"> //把result转成JSON        String json = objectMapper<span class="hljs-selector-class">.writeValueAsString</span>(result);        //响应出去        PrintWriter out = response<span class="hljs-selector-class">.getWriter</span>();        out<span class="hljs-selector-class">.write</span>(json);        out<span class="hljs-selector-class">.flush</span>();//上面的response<span class="hljs-selector-class">.getWriter</span>();指明了流要输出的对象是response里面，输入的是json字符串//输出流一般都是指明输出的地址的。</code></pre></div><div class="code-wrapper"><pre><code class="hljs css">Spring Security中的安全上下文（SecurityContext）是一个存储当前用户认证信息和权限信息的对象，它可以通过SecurityContextHolder类获取和设置。安全上下文的持续时间取决于SecurityContextHolder的策略和HttpSession的生命周期。SecurityContextHolder有三种策略，分别是：•  MODE_THREADLOCAL：这是默认的策略，它使用ThreadLocal来存储安全上下文，这意味着安全上下文只在当前线程中有效，当线程结束时，安全上下文也会消失。•  MODE_INHERITABLETHREADLOCAL：这种策略也使用ThreadLocal来存储安全上下文，但是它允许子线程继承父线程的安全上下文，这对于使用线程池的情况比较有用。•  MODE_GLOBAL：这种策略使用一个全局的变量来存储安全上下文，这意味着所有的线程都共享同一个安全上下文，这种策略很少使用，因为它可能导致数据混乱和安全风险。HttpSession是一个用于存储用户会话信息的对象，它可以在多个请求之间保持用户状态。HttpSession的持续时间取决于服务器的配置和客户端的行为，一般有以下几种情况：•  如果服务器设置了HttpSession的超时时间（timeout），那么当用户在一段时间内没有发起任何请求时，HttpSession会自动失效，安全上下文也会被清除。https://spring.io/projects/spring-security/•  如果用户主动退出登录或关闭浏览器，那么HttpSession会被销毁，安全上下文也会被清除•  如果用户在同一个浏览器中打开多个标签页或窗口访问同一个应用，那么它们会共享同一个HttpSession和安全上下文。•  如果用户在不同的浏览器或设备中访问同一个应用，那么它们会拥有不同的HttpSession和安全上下文。</code></pre></div><p><a href="https://blog.csdn.net/sheng0113/article/details/122712947">Java迭代器详解，看这一篇就够了-CSDN博客</a></p><div class="code-wrapper"><pre><code class="hljs css">DigestUtils是spring提供的加密类，DigestUtils<span class="hljs-selector-class">.md5DigestAsHex</span>(password<span class="hljs-selector-class">.getBytes</span>());</code></pre></div><p>在IDEA中可以通过在注释中添加TODO来标识待完善的部分。可以点击左下角的TODO来快速定位TODO的位置。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696484149698-36a5f1a3-e706-4970-a632-6b942e003334.png#averageHue=%23fcfaf9&clientId=ua374d035-53e1-4&from=paste&height=333&id=u69887b62&originHeight=416&originWidth=733&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=80915&status=done&style=none&taskId=u388ed148-fca9-4b52-a028-f42c138b3b6&title=&width=586.4" alt="image.png"><br>Swagger:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696484636385-8e226c29-29cf-4c87-af60-71f5ad2671ed.png#averageHue=%23fcfaf6&clientId=ua374d035-53e1-4&from=paste&height=304&id=u88ff5e7b&originHeight=380&originWidth=984&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=134543&status=done&style=none&taskId=u23493cee-f634-4219-acd2-6e860b58e88&title=&width=787.2" alt="image.png"><br>springboot2和springboot3中swaager导入的版本不同<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696485481258-17f092d0-ef2b-490b-b6ba-1dd4cf26831f.png#averageHue=%23f8f0e2&clientId=ua374d035-53e1-4&from=paste&height=267&id=u0819f7ac&originHeight=334&originWidth=802&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=135270&status=done&style=none&taskId=u30768b4e-de18-4032-95b9-f65dcec97e9&title=&width=641.6" alt="image.png"><br><a href="https://doc.xiaominfo.com/docs/quick-start">快速开始 | Knife4j</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696487431526-e530cba7-6a71-4b22-9905-e9f9e6e5651b.png#averageHue=%2372805d&clientId=ua374d035-53e1-4&from=paste&height=242&id=u3d20006f&originHeight=302&originWidth=1366&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=330870&status=done&style=none&taskId=u42d64647-10a0-4913-832e-fede2183a10&title=&width=1092.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696487700354-5ef5e3a5-1629-4909-807b-815c05d3c041.png#averageHue=%23f2f1f2&clientId=ua374d035-53e1-4&from=paste&height=436&id=u13a6538a&originHeight=545&originWidth=1511&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=352888&status=done&style=none&taskId=uf3c8f14b-356d-4196-9a2a-397b55b3002&title=&width=1208.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696488049625-cd8d61ba-8624-4d82-97a0-8460650eff87.png#averageHue=%2393a4a6&clientId=ua374d035-53e1-4&from=paste&height=341&id=u8d495c29&originHeight=426&originWidth=935&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=94680&status=done&style=none&taskId=u758aeb31-a544-4578-bb3c-812aa615abc&title=&width=748" alt="image.png"><br>BeanUtils.<em>copyProperties</em>(employeeDTO, employee);是将employeeDTO该对象的相关属性赋值给employee.<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696496769542-58321bd5-e845-474c-8c2e-3a1994bc0430.png#averageHue=%23627d66&clientId=u44c118de-c29f-4&from=paste&height=238&id=u013ef5b6&originHeight=297&originWidth=1414&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=361070&status=done&style=none&taskId=u7fb9f95d-6840-43fa-8d7c-fc45215ffbf&title=&width=1131.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696496875531-1d116105-5551-48ce-b42f-41328647ff30.png#averageHue=%23282c36&clientId=u44c118de-c29f-4&from=paste&height=87&id=u99745c08&originHeight=109&originWidth=860&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=75745&status=done&style=none&taskId=u928d3187-8b81-4665-a22c-16e66a5ef91&title=&width=688" alt="image.png"><br>controller层注入service接口，service接口的实现类注入mapper接口类，并利用注入的接口类中的接口方法操作数据库。<br>IDEA实现修改Springboot项目后不用重新启动就可以看到更改：<br>1.导入依赖：</p><div class="code-wrapper"><pre><code class="hljs css">&lt;dependency&gt;    &lt;groupId&gt;org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span>&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre></div><p>2.<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696499235039-fd2c1235-8480-4e09-a91a-d79292f87937.png#averageHue=%233f444a&clientId=u44c118de-c29f-4&from=paste&height=509&id=u8fbec3b4&originHeight=636&originWidth=1292&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=239320&status=done&style=none&taskId=u4575fa55-807c-4869-8130-b5a2d39145c&title=&width=1033.6" alt="image.png"><br>3.<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696499245170-1573a9b7-1138-47cf-9cd2-b6a0a069bd30.png#averageHue=%233e4348&clientId=u44c118de-c29f-4&from=paste&height=671&id=u89514ab4&originHeight=839&originWidth=1286&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=271719&status=done&style=none&taskId=ud5fe3661-0f8d-4d6a-ad76-d71083ba80e&title=&width=1028.8" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs css">spring-boot-devtools 是 Spring Boot 提供的一个开发工具模块，旨在提高开发人员的开发体验和生产力。它为开发人员提供了一些有用的功能，以加快应用程序的开发、调试和重新加载过程。以下是 spring-boot-devtools 提供的主要功能：自动应用程序重启：当你进行代码更改时，spring-boot-devtools 可以自动监测到变化，并自动重新启动应用程序，以便立即看到更改的效果，而无需手动停止和启动应用程序。自动重新加载：除了重启应用程序外，spring-boot-devtools 还支持许多类文件的自动重新加载，而无需重新启动整个应用程序。这对于一些轻量级的更改，如修改控制器、视图模板或静态资源文件等，可以更快地生效。禁用模板缓存：在开发阶段，模板引擎通常会对模板文件进行缓存，以提高性能。但这也会导致在更改模板文件后，你无法立即看到更改的效果。spring-boot-devtools 可以自动禁用模板缓存，以便在每次请求时都重新加载模板文件。静态资源自动更新：当你修改静态资源文件（如 CSS、JavaScript 或图片文件）时，spring-boot-devtools 可以自动检测到更改，并将其复制到应用程序的类路径中，以便立即生效。全局设置更改：spring-boot-devtools 还提供了一个 META-INF/spring-devtools<span class="hljs-selector-class">.properties</span> 文件，你可以在其中配置一些全局设置，如禁用某些特性或自定义重新加载的策略等。</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696501056331-bef4cb36-255b-44af-ad86-b9a10ac62a3d.png#averageHue=%232a303b&clientId=u44c118de-c29f-4&from=paste&height=313&id=u23828f62&originHeight=391&originWidth=1148&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=357659&status=done&style=none&taskId=u64c19e3e-8e81-4717-82b2-b4e0b46ca1a&title=&width=918.4" alt="image.png"></p><ol><li>@ConfigurationProperties 的 POJO类的命名比较严格,因为它必须和prefix的后缀名要一致, 不然值会绑定不上, 特殊的后缀名是“driver-class-name”这种带横杠的情况,在POJO里面的命名规则是 <strong>下划线转驼峰</strong> 就可以绑定成功，所以就是 “driverClassName”</li></ol><p>@ConfigurationProperties实现从配置文件自动注入对应的配置值到对应的Bean对象时所采取的绑定是宽松绑定（把中划线-、下划线_ 都去掉,且不区分大小写）但是prefix只能使用纯小写字母，数字，下划线。：<a href="https://blog.csdn.net/m0_45877477/article/details/125451975">SpringBoot松散绑定(宽松绑定)@ConfigurationProperties_spring boot 2.7 @configurationproperties_梨轻巧的博客-CSDN博客</a><br>request.getHeader（）传入请求头的名，返回请求头的值。</p><div class="code-wrapper"><pre><code class="hljs css">/判断当前拦截到的是Controller的方法还是其他资源        if (!(handler instanceof HandlerMethod)) &#123;            //当前拦截到的不是动态方法，直接放行            return true;        &#125;使用了 instanceof 运算符，它可以判断一个对象是否属于某个类或接口。你判断了 handler 是否属于 HandlerMethod 类，它是一个表示控制器方法的对象。如果 handler 不是 HandlerMethod 的实例，说明当前拦截到的不是控制器方法，而是其他资源，比如静态文件、视图等。这时，你直接返回 true，表示放行请求，不进行任何拦截处理。如果 handler 是 HandlerMethod 的实例，说明当前拦截到的是控制器方法，这时你可以根据你的业务逻辑来决定是否拦截或处理请求。</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"> Claims claims = Jwts<span class="hljs-selector-class">.parser</span>()                // 设置签名的秘钥                <span class="hljs-selector-class">.setSigningKey</span>(secretKey<span class="hljs-selector-class">.getBytes</span>(StandardCharsets<span class="hljs-selector-class">.UTF_8</span>))                // 设置需要解析的jwt                <span class="hljs-selector-class">.parseClaimsJws</span>(token)<span class="hljs-selector-class">.getBody</span>();代码调用 Jwts<span class="hljs-selector-class">.parser</span>() 返回一个 JwtParser 对象，用于解析 JWT。接下来，通过链式调用 setSigningKey(secretKey<span class="hljs-selector-class">.getBytes</span>(StandardCharsets<span class="hljs-selector-class">.UTF_8</span>)) 方法设置签名的密钥。secretKey 是一个字符串表示的密钥，通过 getBytes() 方法将其转换为字节数组。然后，调用 parseClaimsJws(token) 方法，并将 JWT 作为参数传递给该方法。token 是要解析的 JWT 字符串。</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696503439259-050e74a1-2435-4a63-8838-800fadce6b17.png#averageHue=%2385765d&clientId=u44c118de-c29f-4&from=paste&height=118&id=u2fedafc8&originHeight=147&originWidth=1217&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=35361&status=done&style=none&taskId=u83b24789-491c-4c1b-8825-14a3d7639a4&title=&width=973.6" alt="image.png"></p><h2 id="分页查询："><a href="#分页查询：" class="headerlink" title="分页查询："></a>分页查询：</h2><div class="code-wrapper"><pre><code class="hljs css">请求参数类型为 Query 是指在 HTTP 请求中，将参数以键值对的形式附加在 URL 后面，用问号（?）分隔，用与号（&amp;）连接。例如：http://example.com/search?keyword=apple&amp;sort=price这个 URL 中，keyword 和 sort 就是 Query 参数的名称，apple 和 price 就是 Query 参数的值。Query 参数可以用来传递一些简单的字符串类型的数据，比如搜索关键词、排序方式、分页信息等。Query 参数的优点是可以直接在浏览器地址栏中输入和修改，方便测试和调试。Query 参数的缺点是长度有限制，不能传递复杂的对象类型的数据，而且会暴露在 URL 中，不适合传递敏感或私密的数据。</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-keyword">@Data</span> 是一个 Lombok 注解，它可以自动生成一些常见的 Java 类代码，如字段的 getter 和 setter方法、equals() 和 hashCode() 方法、toString() 方法等</code></pre></div><div class="code-wrapper"><pre><code class="hljs css">log<span class="hljs-selector-class">.info</span>(&quot;分页查询：&#123;&#125;&quot;,employeePageQueryDTO);花括号&#123;&#125;充当变量值的占位符</code></pre></div><div class="code-wrapper"><pre><code class="hljs css">&lt;select id=&quot;pageQuery&quot; resultType=&quot;com<span class="hljs-selector-class">.sky</span><span class="hljs-selector-class">.entity</span><span class="hljs-selector-class">.Employee</span>&quot;&gt;    select * <span class="hljs-selector-tag">from</span> employee    &lt;where&gt;        &lt;if test=&quot;name != null and name != &#x27;&#x27;&quot;&gt;            and name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)        &lt;/if&gt;    &lt;/where&gt;    <span class="hljs-attribute">order</span> by create_time desc&lt;/select&gt;//&lt;where&gt; 标签和 &lt;if&gt; 条件判断：用于根据条件动态生成查询语句的 WHERE 子句。//其中的resultType绑定查询到的每条结果的映射。这里的mapper接口的方法是返回一个//page&lt;Employee&gt;所以这里的resultType是com<span class="hljs-selector-class">.sky</span><span class="hljs-selector-class">.entity</span><span class="hljs-selector-class">.Employee</span>。</code></pre></div><p><a href="https://pagehelper.github.io/docs/howtouse/#2-%E9%85%8D%E7%BD%AE%E6%8B%A6%E6%88%AA%E5%99%A8%E6%8F%92%E4%BB%B6">如何使用分页插件</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696510139759-6aa1ef5f-7f45-4c53-81dd-a4dfcdf1c2a0.png#averageHue=%23747c66&clientId=u44c118de-c29f-4&from=paste&height=157&id=ud6b729b2&originHeight=196&originWidth=702&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=95518&status=done&style=none&taskId=u6645482a-ce44-4ffd-ab84-b4e576cb6bc&title=&width=561.6" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs css">PageHelper<span class="hljs-selector-class">.startPage</span>(employeePageQueryDTO<span class="hljs-selector-class">.getPage</span>(), employeePageQueryDTO<span class="hljs-selector-class">.getPageSize</span>());这个方法的第一个参数是查询第几页（第一页为最初页）第二个参数是每页的条数。如果显示的查询为第<span class="hljs-number">0</span>页，不会返回查询对象。</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696511481893-51a7dec1-71b3-4c72-b721-e9d28e3d4225.png#averageHue=%23353433&clientId=u44c118de-c29f-4&from=paste&height=188&id=u71713dd8&originHeight=235&originWidth=981&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=47340&status=done&style=none&taskId=u1afbb47f-ebf1-4b55-92a8-e63be3109ec&title=&width=784.8" alt="image.png"><br><a href="https://www.baeldung.com/spring-httpmessageconverter-rest">https://www.baeldung.com/spring-httpmessageconverter-rest</a><br>利用SpringMVC框架，可以使得我们在开发时，只要在代码中使用@RequestBody和@ResponseBody两个注解，就可以分别完成从请求报文到对象和从对象到响应报文的转换。而在源码内部，其实这种灵活的消息转换机制就是利用HttpMessageConverter来实现的。<br>HttpMessageConverter的调用是RequestResponseBodyMethodProcessor类的解析请求参数的方法resolveArgument()和处理返回值的方法handleReturnValue()中进行调用的。这是关于@RequestBody和@ResponseBody两个注解的原理。</p><p> <img src="https://cdn.nlark.com/yuque/0/2023/webp/28066124/1696514104432-ba89f22e-3e8d-4493-adb6-27fbfb0910c2.webp#averageHue=%23f5f5f5&clientId=u44c118de-c29f-4&from=paste&id=u5df98b36&originHeight=491&originWidth=1512&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u3e2ad3ad-bd0d-4a6f-82af-6a2c7916b35&title="><br>day3:<br>AOP，即面向切面编程，是一种编程范式，它可以将一些与业务逻辑无关的功能，如日志、安全、事务等，抽取出来，独立实现，然后在运行时动态地插入到目标对象中，从而实现功能的统一维护和复用<a href="https://zhuanlan.zhihu.com/p/395709988">https://zhuanlan.zhihu.com/p/395709988</a>。AOP是OOP的延续和补充，它可以解决OOP中的横切关注点问题<a href="https://zhuanlan.zhihu.com/p/161705262">https://zhuanlan.zhihu.com/p/161705262</a>。</p><p>AOP的核心概念有以下几个<a href="https://bing.com/search?q=AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F&form=SKPBOT">https://bing.com/search?q=AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F&form=SKPBOT</a>：</p><p>•  切面（Aspect）：一个切面包含了一些通知和切点，定义了切面的功能和作用范围。</p><p>•  通知（Advice）：一个通知是切面要执行的具体操作，比如在方法前后打印日志等。通知有五种类型：前置通知、后置通知、返回通知、异常通知和环绕通知。</p><p>•  切点（Pointcut）：一个切点是指定哪些连接点需要被通知的条件，比如匹配某些类或方法等。切点可以通过AspectJ的切点表达式语言来定义。</p><p>•  连接点（Joinpoint）：一个连接点是程序执行过程中的一个点，比如方法调用、异常抛出等。连接点是通知的应用对象。</p><p>•  织入（Weaving）：织入是将切面应用到目标对象的过程，可以在编译期、类加载期或运行期进行。</p><p>AOP的优点有以下几个<a href="https://baike.baidu.com/item/AOP/1332219">https://baike.baidu.com/item/AOP/1332219</a>：</p><p>•  可以提高代码的模块化和复用性，减少代码冗余和耦合。</p><p>•  可以提高代码的可读性和可维护性，增加代码的清晰度和一致性。</p><p>•  可以提高代码的安全性和性能，增加代码的灵活性和扩展性。<br><a href="https://blog.csdn.net/q982151756/article/details/80513340">细说Spring——AOP详解（AOP概览）-CSDN博客</a><br>@Retention(RetentionPolicy.RUNTIME)<br>@Retention(RetentionPolicy.RUNTIME) 是一个 Java 注解，用于指定注解的保留策略（retention policy）。在这个特定的注解中，RetentionPolicy.RUNTIME 表示注解将在运行时保留，可以通过反射来获取注解的信息。<br>Java 注解的保留策略有三种：</p><ol><li>RetentionPolicy.SOURCE：源代码级别的保留策略。注解仅存在于源代码中，在编译后的字节码文件中不可见。</li><li>RetentionPolicy.CLASS：类文件级别的保留策略。注解将保留到编译后的字节码文件中，但在运行时不可见。</li><li>RetentionPolicy.RUNTIME：运行时级别的保留策略。注解将保留到编译后的字节码文件中，并且在运行时可以通过反射获取注解的信息。</li></ol><p>当使用 @Retention 注解时，通过设置 RetentionPolicy 参数来指定所需的保留策略。对于 @Retention(RetentionPolicy.RUNTIME)，它表示注解将在运行时保留，并且可以通过反射在运行时访问注解的信息。<br>以下是一个示例，展示了如何定义一个注解并使用 @Retention(RetentionPolicy.RUNTIME) 设置其保留策略为运行时级别：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;    <span class="hljs-comment">// 注解的元素</span>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;&#125;</code></pre></div><p>在上述示例中，@MyAnnotation 是一个自定义的注解，通过 @Retention(RetentionPolicy.RUNTIME) 设置其保留策略为运行时级别。<br>通过设置注解的保留策略为运行时级别，可以在程序运行时使用反射来获取注解的信息。例如，可以获取注解的值、解析注解中的元素等。<br>请注意，注解的保留策略根据不同的使用场景进行选择。根据需要，您可以选择适合您应用程序的保留策略。</p><h2 id="IOC和AOP："><a href="#IOC和AOP：" class="headerlink" title="IOC和AOP："></a>IOC和AOP：</h2><p>IOC：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696562276048-4e6a24df-4e41-49e9-81b6-2e015cc72ae3.png#averageHue=%23f2f1f1&clientId=u44c118de-c29f-4&from=paste&height=87&id=u25b98ac9&originHeight=109&originWidth=602&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=46356&status=done&style=none&taskId=u449e49c9-a658-436d-83af-e40c4567505&title=&width=481.6" alt="image.png"><br>添加依赖：</p><div class="code-wrapper"><pre><code class="hljs css">&lt;dependency&gt;        &lt;groupId&gt;org<span class="hljs-selector-class">.springframework</span>&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;<span class="hljs-number">6.0</span>.<span class="hljs-number">12</span>&lt;/version&gt;    &lt;/dependency&gt;</code></pre></div><p>spring-context是Spring框架的一个模块，该模块的功能是实现IOC（控制反转容器），它使用依赖注入来实现控制反转的。在springboot项目中可以不用导入该依赖，因为 spring-boot-starter-* 依赖来自动导入 Spring Framework 的核心模块，包括 spring-context。<br>依赖注入设计模式：就算将一个类的依赖不用在本类中new,而是交给一个容器来利用反射机制来创建。<br><a href="https://juejin.cn/post/7233587830387015741">一起来学设计模式之依赖注入模式 - 掘金</a></p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-keyword">@Target</span>(&#123;ElementType<span class="hljs-selector-class">.CONSTRUCTOR</span>, ElementType<span class="hljs-selector-class">.METHOD</span>, ElementType<span class="hljs-selector-class">.PARAMETER</span>, ElementType<span class="hljs-selector-class">.FIELD</span>, ElementType<span class="hljs-selector-class">.ANNOTATION_TYPE</span>&#125;)<span class="hljs-keyword">@Retention</span>(RetentionPolicy.RUNTIME)@Documentedpublic @interface Autowired &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Declares whether the annotated dependency is required.</span><span class="hljs-comment">     * &lt;p&gt;Defaults to &#123;@code true&#125;.</span><span class="hljs-comment">     */</span>    boolean required() default true;//required是一个方法，用来表示注解元素是否是必须的&#125;// 定义Java类的接口及实现类public interface UserService &#123;    void sayHello();&#125;public class UserServiceImpl implements UserService &#123;    <span class="hljs-keyword">@Autowired</span>    private UserService userService1;    <span class="hljs-keyword">@Override</span>    public void sayHello() &#123;        userService1<span class="hljs-selector-class">.sayHello</span>();    &#125;&#125;public class UserService1Impl implements UserService &#123;    <span class="hljs-keyword">@Override</span>    public void sayHello() &#123;        System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(&quot;Hello, userService1&quot;);    &#125;&#125;// 使用反射机制在IOC容器中创建Java对象public class BeanFactory &#123;    public static <span class="hljs-selector-tag">Object</span> getBean(String className) &#123;        <span class="hljs-selector-tag">Object</span> <span class="hljs-selector-tag">object</span> = null;        try &#123;            Class clazz = Class<span class="hljs-selector-class">.forName</span>(className);            <span class="hljs-selector-tag">object</span> = clazz<span class="hljs-selector-class">.newInstance</span>();// clazz<span class="hljs-selector-class">.newInstance</span>()是使用          //无参构造创建实例        &#125; catch (ClassNotFoundException e) &#123;            // handle exception        &#125; catch (InstantiationException e) &#123;            // handle exception        &#125; catch (IllegalAccessException e) &#123;            // handle exception        &#125;        return <span class="hljs-selector-tag">object</span>;    &#125;&#125;// 定义IOC容器类，即存储Java对象的容器// 对象依赖关系的维护，即在创建对象时，扫描对象的属性并注入依赖的对象public class Container &#123;    private Map&lt;String, <span class="hljs-selector-tag">Object</span>&gt; beans = new HashMap&lt;&gt;();    public void register(String beanName, <span class="hljs-selector-tag">Object</span> bean) &#123;        beans<span class="hljs-selector-class">.put</span>(beanName, bean);    &#125;    public <span class="hljs-selector-tag">Object</span> getBean(String beanName) &#123;        <span class="hljs-selector-tag">Object</span> <span class="hljs-selector-tag">object</span> = beans<span class="hljs-selector-class">.get</span>(beanName);        // 获取对象的所有属性，通过反射获取所有的成员对象数组        Field<span class="hljs-selector-attr">[]</span> fields = <span class="hljs-selector-tag">object</span><span class="hljs-selector-class">.getClass</span>()<span class="hljs-selector-class">.getDeclaredFields</span>();        // 遍历属性，注入依赖的对象        for (Field field : fields) &#123;            if (field<span class="hljs-selector-class">.isAnnotationPresent</span>(Autowired<span class="hljs-selector-class">.class</span>)) &#123;                String fieldName = field<span class="hljs-selector-class">.getName</span>();                <span class="hljs-selector-tag">Object</span> dependency = getBean(fieldName);                if (dependency != null) &#123;                    try &#123;                        field<span class="hljs-selector-class">.setAccessible</span>(true);                        field<span class="hljs-selector-class">.set</span>(<span class="hljs-selector-tag">object</span>, dependency);                    &#125; catch (IllegalAccessException e) &#123;                        // handle exception                    &#125;                &#125;            &#125;        &#125;        return <span class="hljs-selector-tag">object</span>;    &#125;&#125;public class <span class="hljs-selector-tag">Main</span> &#123;    public static void <span class="hljs-selector-tag">main</span>(String<span class="hljs-selector-attr">[]</span> args) &#123;        Container container = new Container();        // 注册Java对象到IOC容器        container<span class="hljs-selector-class">.register</span>(&quot;userService&quot;, BeanFactory<span class="hljs-selector-class">.getBean</span>(&quot;com<span class="hljs-selector-class">.java</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.dependency</span><span class="hljs-selector-class">.UserServiceImpl</span>&quot;));        container<span class="hljs-selector-class">.register</span>(&quot;userService1&quot;, BeanFactory<span class="hljs-selector-class">.getBean</span>(&quot;com<span class="hljs-selector-class">.java</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.dependency</span><span class="hljs-selector-class">.UserService1Impl</span>&quot;));        // 从IOC容器中获取Java对象并使用        UserService userService = (UserService) container<span class="hljs-selector-class">.getBean</span>(&quot;userService&quot;);        userService<span class="hljs-selector-class">.sayHello</span>();        // Hello, userService1    &#125;&#125;//后面的userServiceImp1和userServiceImp2互相依赖。但是他们并不都是在直接类中new对方实例；  而是通过BeanFactory<span class="hljs-selector-class">.getBean</span>方法，无参构造一个对象然后注入中进行管理。容器根据扫描注入类的  属性，看是否有 <span class="hljs-keyword">@Autowired</span>注解修饰，如果有就通过反射在该对象类创建依赖的对象。</code></pre></div><p>一个类A依赖类B，按理来说类A中的方法要使用到类B的实例，就需要在类A中new一个类B，但是这样类A和类B的耦合度就高了。依赖注入就算让类A不在使用new来声明B实例了，而是在A中的B属性前用@Autowierd   注解表示自动注入。这个时候声明一个容器，这个容器存放类A和类B的实例（一般是无参构造的实例），把A和B放入容器后，容器利用反射机制扫描类A和类B的属性，发现了@Autowired  注解修饰的属性时，这里也就扫描A的属性发现了B属性，然后将B属性的实例名在容器中寻找B实例。将该属性的值赋值为容器中找到的B实例。至于为什么会有依赖注入和IOC的设置我暂且不知道，可能是为了更好的维护吧？<br>AOP：<br><a href="https://juejin.cn/post/7096780005295783973">Spring中的AOP面向切面编程 - 掘金</a><br>AOP的实现是靠动态代理实现的，AOP的动态代理有JDK动态代理和CGLib动态代理。JDK动态代理是实现要代理的类的全部接口，继承了<strong>Proxy类；使用JDK动态代理生成的对应的AOP方法（如果该方法在原类不是实现接口的方法）无法对非接口中的方法生效。CGLib是</strong>通过操作字节码重写父类的方法生成子类实现的，但是由于重新无法重新fianl修饰的方法，所以该代理生成的AOP方法无法对原类中的final修饰的方法生效。<br><a href="https://www.cnblogs.com/tuyang1129/p/12878549.html">浅析Spring中AOP的实现原理——动态代理 - 特务依昂 - 博客园</a><br><a href="https://pdai.tech/md/spring/spring-x-framework-aop.html#aop%E6%9C%AF%E8%AF%AD">Spring基础 - Spring核心之面向切面编程(AOP)</a><br>AOP编程的方法可以自己声明一个注解标记在要进行AOP操作的方法上，写一个@Aspect修饰的处理类。<br>@Aspect  声明的方法中有一个单独的@Pointcut声明的切入点方法。后面的@Before等  通知的注解的值可以是这个，在相关的通知方法利用反射机制书写特定的逻辑。然后在要进行织入的方法上用该注解修饰。<br>AOP切面如果书写的切面类的切面点是一个私有方法，那么将无法代理该私有方法，也就是切面方法无法织入到切面点的。JDK代理是生成公共的接口，私有方法不会存在于代理类中，CGLib代理会在生成代理对象的过程中pass掉私有方法。<br>反射：<br><a href="https://blog.csdn.net/a745233700/article/details/82893076">Java基础篇：反射机制详解_java反射机制原理详解-CSDN博客</a><br><a href="https://pdai.tech/md/java/basic/java-basic-x-reflection.html">Java 基础 - 反射机制详解</a><br><a href="https://blog.csdn.net/a745233700/article/details/90232862">Java虚拟机：对象创建过程与类加载机制、双亲委派模型-CSDN博客</a><br>文件上传：<br>这里使用的阿里云图片上传的OSS技术，其实在图片上传的时候是将图片上传到阿里云的OSS然后在将返回地址返回给前端，然后前端在把图片地址信息和其他相关信息上传给后端，然后后端在数据库当中储存图片的地址。<br>上传到阿里云OSS成功后但是后面的访问无法访问的问题：<br>原因是阿里云OSS的文件权限的问题设置为私有的。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696596200087-d7b6442b-79e4-42c2-ab53-3c1a534a5122.png#averageHue=%23fcfbfa&clientId=u44c118de-c29f-4&from=paste&height=429&id=u5387fd6e&originHeight=536&originWidth=1154&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=88796&status=done&style=none&taskId=u16e3e2c4-85bb-4518-8fb2-a1748c57b6d&title=&width=923.2" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs css">MultipartFile 是 Spring Framework 中提供的一个接口，用于处理文件上传的封装。MultipartFile 接口定义了用于获取上传文件信息和操作文件内容的方法。它是对 HTTP 请求中的文件数据进行封装，使得在 Spring Web 应用中可以方便地处理文件上传操作。通过使用 MultipartFile，您可以轻松地获取上传文件的原始文件名、文件类型、文件大小以及文件内容。以下是 MultipartFile 接口的一些常用方法：getOriginalFilename()：获取上传文件的原始文件名。getContentType()：获取上传文件的内容类型。getSize()：获取上传文件的大小。getBytes()：获取上传文件的字节数组。getInputStream()：获取上传文件的输入流，用于读取文件内容。</code></pre></div><p>mybits如果插入的是一个链表：这里的flavors是mapper接口传来的参数，是一个链表。这里使用的是foreach标签来实现循环插入</p><div class="code-wrapper"><pre><code class="hljs css">&lt;insert id=&quot;insertBatch&quot;&gt;        insert into dish_flavor (dish_id, name, value) VALUES        &lt;foreach collection=&quot;flavors&quot; item=&quot;df&quot; separator=&quot;,&quot;&gt;            (#&#123;df<span class="hljs-selector-class">.dishId</span>&#125;,#&#123;df<span class="hljs-selector-class">.name</span>&#125;,#&#123;df<span class="hljs-selector-class">.value</span>&#125;)        &lt;/foreach&gt;    &lt;/insert&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs css">    &lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;        insert into dish (name, category_id, price, image, description, create_time, update_time, create_user,update_user, status)        values (#&#123;name&#125;, #&#123;categoryId&#125;, #&#123;price&#125;, #&#123;image&#125;, #&#123;description&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;, #&#123;status&#125;)    &lt;/insert&gt;//insert 是 &lt;insert&gt; 标签的 id 属性，用于标识该插入语句的唯一标识符，以便在其他地方引用。useGeneratedKeys=&quot;true&quot; 是 &lt;insert&gt; 标签的属性之一，用于指示 MyBatis 是否应该返回生成的主键值。将其设置为 true 表示希望获取自动生成的主键值。keyProperty=&quot;id&quot; 是 &lt;insert&gt; 标签的属性之一，用于指定将生成的主键值设置到哪个属性中。在这个例子中，生成的主键值将被设置到名为 id 的属性中。这段代码表明在执行插入操作后，MyBatis 将自动获取生成的主键值，并将其设置到名为 id 的属性中。这样可以方便地获取插入操作后生成的主键值，以便后续的处理或展示。</code></pre></div><p><a href="https://zhuanlan.zhihu.com/p/57693064">最全面的SpringBoot配置文件详解</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696592788345-07faa46e-0a5d-46a0-81eb-c2482a183218.png#averageHue=%23697f60&clientId=u44c118de-c29f-4&from=paste&height=219&id=u18fe79aa&originHeight=274&originWidth=835&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=202335&status=done&style=none&taskId=ucdbe73d5-ffc6-4daf-ac91-64af1f2a39d&title=&width=668" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696594819349-04903179-f045-46c2-be29-9096ae4af7a2.png#averageHue=%23353433&clientId=u44c118de-c29f-4&from=paste&height=203&id=ueb42be43&originHeight=254&originWidth=807&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=53645&status=done&style=none&taskId=ud9d3c0dc-202a-47e0-aa12-6c415b9c638&title=&width=645.6" alt="image.png"><br>解决IDEAmapper文件报未设置SQL方言警告的方法：<br>IDEA设置里面选中SQL相关的设置，按照下面的配置：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696599153092-2bf0e6a2-bb89-4a43-89ae-451c006ca770.png#averageHue=%23383d42&clientId=u01839493-c0e4-4&from=paste&height=712&id=u9c49debe&originHeight=890&originWidth=1242&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=143921&status=done&style=none&taskId=u041d804c-58e9-44fe-8b74-349a4fe3075&title=&width=993.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696599237875-59b79bf8-b80a-457c-b81e-ee86c46c3123.png#averageHue=%23373e4b&clientId=u01839493-c0e4-4&from=paste&height=150&id=ud117139e&originHeight=187&originWidth=753&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=102878&status=done&style=none&taskId=u54c29bed-7123-459b-9c21-72548aba864&title=&width=602.4" alt="image.png"><br>代码规范：方法注释模板设置，实现在方法头部添加注释实现在注释块添加返回参数类型和方法参数类型<br>1.进入</p><ul><li>设置 - 编辑器 - 活动模板<br>添加如下模板<div class="code-wrapper"><pre><code class="hljs css">** $param$ * <span class="hljs-keyword">@return</span> $return$ * @date $date$ $time$ * @description $description$ */</code></pre></div><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696602753869-f1f8dee7-c54c-44ea-8064-c7df4f2c4b6e.png#averageHue=%233c4146&clientId=u01839493-c0e4-4&from=paste&height=696&id=u2210aa34&originHeight=870&originWidth=1193&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=115405&status=done&style=none&taskId=ubc1503d2-a015-41dc-addc-f0f5df63485&title=&width=954.4" alt="image.png"><br>编辑环境变量：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696602837186-b6cc6b83-5fce-48e9-b022-194f2477b0f3.png#averageHue=%233e444a&clientId=u01839493-c0e4-4&from=paste&height=312&id=gxy03&originHeight=390&originWidth=780&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=47627&status=done&style=none&taskId=u51752a25-2626-4256-837a-448c8aee419&title=&width=624" alt="image.png"><div class="code-wrapper"><pre><code class="hljs css">groovyScript(&quot;def result=&#x27;&#x27;; def params=\&quot;$&#123;_1&#125;\&quot;<span class="hljs-selector-class">.replaceAll</span>(&#x27;<span class="hljs-selector-attr">[\\\\[|\\\\]</span>|\\\\s]&#x27;, &#x27;&#x27;)<span class="hljs-selector-class">.split</span>(&#x27;,&#x27;)<span class="hljs-selector-class">.toList</span>(); for(<span class="hljs-selector-tag">i</span> = <span class="hljs-number">0</span>; <span class="hljs-selector-tag">i</span> &lt; params<span class="hljs-selector-class">.size</span>(); <span class="hljs-selector-tag">i</span>++) &#123;result+=&#x27;* <span class="hljs-keyword">@param</span>: <span class="hljs-string">&#x27; + params[i] + ((i &lt; params.size() - 1) ? &#x27;</span>\\n <span class="hljs-string">&#x27; : &#x27;</span><span class="hljs-string">&#x27;)&#125;;return result&quot;, methodParameters())  </span></code></pre></div>在方法上面使用注解块的时候&#x2F;**然后按tab就可以生成了。<br><a href="https://www.cnblogs.com/cc11001100/p/7811257.html">mybatis笔记之使用Mapper接口注解 - CC11001100 - 博客园</a><div class="code-wrapper"><pre><code class="hljs css">在 Spring AOP 中，<span class="hljs-keyword">@within</span> 是一个切点表达式，用于选择标记有特定注解的类或类的方法。@within 切点表达式的语法如下：Copy@within(annotationType)其中，annotationType 是一个注解类型的名称，用于选择标记有该注解的类或类的方法。以下是一个示例，展示如何在 Spring AOP 中使用 @within 切点表达式：javaCopy@Aspectpublic class MyAspect &#123;        <span class="hljs-keyword">@Pointcut</span>(&quot;<span class="hljs-keyword">@within</span>(org.springframework.stereotype.Controller)&quot;)    public void controllerMethods() &#123;&#125;    <span class="hljs-keyword">@Before</span>(&quot;controllerMethods()&quot;)    public void beforeControllerMethod(JoinPoint joinPoint) &#123;        // 在标记有 <span class="hljs-keyword">@Controller</span> 注解的类的方法执行前执行        // ...    &#125;&#125;在上述示例中，我们定义了一个切点 controllerMethods()，使用 @within(org.springframework.stereotype.Controller) 来选择标记有 @Controller 注解的类或类的方法。然后，我们在 beforeControllerMethod() 方法上使用 @Before 注解来指定在符合切点条件的方法执行前执行的通知。这样，当任何标记有 @Controller 注解的类的方法被调用时，beforeControllerMethod() 方法将会在方法执行前被调用。需要注意的是，切点表达式中的注解类型名称应使用全限定名，例如 org.springframework.stereotype.Controller。</code></pre></div><a href="https://www.cnblogs.com/cc11001100/p/7811257.html">mybatis笔记之使用Mapper接口注解 - CC11001100 - 博客园</a></li></ul><h2 id="第二部分："><a href="#第二部分：" class="headerlink" title="第二部分："></a>第二部分：</h2><h3 id="redis"><a href="#redis" class="headerlink" title="redis:"></a>redis:</h3><p>redis设置远程连接：<br><a href="https://blog.csdn.net/LONG_Yi_1994/article/details/113940332">redis远程连接配置文件</a>如果远程连接中的时候要关闭掉原来的redis-serve进程，但是这个时候用kill-9命令却是无法关闭掉redis-server的时候可以用service redis-server stop命令关闭redis-server进程，然后在使用redis-server “新的redis配置文件的路径”启动redis.之所以上面的kill -9无法关闭启动了的redis的原因是：redis将启动设置写入了一个配置文件中了的，这个时候关闭了redis，相应的配置文件会利用其父进程生成新的redis-server<br>redis操作：<br><a href="https://juejin.cn/post/6844904094545477640">Spring Data Redis 最佳实践！ - 掘金</a><br><a href="https://ost.51cto.com/posts/2333">spring boot整合redis —- RedisTemplate 三分钟快速入门-开源基础软件社区-51CTO.COM</a><br>IOC容器中注入了2个一样的Bean</p><div class="code-wrapper"><pre><code class="hljs css">如果向Spring的IOC容器中注入两个同类的Bean，会发生什么呢？这取决于您如何配置和使用这两个Bean。一般来说，有以下几种可能的情况：•  如果您为这两个Bean指定了不同的id或name属性，那么它们就是不同的Bean实例，可以通过它们的id或name来区分和引用•  如果您为这两个Bean指定了相同的id或name属性，那么后面定义的Bean会覆盖前面定义的Bean，只有后面定义的Bean会被创建和使用•  如果您没有为这两个Bean指定id或name属性，那么它们就是匿名Bean，不能直接被引用，但可以作为其他Bean的依赖注入•  如果您想要在一个地方使用这两个Bean，那么您需要使用<span class="hljs-keyword">@Qualifier</span>注解或其他方式来指定您想要使用哪一个Bean，否则会出现歧义（NoUniqueBeanDefinitionException）</code></pre></div><div class="code-wrapper"><pre><code class="hljs css">Bean中如果注入的是方法返回的bean，那么这个bean的id默认为方法名，如果容器中已经存在同Id的bean。那么后面注入的bean会覆盖前面的；常见的<span class="hljs-keyword">@configuration</span>就是这样实现对原本自动注入容器中的bean进行覆盖的。如果注入的是类，那么该bean的id是全类名</code></pre></div><h3 id="同名bean："><a href="#同名bean：" class="headerlink" title="同名bean："></a>同名bean：</h3><p><a href="https://juejin.cn/post/6844903696954818568">SpringBoot基础篇之重名Bean的解决与多实例选择 - 掘金</a><br>同名bean：多个bean 有相同的 name 或者 id，称之为同名bean<br><strong>bean 的id 和 name的区别</strong><br>id和name都是spring 容器中中bean 的唯一<a href="https://so.csdn.net/so/search?q=%E6%A0%87%E8%AF%86%E7%AC%A6&spm=1001.2101.3001.7020">标识符</a>。</p><ol><li>id: 一个bean的唯一标识 ， 命名格式必须符合XML ID属性的命名规范</li><li>name: 可以用特殊字符，并且一个bean可以用多个名称：name&#x3D;“bean1,bean2,bean3”<br>,用逗号或者分号或者空格隔开。如果没有id，则name的第一个名称默认是id</li></ol><p>spring 容器如何处理同名bean？</p><ul><li>同一个spring配置文件中，bean的 id、name是不能够重复的，否则spring容器启动时会报错。<br>如果一个spring容器从多个配置文件中加载配置信息，则多个配置文件中是允许有同名bean的，并且后面加载的配置文件的中的bean定义会覆盖前面加载的同名bean。<br>1、在spring同一个配置文件中，不能存在id相同的两个bean，否则会报错。<br>2、在两个不同的spring配置文件中，可以存在id相同的两个bean，启动时，不会报错。这是因为spring<br>ioc容器在加载bean的过程中，类DefaultListableBeanFactory会对id相同的bean进行处理：后加载的配置文件的bean，覆盖先加载的配置文件的bean。DefaultListableBeanFactory类中，有个属性allowBeanDefinitionOverriding，默认值为true，该值就是用来指定出现两个bean的id相同的情况下，如何进行处理。如果该值为false，则不会进行覆盖，而是抛出异常。</li></ul><p>spring 容器如何处理没有指定id、name属性的bean？<br>如果 一个 bean 标签未指定 id、name 属性，则 spring容器会给其一个默认的id，值为其类全名。<br>如果有多个bean标签未指定 id、name 属性，则spring容器会按照其出现的次序，分别给其指定 id 值为 “类全名#1”, “类全名#2”<br>如下：<br>配置文件：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xxx.UserInfo&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;accountName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;no-id-no-name0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xxx.UserInfo&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;accountName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;no-id-no-name1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xxx.UserInfo&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;accountName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;no-id-no-name2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p>获取bean的方式：</p><div class="code-wrapper"><pre><code class="hljs abnf">UserInfo u4 <span class="hljs-operator">=</span> (UserInfo)ctx.getBean(<span class="hljs-string">&quot;com.xxx.UserInfo&quot;</span>)<span class="hljs-comment">;  </span>UserInfo u5 <span class="hljs-operator">=</span> (UserInfo)ctx.getBean(<span class="hljs-string">&quot;com.xxx.UserInfo#1&quot;</span>)<span class="hljs-comment">;  </span>UserInfo u6 <span class="hljs-operator">=</span> (UserInfo)ctx.getBean(<span class="hljs-string">&quot;com.xxx.UserInfo#2&quot;</span>)<span class="hljs-comment">;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs less">当一个类被标记为 <span class="hljs-variable">@Configuration</span> 时，它就变成了一个配置类，可以用来定义 beans、配置组件扫描、声明依赖关系等。配置类主要用于替代传统的 XML 配置文件，通过 Java 代码方式进行配置。<span class="hljs-variable">@Configuration</span> 注解告诉 Spring 框架这个类是一个配置类，Spring 在启动时会扫描这个类，并根据其中的配置信息来创建和初始化相应的 beans。通过配置类的方式，可以更加灵活和可读性强的方式来配置和组织应用程序。</code></pre></div><p><a href="https://cloud.tencent.com/developer/article/1497568">【小家Spring】Redis序列化、RedisTemplate序列化方式大解读，介绍Genericjackson2jsonredisserializer序列化器的坑-腾讯云开发者社区-腾讯云</a><br>IDEA无法连接远程的redis解决方法：<br>我这里的原因是因为版本不兼容的原因造成的，也就是springboot和redis中的版本不兼容造成无法连接的。就不该在这上面浪费那么多时间的！！！下次在选择软件搭配的时候，第一件事情就是想着版本搭配。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696683872839-504bd5b1-d5b3-4a41-b59f-a9b67eeb6e99.png#averageHue=%23363433&clientId=uaab8ed78-6ff9-4&from=paste&height=94&id=u7b797e1e&originHeight=117&originWidth=940&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=28663&status=done&style=none&taskId=u471d87fc-bec8-4938-9052-2644b842096&title=&width=752" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696685225386-2ddceecd-ae85-4cf6-a3cc-0b0efbad2a22.png#averageHue=%23696649&clientId=uaab8ed78-6ff9-4&from=paste&height=85&id=u800e55bd&originHeight=106&originWidth=767&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=87266&status=done&style=none&taskId=u6b61fca3-6415-4f23-b697-21945a01b6c&title=&width=613.6" alt="image.png"><br>消息转换器：<br><a href="https://juejin.cn/post/7169590769789960205">Spring Mvc：HttpMessageConverter 消息转换器 - 掘金</a><br><a href="https://blog.csdn.net/JokerLJG/article/details/125099369">SpringBoot消息转换器：HttpMessageConverter-CSDN博客</a><br>HttpClient<br><a href="https://blog.icexmoon.cn/archives/450.html">从零开始 Spring Boot 15：Http Client - 红茶的个人站点</a><br><a href="https://blog.csdn.net/sco5282/article/details/121458401">【HttpClient】在 SpringBoot 中使用 HttpClient 实现 HTTP 请求_springboot使用httpclient-CSDN博客</a><br><a href="https://www.baeldung.com/httpclient-guide">Just a moment…</a><br><a href="https://cloud.tencent.com/developer/article/1537173">springboot实战之常用http客户端整合-腾讯云开发者社区-腾讯云</a><br><a href="https://reflectoring.io/spring-webclient/">Sending HTTP requests with Spring WebClient</a></p><h3 id="小程序开发："><a href="#小程序开发：" class="headerlink" title="小程序开发："></a>小程序开发：</h3><p>1.小程序中的json不能有注释。</p><h5 id="查看appid和appsecret的方法："><a href="#查看appid和appsecret的方法：" class="headerlink" title="查看appid和appsecret的方法："></a>查看appid和appsecret的方法：</h5><p>登录：<a href="https://mp.weixin.qq.com/">微信公众平台</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1696938122732-4ca99cf6-323c-47dc-866c-ecd383004ef2.png#averageHue=%236ac15e&clientId=u56082022-af55-4&from=paste&height=821&id=u5d84ba38&originHeight=1026&originWidth=1740&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=99598&status=done&style=none&taskId=u94022fb8-4aa7-458d-82e5-559bbf3eaa5&title=&width=1392" alt="image.png"><br><a href="https://juejin.cn/post/7076244567569203208#heading-6">SpringBoot教程(十四) | SpringBoot集成Redis(全网最全) - 掘金</a><br>springboot在使用redis的时候导入了相关的依赖的时候，这个依赖里面有相关的配置类和配置文件中的redis配置信息相关联，redis会根据导入的客户端类来判断redis使用的客户端是什么，是根据@ConditionalOnClass组件来判断加载那种客户端。可以自己配置redis的配置类从而覆盖依赖导入的配置类，从而实现修改redis序列化时自己的序列化方式。redis导入依赖的时候就把redisTemplate类注入到容器了，在控制层使用redisTemplate的时候可以使用@AutoWired  的方式注入该依赖。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Set</span> keys = redisTemplate.<span class="hljs-title function_">keys</span>(pattern);<span class="hljs-title function_">keys</span>(pattern)是<span class="hljs-title class_">RedisTemplate</span>中的一个方法，它可以根据一个通配符模式来查询匹配的key集合，  返回一个<span class="hljs-title class_">Set</span>类型的结果。</code></pre></div><p> SpringCache:</p><div class="code-wrapper"><pre><code class="hljs javascript">  @<span class="hljs-title class_">Insert</span>(<span class="hljs-string">&quot;insert into user(name,age) values (#&#123;name&#125;,#&#123;age&#125;)&quot;</span>)    @<span class="hljs-title class_">Options</span>(useGeneratedKeys = <span class="hljs-literal">true</span>,keyProperty = <span class="hljs-string">&quot;id&quot;</span>)    <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span>(<span class="hljs-title class_">User</span> user);@options指定<span class="hljs-variable constant_">SQL</span>语句的其他选项。useGeneratedKeys 设置为<span class="hljs-string">&quot;true&quot;</span> 表明要 <span class="hljs-title class_">MyBatis</span> 获取由数据库自动生成的主键。keyProperty=“eqCsImgId” 指定把获取到的主键值注入到相对应实体类中 eqCsImgId属性。keyColumn=<span class="hljs-string">&quot;eq_cs_img_id指定数据中自增主键的名称。</span><span class="hljs-string"></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript">@<span class="hljs-title class_">CachePut</span>(value = <span class="hljs-string">&quot;userCache&quot;</span>, key = <span class="hljs-string">&quot;#user.id&quot;</span>)</code></pre></div><h4 id="springboot缓存"><a href="#springboot缓存" class="headerlink" title="springboot缓存:"></a>springboot缓存:</h4><p>IDEA的插件有时候会因为版本原因等问题导致插件是无法正常工作的。这个时候在排查错误的时候如果实战没有发现错误的时候，一定不要忘了可能是插件的版本或者插件中存在的问题。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697112999200-717bdda5-5636-4fb9-a888-56c453dda8c3.png#averageHue=%23f6f5f5&clientId=u18117cc1-8688-4&from=paste&height=302&id=ucea6d794&originHeight=377&originWidth=932&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=88714&status=done&style=none&taskId=uebb761f0-03e1-4d79-9a3d-349ffa37c88&title=&width=745.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697112450948-bd75f5e8-a645-4573-aced-6068f2f869e2.png#averageHue=%23f8f5f2&clientId=u18117cc1-8688-4&from=paste&height=113&id=u17def977&originHeight=141&originWidth=464&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=24360&status=done&style=none&taskId=u0783b0f8-0985-4aef-b5cf-5f782c545db&title=&width=371.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697112466354-3789921e-54aa-490d-8500-2a73352c8f8a.png#averageHue=%23faf9f8&clientId=u18117cc1-8688-4&from=paste&height=269&id=ud2403e04&originHeight=336&originWidth=1181&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=37008&status=done&style=none&taskId=u0af9ea70-12c7-4306-89c7-ed7fb423ce0&title=&width=944.8" alt="image.png"></p><h5 id="Caching-参数"><a href="#Caching-参数" class="headerlink" title="@Caching(参数)"></a>@Caching(参数)</h5><p>用于同时添加多个缓存注解，比如：</p><div class="code-wrapper"><pre><code class="hljs javascript">@<span class="hljs-title class_">Caching</span>(evict=&#123;  @<span class="hljs-title class_">CacheEvict</span>(...)  @<span class="hljs-title class_">CacheEvict</span>(...)  ...&#125;)</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript">   @<span class="hljs-title class_">Cacheable</span>(cacheNames = <span class="hljs-string">&quot;user&quot;</span> ,condition=<span class="hljs-string">&quot;#id!=null&quot;</span>)     public <span class="hljs-title class_">User</span> <span class="hljs-title function_">getById</span>(<span class="hljs-params">  Long id</span>)&#123;     这里的cacheNames和上面的vaule是一样的。这里的condition的意思是要缓存的是下面方法的参数id但是该id不能为<span class="hljs-literal">null</span>。     <span class="hljs-string">`condition`</span> 是 <span class="hljs-string">`@Cacheable`</span> 注解的一个参数属性，用于指定缓存条件。  如果指定了 <span class="hljs-string">`condition`</span> 属性，则只有当条件表达式为 <span class="hljs-string">`true`</span> 时才会进行缓存操作</code></pre></div><p><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247486428&amp;idx=1&amp;sn=e64947b13d5261db72e7c8d3e56e9cfe&amp;chksm=fce71070cb90996677ae7a42600977855e45a9fe2fa24700b21936287c6dcfa44b9eb2ff68dd&amp;token=1673053889&amp;lang=zh_CN#rd">Spring系列缓存注解@Cacheable @CacheEvit @CachePut 使用姿势介绍</a><br><a href="https://blog.csdn.net/justry_deng/article/details/89283664">SpringBoot使用Spring缓存注解_org.springframework.cache.annotation.abstractcachi-CSDN博客</a><br><a href="https://blog.csdn.net/qq_42418169/article/details/112907375">mybatis之多行插入（批量操作）_mybatis多行插入_百日梦想家的博客-CSDN博客</a><br><a href="https://blog.csdn.net/beilizhang/article/details/117390536">mysql插入语句</a><br><a href="https://www.cnblogs.com/fnlingnzb-learner/p/10566452.html">mybatis之foreach用法 - Boblim - 博客园</a><br><a href="https://blog.csdn.net/m0_37965811/article/details/117635299">Mybatis——foreach用法_mybatis foreach_火山彬的博客-CSDN博客</a><br><a href="https://blog.csdn.net/wt_better/article/details/80941646?spm=1001.2101.3001.6650.14&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-14-80941646-blog-117635299.235%5Ev38%5Epc_relevant_default_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-14-80941646-blog-117635299.235%5Ev38%5Epc_relevant_default_base&utm_relevant_index=21">mybatis foreach标签的使用-CSDN博客</a><br>数据库中表关系中的主键和外键设置后，删除表的时候特别不方便。删除主键表必须要把其关联的外键表删除了！这个时候为了方便删除表，可以在业务层也就是用代码对插入删除进行特殊的处理让他们（这些表）处于一种逻辑上面的主键和外键关系。<br>springTask:<br><a href="https://blog.csdn.net/qq_41941477/article/details/103532393">mybatis的Update之if标签的使用-CSDN博客</a><br><a href="https://blog.csdn.net/qq991658923/article/details/127022522">Spring Boot 集成 WebSocket（原生注解与Spring封装）_springboot集成websocket-CSDN博客</a><br><a href="https://juejin.cn/post/7020964728386093093">一文吃透 WebSocket 原理 刚面试完，趁热赶紧整理 - 掘金</a><br><a href="https://echarts.apache.org/handbook/zh/get-started/?sid=iDR6W2">https://echarts.apache.org/handbook/zh/get-started/?sid=iDR6W2</a></p>]]></content>
    
    
    <categories>
      
      <category>springboot2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springboot项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件体系结构学习总结</title>
    <link href="/2024/01/26/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9A/"/>
    <url>/2024/01/26/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><a href="https://www.bilibili.com/video/BV1GE411G7hu/?spm_id_from=333.337.search-card.all.click&vd_source=add54d0fcd49c96c6c124259f9775bc3">软件体系结构-6.REST架构_哔哩哔哩_bilibili</a></p><h2 id="基础信息："><a href="#基础信息：" class="headerlink" title="基础信息："></a>基础信息：</h2><h4 id="1-设计模式和软件体系结构的区别："><a href="#1-设计模式和软件体系结构的区别：" class="headerlink" title="1.设计模式和软件体系结构的区别："></a>1.设计模式和软件体系结构的区别：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697952543929-85e364d1-96c1-4e53-aadc-d168d1cb529d.png#averageHue=%23d1cfcd&clientId=u436bf433-d833-4&from=paste&height=434&id=ub6b3d71c&originHeight=543&originWidth=901&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=112953&status=done&style=none&taskId=ub3648dd4-9e7a-41b3-8290-23089514668&title=&width=720.8" alt="image.png"></p><h4 id="2-mvn-spring-boot-run可以让spring项目跑起来"><a href="#2-mvn-spring-boot-run可以让spring项目跑起来" class="headerlink" title="2. mvn spring-boot:run可以让spring项目跑起来"></a>2. mvn spring-boot:run可以让spring项目跑起来</h4><h4 id="3-CBD：基于构建构件的软件开发"><a href="#3-CBD：基于构建构件的软件开发" class="headerlink" title="3.CBD：基于构建构件的软件开发"></a>3.CBD：基于构建构件的软件开发</h4><h4 id="构建开发例子："><a href="#构建开发例子：" class="headerlink" title="构建开发例子："></a>构建开发例子：</h4><p>springboot项目导入了模板引擎依赖和springsecurity依赖</p><div class="code-wrapper"><pre><code class="hljs javascript">@<span class="hljs-title class_">Controller</span><span class="hljs-comment">//注意这里是contreller注解，而不是@RestController；后者是基于RESFUL风格的请求;</span><span class="hljs-comment">//后者返回的是一个单纯的字符串，而前者返回的是一个视图的名称</span>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleController</span> &#123;  <span class="hljs-comment">// $&#123;&#125;获取配置文件中的信息</span>    @<span class="hljs-title class_">Value</span>(<span class="hljs-string">&quot;$&#123;spring.application.name&#125;&quot;</span>)    <span class="hljs-title class_">String</span> springApplicationName;    @<span class="hljs-title class_">GetMapping</span>(<span class="hljs-string">&quot;/&quot;</span>)  <span class="hljs-comment">// Modle返回的视图模型</span>    public <span class="hljs-title class_">String</span> <span class="hljs-title function_">homePage</span>(<span class="hljs-params">Model model</span>)&#123;      <span class="hljs-comment">// 下面的方法给视图新增了一个appName属性。该属性可以在模板引擎中用</span>        model.<span class="hljs-title function_">addAttribute</span>(<span class="hljs-string">&quot;appName&quot;</span>,springApplicationName);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;home&quot;</span>;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-comment">&lt;!--模板引擎，这里不用添加命令空间，因为导入了模板引擎依赖  --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Home Page<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Welcome to <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;appName&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript">spring.<span class="hljs-property">application</span>.<span class="hljs-property">name</span> = <span class="hljs-title class_">My</span> <span class="hljs-title class_">First</span> <span class="hljs-title class_">Web</span> <span class="hljs-title class_">App</span></code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697958874431-5f65d8e9-d9fa-4f39-897c-c98ebc81d206.png#averageHue=%23d4ae3a&clientId=u49304794-0dc7-4&from=paste&height=368&id=u03174004&originHeight=460&originWidth=831&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=87486&status=done&style=none&taskId=u81e05ce7-5b63-4b42-8245-9cb89ec10a1&title=&width=664.8" alt="image.png"></p><h4 id="反转控制和依赖注入："><a href="#反转控制和依赖注入：" class="headerlink" title="反转控制和依赖注入："></a>反转控制和依赖注入：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697959176912-7c3ecccb-59b0-44bb-9876-b2a271fed6c4.png#averageHue=%23a4c642&clientId=u49304794-0dc7-4&from=paste&height=441&id=u1f00475d&originHeight=551&originWidth=1004&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=218078&status=done&style=none&taskId=u34bb1a40-bd43-4360-a397-3e1561bc2e3&title=&width=803.2" alt="image.png"><br>控制反转IOC：<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697959249397-b0d3843c-ac38-4ad6-ae3a-9e8eac17fe2c.png#averageHue=%23d7d7d7&clientId=u49304794-0dc7-4&from=paste&height=36&id=u242c06f0&originHeight=45&originWidth=830&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=32476&status=done&style=none&taskId=u61f1eea8-2cc2-42f2-8686-1187999bf31&title=&width=664" alt="image.png"><br>上面提供服务的是Controller组件，请求者是Web Server.<br>控制反转的概念：<br>（一个组件并不创造它所依赖的组件，而是由其他控件去创建。）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697962355523-f43aabca-6ce7-45ff-8e79-21852c347fbd.png#averageHue=%23faf8f8&clientId=u49304794-0dc7-4&from=paste&height=113&id=u1a37f638&originHeight=141&originWidth=923&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=52692&status=done&style=none&taskId=u0fffc078-f22f-4039-9100-4ff37fa97c0&title=&width=738.4" alt="image.png"><br>特别符合依赖倒置原则也就是构建不依赖具体的实现类，而是依赖于一个接口。<br>（反转控件就是由一个容器独立的定义一组构建以及他们之间的依赖关系，用这种方式实现把构建在运行时组合在一起，在构建生命周期的特殊时间段调用它）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697962509900-505d7c86-5448-4683-879c-3a3f7994e575.png#averageHue=%23f8f8f8&clientId=u49304794-0dc7-4&from=paste&height=202&id=ue0a6ecf9&originHeight=252&originWidth=927&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=106721&status=done&style=none&taskId=u47c93f95-c9d8-4cd6-babc-327a36d6a94&title=&width=741.6" alt="image.png"><br>实现反转控制可以通过依赖注入或者Service Locator来实现。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697964675412-9233193c-a8d0-41c2-ba41-6100f29b08ee.png#averageHue=%23fbfbfb&clientId=u49304794-0dc7-4&from=paste&height=438&id=ub4c0e8d5&originHeight=547&originWidth=841&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=125340&status=done&style=none&taskId=u802f681a-8638-4006-8555-529c4778ce4&title=&width=672.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697964722352-c8065877-eed8-4419-bc48-71774720551b.png#averageHue=%23fbfbfb&clientId=u49304794-0dc7-4&from=paste&height=350&id=u6ca29748&originHeight=438&originWidth=959&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=124357&status=done&style=none&taskId=u60bafe33-4ee8-4dfc-99ef-ed550a28531&title=&width=767.2" alt="image.png"><br>总结：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1697967593331-4ee01bf7-25b8-4c5d-95b8-3b0658cc4bdb.jpeg"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697967875519-07dcfc7a-9b5b-4223-816a-ecd5dce11a9b.png#averageHue=%2326262a&clientId=u49304794-0dc7-4&from=paste&height=230&id=u09c07e8e&originHeight=288&originWidth=953&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=167460&status=done&style=none&taskId=u3515a796-eb0b-45e1-ba75-3b164b9e834&title=&width=762.4" alt="image.png"></p><h4 id="注解的理解："><a href="#注解的理解：" class="headerlink" title="注解的理解："></a>注解的理解：</h4><p><a href="https://blog.csdn.net/KingBoyWorld/article/details/105337011">Java注解入门到精通，这一篇就够了_java注解精通联系-CSDN博客</a><br><a href="https://blog.csdn.net/ajianyingxiaoqinghan/article/details/81436118">Java 注解 —— 注解的理解、注解的使用与自定义注解_java注解-CSDN博客</a></p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html">Redirecting…</a><br><a href="https://www.jikexueyuan.com/">极客企业版</a></p><h2 id="分层架构："><a href="#分层架构：" class="headerlink" title="分层架构："></a>分层架构：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697973508115-cb275da9-03a8-4178-bcb1-32a2920c9cc6.png#averageHue=%23fdfefc&clientId=u49304794-0dc7-4&from=paste&height=421&id=u2d27c062&originHeight=526&originWidth=781&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=207763&status=done&style=none&taskId=ued4347ea-06c2-4e1a-99b2-7926e9652e9&title=&width=624.8" alt="image.png"><br>三层体系结构：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697973933531-4ea84acd-132b-4e2b-bdb6-1442e1620c33.png#averageHue=%23fbf7f0&clientId=u49304794-0dc7-4&from=paste&height=444&id=u81034b75&originHeight=555&originWidth=973&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=221766&status=done&style=none&taskId=ue52c2db9-cb3d-4219-8d26-c34eba9d4f6&title=&width=778.4" alt="image.png"></p><h2 id="客户机服务器模式："><a href="#客户机服务器模式：" class="headerlink" title="客户机服务器模式："></a>客户机服务器模式：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697974158750-b0b7ea35-5b3a-4a34-a775-cd9ab1e3c1bd.png#averageHue=%23fdfdfd&clientId=u49304794-0dc7-4&from=paste&height=390&id=uac2b1a47&originHeight=487&originWidth=909&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=82654&status=done&style=none&taskId=ua5f862fe-ae1c-4c1d-a30b-5219e810e2f&title=&width=727.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697974366196-726befe9-168b-4995-a569-3c21363ad1f4.png#averageHue=%23fcfcfc&clientId=u49304794-0dc7-4&from=paste&height=329&id=u0dbea32e&originHeight=411&originWidth=863&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=51671&status=done&style=none&taskId=ua724f0f5-fa25-4347-942e-a5324120138&title=&width=690.4" alt="image.png"><br>Fat Client:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697974452946-db7295a0-8deb-4c5f-a77f-2ab7fcb4fa07.png#averageHue=%23fcfcfc&clientId=u49304794-0dc7-4&from=paste&height=351&id=u35073d37&originHeight=439&originWidth=1007&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=108230&status=done&style=none&taskId=u670a087e-f30b-4bb7-a229-aafc8663a1b&title=&width=805.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697974542905-fef86043-1239-4e5f-9721-9405370b20ad.png#averageHue=%23fcfcfc&clientId=u49304794-0dc7-4&from=paste&height=420&id=u9c8f4a52&originHeight=525&originWidth=972&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=135046&status=done&style=none&taskId=u1328a997-45b4-4022-96c5-b56143a5123&title=&width=777.6" alt="image.png"></p><h3 id="基于servlet的BS架构："><a href="#基于servlet的BS架构：" class="headerlink" title="基于servlet的BS架构："></a>基于servlet的BS架构：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697975183209-7e6a41ed-9c7e-4b67-bb6b-023db6784fc5.png#averageHue=%23eff0f0&clientId=u49304794-0dc7-4&from=paste&height=408&id=ub0d5a1e5&originHeight=510&originWidth=686&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=103076&status=done&style=none&taskId=u3028007d-93d5-471c-83d1-067d9e45a66&title=&width=548.8" alt="image.png"><br><a href="https://luoyong.blog.csdn.net/article/details/130204152?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-130204152-blog-117879799.235%5Ev38%5Epc_relevant_default_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-130204152-blog-117879799.235%5Ev38%5Epc_relevant_default_base&utm_relevant_index=10">Spring Boot进阶(85)：配置Jetty容器|超级详细，建议收藏_springboot jetty-CSDN博客</a><br>spring-boot更好jetty服务器后用:mvn jetty:run启动项目</p><h2 id="模型-视图-控制器："><a href="#模型-视图-控制器：" class="headerlink" title="模型-视图-控制器："></a>模型-视图-控制器：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697980670345-d96f8921-b7ce-4b44-95b5-2c29114df75b.png#averageHue=%23fafafa&clientId=u734475b1-ed84-4&from=paste&height=457&id=u79f55de2&originHeight=571&originWidth=1035&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=141435&status=done&style=none&taskId=u3208e6e3-add9-4387-b860-26b785f0a18&title=&width=828" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697980856511-b50514ae-9ec9-4e3a-9285-cb302966d3dc.png#averageHue=%23fcfcfc&clientId=u734475b1-ed84-4&from=paste&height=429&id=u04355d5c&originHeight=536&originWidth=1002&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=157239&status=done&style=none&taskId=uc1bfdfeb-3284-402b-bd46-480a7d8a741&title=&width=801.6" alt="image.png"></p><h4 id="MVC的概念："><a href="#MVC的概念：" class="headerlink" title="MVC的概念："></a>MVC的概念：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697981940499-78ee883c-8ec2-4b2b-97bd-007675fec64b.png#averageHue=%23538726&clientId=u734475b1-ed84-4&from=paste&height=431&id=ud7b1c8eb&originHeight=539&originWidth=1183&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=547298&status=done&style=none&taskId=ub12a801e-6314-4c03-9f15-fb22bc1cc8d&title=&width=946.4" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697981983781-177588ca-d219-4d9a-9e6e-6c50dc5a602d.png#averageHue=%23748b48&clientId=u734475b1-ed84-4&from=paste&height=690&id=u32e6154b&originHeight=862&originWidth=1660&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=584160&status=done&style=none&taskId=u49393f6b-4afc-4b6a-8fff-74755213873&title=&width=1328" alt="image.png"><br>上面的UI可以是模板引擎。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697982612706-9566502b-b48f-49db-ba12-9a5a36403132.png#averageHue=%23558929&clientId=u734475b1-ed84-4&from=paste&height=586&id=u050527c4&originHeight=733&originWidth=1380&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=596424&status=done&style=none&taskId=ua45351e1-9d2c-4761-876c-62daade6ff6&title=&width=1104" alt="image.png"><br>接受用户请求之后，业务不用在serve当中实现了，而是交给另外一个组件来实现这个组件就是Modle,Modle实现相关业务逻辑。Model可能是一个算法模型，或者是和数据库交互进行存储持久化操作等等。Modle执行业务逻辑得到的结果交还给Controller，Controller再交给UI进行渲染作为Respanse返回给用户。把原理单独的servlet拆分为3部分了，Modle,View,Controller.<br>Controller接收用户请求并解释用户请求交给Model来执行业务逻辑，得到的结果返回给控制器然后返回交给视图View，View将渲染后的结果当中响应返回给Client.<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697983201831-484f057c-d250-4e9e-8d00-c6454cf63fa4.png#averageHue=%23f7f7f7&clientId=u734475b1-ed84-4&from=paste&height=631&id=u7e4b5878&originHeight=789&originWidth=1622&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=303571&status=done&style=none&taskId=u9d8909fc-32a0-45c6-8843-fc4968e2987&title=&width=1297.6" alt="image.png"><br>例子：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697983343193-7ec9e50f-98d6-4886-b4b9-b57035c2c3dd.png#averageHue=%23fcfcfb&clientId=u734475b1-ed84-4&from=paste&height=523&id=ue8a4c8c6&originHeight=654&originWidth=1415&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=220986&status=done&style=none&taskId=u43ecdbe4-fe1d-4ec0-8609-fb2f3702cd9&title=&width=1132" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697983602965-c1f208d8-db72-449f-be08-62c1b7fdf27b.png#averageHue=%237da57d&clientId=u734475b1-ed84-4&from=paste&height=627&id=u84082edb&originHeight=784&originWidth=1570&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=601592&status=done&style=none&taskId=u25f3a8b0-f183-4e80-9fa6-8a1befc4eff&title=&width=1256" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697983605805-4fb74fb5-2445-4c7e-abe0-9c2a6c369bbb.png#averageHue=%23d1beb5&clientId=u734475b1-ed84-4&from=paste&height=570&id=u2fb12b65&originHeight=712&originWidth=1028&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=333821&status=done&style=none&taskId=u09d4329e-8705-4a0d-944e-ddc2cf90048&title=&width=822.4" alt="image.png"></p><h4 id="springmvc"><a href="#springmvc" class="headerlink" title="springmvc:"></a>springmvc:</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697983634413-63b5dc74-a2fb-4804-872e-41d341db6bc4.png#averageHue=%23b8b7b6&clientId=u734475b1-ed84-4&from=paste&height=666&id=u2d4450ef&originHeight=832&originWidth=929&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=241546&status=done&style=none&taskId=u3b82dfbb-1ee7-4dc3-a670-952604976e5&title=&width=743.2" alt="image.png"><br>Dispatcher:调度，分配。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697983778149-4e727f97-46e4-4caa-8f24-80e10009ad0a.png#averageHue=%23d6b141&clientId=u734475b1-ed84-4&from=paste&height=601&id=u9c72f8cb&originHeight=751&originWidth=1287&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=237892&status=done&style=none&taskId=u31972873-b6ba-47c0-8676-a2347803559&title=&width=1029.6" alt="image.png"><br>这里的Controller并不是把MVC中的M和C结合到一起了。Controller会调用相关Model中的方法。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697985852986-0cbd7b5f-f042-4da0-90df-de709286b8ea.png#averageHue=%23fcfbf5&clientId=u734475b1-ed84-4&from=paste&height=94&id=ub28a5c58&originHeight=118&originWidth=667&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=56394&status=done&style=none&taskId=u3d176cd4-db9c-43a7-bf9b-e4360f8149f&title=&width=533.6" alt="image.png"></p><h4 id="测试Controller：-WebMvcTest"><a href="#测试Controller：-WebMvcTest" class="headerlink" title="测试Controller：@WebMvcTest();"></a>测试Controller：@WebMvcTest();</h4><p>测试类上添加@WebMvcTest注解，该注解的属性值就是要测试的类，如果该要测试的类需要注入Modle的时候，也技术依赖Modle类，测试中；在测试类中要注入@Autowired  MockMvc组件模拟发送请求并断言。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697987314551-24ce1813-9e6f-49c6-84ed-4405b8d8cc68.png#averageHue=%23fdfcfc&clientId=u734475b1-ed84-4&from=paste&height=353&id=ub8dd2186&originHeight=441&originWidth=875&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=167030&status=done&style=none&taskId=uc25d757c-d39f-402f-af03-35c6b41deeb&title=&width=700" alt="image.png"><br>单纯只添加了这个注解，如果测试的类也就是控制类的时候，如果</p><h2 id="REST："><a href="#REST：" class="headerlink" title="REST："></a>REST：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698018173231-339b7dad-fb14-4ac6-ba18-5bf0bc0e07c1.png#averageHue=%23f5f5f5&clientId=u7a79556a-f9a9-4&from=paste&height=643&id=ue9bcef9d&originHeight=804&originWidth=1586&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=190959&status=done&style=none&taskId=u0b31f6a5-e1c3-4dca-8a8d-8366cb17f1a&title=&width=1268.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698018182905-4315e3e5-cf40-435d-9614-cd18536bc4fc.png#averageHue=%23fbfbfb&clientId=u7a79556a-f9a9-4&from=paste&height=703&id=ud3b73cb4&originHeight=879&originWidth=1441&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=200517&status=done&style=none&taskId=u322e17ce-b0ac-47fd-a899-4ff580304df&title=&width=1152.8" alt="image.png"></p><h4 id="统一资源接口："><a href="#统一资源接口：" class="headerlink" title="统一资源接口："></a>统一资源接口：</h4><p>所有的东西在REST下都称作资源。<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698018318571-c8a69469-e7bb-4925-b2bd-41451795ee07.png#averageHue=%23fafafa&clientId=u7a79556a-f9a9-4&from=paste&height=642&id=uc3b17c5f&originHeight=802&originWidth=1546&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=179046&status=done&style=none&taskId=u09197a86-00d4-4b0d-84fc-e846b77a29c&title=&width=1236.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698018370097-7d09f383-c6d2-4114-8c77-bbbfb5f3137b.png#averageHue=%23f4f4f4&clientId=u7a79556a-f9a9-4&from=paste&height=661&id=u85b8d103&originHeight=826&originWidth=1559&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=285214&status=done&style=none&taskId=u566186af-caf8-481f-9ffa-079d15201cb&title=&width=1247.2" alt="image.png"><br>上面的URL中分号；代表同级关系，&#x2F;代表层级关系。？后面是查询字符串，代表资源的过滤要满足的条件。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698018426982-e92f0428-7587-4440-83b6-9a28bfca1e94.png#averageHue=%23fafafa&clientId=u7a79556a-f9a9-4&from=paste&height=701&id=u1fd8c291&originHeight=876&originWidth=1285&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=240921&status=done&style=none&taskId=u77b42584-054a-40bb-9703-7fd022bf46a&title=&width=1028" alt="image.png"><br><a href="https://www.runoob.com/w3cnote/http-vs-https.html#SnippetTab">HTTP 与 HTTPS 的区别 | 菜鸟教程</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698018749614-f1ad5f33-d8df-4a20-bb59-f08e278293ed.png#averageHue=%23f3f3f3&clientId=u7a79556a-f9a9-4&from=paste&height=690&id=u551cfc02&originHeight=862&originWidth=1558&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=440719&status=done&style=none&taskId=u5686980b-0e42-4a01-afb8-de9d2b5dfd2&title=&width=1246.4" alt="image.png"><br><strong>HEAD方法</strong>跟GET方法相同，只不过服务器响应时不会返回消息体，只返回资源响应的头部信息。 一个HEAD请求的响应中，HTTP头中包含的元信息应该和一个GET请求的响应消息相同。 这种方法能够用来获取请求中隐含的元信息（元信息是描述数据或信息资源的数据），而不用传输实体自己。 也常常用来测试超连接的有效性、可用性和最近的修改。这里的资源指的是URL定义的一个资源。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698021648064-1edc6bdf-7b70-42f0-ad22-4df6a730056b.png#averageHue=%23fefefe&clientId=u7a79556a-f9a9-4&from=paste&height=375&id=ud2231a34&originHeight=469&originWidth=905&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=166772&status=done&style=none&taskId=u11e811fa-59a9-4a81-87cc-2df8ebf3c7f&title=&width=724" alt="image.png"><br>get请求的安全是不管请求多少次都不会改变服务器的状态的，幂等是多次HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用，幂等性——是系统的接口对外一种承诺（而不是实现），承诺只要调用接口成功，外部多次调用对系统的影响是一致的。<br>一个幂等的操作典型如：把编号为5的记录的A字段设置为0，这种操作不管执行多少次都是幂等的。<br>一个非幂等的操作典型如：把编号为5的记录的A字段增加1，这种操作显然就不是幂等的。这里get幂等的意思是多次get都是获取同一资源，对服务器上的资源没有副作用。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698021917232-26551e4d-dad1-4131-bfb7-5fa28c7c19e3.png#averageHue=%23f0f0f1&clientId=u7a79556a-f9a9-4&from=paste&height=420&id=u17d42d5c&originHeight=525&originWidth=917&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=255984&status=done&style=none&taskId=u2613032b-7f8f-424a-811e-a4d464f0ff7&title=&width=733.6" alt="image.png"><br><a href="https://www.cnblogs.com/gyjjyg/p/9855511.html">理解http的幂等性 - yjge - 博客园</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698022556197-4340d667-960c-4645-8c46-6e8ebbd42ea4.png#averageHue=%23fefefe&clientId=u7a79556a-f9a9-4&from=paste&height=395&id=u5ed7dcfc&originHeight=494&originWidth=918&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=223098&status=done&style=none&taskId=u5595e437-a491-452a-ad65-9cc7f7ece2e&title=&width=734.4" alt="image.png"><br>post url请求中url标识对该请求的处理并创建资源，这样多次post请求可能会生成多个资源实例，其多次请求对服务器产生了不一样的效果：生成了多个url资源；但是put请求中的url就是该表该要修改的资源，多次相同的put请求都是对同一个url产生效果。<br>就跟上面一样：put请求是用客户端的实例号创建资源，后面的相同的put请求就是在相同的url上进行修改。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698022903545-c27559e9-7c54-4d55-b44e-c9b3c0883578.png#averageHue=%23fefefe&clientId=u7a79556a-f9a9-4&from=paste&height=370&id=u99a0e18a&originHeight=462&originWidth=933&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=112371&status=done&style=none&taskId=ucbd76200-a6e2-4186-b940-ffbca521d43&title=&width=746.4" alt="Snipaste_2023-10-23_09-01-35.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698022953990-4a500979-4c0a-46e1-8a16-f3c90fc5e97f.png#averageHue=%23fdfdfd&clientId=u7a79556a-f9a9-4&from=paste&height=345&id=u326862c6&originHeight=431&originWidth=924&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=120867&status=done&style=none&taskId=u4fa409e3-98b5-478b-8054-5477af6bbff&title=&width=739.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698022966939-14786148-b3fc-41a1-9e48-4428e02aebd5.png#averageHue=%23fdfdfd&clientId=u7a79556a-f9a9-4&from=paste&height=402&id=u653f6e17&originHeight=502&originWidth=925&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=201160&status=done&style=none&taskId=u27aafe9e-33dd-47aa-b150-0c3d7eaffc1&title=&width=740" alt="image.png"><br>总结：url代表的是服务器一个资源的标识符，一个资源可以有多个标识符；但是一个url只能指向一个资源。<br>url中的?后面跟的是参数，分号代表同级下的资源，&#x2F;斜杠代表层级结构。<br>REST中的get,HEAD是安全且幂等的。安全是服务器中的资源在该请求下不会发送变化，幂等是同样的请求，多次都是针对同一个url，且对系统资源的影响是一样的就是幂等性。<br>get HEAD是安全幂等的，是他们的请求既不会对服务器的资源产生变化，且多次请求都是对同一个资源进行获取，对服务器是无影响的。<br>POST是不安全且不幂等的，因为post请求是创建资源或更新资源，都会资源发送变化（就算改变后的数据和改变前的数据是一样的，但是该数据的确是改变了的）。POST URL请求中的URL是服务端的请求对象，这里的URL并非操作资源的标识符，指定了URL请求对象可能在多次POST会产生不同的情况，也就是2次同样的POST请求可能操作的资源不是同一个，这样对服务器的影响是不一样的。<br>PUT请求是不安全但是幂等的。幂等的原因是PUT URL中的URL指向是具体的资源，多个相同的PUT请求都是对同一个URL进行操作。</p><h4 id="REST的资源表征和状态转移："><a href="#REST的资源表征和状态转移：" class="headerlink" title="REST的资源表征和状态转移："></a>REST的资源表征和状态转移：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698024138765-a08f53d2-1d4d-4078-b3bb-d46ff864290a.png#averageHue=%23ebebec&clientId=u7a79556a-f9a9-4&from=paste&height=364&id=u38b91ad1&originHeight=455&originWidth=935&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=224048&status=done&style=none&taskId=ua800327e-5e8f-424d-850b-6d62d56d97e&title=&width=748" alt="image.png"><br>比如数据库中的一条记录就是一个资源，它可以表示为JSON格式作为响应体响应出去，也可以作为相应的变量传递给模板引擎，后面的情况就是资源的表现层。<br> <img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698024392473-63574539-8dd3-4370-90a1-4e6397fd0d75.png#averageHue=%23ececec&clientId=u7a79556a-f9a9-4&from=paste&height=392&id=u00e65c6c&originHeight=490&originWidth=934&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=260848&status=done&style=none&taskId=uf2dc333f-7838-4807-a0c6-10a0c372a37&title=&width=747.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698024655852-8a81f475-5bb2-488a-ac11-3e1708468043.png#averageHue=%23e2ead4&clientId=u7a79556a-f9a9-4&from=paste&height=422&id=ua0629266&originHeight=528&originWidth=953&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=307248&status=done&style=none&taskId=uc577fbaa-cd1d-4bd5-8f7f-d7935bd763a&title=&width=762.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698025253620-155add42-33d3-4f39-b25f-3af31ecd593a.png#averageHue=%23e4ebd4&clientId=u7a79556a-f9a9-4&from=paste&height=425&id=u09477531&originHeight=531&originWidth=959&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=262800&status=done&style=none&taskId=u9aaf740f-dbd4-4977-9b2b-91176b65ba0&title=&width=767.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698025441670-1091c508-141c-44b0-81a2-511b0a8cf354.png#averageHue=%23edf3df&clientId=u7a79556a-f9a9-4&from=paste&height=370&id=u7e5de6de&originHeight=463&originWidth=811&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=185770&status=done&style=none&taskId=u4d5feeb0-087a-4b34-b97a-2c6c9972881&title=&width=648.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698025484225-2bb4cdb6-c6f0-40d0-82af-4e77b9c8478b.png#averageHue=%23f9f9f9&clientId=u7a79556a-f9a9-4&from=paste&height=437&id=ufd1cfd04&originHeight=546&originWidth=959&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=210098&status=done&style=none&taskId=u2e9977c9-c9d4-4a3c-bf77-dee29caf0e4&title=&width=767.2" alt="image.png"><br>状态转移：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698029345277-cb2572ac-40a6-449e-868b-d340be4df942.png#averageHue=%23dddddd&clientId=u7a79556a-f9a9-4&from=paste&height=67&id=u8d8adc8a&originHeight=84&originWidth=882&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=56155&status=done&style=none&taskId=ud8d1ee41-f064-49d0-8405-ed32398f96e&title=&width=705.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698029600852-6c15950c-e7a7-44ea-91cd-41b33cfec5d7.png#averageHue=%23dedede&clientId=u7a79556a-f9a9-4&from=paste&height=155&id=u7afdaf44&originHeight=194&originWidth=907&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=126164&status=done&style=none&taskId=uccdbc11d-133a-4d85-9a80-0e04377c94c&title=&width=725.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698029663890-cb454a53-79f9-4e74-87d2-6b557084c222.png#averageHue=%23696e6b&clientId=u7a79556a-f9a9-4&from=paste&height=356&id=u35f35560&originHeight=445&originWidth=923&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=293791&status=done&style=none&taskId=u61276bf1-815c-48e2-8c95-d892af822dc&title=&width=738.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698029884723-d64aa6c3-3a91-44ca-8d0c-1359229aec97.png#averageHue=%235a5e5a&clientId=u7a79556a-f9a9-4&from=paste&height=365&id=ubae1f7e8&originHeight=456&originWidth=930&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=281904&status=done&style=none&taskId=u22686dba-887b-475e-ad72-684687a94d7&title=&width=744" alt="image.png"><br>上面的点击进入下一个页面并成功进入到下一个页面了，就是客户端实现了状态转移。<br><a href="https://www.cnblogs.com/mzq123/p/11747845.html">SpringBoot HATEOAS用法简介 - smileNicky - 博客园</a><br><a href="https://zhuanlan.zhihu.com/p/626962131">Spring ResponseEntity 详解：从原理到实践</a></p><h2 id="可扩展架构："><a href="#可扩展架构：" class="headerlink" title="可扩展架构："></a>可扩展架构：</h2><p>传统的CS架构只有一个服务器，当请求数量特别多的时候，服务器压力特别大。</p><h4 id="压力测试："><a href="#压力测试：" class="headerlink" title="压力测试："></a>压力测试：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698039097227-3b04994d-8e30-4949-983b-992a0dfff95f.png#averageHue=%23fefaf8&clientId=uaffa3aa4-bdea-4&from=paste&height=166&id=u9d10e904&originHeight=208&originWidth=531&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=35960&status=done&style=none&taskId=ubae9359e-e173-4c10-b922-85f54502cb1&title=&width=424.8" alt="image.png"><br><a href="https://xiuxiuing.gitee.io/blog/2018/09/18/gatlingintellij/">使用IntelliJ开发Gatling - 咻咻ing</a></p><h4 id="垂直扩展："><a href="#垂直扩展：" class="headerlink" title="垂直扩展："></a>垂直扩展：</h4><p>更新硬件或者更好服务器提到性能。<br><a href="https://blog.csdn.net/qq_40298902/article/details/106543208">https://blog.csdn.net/qq_40298902&#x2F;article&#x2F;details&#x2F;106543208</a></p><h4 id="SpringCaching-Redis"><a href="#SpringCaching-Redis" class="headerlink" title="SpringCaching Redis:"></a>SpringCaching Redis:</h4><p><a href="https://blog.csdn.net/qq_44421399/article/details/109825479">@Repository 与 @Mapper的区别-CSDN博客</a><br><a href="https://blog.csdn.net/qq_31635851/article/details/120886426">【精选】【Spring Boot】Spring Boot + H2 Database 示例_springboot h2 database创建表-CSDN博客</a><br><a href="https://blog.csdn.net/qq_59363371/article/details/133758281">haproxy负载均衡_sorry#的博客-CSDN博客</a></p><h4 id="SpringsessionJDBC"><a href="#SpringsessionJDBC" class="headerlink" title="SpringsessionJDBC:"></a>SpringsessionJDBC:</h4><p><a href="https://www.bing.com/ck/a?!&&p=7e43384f8ea7ba95JmltdHM9MTY5ODAxOTIwMCZpZ3VpZD0wZjZlN2RlZC04YjRmLTZiYWQtMWQ2YS02ZTk4OGFhNTZhY2UmaW5zaWQ9NTQ1MA&ptn=3&hsh=3&fclid=0f6e7ded-8b4f-6bad-1d6a-6e988aa56ace&psq=session%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%B6%88%E5%A4%B1&u=a1aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hwZWFjaGVuZy9hcnRpY2xlL2RldGFpbHMvMTIwNTM2NzMyIzp-OnRleHQ9JUU2JTg4JTkxJUU0JUJCJUFDJUU5JTgzJUJEJUU3JTlGJUE1JUU5JTgxJTkzU2Vzc2lvbiVFNiU5OCVBRiVFNSU4RiVBRiVFNCVCQiVBNSVFNiU4QyU4MSVFNCVCOSU4NSVFNSU4QyU5NiVFNSU5QyVBOCVFNiU5QyU4RCVFNSU4QSVBMSVFNSU5OSVBOCVFNCVCOCVBRCVFNCVCRiU5RCVFNSVBRCU5OCVFNyU5QSU4NCVFRiVCQyU4QyVFOCU4MCU4QyVFNCVCOCU5NCVFOSVCQiU5OCVFOCVBRSVBNCVFNiU5NyVCNiVFOSU5NyVCNCVFNiU5OCVBRjMwJUU1JTg4JTg2JUU5JTkyJTlGJUVGJUJDJThDJUU4JUJGJTk5JUU0JUI4JUFBJUU2JTk4JUFGJUU1JThGJUFGJUU0JUJCJUE1JUU1JTlDJUE4Y29uZiUyRndlYi54bWwlRTYlOTYlODclRTQlQkIlQjYlRTUlQTQlQjklRTQlQjglOEIlRTUlOEYlQUYlRTQlQkIlQTUlRTQlQkYlQUUlRTYlOTQlQjklRTclOUElODQlRUYlQkMlOEMlRTUlQjklQjYlRTQlQjglOTRTZXNzaW9uJUU1JThGJUFBJUU2JTlDJTg5JUU1JTlDJUE4JUU2JTlDJThEJUU1JThBJUExJUU1JTk5JUE4JUU1JTg1JUIzJUU5JTk3JUFEJUU3JTlBJTg0JUU2JTk3JUI2JUU1JTgwJTk5JUVGJUJDJThDJUU2JTg4JTk2JUU4JTgwJTg1JUU0JUJEJUJGJUU3JTk0JUE4LGludmFsaWRhdGUlMjAlMjglMjklRTclOUElODQlRTYlOTclQjYlRTUlODAlOTklRTYlODklOEQlRTQlQkMlOUElRTYlQjYlODglRTUlQTQlQjElRTMlODAlODI&ntb=1">session存活时间</a><br><a href="https://www.yuque.com/gezigezi-lc6ye/wn4u60/clx59t?view=doc_embed">可扩展架构-续</a></p><h2 id="管道过滤器结构："><a href="#管道过滤器结构：" class="headerlink" title="管道过滤器结构："></a>管道过滤器结构：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698111542403-22360f2c-232b-42d3-8fac-f860b57c14c7.png#averageHue=%23fbfbfb&clientId=u4d1c17cb-e6d8-4&from=paste&height=617&id=u26034929&originHeight=771&originWidth=1471&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=118980&status=done&style=none&taskId=u13a5b9c5-d7a7-4649-8a56-789876c3783&title=&width=1176.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698111599403-d514dbe9-2433-4604-a71f-79e7d6f265be.png#averageHue=%23fcfcfc&clientId=u4d1c17cb-e6d8-4&from=paste&height=632&id=ub71c2934&originHeight=790&originWidth=1640&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=122713&status=done&style=none&taskId=u38b5e005-0f8c-485a-93bb-ee1c0561607&title=&width=1312" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698111709762-163c62ca-c2f3-4b7d-a715-d7eff18660d4.png#averageHue=%23f4f4f4&clientId=u4d1c17cb-e6d8-4&from=paste&height=660&id=ucbc10473&originHeight=825&originWidth=1432&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=249265&status=done&style=none&taskId=u760c50f2-448d-4508-91b8-7826ac2a1d2&title=&width=1145.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698111862134-65d5aaee-6f8b-4d12-b57e-8a2515ca37e6.png#averageHue=%23f2f2f2&clientId=u4d1c17cb-e6d8-4&from=paste&height=604&id=u9e3dc042&originHeight=755&originWidth=1538&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=276134&status=done&style=none&taskId=ua111ee66-0010-4435-8f99-074c72f343f&title=&width=1230.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698111898662-bf4ad5b0-f2db-453c-a504-55d1350f4a5d.png#averageHue=%23f2f2f2&clientId=u4d1c17cb-e6d8-4&from=paste&height=587&id=u6df19330&originHeight=734&originWidth=1500&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=212100&status=done&style=none&taskId=u095a9fa8-14aa-4513-b95e-6bf73c9d60c&title=&width=1200" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698111913217-88ad40bf-6ef2-41ee-a9d4-f41d6de57856.png#averageHue=%23f1f1f1&clientId=u4d1c17cb-e6d8-4&from=paste&height=664&id=uef8ec7fb&originHeight=830&originWidth=1535&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=369640&status=done&style=none&taskId=ubd7eeecf-a399-4d96-8f05-2c16c83c49f&title=&width=1228" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698111942558-7374244f-2edd-4c26-a84b-cdb9b763a806.png#averageHue=%23fcfcfc&clientId=u4d1c17cb-e6d8-4&from=paste&height=684&id=uff3dc625&originHeight=855&originWidth=1372&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=138388&status=done&style=none&taskId=u73a4f72e-d678-4d26-8001-fdd84ed4d52&title=&width=1097.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698111969254-bdbb8a65-d08e-45f9-8ccb-0e9d735a4af6.png#averageHue=%23f8f8f8&clientId=u4d1c17cb-e6d8-4&from=paste&height=668&id=u1e7f0dbd&originHeight=835&originWidth=1415&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=145919&status=done&style=none&taskId=u1b582beb-b2fa-44de-833b-e9eb7e7d140&title=&width=1132" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698111992119-90a67c3a-fab1-4216-bf1e-3041861a2c3a.png#averageHue=%23f8f8f8&clientId=u4d1c17cb-e6d8-4&from=paste&height=584&id=u1ce4f4b0&originHeight=730&originWidth=1363&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=144944&status=done&style=none&taskId=ub2ec7e0a-ba09-4a49-9033-c60fb47e649&title=&width=1090.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698112033911-9ef16fc5-fe4c-4aa9-871e-546121a15be3.png#averageHue=%23f9f9f9&clientId=u4d1c17cb-e6d8-4&from=paste&height=354&id=u14244ff8&originHeight=442&originWidth=1267&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=117291&status=done&style=none&taskId=u831772ce-9d25-410b-ae0b-abce3fbc722&title=&width=1013.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698112061008-acbfeeec-2178-428b-a83e-87d2a70a5622.png#averageHue=%23f4f4f4&clientId=u4d1c17cb-e6d8-4&from=paste&height=562&id=ua0e54674&originHeight=702&originWidth=1482&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=128325&status=done&style=none&taskId=udcdd1e7d-751c-4549-bd3d-24ca8118d93&title=&width=1185.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698112071807-8d2413c9-081b-415f-8fe8-10ec81511198.png#averageHue=%23f5f5f5&clientId=u4d1c17cb-e6d8-4&from=paste&height=675&id=u436c350c&originHeight=844&originWidth=1579&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=307989&status=done&style=none&taskId=u4107cb5f-e93c-40fb-a10c-f99d34497b7&title=&width=1263.2" alt="image.png"><br>JavaIO流大都情况下是这个模式。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698112139507-7bf55aa6-f750-4d9d-bf98-182db10724b6.png#averageHue=%23fbfbfb&clientId=u4d1c17cb-e6d8-4&from=paste&height=641&id=udc005eed&originHeight=801&originWidth=1477&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=126842&status=done&style=none&taskId=uc6721cd9-d260-4c7a-9aff-70a0d5e57f8&title=&width=1181.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698112183822-b9803781-3f96-4874-99a2-00d477340a17.png#averageHue=%23f9f9f9&clientId=u4d1c17cb-e6d8-4&from=paste&height=688&id=ua93d279f&originHeight=860&originWidth=1538&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=328048&status=done&style=none&taskId=u2cdb4414-79b1-4020-b1f1-293b2cd8590&title=&width=1230.4" alt="image.png"><br>pipe实现了在父子进程之间的通信。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698112272369-0d972c5b-a118-48fa-bc43-5c5f8ded5432.png#averageHue=%23f6f5f4&clientId=u4d1c17cb-e6d8-4&from=paste&height=595&id=u2cb49bc3&originHeight=744&originWidth=1508&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=291818&status=done&style=none&taskId=u685ebbc7-0090-4166-acca-54a5db02dce&title=&width=1206.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698112324985-d782706f-b86e-4d0f-b147-b946c84f1724.png#averageHue=%23fbfbfb&clientId=u4d1c17cb-e6d8-4&from=paste&height=723&id=u2c8cd9ac&originHeight=904&originWidth=1696&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=273726&status=done&style=none&taskId=u1977a55e-a72d-43b4-beb0-54d93eed91a&title=&width=1356.8" alt="image.png"><br>通过中间形式实现不同语言的互通。</p><h4 id="SpringBatch-进行大批批处理的框架"><a href="#SpringBatch-进行大批批处理的框架" class="headerlink" title="SpringBatch:进行大批批处理的框架"></a>SpringBatch:进行大批批处理的框架</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698112403869-68343d01-179a-4c4d-b723-446adeb6eecf.png#averageHue=%23f2f3f2&clientId=u4d1c17cb-e6d8-4&from=paste&height=649&id=u10efbd8a&originHeight=811&originWidth=1552&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=383369&status=done&style=none&taskId=uff5f7288-8d10-4626-a6b5-517ac0ad993&title=&width=1241.6" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698112513669-29e4a06b-8474-479e-86a8-60a3c7f577e9.png#averageHue=%23f7f2ec&clientId=u4d1c17cb-e6d8-4&from=paste&height=697&id=u9d790273&originHeight=871&originWidth=1351&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=215942&status=done&style=none&taskId=uf0117dbc-6f41-4633-a92f-e9fc1305c51&title=&width=1080.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698112576440-1f5df12f-22c8-4ff1-b45f-855c0942b579.png#averageHue=%23fbf9f4&clientId=u4d1c17cb-e6d8-4&from=paste&height=666&id=u3cdba329&originHeight=832&originWidth=1461&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=216267&status=done&style=none&taskId=u6ee3173f-f6fc-49a1-9c2e-29e35b662c7&title=&width=1168.8" alt="image.png"><br><a href="https://spring.io/projects/spring-batch">Spring Batch</a><br><a href="https://spring.io/batch">Batch</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698112942602-b70256f0-0497-48b2-b7b1-ef3870248b63.png#averageHue=%23fdfcfb&clientId=u4d1c17cb-e6d8-4&from=paste&height=457&id=ub4cd4964&originHeight=571&originWidth=1012&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=271856&status=done&style=none&taskId=u3aa8a0c9-3005-4ddc-b462-732ffeb4671&title=&width=809.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698113063287-b81b2d51-5d8e-4b70-9cef-1dc982a29de5.png#averageHue=%23f5f5f5&clientId=u4d1c17cb-e6d8-4&from=paste&height=735&id=uf43e818c&originHeight=919&originWidth=1587&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=495311&status=done&style=none&taskId=u10688858-52e3-460f-ad59-bc61f007e73&title=&width=1269.6" alt="image.png"></p><h2 id="事件驱动架构："><a href="#事件驱动架构：" class="headerlink" title="事件驱动架构："></a>事件驱动架构：<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698114239770-0b4a0ce9-ef27-409c-a0da-a7dbf0bff81e.png#averageHue=%23f8f8f8&clientId=u4d1c17cb-e6d8-4&from=paste&height=702&id=u9a9ae9ba&originHeight=877&originWidth=1666&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=229772&status=done&style=none&taskId=u1dc28dfa-597f-4ace-adc4-a0fc6c92bd8&title=&width=1332.8" alt="image.png"></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698114298557-a1738aca-1885-4cb5-8947-d755c3ece8ef.png#averageHue=%23f6f6f6&clientId=u4d1c17cb-e6d8-4&from=paste&height=688&id=u0c056f53&originHeight=860&originWidth=1613&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=223383&status=done&style=none&taskId=u924d4caa-d359-4077-8861-b3a29471d43&title=&width=1290.4" alt="image.png"></h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698114326988-288ae8a2-19bb-4cf7-a6a5-ba41f8fe0c7d.png#averageHue=%23c7b97a&clientId=u4d1c17cb-e6d8-4&from=paste&height=654&id=u3008e674&originHeight=817&originWidth=1584&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=675407&status=done&style=none&taskId=u2dc75531-8d30-4a26-8476-4d98726a47c&title=&width=1267.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698114359262-4a00707e-d66e-42de-8f5e-de266a57ac28.png#averageHue=%23f5ede0&clientId=u4d1c17cb-e6d8-4&from=paste&height=673&id=u75b6c92a&originHeight=841&originWidth=1560&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=378016&status=done&style=none&taskId=u4b556cb9-ac30-4cae-882e-84a283f5d31&title=&width=1248" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698114383154-e9c0f3be-0e91-4f78-888b-bcb9be5ef34b.png#averageHue=%23f6f6f6&clientId=u4d1c17cb-e6d8-4&from=paste&height=596&id=u68b51cb4&originHeight=745&originWidth=1266&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=195742&status=done&style=none&taskId=u2e310a33-a86a-4e9d-b06d-1e150f11f0c&title=&width=1012.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698114450537-b3cea071-8dd6-4321-86d7-2965cb03ef92.png#averageHue=%23f8f6f5&clientId=u4d1c17cb-e6d8-4&from=paste&height=621&id=u84ac8ce9&originHeight=776&originWidth=1240&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=206724&status=done&style=none&taskId=u6b08dae9-3153-4f59-923d-76c830b822d&title=&width=992" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698114487691-4d4a70fa-4c19-4902-9dd7-f636c6d810b2.png#averageHue=%23faf9f2&clientId=u4d1c17cb-e6d8-4&from=paste&height=527&id=ud450b2b6&originHeight=659&originWidth=1079&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=145617&status=done&style=none&taskId=ubb0b4a96-9305-406e-b6fb-89c695367ec&title=&width=863.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698114591938-7ab69a43-818b-43b6-bfa4-cf1f72b4d751.png#averageHue=%23f2f1f1&clientId=u4d1c17cb-e6d8-4&from=paste&height=559&id=u5eabfa53&originHeight=699&originWidth=1369&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=372538&status=done&style=none&taskId=u9ca84bef-931c-4f7e-bc21-e9b54ba4c86&title=&width=1095.2" alt="image.png"><br><a href="https://www.cnblogs.com/caicz/p/15127904.html">Spring Event奇技淫巧 - 菜菜聊架构 - 博客园</a><br><a href="https://www.baeldung.com/spring-events">Just a moment…</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698114671024-60dd429c-d10a-4fe0-951d-e831298290cc.png#averageHue=%23f8f8f8&clientId=u4d1c17cb-e6d8-4&from=paste&height=675&id=uac1bc5f6&originHeight=844&originWidth=1651&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=389818&status=done&style=none&taskId=ufeb54eb1-2118-4851-8c88-628a51e5149&title=&width=1320.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698114973444-e757d85c-dd8a-4e16-ae0d-3ff05d1cb699.png#averageHue=%23f0efee&clientId=u4d1c17cb-e6d8-4&from=paste&height=638&id=u88d49958&originHeight=798&originWidth=1432&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=469066&status=done&style=none&taskId=uf4504bad-6c2e-4370-b7ec-9b6d9be78bc&title=&width=1145.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698115003732-2d073421-e7a8-42a1-a4b4-9fd221522200.png#averageHue=%23f69762&clientId=u4d1c17cb-e6d8-4&from=paste&height=721&id=u9c509b26&originHeight=901&originWidth=1604&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=318400&status=done&style=none&taskId=u852be7c0-d509-40ce-98c8-4805d9e9495&title=&width=1283.2" alt="image.png"></p><h2 id="响应式架构："><a href="#响应式架构：" class="headerlink" title="响应式架构："></a>响应式架构：</h2><p>响应式架构比springmvc吞吐率高，执行效率也高。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698117409784-af643b8c-1ddb-4885-83f0-574e1ddb38f8.png#averageHue=%23f6f6f6&clientId=u4d1c17cb-e6d8-4&from=paste&height=650&id=u28804216&originHeight=813&originWidth=1669&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=291827&status=done&style=none&taskId=u3f06b05d-0842-401b-961f-eb71e0ecbc6&title=&width=1335.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698117654697-2bf6b061-debf-4347-bd8e-c72c18d5b803.png#averageHue=%23f9f9f8&clientId=u4d1c17cb-e6d8-4&from=paste&height=686&id=u5080ed24&originHeight=857&originWidth=1666&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=260988&status=done&style=none&taskId=ufbc3cdfa-0fe1-43ef-ba64-fcaecba8b43&title=&width=1332.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698119268912-af228d7d-6c19-4f24-ba98-2a4f1e0b370d.png#averageHue=%23c0bf66&clientId=u4d1c17cb-e6d8-4&from=paste&height=438&id=ue7a0f927&originHeight=548&originWidth=997&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=276704&status=done&style=none&taskId=u0ea251ec-b4ce-4c94-ad69-9f9d6de6496&title=&width=797.6" alt="image.png"><br>原因：REST风格的spring项目，当每个请求来的时候就会在tomcat服务器中的线程池中创建一个线程，而线程的创建和切换都会有额外的开销，但是当其中的一个用户请求创建的线程陷入到了阻塞，分配给该线程的cpu是浪费的；而响应式是将数据的请求当成一个流，当一个请求陷入了阻塞，线程就会切换到另外的地方处理其他失去而非等待。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698124843727-2f5464b9-a1eb-4c0f-9d1b-2b379ba940df.png#averageHue=%23f9f9f3&clientId=u4d1c17cb-e6d8-4&from=paste&height=642&id=uf37fb6f1&originHeight=802&originWidth=1354&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=289669&status=done&style=none&taskId=u17766a7a-65fd-4d9d-98f9-5ca682d9162&title=&width=1083.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698124854963-e17d3edc-983b-496e-85df-f874c7be8b0e.png#averageHue=%23f6f6f5&clientId=u4d1c17cb-e6d8-4&from=paste&height=641&id=u60c86613&originHeight=801&originWidth=1498&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=284635&status=done&style=none&taskId=u67450b8a-4f13-4505-aa23-633aeac1cc4&title=&width=1198.4" alt="image.png"></p><h1 id="复习："><a href="#复习：" class="headerlink" title="复习："></a>复习：</h1><p><a href="https://leibudao.github.io/posts/safinalexam/">软件体系结构期末复习</a><br><a href="https://acupofair.github.io/post/software_arch/">软件体系结构核心点复习</a><br><a href="https://blog.csdn.net/weixin_51970555/article/details/125272228">软件体系结构期末复习六十题_软件设计与体系结构期末考试题-CSDN博客</a><br>1.软件架构包括组件、连接件和约束三大要素。</p><ul><li>组件：可以是一组代码，也可以是独立的程序。</li><li>连接件：可以是过程调用、管道和消息等，用于表示组件间的相互关系。</li><li>约束：组件连接时的条件。</li></ul><p><a href="https://www.cnblogs.com/qixin/p/3163536.html">“4+1”视图模型 - QI XIN - 博客园</a><br><a href="https://leibudao.github.io/posts/safinalexam/">软件体系结构期末复习</a><br>主义上面2种关于4+1不同的说法，但是实质是一样的，只不过使用的标准不一样。第一个是某个论文提出的，第二个是Rational Rose中提出的，但是他们的本质是不变的。<br>1.逻辑视图是描述系统的功能需求的，也即是系统提供给用户什么服务。通常包括类图、对象图、状态图和协作图<br>2.过程视图：描述系统中的进程，该视图通常包含活动图、顺序图等。<br>3.开发视图侧重于软件模块的组织和管理。也就是组织软件模块，库，子系统，开发单元。</p><ul><li>描述系统的各部分如何被组织为模块和组件。</li><li>该视图通常包含包图和组件图。</li><li>管理系统体系结构中的层非常有用。</li></ul><p>4.物理视图：将其他元素映射到处理和通信节点。描述如何将前三个视图中所述的系统设计实现为一组现实世界的实体，该视图通常包含部署图，展示了抽象部分如何映射到最终部署的系统中。<br>5.用例视图（场景视图）：将其他视图映射到重要的用例（这些用例被称作场景）上对体系结构加以说明。场景视图就是描述现实中的一个系统运用场景的过程；</p><ul><li>从外部世界的角度描述正在建模的系统的功能。</li><li>需要使用此视图来描述系统应该执行的操作。 所有其他视图都依靠用例视图（场景）来指导，这就是将模型称为4 + 1的原因。</li><li>该视图通常包含用例图，描述和概述图。</li></ul><p>为什么事件驱动的特殊风格的架构存在数据交换的问题？</p><div class="code-wrapper"><pre><code class="hljs java">一个问题是事件驱动架构中的数据交换需要通过事件消息进行，这可能导致数据的复制和传递过程。当一个事件被触发时，它必须通过事件消息进行传递到相应的处理器或订阅者。这可能涉及将数据从一个组件复制到另一个组件，从而引入了额外的开销和延迟。如果系统中存在大量频繁的数据交换，这种复制和传递过程可能会成为性能瓶颈。此外，事件驱动架构中的数据交换通常是异步的。当事件被触发时，发送事件消息的组件不会立即等待接收方的响应。这意味着在事件消息被处理之前，发送方无法得知接收方的状态或结果。这种异步性质可以增加系统的复杂性，特别是在处理涉及多个事件和依赖关系的复杂业务逻辑时。另一个可能的问题是事件驱动架构中的数据一致性。由于事件消息的异步性质，可能存在事件消息的顺序问题或丢失问题。如果事件消息的顺序很重要，或者某些事件消息丢失将导致数据不一致，那么在设计和实现事件驱动架构时需要考虑这些问题，并采取适当的措施来确保数据的一致性。</code></pre></div><p>黑板知识库：</p><div class="code-wrapper"><pre><code class="hljs java">黑板知识库（Blackboard Knowledge Base）是一种软件架构中的组件，用于支持基于协同问题解决的系统。它的设计灵感来自于人类协同问题解决的模式，其中多个专家在一个黑板上共同解决复杂问题。在黑板知识库的架构中，系统的问题被表示为一个共享的黑板，也称为黑板区域（Blackboard Area）。问题的初始状态被放置在黑板上，然后系统中的多个独立的专家组件（称为知识源）并行地观察和分析问题，并尝试提供解决方案。每个知识源是一个独立的模块，具有特定的知识、推理能力或算法。它们独立地工作，观察黑板上的问题状态，并生成或修改与问题相关的信息。每当知识源做出改变时，它将其结果写回黑板，以便其他知识源可以读取并进行进一步的推理和分析。黑板知识库架构的核心思想是通过知识源之间的协同合作来解决问题。不同的知识源可以具有不同的专业领域知识、算法或推理能力，它们可以根据自己的知识和推理结果来决定何时对问题状态进行修改。这种协同合作的方式可以使系统更具灵活性和适应性，能够处理复杂的、多学科的问题。黑板知识库的架构适用于解决那些问题领域复杂、需要多种专业知识和推理方法的应用。它可以应用于领域如人工智能、专家系统、机器学习和数据挖掘等。</code></pre></div><p>C2风格是什么？</p><div class="code-wrapper"><pre><code class="hljs java">C2风格的设计灵感来自于人类协同工作的模式，例如团队合作、集体智慧和群体决策。它提供了一种机制和架构，使得分布在不同位置的多个计算节点能够相互通信、协同工作和协同决策。C2风格的核心概念是<span class="hljs-string">&quot;C2&quot;</span>，即指挥与控制（Command and Control）。在这种风格下，一个或多个指挥节点（Command Node）负责协调和指导系统中的其他节点。指挥节点可以收集、分析和传达信息，协调节点之间的工作，并做出决策。其他节点被称为执行节点（Execution Node），它们根据指挥节点的指令执行任务，并将结果反馈给指挥节点。执行节点之间可以相互通信和协作，共同解决问题。指挥节点可以根据执行节点的反馈信息进行调整和决策，以实现协同工作和协同决策的目标。</code></pre></div><p>剪切板应该是什么体系结构？</p><div class="code-wrapper"><pre><code class="hljs java">体系结构的角度来看，剪切板功能可以被认为是一个典型的发布-订阅（Publish-Subscribe）或观察者模式（Observer Pattern）。应用程序可以将数据发布到剪切板，并通知操作系统，表示数据可供其他应用程序订阅和使用。其他应用程序可以订阅剪切板，并在有新数据可用时接收通知，并获取数据以供其自身使用。</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700013735889-9777f591-8570-43b1-b655-3dd7df475e42.png#averageHue=%23fcfcfb&clientId=u742374d8-b650-4&from=paste&height=245&id=ud09a17da&originHeight=306&originWidth=532&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=17678&status=done&style=none&taskId=ude90b039-6dce-4d2e-b4a2-5d801c6e947&title=&width=425.6" alt="image.png"><br>过程控制是属于控制流的体系结构。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700013822753-5556384c-7bac-49c4-99c1-694c0b54fb99.png#averageHue=%23fdfdfc&clientId=u742374d8-b650-4&from=paste&height=286&id=u2cc55c9f&originHeight=358&originWidth=647&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=15991&status=done&style=none&taskId=u60b47502-7f65-42e3-8f22-76a1eba7ea0&title=&width=517.6" alt="image.png"><br>D是拓扑的意思。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700014207022-ada4dbab-2d0d-4c77-9753-643e62a23ee3.png#averageHue=%23fbfaf9&clientId=u742374d8-b650-4&from=paste&height=287&id=u9670232e&originHeight=359&originWidth=863&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=45149&status=done&style=none&taskId=uc28ca3a5-88db-411c-ae8f-809678d2e38&title=&width=690.4" alt="image.png"><br>D选项，B&#x2F;S体系结构是不利于事务的处理的。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700014343808-e7746300-3b75-45b8-95ef-d124c2689ca2.png#averageHue=%23fbfafa&clientId=u742374d8-b650-4&from=paste&height=254&id=u3f33747c&originHeight=318&originWidth=555&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=21881&status=done&style=none&taskId=ufa8e0ff3-5f32-44ba-b547-8489bcdaa36&title=&width=444" alt="image.png"><br>C选项的移植困难是因为不同的操作系统兼容性不一样，维护困难和升级困难是因为客户端被安装到本地电脑上了需要逐个升级和维护。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700014819232-01e99db7-10b0-437d-acb6-41a5a2ea08ed.png#averageHue=%23fcfbfa&clientId=u742374d8-b650-4&from=paste&height=268&id=u00806b3f&originHeight=335&originWidth=432&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=23730&status=done&style=none&taskId=u48ca5b91-8320-4b82-9f7e-14c6a834340&title=&width=345.6" alt="image.png">（B选项可以这样理解spring中的控制层返回的是一个页面也就是view，他们并没有完全的解耦；C选项视图要通过控制器才能访问模型数据。模型（Model）是MVC架构中的组成部分之一，它代表应用程序的数据和业务逻辑。模型负责存储和管理数据，以及定义与数据相关的操作和规则。模型封装了数据的访问方法，并提供了对数据的增加、删除、修改和查询等操作。而spring中的模型我们常常用到它的存储和管理数据功能来动态修改模板引擎的数据。可以理解为springboot中的model将MVC中的V分割为了2部分，一部分是操作数据，一部分是存储和管理数据的）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700015194915-4a8b49f1-2fc8-431b-9b22-ca7325ae8140.png#averageHue=%23fdfdfc&clientId=u742374d8-b650-4&from=paste&height=254&id=ud15c552a&originHeight=318&originWidth=709&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=15716&status=done&style=none&taskId=ucaa92803-851a-4148-a7e3-9e8b2fd8893&title=&width=567.2" alt="image.png"><br>XML：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700015304570-17ca2138-af1c-4376-9d29-c26bcf5d4336.png#averageHue=%23fefefe&clientId=u742374d8-b650-4&from=paste&height=257&id=uabef6ede&originHeight=321&originWidth=973&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=101673&status=done&style=none&taskId=uc7eee41e-dbf5-4904-946d-345dca19764&title=&width=778.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700015396526-758b3560-6614-4339-b017-cbb4791e8781.png#averageHue=%23fefefe&clientId=u742374d8-b650-4&from=paste&height=422&id=u37603c34&originHeight=528&originWidth=1001&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=275180&status=done&style=none&taskId=u5405bd6c-ab35-4270-a231-885be0eb2d8&title=&width=800.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700015464454-cae499bc-8604-49f1-b80a-27d68af12053.png#averageHue=%23fef9f7&clientId=u742374d8-b650-4&from=paste&height=147&id=u3d8ba980&originHeight=184&originWidth=952&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=93444&status=done&style=none&taskId=u23e6c597-6f97-456b-aa2f-f78afff83e1&title=&width=761.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700015523330-388680ec-666b-49c9-9888-d486fa4cef9d.png#averageHue=%23fbf8f7&clientId=u742374d8-b650-4&from=paste&height=410&id=u70abc40a&originHeight=512&originWidth=952&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=83022&status=done&style=none&taskId=u3cdb66ce-cb3f-4839-b9db-bd463c83374&title=&width=761.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700015590836-61c08192-e470-4708-a76d-7da0ce7f7347.png#averageHue=%23ebe9e6&clientId=u742374d8-b650-4&from=paste&height=267&id=ue95cff94&originHeight=334&originWidth=952&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=145754&status=done&style=none&taskId=ubc24f260-a3e6-4ade-92f6-d8abce311f1&title=&width=761.6" alt="image.png"><br>Web服务的特点：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700016557597-541c8c00-4f75-4bc1-aa46-5af96d57dd6a.png#averageHue=%23eeeeee&clientId=u742374d8-b650-4&from=paste&height=446&id=u5ac201a3&originHeight=557&originWidth=1039&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=349198&status=done&style=none&taskId=u8f34730a-1162-4c5d-9c02-be05c83c16b&title=&width=831.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700016569231-9dc384d2-e189-4274-b9be-d59b8c82898b.png#averageHue=%23edef69&clientId=u742374d8-b650-4&from=paste&height=392&id=uc744be14&originHeight=490&originWidth=1045&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=183696&status=done&style=none&taskId=ub2019e17-e526-49fe-9b4f-392b8845424&title=&width=836" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700016601995-f2541fe8-737e-4313-bb4b-6cb99c38e144.png#averageHue=%23e8e8e8&clientId=u742374d8-b650-4&from=paste&height=451&id=u9bcc8ae0&originHeight=564&originWidth=1045&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=276521&status=done&style=none&taskId=uf72c08dd-4525-449a-946d-4747c2b4e4b&title=&width=836" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700016613738-e71db09a-a1aa-4c1b-8d97-e82586d38e80.png#averageHue=%23e0e0e0&clientId=u742374d8-b650-4&from=paste&height=183&id=u7b41e090&originHeight=229&originWidth=647&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=82334&status=done&style=none&taskId=u7bc0f1b6-3a20-43a6-8e93-e2ee60eacff&title=&width=517.6" alt="image.png"><br>简单对象访问协议(SOAP)是一个基于XML, 在松散分布式环境中交换结构化信息的轻量级协议，它本身不定义任何应用<br>语言。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700016750948-92a090ff-93a6-4428-8500-ab2ca05d011d.png#averageHue=%23fcfcfc&clientId=u742374d8-b650-4&from=paste&height=281&id=u8fe8ff1a&originHeight=351&originWidth=693&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=17451&status=done&style=none&taskId=ue8f655b2-1f2e-470e-9cdd-99e46f94047&title=&width=554.4" alt="image.png"><br><a href="https://blog.csdn.net/Cookie__C/article/details/105789466">六、Web服务体系结构_wsdl定义了服务的接口、格式协议、实现三个层次的概念。每一层各包括哪些基本元素-CSDN博客</a><br>软件体系结构的描述方法有非标准图形符号，UML,ADL，，但是无法用XML来描述，其中非标准图形符号的优点是直观形象，简单易用。<br>软件体系结构的描述方法：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700019378933-2820ab59-3cfb-41dd-95d5-c3ca295e32ef.png#averageHue=%23f4f3f3&clientId=u742374d8-b650-4&from=paste&height=167&id=u42c9a972&originHeight=209&originWidth=304&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=20384&status=done&style=none&taskId=u691ff6a7-133a-4544-bd5b-2227376827f&title=&width=243.2" alt="image.png"><br>软件体系结构用UML描述的特点：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700019433514-cc1eaa2c-b6c0-4a6b-b2ed-884183f23e37.png#averageHue=%23f8f7f7&clientId=u742374d8-b650-4&from=paste&height=446&id=u4329c237&originHeight=558&originWidth=590&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=67631&status=done&style=none&taskId=u866b601b-e2e3-4ac7-9adf-0024913ad9c&title=&width=472" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700019500458-1f5299e6-371a-4574-9518-951cb68ed630.png#averageHue=%23f5f5f4&clientId=u742374d8-b650-4&from=paste&height=499&id=ubc606769&originHeight=624&originWidth=992&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=149174&status=done&style=none&taskId=u71f7db35-9a7d-4035-8824-05896ab6d20&title=&width=793.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700019508481-c9f6ab58-99b8-46af-afca-bbfd34ac7b0c.png#averageHue=%23f0efef&clientId=u742374d8-b650-4&from=paste&height=195&id=u905568df&originHeight=244&originWidth=976&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=107268&status=done&style=none&taskId=u339cf97c-d2e5-494a-ab53-cf396279442&title=&width=780.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700019520744-def141c9-0e42-4db4-a0f2-37a87c5ce571.png#averageHue=%23eeeded&clientId=u742374d8-b650-4&from=paste&height=113&id=u14e2e716&originHeight=141&originWidth=957&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=69651&status=done&style=none&taskId=u9a14da4b-45a4-4e5b-8c27-8bcdfafb9e3&title=&width=765.6" alt="image.png"><br>上面的ADL是软件体系结构的形式化描述。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700018422750-1fb0b6a3-206d-4d89-b7e2-6e15419ee93b.png#averageHue=%23fdfcfc&clientId=u742374d8-b650-4&from=paste&height=260&id=u64ad5fd6&originHeight=325&originWidth=448&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=15508&status=done&style=none&taskId=u4b059079-2ae6-439f-bcbe-3c93a80a83d&title=&width=358.4" alt="image.png"><br>服务发现是服务使用者的特性<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700018477239-ae4f4d91-fc50-40b7-b233-4e49a7090746.png#averageHue=%23fbfbfa&clientId=u742374d8-b650-4&from=paste&height=273&id=u0b9388a9&originHeight=341&originWidth=553&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=22073&status=done&style=none&taskId=u68f038e0-4220-4c5e-b7fd-99efcf0c069&title=&width=442.4" alt="image.png"><br>XML本身不显示数据的样式，但是可以和其他技术（XSLT）结合来显示样式。</p><div class="code-wrapper"><pre><code class="hljs java">XML本身并不关注数据的显示样式，它主要用于表示和组织数据的结构和内容，并提供一种通用的标记语言来描述数据。XML可以用于存储、传输和交换数据，但它并不提供直接的样式描述功能。XML可以与其他技术和语言（如XSLT和CSS）结合使用，以实现数据的样式化和展示。通过使用XSLT（Extensible Stylesheet Language Transformations）和CSS（Cascading Style Sheets），可以将XML数据与样式表关联，并将其转换为特定的显示格式，例如HTML或PDF。但这种样式化的过程是通过外部的样式表和转换规则来实现的，而不是XML本身提供的功能。</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700018641153-0bfab7f8-6af4-403c-85a3-1c4c65618646.png#averageHue=%23fbfaf9&clientId=u742374d8-b650-4&from=paste&height=271&id=u1ffcf3da&originHeight=339&originWidth=919&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=33803&status=done&style=none&taskId=uc5bfd5d2-f6df-4005-9aa6-6ba99e085f1&title=&width=735.2" alt="image.png"><br>可以这样理解对象层就是类图中某个具体类的名称，特征层就是类的属性和方法；特征层描述的是类的特征（属性）和相关问题域的行为（方法），关系层就是类之间的关系，比如依赖，关联什么的。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700018701480-9436917c-9cd2-4689-be64-b06be024c0d0.png#averageHue=%23f1f1f1&clientId=u742374d8-b650-4&from=paste&height=447&id=u458c3098&originHeight=559&originWidth=950&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=139915&status=done&style=none&taskId=u37a51187-c24b-4b58-8f0d-fb6e2b2b70b&title=&width=760" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700024635391-82415447-d369-4753-99da-d0a53abb50c5.png#averageHue=%23f7f4f4&clientId=u742374d8-b650-4&from=paste&height=462&id=u7a7ef77b&originHeight=577&originWidth=1028&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=154000&status=done&style=none&taskId=u5d152080-5d78-4e32-ae42-b19d0e895a5&title=&width=822.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700025546362-9f562463-1686-48b6-b6ed-6e02faf2209d.png#averageHue=%23f2f2f2&clientId=u742374d8-b650-4&from=paste&height=185&id=u5919e98a&originHeight=231&originWidth=351&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=15631&status=done&style=none&taskId=u4470f4d1-9c93-4558-9690-19d96e141bd&title=&width=280.8" alt="image.png"><br>C&#x2F;S体系结构和文件共享体系结构一般处理的情况不一样，文件共享体系结构处理的是文件的上传和修改等业务操作；文件体系结构在客户端和服务端传输的是文件，而C&#x2F;S体系结构传输的是响应和请求数据，文件共享体系结构中的文件数据在客户端和服务器之间进行实际的传输和共享。当用户需要访问或编辑文件时，文件被从服务器传输到客户端，用户对文件进行操作后，可能会将修改后的文件再次上传到服务器。因此，文件共享体系结构涉及大量的文件数据在客户端和服务器之间来回移动。客户&#x2F;服务器结构返回给客户端的是处理后的结果数据,文件服务器结构返回给客户端的是包含客户所需数据的文件<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700025667607-e36a591e-6fa0-4dd2-a872-393d662ec006.png#averageHue=%23f4f4f4&clientId=u742374d8-b650-4&from=paste&height=178&id=u3c35a967&originHeight=222&originWidth=347&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=12644&status=done&style=none&taskId=u2e07a53e-67a6-45a4-b1ee-fadb2d9abfc&title=&width=277.6" alt="image.png"><br>C&#x2F;S体系结构开发的软件在安装和部署的时候要考虑不同的操作系统，相比于B&#x2F;S不那么容易安装和部署。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700026546234-a8823cf3-fae4-450e-87cc-ed7abaf8c537.png#averageHue=%23f7f0f0&clientId=u742374d8-b650-4&from=paste&height=209&id=uf4553c4c&originHeight=261&originWidth=908&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=74949&status=done&style=none&taskId=u3392d39f-3951-4b13-a8b2-905ae925067&title=&width=726.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700026580035-8364fbba-3d7a-4fa9-bdec-a66636c1cda2.png#averageHue=%23faeaea&clientId=u742374d8-b650-4&from=paste&height=94&id=u5d94945d&originHeight=118&originWidth=793&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=33771&status=done&style=none&taskId=u00313762-e4cc-4757-b842-73c0801ea3f&title=&width=634.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700026600859-424b639d-4c6c-473d-b5ce-9ae20c5f96c1.png#averageHue=%23f2eeee&clientId=u742374d8-b650-4&from=paste&height=416&id=u69e9e676&originHeight=520&originWidth=1016&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=160885&status=done&style=none&taskId=u068654b4-1627-4bc0-b1e1-c36140f89b2&title=&width=812.8" alt="Snipaste_2023-11-15_13-36-34.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700026613188-6c64cf42-8559-42f8-8b9a-f74b9d182422.png#averageHue=%23f7ecec&clientId=u742374d8-b650-4&from=paste&height=312&id=ue12b48a4&originHeight=390&originWidth=992&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=118688&status=done&style=none&taskId=u66540ba1-fe89-4e86-a737-3316b651b5c&title=&width=793.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700026623529-8172f689-4923-47a2-92d6-37d561743dda.png#averageHue=%23f5f2f2&clientId=u742374d8-b650-4&from=paste&height=204&id=ucf1b91cf&originHeight=255&originWidth=986&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=64221&status=done&style=none&taskId=u34880127-8a4a-458e-bfa5-7a5e04d98f8&title=&width=788.8" alt="Snipaste_2023-11-15_13-36-58.png"><br>中间件：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700027105757-2b6389a5-22da-4eef-a7e6-c3e22e74edbe.png#averageHue=%23fbf4f4&clientId=u742374d8-b650-4&from=paste&height=148&id=u85b4259a&originHeight=185&originWidth=650&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=30910&status=done&style=none&taskId=ud19db07f-020b-4afb-b1b4-59f32d14f2f&title=&width=520" alt="image.png"><br>中间件的定义：一种连接类软件，由一组服务构成，用来连接不同的软件构件或应用系统这些服务可以让运行在同一台或多台机器上的进程进行通信交互；在分布式计算环境中是一种处于操作系统和应用系统之间的软件层。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700027275407-6eee22c0-919e-48ef-9c04-472be1ae8b18.png#averageHue=%23e6d9d9&clientId=u742374d8-b650-4&from=paste&height=339&id=u8f3099ab&originHeight=424&originWidth=1019&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=263724&status=done&style=none&taskId=ub985b905-7539-430d-a7eb-0facd6d4cb0&title=&width=815.2" alt="image.png"><br>中间件的类型：RPC：远程过程调用，MOM：消息中间件；ORB:对象请求代理中间件；SQL;TP Monitor:事件处理监听器；<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700029667129-4909a61d-7c03-44d1-8d98-eec7731f623a.png#averageHue=%23f5f4f4&clientId=u742374d8-b650-4&from=paste&height=487&id=uc06be3c7&originHeight=609&originWidth=1039&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=201148&status=done&style=none&taskId=u7041192a-5406-4685-98f3-cafacdd3928&title=&width=831.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700029941215-63edd40f-706e-4a7c-9d8a-9dba09fe67b2.png#averageHue=%23ebdfdf&clientId=u742374d8-b650-4&from=paste&height=381&id=u3944d521&originHeight=476&originWidth=987&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=221651&status=done&style=none&taskId=u1c99558a-60f5-459e-a8a2-c777f2d387c&title=&width=789.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700029963648-ec45e416-3197-4619-87fe-0510718911be.png#averageHue=%23eedfdf&clientId=u742374d8-b650-4&from=paste&height=307&id=u4dd68796&originHeight=384&originWidth=1000&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=180108&status=done&style=none&taskId=ud049f40e-f5f7-40d1-98aa-8a4b266ac97&title=&width=800" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700029981169-5f3c75cd-9e77-4e38-9aa3-962020181315.png#averageHue=%23ede6e6&clientId=u742374d8-b650-4&from=paste&height=316&id=u3f78b583&originHeight=395&originWidth=1013&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=208082&status=done&style=none&taskId=u2a30b063-704a-4ff5-9f37-dfc155b78b0&title=&width=810.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700030044889-1cf400ee-c555-4420-bc0d-0f5c8d9fadf2.png#averageHue=%23f8f4f4&clientId=u742374d8-b650-4&from=paste&height=464&id=u75864ed2&originHeight=580&originWidth=1018&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=132461&status=done&style=none&taskId=ued03c55f-a66e-4664-b44a-b5aaa58781a&title=&width=814.4" alt="image.png"><br>MVC遵循稳定依赖原则，其中稳定依赖原则是SDP；MVC稳定依赖的部分是模型，因为模型不依赖于控制器和视图。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700030184946-5a3895aa-7755-4125-8c0e-56aa2032980c.png#averageHue=%23fbf6ef&clientId=u742374d8-b650-4&from=paste&height=502&id=ue9e0738c&originHeight=628&originWidth=1028&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=347135&status=done&style=none&taskId=u03dd6c37-0a06-4f56-b759-6dbd49bad28&title=&width=822.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700030229000-e00050ad-48c1-45fe-94a8-c67e888e8178.png#averageHue=%23f8f2f2&clientId=u742374d8-b650-4&from=paste&height=269&id=ubcacf6c9&originHeight=336&originWidth=1010&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=88760&status=done&style=none&taskId=ufb181a55-2b7e-4910-bbf2-25044da4e01&title=&width=808" alt="image.png"><br>MVC的被动模式：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700031177103-1fb3ff4f-c22a-4e95-879d-284af56fc470.png#averageHue=%23fffefe&clientId=u742374d8-b650-4&from=paste&height=225&id=uddc7095a&originHeight=281&originWidth=1004&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=68905&status=done&style=none&taskId=u53d17c56-e708-4e53-812b-096b365cc4d&title=&width=803.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700031289673-0eeae289-78cb-49ea-bad1-17d06f5dc825.png#averageHue=%23fbfaf9&clientId=u742374d8-b650-4&from=paste&height=250&id=ue932c60d&originHeight=312&originWidth=527&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=22090&status=done&style=none&taskId=ufbd8466a-cd0b-4ba6-b26a-c242b996d8c&title=&width=421.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700031601457-f0b8d4e0-4182-42b1-b838-4fa3924588dc.png#averageHue=%23f7f7f8&clientId=u742374d8-b650-4&from=paste&height=225&id=u722420aa&originHeight=281&originWidth=426&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=13607&status=done&style=none&taskId=ud672f52b-7b1c-49b5-8c24-d226f72f2f9&title=&width=340.8" alt="image.png"><br>SOA的优点：</p><ul><li>（1）灵活性，根据需求变化，重新编排服务。</li><li>（2）对IT资产的复用。</li><li>（3）使企业的信息化建设真正以业务为核心。业务人员根据需求编排服务，而不必考虑技术细节。</li></ul><p>WSDL是SOA中Web服务的描述，WSDL文档也描述了Web服务的接口。<br>软件体系结构是什么？<br>软件体系结构来源于建筑学的体系结构，覆盖软件开发的全周期，主要聚焦于系统的总体结构以及需求和实现之间的对应；注重组件的可重用性和软件的健壮性，可维护性；软件体系结构&#x3D;构件+连接件+拓扑结构+约束+质量，其中构件，连接件，约束是软件体系结构的三大要素；</p><div class="code-wrapper"><pre><code class="hljs java">软件重用是指在软件开发过程中，利用已有的软件组件、模块、库、框架或设计模式等，以提高开发效率、降低成本，并改善软件质量和可维护性的实践。它的核心思想是通过重复使用已有的可靠和经过验证的软件资产，避免从头开始编写代码，从而加快开发速度、减少开发风险并提高软件的质量。软件重用的几个关键是：组件和模块重用；第三方库和框架重用；设计模式和架构重用；经验和知识重用</code></pre></div><p>批处理和管道过滤器的比较：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700033163645-b49f2b97-eb43-464a-a8a0-a81f6160925c.png#averageHue=%23dfdfdf&clientId=u742374d8-b650-4&from=paste&height=185&id=u917a4381&originHeight=231&originWidth=813&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=31047&status=done&style=none&taskId=u17fc0d0f-bef5-4f1c-9362-469f2d33545&title=&width=650.4" alt="image.png"><br>批处理是将多个任务按照一定的顺序排好自动执行的，而管道过滤器是逐步执行的，数据流经过一个过滤器后处理信息后传递该后一个过滤器；管道可以在Linux系统中实现父子进程的通信，而批处理不可以。管道过滤器可能会发生死锁，其也支持死锁检测；</p><div class="code-wrapper"><pre><code class="hljs java">(<span class="hljs-number">1</span>)合理地划分三层结构的功能，可以使系统的逻辑结构更加清晰，提高软件的可维护性和可扩充性。(<span class="hljs-number">2</span>)在实现三层C/S架构时，可以更有效地选择运行平台和硬件环境，从而使每一层都具有清晰的逻辑结构、良好的负荷处理能力和较好的开放性。(<span class="hljs-number">3</span>)在C/S架构中，可以分别选择合适的编程语言并行开发。(<span class="hljs-number">4</span>)系统具有较高的安全性。</code></pre></div><p>软件体系结构的描述方法有：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700036061364-b032b32f-3101-4764-86f0-e0e1bad62749.png#averageHue=%23fefefd&clientId=u4491d297-fb93-4&from=paste&height=157&id=u0cea7455&originHeight=196&originWidth=892&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=29669&status=done&style=none&taskId=uc1fedf09-194b-45b6-8fe7-6a1c1a3f141&title=&width=713.6" alt="image.png"><br>1.非标准图形符号描述：特点是：语义丰富，但是不精确，直观形象，简单易用<br>2.UML：侧重于面向对象分析，语义丰富，且精确；可以根据UML图生成代码；<br>3.模块接口语言：MIL，语义比较丰富，精确，但是实现级别，层次较低；<br>4.体系结构描述语言ADL：在软件体系结构抽象级上提供了精确的定义，提供了强有力的分析能力，抽象和实现细节无观性，为体系结构元素定义了一系列的符号。语言准确无二义性；<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700035760288-d3931967-707e-4391-a3da-bbd39186fb17.png#averageHue=%23fefefd&clientId=u4491d297-fb93-4&from=paste&height=253&id=u1d1e0cd3&originHeight=316&originWidth=521&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=17428&status=done&style=none&taskId=u9034af6e-d732-4771-ade3-abd0b4fe6cf&title=&width=416.8" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs java">开发关注的是组件的组合方式，也就是开发环境中的静态组织结构，其属于开发期的质量属性</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700035849072-9b414d07-f0ea-4fd5-b067-c7db0ee6bebe.png#averageHue=%23fefefd&clientId=u4491d297-fb93-4&from=paste&height=282&id=u83f7a197&originHeight=353&originWidth=844&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=24266&status=done&style=none&taskId=uc59fe91c-05cd-4bcd-9dd2-1df63bf657d&title=&width=675.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700035943599-d53fac9d-7e08-46fe-a374-84f9be04d2f5.png#averageHue=%23fefdfb&clientId=u4491d297-fb93-4&from=paste&height=275&id=uc5f7915b&originHeight=344&originWidth=772&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=29588&status=done&style=none&taskId=uffeaf5ad-e862-4f95-956d-e87fe238a2c&title=&width=617.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700035990296-98c3de37-d2bf-4330-89cd-6365eaaf0cfa.png#averageHue=%23fefefe&clientId=u4491d297-fb93-4&from=paste&height=298&id=u4b8dda1e&originHeight=373&originWidth=1061&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=33542&status=done&style=none&taskId=u5773f8e3-2516-4647-b0a8-29702d6a41a&title=&width=848.8" alt="image.png"><br>开发视图通常使用构件图来描述。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700036246949-17dcd291-ca2f-4bfe-8862-51691720f97a.png#averageHue=%23fefdfc&clientId=u4491d297-fb93-4&from=paste&height=402&id=uc40a9604&originHeight=503&originWidth=1057&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=75270&status=done&style=none&taskId=u32efd650-ba7d-4108-a8d4-738b9ab8db3&title=&width=845.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700036608106-975c8478-50ee-49bb-bf89-5f3396eb1891.png#averageHue=%23fefefd&clientId=u4491d297-fb93-4&from=paste&height=277&id=u57695e5b&originHeight=346&originWidth=563&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=16721&status=done&style=none&taskId=u7f33cb08-eef3-48c4-9e4c-53747541daf&title=&width=450.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700036692900-b8ceea18-44a3-43b9-aeab-441a7d49d842.png#averageHue=%23fefdfc&clientId=u4491d297-fb93-4&from=paste&height=324&id=u04485349&originHeight=405&originWidth=939&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=47173&status=done&style=none&taskId=u6a9c7a19-342b-4c4a-a5e1-4441b04b2ae&title=&width=751.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700037033333-e65dcaac-aec7-4eb1-8e7d-1ab036d0e287.png#averageHue=%23fbfaf9&clientId=u4491d297-fb93-4&from=paste&height=383&id=ueabf9161&originHeight=479&originWidth=1078&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=54822&status=done&style=none&taskId=u836db62c-674c-44eb-9078-d37b4fb9f0d&title=&width=862.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700037146888-d9ff8dad-3996-43d8-92fa-a457c516f294.png#averageHue=%23fefefd&clientId=u4491d297-fb93-4&from=paste&height=282&id=u6cd65ff3&originHeight=352&originWidth=633&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=25248&status=done&style=none&taskId=u1d1eae15-ca2b-408a-a26c-3ac0369aff7&title=&width=506.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700038601588-2e538f43-d810-49bc-b2af-206d9761b65e.png#averageHue=%23fefdfb&clientId=u4491d297-fb93-4&from=paste&height=267&id=uee7f9664&originHeight=334&originWidth=646&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=34389&status=done&style=none&taskId=ud1f2c037-3fa2-406a-936c-6214dcc1411&title=&width=516.8" alt="image.png"><br>Web服务所提供的接口、对Web服务的请求、Web服务的应答数据都是通过XML来描述的。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700039090428-5914aba4-d8a0-4e41-9a7b-f9b6e2e30390.png#averageHue=%23fefefd&clientId=u4491d297-fb93-4&from=paste&height=366&id=u701b67e0&originHeight=458&originWidth=712&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=27243&status=done&style=none&taskId=u85c5a2be-4fdd-473f-a88c-91a7883d175&title=&width=569.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700039273910-da1c79c2-3660-4ade-aba0-c507c8ebb1a9.png#averageHue=%23fefefe&clientId=u4491d297-fb93-4&from=paste&height=258&id=u14a6851c&originHeight=323&originWidth=718&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=42652&status=done&style=none&taskId=u5b85a85d-053b-4c5e-ac0a-9bd28e3b0e9&title=&width=574.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700039741906-c499e826-cfe9-4af2-ac4d-b6084ccdacd5.png#averageHue=%23fefefd&clientId=u4491d297-fb93-4&from=paste&height=292&id=u13076abf&originHeight=365&originWidth=1094&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=25722&status=done&style=none&taskId=u79fb2cfe-99b8-4119-85ca-648ff33c275&title=&width=875.2" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>课程作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件体系结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql怎么运行起来总结</title>
    <link href="/2024/01/26/mysql%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5%E7%9A%84%EF%BC%9A/"/>
    <url>/2024/01/26/mysql%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5%E7%9A%84%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h1><h2 id="服务器处理客户端请求："><a href="#服务器处理客户端请求：" class="headerlink" title="服务器处理客户端请求："></a>服务器处理客户端请求：</h2><h3 id="1-原理："><a href="#1-原理：" class="headerlink" title="1.原理："></a>1.原理：</h3><p>客户端进程向服务器进程发送一段文本 ( MySQL 语句) .服务器进程处理后再向客户端进程返回一段文本(处理结果）。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704529542278-22453d7f-abe8-4ec1-8c2f-8afac2ea1a57.png#averageHue=%23f6f7f3&clientId=ub7fde7af-637c-4&from=paste&height=430&id=u66753e53&originHeight=537&originWidth=900&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=285847&status=done&style=none&taskId=uf760c2ec-fd12-4989-abe2-a439fe3e19b&title=&width=720" alt="image.png"></p><h3 id="2-连接管理："><a href="#2-连接管理：" class="headerlink" title="2.连接管理："></a>2.连接管理：</h3><p>1.每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程，专门处理与这个客户端的交互;    当该客户端退出时会与服务器断开连接，   服务器并不会立即把与该，客户端交互的线程销毁，   而是把它缓存起来，   在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端.这样就不用频繁地创建和销毁线程，从而节省了开销.<br>2.在客户端程序发起连接时，   需要携带主机信息、用户名、密码等信息，服务器程序会对客户端程序提供的这些信息进行认证.如果认证失败，  服务辑程序会拒绝连接.另外，如果客户端程序和服务器程序不运行在一台计算机上，我们还可以通过采用传输层安全性 (TransportLayer Security , TLS) 协议对连接进行加密，从而保证数据传输的安全性。当连接建立后，与该客户端关联的服务器线程会一直等待客户端发送过来的请求.MySQL 服务器接收到的请求只是一个文本消息，该文本消息还要经过各种处理.</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-number">1.</span>客户端发起连接需携带一些认证信息，认证成功就在服务段创建线程，然后该线程一直监听客户端发送来的请求。客户端断开连接后该线程并不会销毁而是缓存起来</code></pre></div><h3 id="解析与优化："><a href="#解析与优化：" class="headerlink" title="解析与优化："></a>解析与优化：</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-number">1.</span>MySQL 服务器程序处理查询请求的过程是这样，会把刚刚处理过的查询请求和结果缓 存起来.  如果下一次有同样的请求过来，直接从缓存中查找结果就好了，就不用再去底层的表中查找了. 这个查询缓存可以在不同的客户端之间共享，也就是说，如果客户端 A 刚刚发送 了 一个查询请求，而客户端 B 之后发送了同样的查询请求，那么客户端 B 的这次查询就可以直接使用查询缓存中的数据了.注：如果两个查询请求有任何字符上的不同(例如，空格、注释、大小写),都会导致缓存不会命中。另外，如果查询请求中包含某些系统函数、用户自定义变量和函数、系统表,则这个请求就不会被缓存.<span class="hljs-number">2.</span>当查询的表数据结构失效后缓存也就失效了。注：MySQL8<span class="hljs-number">.0</span>中直接将缓存删除<span class="hljs-number">3.</span></code></pre></div><h3 id="语法解析："><a href="#语法解析：" class="headerlink" title="语法解析："></a>语法解析：</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-number">1.</span>如果查询缓存没有命中，接下来就需要进入正式的查询阶段了。因为客户端程序发送过来的请求只是一段文本，所以MySQL服务器程序首先要对这段文本进行分析，判断请求的语法是否正确，然后从文本中将要查询的表、各种查询条件都提取出来放到MySQL服务器内部使用的一些数据结构上。</code></pre></div><h3 id="查询优化："><a href="#查询优化：" class="headerlink" title="查询优化："></a>查询优化：</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-number">1.</span>在语法解析之后，服务器程序获得到了需要的信息，比如要查询的表和列是哪些、搜索条件是什么等.但光有这些是不够的，因为我们写的 MySQL 语句执行起来效率可能并不是很高， MySQL 的优化程序会对我们的话句做一些优化。</code></pre></div><h3 id="存储引擎："><a href="#存储引擎：" class="headerlink" title="存储引擎："></a>存储引擎：</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-number">1.</span>到服务器程序完成了查询优化为止，还没有真正地去访问真实的表中数据<span class="hljs-number">2.</span>MySQL 服务器把数据的存储和提取操作都封装到了一个名为存储引擎的模块中.我们知道，表是由一行一行的记录组成的，但这只是一个逻辑上的概念.在物理上如何表示记录，怎么从表中读取数据，以及怎么把数据写入具体的物理存储器上，都是存储引擎负责的事情.为了实现不同的功能，MySQL 提供了各式各样的存储引擎，不同存储引擎管理的表可能有不同的存储结构， 采用的存取算法也可能不同.<span class="hljs-number">3.</span>为了方便管理，人们把 MySQL 服务器处理请求的过程简单地划分为 server 层和存储引擎层.连接管理、查询缓存、语法解析、查询优化这些并不涉及真实数据存取的功能划分为 server 层的功能，存取真实数据的功能划分为存储引擎层的功能.各种不同的存储引擎为server 层提供统一的调用接口，其中包含了几十个不同用途的底层函数，比如<span class="hljs-string">&quot;读取索引第一条记录读取索引下一条记录&quot;</span> <span class="hljs-string">&quot;插入记录&quot;</span>等.<span class="hljs-number">4.</span>所以在 server 层完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的接口获取到数据后返回给客户端就好了<span class="hljs-number">5.</span>server 层和存储引擎层交互时，一般是以记录为单位的.以 SELECT 语句为例， se凹er 层根据执行计划先向存储引擎层取一条记录，然后判断是否符合 WHE阻条件:如果符合， 就发送给客户端，否则跳过该记录，然后继续向存储引擎索要下一条记录:依此类推.</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-number">6.</span>存储引擎的常见操作：<span class="hljs-number">1.</span>查看当前服务器程序支持的存储引擎：show engines ;<span class="hljs-number">2.</span>设置表的存储引擎：创建表时指定存储引擎：CREATE TABLE 表名(建表语句，) ENGINE =存储引擎名称；修改表的存储引擎:ALTER TABLE 表名 ENGINE =存储引擎名称；<span class="hljs-number">3.</span>查看存储引擎：show create table 表名 ;<span class="hljs-number">4.</span></code></pre></div><h2 id="系统变量："><a href="#系统变量：" class="headerlink" title="系统变量："></a>系统变量：</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-number">1.</span>查看系统变量：SHOW VARIABLES [LIKE 匹配模式];<span class="hljs-number">2.</span>设置系统变量：通过启动选项设置：<span class="hljs-number">1.</span>通过命令行添加启动选项.比方说在启动服务器程序时用这个命令：mysqld --default-storage-engine-MyISAH --<span class="hljs-built_in">max</span>-connections-<span class="hljs-number">10</span><span class="hljs-number">2.</span>通过配置文件添加启动选项.可以这样填写配置文件[server]default-storage-engine- MyISAM <span class="hljs-built_in">max</span>-connections-<span class="hljs-number">10</span><span class="hljs-number">3.</span>服务器程序运行过程中设置：• GLOBAL (全局范围)： 影响服务器的整体操作.具有 GLOBAL 作用范围的系统变量可以称为全面变量.• session(会话范围)，影响某个客户端连接的操作.具有 SESSION 作用范围的系统变量可以称为会话变量.•通过启动选项设置的系统变量的作用范围都是 GLOBAL 的;•设置系统变量的语法:SET   (GLOBAL|SESSION) 系统变量名=值；或者SET   [(@@(GLOBAL|SESSION).] 系统变量名=值;•全局变量（<span class="hljs-keyword">global</span> variables）：全局变量在MySQL服务器的整个生命周期内保持持久性，并且对所有会话都是可见的。这些变量可以被任何连接到MySQL服务器的客户端修改，并且对所有连接都具有相同的值。全局变量的值在MySQL服务器重启后仍然保持不变。•会话变量（session variables）：会话变量是与特定会话相关联的变量。每个连接到MySQL服务器的客户端都会有自己的会话变量。这些变量的值只在当前会话中有效，并且对其他会话不可见。当会话结束时，会话变量的值将被清除。•查看全局变量的值：SHOW GLOBAL VARIABLES LIKE <span class="hljs-string">&#x27;variable_name&#x27;</span>;•查看会话变量的值：SHOW SESSION VARIABLES LIKE <span class="hljs-string">&#x27;variable_name&#x27;</span>;•一些变量既可以作为全局变量又可以作为会话变量存在。在这种情况下，如果设置了会话变量的值，则会话变量的值将覆盖全局变量的值。如果没有设置会话变量的值，则会话变量将采用全局变量的值。•SET 系统变量名=值<span class="hljs-string">&quot;和 &quot;</span>SET SESSrON 系统变量名=值<span class="hljs-string">&quot;是等价的.</span><span class="hljs-string">•如果某个客户 端改变了 某个系统变量在 GLOBAL 作用范围的值，其并不会影响谅系</span><span class="hljs-string">统变量在当前已经连接的客户端作用范围为 SESSION 的值，只会影响后续追入的客户</span><span class="hljs-string">端作用范围为 SESSION 的值.</span><span class="hljs-string">•并不是所有的系统变量都具有 GLOBAL 和 SESSION 的作用范围.</span></code></pre></div><h2 id="状态变量："><a href="#状态变量：" class="headerlink" title="状态变量："></a>状态变量：</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-number">1.</span>概念：为了让我们更好地了解服务器程序的运行情况，MySQL 服务器程序中维护了好多关于程序运行状态的变量，它们被称为状态变量.<span class="hljs-number">2.</span>由于状态变量是用来显示服务器程序运行状态的，所以它们的值只能由服务器程序自己来设置，不能入为设置.与系统变量类似，状态变量也有 GLOBAL 和 SESSION 两个作用范围，查看<span class="hljs-string">&#x27;状态变量的语句可以这么写：</span><span class="hljs-string">SHOW   （GLOBAL|SESSION) STATUS (LIKE 匹配的模式);</span><span class="hljs-string"></span></code></pre></div><h2 id="字符集："><a href="#字符集：" class="headerlink" title="字符集："></a>字符集：</h2><div class="code-wrapper"><pre><code class="hljs python">在MySQL中，字符集（character <span class="hljs-built_in">set</span>）定义了如何存储和处理文本数据的字符编码方式，而字符集比较规则（collation）则定义了如何对字符进行排序和比较。字符集比较规则决定了在排序、字符串比较和索引等操作中字符的顺序和比较规则。不同的字符集比较规则可能会导致不同的排序结果和比较行为。以下是一些常见的字符集比较规则：utf8_general_ci：UTF-<span class="hljs-number">8</span>编码的不区分大小写的比较规则，适用于一般的文本排序和比较。utf8_bin：UTF-<span class="hljs-number">8</span>编码的区分大小写的比较规则，区分大小写的排序和比较。utf8mb4_general_ci：UTF-<span class="hljs-number">8</span>编码的不区分大小写的比较规则，适用于包括Emoji在内的所有Unicode字符的排序和比较。utf8mb4_bin：UTF-<span class="hljs-number">8</span>编码的区分大小写的比较规则，区分大小写的排序和比较，适用于包括Emoji在内的所有Unicode字符。在创建数据库、表或列时，可以指定字符集和字符集比较规则。例如：CREATE DATABASE database_name CHARACTER SET charset_name COLLATE collation_name;CREATE TABLE table_name (...) CHARACTER SET charset_name COLLATE collation_name;ALTER TABLE table_name MODIFY column_name column_type CHARACTER SET charset_name COLLATE collation_name;要查看数据库、表或列的字符集和字符集比较规则设置，可以使用以下语句：SHOW CREATE DATABASE database_name;SHOW CREATE TABLE table_name;SHOW FULL COLUMNS FROM table_name;在进行字符串比较、排序和索引时，确保选择正确的字符集和字符集比较规则非常重要，以避免不一致的排序结果和比较行为。</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">字符集指的是某个字符范围的编码规则.比较规则是对某个字符集中的字符比较大小的一种规则.在 MySQL 中， 一个字符集可以有若干种比较规则，其中有一个默认的比较规则.一个比较规则必须对应一个字符集.在 MySQL 中查看支持的字符集和比较规则的语句如下:•  SHOW (CHARACTER SET|CHARSET） [LIKE 匹配的模式);•    SHOW COLLATION [LIKE 匹配的模式);MySQL 有 <span class="hljs-number">4</span> 个级别的字符集和比较规则，具体如下.· 服务器级别character_set_server 表示服务器级别的字符集，collation_server 表示服务器级别的比较规则.数据库级别创建和修改数据库时可以指定字符集和比较规则:CREATE DATABASE 数据库名[[DEFAULT]   CHARACTER SET 宇符集名称][[DEFAULT] COLLATE 比较规则名称];ALTER DATABA$E 数据库名[[DEFAULT]   CHARACTER SET 宇符集名称][[DEFAULT] COLLATE 比较规则名称];character_set_database 表示当前数据库的字符集.collation_database 表示当前数据库的比较规则.这两个系统交量只用来读取，修改它们并不会改变当前数据库的字符集和比较规则.如果没有指定当前数据库，则这两个系统变量与服务器级别相应的系统变量具有相同的值.表级别创建和修改袤的时候指定袤的字符集和比较规则:CREATE TABLE 表名 （列信息）[[DEFAULT]   CHARACTER SET 宇符集名称][[DEFAULT] COLLATE 比较规则名称];ALTER TABLE 表名 [[DEFAULT]   CHARACTER SET 宇符集名称][[DEFAULT] COLLATE 比较规则名称];列级别：创建和修改列的时候指定该列的字符集和比较规则:CREATE TABLE 表名（列名 列类型 [CHARACTER SET 宇符集名称][[DEFAULT] COLLATE 比枝规则名称].其他列...);</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704536596996-3fde9712-6c2e-4baf-ba31-2a2fb1ea9e33.png#averageHue=%23f3f4f1&clientId=ub7fde7af-637c-4&from=paste&height=491&id=ue0a431a8&originHeight=614&originWidth=1113&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=592803&status=done&style=none&taskId=uaa07d11e-331b-46ce-80cf-eff97b80956&title=&width=890.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704536634444-c4520c48-35d0-499f-a52d-210e6ad00de0.png#averageHue=%23fcfcf9&clientId=ub7fde7af-637c-4&from=paste&height=334&id=u1323a73b&originHeight=417&originWidth=1089&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=307247&status=done&style=none&taskId=u977a9d76-42b3-4490-8965-f0153e63633&title=&width=871.2" alt="image.png"></p><h2 id="InnoDB记录存储结构"><a href="#InnoDB记录存储结构" class="headerlink" title="InnoDB记录存储结构:"></a>InnoDB记录存储结构:</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-number">1.</span>读取数据和刷新数据lnnoDB 采取的方式是，将数据划分分为若干个页，以页作为磁盘和内存之间交互的基本单位.lnnoDB 中 页的大小一般为16KB。也就是在一般情况下，一次最少从磁盘中读取 16KB 的内容到内存中，一次最少把内存中的16KB 内容刷新到磁盘中。可以通过下面的命令查看Innodb页的大小：SHOW VARIABLES LIKE <span class="hljs-string">&#x27;innodb_page_size&#x27;</span>;</code></pre></div><p>InnoDB 行格式：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-number">1.</span>我们平时都是以记录为单位向表中插入数据的，这些记录在磁盘上的存放形式也被称为行格式或者记录格式.设计 InnoDB 存储引擎的大叔到现在为止设计了 <span class="hljs-number">4</span> 种不同类型的行格式，分别是 COMPACT、  REDUNDANT、  DYNAMIC 和 COMPRESSED.</code></pre></div><p>指定行格式的语法：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704701423123-83b69ae2-fd56-4518-a001-2ff53ebddff4.png#averageHue=%23f6f7f3&clientId=u50e43ce6-dc72-4&from=paste&height=71&id=ubadb5a57&originHeight=89&originWidth=637&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=45057&status=done&style=none&taskId=u5ed7937d-67eb-4f18-98c9-1ca7689b039&title=&width=509.6" alt="image.png"><br>COMPACT 行格式：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704701546371-5cc3845b-25ef-4080-a8d7-477316191433.png#averageHue=%23e1e6e1&clientId=u50e43ce6-dc72-4&from=paste&height=138&id=u1b67adcc&originHeight=173&originWidth=930&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=127246&status=done&style=none&taskId=u94229be1-1d82-45b1-b328-07cf71942ab&title=&width=744" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704701584546-9ef1431b-7b65-4a46-bb22-596abfc60766.png#averageHue=%23fafaf7&clientId=u50e43ce6-dc72-4&from=paste&height=475&id=u6955ae3f&originHeight=594&originWidth=1131&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=597336&status=done&style=none&taskId=u1c0dafdd-9616-4f49-97d8-a7f3a539193&title=&width=904.8" alt="image.png"><br>为了确定每个列的变长字段的长度用几字节表示：Innodb有一套规则。为了更好地表述清楚这个规则，我们引入 W、 M 和 L 这几个符号，先分别看看这些符号的意思.<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704701958658-8f313347-b027-4f68-910b-0711e9656ec1.png#averageHue=%23f6f6f3&clientId=u50e43ce6-dc72-4&from=paste&height=265&id=uf26e45b1&originHeight=331&originWidth=1144&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=352260&status=done&style=none&taskId=ua18c44a5-c6fa-4f57-8564-e8ef7492f45&title=&width=915.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704701986794-e867f8af-a529-463d-84ba-dcd738ac46b9.png#averageHue=%23f4f4f4&clientId=u50e43ce6-dc72-4&from=paste&height=108&id=uf5b62d57&originHeight=135&originWidth=808&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=93477&status=done&style=none&taskId=u04a85c5e-6ef4-4a84-b384-9ee999a0ea3&title=&width=646.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704702279433-decd91cf-10e1-4da8-b3b8-267fa5282644.png#averageHue=%23d9dddb&clientId=u50e43ce6-dc72-4&from=paste&height=190&id=u62a14e7a&originHeight=238&originWidth=1008&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=363525&status=done&style=none&taskId=uf52bab04-5daa-4a27-801f-88ebaeaa05f&title=&width=806.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704702378382-9cf8d102-e67f-4530-bd7f-82e224114bbd.png#averageHue=%23f6f7f4&clientId=u50e43ce6-dc72-4&from=paste&height=82&id=u4421210a&originHeight=103&originWidth=1133&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=125176&status=done&style=none&taskId=u81ce9824-84f6-4a07-b801-4297d72fdbe&title=&width=906.4" alt="image.png"><br>127的二进制刚好是1111111，而int是8位，其第一位被用作标志为使用的一个字节还是2个字节来表示其变成列的长度。<br>另外需要注意的一点是，变*字段长度列表中只存储值为非NULL 的列的内容长度，不存储值为 NULL 的列的内容长度。<br>并不是所有记录都有这个变长字段长度列表的部分，如果表中所有的列都不是变长的数据类型或者所有列的值都是NULL 的话，就不需要有变长字段长度列表.<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704702861460-187a9a6b-3ada-43c3-944d-b4c13803cad2.png#averageHue=%23f7f8f5&clientId=u50e43ce6-dc72-4&from=paste&height=416&id=u7dd9aca2&originHeight=520&originWidth=1135&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=514361&status=done&style=none&taskId=uaa2590a6-258c-49b9-aaaf-62b939bd455&title=&width=908" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704703108025-0a545aa6-fb65-481e-9a19-af033ee8f347.png#averageHue=%23f0f4f0&clientId=u50e43ce6-dc72-4&from=paste&height=44&id=ubee007ba&originHeight=55&originWidth=805&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=39259&status=done&style=none&taskId=ufa77b469-9d58-4646-a29b-3ffb42eb9a4&title=&width=644" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704703141248-aec18f99-41c4-4ac5-b0a5-6c1b514e9b86.png#averageHue=%23e5eae9&clientId=u50e43ce6-dc72-4&from=paste&height=59&id=uda57c097&originHeight=74&originWidth=1027&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=93923&status=done&style=none&taskId=u3bd36e02-a27c-41ae-a511-218e66e33b0&title=&width=821.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704703216639-e951b84a-6091-41ba-9310-68b1fd820c05.png#averageHue=%23fafaf7&clientId=u50e43ce6-dc72-4&from=paste&height=383&id=u21d7cc1e&originHeight=479&originWidth=1151&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=291526&status=done&style=none&taskId=u3ad21d36-fba8-4c42-a008-f4a5c496144&title=&width=920.8" alt="image.png"><br>除了我们自己定义的列的数据外. MySQL会为每个记录默认地添加一些列(也称为隐藏列)：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704703378823-d24334d8-d3fd-4695-869f-66bd57b90692.png#averageHue=%23f9f9f6&clientId=u50e43ce6-dc72-4&from=paste&height=183&id=ub1e625e8&originHeight=229&originWidth=1121&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=136224&status=done&style=none&taskId=u66a2a981-3f27-4e27-be0d-46c07a545da&title=&width=896.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704703323160-10eb994c-8781-439a-84a0-a7b6ceadb502.png#averageHue=%23edeeea&clientId=u50e43ce6-dc72-4&from=paste&height=108&id=u4656005c&originHeight=135&originWidth=1157&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=167027&status=done&style=none&taskId=ud2a041bf-ce91-40f1-8c7a-e8997bf334d&title=&width=925.6" alt="image.png"><br>CHAR(M) 列的存储格式：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704703887654-8c0d6035-da13-4c5a-bcdd-9b3fd66c18be.png#averageHue=%23eaecea&clientId=u50e43ce6-dc72-4&from=paste&height=99&id=uc46cc009&originHeight=124&originWidth=1136&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=156781&status=done&style=none&taskId=u35fd7f2b-f13e-476b-a2b0-5da72f6cae0&title=&width=908.8" alt="image.png"><br><a href="https://blog.csdn.net/yang131peng/article/details/113849366">mysql学习-Innodb行格式compact行记录解析_compact行格式为什么存储长度时要逆序-CSDN博客</a></p><h2 id="InnoDB-数据页结构："><a href="#InnoDB-数据页结构：" class="headerlink" title="InnoDB 数据页结构："></a>InnoDB 数据页结构：</h2><h3 id="数据页结构："><a href="#数据页结构：" class="headerlink" title="数据页结构："></a>数据页结构：</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704712618197-20163d04-ee78-4f3b-876e-2cc196267c14.png#averageHue=%23eff0ec&clientId=u50e43ce6-dc72-4&from=paste&height=437&id=u89bfcc81&originHeight=546&originWidth=1160&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=285291&status=done&style=none&taskId=ued60375c-f5db-4d90-a071-96f2d456dbe&title=&width=928" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704712651223-585ac0c8-a084-49b2-9d2d-1da2b5207fde.png#averageHue=%23f9faf7&clientId=u50e43ce6-dc72-4&from=paste&height=328&id=u9a089634&originHeight=410&originWidth=1152&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=384554&status=done&style=none&taskId=uad0a1ad1-0c68-4f60-acc7-b09e1672f8e&title=&width=921.6" alt="image.png"></p><h3 id="记录在页中的存储："><a href="#记录在页中的存储：" class="headerlink" title="记录在页中的存储："></a>记录在页中的存储：</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704712771510-43cbbf19-ec9e-4554-a67a-3e2ead98e011.png#averageHue=%23f7f8f5&clientId=u50e43ce6-dc72-4&from=paste&height=189&id=uf21b32cb&originHeight=236&originWidth=1136&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=313912&status=done&style=none&taskId=uc2ae3975-c6f9-4d7b-a491-13cab8a8f3c&title=&width=908.8" alt="image.png"></p><h3 id="记录头信息："><a href="#记录头信息：" class="headerlink" title="记录头信息："></a>记录头信息：</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-number">1.</span>deleted _ flag :这个属性用来标记当前记录是否被删除，占用<span class="hljs-number">1</span>比特.值为 <span class="hljs-number">0</span> 时表示记录没有被删除，值为 <span class="hljs-number">1</span> 时表示记录被删除了.这些被删除的记录之所以不从磁盘上移除，是因为在移除它们之后，还需要在磁盘上亟新排列其他的记录，  这会带来性能消耗，所以只打一个删除标记就可以避免这个问题.所有被删除掉的记录会组成一个垃圾链衰，记录在这个链表中占用的空间称为可重用空间(关于链表是怎么形成的，在介绍过 next_record 属性后大家就知道了).</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704713447404-6e208dd0-091b-4876-9dda-2b6a104a3fe5.png#averageHue=%23f0f0ed&clientId=u50e43ce6-dc72-4&from=paste&height=458&id=u46da2564&originHeight=572&originWidth=1126&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=423011&status=done&style=none&taskId=ucb504b6b-86cf-4f36-80bd-32113caed9b&title=&width=900.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704713558940-c8562c6d-d8e2-4f3e-9a26-d95f314dbc95.png#averageHue=%23f0f0ed&clientId=u50e43ce6-dc72-4&from=paste&height=371&id=ua5b437be&originHeight=464&originWidth=1183&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=523663&status=done&style=none&taskId=u75dcefbc-ed37-4c68-907f-29a33e97638&title=&width=946.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704713581678-9e9d13f9-6b83-40a0-b841-b0c87d4b7377.png#averageHue=%23f3f3f0&clientId=u50e43ce6-dc72-4&from=paste&height=138&id=ua5bbc240&originHeight=172&originWidth=1126&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=131220&status=done&style=none&taskId=u64de9728-2443-4718-826d-515afbdc16b&title=&width=900.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704713643175-fdcb7c59-7bba-48e3-a9e9-bdaebf06218c.png#averageHue=%23f4f5f2&clientId=u50e43ce6-dc72-4&from=paste&height=184&id=u018a8a08&originHeight=230&originWidth=1072&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=263163&status=done&style=none&taskId=u4a4b322b-4974-48cf-82ab-b46220b8bdb&title=&width=857.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704713665094-9d6f3897-2585-46ed-8b00-73b0ff652fad.png#averageHue=%23e8e8e5&clientId=u50e43ce6-dc72-4&from=paste&height=104&id=u584007b3&originHeight=130&originWidth=1085&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=141195&status=done&style=none&taskId=u0c3162e7-3881-4f8c-938f-e9561dd645a&title=&width=868" alt="image.png"></p><h3 id="Page-Directory-页-目-录-："><a href="#Page-Directory-页-目-录-：" class="headerlink" title="Page Directory  (  页 目 录 )："></a>Page Directory  (  页 目 录 )：</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704719269276-f451a3e1-d0c7-4b7a-a457-b99c49a58943.png#averageHue=%23f9faf7&clientId=u50e43ce6-dc72-4&from=paste&height=358&id=u561861ee&originHeight=448&originWidth=1146&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=495237&status=done&style=none&taskId=ud9c4be15-bc16-4201-9b5a-12a7ffb9158&title=&width=916.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704719403490-9fa13f3b-6351-4881-88ff-97a364783960.png#averageHue=%23f1f1f1&clientId=u50e43ce6-dc72-4&from=paste&height=299&id=u085e2932&originHeight=374&originWidth=1144&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=398090&status=done&style=none&taskId=u6e507950-630b-44e3-b11c-d6cb54b5a45&title=&width=915.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704719407163-4c090b00-ec2f-4940-8974-49107b004355.png#averageHue=%23f4f5f2&clientId=u50e43ce6-dc72-4&from=paste&height=46&id=u884afb1d&originHeight=58&originWidth=868&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=41631&status=done&style=none&taskId=ucecc558f-e354-45ae-bcc4-a14457468d9&title=&width=694.4" alt="image.png"></p><h3 id="Page-Header-页面头部-："><a href="#Page-Header-页面头部-：" class="headerlink" title="Page Header (页面头部)："></a>Page Header (页面头部)：</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704719669174-57930b0a-e9ac-4eb2-b07c-9c588b188259.png#averageHue=%23fcfcf9&clientId=u50e43ce6-dc72-4&from=paste&height=154&id=uc8d995c3&originHeight=192&originWidth=1166&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=222898&status=done&style=none&taskId=u6702d6ba-307c-4951-b9ce-58e70b3d22e&title=&width=932.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704719730841-b241990b-030a-4536-806a-0fd488708faa.png#averageHue=%23edeee9&clientId=u50e43ce6-dc72-4&from=paste&height=249&id=u8bb5bece&originHeight=311&originWidth=1138&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=306066&status=done&style=none&taskId=u4df01442-f1b9-404b-a57e-3cc2d88caf5&title=&width=910.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704719834202-30badac0-51b2-4a5e-8841-d0ccd68f4d40.png#averageHue=%23f5f6f3&clientId=u50e43ce6-dc72-4&from=paste&height=571&id=ub60b18f3&originHeight=714&originWidth=1172&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=812586&status=done&style=none&taskId=u6cac7d45-fea9-4e96-bf5e-843e687f1a3&title=&width=937.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704719887651-6f8841aa-5d97-4320-9e99-9080aabc884d.png#averageHue=%23f1f1ef&clientId=u50e43ce6-dc72-4&from=paste&height=68&id=u6b1cac48&originHeight=85&originWidth=1058&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=62690&status=done&style=none&taskId=u78078a42-4a63-4763-8c47-8f94f92e982&title=&width=846.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704719901577-0e1d86b0-fa9d-423e-9789-8cee1a7e7d0a.png#averageHue=%23f9faf7&clientId=u50e43ce6-dc72-4&from=paste&height=627&id=u24e15187&originHeight=784&originWidth=1118&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=724970&status=done&style=none&taskId=uba562745-1057-4140-a801-b2f1a2f6757&title=&width=894.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704719909810-d314973f-03f7-42c3-9fa7-7ea4f30cb8cb.png#averageHue=%23f7f7f4&clientId=u50e43ce6-dc72-4&from=paste&height=154&id=uf672e111&originHeight=192&originWidth=1132&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=179107&status=done&style=none&taskId=u734ca507-cb1b-4c65-9a80-a45aeed8da9&title=&width=905.6" alt="image.png"></p><h2 id="索引："><a href="#索引：" class="headerlink" title="索引："></a>索引：</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704720359154-9d0c4c13-6093-45a1-b8cc-476aaaa91083.png#averageHue=%23f9faf7&clientId=u50e43ce6-dc72-4&from=paste&height=225&id=uf900ae64&originHeight=281&originWidth=925&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=193055&status=done&style=none&taskId=ube778cdc-5927-4657-86e6-e688d5e01a3&title=&width=740" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704720366351-2fda4b31-4937-40c3-a5a4-ca00d9822b3e.png#averageHue=%23f8f9f6&clientId=u50e43ce6-dc72-4&from=paste&height=79&id=ue0aa177f&originHeight=99&originWidth=1066&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=98137&status=done&style=none&taskId=ue0407a69-b88a-48fa-9716-cd2bac6f63f&title=&width=852.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704720374637-d59bab08-f4b0-4b9f-ba77-5eb28c7c9197.png#averageHue=%23ebefee&clientId=u50e43ce6-dc72-4&from=paste&height=98&id=ua78a2059&originHeight=122&originWidth=1075&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=160386&status=done&style=none&taskId=ue29f7e6b-46e1-4efd-ac1a-420374403b4&title=&width=860" alt="image.png"></p><h3 id="聚簇索引："><a href="#聚簇索引：" class="headerlink" title="聚簇索引："></a>聚簇索引：</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704721815037-da0f39f1-6857-439a-b949-ab4a38c814df.png#averageHue=%23f0f0ed&clientId=u50e43ce6-dc72-4&from=paste&height=236&id=u73956633&originHeight=295&originWidth=1092&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=307840&status=done&style=none&taskId=u6f0b74d8-17f1-4c62-bf04-400db2303a2&title=&width=873.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704721863862-a71f766b-e664-4b6b-9534-1aff0439dafd.png#averageHue=%23f6f6f6&clientId=u50e43ce6-dc72-4&from=paste&height=138&id=u1f9f0a15&originHeight=173&originWidth=1112&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=149882&status=done&style=none&taskId=uffca32ce-6dd3-48a1-ae2f-7fe67029214&title=&width=889.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704721892409-74c1719a-5c2a-419f-9172-0c9613a082c1.png#averageHue=%23f5f6f3&clientId=u50e43ce6-dc72-4&from=paste&height=166&id=u70f928db&originHeight=208&originWidth=1173&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=269362&status=done&style=none&taskId=u059dedeb-64e3-4753-b928-7e901033ee7&title=&width=938.4" alt="image.png"></p><h3 id="二级索引："><a href="#二级索引：" class="headerlink" title="二级索引："></a>二级索引：</h3><p>就是根据非主键的列生成一个新的b+树，而这个树和聚簇索引树是类似的。只不过叶子节点不是完整的用户记录，而是该列和主键。然后根据找到的主键回表到聚簇索引中来查找完整的用户记录。这样的目的是节约了空间和时间。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704722631997-8050c913-5ba1-4e3c-be28-00ab159fbfe6.png#averageHue=%23f3f3f0&clientId=u50e43ce6-dc72-4&from=paste&height=206&id=uc63d284d&originHeight=257&originWidth=1074&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=278312&status=done&style=none&taskId=uff657c2d-8c29-4312-9c7d-6613e42f0df&title=&width=859.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704722640397-f1c3c8df-2678-4541-bb54-4c1ab3faed34.png#averageHue=%23eef0ec&clientId=u50e43ce6-dc72-4&from=paste&height=179&id=u0f244dbf&originHeight=224&originWidth=1060&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=230014&status=done&style=none&taskId=ud9d8d40c-1f78-4b65-8e62-74d3444f0bb&title=&width=848" alt="image.png"></p><h3 id="联合索引："><a href="#联合索引：" class="headerlink" title="联合索引："></a>联合索引：</h3><p>就是以多个列来创建一种类似于二级索引的B+树<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704723058423-c8de4ed4-8c7f-4eee-b5fb-f7c23ac1cffa.png#averageHue=%23f3f3f0&clientId=u50e43ce6-dc72-4&from=paste&height=345&id=u0356d052&originHeight=431&originWidth=1140&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=375192&status=done&style=none&taskId=u7ce4aaa1-a286-41ca-bd2a-45b5881c883&title=&width=912" alt="image.png"></p><h3 id="B-树索引的使用："><a href="#B-树索引的使用：" class="headerlink" title="B+树索引的使用："></a>B+树索引的使用：</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704723199420-6bdf50f1-7f04-46e8-a823-32d8f63e9a5f.png#averageHue=%23f6f7f4&clientId=u50e43ce6-dc72-4&from=paste&height=564&id=u94973148&originHeight=705&originWidth=1079&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=925189&status=done&style=none&taskId=ue350a661-83ee-4bd9-b9eb-d599a82ac6e&title=&width=863.2" alt="image.png"><br><a href="https://blog.csdn.net/amoscykl/article/details/88553308">MySQL中键(key)和索引(index)的区别_key和index的区别-CSDN博客</a></p><h3 id="使用索引："><a href="#使用索引：" class="headerlink" title="使用索引："></a>使用索引：</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704764863791-34ca6b55-3ed9-4a61-84b0-cd6b76308fbe.png#averageHue=%23fafbf8&clientId=u50e43ce6-dc72-4&from=paste&height=288&id=uc128f862&originHeight=360&originWidth=1138&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=319938&status=done&style=none&taskId=udcaa3263-8f16-4d4f-b8c7-486c5c9c4a5&title=&width=910.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704764900373-e00d3768-b370-461c-b21b-a596ad5c21eb.png#averageHue=%23f9faf7&clientId=u50e43ce6-dc72-4&from=paste&height=196&id=ubb064195&originHeight=245&originWidth=1142&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=285780&status=done&style=none&taskId=u7a477b8a-4ef6-417a-901c-723678be6e9&title=&width=913.6" alt="image.png"></p><h2 id="MySQL的数据目录："><a href="#MySQL的数据目录：" class="headerlink" title="MySQL的数据目录："></a>MySQL的数据目录：</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704765871256-0f21766a-4e21-432d-a8dc-66c215f1e706.png#averageHue=%23ededeb&clientId=u50e43ce6-dc72-4&from=paste&height=62&id=ubc20d2ea&originHeight=77&originWidth=1141&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=101834&status=done&style=none&taskId=ud539778c-5810-4e8c-a40e-25cbb56d561&title=&width=912.8" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs python">查看数据目录：show variables like <span class="hljs-string">&#x27;datadir&#x27;</span></code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704766122399-eaee1edd-86ac-4081-a5d2-b4559e077f90.png#averageHue=%23f9faf7&clientId=u50e43ce6-dc72-4&from=paste&height=254&id=uc4b7dab9&originHeight=318&originWidth=1141&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=342391&status=done&style=none&taskId=ub01f18f8-0d4e-4136-a02f-e23ca16820e&title=&width=912.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704766416050-73963e6a-d6f3-46e9-9249-cdec8916e1cc.png#averageHue=%23f8f8f8&clientId=u50e43ce6-dc72-4&from=paste&height=137&id=uba837fa3&originHeight=171&originWidth=983&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=88648&status=done&style=none&taskId=uefe258cf-13fa-4ee3-a95c-62967561b94&title=&width=786.4" alt="image.png"><br>InnoDB 和 MyISAM 这两种存储引擎都在数据目录下对应的数据库子目录中创建了一个专门用于描述表结构的文件，   文件名是下面这样：表名.frm;<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704766606276-9ff4abe3-dae1-4b54-b724-b9dd7f2b4932.png#averageHue=%23f9faf7&clientId=u50e43ce6-dc72-4&from=paste&height=420&id=uca547619&originHeight=525&originWidth=1189&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=606155&status=done&style=none&taskId=ubbedfde0-0c87-47bb-8f2f-74c1fd22d0c&title=&width=951.2" alt="image.png"><br>系统表空间：这个系统表空间可以对应文件系统上一个或多个实际的文件.在默认情况下. lnnoDB 会<br>在数据目录下创建一个名为 ibdata 1 (在你的数据目录下找找看有没有)、大小为 12MB 的文件，这个文件就是对应的系统表空间在文件系统上的表示。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704766854096-55a7e2c4-758a-45c9-a891-e153be721607.png#averageHue=%23f5f6f3&clientId=u50e43ce6-dc72-4&from=paste&height=79&id=ucb72a6d1&originHeight=99&originWidth=1129&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=115156&status=done&style=none&taskId=u036f0954-3260-4f11-92c3-0dce8d95708&title=&width=903.2" alt="image.png"><br>独立表空间：<img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704766723931-28da8e5f-e267-4f58-85d8-5f54e6118969.png#averageHue=%23edf1f0&clientId=u50e43ce6-dc72-4&from=paste&height=205&id=uc7b6e60e&originHeight=256&originWidth=1156&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=293747&status=done&style=none&taskId=u71595563-debe-448e-8f54-bf958b5641f&title=&width=924.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704766878441-90eed82c-1d61-4a96-b05a-71cc89fb4f67.png#averageHue=%23fbfbf8&clientId=u50e43ce6-dc72-4&from=paste&height=126&id=u5d0de595&originHeight=158&originWidth=1151&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=145930&status=done&style=none&taskId=u14058840-c32f-493b-bad6-224255f1041&title=&width=920.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704766893869-f95272fe-85ce-4827-a9ec-7d14dc602181.png#averageHue=%23fbfbf8&clientId=u50e43ce6-dc72-4&from=paste&height=356&id=uea275b71&originHeight=445&originWidth=1156&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=419016&status=done&style=none&taskId=uc563bdb9-a79a-4bc9-bafe-21bdcf59131&title=&width=924.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704766922999-346532bd-df6b-416b-91ff-4cd598367acd.png#averageHue=%23f4f4f1&clientId=u50e43ce6-dc72-4&from=paste&height=474&id=ub5e099ea&originHeight=592&originWidth=1177&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=633192&status=done&style=none&taskId=u0cd702d3-2864-4051-95cf-7ac7f6328a0&title=&width=941.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704766949419-7534de6b-cfb3-41ae-a9af-93e7c022c1a8.png#averageHue=%23f5f5f2&clientId=u50e43ce6-dc72-4&from=paste&height=357&id=udf92aa78&originHeight=446&originWidth=1174&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=454430&status=done&style=none&taskId=u1062266f-6c71-4133-905a-642d963db72&title=&width=939.2" alt="image.png"></p><h2 id="InnoDB-的表空间："><a href="#InnoDB-的表空间：" class="headerlink" title="InnoDB 的表空间："></a>InnoDB 的表空间：</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704769619803-9bdd77d3-cc56-4e6d-bfbb-1f70900c69e7.png#averageHue=%23f6f6f6&clientId=u50e43ce6-dc72-4&from=paste&height=534&id=u2ab6707f&originHeight=667&originWidth=1144&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=603647&status=done&style=none&taskId=u3be75562-38b8-4f6c-a399-a6fabced6d8&title=&width=915.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704769632365-94f67884-eb61-46f9-8b30-2b2a89e5c934.png#averageHue=%23f9faf7&clientId=u50e43ce6-dc72-4&from=paste&height=590&id=ue6f0d831&originHeight=737&originWidth=1154&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=840235&status=done&style=none&taskId=u70bdb041-0c53-46df-8419-5e65a28f5cb&title=&width=923.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704769643425-b41d24e9-4a2b-436c-8889-ba6432b0096d.png#averageHue=%23f9faf7&clientId=u50e43ce6-dc72-4&from=paste&height=86&id=ufdb84da3&originHeight=108&originWidth=1160&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=149656&status=done&style=none&taskId=u20b54703-cb55-4a7a-89e3-50aca2115b9&title=&width=928" alt="image.png"><br>单表访问方法：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-number">1</span>、const:通过主键和二级索引来查找;<span class="hljs-number">2.</span>ref:设计 MySQL 的大叔把这种<span class="hljs-string">&quot;搜索条件为二级索引列与常数进行得值比较，形成的扫描区间为单点扫描区间，   采用二级索引来执行查询&quot;</span>的访问方法称为 ref</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704770304310-fc385516-dd1a-4bf3-ba35-b54c14cdd6c0.png#averageHue=%23f6f7f4&clientId=u50e43ce6-dc72-4&from=paste&height=236&id=u1de3c5c9&originHeight=295&originWidth=1249&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=360313&status=done&style=none&taskId=u12c01250-f654-4d33-af13-675f960ffa2&title=&width=999.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704770395900-519a80e8-ee81-4b80-9052-11862d85f38c.png#averageHue=%23f6f7f4&clientId=u50e43ce6-dc72-4&from=paste&height=173&id=u6ec1fb87&originHeight=216&originWidth=1134&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=298111&status=done&style=none&taskId=ua29ed9d9-5cff-4fb9-8316-4a286dec671&title=&width=907.2" alt="image.png"><br>ref和const之间关于二级索引的区别：const表示二级索引的列是唯一的，不重复的；而ref不是这样的<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704770469767-bc3f3d25-fd9d-488f-95f9-ee3d610c43d9.png#averageHue=%23fafbf8&clientId=u50e43ce6-dc72-4&from=paste&height=114&id=u3222cef2&originHeight=142&originWidth=1105&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=171226&status=done&style=none&taskId=u696bda21-42fe-4c76-bc2c-57568ec48c8&title=&width=884" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704770497546-30459041-b1c3-49af-875f-993af31601d9.png#averageHue=%23e3e7e5&clientId=u50e43ce6-dc72-4&from=paste&height=126&id=uda11cee8&originHeight=158&originWidth=1107&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=230996&status=done&style=none&taskId=uf20319ce-0abd-416c-bef5-29239aff341&title=&width=885.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704770575047-aa52e077-dc58-4998-92e1-0b022548aecc.png#averageHue=%23fbfbf8&clientId=u50e43ce6-dc72-4&from=paste&height=470&id=uf1e2c3f9&originHeight=587&originWidth=1141&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=282693&status=done&style=none&taskId=u3e65bc9d-c3a9-4734-84a3-738e5317d6a&title=&width=912.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704770623577-cb632efe-ce6c-4b6a-a514-d7ffa756bf84.png#averageHue=%23f2f4f1&clientId=u50e43ce6-dc72-4&from=paste&height=474&id=u2fab2c32&originHeight=592&originWidth=1131&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=719037&status=done&style=none&taskId=uc684de6b-c90f-4737-9205-3a3a7438333&title=&width=904.8" alt="image.png"></p><h2 id="事务："><a href="#事务：" class="headerlink" title="事务："></a>事务：</h2><p>事务具有原子性，隔离性，一致性，持久性。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704778240337-bfe3b3ae-67b5-4b6f-af9d-efc35cecd2d6.png#averageHue=%23f7f8f5&clientId=u50e43ce6-dc72-4&from=paste&height=64&id=u7ceb77ce&originHeight=80&originWidth=1125&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=87411&status=done&style=none&taskId=u09acf50a-93e0-468c-9324-825b3201c2d&title=&width=900" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704778292040-d7d7aaa0-f8cb-4c2c-a1ac-b617cf38d29c.png#averageHue=%23f0f2ef&clientId=u50e43ce6-dc72-4&from=paste&height=490&id=u7a6bb809&originHeight=613&originWidth=1064&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=796969&status=done&style=none&taskId=u4fc39b94-8f60-4dd8-9718-ea549c19205&title=&width=851.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704778311761-acb6ef9d-dba2-4713-b42d-41e3a67d3052.png#averageHue=%23fcfdfa&clientId=u50e43ce6-dc72-4&from=paste&height=408&id=u0d981b69&originHeight=510&originWidth=919&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=220215&status=done&style=none&taskId=u2801da27-67bb-4e26-b095-d25936aedbb&title=&width=735.2" alt="image.png"><br>只有当事务处于提交的或者中止的状态时个事务的生命周期才算是结束了.对于已经提交的事务来说， 该事务对数据库所做的修改将永久生效;    对于处于中止状态的事务来说，该事务对数据库所傲的所有修改都会被回滚雪j没执行该事务之前的状态.<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704778552993-f9890243-72a6-431b-be59-5d3f75a60910.png#averageHue=%23f9f9f9&clientId=u50e43ce6-dc72-4&from=paste&height=630&id=ua1fe109b&originHeight=787&originWidth=1156&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=372507&status=done&style=none&taskId=uccbd4855-cc3a-4a9b-8140-73b306c7b00&title=&width=924.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704778583776-b4e195e2-1d62-46f3-9870-0162258fefa5.png#averageHue=%23f9f9f6&clientId=u50e43ce6-dc72-4&from=paste&height=151&id=udad72847&originHeight=189&originWidth=1023&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=152533&status=done&style=none&taskId=uf9f86fd8-a038-469a-b687-302994ba05a&title=&width=818.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704778618093-6ab5b273-f466-4b38-8676-6ce1246129dd.png#averageHue=%23f9f9f6&clientId=u50e43ce6-dc72-4&from=paste&height=221&id=udfe1d674&originHeight=276&originWidth=1144&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=244251&status=done&style=none&taskId=u19aaa563-426b-4503-919a-3b3abbbdefe&title=&width=915.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704778638210-11a19f1f-a0bf-4ef6-bc46-4be41b66674b.png#averageHue=%23fbfbfb&clientId=u50e43ce6-dc72-4&from=paste&height=182&id=u3c4bc943&originHeight=227&originWidth=1170&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=115612&status=done&style=none&taskId=u3de19052-171f-4968-8593-6dbae487b78&title=&width=936" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704778676830-5c169c10-26f7-43e5-85b4-11f6d1d58e1a.png#averageHue=%23fbfbf8&clientId=u50e43ce6-dc72-4&from=paste&height=213&id=ue8828826&originHeight=266&originWidth=773&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=101593&status=done&style=none&taskId=u5f4968f1-c8df-4c48-8891-99568d8a6a9&title=&width=618.4" alt="Snipaste_2024-01-09_13-37-53.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704778777513-5e37342f-6e0b-4bc7-9658-8d8d26f50924.png#averageHue=%23f6f6f6&clientId=u50e43ce6-dc72-4&from=paste&height=666&id=u3669d6af&originHeight=833&originWidth=1143&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=616084&status=done&style=none&taskId=u3489abc7-46f9-4ed1-8ff1-c585750f70c&title=&width=914.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704778810366-5cee1e31-0fb8-4a9c-b844-13326e1d06dd.png#averageHue=%23f9f9f6&clientId=u50e43ce6-dc72-4&from=paste&height=554&id=u56de42ee&originHeight=693&originWidth=1158&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=477989&status=done&style=none&taskId=u9e24d0aa-8787-47f2-8cd7-f17feb139c8&title=&width=926.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704778833359-237cf3e8-3cb2-432a-b664-f4ab3ead5ed9.png#averageHue=%23f9faf6&clientId=u50e43ce6-dc72-4&from=paste&height=122&id=u84f72d7a&originHeight=153&originWidth=1138&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=135862&status=done&style=none&taskId=u16f00498-e082-4dec-9dd2-aea0ff956b3&title=&width=910.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704778876033-a61125a8-b31d-4e01-b01e-233539f6bb83.png#averageHue=%23f7f8f5&clientId=u50e43ce6-dc72-4&from=paste&height=431&id=u58abfab8&originHeight=539&originWidth=1147&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=484503&status=done&style=none&taskId=ue6606d84-4eb2-4781-a771-1f363ccbb33&title=&width=917.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704778885203-91eaad65-5335-4812-ba55-42c8dbac9ddd.png#averageHue=%23f4f5f2&clientId=u50e43ce6-dc72-4&from=paste&height=106&id=ud1db022d&originHeight=133&originWidth=1059&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=127476&status=done&style=none&taskId=u884582fc-4a6c-49ec-add4-da10cc02eee&title=&width=847.2" alt="image.png"></p><h2 id="事务日志："><a href="#事务日志：" class="headerlink" title="事务日志："></a>事务日志：</h2><p><a href="https://blog.csdn.net/weixin_43004044/article/details/126818251">尚硅谷mysql日志</a><br><a href="https://www.cxyxiaowu.com/10740.html">https://www.cxyxiaowu.com/10740.html</a></p><h2 id="事务隔离级别和MVCC："><a href="#事务隔离级别和MVCC：" class="headerlink" title="事务隔离级别和MVCC："></a>事务隔离级别和MVCC：</h2><h3 id="事务一致性问题："><a href="#事务一致性问题：" class="headerlink" title="事务一致性问题："></a>事务一致性问题：</h3><div class="code-wrapper"><pre><code class="hljs python">在事务中的语句在执行时，并不会立即对数据库进行实际的修改。事务中的语句在执行过程中，会生成对数据库的操作日志，而不是直接修改数据库的实际数据。当调用事务的提交操作（COMMIT）时，事务将会执行以下步骤：首先，数据库管理系统将会将事务所做的操作日志持久化到磁盘，即将操作日志写入事务日志（Transaction Log）。然后，数据库管理系统会将事务中的所有修改操作应用到数据库的实际数据中，将事务所做的修改更新到相关的数据页或索引中。最后，数据库管理系统会通知应用程序事务已经成功提交，并将事务从活动状态转换为已完成状态。这样，通过事务的提交，数据库实际上才会将事务中的修改操作应用到数据库中，使其对其他事务可见。如果在事务执行过程中发生了错误或者执行了回滚操作（ROLLBACK），那么事务中的语句所做的修改操作将不会被提交。数据库管理系统会将事务操作日志中的记录进行撤销，从而回滚事务的修改，恢复到事务开始前的状态。重要的是要理解，事务的提交是一个关键步骤，它标志着事务的最终确认和永久性的修改。在事务提交之前，事务所做的修改只存在于事务日志中，并不对其他事务可见。只有在提交时，数据库才会将这些修改应用到实际数据中。</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">事务（Transaction）是对数据库的一组操作作为一个逻辑单元进行执行的过程。事务具有原子性、一致性、隔离性和持久性（ACID）的特性。它将一系列操作（读取、写入、修改等）组合在一起，要么全部成功执行，要么全部回滚。操作日志（Transaction Log）是数据库管理系统用于记录事务操作的一种机制。它是一个持久化的数据结构，用于记录每个事务的操作细节和顺序。操作日志通常以一种顺序的方式记录事务的开始、操作和结束。操作日志的主要作用是提供数据的恢复和持久性。通过记录事务操作的详细日志，数据库可以在系统故障或崩溃后进行恢复，并确保数据的一致性和完整性。在事务执行过程中，数据库管理系统将事务的操作记录写入操作日志，而不是直接修改数据库中的实际数据。这意味着在事务提交之前，数据库中的实际数据并没有发生变化，而是将相应的修改操作记录到操作日志中。操作日志记录了事务执行的详细信息，包括事务的标识符、开始时间、操作类型（读取、写入、修改等）以及相应的数据内容。通过操作日志，数据库可以实现以下功能：事务恢复：在系统故障或崩溃后，数据库可以通过回放操作日志来恢复未提交的事务或撤销已提交的事务，从而保证数据的一致性。并发控制：操作日志可以用于实现并发控制机制，如多版本并发控制（MVCC）。数据库可以根据事务的开始时间和操作日志的顺序来确定事务的可见性和隔离性。归档和备份：操作日志可以用于数据库的归档和备份。通过定期备份操作日志，可以在需要时还原数据库到特定时间点的状态。在数据库系统中，操作日志是非常重要的组成部分，它确保了数据的可靠性和一致性。通过记录事务的操作细节，操作日志提供了数据恢复、并发控制和备份等关键功能。</code></pre></div><p>1.事务开启后，其书写的sql语句，其实都会执行的，只不过提交是将其事务更改的数据刷新到磁盘中。<br>脏写：如果一个事务修改了另一个未提交事务修改过的数据，  就意味着发生了脏写现象。<br>脏读：如果一个事务读到了另一个未提交事务修改过的数据，就意味着发生了脏读现象。<br>不可重复读 ( Non-Repea~ble Read ) ：如果一个事务修改了另一个半提交事务读取的数据，    就意味着发生了不可重复读现象，或者叫模糊读 ( Fu町 Read) 现象。<br>幻读 (Phantom)：如果一个事务先根据某些搜索条件查询出一些记录，在该事务未提交时，另一个事务写<br>入一些了符合那些搜索条件的记录(这里的写入可以指 INSERT、DELETE、  UPDATE 操作) , 就意味着发生了幻读现象.</p><h2 id="锁："><a href="#锁：" class="headerlink" title="锁："></a>锁：</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704782637979-9c5b1a25-de61-4986-bb83-b99fabf025f6.png#averageHue=%23fafbf8&clientId=u50e43ce6-dc72-4&from=paste&height=288&id=ua2e3505e&originHeight=360&originWidth=1156&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=329396&status=done&style=none&taskId=u3c914d15-fabb-42a7-b965-4e5c304a6be&title=&width=924.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704782644522-1a9b856b-97a4-4a5a-838c-32f5020af4dc.png#averageHue=%23f8faf6&clientId=u50e43ce6-dc72-4&from=paste&height=115&id=u1a674c73&originHeight=144&originWidth=1161&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=139116&status=done&style=none&taskId=u093b370e-1281-4fda-a5d7-e7bd9ddf2bd&title=&width=928.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704782688091-33b0ba35-588c-47e7-bd6f-7a7989fd1a98.png#averageHue=%23eef3f0&clientId=u50e43ce6-dc72-4&from=paste&height=122&id=u24d40228&originHeight=153&originWidth=1139&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=175018&status=done&style=none&taskId=u8fbe2109-d8e9-4573-89e2-48ea3b1960f&title=&width=911.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704782728336-795e4d3a-4147-4fde-bc4b-b4801fc7469f.png#averageHue=%23f6f6f3&clientId=u50e43ce6-dc72-4&from=paste&height=461&id=u4e9d48a9&originHeight=576&originWidth=1178&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=421849&status=done&style=none&taskId=u29021354-f836-4f2e-befb-7dfbf49c03a&title=&width=942.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704782744991-0ea11327-2aaa-4f78-98f0-17cc5e83f711.png#averageHue=%23f7f7f7&clientId=u50e43ce6-dc72-4&from=paste&height=302&id=u8e219d63&originHeight=377&originWidth=1168&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=249415&status=done&style=none&taskId=uc7a7b8ca-2abf-4d24-9e1e-70f1920f818&title=&width=934.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704782763109-1ce63cef-c600-4421-bcba-2c5bf68e2601.png#averageHue=%23f3f3f3&clientId=u50e43ce6-dc72-4&from=paste&height=360&id=u71f7d151&originHeight=450&originWidth=1121&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=402934&status=done&style=none&taskId=u54d2dc11-6339-4ead-954a-cd919b45144&title=&width=896.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704782867519-22deb640-c2dd-4ea4-85c0-78de886e3334.png#averageHue=%23f7f7f7&clientId=u50e43ce6-dc72-4&from=paste&height=571&id=ub13c70b7&originHeight=714&originWidth=1151&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=568450&status=done&style=none&taskId=ubea06d7a-6696-494b-abbb-3fd15930de1&title=&width=920.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704782878305-ac0f1828-cd55-425a-a007-cfbbaaa06547.png#averageHue=%23fcfcf9&clientId=u50e43ce6-dc72-4&from=paste&height=277&id=u2eab52b3&originHeight=346&originWidth=1147&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=218273&status=done&style=none&taskId=uba7f808d-a7d6-4482-b3bf-edee12c429c&title=&width=917.6" alt="Snipaste_2024-01-09_14-47-54.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704782952432-ac741d41-98be-4ac4-98aa-173b1ec35b4c.png#averageHue=%23f9faf7&clientId=u50e43ce6-dc72-4&from=paste&height=457&id=u06cd12d6&originHeight=571&originWidth=1140&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=671434&status=done&style=none&taskId=uc205756d-3e4b-47ae-970c-ce4c7e1c683&title=&width=912" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704782962300-f3289ffe-2f0b-4d11-ab97-7a2c2500dbf2.png#averageHue=%23f8f9f6&clientId=u50e43ce6-dc72-4&from=paste&height=279&id=u0928012a&originHeight=349&originWidth=1156&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=384805&status=done&style=none&taskId=u36ac1957-c056-4ef2-8637-1c0e3783342&title=&width=924.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704782993716-5d7b39b4-deec-4315-b1f7-12a6b27a65aa.png#averageHue=%23f2f4f1&clientId=u50e43ce6-dc72-4&from=paste&height=193&id=u4a418ed1&originHeight=241&originWidth=1103&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=246854&status=done&style=none&taskId=ufd665bf8-4a76-49e4-a962-6cc6de37828&title=&width=882.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704783048582-15a18ac7-351e-48f9-8554-54957611a34e.png#averageHue=%23f3f3f0&clientId=u50e43ce6-dc72-4&from=paste&height=454&id=u2c3c35bc&originHeight=567&originWidth=1130&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=673219&status=done&style=none&taskId=ue5023c6d-62df-41e3-9e2d-fdb5ec919a5&title=&width=904" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704783172653-70174689-ab02-4d67-bc03-ee5e6cdcf5db.png#averageHue=%23f7f7f7&clientId=u50e43ce6-dc72-4&from=paste&height=546&id=uaa62d5be&originHeight=683&originWidth=1165&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=494443&status=done&style=none&taskId=u728c983b-6040-4bdf-a1ed-f650f3634bd&title=&width=932" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704783179713-377c2a95-5dba-4155-8847-20fc5054cb66.png#averageHue=%23fafaf7&clientId=u50e43ce6-dc72-4&from=paste&height=78&id=u394f3d02&originHeight=98&originWidth=749&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=67193&status=done&style=none&taskId=u7e533629-f754-4f86-b7a2-99be7766643&title=&width=599.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704783287118-b29ef23b-fa00-4e64-a4f0-d21ab924cfd6.png#averageHue=%23fafbf8&clientId=u50e43ce6-dc72-4&from=paste&height=505&id=ud571ebc7&originHeight=631&originWidth=1133&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=664853&status=done&style=none&taskId=u038370cb-ef2b-4595-821f-695fcaeb4f2&title=&width=906.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704783303491-258993c2-47f0-4433-a9a3-f07da5991782.png#averageHue=%23f2f4f1&clientId=u50e43ce6-dc72-4&from=paste&height=249&id=u2c760c24&originHeight=311&originWidth=1129&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=364581&status=done&style=none&taskId=ue74ab32f-b8d9-40e6-96d3-6eb5991e3f9&title=&width=903.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704783321314-19f380d6-6430-40c0-9e5a-814fb69dc943.png#averageHue=%23ebece9&clientId=u50e43ce6-dc72-4&from=paste&height=362&id=u68b8f65c&originHeight=453&originWidth=1166&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=507387&status=done&style=none&taskId=uf96beb5e-8828-489c-927c-aef6395cc39&title=&width=932.8" alt="image.png"><br>InnoDB 中的行级锁：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704784011594-91639a65-97a4-478e-9dfd-705132c944d0.png#averageHue=%23f4f8f6&clientId=u50e43ce6-dc72-4&from=paste&height=250&id=ua6abce6f&originHeight=312&originWidth=1080&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=325206&status=done&style=none&taskId=ueefd5b59-4bef-4de9-b5d8-84ed3969a4d&title=&width=864" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1704784018104-7ab7a4ff-12fa-4156-86b6-e4126f6369f6.png#averageHue=%23e9ebe9&clientId=u50e43ce6-dc72-4&from=paste&height=60&id=u767b498d&originHeight=75&originWidth=1069&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=98148&status=done&style=none&taskId=u8f3a8cd6-cd5e-4edf-b591-208eae2eeae&title=&width=855.2" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot2江南一点雨博客总结</title>
    <link href="/2024/01/26/%E6%B1%9F%E5%8D%97%E4%B8%80%E7%82%B9%E9%9B%A8springboot%E6%95%B4%E7%90%86%EF%BC%9A/"/>
    <url>/2024/01/26/%E6%B1%9F%E5%8D%97%E4%B8%80%E7%82%B9%E9%9B%A8springboot%E6%95%B4%E7%90%86%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot:"></a>Springboot:</h1><h2 id="入门："><a href="#入门：" class="headerlink" title="入门："></a>入门：</h2><h3 id="ComponentScan注解："><a href="#ComponentScan注解：" class="headerlink" title="@ComponentScan注解："></a>@ComponentScan注解：</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(basePackages = &quot;org.javaboy&quot;, useDefaultFilters = true,</span><span class="hljs-meta">excludeFilters = &#123;@ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Controller.class)&#125;)</span></code></pre></div><p><a href="https://blog.csdn.net/huangjhai/article/details/104600328">@ComponentScan注解用于定义扫描的路径，从中找出标识了需要装配的类自动装配到Spring的Bean容器中。basePackages属性用于指定扫描路径，可以是单个路径，也可以是扫描的路径数组。如果不指定该属性，则默认扫描该注解所在类的同级目录及其子目录下所有的类。useDefaultFilters属性默认为true，表示开启默认过滤器，即只有标注了@Component、@Repository、@Service、@Controller等注解的类才会被装配到Spring的Bean容器中。如果不想使用默认过滤器，可以将该属性设置为false。如果需要排除某些类，则可以使用excludeFilters属性，该属性接收一个数组参数，数组中每个元素都是一个过滤器。在这里，您使用了一个排除过滤器，即排除所有标注了@Controller注解的类。</a></p><h3 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet:"></a>DispatcherServlet:</h3><p><a href="https://www.baeldung.com/spring-controllers#Overview">Just a moment…</a><br>springmvc流程图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698890087546-b6de719c-e18f-4797-9ead-a98872acf9ed.png#averageHue=%23fcf9f8&clientId=uc63d89a5-684b-4&from=paste&height=439&id=ud49b9475&originHeight=549&originWidth=982&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=68285&status=done&style=none&taskId=ue9f3a3a4-2fca-42ea-8913-177b8ae22d6&title=&width=785.6" alt="image.png"><br>**_Front Controller _**主要职责包括：</p><ul><li>拦截传入请求</li><li>将请求的有效负载（请求的有效载荷就是请求中的数据部分，也就是请求体部分）转换为数据的内部结构</li><li>将数据发送到_模型_进行进一步处理</li><li>从模型中获取处理后的数据_，_并将该数据推进到_视图_进行渲染</li></ul><p><em>DispatcherServlet</em> 在架构中扮演着 <em>Front Controller</em> 的角色。该图既适用于典型的 MVC 控制器，也适用于 RESTful 控制器，但有一些细微的差异（如下所述）。<br>在传统方法中，<em>MVC</em> 应用程序不是面向服务的;因此，有一个 V_iew 解析器_，它根据从 <em>Controller</em> 接收的数据呈现最终视图。<br><em>RESTful</em> 应用程序被设计为面向服务并返回原始数据（通常为 JSON&#x2F;XML）。由于这些应用程序不执行任何视图渲染，因此没有_视图解析器，并且通常期望控制器_通过 HTTP 响应直接发送数据。</p><h3 id="ServletContext："><a href="#ServletContext：" class="headerlink" title="ServletContext："></a>ServletContext：</h3><p>1.一个web应用只有一个ServletContext。<br>2，在web应用部署成功后，servlet容器为应用创建了ServletContext实例，当服务器关闭时，其才被释放。在web中，<strong>一个用户可以有多个request；一个用户有一个session，而ServletContext，是所有的用户共用一个</strong>。所以，_ServletContext的存在，就是为了存放必须的、重要的、所有用户需要共享的、线程又是安全的一些资源信息，这样不仅节省了空间，还提高了效率_。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698891268381-033152f0-2985-471a-9d81-bef534b0e081.png#averageHue=%23fbf9f8&clientId=uc63d89a5-684b-4&from=paste&height=562&id=u20e7ea4b&originHeight=703&originWidth=1186&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=53892&status=done&style=none&taskId=u6a8bec85-9013-4249-a54f-67002fef631&title=&width=948.8" alt="image.png"></p><h3 id="消息转换器："><a href="#消息转换器：" class="headerlink" title="消息转换器："></a>消息转换器：</h3><p><a href="https://cloud.tencent.com/developer/article/1666635">https://cloud.tencent.com/developer/article/1666635</a><br><a href="https://www.baeldung.com/spring-httpmessageconverter-rest">Just a moment…</a><br>1.@RestController 注解即可将返回的数据结构转换成 Json 格式;@ResponseBody 注解是将返回的数据结构转换为 Json 格式。<br>2.要自定义JSON转换可以在相关配置类中重写configureMessageConverters方法。</p><h2 id="基础配置："><a href="#基础配置：" class="headerlink" title="基础配置："></a>基础配置：</h2><p><strong>application.properties配置文件的位置和顺序：</strong></p><ol><li>当前项目根目录下的 config 目录下</li><li>当前项目的根目录下</li><li>resources 目录下的 config 目录下</li><li>resources 目录下</li></ol><p>按如上顺序，四个配置文件的优先级依次降低。如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698904143503-fb8b531c-fac5-4f21-bd37-7709b2815ad7.png#averageHue=%23fcfaf9&clientId=uc63d89a5-684b-4&from=paste&id=uc570651b&originHeight=402&originWidth=285&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=12916&status=done&style=none&taskId=u707a1795-6eeb-402b-b86d-ff31eb75e48&title=" alt="image.png"><br><a href="https://blog.csdn.net/sanduo112/article/details/129061118">SpringBoot 启动配置文件加载和参数配置修改问题_springboot 动态修改properties-CSDN博客</a></p><h3 id="通过配置文件实现属性注入："><a href="#通过配置文件实现属性注入：" class="headerlink" title="通过配置文件实现属性注入："></a>通过配置文件实现属性注入：</h3><p><a href="https://blog.csdn.net/qq_42937522/article/details/106230679">修改SpringBoot默认的启动图案_springboot项目启动动画-CSDN博客</a></p><h4 id="properties版本："><a href="#properties版本：" class="headerlink" title="properties版本："></a>properties版本：</h4><p>法1：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698904456651-70570623-1d03-452d-b10c-51e07f2fdcdd.png#averageHue=%23f7f6f6&clientId=uc63d89a5-684b-4&from=paste&height=195&id=u5acadc95&originHeight=244&originWidth=1079&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=48642&status=done&style=none&taskId=ud6a3335b-be02-4fde-982e-2acc317af40&title=&width=863.2" alt="image.png"><br>法2：自定义属性配置文件<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698904509965-5d092091-2cba-4726-8f33-3e1cb0dc058c.png#averageHue=%23f7f6f5&clientId=uc63d89a5-684b-4&from=paste&height=295&id=uc034b30f&originHeight=369&originWidth=648&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=31205&status=done&style=none&taskId=uca732f19-c64d-497a-af94-bec3c517878&title=&width=518.4" alt="image.png"><br>法3：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698904570866-42066c9d-da27-4c3f-a23d-ceff0cea9c78.png#averageHue=%23f6f5f4&clientId=uc63d89a5-684b-4&from=paste&height=251&id=uda6ed2bf&originHeight=314&originWidth=1096&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=36820&status=done&style=none&taskId=u982f2f91-bfe1-487b-b49f-eb43e84434d&title=&width=876.8" alt="image.png"><br>yaml文件的数组注入：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698904672864-5748916a-b284-40ad-83a2-780fddb87c3b.png#averageHue=%23f8f7f7&clientId=uc63d89a5-684b-4&from=paste&height=205&id=u65a5874b&originHeight=256&originWidth=1128&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=24788&status=done&style=none&taskId=uec0a16e1-b425-4fc1-801b-bc37b59bb15&title=&width=902.4" alt="image.png"><br><a href="https://www.ruanyifeng.com/blog/2016/07/yaml.html">YAML 语言教程 - 阮一峰的网络日志</a><br>YAML文件是有序的。这意味着在YAML文件中，键值对的顺序是被保留的，并且在读取配置文件时会按照它们的出现顺序进行处理。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698909888570-fe6ca9f5-a789-41d5-b841-e0cfc0a80fff.png#averageHue=%233e4c5b&clientId=uc63d89a5-684b-4&from=paste&height=387&id=u84e7a604&originHeight=484&originWidth=1201&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=277512&status=done&style=none&taskId=u33e0fd3a-ecbc-4873-b82d-b9e0d75d9c1&title=&width=960.8" alt="image.png"></p><h3 id="配置文件多环境区分："><a href="#配置文件多环境区分：" class="headerlink" title="配置文件多环境区分："></a>配置文件多环境区分：</h3><p><a href="https://www.cnblogs.com/Chenjiabing/p/13968781.html">嗯，挺全乎儿的，Spring Boot 多环境配置都在这里了，你喜欢哪种？ - 爱撒谎的男孩 - 博客园</a><br>1.创建不同环境的配置文件：<br>既然每个环境的配置都不相同，索性将不同环境的配置放在不同的配置文件中，因此需要创建三个不同的配置文件，分别是<strong>application-dev.properties</strong>、<strong>application-test.properties</strong>、<strong>application-prod.properties</strong>。<br><strong>「注意」</strong>：配置文件的名称一定要是<strong>application-name.properties</strong>或者<strong>application-name.yml</strong>格式。这个<strong>name</strong>可以自定义，主要用于区分。<br>此时整个项目中就有四个配置文件，加上<strong>application.properties</strong>。<br>2.指定运行的环境<br>虽然你创建了各个环境的配置文件，但是Spring Boot 仍然不知道你要运行哪个环境，有以下两种方式指定：<br>配置文件中指定：<br>在application.properties或者application.yml文件中指定，内容如下：</p><div class="code-wrapper"><pre><code class="hljs java">指定运行环境为测试环境spring.profiles.active=test</code></pre></div><p>如果没有指定运行的环境，<strong>Spring Boot</strong> 默认会加载<strong>application.properties</strong>文件，而这个的文件又告诉<strong>Spring Boot</strong> 去找<strong>test</strong>环境的配置文件。<br>运行 jar 的时候指定：<br><strong>Spring Boot</strong> 内置的环境切换能够在运行<strong>Jar</strong>包的时候指定环境，命令如下：</p><div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>-<span class="hljs-keyword">jar </span>xxx.<span class="hljs-keyword">jar </span>--spring.profiles.active=test</code></pre></div><p>以上命令指定了运行的环境是<strong>test</strong>。</p><h3 id="springboot关于tomcat的配置："><a href="#springboot关于tomcat的配置：" class="headerlink" title="springboot关于tomcat的配置："></a>springboot关于tomcat的配置：</h3><p><a href="https://www.cnblogs.com/jvstarblog/p/12717900.html">SpringBoot - 内置的Tomcat服务器配置详解（附：启用HTTPS服务） - 11014p - 博客园</a></p><div class="code-wrapper"><pre><code class="hljs java">server.port：配置 Web 容器的端口号（默认为 <span class="hljs-number">8080</span>）server.error.path：配置当前项目出错时跳转去的页面。server.servlet.session.timeout：配置 session 失效时间。30m 表示 <span class="hljs-number">30</span> 分钟，如果不写单位则默认单位是秒。（注意：由于 Tomcat 中配置 session 过期时间是以分钟为单位，如果我们这里设置是秒的话，那么会自动转换为一个不超过所配置秒数的最大分钟数。比如配置了 <span class="hljs-number">119</span> 秒，那么实际 session 过期时间是 <span class="hljs-number">1</span> 分钟）server.servlet.context-path：配置项目名称（默认为 /），如果配置了项目名称，那么在访问路径中要加上配置的路径server.tomcat.uri-encoding：配置 Tomcat 请求编码server.tomcat.max-threads：配置 Tomcat 的最大线程数server.tomcat.basedir：配置 Tomcat 运行日志和临时文件的目录。若不配置，则默认使用系统的临时目录。</code></pre></div><p>其中tomcat的配置选项还有https的配置选项。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698909158697-f4c6a29d-0f6b-4784-9009-5a2237a7efb6.png#averageHue=%232b2c31&clientId=uc63d89a5-684b-4&from=paste&height=104&id=uf19d6248&originHeight=130&originWidth=574&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=42016&status=done&style=none&taskId=ucf1289cd-e685-465d-aa5c-1734cfc66dc&title=&width=459.2" alt="image.png"></p><h3 id="自定义一个start"><a href="#自定义一个start" class="headerlink" title="自定义一个start:"></a>自定义一个start:</h3><h2 id="整合视图："><a href="#整合视图：" class="headerlink" title="整合视图："></a>整合视图：</h2><h2 id="整合web开发："><a href="#整合web开发：" class="headerlink" title="整合web开发："></a>整合web开发：</h2><h3 id="静态资源配置："><a href="#静态资源配置：" class="headerlink" title="静态资源配置："></a>静态资源配置：</h3><p>&#x2F;** 表示可以匹配任意层级的路径；</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ComponentScan(basePackages = &quot;org.sang.javassm&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringMVCConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebMvcConfigurationSupport</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> &#123;        registry.addResourceHandler(<span class="hljs-string">&quot;/**&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;/&quot;</span>);    &#125;&#125;</code></pre></div><p>在 Spring Boot 中，默认情况下，一共有5个位置可以放静态资源，五个路径分别是如下5个：</p><ol><li>classpath:&#x2F;META-INF&#x2F;resources&#x2F;</li><li>classpath:&#x2F;resources&#x2F;</li><li>classpath:&#x2F;static&#x2F;</li><li>classpath:&#x2F;public&#x2F;</li><li>&#x2F;</li></ol><p>第5个 &#x2F; 其实就是表示 webapp 目录中的静态资源；如果同一个文件分别出现在五个目录下，那么优先级也是按照上面列出的顺序。</p><h3 id="ControllerAdvice-注解"><a href="#ControllerAdvice-注解" class="headerlink" title="@ControllerAdvice 注解"></a>@ControllerAdvice 注解</h3><p>以实现三个方面的功能：</p><ol><li>全局异常处理</li><li>全局数据绑定</li><li>全局数据预处理<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyGlobalExceptionHandler</span> &#123;    <span class="hljs-comment">//@ExceptionHandler 注解用来指明异常的处理类型</span>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span>    <span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">customException</span><span class="hljs-params">(Exception e)</span> &#123;        <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mv</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>();        mv.addObject(<span class="hljs-string">&quot;message&quot;</span>, e.getMessage());        mv.setViewName(<span class="hljs-string">&quot;myerror&quot;</span>);        <span class="hljs-keyword">return</span> mv;    &#125;&#125;</code></pre></div>全局数据绑定功能可以用来做一些初始化的数据操作，我们可以将一些公共的数据定义在添加了 @ControllerAdvice 注解的类中，这样，在每一个 Controller 的接口中，就都能够访问导致这些数据。<br>全局数据预处理：</li></ol><p>Model,ModelMap,ModelAndView的区别：<br><a href="https://www.baeldung.com/spring-mvc-model-model-map-model-view">Model, ModelMap, and ModelAndView in Spring MVC | Baeldung</a><br><a href="https://blog.csdn.net/ITBigGod/article/details/79685610">Model、ModelMap和ModelAndView的使用详解-CSDN博客</a>（完整）<br>Model是一个接口,ModelMap类，ModelAndView是容器：</p><div class="code-wrapper"><pre><code class="hljs java">Model is an <span class="hljs-keyword">interface</span> <span class="hljs-title class_">that</span> defines a holder <span class="hljs-keyword">for</span> model attributes and is primarily designed <span class="hljs-keyword">for</span> adding attributes to the model. It can supply attributes used <span class="hljs-keyword">for</span> rendering views. To provide a view with usable data, we simply add <span class="hljs-built_in">this</span> data to its Model object. Additionally, maps with attributes can be merged with Model instances.ModelMap is a <span class="hljs-keyword">class</span> <span class="hljs-title class_">that</span> is also used to pass values to render a view. The advantage of ModelMap is it gives us the ability to pass a collection of values and treat these values as <span class="hljs-keyword">if</span> they were within a Map.ModelAndView is a container <span class="hljs-keyword">for</span> both a ModelMap and a view object. It allows a controller to <span class="hljs-keyword">return</span> both as a single value.</code></pre></div><h3 id="ModelAttribute："><a href="#ModelAttribute：" class="headerlink" title="@ModelAttribute："></a>@ModelAttribute：</h3><p><a href="https://blog.csdn.net/wxgxgp/article/details/81304570">【Spring】@ModelAttribute三种使用场景_@modelattribute @valid-CSDN博客</a><br><strong>1.用在Controller的方法上：</strong><br>每次执行方法时都会先执行@ModelAttribute注解的方法（此时该注解修饰的方法是用来准备数据的)，并将结果添加到<a href="https://so.csdn.net/so/search?q=model&spm=1001.2101.3001.7020">model</a>中。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698928290546-b45a1883-fd5e-4c04-989e-1c64fa3b57aa.png#averageHue=%232c2e33&clientId=ucec36595-9ede-4&from=paste&height=350&id=u2932cf82&originHeight=437&originWidth=1059&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=219047&status=done&style=none&taskId=u20da7afb-e587-4342-86dc-6fec0214a04&title=&width=847.2" alt="image.png"><br>@ModelAttribute(“top”)中的top是该Model的名字；<br>控制台结果：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698928330942-01750c78-3802-4167-bbdc-0c84b652fd99.png#averageHue=%236083a6&clientId=ucec36595-9ede-4&from=paste&height=42&id=u8e11ba24&originHeight=52&originWidth=336&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=9108&status=done&style=none&taskId=u20581994-2e5a-46b6-a74f-4aa15f8b42d&title=&width=268.8" alt="image.png"><br>2**.用在方法的参数上：**可以直接从指定的模型中中取值.标注在方法参数上的@ModelAttribute说明了该方法参数的值将由model中取得。如果model中找不到，那么该参数会先被实例化，然后被添加到model中。在model中存在以后，请求中所有名称匹配的参数都会填充到该参数中。<br>3.<strong>用在ControllerAdvice的方法中：</strong>每个Controller中的方法执行前都会先执行 @ModelAttribute注解标注的方法，并将返回值添加到model<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698929265928-829ccb7a-716b-48d4-9df4-6dee12417bc3.png#averageHue=%232b2f37&clientId=ucec36595-9ede-4&from=paste&height=313&id=u3611b62b&originHeight=391&originWidth=964&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=190086&status=done&style=none&taskId=u4b8a4672-d6b4-4075-ad49-271013eca25&title=&width=771.2" alt="image.png"><a href="https://zhuanlan.zhihu.com/p/115902823">SpringBoot2教程29整合SpringMVC之@InitBinder处理请求参数的绑定(一)</a></p><h3 id="自定义异常处理："><a href="#自定义异常处理：" class="headerlink" title="自定义异常处理："></a>自定义异常处理：</h3><p>springboot错误处理原理：</p><ul><li><ol><li>SpringBoot 会<strong>自适应处理错误</strong>，<strong>响应页面</strong>或<strong>JSON数据</strong></li></ol></li><li>2.** SpringMVC的错误处理机制<strong>依然保留，</strong>MVC处理不了<strong>，才会</strong>交给boot进行处理**</li><li><img src="https://cdn.nlark.com/yuque/0/2023/svg/1613913/1681723795095-828d2034-1e6c-4d98-8e47-573dd6b5463b.svg#from=url&id=ORNes&originHeight=842&originWidth=1047&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></li></ul><h4 id="静态异常页面："><a href="#静态异常页面：" class="headerlink" title="静态异常页面："></a>静态异常页面：</h4><h4 id="动态异常页面："><a href="#动态异常页面：" class="headerlink" title="动态异常页面："></a>动态异常页面：</h4><p><strong>动态页面模板，不需要开发者自己去定义控制器，直接定义异常页面即可 ，Spring Boot 中自带的异常处理器会自动查找到异常页面。</strong><br>如果动态页面和静态页面同时定义了异常处理页面，例如 classpath:&#x2F;static&#x2F;error&#x2F;404.html 和 classpath:&#x2F;templates&#x2F;error&#x2F;404.html 同时存在时，默认使用动态页面。</p><h4 id="自定义异常视图："><a href="#自定义异常视图：" class="headerlink" title="自定义异常视图："></a>自定义异常视图：</h4><p><a href="https://www.baeldung.com/global-error-handler-in-a-spring-rest-api">Custom Error Message Handling for REST API | Baeldung</a></p><h3 id="解决跨域问题："><a href="#解决跨域问题：" class="headerlink" title="解决跨域问题："></a>解决跨域问题：</h3><p><a href="https://blog.csdn.net/weixin_42318691/article/details/121187785">【精选】跨域请求被拒绝时，会进入后端接口执行吗？ 对跨域有个全面的认知_跨域请求被拦截后怎么判断请求到达后端_Yionr的博客-CSDN博客</a>（较长，有点废话）<br>1.所谓同源是指协议、域名以及端口要相同。</p><ul><li>浏览器的跨域请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。</li><li>所谓跨域是指浏览器当前访问的界面和请求的界面不是同一个源</li><li><strong>如果服务器没有配置CORS，则简单跨域请求可以成功执行，但是返回的内容会被浏览器拦截！</strong></li><li>当我们使用阿里OSS存储访问图片的时候，大都情况下是访问图片的请求是跨域请求；但是阿里云后端解决了跨域问题，所以访问前端可以直接访问图片，而不用处理跨域问题。</li><li><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698983164618-07adea71-2756-4788-b027-561c6b95dbae.png#averageHue=%23fdfdfc&clientId=ucec36595-9ede-4&from=paste&height=613&id=u7a47e668&originHeight=766&originWidth=1153&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=195846&status=done&style=none&taskId=u2079ddce-adf2-4073-b4ed-c8d2cfcc09a&title=&width=922.4" alt="image.png"></li></ul><p>解决跨域问题：<br><a href="https://blog.csdn.net/qq_39390545/article/details/106615075">Springboot处理CORS跨域请求的三种方法_springmvc 中的请求转发 重定向 导致 cors-CSDN博客</a><br>法1：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1.</span>可以通过<span class="hljs-meta">@CrossOrigin</span>注解配置某一个方法（contrller类）接受某一个域的请求，<span class="hljs-meta">@CrossOrigin(value = &quot;http://localhost:8081&quot;)</span> <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;    &#125;表示hello方法将解释来自http:<span class="hljs-comment">//localhost:8081的请求。也就是说该方法可以接受不属于自己域的值</span>如果该注解修饰的是一个controller类，那么表示该控制器的所有方法将可以接受不属于自己域的请求。</code></pre></div><p>法2：全局配置：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> &#123;        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>).allowedOrigins(<span class="hljs-string">&quot;http://localhost:8081&quot;</span>)                .allowedHeaders(<span class="hljs-string">&quot;*&quot;</span>)                .allowedMethods(<span class="hljs-string">&quot;*&quot;</span>)                .maxAge(<span class="hljs-number">30</span> * <span class="hljs-number">1000</span>);    &#125;&#125;<span class="hljs-comment">//1.registry.addMapping(&quot;/**&quot;)表示将控制器所有的方法都映射到跨源处理当中，也就是说控制器的所有</span><span class="hljs-comment">// 方法都可以处理来自不同域的请求;</span><span class="hljs-comment">// 2.allowedOrigins表示该控制器允许处理的其他域；</span><span class="hljs-comment">// 3.allowedMethods(&quot;*&quot;)是允许处理所有的请求方法，也就是get,put等等</span><span class="hljs-comment">//4. 可以这样思考：一个请求包括请求地址，请求方式，请求头；所以在addCorsMappings方法中要分别</span><span class="hljs-comment">// 对他们进行处理。</span></code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1699068846815-6ca54bd8-343f-4c8c-9b31-b6a9bd1703c8.png#averageHue=%23b9b9b9&clientId=u8707d90f-a194-4&from=paste&height=134&id=u507bd7a1&originHeight=168&originWidth=1210&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=175723&status=done&style=none&taskId=ud0cb1ccb-c3b0-47cc-af37-4d2d7f740da&title=&width=968" alt="image.png"></p><div class="code-wrapper"><pre><code class="hljs java">这里的.maxAge(<span class="hljs-number">30</span> * <span class="hljs-number">1000</span>)方法的含义是设置预检请求的响应可以被客户端缓存的时间，单位是毫秒。这样，如果客户端在这个时间内再次发送相同的预检请求，就不需要再次询问服务器，而是直接使用缓存的响应。这可以提高性能和效率。预检请求是一种特殊的OPTIONS请求，用于在跨域请求之前检查服务器是否允许该请求。预检请求会携带一些特定的头信息，如Origin, Access-Control-Request-Method, Access-Control-Request-Headers等，以告知服务器客户端的请求信息。服务器会根据这些信息返回一个响应，包含一些CORS相关的头信息，如Access-Control-Allow-Origin, Access-Control-Allow-Methods, Access-Control-Allow-Headers等，以告知客户端是否允许该请求。</code></pre></div><h3 id="自定义系统启动定时任务："><a href="#自定义系统启动定时任务：" class="headerlink" title="自定义系统启动定时任务："></a>自定义系统启动定时任务：</h3><p>1.往spring容器中注入实现CommandLineRunner接口的bean.并重写run方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-comment">//oredr代表的启动顺序，数字越小启动越早</span><span class="hljs-meta">@Order(98)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCommandLineRunner2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CommandLineRunner</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception &#123;        System.out.println(<span class="hljs-string">&quot;MyCommandLineRunner2&gt;&gt;&gt;&quot;</span>+Arrays.toString(args));    &#125;&#125;</code></pre></div><ol><li>首先通过 @Compoent 注解将 MyCommandLineRunner1 注册为Spring容器中的一个 Bean。</li><li>添加 @Order注解，表示这个启动任务的执行优先级，因为在一个项目中，启动任务可能有多个，所以需要有一个排序。@Order 注解中，数字越小，优先级越大，默认情况下，优先级的值为 Integer.MAX_VALUE，表示优先级最低。</li><li>在 run 方法中，写启动任务的核心逻辑，当项目启动时，run方法会被自动执行。</li><li>run 方法的参数，来自于项目的启动参数，即项目入口类中，main方法的参数会被传到这里。</li></ol><p>其中启动项目参数的设置：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1699027215737-3f76fcf5-a990-41c1-b55a-2a8d0f4a2d89.png#averageHue=%232d3034&clientId=ucec36595-9ede-4&from=paste&height=557&id=uf6b3bb45&originHeight=696&originWidth=1307&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=80941&status=done&style=none&taskId=u6cf348ff-05b0-47a9-a498-5d0f3937027&title=&width=1045.6" alt="image.png"><br>另一种方式，则是将项目打包，在命令行中启动项目，然后启动时在命令行传入参数，如下：</p><div class="code-wrapper"><pre><code class="hljs java">java -jar devtools-<span class="hljs-number">0.0</span><span class="hljs-number">.1</span>-SNAPSHOT.jar 三国演义 西游记</code></pre></div><p>2.实现ApplicationRunner<br>ApplicationRunner 可以接收更多类型的参数（ApplicationRunner 除了可以接收 CommandLineRunner 的参数之外，还可以接收 key&#x2F;value形式的参数）。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Order(98)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplicationRunner1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationRunner</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception &#123;        List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs();        System.out.println(<span class="hljs-string">&quot;MyApplicationRunner1&gt;&gt;&gt;&quot;</span>+nonOptionArgs);        Set&lt;String&gt; optionNames = args.getOptionNames();        <span class="hljs-keyword">for</span> (String key : optionNames) &#123;            System.out.println(<span class="hljs-string">&quot;MyApplicationRunner1&gt;&gt;&gt;&quot;</span>+key + <span class="hljs-string">&quot;:&quot;</span> + args.getOptionValues(key));        &#125;        String[] sourceArgs = args.getSourceArgs();        System.out.println(<span class="hljs-string">&quot;MyApplicationRunner1&gt;&gt;&gt;&quot;</span>+Arrays.toString(sourceArgs));    &#125;&#125;</code></pre></div><p>当项目启动时，这里的 run 方法就会被自动执行，关于 run 方法的参数 ApplicationArguments ，我说如下几点：</p><ol><li>args.getNonOptionArgs();可以用来获取命令行中的无key参数（和CommandLineRunner一样）。</li><li>args.getOptionNames();可以用来获取所有key&#x2F;value形式的参数的key。</li><li>args.getOptionValues(key));可以根据key获取key&#x2F;value 形式的参数的value。</li><li>args.getSourceArgs(); 则表示获取命令行中的所有参数。</li></ol><p>ApplicationRunner 定义完成后，传启动参数也是两种方式，参数类型也有两种，第一种和 CommandLineRunner 一致，第二种则是 –-key&#x3D;value 的形式<br>或者使用 如下启动命令：</p><div class="code-wrapper"><pre><code class="hljs java">java -jar devtools-<span class="hljs-number">0.0</span><span class="hljs-number">.1</span>-SNAPSHOT.jar 三国演义 西游记 --age=<span class="hljs-number">99</span></code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1699027440578-37ca5b8f-1ec7-40b9-84d0-b0021ed1e8ba.png#averageHue=%232e3035&clientId=ucec36595-9ede-4&from=paste&height=250&id=u2ea68ea4&originHeight=312&originWidth=1311&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=38886&status=done&style=none&taskId=u40cd6dc6-c2e9-4c32-bbbe-9566398f4ce&title=&width=1048.8" alt="image.png"></p><h3 id="整合Swagger2"><a href="#整合Swagger2" class="headerlink" title="整合Swagger2:"></a>整合Swagger2:</h3><h3 id="返回JSON数据："><a href="#返回JSON数据：" class="headerlink" title="返回JSON数据："></a>返回JSON数据：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1699029558493-55ad3d7c-e0ec-47a0-87a5-1fbe6b65e887.png#averageHue=%23c1c1c1&clientId=ucec36595-9ede-4&from=paste&height=246&id=u79c1b3f4&originHeight=307&originWidth=939&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=126216&status=done&style=none&taskId=u92e2689f-b9d8-42d3-84dc-c763c912b08&title=&width=751.2" alt="image.png"><br>@JsonIgnore<br>@JsonFormat</p><h3 id="文件上传："><a href="#文件上传：" class="headerlink" title="文件上传："></a>文件上传：</h3><h4 id="当个文件上传："><a href="#当个文件上传：" class="headerlink" title="当个文件上传："></a>当个文件上传：</h4><p>上传后实际文件的路径：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1699065995881-ba07577d-1fb2-4e73-b883-e2b075b6ab8c.png#averageHue=%232e3f60&clientId=u8707d90f-a194-4&from=paste&height=50&id=u80220495&originHeight=62&originWidth=1021&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=49946&status=done&style=none&taskId=ub3f72b4d-fed8-4cfd-bc01-b115cdcdd27&title=&width=816.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1699066123309-ccaad666-22dd-4be9-b683-ec039a5a7265.png#averageHue=%23f9f7f5&clientId=u8707d90f-a194-4&from=paste&height=230&id=ua3cef9b1&originHeight=287&originWidth=1030&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=63131&status=done&style=none&taskId=uc7c22aba-2fff-4de9-9665-b30d3d88c69&title=&width=824" alt="image.png"><br>上面的文件夹是服务器每次重启后都会新建一个。之前我做过一个项目是将上传头像的功能，上传的头像放在静态资源的路径下，但是每次上传成功后头像要系统重启后才能访问！会产生这种情况的原因是：静态资源在web访问启动后会被打包在target目录的class目录下。更新的头像更新了原静态文件夹的内容，但是这是没有更新class目录下的图片，只能重启重新打包在 class文件下。因为前端访问的静态资源是打包后class路径下的静态资源，而非服务器我们创建用来存放头像的静态资源。我们可以通过把头像放在上面tomcat生成的文件夹，从而实现文件的实时更新。<br>理解tomcat启动创建的文件夹：<br>上面的文件夹是web服务启动时，在temp目录下创建的。<br><a href="https://www.cnblogs.com/gavincoder/p/13794913.html">SpringBoot设置tomcat临时文件目录必要性 - 马非白即黑 - 博客园</a><br><a href="https://juejin.cn/s/tomcat%20temp%E7%9B%AE%E5%BD%95%E4%BD%9C%E7%94%A8">tomcat temp目录作用-掘金</a><br>文件上传form表单中的entype&#x3D;”multipart&#x2F;form-data”的理解：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1699066512036-4b29ca6a-e35f-4662-bd38-211e7586d6da.png#averageHue=%23b6b7b6&clientId=u8707d90f-a194-4&from=paste&height=57&id=u303dd822&originHeight=71&originWidth=947&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=96749&status=done&style=none&taskId=uda3fa412-7da8-4637-be35-de238de8bc9&title=&width=757.6" alt="image.png"><br>multipart是多部分的意思。<br><a href="https://zhuanlan.zhihu.com/p/195726295">entype&#x3D;”multipart&#x2F;form-data”是一种指定表单数据的编码方式，它可以让表单同时发送文本和二进制数据，比如文件、图片等。这种编码方式将表单数据分成多个部分，每个部分都有自己的头信息和内容，这样服务器就可以根据头信息来解析不同类型的数据</a><a href="https://zhuanlan.zhihu.com/p/195726295">1</a>。</p><h3 id="配置类和XML："><a href="#配置类和XML：" class="headerlink" title="配置类和XML："></a>配置类和XML：</h3><h3 id="拦截器："><a href="#拦截器：" class="headerlink" title="拦截器："></a>拦截器：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1699086129180-f794aa5f-d1fa-42bf-8715-bceea0e76fbe.png#averageHue=%23b6b6b6&clientId=u8707d90f-a194-4&from=paste&height=154&id=u96750bc5&originHeight=192&originWidth=1260&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=258261&status=done&style=none&taskId=ub347e9f5-f197-4655-8c6c-f66adc954e4&title=&width=1008" alt="image.png"></p><h3 id="整合Servlet，Filter-Listener"><a href="#整合Servlet，Filter-Listener" class="headerlink" title="整合Servlet，Filter,Listener:"></a>整合Servlet，Filter,Listener:</h3><h3 id="路径映射："><a href="#路径映射：" class="headerlink" title="路径映射："></a>路径映射：</h3><h3 id="配置AOP："><a href="#配置AOP：" class="headerlink" title="配置AOP："></a>配置AOP：</h3><h2 id="数据持久化："><a href="#数据持久化：" class="headerlink" title="数据持久化："></a>数据持久化：</h2><h3 id="JdbcTemplate："><a href="#JdbcTemplate：" class="headerlink" title="JdbcTemplate："></a>JdbcTemplate：</h3><h3 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis:"></a>mybatis:</h3><p><a href="https://blog.csdn.net/weixin_43944305/article/details/116178864">【精选】使用tk-mapper(通用mapper)自动生成mybatis的mapper&#x2F;实体&#x2F;接口_mybatis tkmapper生成接口-CSDN博客</a></p><h3 id="JPA"><a href="#JPA" class="headerlink" title="JPA:"></a>JPA:</h3><p><a href="https://blog.csdn.net/weixin_48321825/article/details/121953316">nativeQuery &#x3D; true是什么意思？_@query(nativequery &#x3D; true_有翅膀的猫的博客-CSDN博客</a><br><a href="https://www.baeldung.com/spring-data-jpa-modifying-annotation">Just a moment…</a></p><h2 id="整合NoSql"><a href="#整合NoSql" class="headerlink" title="整合NoSql:"></a>整合NoSql:</h2><h2 id="REST："><a href="#REST：" class="headerlink" title="REST："></a>REST：</h2><p>1.REST风格服务端不储存session,相关的信息要么要么通过客户端的token保存，要么保存在特点的redis中。</p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket:"></a>WebSocket:</h3><p><a href="https://juejin.cn/post/6926419575349182477#heading-0">SpringBoot + Vue 实现基于 WebSocket 的聊天室 - 掘金</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1699162382400-919c2099-2242-4b29-9019-41cc2d6e49e7.png#averageHue=%23b9b9b9&clientId=ucddaab6e-692b-4&from=paste&height=363&id=uf6182c7b&originHeight=454&originWidth=1289&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=481655&status=done&style=none&taskId=uca19d7bf-4492-460f-82e7-f71e309e769&title=&width=1031.2" alt="image.png"><br>STOMP 是一种简单的可互操作协议，设计用于通过中介服务器在客户端之间传递异步消息。它为这些客户端和服务器之间传递的消息定义了基于文本的有线格式。<a href="https://stomp.github.io/stomp-specification-1.1.html">STOMP官方文档</a></p><div class="code-wrapper"><pre><code class="hljs java">Spring Boot提供了WebSocket的支持，可以使用<span class="hljs-meta">@ServerEndpoint</span>注解来标注一个类，表示该类是一个WebSocket服务器端的处理器。在使用<span class="hljs-meta">@ServerEndpoint</span>注解时，我们还需要为该处理器配置一个ServerEndpointExporter实例，以便能够将其发布到服务器中。ServerEndpointExporter是一个Spring Bean，可以通过在配置类中添加<span class="hljs-meta">@Bean</span>注解来创建它的实例。在创建ServerEndpointExporter实例时，我们需要注入ServerEndpointExporter所需的其他Bean，例如ServerEndpointConfig和MessageConverter等。</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>springboot2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springboot2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springSecurity</title>
    <link href="/2024/01/26/%E6%B1%9F%E5%8D%97%E4%B8%80%E7%82%B9%E9%9B%A8springSecurity_/"/>
    <url>/2024/01/26/%E6%B1%9F%E5%8D%97%E4%B8%80%E7%82%B9%E9%9B%A8springSecurity_/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="springsecurity自动配置解析："><a href="#springsecurity自动配置解析：" class="headerlink" title="springsecurity自动配置解析："></a>springsecurity自动配置解析：</h2><p>SecurityFilterAutoConfiguration：<br><a href="https://www.cnblogs.com/chengxuxiaoyuan/p/17300575.html">spring security自动配置的源码简单分析 - 程序晓猿 - 博客园</a>（详细但是也挺难的）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@EnableConfigurationProperties(&#123;SecurityProperties.class&#125;)</span>注解，Spring Boot会自动将这些属性加载到应用程序的上下文中，使得我们可以通过<span class="hljs-meta">@Autowired</span>注解或其他方式方便地访问和使用这些属性。</code></pre></div><div class="code-wrapper"><pre><code class="hljs java">表示SecurityFilterAutoConfiguration的自动配置必须要在</code></pre></div><h3 id="请求到达spring-security的处理过程："><a href="#请求到达spring-security的处理过程：" class="headerlink" title="请求到达spring security的处理过程："></a>请求到达spring security的处理过程：</h3><p>一个请求到达spring security后首先会被DelegatingFilterProxy这个过滤器拦截到，这是一个代理过滤器，它会使用内部的代理目标delegate 也就是从容器中获取名称是springSecurityFilterChain的过滤器（而这个过滤器是由由WebSecurity 构建的FilterChainProxy这个类型的过滤器来处理请求,）总结下请求的处理路径就是：<br>1.DelegatingFilterProxy —–&gt;2.FilterChainProxy<br>详细看下FilterChainProxy这个过滤器</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterChainProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GenericFilterBean</span> &#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">    这个属性很重要,过滤器链的集合,从这个属性的类型可以知道spring security支持多个过滤器链</span><span class="hljs-comment">    一个链条对象SecurityFilterChain中会包含多个过滤器,</span><span class="hljs-comment">    当然一般情况我们的应用中只需要配置一个链条对象</span><span class="hljs-comment">    */</span>    <span class="hljs-keyword">private</span> List&lt;SecurityFilterChain&gt; filterChains;        <span class="hljs-meta">@Override</span>    <span class="hljs-comment">//下面的方法用于拦截并处理HTTP请求。首先检查是否已经应用了过滤器，如果没有则将一个标记属</span>    <span class="hljs-comment">// 性设置到请求中，然后执行内部的过滤器处理方法。最后，清除SecurityContextHolder中的上下</span>    <span class="hljs-comment">// 文，并移除标记属性。如果已经应用了过滤器，则直接执行内部处理方法。</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response,</span><span class="hljs-params">FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<span class="hljs-type">boolean</span> <span class="hljs-variable">clearContext</span> <span class="hljs-operator">=</span> request.getAttribute(FILTER_APPLIED) == <span class="hljs-literal">null</span>;<span class="hljs-keyword">if</span> (clearContext) &#123;<span class="hljs-keyword">try</span> &#123;request.setAttribute(FILTER_APPLIED, Boolean.TRUE);doFilterInternal(request, response, chain);&#125;<span class="hljs-keyword">finally</span> &#123;SecurityContextHolder.clearContext();request.removeAttribute(FILTER_APPLIED);&#125;&#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//请求进来后会执行到这里来执行真正的过滤逻辑</span>doFilterInternal(request, response, chain);&#125;&#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilterInternal</span><span class="hljs-params">(ServletRequest request, ServletResponse response,</span><span class="hljs-params">FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<span class="hljs-type">FirewalledRequest</span> <span class="hljs-variable">fwRequest</span> <span class="hljs-operator">=</span> firewall.getFirewalledRequest((HttpServletRequest) request);<span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">fwResponse</span> <span class="hljs-operator">=</span> firewall.getFirewalledResponse((HttpServletResponse) response);        <span class="hljs-comment">/* 首先通过这个getFilters方法来从过滤器链的集合filterChains中匹配到一个过滤器链</span><span class="hljs-comment">           对象SecurityFilterChain，返回这个链条里边的所有过滤器</span><span class="hljs-comment">        */</span>List&lt;Filter&gt; filters = getFilters(fwRequest);<span class="hljs-keyword">if</span> (filters == <span class="hljs-literal">null</span> || filters.size() == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;logger.debug(UrlUtils.buildRequestUrl(fwRequest)+ (filters == <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot; has no matching filters&quot;</span>: <span class="hljs-string">&quot; has an empty filter list&quot;</span>));&#125;fwRequest.reset();chain.doFilter(fwRequest, fwResponse);<span class="hljs-keyword">return</span>;&#125; <span class="hljs-comment">// 根据filters构造虚拟过滤器链对象VirtualFilterChain来遍历执行filters中的每个过滤器</span>         <span class="hljs-comment">// VirtualFilterChain是当前类中的内部类，遍历的原理就是这个类</span><span class="hljs-type">VirtualFilterChain</span> <span class="hljs-variable">vfc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VirtualFilterChain</span>(fwRequest, chain, filters);vfc.doFilter(fwRequest, fwResponse);&#125;        <span class="hljs-comment">// 这个方法用来根据request对象从filterChains中匹配出一个SecurityFilterChain对象并返回</span>    <span class="hljs-comment">// 此链条中的所有过滤器</span>    <span class="hljs-keyword">private</span> List&lt;Filter&gt; <span class="hljs-title function_">getFilters</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<span class="hljs-comment">//从这个方法可以看出SecurityFilterChain中一定存在两个方法 matches，getFilters</span>        <span class="hljs-keyword">for</span> (SecurityFilterChain chain : filterChains) &#123;<span class="hljs-keyword">if</span> (chain.matches(request)) &#123;<span class="hljs-keyword">return</span> chain.getFilters();&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;        <span class="hljs-comment">//内部类用来依次执行上边getFilters方法获取到的filters中的所有过滤器</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualFilterChain</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FilterChain</span> &#123;<span class="hljs-comment">/* 这个变量记录了原始的FilterChain对象,也就是FilterChainProxy这个过滤器的doFilter方法中的参            数FilterChain,通过这个FilterChain可以把请求从FilterChainProxy转给其他的过滤器(请求已经被         spring security处理完了接着去执行其他的过滤器)</span><span class="hljs-comment"></span><span class="hljs-comment">这里需要普及一下Filter的相关知识,当我们的应用中配置多个过滤器(不仅是spirng security的过滤器)         时,是通过FilterChain实现从filter1转给filter2的</span><span class="hljs-comment">下面是Filter接口的源码</span><span class="hljs-comment">        public interface Filter &#123;</span><span class="hljs-comment">        </span><span class="hljs-comment">           //这个方法参数chain就是用来实现把请求从filter1转给filter2的</span><span class="hljs-comment">            public void doFilter(ServletRequest request, ServletResponse response,</span><span class="hljs-comment">                FilterChain chain) throws IOException, ServletException;</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">        </span><span class="hljs-comment">        一般我们实现Filter接口时都要实现此方法,并通过chain.doFilter方法实现把请求交给下一个过滤器。</span><span class="hljs-comment">        public  MyFilter implements Filter&#123;</span><span class="hljs-comment">        @Override</span><span class="hljs-comment">        public void doFilter(ServletRequest request, ServletResponse response,</span><span class="hljs-comment">            FilterChain chain) throws IOException, ServletException&#123;</span><span class="hljs-comment">            </span><span class="hljs-comment">              ...一些过滤的逻辑</span><span class="hljs-comment">              //最后把请求交给下一个顾虑器时都会执行</span><span class="hljs-comment">              chain.doFilter(request, response);</span><span class="hljs-comment">            &#125;</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">        </span><span class="hljs-comment">*/</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> FilterChain originalChain;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Filter&gt; additionalFilters;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> FirewalledRequest firewalledRequest;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> size;<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">currentPosition</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">private</span> <span class="hljs-title function_">VirtualFilterChain</span><span class="hljs-params">(FirewalledRequest firewalledRequest,</span><span class="hljs-params">FilterChain chain, List&lt;Filter&gt; additionalFilters)</span> &#123;<span class="hljs-built_in">this</span>.originalChain = chain;<span class="hljs-built_in">this</span>.additionalFilters = additionalFilters;<span class="hljs-built_in">this</span>.size = additionalFilters.size();<span class="hljs-built_in">this</span>.firewalledRequest = firewalledRequest;&#125;<span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span><span class="hljs-keyword">throws</span> IOException, ServletException &#123;            <span class="hljs-comment">//这个方法通过currentPosition来控制递归调用additionalFilters中的所有过滤器</span><span class="hljs-keyword">if</span> (currentPosition == size) &#123;                <span class="hljs-comment">//这里表示执行到了最后一个过滤器</span><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;logger.debug(UrlUtils.buildRequestUrl(firewalledRequest)+ <span class="hljs-string">&quot; reached end of additional filter chain; proceeding with original chain&quot;</span>);&#125;<span class="hljs-comment">// Deactivate path stripping as we exit the security filter chain</span><span class="hljs-built_in">this</span>.firewalledRequest.reset();<span class="hljs-comment">// spring security已经处理完了，把请求转给其他的过滤器</span>originalChain.doFilter(request, response);&#125;<span class="hljs-keyword">else</span> &#123;currentPosition++;<span class="hljs-comment">// 取出additionalFilters中currentPosition位置的过滤器</span><span class="hljs-type">Filter</span> <span class="hljs-variable">nextFilter</span> <span class="hljs-operator">=</span> additionalFilters.get(currentPosition - <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;logger.debug(UrlUtils.buildRequestUrl(firewalledRequest)+ <span class="hljs-string">&quot; at position &quot;</span> + currentPosition + <span class="hljs-string">&quot; of &quot;</span> + size+ <span class="hljs-string">&quot; in additional filter chain; firing Filter: &#x27;&quot;</span>+ nextFilter.getClass().getSimpleName() + <span class="hljs-string">&quot;&#x27;&quot;</span>);&#125;<span class="hljs-comment">//因为VirtualFilterChain实现了FilterChain接口，所以这里</span>                <span class="hljs-comment">//利用this把请求又转给了自己,相当于递归,通过currentPosition的递增会</span>                 <span class="hljs-comment">//遍历执行完additionalFilters中的全部过滤器。</span>nextFilter.doFilter(request, response, <span class="hljs-built_in">this</span>);&#125;&#125;&#125;&#125;</code></pre></div><p>所以真正处理请求的其实是FilterChainProxy中维护的 SecurityFilterChain ,再更新下上边说的请求处理路径<br>1.DelegatingFilterProxy —–&gt;2.FilterChainProxy —-&gt;3.SecurityFilterChain<br>总结：<br>先是在SecurityFilterAutoConfiguration中给容器中加入了一个DelegatingFilterProxyRegistrationBean ,这个bean最后会给应用中注册一个DelegatingFilterProxy,这个代理过滤器会从容器中找出名称为springSecurityFilterChain的过滤器来执行它；<br>而这个springSecurityFilterChain是在WebSecurityConfiguration（这个类可以靠SecurityAutoConfiguration导入到容器中的）<br>）中由springSecurityFilterChain这个方法加到spring容器中的,在这个方法中会调用构建器WebSecurity.build方法创建出一个FilterChainProxy过滤器放到spring容器中;<br>当执行到WebSecurity.performBuild方法,会先调用SecurityFilterChain的构建器HttpSecurity的build方法构建出DefaultSecurityFilterChain对象,该对象内部会持有多个过滤器,然后把该对象作为参数创建出FilterChainProxy 对象返回。<br>可以看到这个过程中WebSecurity 是一个很关键的角色，它创建了DefaultSecurityFilterChain和FilterChainProxy</p><ul><li><input disabled="" type="checkbox"> SecurityFilterAutoConfiguration-&gt;DelegatingFilterProxyRegistrationBean-&gt;DelegatingFilterProxy-&gt;FilterChainProxy-&gt;DefaultSecurityFilterChain;这里其中的FilterChainProxy-&gt;DefaultSecurityFilterChain是在websecurity中创建的。</li></ul><p>webSecurity这个构建器用来创建Filter,，其中它具体构造过滤链还是落在WebSecurityConfigurerAdapter上的configure方法。<br>WebSecurity是一个接口，它定义了Spring Security框架提供的安全功能的抽象接口。WebSecurityConfigurer是一个抽象类，用于配置Web应用程序的安全性。WebSecurityConfigurerAdapter是WebSecurityConfigurer的子类，它通过实现WebSecurityConfigurer中的抽象方法来配置Web应用程序的安全性。它还提供了默认实现来简化配置过程。因此，WebSecurityConfigurerAdapter是WebSecurityConfigurer的适配器类，用于方便地配置Web应用程序的安全性。<br>个人总结：我们一般配置安全信息配置类一般是要重写WebSecurityConfigurerAdapter，为什么要重写这个？因为spring从SecurityFilterAutoConfiguration自动加载过滤链的时候需要提取加载WebSecurityAutoConfiguration到容器中，而WebSecurityAutoConfiguration会加载WebSecurityConfiguration到容器中，其中真正过滤器链的创建还是要落在WebSecurityConfigurerAdapter上的configure方法上，当我们没有配置安全信息类时就启动时就加载WebSecurityConfigurerAdapter的其他默认配置类到容器中，比如：DefaultConfigurerAdapter。<br><a href="https://juejin.cn/post/7046236598832201758#heading-14">🍃【Spring专题】「技术原理」Spring Security的核心功能和加载运行流程的原理分析 - 掘金</a>（这个简单些）<br><a href="https://blog.csdn.net/m0_37989980/article/details/107519382">Spring Security——认证、授权的工作原理_spring security 授权原理-CSDN博客</a><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1700456347886-7de54b1e-0d9e-4152-ad92-47bd9ef539fb.jpeg#averageHue=%23fafafa&clientId=uf783de77-98a1-4&from=paste&id=BlS8q&originHeight=1488&originWidth=1080&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u3002f874-d427-448f-aeaa-de701abfb8e&title="><br>个人简单总结：就是安全的过滤链配置是通过重写WebSecurityConfigurerAdapter中的configure实现的，而这个过滤链接包括认证和授权：而下面的认证授权过滤链几乎都集中到WebSecurityConfigurerAdapter中了。<br>认证：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700459594842-c9c3cb42-5ff5-4ea1-92a6-638ed3a7fc2c.png#averageHue=%23fefefe&clientId=uf783de77-98a1-4&from=paste&id=u4bc7aa3f&originHeight=519&originWidth=1011&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uf0086c3a-d91d-4588-9269-6dc0a248b09&title="><br>授权：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700459619119-d8bcb9b2-56ec-45fd-bf0d-710ba773b507.png#averageHue=%23fefefe&clientId=uf783de77-98a1-4&from=paste&id=u795db273&originHeight=424&originWidth=843&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ue765f258-cee3-4292-96b9-2692eb9f292&title="></p><h2 id="获取ip地址："><a href="#获取ip地址：" class="headerlink" title="获取ip地址："></a>获取ip地址：</h2><h2 id="SpringSecurity配置过滤器的时候对-and的理解："><a href="#SpringSecurity配置过滤器的时候对-and的理解：" class="headerlink" title="SpringSecurity配置过滤器的时候对.and的理解："></a>SpringSecurity配置过滤器的时候对.and的理解：</h2><p><a href="https://cloud.tencent.com/developer/article/1651669">Spring Security 配置中的 and 到底该怎么理解？-腾讯云开发者社区-腾讯云</a><br>springsecurity有15个过滤器，and结束的地方是每个过滤器相关配置结束的地方。</p><h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2><p>1.我们往容器中注入了UserDetailsService后，我们配置文件中配置的</p><div class="code-wrapper"><pre><code class="hljs java">spring:  security:    user:      name: admin      password: <span class="hljs-number">888888</span></code></pre></div><p>就会失效。这是因为在这种情况下，Spring Security将使用注入的UserDetailsService返回的UserDetails对象来进行身份验证，而不再使用配置文件中的用户名和密码。<br>2.当我们希望系统想从指定的数据源获取<br>3.</p><div class="code-wrapper"><pre><code class="hljs java">UserDetails是一个接口，表示用户的身份信息。它包含了用户的基本信息，如用户名、密码、角色等。WebAuthenticationDetails是一个类，表示Web应用程序中的身份验证细节。它包含了用户进行身份验证时的相关信息，如用户的IP地址、浏览器的 Referer 等UserDetails是UserDetailsService获取的。</code></pre></div><p>4.<a href="https://stackoverflow.com/questions/64526372/when-should-i-override-the-configureauthenticationmanagerbuilder-auth-from-spr">When should I override the configure(AuthenticationManagerBuilder auth) from Spring Security in a Spring Boot app?</a></p><div class="code-wrapper"><pre><code class="hljs java">注入 UserDetailsService 实例和重写 configure(AuthenticationManagerBuilder auth) 方法之间的区别在于配置的灵活性和控制权。注入 UserDetailsService 实例：通过将 UserDetailsService 实例注入到容器中，Spring Security 将自动使用该实例进行身份验证。这种方式适用于简单的身份验证需求，例如基于数据库的验证，只需要提供用户详细信息的查询逻辑。你无法直接在代码中对身份验证流程进行更详细的配置，因为验证过程是由 Spring Security 自动处理的。重写 configure(AuthenticationManagerBuilder auth) 方法：通过重写 configure(AuthenticationManagerBuilder auth) 方法，你可以更精确地配置身份验证过程。你可以定义多个身份验证提供者，并为每个提供者指定不同的验证逻辑、密码编码器等。可以使用多种身份验证方式，如数据库、LDAP、OAuth 等。可以自定义用户详细信息的加载方式和逻辑。可以添加其他的身份验证配置，如记住我功能、会话管理、多因素身份验证等。你可以在代码中直接控制身份验证的细节，并根据需要进行自定义和扩展。</code></pre></div><h2 id="springsecurity中的-ThreadLocal如何理解："><a href="#springsecurity中的-ThreadLocal如何理解：" class="headerlink" title="springsecurity中的 ThreadLocal如何理解："></a>springsecurity中的 ThreadLocal如何理解：</h2><div class="code-wrapper"><pre><code class="hljs java">在Spring Security中，ThreadLocal主要用于存储当前用户的信息。当用户进行认证并获得访问权限后，Spring Security会将用户信息存储到ThreadLocal中，以便在请求的处理过程中可以获取到当前用户的信息。  具体来说，Spring Security提供了SecurityContextHolder类来管理用户信息的存储和获取。SecurityContextHolder类中有一个getContext()方法返回一个SecurityContext对象，该对象中有一个getAuthentication()方法返回一个Authentication对象，该对象中存储了用户的信息。 在每个请求的处理过程中，Spring Security会将Authentication对象存储到ThreadLocal中，以便在需要访问用户信息的地方可以通过SecurityContextHolder.getContext().getAuthentication()来获取到用户的信息。  需要注意的是，ThreadLocal的使用可以保证每个请求都有独立的用户信息存储空间，避免了多个线程间共享用户信息导致的安全问题。但是，ThreadLocal的使用也会带来一定的性能开销，因为每个线程都需要存储和获取自己的ThreadLocal对象。因此，在使用ThreadLocal存储用户信息时，需要注意权衡安全和性能的关系。</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>springSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springSecurity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机基础实验五：程序链接和ELF</title>
    <link href="/2024/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%9E%E9%AA%8C%E4%BA%94%EF%BC%9A%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E5%92%8CELF%EF%BC%9A/"/>
    <url>/2024/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%9E%E9%AA%8C%E4%BA%94%EF%BC%9A%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E5%92%8CELF%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="实验前的准备：下载相关tar包并解压"><a href="#实验前的准备：下载相关tar包并解压" class="headerlink" title="实验前的准备：下载相关tar包并解压"></a>实验前的准备：下载相关tar包并解压</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686930452605-21aab784-abff-40d2-a5e6-b2601061dc9e.png#averageHue=%239daea3&clientId=u2fc4f0fd-b0be-4&from=paste&height=122&id=u2a6f2bfb&originHeight=153&originWidth=982&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=33956&status=done&style=none&taskId=u4683b393-026e-49ab-bea5-9478af7adff&title=&width=785.6" alt="image.png"></p><h2 id="链接和ELF实验：静态数据与ELF数据节"><a href="#链接和ELF实验：静态数据与ELF数据节" class="headerlink" title="链接和ELF实验：静态数据与ELF数据节"></a>链接和ELF实验：静态数据与ELF数据节</h2><h4 id="实验内容："><a href="#实验内容：" class="headerlink" title="实验内容："></a>实验内容：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686930285773-3845529d-7925-4dc0-bd50-59a1f8df4075.png#averageHue=%23c4cdd7&clientId=u2fc4f0fd-b0be-4&from=paste&height=94&id=u8ba43333&originHeight=117&originWidth=710&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=106462&status=done&style=none&taskId=uee865758-9bf9-4e37-b0b4-fd399d2aac1&title=&width=568" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686930400583-02a13afa-8f65-4dbf-9145-d0cebe5e2353.png#averageHue=%23c7d0da&clientId=u2fc4f0fd-b0be-4&from=paste&height=63&id=ua6e353cd&originHeight=79&originWidth=714&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=60972&status=done&style=none&taskId=u35dcdd4a-74d7-422b-8342-4b0fffdcf81&title=&width=571.2" alt="image.png"><br>本实验的内容：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686966994243-dbd58fa7-c98f-4769-b144-3fb202885bb9.png#averageHue=%23bbc4ce&clientId=uc4e10333-fa46-4&from=paste&height=87&id=udc53ab43&originHeight=109&originWidth=682&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=101975&status=done&style=none&taskId=uf9b7fa57-3074-4a2d-8d95-6b335796cea&title=&width=545.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686967036411-6bfb8b10-4671-4610-88f0-8c8cafaf2036.png#averageHue=%23d0dfeb&clientId=uc4e10333-fa46-4&from=paste&height=74&id=ue81f870a&originHeight=92&originWidth=568&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=62799&status=done&style=none&taskId=u9d66ce7c-5629-439c-92ba-0ea961369a2&title=&width=454.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686967055177-63f3a27a-4854-4584-82c0-fdf288d9f950.png#averageHue=%23d1dfed&clientId=uc4e10333-fa46-4&from=paste&height=96&id=u5407e56f&originHeight=120&originWidth=571&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=51079&status=done&style=none&taskId=ue2206ce1-acf2-4180-93b0-b606d1ee689&title=&width=456.8" alt="image.png"></p><h4 id="实验要求："><a href="#实验要求：" class="headerlink" title="实验要求："></a>实验要求：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686930562095-021a55dc-6dc0-4790-80f9-d81d1c3f5168.png#averageHue=%23cdd5dc&clientId=u2fc4f0fd-b0be-4&from=paste&height=265&id=u954494d5&originHeight=331&originWidth=1096&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=437739&status=done&style=none&taskId=u68bddd94-5b64-45eb-97ca-2db86de5ab8&title=&width=876.8" alt="image.png"><br>更改每个阶段可执行文件的输出。</p><h4 id="事例："><a href="#事例：" class="headerlink" title="事例："></a>事例：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686931078857-408cc73e-4603-4c4c-9931-7afd2311f457.png#averageHue=%231c306d&clientId=uc4e10333-fa46-4&from=paste&height=92&id=u6b6c7af3&originHeight=115&originWidth=958&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=167119&status=done&style=none&taskId=ud1134e26-8f0f-4ef0-b4b9-884d4f4bc28&title=&width=766.4" alt="image.png">（第一次编译报错的原因是Linux架构和main.o和phasel.o不一样，后者是i386，需要使用-m32选项指定使用 i386 架构编译目标文件）<br>运行：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686931233066-44f2a666-00ce-495a-a5c8-d01beb5ddac8.png#averageHue=%231e2b6c&clientId=uc4e10333-fa46-4&from=paste&height=41&id=uf067abfe&originHeight=51&originWidth=1416&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=96877&status=done&style=none&taskId=uf8f8c0e4-67de-47b7-b759-f512d323fa1&title=&width=1132.8" alt="image.png"></p><h4 id="相关知识点："><a href="#相关知识点：" class="headerlink" title="相关知识点："></a>相关知识点：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686931429682-f3c7d168-7b8f-4d41-a437-5cf8e48467ae.png#averageHue=%23d5dde3&clientId=uc4e10333-fa46-4&from=paste&height=338&id=u2600a89f&originHeight=423&originWidth=677&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=262879&status=done&style=none&taskId=ua1953c3c-a696-4df5-a739-fdd9d37ae6b&title=&width=541.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686931448024-9a6edb3e-8122-4e72-a004-309323e7e531.png#averageHue=%23dce6ee&clientId=uc4e10333-fa46-4&from=paste&height=41&id=u22067e36&originHeight=74&originWidth=349&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=47879&status=done&style=none&taskId=ue0535751-d0c6-4f16-aa15-d2ad17e8d0c&title=&width=194.1999969482422" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686931438554-4d5520a3-76ad-4357-81c5-3e03900de425.png#averageHue=%23c6d4e0&clientId=uc4e10333-fa46-4&from=paste&height=66&id=u37b1cda1&originHeight=82&originWidth=998&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=134038&status=done&style=none&taskId=ufce1b0d9-f779-45f1-ac50-95295b42983&title=&width=798.4" alt="image.png"><br>链接的本质是合并相同的节。<br>链接的过程：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686962541386-8bfe0185-cf9c-456f-962e-8dd00add7e50.png#averageHue=%23d0dde7&clientId=uc4e10333-fa46-4&from=paste&height=101&id=u893715f5&originHeight=126&originWidth=783&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=127116&status=done&style=none&taskId=u5fbed367-2de9-4261-879a-867fe756da0&title=&width=626.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686962585846-3af8b6dd-179a-410d-9010-c674e6a19761.png#averageHue=%23cedae5&clientId=uc4e10333-fa46-4&from=paste&height=124&id=ubedffb9d&originHeight=155&originWidth=1081&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=230671&status=done&style=none&taskId=u1808e582-1621-4e44-a5eb-760c3ed4d26&title=&width=864.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686962601782-12e3bf97-6819-4be0-a36c-8cced0f3c53e.png#averageHue=%23c0d0dd&clientId=uc4e10333-fa46-4&from=paste&height=38&id=ucb75d45f&originHeight=47&originWidth=910&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=80507&status=done&style=none&taskId=u6210a4ba-46a0-490a-b2b8-9e62a26059b&title=&width=728" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686962621833-3a3727a5-f676-46ce-9a51-d1f34bc34bd1.png#averageHue=%23d2dee8&clientId=uc4e10333-fa46-4&from=paste&height=112&id=u3ab3ec6d&originHeight=140&originWidth=1028&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=176963&status=done&style=none&taskId=u2c1c9d99-a543-4e9c-8dc2-ba105ba34ce&title=&width=822.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686962638814-49af89ba-a227-4a5f-8ec9-19806292eb1f.png#averageHue=%23c4d2df&clientId=uc4e10333-fa46-4&from=paste&height=78&id=u81de06c6&originHeight=97&originWidth=820&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=153761&status=done&style=none&taskId=u2c6bbad2-83ca-4da2-af70-36eedfe00a6&title=&width=656" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686962671790-16c5e348-5921-47f1-b970-c2541d1127d0.png#averageHue=%23d2dbe4&clientId=uc4e10333-fa46-4&from=paste&height=126&id=uffe110de&originHeight=158&originWidth=602&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=96499&status=done&style=none&taskId=u2c072607-b6a9-4b49-9e6e-d948ed871bf&title=&width=481.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686962681016-1abbe57b-0a30-4e5c-b727-8d458e9a1352.png#averageHue=%23c1c9d0&clientId=uc4e10333-fa46-4&from=paste&height=131&id=ubf59d4a0&originHeight=164&originWidth=602&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=134604&status=done&style=none&taskId=ub9cc5b31-e7fb-482a-8d1c-b6e171fbba3&title=&width=481.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686962699731-13bbc031-c58d-43fd-ae71-cd608fbbf0fe.png#averageHue=%23cad2da&clientId=uc4e10333-fa46-4&from=paste&height=149&id=ue62a667d&originHeight=186&originWidth=612&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=114752&status=done&style=none&taskId=u1e79204f-4c0a-4bd9-b094-550e820c661&title=&width=489.6" alt="image.png"><br>可重定位目标文件：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686962746511-bcff010c-3f27-4205-859f-2283738ca8ac.png#averageHue=%23afc2d3&clientId=uc4e10333-fa46-4&from=paste&height=34&id=u7a962a7d&originHeight=43&originWidth=625&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=54799&status=done&style=none&taskId=u01ba2f15-8f41-4e80-951e-bd9cc2ef43d&title=&width=500" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686962753310-05e968d8-60aa-4aa7-86d7-906e8910ad1c.png#averageHue=%23c5d3e0&clientId=uc4e10333-fa46-4&from=paste&height=62&id=u2833a9ee&originHeight=77&originWidth=1010&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=123384&status=done&style=none&taskId=ue44135e1-3ba7-45fd-8dd8-0ed22a20d97&title=&width=808" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686962774283-38bee5ee-64ce-45b3-ab23-4d758932e704.png#averageHue=%23c1d0dd&clientId=uc4e10333-fa46-4&from=paste&height=60&id=ufc7c5954&originHeight=75&originWidth=1001&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=133837&status=done&style=none&taskId=u99a2317d-9e42-455d-a026-75bc2068959&title=&width=800.8" alt="image.png"><br>可重定位目标格式：<br>ELF文件：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686963303523-dceeb23a-fa9b-4c18-a8c9-aecd7fd26b39.png#averageHue=%23d2dae0&clientId=uc4e10333-fa46-4&from=paste&height=400&id=uf209af8a&originHeight=500&originWidth=286&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=129695&status=done&style=none&taskId=ue127e0fd-7bb0-4126-a3f7-4bf18352fa5&title=&width=228.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686962815581-0c112812-739c-410d-83b2-507d4003f369.png#averageHue=%23cbd7e2&clientId=uc4e10333-fa46-4&from=paste&height=86&id=ub6563719&originHeight=108&originWidth=775&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=156598&status=done&style=none&taskId=ueb63bbdf-f675-44c6-be46-a35c8408b84&title=&width=620" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686962842428-ddffb608-0eb4-439e-8fb0-5eed2f17aec0.png#averageHue=%23e4ecf2&clientId=uc4e10333-fa46-4&from=paste&height=82&id=uabfc49e5&originHeight=103&originWidth=758&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=123351&status=done&style=none&taskId=uac644b77-f90e-4421-a05f-d554b8c7c9b&title=&width=606.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686962866634-e7d15ec3-6952-46f3-8d6a-a07c6c283d14.png#averageHue=%23c5d3df&clientId=uc4e10333-fa46-4&from=paste&height=58&id=udfe59b23&originHeight=72&originWidth=780&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=111962&status=done&style=none&taskId=ucff980ba-49c6-4e85-b839-87fe302689a&title=&width=624" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686962885273-c9f5f75e-e80e-4fe9-8216-87542e09fc85.png#averageHue=%23b5c6d6&clientId=uc4e10333-fa46-4&from=paste&height=78&id=u5881c02e&originHeight=98&originWidth=625&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=119648&status=done&style=none&taskId=u5d0f3694-e525-446a-a5b5-90d3d7075b8&title=&width=500" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686962931296-9711920b-cee0-4325-8c64-dce1609280de.png#averageHue=%23c9d6e1&clientId=uc4e10333-fa46-4&from=paste&height=166&id=ua44f958e&originHeight=207&originWidth=624&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=227181&status=done&style=none&taskId=u69472935-587f-4d05-b555-45d694fdc77&title=&width=499.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686962945018-0519e185-a87f-488d-a22a-c84317f67ccb.png#averageHue=%23c2d0dd&clientId=uc4e10333-fa46-4&from=paste&height=52&id=u0a9658e5&originHeight=65&originWidth=617&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=81822&status=done&style=none&taskId=u3c45d123-800e-43cf-88df-42f6514768f&title=&width=493.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686962956895-f7ec75e9-33bd-4afc-989f-0190f188abae.png#averageHue=%23a9bacc&clientId=uc4e10333-fa46-4&from=paste&height=24&id=ue50704b9&originHeight=30&originWidth=66&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=4323&status=done&style=none&taskId=u04228461-f25f-44bd-96ad-979e1edd6fc&title=&width=52.8" alt="image.png"><br>可执行目标文件：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686963277209-132e6f56-b26c-45e2-930c-f726bcd0ddaa.png#averageHue=%23c8d4d9&clientId=uc4e10333-fa46-4&from=paste&height=401&id=u444967fb&originHeight=501&originWidth=360&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=200595&status=done&style=none&taskId=u8207734d-55a2-4600-a37b-a7a4e5d55ed&title=&width=288" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686962987820-c198ad6c-0bd3-4afb-a0be-236155123d85.png#averageHue=%23c4d2de&clientId=uc4e10333-fa46-4&from=paste&height=34&id=uca43ef77&originHeight=43&originWidth=446&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=35793&status=done&style=none&taskId=u0f879822-dd5f-4721-a083-d9de7c7769e&title=&width=356.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686962996114-83ac3a62-8033-44d4-b79e-72762ab25b89.png#averageHue=%23b5c0ca&clientId=uc4e10333-fa46-4&from=paste&height=53&id=u91008477&originHeight=66&originWidth=662&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=91608&status=done&style=none&taskId=uca8bc3c6-a549-4e77-b388-b644ed8a9f0&title=&width=529.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686963015199-18dc3476-9e58-437a-9189-2921889e1954.png#averageHue=%23bec9d3&clientId=uc4e10333-fa46-4&from=paste&height=78&id=u08fbe7cc&originHeight=97&originWidth=698&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=112199&status=done&style=none&taskId=u749f095b-c8d9-4a34-b372-9595b970043&title=&width=558.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686963029393-54264527-19b3-46d1-907e-71f7c90a0e24.png#averageHue=%23c9d6e2&clientId=uc4e10333-fa46-4&from=paste&height=94&id=ufc13d00a&originHeight=118&originWidth=653&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=145879&status=done&style=none&taskId=uf0cf9a42-327b-4c7c-83f3-56f153bc18c&title=&width=522.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686963049953-0c26cb0d-c69e-4da4-bfb3-f0b0b81b8f14.png#averageHue=%23cdd9e4&clientId=uc4e10333-fa46-4&from=paste&height=69&id=u5bb737aa&originHeight=86&originWidth=656&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=90106&status=done&style=none&taskId=ua5d07bc6-1753-4eec-92ac-5e4f108e655&title=&width=524.8" alt="image.png"><br>可重定位文件和可执行文件的区别：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686963119015-aad76b63-c218-4663-b5da-3a0d286535d4.png#averageHue=%23c6d2dc&clientId=uc4e10333-fa46-4&from=paste&height=77&id=u2ce210a1&originHeight=96&originWidth=627&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=90822&status=done&style=none&taskId=u88503195-b818-4fee-aa0a-5842a0126e5&title=&width=501.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686963131675-18935fc7-8d14-43f7-9023-a74fc4a9c9a9.png#averageHue=%23c1c8cf&clientId=uc4e10333-fa46-4&from=paste&height=58&id=uf23305fe&originHeight=72&originWidth=611&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=71078&status=done&style=none&taskId=uda51b46a-e784-4297-885b-3c36504d8fc&title=&width=488.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686963144953-71d602a8-ea53-4814-8dd1-6c616e99a35a.png#averageHue=%23b6bec5&clientId=uc4e10333-fa46-4&from=paste&height=33&id=u22561cf9&originHeight=41&originWidth=588&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=38721&status=done&style=none&taskId=uc7397f7b-5ba6-488f-946e-686232f4dc0&title=&width=470.4" alt="image.png"><br>可执行文件存储器映像：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686963447543-7b8256aa-ac05-4534-9451-8898e37a52cc.png#averageHue=%23c5d6c8&clientId=uc4e10333-fa46-4&from=paste&height=398&id=u9b91d5da&originHeight=497&originWidth=762&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=354314&status=done&style=none&taskId=u1c12df7b-7110-4679-a04d-968821c607b&title=&width=609.6" alt="image.png"><br>每个重定位的结构：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686967771659-bdb5f50b-6bef-4a64-be20-87086a737788.png#averageHue=%238799b0&clientId=uc4e10333-fa46-4&from=paste&height=142&id=uUcji&originHeight=178&originWidth=492&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=68970&status=done&style=none&taskId=uadb1c403-7546-4380-995f-8506857ac44&title=&width=393.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686968066026-7b0f5858-475a-40fb-8433-cde02205dfde.png#averageHue=%23a7b7c8&clientId=uc4e10333-fa46-4&from=paste&height=71&id=aDnF9&originHeight=89&originWidth=443&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=53020&status=done&style=none&taskId=uc87d727c-14e1-41ed-af74-07bcb06004c&title=&width=354.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686968292954-2c940a1d-596a-42e4-a254-e73bfe683e4d.png#averageHue=%23fdfefc&clientId=uc4e10333-fa46-4&from=paste&height=123&id=VrwM9&originHeight=154&originWidth=575&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=100410&status=done&style=none&taskId=u4126e07c-ab24-4d91-ac0b-0c1bc69aca4&title=&width=460" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686969297445-1d71255b-75a0-4e5b-ab14-2f3b31eb8789.png#averageHue=%23fdfdfb&clientId=uc4e10333-fa46-4&from=paste&height=118&id=l6LmZ&originHeight=148&originWidth=558&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=85803&status=done&style=none&taskId=u26b947e9-a4c0-4784-a577-deb306f2c70&title=&width=446.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686969685664-eeef0dab-4738-4b24-9d28-90c06a58805a.png#averageHue=%23d7e2ea&clientId=uc4e10333-fa46-4&from=paste&height=385&id=uda59f324&originHeight=481&originWidth=620&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=363901&status=done&style=none&taskId=u388cb9df-5f68-481a-9af3-ffb5c4fddb0&title=&width=496" alt="image.png"></p><h4 id="实验工具："><a href="#实验工具：" class="headerlink" title="实验工具："></a>实验工具：</h4><p>readelf:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686963522932-e3ef3e08-939e-4771-816f-d80cd2834a19.png#averageHue=%23c4cfdc&clientId=uc4e10333-fa46-4&from=paste&height=126&id=u0548e60c&originHeight=158&originWidth=563&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=128707&status=done&style=none&taskId=u4d7241e1-7b19-407f-9510-3c2ee63b094&title=&width=450.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686963538445-98430e88-8e61-4224-8225-d393a0a74d1b.png#averageHue=%23c2d0de&clientId=uc4e10333-fa46-4&from=paste&height=62&id=u35a4b81a&originHeight=78&originWidth=398&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=51885&status=done&style=none&taskId=u9e849582-8e1d-4b34-98f7-ce52858949e&title=&width=318.4" alt="image.png"><br>常用选项：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686963568477-d82ae33c-5a77-4005-ac5a-69dc8a26c8ba.png#averageHue=%23bdcddd&clientId=uc4e10333-fa46-4&from=paste&height=101&id=u517ad99d&originHeight=126&originWidth=575&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=104533&status=done&style=none&taskId=ua3aad22c-58d9-45fc-a66c-8e888ed37d7&title=&width=460" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686963576696-a3f79edd-49c9-4138-823a-c2201f0dfbcc.png#averageHue=%23c0cedd&clientId=uc4e10333-fa46-4&from=paste&height=30&id=u089ce01d&originHeight=38&originWidth=328&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=23314&status=done&style=none&taskId=ua2748a25-ec13-4adf-a02d-96488c3f8e9&title=&width=262.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686963584874-ecde3e89-84cd-45a9-9dc8-84f48b7e1a58.png#averageHue=%23b2c3d5&clientId=uc4e10333-fa46-4&from=paste&height=30&id=u3d0ae0fd&originHeight=37&originWidth=388&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=27019&status=done&style=none&taskId=u770ef882-0f62-4c5d-9cb3-069023f5976&title=&width=310.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686963593816-607feba8-1e1e-4284-ba02-86eaf81ccc8c.png#averageHue=%23b7c7d8&clientId=uc4e10333-fa46-4&from=paste&height=58&id=u957058b4&originHeight=72&originWidth=587&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=73838&status=done&style=none&taskId=uf0237df5-4756-4e2a-b604-f434c90a079&title=&width=469.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686963604836-1b6b3c27-6dd7-4e3a-9d50-0f1b29f1c31b.png#averageHue=%23bbcadb&clientId=uc4e10333-fa46-4&from=paste&height=63&id=u6d23aa6e&originHeight=79&originWidth=568&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=71820&status=done&style=none&taskId=ua6006cfa-bd86-4d25-8837-17c070fc7ae&title=&width=454.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686966141552-513819d7-ca49-49c0-b0bb-cd1eafb7f14d.png#averageHue=%23bac3ce&clientId=uc4e10333-fa46-4&from=paste&height=109&id=u3b7b16fe&originHeight=136&originWidth=610&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=92267&status=done&style=none&taskId=uf52a62c4-192e-4825-8f55-57e4d63e77e&title=&width=488" alt="image.png"></p><h6 id="readelf使用案例："><a href="#readelf使用案例：" class="headerlink" title="readelf使用案例："></a>readelf使用案例：</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686965387849-1852e0e6-26ff-4fc9-a879-43a335abe33f.png#averageHue=%23264484&clientId=uc4e10333-fa46-4&from=paste&height=404&id=u5ad8e7ed&originHeight=505&originWidth=745&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=497497&status=done&style=none&taskId=u907842d3-3fd2-4a63-9faa-1bf77de8d22&title=&width=596" alt="image.png"><br>-S选项打印各个节（节头表）的信息。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686965492269-33efb804-3fd7-41eb-9959-17df8ad9880d.png#averageHue=%232c447f&clientId=uc4e10333-fa46-4&from=paste&height=278&id=ub4e275b0&originHeight=348&originWidth=896&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=419988&status=done&style=none&taskId=u9d9875d1-e2e8-4427-b73f-927117902d6&title=&width=716.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686965590643-3b944c64-fa45-4a6d-b783-4014a195c2cf.png#averageHue=%232a5591&clientId=uc4e10333-fa46-4&from=paste&height=183&id=u505c250a&originHeight=229&originWidth=561&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=203068&status=done&style=none&taskId=ufdbcf981-c1e2-403d-878b-81e066f8601&title=&width=448.8" alt="image.png">Ndx可以对应节头表的Nr确定改符合位于哪个节当中。Bind是访问属性。<br>r选项显示重定位信息：<br>-<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686965807931-205efeed-5c78-4f54-a66f-0a2c410b48ee.png#averageHue=%23244889&clientId=uc4e10333-fa46-4&from=paste&height=290&id=u5872cecf&originHeight=362&originWidth=713&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=372055&status=done&style=none&taskId=ufd71bbdb-b65d-4a22-b8ae-20cd9511fd6&title=&width=570.4" alt="image.png"><br>x选项显示指定模块的指定节内容：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686965913804-39af7a32-7fa6-4d0b-91e0-3aac24865c11.png#averageHue=%232a3c75&clientId=uc4e10333-fa46-4&from=paste&height=123&id=u5f399a7f&originHeight=154&originWidth=885&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=187042&status=done&style=none&taskId=ubf728095-325c-4e55-961d-f0cc90b3686&title=&width=708" alt="image.png">（每一行显示了该节的16字节的内容， 最左边的4字节是指定节的偏移量。最右边是把数据内容中每一字节的值ASCLL码解释出来。</p><h6 id="hexedit工具的使用："><a href="#hexedit工具的使用：" class="headerlink" title="hexedit工具的使用："></a>hexedit工具的使用：</h6><p>使用hexedit main.o后：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686966858303-fcd2711c-987e-4360-86e2-783526e6b4cf.png#averageHue=%231e3b7d&clientId=uc4e10333-fa46-4&from=paste&height=26&id=uaae1d185&originHeight=32&originWidth=351&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=19186&status=done&style=none&taskId=uabe25ac2-4917-409f-b3b6-8a629c7f7f4&title=&width=280.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686966303380-2437867f-8da2-438e-b0b3-6f353b9a8341.png#averageHue=%2333336b&clientId=uc4e10333-fa46-4&from=paste&height=66&id=ua5b69075&originHeight=82&originWidth=1620&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=201082&status=done&style=none&taskId=u4156a27b-56f2-4e6a-9fe3-bae504a5236&title=&width=1296" alt="image.png"><br>左边的4字节是便宜量，中间是显示二进制的内容，最右边是把中间显示的文件内容每一字节可用ascll码的就解释出来，不可的用.代替。<br>光标停留的位置直接输入想修改的的内容。修改结束后用ctrl+x保存修改内容。ctrl+c不保存退出。</p><h4 id="实验过程："><a href="#实验过程：" class="headerlink" title="实验过程："></a>实验过程：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686967094557-3bbe8d8e-3ef1-4dd8-99ec-d929196fd3a7.png#averageHue=%23c6d7e7&clientId=uc4e10333-fa46-4&from=paste&height=206&id=u8ae38124&originHeight=258&originWidth=681&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=194740&status=done&style=none&taskId=u6b45cb5a-0cf2-4a2f-a5d6-77ec7297a72&title=&width=544.8" alt="image.png"></p><h6 id="1-获取phase1-o的汇编代码："><a href="#1-获取phase1-o的汇编代码：" class="headerlink" title="1.获取phase1.o的汇编代码："></a>1.获取phase1.o的汇编代码：</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686967194400-34f571a6-791b-49fd-a2d2-37054d6c0ebb.png#averageHue=%23254e90&clientId=uc4e10333-fa46-4&from=paste&height=364&id=ufe6fcd67&originHeight=455&originWidth=638&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=384506&status=done&style=none&taskId=u4d682674-655d-4952-93a1-989891155d9&title=&width=510.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686967271394-bf1f586e-4129-4c3e-acf1-7c57eccd0df8.png#averageHue=%231e3372&clientId=uc4e10333-fa46-4&from=paste&height=42&id=u8227118e&originHeight=53&originWidth=556&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=47910&status=done&style=none&taskId=uc25f8ae2-0caa-4495-b239-bd737537d16&title=&width=444.8" alt="image.png"></p><h6 id="2-获取phase1-o目标模块中的重定位记录："><a href="#2-获取phase1-o目标模块中的重定位记录：" class="headerlink" title="2.获取phase1.o目标模块中的重定位记录："></a>2.获取phase1.o目标模块中的重定位记录：</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686967368893-d4e96df7-2b44-4fc6-80ac-a6fbe5560216.png#averageHue=%23244a8b&clientId=uc4e10333-fa46-4&from=paste&height=289&id=u36469f66&originHeight=361&originWidth=647&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=346222&status=done&style=none&taskId=ue00f37e0-5b82-4d2c-a320-17738b98617&title=&width=517.6" alt="image.png"></p><h6 id="3-分析phase1-o汇编代码："><a href="#3-分析phase1-o汇编代码：" class="headerlink" title="3.分析phase1.o汇编代码："></a>3.分析phase1.o汇编代码：</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686967507915-ea0f0470-f159-4ce8-b716-dad421892ca1.png#averageHue=%23255395&clientId=uc4e10333-fa46-4&from=paste&height=240&id=u3771f73b&originHeight=300&originWidth=564&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=231222&status=done&style=none&taskId=ua3f1267e-e214-4fea-b66a-20f7133ece4&title=&width=451.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686967522152-5d62ec93-74ff-4a69-bc44-e6f3ec64d68a.png#averageHue=%23cdd5dd&clientId=uc4e10333-fa46-4&from=paste&height=122&id=ucce01470&originHeight=152&originWidth=553&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=132477&status=done&style=none&taskId=u715b96a9-3b80-4b25-9403-ededfa0dee2&title=&width=442.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686967546636-d658d910-9cac-4abf-ac52-b79133de8201.png#averageHue=%23ced6dc&clientId=uc4e10333-fa46-4&from=paste&height=70&id=uceb01c5c&originHeight=88&originWidth=521&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=61723&status=done&style=none&taskId=u76fe9537-af1f-41c8-b2b6-f2bf5ff7889&title=&width=416.8" alt="image.png">（call指令）<br>要确定call指令调用的是哪个函数要结合phase1.o的重定位记录。<br>call常采用的是绝对地址重定位，call后面的10就是偏移量，由于call的重定位信息存在.rel.text中，可以知道call重定位信息为：<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686968194725-631d3370-d420-4a1b-a04e-c6dbff5873ca.png#averageHue=%232274b5&clientId=uc4e10333-fa46-4&from=paste&height=30&id=uddc14596&originHeight=38&originWidth=498&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=33805&status=done&style=none&taskId=u5c46559d-750d-46f7-a0d6-6e82b1183b1&title=&width=398.4" alt="image.png"><br>可以看出puts函数采用的是PC相对地址重定位方式。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686969515575-3d18451f-a99b-4d7f-a001-5abe76d0cec9.png#averageHue=%23fefefd&clientId=uc4e10333-fa46-4&from=paste&height=64&id=u29c5c3f2&originHeight=80&originWidth=544&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=60104&status=done&style=none&taskId=u263ea825-52ad-4661-849f-2907d6ca31e&title=&width=435.2" alt="image.png"></p><h6 id="确定data节在phase节中的位置："><a href="#确定data节在phase节中的位置：" class="headerlink" title="确定data节在phase节中的位置："></a>确定data节在phase节中的位置：</h6><p><strong>获取节头表：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686969626814-13189395-c9fb-4f4e-9c47-0279b88b0c24.png#averageHue=%2327417f&clientId=uc4e10333-fa46-4&from=paste&height=458&id=u3e71663d&originHeight=573&originWidth=871&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=687458&status=done&style=none&taskId=ub25d6553-f0cc-4c11-a1db-9024d022a14&title=&width=696.8" alt="image.png">（可以看出data节的偏移地址是0x60，结合前面重定位的分析输出字符串的地址相对与data节起始地址的偏移量是:0x79;输出字符串的起始地址：0x60+0x79&#x3D;0xd9;</p><h6 id="使用hexedit工具对该位置开始的内容修改："><a href="#使用hexedit工具对该位置开始的内容修改：" class="headerlink" title="使用hexedit工具对该位置开始的内容修改："></a>使用hexedit工具对该位置开始的内容修改：</h6><p><strong>查看data节数据：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686970527139-7a48faca-e22c-4844-964f-d5eaeb57d9aa.png#averageHue=%23253e7c&clientId=uc4e10333-fa46-4&from=paste&height=390&id=u8d296cb8&originHeight=488&originWidth=920&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=691148&status=done&style=none&taskId=u7fe144c2-ffce-42a0-b00e-70b32fb0362&title=&width=736" alt="image.png"><br>对比输出：对比偏向量0x79发现输出没有问题<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686970582112-71a6901d-03f9-4612-aeaa-2c32c18280ba.png#averageHue=%23392b5d&clientId=uc4e10333-fa46-4&from=paste&height=43&id=u92f85869&originHeight=54&originWidth=1335&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=90555&status=done&style=none&taskId=uc56b5e82-94aa-4b21-b1f2-e076c78e631&title=&width=1068" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686970880871-a605dd72-506d-4848-b60a-b2eb5f3e8212.png#averageHue=%23145c99&clientId=uc4e10333-fa46-4&from=paste&height=180&id=uf5db664a&originHeight=225&originWidth=596&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=166566&status=done&style=none&taskId=ub884bf3e-e6ce-400e-977d-7ec1f4f1ff8&title=&width=476.8" alt="image.png">（选中的内容就是输出的字符串，输出的字符串以00接着说一看到0x00就可以判断此处为字符串的结束位置。（0x00对应的字符串不打印）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686971116882-5ce5d8ca-cd0a-4a77-93b2-21c9602fddda.png#averageHue=%23b1b9c2&clientId=uc4e10333-fa46-4&from=paste&height=142&id=u91ef6570&originHeight=177&originWidth=664&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=159280&status=done&style=none&taskId=ubc1c2b46-0895-4e22-beac-037ba6fd603&title=&width=531.2" alt="image.png"><br><strong>修改：data节的起始地址是0x60，其中输出字符串相对于data节的偏移量是0x79,那么输出字节地址为0x60+0x79&#x3D;0xd9;</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686971938781-0c80195c-c759-47a3-9086-36acc2c70e3a.png#averageHue=%233a3368&clientId=uc4e10333-fa46-4&from=paste&height=22&id=u68fa39be&originHeight=27&originWidth=1604&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=63644&status=done&style=none&taskId=uffef29e6-75b7-4220-9956-7c674258743&title=&width=1283.2" alt="image.png">(上图中黄色的部分就是输出字符串的起始地址）从起始位置修改字符串最后以0x00结尾，实现swpu-202131061114的输出；注意修改的ascll码用16进制<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686972365207-6cdaa2d2-a4e4-4a38-8fc7-b2c90421a718.png#averageHue=%23383367&clientId=uc4e10333-fa46-4&from=paste&height=18&id=uebf506d8&originHeight=23&originWidth=1020&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=38128&status=done&style=none&taskId=u8ab764ff-ca4b-4e9b-a5c4-d8e07176f23&title=&width=816" alt="image.png"></p><h6 id="重新链接输出："><a href="#重新链接输出：" class="headerlink" title="重新链接输出："></a>重新链接输出：</h6><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686972449398-73f8327c-f7e5-459b-8332-47687c2792b3.png#averageHue=%231d306f&clientId=uc4e10333-fa46-4&from=paste&height=58&id=ub2ab3260&originHeight=72&originWidth=621&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=65593&status=done&style=none&taskId=ub01c5ffb-c129-45d1-a7ac-2f9b4bce6f1&title=&width=496.8" alt="image.png"></h4><h2 id="指令和ELF代码节："><a href="#指令和ELF代码节：" class="headerlink" title="指令和ELF代码节："></a>指令和ELF代码节：</h2><h4 id="实验内容：-1"><a href="#实验内容：-1" class="headerlink" title="实验内容："></a>实验内容：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686972530930-6ad83bf7-303f-4da0-80d7-cf3ee27ec260.png#averageHue=%23bac2cb&clientId=uc4e10333-fa46-4&from=paste&height=92&id=ue98bc804&originHeight=115&originWidth=666&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=101405&status=done&style=none&taskId=ub413d207-f64e-49fa-a624-d5f5a56288e&title=&width=532.8" alt="image.png"></p><h4 id="实验过程：-1"><a href="#实验过程：-1" class="headerlink" title="实验过程："></a>实验过程：</h4><h6 id="1-获取phase2-o的汇编代码："><a href="#1-获取phase2-o的汇编代码：" class="headerlink" title="1.获取phase2.o的汇编代码："></a>1.获取phase2.o的汇编代码：</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686972709741-88f638e2-5add-4348-84fa-b1a634342bb4.png#averageHue=%23203272&clientId=uc4e10333-fa46-4&from=paste&height=27&id=u0af60c08&originHeight=34&originWidth=500&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=29484&status=done&style=none&taskId=uc31ca229-28e5-4701-8a8c-76b818a9204&title=&width=400" alt="image.png"><br>部分汇编代码：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686972839636-299bb7f8-7747-4a10-8499-2c71a5ddc3d5.png#averageHue=%23faf8f5&clientId=uc4e10333-fa46-4&from=paste&height=275&id=u7cc81f0b&originHeight=344&originWidth=620&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=69186&status=done&style=none&taskId=uba90a079-83b4-4692-99c1-9b693d649ea&title=&width=496" alt="image.png"></p><h6 id="2-获取phase2-o的重定位记录："><a href="#2-获取phase2-o的重定位记录：" class="headerlink" title="2.获取phase2.o的重定位记录："></a>2.获取phase2.o的重定位记录：</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686972932511-be2e6421-53ea-4819-b6c7-ff96d3100421.png#averageHue=%23254a8a&clientId=uc4e10333-fa46-4&from=paste&height=369&id=ud86a8148&originHeight=461&originWidth=664&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=447718&status=done&style=none&taskId=u8882bbe1-83bc-4dc6-888b-308b656d0e9&title=&width=531.2" alt="image.png"></p><h6 id="3-在phase2-o的代码节中中找到类似put的输出函数：（结合call的偏移地址和重定位信息表）"><a href="#3-在phase2-o的代码节中中找到类似put的输出函数：（结合call的偏移地址和重定位信息表）" class="headerlink" title="3.在phase2,o的代码节中中找到类似put的输出函数：（结合call的偏移地址和重定位信息表）"></a>3.在phase2,o的代码节中中找到类似put的输出函数：（结合call的偏移地址和重定位信息表）</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686973752406-351e2992-bec8-4f4f-9144-f6e53fa7c385.png#averageHue=%23313971&clientId=uc4e10333-fa46-4&from=paste&height=26&id=uf3e3e720&originHeight=33&originWidth=554&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=23900&status=done&style=none&taskId=uac5bb9a7-af29-4137-bf86-e8a74e693f1&title=&width=443.2" alt="image.png">（可以看出这个call的偏移量是c4，按照重定位信息发现偏移量c4中是puts函数，也即后面的AFPQyocF处）<br>可以在do_phase中修改nop指令实现对AFPQyocF函数的调用，从而实现对目标字符串的输出。</p><h6 id="4-查找输出函数AFPQyocF在-text节中的的偏移量："><a href="#4-查找输出函数AFPQyocF在-text节中的的偏移量：" class="headerlink" title="4.查找输出函数AFPQyocF在.text节中的的偏移量："></a>4.查找输出函数AFPQyocF在.text节中的的偏移量：</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686974313997-f6af8b1f-72bc-430b-9cdb-93363f2027cb.png#averageHue=%23254787&clientId=uc4e10333-fa46-4&from=paste&height=411&id=ua3e27848&originHeight=514&originWidth=683&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=494374&status=done&style=none&taskId=u311ba29a-dc78-4e53-bd9c-b1823395a86&title=&width=546.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686974444457-062c3ca7-e0ca-481d-9dce-a87a9bab17db.png#averageHue=%23264485&clientId=uc4e10333-fa46-4&from=paste&height=360&id=u2193e9a4&originHeight=450&originWidth=906&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=529318&status=done&style=none&taskId=u24eb26b8-d39a-40b8-8949-f298b286413&title=&width=724.8" alt="image.png">（AFPQy0cF的Ndx为1，在节头表中查找到Nr为1的是.text,所有此函数位于,.text节中）<br>结合上面2图可以得出该函数位于.text节中偏移量为0xa0处。同时该函数<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686974626140-4403af66-7160-4031-b561-44bf7dcc133e.png#averageHue=%23fafefe&clientId=uc4e10333-fa46-4&from=paste&height=23&id=u9a9cb625&originHeight=29&originWidth=225&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=13272&status=done&style=none&taskId=u94148388-1b47-4153-99b1-a8542e6c4d6&title=&width=180" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686974632681-434c43b8-7af7-48cd-9204-1bd4bc2802b7.png#averageHue=%23fafefc&clientId=uc4e10333-fa46-4&from=paste&height=99&id=u9afc03a1&originHeight=124&originWidth=374&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=84949&status=done&style=none&taskId=u1627f454-3c85-4ed7-b47f-7266caccff2&title=&width=299.2" alt="image.png">利用objdump反汇编的汇编代码中函数前也给出了该函数在所在节的偏移量。</p><h6 id="5-构造调用上面函数的指令代码："><a href="#5-构造调用上面函数的指令代码：" class="headerlink" title="5.构造调用上面函数的指令代码："></a>5.构造调用上面函数的指令代码：</h6><p><strong>分析函数执行逻辑：（结合汇编代码和重定位信息表分析）</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686972839636-299bb7f8-7747-4a10-8499-2c71a5ddc3d5.png#averageHue=%23faf8f5&from=url&id=DOOlN&originHeight=344&originWidth=620&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686974918965-e2eed8ed-74a2-4cbd-8668-503d188d210e.png#averageHue=%233868a3&clientId=uc4e10333-fa46-4&from=paste&height=120&id=u016c1f57&originHeight=150&originWidth=555&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=148378&status=done&style=none&taskId=u610a5254-05dc-489b-8551-61290814320&title=&width=444" alt="image.png"><br>该函数先利用strcmp函数比较2个字符串的长度，然后将返回值（相同返回0，不同返回非0）送到eax寄存器中，<br>如果eax的值不为0就执行jne指令，为0就执行puts要输出的参数入栈执行put函数。<br>查看重定位表可以看出strcmp的其中一个参数位于.rodata节中，其相对与.rodata节的偏移地址分别为：0x2;<br>**查找该参数的内容：**<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686975966941-8e7030d4-ae10-45c7-b3ce-3e6b2092b9f5.png#averageHue=%231c3776&clientId=uc4e10333-fa46-4&from=paste&height=95&id=u59c13ff8&originHeight=119&originWidth=606&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=89702&status=done&style=none&taskId=ua5330b9c-cc9a-4e19-ab3f-4ed7c264257&title=&width=484.8" alt="image.png">也即这个参数和第一个参数比较。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686976120706-41044eff-55c9-4444-8ea9-51a92e892a63.png#averageHue=%23f5f2ee&clientId=uc4e10333-fa46-4&from=paste&height=20&id=u190c9936&originHeight=25&originWidth=262&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=6206&status=done&style=none&taskId=u7dc86c42-7d3d-482a-a71d-eb5389e662e&title=&width=209.6" alt="image.png">（是AFP…的第一个参数）分析上面可知：如果要输出学号，那么传递给AFP…的第一关参数是yksPHJa,第二个参数是学号。<br><strong>构造指令代码：</strong><br>sub $0x28,esp<br>mov1 $0x50736b79,-0x10(ebp)<br>mov1 $0x614a48,-0xc(%ebp)<br>mov1 $0x31323032,-0x1a(8ebp)<br>mov1 $0x36303133,-0x16(%ebp)<br>movw $0x34313131,-0x12(%ebp)<br>sub $0x8,esp<br>lea -0x1a(ebp),%eax<br>push %eax<br>lea -0x10(%ebp),%eax<br>push %eax<br>call 0x00<br>add $0x10,%esp<br>nop<br>leave<br>ret<br>将上述代码写入ins.s中并把其编译为可重定位目标文件<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686983659200-5c9750fa-b2a3-402b-98e1-6b82cd6ed5c6.png#averageHue=%233e264d&clientId=uc4e10333-fa46-4&from=paste&height=348&id=u67db4665&originHeight=435&originWidth=450&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=247253&status=done&style=none&taskId=u577376aa-d67d-4904-8163-da02141ac80&title=&width=360" alt="image.png">（注意这里要在头文件出加.code32,统一格式）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686983798722-a365217a-ae40-45d2-a5dc-5852db713ce3.png#averageHue=%23284280&clientId=uc4e10333-fa46-4&from=paste&height=477&id=uf73e905b&originHeight=596&originWidth=781&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=603688&status=done&style=none&taskId=uc80ccdf6-f5aa-427f-ba30-784ab0fc9d2&title=&width=624.8" alt="image.png">（这里的格式是x86-64需要转换格式）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686984287214-a8454f0e-5147-4cae-89dc-0b7450fc0a73.png#averageHue=%231f3271&clientId=uc4e10333-fa46-4&from=paste&height=23&id=u95c12851&originHeight=29&originWidth=564&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=28034&status=done&style=none&taskId=u56152aba-7467-4400-ab58-ffcd1cf8a4e&title=&width=451.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686984336326-b0e70fa6-d6be-487d-beb9-4e6675a14f22.png#averageHue=%231f3170&clientId=uc4e10333-fa46-4&from=paste&height=19&id=ud11bb07c&originHeight=24&originWidth=521&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=22148&status=done&style=none&taskId=u6b78d3b8-547b-4e85-b87f-3a27baa0d4d&title=&width=416.8" alt="image.png"><br>inst.s的汇编内容：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686984375516-826e46d8-2c52-449b-8a39-d4592fbcc710.png#averageHue=%23f9f8f5&clientId=uc4e10333-fa46-4&from=paste&height=341&id=u7f50504c&originHeight=426&originWidth=629&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=71243&status=done&style=none&taskId=u6ed937a3-7526-494a-a32a-b1c3d0089fc&title=&width=503.2" alt="image.png">（中间的指令就是要插入到phase2.o中do_phase函数体中替换nop的内容也就是0x90，）</p><h6 id="6-获取目标模块机器码的插入位置："><a href="#6-获取目标模块机器码的插入位置：" class="headerlink" title="6.获取目标模块机器码的插入位置："></a>6.获取目标模块机器码的插入位置：</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686984628407-4f1c3052-4b65-4ba2-ae16-edfdeb395f2c.png#averageHue=%23f6f862&clientId=uc4e10333-fa46-4&from=paste&height=20&id=u6fca274f&originHeight=25&originWidth=716&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=4100&status=done&style=none&taskId=ub23d2b3b-42ab-4317-bb48-f3d1b78c072&title=&width=572.8" alt="image.png">（.text节在phase.o中的偏移量为0x34)<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686984709207-32653765-09ac-4b6e-b523-5b99bfd96186.png#averageHue=%23fbf9f8&clientId=uc4e10333-fa46-4&from=paste&height=62&id=ufaca7be9&originHeight=77&originWidth=593&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=12422&status=done&style=none&taskId=u08ddca4b-b685-45f6-921f-c37a28e17db&title=&width=474.4" alt="image.png">(首个nop指令在.text节中的偏移量是0xd3)插入机器码在文件中的起始偏移量为：0xd3+0x34&#x3D;0x 107</p><h6 id="7-使用hexedit工具修改："><a href="#7-使用hexedit工具修改：" class="headerlink" title="7.使用hexedit工具修改："></a>7.使用hexedit工具修改：</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686986225404-6193b1b0-6812-4da0-ae57-9b7a32735e69.png#averageHue=%23fcfbf9&clientId=uc4e10333-fa46-4&from=paste&height=310&id=u4b77e35b&originHeight=388&originWidth=571&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=47232&status=done&style=none&taskId=ub69f0c1a-be79-420b-b10b-b08d6b8f653&title=&width=456.8" alt="image.png"><br>注意在填写call指令的二进制的时候其后的二进制要修改使其可以相对pc寻址。修改为：<br>oxa0-(0xd3+0x36)&#x3D;ffffff97<br>修改后的：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686986749458-f8e87b67-cc88-4f10-9f33-4247c05a6ea9.png#averageHue=%23362959&clientId=uc4e10333-fa46-4&from=paste&height=69&id=u3b4e2331&originHeight=86&originWidth=1249&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=143823&status=done&style=none&taskId=ua7a6c623-cc74-49ee-b44d-2f1b1230b80&title=&width=999.2" alt="image.png"></p><h6 id="8-链接编译："><a href="#8-链接编译：" class="headerlink" title="8.链接编译："></a>8.链接编译：</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686987964118-f77dc5fd-98dc-4c01-8eed-9c139deb496e.png#averageHue=%231e4b8b&clientId=uc4e10333-fa46-4&from=paste&height=31&id=u1d6afc55&originHeight=39&originWidth=420&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=28658&status=done&style=none&taskId=uea9b91cb-9dab-4d53-843a-f3db93b58a3&title=&width=336" alt="image.png"></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>test指令：test 是一种汇编指令，它用于对两个操作数进行按位 AND 运算，并设置相应的标志位。test 指令的语法通常为：test dest, src；<br>less查看文件时输入：”&#x2F;‘起到查找的内容。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686973025572-c4ca9e87-1dab-4680-8836-ba444eb3ab31.png#averageHue=%23fdfefb&clientId=uc4e10333-fa46-4&from=paste&height=65&id=u9dff337a&originHeight=81&originWidth=613&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=60693&status=done&style=none&taskId=u6356432d-6b78-428f-aefd-3b65239f937&title=&width=490.4" alt="image.png"></p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686967522152-5d62ec93-74ff-4a69-bc44-e6f3ec64d68a.png?x-oss-process=image/resize,w_552,limit_0#averageHue=%23cdd5dd&from=url&id=ht6Vv&originHeight=152&originWidth=552&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></h2>]]></content>
    
    
    <categories>
      
      <category>课程作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机基础实验四：程序控制结构</title>
    <link href="/2024/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9A%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%EF%BC%9A/"/>
    <url>/2024/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9A%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="传送指令："><a href="#传送指令：" class="headerlink" title="传送指令："></a>传送指令：</h2><h4 id="相关知识点："><a href="#相关知识点：" class="headerlink" title="相关知识点："></a>相关知识点：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686826276173-aad12eb3-4860-4229-8606-c03ded8836ae.png#averageHue=%23c9d0d7&clientId=u8a9bb9ac-3800-4&from=paste&height=135&id=u54e3c267&originHeight=169&originWidth=517&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=91854&status=done&style=none&taskId=u9af0963d-4077-473e-8a19-dab1eeaf944&title=&width=413.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686826291952-77fe05d1-f7e4-4ac1-84ee-256ca9e9c575.png#averageHue=%23d9e2e9&clientId=u8a9bb9ac-3800-4&from=paste&height=274&id=u78f5e13b&originHeight=343&originWidth=857&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=262976&status=done&style=none&taskId=u334321c4-0213-43c9-abb2-187da38d562&title=&width=685.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686826350626-f01f2f26-3420-4e95-ad3b-e3c48d413e6e.png#averageHue=%23d6dfe7&clientId=u8a9bb9ac-3800-4&from=paste&height=275&id=ufa008afc&originHeight=344&originWidth=869&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=333642&status=done&style=none&taskId=u3258ac85-23fc-4328-8252-e651b97143a&title=&width=695.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686826379968-0d65f310-dc6d-4764-89f5-491986655d74.png#averageHue=%23d5dde5&clientId=u8a9bb9ac-3800-4&from=paste&height=310&id=u90b3563d&originHeight=388&originWidth=889&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=385485&status=done&style=none&taskId=ua1456478-84a4-430c-b4ad-e8e3b27ca9f&title=&width=711.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686826417261-62ec62ab-a503-45c9-9f78-4d8cbcdf6180.png#averageHue=%23d3dbe4&clientId=u8a9bb9ac-3800-4&from=paste&height=346&id=uef225de2&originHeight=433&originWidth=979&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=454121&status=done&style=none&taskId=u2dddcd76-8e3c-40bd-9c01-127bb97658a&title=&width=783.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686826437698-34b29510-97e9-4ade-93d4-06e718fe0d07.png#averageHue=%23d1dbe3&clientId=u8a9bb9ac-3800-4&from=paste&height=43&id=ub57d0227&originHeight=54&originWidth=796&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=51475&status=done&style=none&taskId=uaed29bce-fb99-42fc-9f5b-021dd0264ef&title=&width=636.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686826534194-ae76534f-c565-4296-8d49-e00ba610c80f.png#averageHue=%23d9a6ab&clientId=u8a9bb9ac-3800-4&from=paste&height=24&id=u8b0442d7&originHeight=30&originWidth=368&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=15884&status=done&style=none&taskId=u01d3feca-9043-4a90-a76e-c3d8fb44f8c&title=&width=294.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686826540346-c1651286-afe8-41b8-b749-402a06a2beeb.png#averageHue=%23d2d9df&clientId=u8a9bb9ac-3800-4&from=paste&height=90&id=udcfb0f32&originHeight=112&originWidth=524&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=91999&status=done&style=none&taskId=u5e2ed4b5-04eb-402d-a371-6d25986c832&title=&width=419.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686826600704-2a904e13-059b-4a74-b25d-730f4e0ae5b6.png#averageHue=%23d8a6aa&clientId=u8a9bb9ac-3800-4&from=paste&height=23&id=u09bfab47&originHeight=29&originWidth=368&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=17127&status=done&style=none&taskId=u87433f39-93d4-4171-9f28-1bdea83a180&title=&width=294.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686826608206-59c89116-5af8-4d5e-9c15-795ac8708aa5.png#averageHue=%23cfd6dc&clientId=u8a9bb9ac-3800-4&from=paste&height=83&id=u23a00faa&originHeight=104&originWidth=521&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=77419&status=done&style=none&taskId=ua4dedd40-ac9d-4ca4-971f-a409a3a7e3f&title=&width=416.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686826624139-b30654a2-09d6-4872-b945-a53499ae5846.png#averageHue=%23d1d8df&clientId=u8a9bb9ac-3800-4&from=paste&height=87&id=ud0d0c460&originHeight=109&originWidth=518&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=70255&status=done&style=none&taskId=uea51ba98-4561-4cea-9944-cebb3f80e97&title=&width=414.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686827527181-811b4119-a733-428f-830e-53475bd9ccde.png#averageHue=%23fefefc&clientId=u8a9bb9ac-3800-4&from=paste&height=61&id=u9470d0c6&originHeight=76&originWidth=435&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=38535&status=done&style=none&taskId=u0d6001a2-27e9-4cfd-9129-59e5368a704&title=&width=348" alt="image.png"></p><h4 id="测试程序："><a href="#测试程序：" class="headerlink" title="测试程序："></a>测试程序：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686827248759-45f3b7aa-006e-46dc-82df-a1f92b4b05b5.png#averageHue=%23362c5e&clientId=u8a9bb9ac-3800-4&from=paste&height=498&id=u983bf029&originHeight=623&originWidth=733&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=512588&status=done&style=none&taskId=ua80275c1-24fd-43cb-ba7f-d65abb5bcee&title=&width=586.4" alt="image.png"></p><h4 id="编译运行："><a href="#编译运行：" class="headerlink" title="编译运行："></a>编译运行：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686827863575-99efcf6d-359f-4e97-b967-8836128ca7c1.png#averageHue=%231f3d7f&clientId=u8a9bb9ac-3800-4&from=paste&height=209&id=u0578ea13&originHeight=261&originWidth=880&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=308500&status=done&style=none&taskId=u9ddca03b-a90c-4fbf-be7a-bc68b07afe8&title=&width=704" alt="image.png"></p><h4 id="调试："><a href="#调试：" class="headerlink" title="调试："></a>调试：</h4><p>部分反汇编内容：<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686827974564-a9011f48-959a-4076-8874-79d2cf84aaf3.png#averageHue=%23fbf9f8&clientId=u8a9bb9ac-3800-4&from=paste&height=519&id=ua3729a2f&originHeight=649&originWidth=909&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=138477&status=done&style=none&taskId=u1aab8d35-469b-4a2e-98f2-52c19856997&title=&width=727.2" alt="image.png"><br> <img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686829093506-fa101fca-b598-4399-a40e-31c228ac5f64.png#averageHue=%23254486&clientId=u8a9bb9ac-3800-4&from=paste&height=331&id=u90be6474&originHeight=414&originWidth=845&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=458992&status=done&style=none&taskId=uf5a5189d-320e-4435-bd27-d74681c1542&title=&width=676" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686829138779-62d80bb2-b89a-452e-a84e-4987828f4cd8.png#averageHue=%23dad552&clientId=u8a9bb9ac-3800-4&from=paste&height=164&id=ue47a4af3&originHeight=205&originWidth=863&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=191000&status=done&style=none&taskId=u0226e5c3-2b44-4124-9f2e-928adfc9389&title=&width=690.4" alt="image.png"></p><h4 id="lea和mov指令的区别："><a href="#lea和mov指令的区别：" class="headerlink" title="lea和mov指令的区别："></a>lea和mov指令的区别：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686829234184-6a786cad-5f08-4eb0-9b3a-823639454153.png#averageHue=%23dbdbda&clientId=u8a9bb9ac-3800-4&from=paste&height=133&id=ue0ee77df&originHeight=166&originWidth=614&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=83786&status=done&style=none&taskId=u22a4c3cc-637e-4b5f-b943-d7ea3f049a0&title=&width=491.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686829254180-a979294e-00ce-4531-ac2a-12126b8d3e53.png#averageHue=%23e3e3e2&clientId=u8a9bb9ac-3800-4&from=paste&height=236&id=u34734692&originHeight=295&originWidth=415&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=72445&status=done&style=none&taskId=u787ef7b0-33dc-4b67-8cde-cd515b85ffc&title=&width=332" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686829267635-678e3b2e-fc3f-4ee2-8cf8-547c908e9797.png#averageHue=%23e1e3e1&clientId=u8a9bb9ac-3800-4&from=paste&height=284&id=u36731d21&originHeight=355&originWidth=307&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=72709&status=done&style=none&taskId=u4425736f-7068-4fd5-aa62-192b5e9777a&title=&width=245.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686829407947-ad20b247-d0eb-4ff1-a820-8c3849897016.png#averageHue=%23e5e5e4&clientId=u8a9bb9ac-3800-4&from=paste&height=160&id=u70e510ec&originHeight=200&originWidth=530&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=91418&status=done&style=none&taskId=u86943098-6a99-432d-824f-3589d1ce28a&title=&width=424" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686829635832-e057f350-27da-4b88-afab-41ed0e5d5bf9.png#averageHue=%23ceccc8&clientId=u8a9bb9ac-3800-4&from=paste&height=343&id=uf1c96c72&originHeight=429&originWidth=662&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=272923&status=done&style=none&taskId=ua1748053-dc76-47c5-ac6a-2845cdb2c0c&title=&width=529.6" alt="image.png">ix,iz，iy是int,usx是unsigned short,uiy,uiz是unsigned int,sx是short,</p><h2 id="加减运算指令："><a href="#加减运算指令：" class="headerlink" title="加减运算指令："></a>加减运算指令：</h2><h4 id="相关知识点：-1"><a href="#相关知识点：-1" class="headerlink" title="相关知识点："></a>相关知识点：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686830250781-43fc3eaf-df02-4cc3-bac4-b1a0cfca65b0.png#averageHue=%23d6d6d5&clientId=u8a9bb9ac-3800-4&from=paste&height=229&id=u28b5b342&originHeight=286&originWidth=588&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=147955&status=done&style=none&taskId=uef4e1e80-2ff8-45c5-a02b-4aed8b0014c&title=&width=470.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686830414669-cb387aa7-ed9b-4b9b-a358-6a23d32735d9.png#averageHue=%23c6c6c5&clientId=u8a9bb9ac-3800-4&from=paste&height=106&id=u0a197988&originHeight=133&originWidth=508&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=51500&status=done&style=none&taskId=u3d585fa8-02af-4dc2-983d-4fea5649ae7&title=&width=406.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686830452294-7a55bb02-361a-45db-8382-c797e18ae563.png#averageHue=%23d2d9e0&clientId=u8a9bb9ac-3800-4&from=paste&height=271&id=ucea9d949&originHeight=339&originWidth=893&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=357178&status=done&style=none&taskId=u57d26b4e-3d53-484e-b5ea-9ad8c25215c&title=&width=714.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686830476547-7564aa4f-abc5-425e-a4d6-b94c08429e17.png#averageHue=%23c8d1d8&clientId=u8a9bb9ac-3800-4&from=paste&height=86&id=u0a08eeef&originHeight=108&originWidth=927&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=136049&status=done&style=none&taskId=u47ee043a-2099-4ae3-9da7-95ccb10b853&title=&width=741.6" alt="image.png"></p><h2 id="整数乘法指令："><a href="#整数乘法指令：" class="headerlink" title="整数乘法指令："></a>整数乘法指令：</h2><h3 id="相关知识点：-2"><a href="#相关知识点：-2" class="headerlink" title="相关知识点："></a>相关知识点：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686830596768-5cba51b7-6dd7-4308-ac32-7081766df3b1.png#averageHue=%23a0b3ca&clientId=u8a9bb9ac-3800-4&from=paste&height=174&id=uda0a9206&originHeight=218&originWidth=512&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=92073&status=done&style=none&taskId=udaa9664c-c9e4-4ea9-b1e1-84b7d85ec6d&title=&width=409.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686830620124-316527ff-71df-4f07-a6fe-80bb6367e77d.png#averageHue=%23a0b3cb&clientId=u8a9bb9ac-3800-4&from=paste&height=210&id=u546cc873&originHeight=263&originWidth=494&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=148430&status=done&style=none&taskId=u2b537fef-fbca-4558-8c30-59a6159a327&title=&width=395.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686830652011-138ccc68-5299-43ce-8b4f-d2b2d41d8833.png#averageHue=%23d3dce4&clientId=u8a9bb9ac-3800-4&from=paste&height=332&id=u9f5a6fed&originHeight=415&originWidth=1015&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=482812&status=done&style=none&taskId=u77450e82-005a-480e-821b-1a3cac97da1&title=&width=812" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686830702136-66794b5e-9ac8-40ae-97ea-874519f11daf.png#averageHue=%23d3dae0&clientId=u8a9bb9ac-3800-4&from=paste&height=43&id=u985b1338&originHeight=54&originWidth=266&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=22148&status=done&style=none&taskId=u338b86b3-3003-4c53-bfb8-68a80a541ca&title=&width=212.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686830845431-d7423158-4a84-46c9-a6e9-66ba7c625e5d.png#averageHue=%2398b0ca&clientId=u8a9bb9ac-3800-4&from=paste&height=82&id=u522ede4c&originHeight=102&originWidth=566&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=80276&status=done&style=none&taskId=u80744678-dcc2-4848-9b91-2706a8270a3&title=&width=452.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686830896735-b05849c5-1277-420d-82b1-e5a3db370c34.png#averageHue=%23e1d9c7&clientId=u8a9bb9ac-3800-4&from=paste&height=116&id=uaa83f533&originHeight=145&originWidth=576&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=78656&status=done&style=none&taskId=u8ae5cf4e-7226-4d39-88f9-1c2cf5ae4a2&title=&width=460.8" alt="image.png">可以看出在乘法指令中编译器会采用不同的指令实现。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686830978727-cb545a0f-9da9-4048-b51d-6827bfc75551.png#averageHue=%23d7d7d7&clientId=u8a9bb9ac-3800-4&from=paste&height=158&id=u13e3146d&originHeight=198&originWidth=503&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=77175&status=done&style=none&taskId=u274e9cec-f7ec-48eb-8bc3-fc1b0c2f06d&title=&width=402.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686830939218-e69c1205-0b6c-4e9e-b45b-b519c3fe2e38.png#averageHue=%23d9d7d7&clientId=u8a9bb9ac-3800-4&from=paste&height=134&id=u724d821e&originHeight=168&originWidth=532&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=81273&status=done&style=none&taskId=uc388c504-e3c2-428d-b4c9-724c128d7b5&title=&width=425.6" alt="image.png"><br>imul和mul指令只有1个操作数的时候，隐含操作数存在eax中，得到的64为结果：<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686831121701-438925fe-0cc7-492f-b4c7-9c9e0efce3a7.png#averageHue=%239eb4cc&clientId=u8a9bb9ac-3800-4&from=paste&height=48&id=u8ae4c507&originHeight=60&originWidth=419&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=48883&status=done&style=none&taskId=u00812d2c-2150-4dab-98c8-7189f5f76b4&title=&width=335.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686831525388-c601942b-9cf5-42ee-8c9b-45db3fd32b92.png#averageHue=%23cbd3da&clientId=u8a9bb9ac-3800-4&from=paste&height=71&id=u91e34492&originHeight=89&originWidth=734&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=73875&status=done&style=none&taskId=ub5b0c8dd-93b8-40bd-997a-328c03c2d67&title=&width=587.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686831530757-03000676-5171-4486-a43d-ee21025642cd.png#averageHue=%23dae2e8&clientId=u8a9bb9ac-3800-4&from=paste&height=106&id=u15eedddf&originHeight=132&originWidth=1028&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=168671&status=done&style=none&taskId=u590255fb-42ab-4396-ae6c-93734c84aed&title=&width=822.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686831579988-ed340859-8671-4649-bfb6-5a177e55841d.png#averageHue=%23d1d8de&clientId=u8a9bb9ac-3800-4&from=paste&height=45&id=u85960dd7&originHeight=56&originWidth=1010&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=74885&status=done&style=none&taskId=udb159fd8-e0e5-4b14-ab0b-3e381f50cb4&title=&width=808" alt="image.png"><br>如果乘积用eax和edx表示时：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686831600764-2659fe5c-4d1e-4758-ac97-4f927bd05e48.png#averageHue=%23dee6ef&clientId=u8a9bb9ac-3800-4&from=paste&height=45&id=u7aacb8e1&originHeight=56&originWidth=971&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=91806&status=done&style=none&taskId=u84833bbd-56c2-4e6a-84cf-4b5ab148a4b&title=&width=776.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686831690409-ec1b3879-4e53-4bd5-984a-160282d8a50b.png#averageHue=%23cbd3db&clientId=u8a9bb9ac-3800-4&from=paste&height=76&id=ue4a605d6&originHeight=95&originWidth=583&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=63940&status=done&style=none&taskId=uffff2508-7d50-40a8-8df0-55bb0f8e42f&title=&width=466.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686831696917-1b56eb6f-8044-495b-8cd1-7df097a3fb76.png#averageHue=%23cdd4da&clientId=u8a9bb9ac-3800-4&from=paste&height=85&id=uff9d58c6&originHeight=106&originWidth=1045&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=155961&status=done&style=none&taskId=ub1f1d91a-6a22-4bb7-a334-8a73184af02&title=&width=836" alt="image.png"><br>如果乘积用eax和edx表示时：<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686831748288-fa1a0bc2-3c01-46d9-9a49-9c1796645882.png#averageHue=%23e1e9f1&clientId=u8a9bb9ac-3800-4&from=paste&height=52&id=udc6783b2&originHeight=65&originWidth=560&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=51668&status=done&style=none&taskId=uc306dca0-cb1c-41bc-a104-43920bfdf3b&title=&width=448" alt="image.png"></p><h2 id="控制转移指令："><a href="#控制转移指令：" class="headerlink" title="控制转移指令："></a>控制转移指令：</h2><h4 id="相关知识点：-3"><a href="#相关知识点：-3" class="headerlink" title="相关知识点："></a>相关知识点：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686831896705-7755ab1c-df9a-448b-a1af-b532f64a5766.png#averageHue=%23a5b6cc&clientId=u8a9bb9ac-3800-4&from=paste&height=98&id=uda8d8273&originHeight=123&originWidth=445&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=67150&status=done&style=none&taskId=ub9ed2a6f-b197-490c-b0db-2220d58bb54&title=&width=356" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686831915331-7ea4a1ba-6c9b-4ded-a634-7f3c88fe9ccf.png#averageHue=%239fb2ca&clientId=u8a9bb9ac-3800-4&from=paste&height=66&id=u3976babd&originHeight=83&originWidth=442&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=35489&status=done&style=none&taskId=u3651bf76-22dd-4364-929e-20d6e792d27&title=&width=353.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686831959104-79060feb-9cd8-4e96-9bc4-9feb9aa90d55.png#averageHue=%23d3dae0&clientId=u8a9bb9ac-3800-4&from=paste&height=267&id=ud01d08b1&originHeight=334&originWidth=812&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=341861&status=done&style=none&taskId=uc108f384-6b01-432c-9edf-03bb8444eea&title=&width=649.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686832001836-a3cfb4be-08d9-4080-86cf-98b71b61821c.png#averageHue=%23d4dce2&clientId=u8a9bb9ac-3800-4&from=paste&height=288&id=ub2308d35&originHeight=360&originWidth=776&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=307073&status=done&style=none&taskId=u45fcaef7-9a36-42a8-be34-695635b31aa&title=&width=620.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686832038114-8fc61cef-ca15-4339-a618-250ddab6f989.png#averageHue=%23e0e7ee&clientId=u8a9bb9ac-3800-4&from=paste&height=146&id=u7c5d7601&originHeight=183&originWidth=894&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=189003&status=done&style=none&taskId=u1268c12b-d35c-4468-8fc6-a884018808d&title=&width=715.2" alt="image.png"></p><h4 id="测试程序：-1"><a href="#测试程序：-1" class="headerlink" title="测试程序："></a>测试程序：</h4><p>#include “stdio.h” </p><p>int sum(int a[],int n)</p><p> {int i,sum&#x3D;0; </p><p>for(i&#x3D;0;i&lt;n;i++) </p><p>sum+&#x3D;a[i]; </p><p>return sum; </p><p>}</p><p>void main()</p><p>{</p><p>int a[4]&#x3D;{1,2,3,4},n&#x3D;3,x;</p><p> x&#x3D;sum(a,n);</p><p>printf(“sum&#x3D;%d\n”,x); </p><p>}</p><h4 id="编译运行：-1"><a href="#编译运行：-1" class="headerlink" title="编译运行："></a>编译运行：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686833459024-9060685b-3e93-41f2-b72d-dfca23eaeb3e.png#averageHue=%231c3977&clientId=u8a9bb9ac-3800-4&from=paste&height=102&id=u50f3eda8&originHeight=127&originWidth=538&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=104013&status=done&style=none&taskId=u1baf8574-ab4a-4a42-aa1f-5438b52ddf7&title=&width=430.4" alt="image.png"></p><h4 id="调试：-1"><a href="#调试：-1" class="headerlink" title="调试："></a>调试：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686833809064-f4646e7a-8d6c-4f5c-bda7-e23dacff6111.png#averageHue=%231f3170&clientId=u8a9bb9ac-3800-4&from=paste&height=36&id=ud0ecc51e&originHeight=45&originWidth=663&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=48689&status=done&style=none&taskId=u5dc5e0e5-3a49-4e46-8689-c87eca5a2e0&title=&width=530.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686833826322-c85a4891-829d-4ead-a20f-c1d4a4bf9f41.png#averageHue=%23ebc8c8&clientId=u8a9bb9ac-3800-4&from=paste&height=58&id=u28036f61&originHeight=72&originWidth=392&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=35753&status=done&style=none&taskId=uaa3ff4b7-4c5e-493e-94e0-a4d56b52457&title=&width=313.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686833839106-44f603fd-b652-498a-b14a-82f9b000fdf0.png#averageHue=%23f8e0df&clientId=u8a9bb9ac-3800-4&from=paste&height=43&id=ucd485cc0&originHeight=54&originWidth=411&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=32022&status=done&style=none&taskId=u1ecbc741-1bf6-47c3-a593-01ee8e6a4f0&title=&width=328.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686833881225-08c3ecf6-9c9d-4bd6-be5a-5780b4af8db7.png#averageHue=%23f5f3f2&clientId=u8a9bb9ac-3800-4&from=paste&height=27&id=uef6ac566&originHeight=34&originWidth=399&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=22503&status=done&style=none&taskId=ufba37afa-702f-47c2-9b24-dcf86d296f2&title=&width=319.2" alt="image.png"><br>部分反汇编内容：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686833774171-d72da01d-132d-425d-a2a3-225873654aba.png#averageHue=%23fbfaf8&clientId=u8a9bb9ac-3800-4&from=paste&height=467&id=u3a091a8d&originHeight=584&originWidth=785&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=97178&status=done&style=none&taskId=u1e28feba-d33c-4a4d-be38-0ad4accf22f&title=&width=628" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686833783650-e079073a-05f6-40fd-9fca-45905c659fdd.png#averageHue=%23fbf9f7&clientId=u8a9bb9ac-3800-4&from=paste&height=540&id=u6cec5164&originHeight=675&originWidth=848&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=137452&status=done&style=none&taskId=u76a0ffab-994a-4beb-b03a-e8244b51960&title=&width=678.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686834150151-16b2aad8-a484-4f10-9c99-a2c3e1343cb3.png#averageHue=%231d3777&clientId=u8a9bb9ac-3800-4&from=paste&height=99&id=uec575f42&originHeight=124&originWidth=629&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=101094&status=done&style=none&taskId=ube940f45-b606-4b3f-b2e8-cbc1a6b0019&title=&width=503.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686834263249-362d4d85-b94a-4067-8fab-e403ce9e2d11.png#averageHue=%23264181&clientId=u8a9bb9ac-3800-4&from=paste&height=449&id=u5533ef00&originHeight=561&originWidth=843&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=640450&status=done&style=none&taskId=ubd7183ac-9235-4880-ae6c-1653bfdec51&title=&width=674.4" alt="image.png"><br>分析上面的调试发现call指令实现了以下2个功能：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686834328114-42de206c-e80e-4c26-bca6-7b3e172f51ee.png#averageHue=%2371a1dd&clientId=u8a9bb9ac-3800-4&from=paste&height=65&id=ub3331ee2&originHeight=81&originWidth=341&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=20540&status=done&style=none&taskId=u9f562f20-cdb5-442a-b85a-5d23be961b0&title=&width=272.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686834336496-fba10f33-36fa-44b4-a863-5e38615c8645.png#averageHue=%2372930a&clientId=u8a9bb9ac-3800-4&from=paste&height=54&id=u68f39ffb&originHeight=67&originWidth=316&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=17491&status=done&style=none&taskId=ucc062d53-37ce-40fe-88d6-7826cc6af8b&title=&width=252.8" alt="image.png">如果是段间转移还会改变cs寄存器的内容。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686834441129-5bed9a66-53e0-4b04-9062-91609228550a.png#averageHue=%23ccbead&clientId=u8a9bb9ac-3800-4&from=paste&height=13&id=uf1ac24f1&originHeight=16&originWidth=551&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=10088&status=done&style=none&taskId=u27e5c481-9239-4700-af21-aa6022aea1d&title=&width=440.8" alt="image.png">可以看出call指令转移时偏移量是0xffffff72(call指令占2个字节）;<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686834529713-25dbb788-e6eb-4df1-a908-ab4b9451b087.png#averageHue=%236593cd&clientId=u8a9bb9ac-3800-4&from=paste&height=43&id=ud5fdb133&originHeight=54&originWidth=438&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=29361&status=done&style=none&taskId=uc00926b3-5e7e-42bf-a433-c051a6f56cb&title=&width=350.4" alt="image.png"><br>相对寻址的目标地址是pc的内容加偏移量。<br>R[eip]&#x3D;0x804923f+5&#x3D;0x8049244<br>目标转移地址：R[eip]+0xffffff72&#x3D;0x80491b6(这个结果刚好是送入eip的目标转移地址，可以根据上面的调试看出）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686834898082-0e80d748-0bd2-44dd-be82-a08f3c0e6186.png#averageHue=%23f9f7f4&clientId=u8a9bb9ac-3800-4&from=paste&height=54&id=u43a0f763&originHeight=67&originWidth=578&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=11612&status=done&style=none&taskId=uffc43356-d943-4522-8fd2-5082139e32b&title=&width=462.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686835293145-7e636992-78f3-4a0f-92ae-bfbdf11e25d1.png#averageHue=%231e498c&clientId=u8a9bb9ac-3800-4&from=paste&height=200&id=u5bb20277&originHeight=250&originWidth=623&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=209179&status=done&style=none&taskId=ud2fdf56a-40f0-405e-a62c-48192487cdb&title=&width=498.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686835299865-61b03166-38d7-4c51-a164-4b3c26b1c404.png#averageHue=%2372a0da&clientId=u8a9bb9ac-3800-4&from=paste&height=56&id=u541a4b6e&originHeight=70&originWidth=497&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=31950&status=done&style=none&taskId=u2b8bc97d-8a67-4cbe-8d70-f36f2c542c4&title=&width=397.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686835324728-92a2fc53-dcbb-408a-9a00-f721cb7c9af7.png#averageHue=%236796d0&clientId=u8a9bb9ac-3800-4&from=paste&height=43&id=u7e70226a&originHeight=54&originWidth=492&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=30894&status=done&style=none&taskId=u95a1d511-f053-47b3-870a-4f8031d39c1&title=&width=393.6" alt="image.png"><br>R[eip]&#x3D;0x80491ce+2&#x3D;0x80491d0;<br>目标转移地址：R[eip]+0x18&#x3D;0x80491e8;(符合上述调试的eip的值）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686835658113-75e55c6a-87dc-4373-832f-3ad7d5cf8889.png#averageHue=%23f9f6f4&clientId=u8a9bb9ac-3800-4&from=paste&height=82&id=u3eee58e0&originHeight=102&originWidth=625&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=20812&status=done&style=none&taskId=uad35ae84-2a4b-4226-b6df-45f627f65d9&title=&width=500" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686835679963-e6537480-821a-4fa6-954d-ed6c05a34e96.png#averageHue=%236d9edb&clientId=u8a9bb9ac-3800-4&from=paste&height=47&id=u5e3c1df0&originHeight=59&originWidth=497&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=27597&status=done&style=none&taskId=u68e0fd87-f4eb-4936-bee5-f9f02b4db71&title=&width=397.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686835778262-b0c346fb-3ff9-4472-b95a-54aa68a4e03a.png#averageHue=%23254e91&clientId=u8a9bb9ac-3800-4&from=paste&height=307&id=u5cea467c&originHeight=384&originWidth=630&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=322694&status=done&style=none&taskId=ub0a31d26-af94-4dc2-8064-3d286dc0ab7&title=&width=504" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686836107312-d81c00a6-b45f-482e-98f0-d7c4ff0b3297.png#averageHue=%231d3576&clientId=u21d6e0b7-1802-4&from=paste&height=78&id=ud58e25bf&originHeight=98&originWidth=570&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=70929&status=done&style=none&taskId=uc627db1a-4282-46dc-8cdd-13f106e4a01&title=&width=456" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686835881902-7f7b1633-0e5c-46df-acab-adf00e3c5899.png#averageHue=%236390c8&clientId=u21d6e0b7-1802-4&from=paste&height=66&id=u4c90acca&originHeight=83&originWidth=503&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=59558&status=done&style=none&taskId=u671148c4-714e-4949-b5f6-37586cb5d8f&title=&width=402.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686836250307-e93ea7d5-041d-46f2-be94-fab3f4924a22.png#averageHue=%23cecece&clientId=u36a04572-862d-4&from=paste&height=75&id=u8bea86f0&originHeight=94&originWidth=539&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=48634&status=done&style=none&taskId=ufcb3a2a7-0e30-4e92-ae2c-59f49bf64b6&title=&width=431.2" alt="image.png"><br>eflags&#x3D;0x293,CF(1),zf(6),sf(7),of(11)满足jl转移条件。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686836547563-5fb5f142-0154-4e28-9422-f8cde13c6e0f.png#averageHue=%23fbf9f7&clientId=u36a04572-862d-4&from=paste&height=30&id=ue3d53e18&originHeight=37&originWidth=440&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=3572&status=done&style=none&taskId=u19c9c73a-f3bf-4b2b-a62a-bf3c1395e6c&title=&width=352" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686836695968-4d076002-3573-4fc1-84ca-c11b1ce3ec4f.png#averageHue=%231c3879&clientId=u36a04572-862d-4&from=paste&height=112&id=ub256286c&originHeight=140&originWidth=619&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=112129&status=done&style=none&taskId=u09ee2f18-3184-4ab9-b16f-13c0fa4e14c&title=&width=495.2" alt="image.png">这里的si已经调试到断点为ret指令了。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686836748251-6805e9c5-8541-4d5a-9e88-0dd8e343d4ce.png#averageHue=%231c3d7d&clientId=u36a04572-862d-4&from=paste&height=134&id=u4ec25cbc&originHeight=167&originWidth=577&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=132733&status=done&style=none&taskId=u49cddcf7-c779-4c4b-aeb8-09ca1625929&title=&width=461.6" alt="image.png">这里是已经执行了ret指令<br>可以看出这里的eip的值发生的变化值为call指令的下一条指令的地址<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686836810615-8badaf10-b3ca-4f36-bbaf-95a8b3ee1e2f.png#averageHue=%23f6f4f2&clientId=u36a04572-862d-4&from=paste&height=35&id=u1830ec1b&originHeight=44&originWidth=572&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=21602&status=done&style=none&taskId=uf1c2699b-c7e1-4736-a560-9df94f2acab&title=&width=457.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686836827256-a625dca1-b29c-43d5-9274-a720b2d71808.png#averageHue=%23618cc3&clientId=u36a04572-862d-4&from=paste&height=60&id=ua698cbe5&originHeight=75&originWidth=419&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=49607&status=done&style=none&taskId=u41bff3c8-26a7-4187-a92a-da15fc13267&title=&width=335.2" alt="image.png"></p><h2 id="栈和过程调用："><a href="#栈和过程调用：" class="headerlink" title="栈和过程调用："></a>栈和过程调用：</h2><h4 id="相关知识："><a href="#相关知识：" class="headerlink" title="相关知识："></a>相关知识：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686837499868-7d62ae5f-60ea-42f3-8f6d-5bafcf4dcc63.png#averageHue=%23d8e0e7&clientId=u36a04572-862d-4&from=paste&height=346&id=u41626404&originHeight=432&originWidth=615&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=300746&status=done&style=none&taskId=uf05cb647-2ad1-4530-99f6-0e3af4ccafc&title=&width=492" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686837510350-06c16436-8166-41eb-a0d8-2db1ee33fe2a.png#averageHue=%23cdd5dc&clientId=u36a04572-862d-4&from=paste&height=448&id=uc313e043&originHeight=560&originWidth=427&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=277611&status=done&style=none&taskId=u9b4974c4-d379-4fab-854d-b6b0d9c47d1&title=&width=341.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686838068118-3eddd728-d548-4384-ae19-9b602ddb8dec.png#averageHue=%23d0d8df&clientId=u36a04572-862d-4&from=paste&height=140&id=u982ea01c&originHeight=175&originWidth=402&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=86826&status=done&style=none&taskId=u78cf6b6a-8dfa-4d9f-b988-a5b5e3a50f6&title=&width=321.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686838013670-ca80b71d-2a55-45f7-8e12-8dd586ccfb1a.png#averageHue=%23c7d4de&clientId=u36a04572-862d-4&from=paste&height=461&id=u1bffe933&originHeight=576&originWidth=1140&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=690449&status=done&style=none&taskId=u5dd93810-c54a-4244-9abd-1d092e8ff10&title=&width=912" alt="image.png"></p><h4 id="测试程序：-2"><a href="#测试程序：-2" class="headerlink" title="测试程序："></a>测试程序：</h4><p>#include &lt;stdio.h&gt;<br>int swap (int <em>x, int</em>y)<br> {<br>int t&#x3D;*x;<br>*x&#x3D;*y;<br>*y&#x3D;t;<br>}<br>void main()<br> {<br>int a&#x3D;15,b&#x3D;22; swap(&amp;a,&amp;b);<br>rintf(“a&#x3D;%d\tb&#x3D;%d\n”,a,b);<br>}</p><h4 id="编译运行：-2"><a href="#编译运行：-2" class="headerlink" title="编译运行："></a>编译运行：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686840985154-c309a319-56f3-4f34-9cf2-15fbebe7cdb2.png#averageHue=%231d3372&clientId=u2fdd0915-c1a2-4&from=paste&height=81&id=uf204671a&originHeight=101&originWidth=667&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=94531&status=done&style=none&taskId=u1c03763d-bfff-4fa6-9da9-4fde58fe388&title=&width=533.6" alt="image.png"></p><h4 id="调试：-2"><a href="#调试：-2" class="headerlink" title="调试："></a>调试：</h4><p>部分反汇编内容：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686841111043-f57aa07d-2606-4bf9-b883-e2c88cdad4c7.png#averageHue=%23fcfaf9&clientId=u2fdd0915-c1a2-4&from=paste&height=412&id=uef19953c&originHeight=515&originWidth=746&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=77203&status=done&style=none&taskId=u5279dd0e-3bac-40b7-a2bb-14b9e771b29&title=&width=596.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686841116058-b447e881-d353-444d-a404-5bf2227b8244.png#averageHue=%23f9f8f5&clientId=u2fdd0915-c1a2-4&from=paste&height=171&id=u8752477a&originHeight=214&originWidth=856&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=42857&status=done&style=none&taskId=u889dfff2-00a0-4fe5-93c7-f1e014053e9&title=&width=684.8" alt="image.png"><br>解析：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686841310466-e64f868c-ac97-42ef-831e-91829ed92e61.png#averageHue=%23fbfaf8&clientId=u2fdd0915-c1a2-4&from=paste&height=26&id=u0c41e3f9&originHeight=32&originWidth=603&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=4409&status=done&style=none&taskId=u0447bf35-efdf-4eeb-b940-5cd7d00798c&title=&width=482.4" alt="image.png">这里指令是回收swap栈空间，是过程调用的结束工作的标志。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686841415297-6cadf712-101b-426f-b71d-536f9827af81.png#averageHue=%23faf8f7&clientId=u2fdd0915-c1a2-4&from=paste&height=20&id=u37f746ad&originHeight=25&originWidth=509&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=3793&status=done&style=none&taskId=u336f388c-de8e-4318-a13d-9e491c52eb4&title=&width=407.2" alt="image.png">保存调用者的edp值；<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686841448100-a6deb8d1-8105-4750-8195-8b3577b9cb4c.png#averageHue=%23f9f6f3&clientId=u2fdd0915-c1a2-4&from=paste&height=15&id=ue4eeca10&originHeight=19&originWidth=519&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=3712&status=done&style=none&taskId=u8e73efcd-bdeb-44d3-b2eb-beb6d007508&title=&width=415.2" alt="image.png">建立自己的栈空间<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686841496720-cd41ea4b-2aab-4af8-bcdc-2bdf303556fc.png#averageHue=%23faf9f7&clientId=u2fdd0915-c1a2-4&from=paste&height=23&id=u3927ce72&originHeight=29&originWidth=577&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=4528&status=done&style=none&taskId=uc536eac5-b707-40f8-854d-78b5b66af83&title=&width=461.6" alt="image.png">为自己的非静态局部变量分配空间（没有寄存器保存也没有调用其他过程）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686841569629-fbfbacc3-5d3c-47b5-8e0d-d36a0376945f.png#averageHue=%23faf8f5&clientId=u2fdd0915-c1a2-4&from=paste&height=14&id=u727f56d4&originHeight=18&originWidth=441&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=3033&status=done&style=none&taskId=u5be7da58-4f06-4df5-b019-69cf19e58f4&title=&width=352.8" alt="image.png">用leave指令回收栈空间<br>ret指令返回调用者。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686841720354-9744305a-7238-4e9f-a22c-41748aadf58e.png#averageHue=%231d3979&clientId=u2fdd0915-c1a2-4&from=paste&height=108&id=uebd16c2a&originHeight=135&originWidth=598&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=104111&status=done&style=none&taskId=u764569c3-15d6-41a5-ac07-93080010cf0&title=&width=478.4" alt="image.png">调试程序断点为swap(&amp;a,&amp;b)处，这里的eip的值是swap的地址，表示已经使用了call指令<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686844612906-058ff451-6fe5-4167-b63e-6e0cd0b52142.png#averageHue=%23254789&clientId=u2fdd0915-c1a2-4&from=paste&height=309&id=ufa48e7ef&originHeight=386&originWidth=760&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=393718&status=done&style=none&taskId=ue9f59cdc-08a0-4ad6-bb59-af0a3cdfca4&title=&width=608" alt="image.png">显示当前的栈帧内容<br>画出栈：<br> <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1686881443299-fd9041eb-5e8e-4052-93c1-599aee4a6476.jpeg#averageHue=%23bfb8ae&clientId=u2fdd0915-c1a2-4&from=paste&height=382&id=ua0839af3&originHeight=784&originWidth=806&originalType=binary&ratio=1.25&rotation=90&showTitle=false&size=35773&status=done&style=none&taskId=u88ff4f02-1c51-40a1-b799-88e093adbe1&title=&width=393" alt="qq_pic_merged_1686881431385.jpg">0x14是16进制是4的倍数。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686881982802-14de8ef5-8a64-4fe6-9244-0ad73d3f93fb.png#averageHue=%231c3474&clientId=u2fdd0915-c1a2-4&from=paste&height=98&id=u53016250&originHeight=122&originWidth=698&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=105543&status=done&style=none&taskId=u14e3dfd7-8b81-404b-9557-081a5a612e3&title=&width=558.4" alt="image.png">这里的断点是call指令，因为没有执行call指令，所有esp比上面的main栈空间多一个多出的是参数<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686882270558-30c056d1-8710-4a6b-b48c-52ef8bfed204.png#averageHue=%231e3678&clientId=u2fdd0915-c1a2-4&from=paste&height=55&id=uf0f024d3&originHeight=69&originWidth=516&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=51068&status=done&style=none&taskId=u8d9beeef-cfe7-4720-a3fd-96c19757e35&title=&width=412.8" alt="image.png">这里是运行了call指令,多出的是返回地址<br>显示当前栈帧内容：（包括返回地址了）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686882803895-d5e5da86-9410-44b2-a8f0-ee62fe1e8fd9.png#averageHue=%231c3271&clientId=u2fdd0915-c1a2-4&from=paste&height=76&id=u75ce1967&originHeight=95&originWidth=710&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=93874&status=done&style=none&taskId=ub6c24b24-1efd-4d91-bc7c-334d8b8528a&title=&width=568" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686883050317-5f7de4e2-2a4e-4b4a-acc4-014f6e81b13e.png#averageHue=%231b4082&clientId=u2fdd0915-c1a2-4&from=paste&height=46&id=ue2edcc67&originHeight=58&originWidth=388&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=27154&status=done&style=none&taskId=ua8b9845c-0432-4d1d-a421-6607f6e2f19&title=&width=310.4" alt="image.png">（调试让断点停留在int t &#x3D; *x;处，此时swap已经分配了栈空间）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686883218841-5b6114d0-8790-4674-837d-ca9e0ea96d9b.png#averageHue=%231c3675&clientId=u2fdd0915-c1a2-4&from=paste&height=111&id=uc4369364&originHeight=139&originWidth=686&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=125052&status=done&style=none&taskId=u5b2db10d-1d33-4144-8396-7cef3e35326&title=&width=548.8" alt="image.png">（可以看出swap栈空间为0x10符合<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686883245619-6f863840-2a0b-4bf6-8638-dca7cf48190a.png#averageHue=%23f8f6f3&clientId=u2fdd0915-c1a2-4&from=paste&height=17&id=u39d25515&originHeight=21&originWidth=525&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=4149&status=done&style=none&taskId=ufcc52e88-7804-4e2f-82a6-58a1376c573&title=&width=420" alt="image.png">这条语句，此时的栈顶为0xffffd458是main栈的ebp地址，是在swap栈中）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686883428348-46ac94f4-13ab-4880-b022-83d4a5e1350a.png#averageHue=%231c3271&clientId=u2fdd0915-c1a2-4&from=paste&height=98&id=u2090e8ac&originHeight=123&originWidth=752&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=132274&status=done&style=none&taskId=u41267527-f48d-4497-877a-49e779c5692&title=&width=601.6" alt="image.png">（这里显示的是swap栈和main栈的部分内容可以看出main栈和swap栈是连续的内存空间）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686883632109-68c617c9-9d04-4d60-9507-5b96bba20668.png#averageHue=%231d397c&clientId=u2fdd0915-c1a2-4&from=paste&height=62&id=u581d2ed9&originHeight=77&originWidth=381&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=39688&status=done&style=none&taskId=ubf9db584-47eb-478c-a216-49acc2673d8&title=&width=304.8" alt="image.png">（这里的断点已经执行了leave指令）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686883714806-3e59c0cb-b4f3-4ddd-9bed-1b98b0c528cd.png#averageHue=%231d387a&clientId=u2fdd0915-c1a2-4&from=paste&height=61&id=uffd40d82&originHeight=76&originWidth=444&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=49233&status=done&style=none&taskId=u62bc7e5f-22e1-416a-b1c6-532b02246a1&title=&width=355.2" alt="image.png">这里的esp是main栈的返回栈顶，内容是返回地址，ebp是main栈的ebp，可以看出leave指令是回收swap栈的空间）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686883860450-9a421ca5-7cfe-4cec-842c-9def8f299d28.png#averageHue=%231d3a7a&clientId=u2fdd0915-c1a2-4&from=paste&height=119&id=u80c6108e&originHeight=149&originWidth=605&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=119279&status=done&style=none&taskId=uc2333a64-2012-45ae-9a13-3480976f705&title=&width=484" alt="image.png">（这里已经调试到刚刚执行ret指令，可以看出esp的值比原main栈少了一个，可以看出是返回地址pop了，eip的值是返回地址，可以看出ret指令让返回地址pop到eip中了）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686884055820-19c0b6fb-6c8b-462f-a0b0-2d9161ee6403.png#averageHue=%23f9f6f4&clientId=u2fdd0915-c1a2-4&from=paste&height=22&id=u49ed1d53&originHeight=28&originWidth=533&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=5236&status=done&style=none&taskId=u18d75be0-686d-4b70-b7a4-5346b606cf5&title=&width=426.4" alt="image.png">（这是main函数中call指令的下一条指令，是一个加法指令，此时main栈中的esp指向的是swap函数的入口参数，这里的加法指令作用是回收了入口参数的存储地址，main的栈空间返回到了swap调用前的状态，当然其中的a,b值已经交换过）</p><h4 id="测试程序2：（修改swap中的参数，变成按值传递）"><a href="#测试程序2：（修改swap中的参数，变成按值传递）" class="headerlink" title="测试程序2：（修改swap中的参数，变成按值传递）"></a>测试程序2：（修改swap中的参数，变成按值传递）</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686885418184-64ff1032-b121-4397-bb01-76b0a2f1d619.png#averageHue=%23392855&clientId=u2fdd0915-c1a2-4&from=paste&height=456&id=ub0d0e819&originHeight=570&originWidth=575&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=350120&status=done&style=none&taskId=u22adc310-4fa5-4537-b164-20136449f3c&title=&width=460" alt="image.png"></p><h4 id="编译运行：-3"><a href="#编译运行：-3" class="headerlink" title="编译运行："></a>编译运行：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686885451893-ac0da8c9-0883-410f-9356-3612da6f05c7.png#averageHue=%231d3473&clientId=u2fdd0915-c1a2-4&from=paste&height=101&id=u21527fff&originHeight=126&originWidth=714&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=125110&status=done&style=none&taskId=u36df87e8-2556-4f68-8e1f-d8d9d9071b2&title=&width=571.2" alt="image.png"></p><h4 id="调试：-3"><a href="#调试：-3" class="headerlink" title="调试："></a>调试：</h4><p>部分反汇编内容：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686885748224-d19f995e-de14-4359-95be-165b21fd446c.png#averageHue=%23fcfbfa&clientId=u2fdd0915-c1a2-4&from=paste&height=353&id=u17b0516f&originHeight=441&originWidth=829&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=62275&status=done&style=none&taskId=uec753e45-22a4-4b7b-8dcd-e3e6ff7959f&title=&width=663.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686885755497-8c55ed1c-0ce0-44b0-b009-8eccd6c2bfc2.png#averageHue=%23fbf9f7&clientId=u2fdd0915-c1a2-4&from=paste&height=278&id=u9b2079d4&originHeight=347&originWidth=788&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=66267&status=done&style=none&taskId=ufdbe3572-ec1c-49a5-8ef7-a5f180968a8&title=&width=630.4" alt="image.png"><br>对比按地址传递方式的汇编：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686886011699-8a8b9fd2-0617-448c-a267-7b6fa33e25f6.png#averageHue=%23fbf8f6&clientId=u2fdd0915-c1a2-4&from=paste&height=228&id=u2256bef4&originHeight=285&originWidth=591&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=46841&status=done&style=none&taskId=u5db97c27-322d-4301-bf49-00715a7ecef&title=&width=472.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686885827996-300821aa-db17-4cb8-95a7-3c2663fcda94.png#averageHue=%23f5f3f0&clientId=u2fdd0915-c1a2-4&from=paste&height=74&id=u696a5322&originHeight=92&originWidth=650&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=20445&status=done&style=none&taskId=uf7812991-81b9-494c-93fc-c88fe89cb1e&title=&width=520" alt="image.png">（按地址传送）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686886032102-b6d343a3-cf1d-4af6-8b66-5f45330f17f7.png#averageHue=%23fbf9f8&clientId=u2fdd0915-c1a2-4&from=paste&height=180&id=uea53f3b2&originHeight=225&originWidth=624&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=33215&status=done&style=none&taskId=u71a1ec6e-3f9c-4106-8615-0bcddeb5419&title=&width=499.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686885844696-d59f58ef-2e0e-4700-a4c6-e4a5d9dd50f9.png#averageHue=%23f7f4f0&clientId=u2fdd0915-c1a2-4&from=paste&height=42&id=u662fc6a2&originHeight=53&originWidth=583&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=13176&status=done&style=none&taskId=u579d8250-a53f-4f65-b5ea-cbd4601529b&title=&width=466.4" alt="image.png">（按值传送）<br>对比2中不同的传递可以看出传递参数和过程体的内容的指令有区别。<br>按地址传送<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686885985479-eefaea1c-731e-4146-a8e7-225c3f2866c1.png#averageHue=%23549dc2&clientId=u2fdd0915-c1a2-4&from=paste&height=44&id=u3c83da69&originHeight=55&originWidth=454&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=51438&status=done&style=none&taskId=ube8a3b57-6440-448c-9352-0ab53b2e14d&title=&width=363.2" alt="image.png"><br>按值传送：<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686886043880-fecd5556-84d3-47c6-b56f-5a29b1484cfd.png#averageHue=%23509bc0&clientId=u2fdd0915-c1a2-4&from=paste&height=49&id=uc5420e7e&originHeight=61&originWidth=457&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=53461&status=done&style=none&taskId=u94a3719c-89df-45ce-805d-2d09595549f&title=&width=365.6" alt="image.png"></p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686886101976-d084a994-9b2e-4160-adfb-cd2727da6da6.png#averageHue=%23c8c8c6&clientId=u2fdd0915-c1a2-4&from=paste&height=181&id=u08a756a4&originHeight=226&originWidth=559&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=106057&status=done&style=none&taskId=uf1de069b-e5da-4d45-9224-16eb8b68be1&title=&width=447.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686886121627-77f44fe8-ac0b-4098-9973-a03b1afb3e72.png#averageHue=%23bfbfbd&clientId=u2fdd0915-c1a2-4&from=paste&height=221&id=ua35ffe7d&originHeight=276&originWidth=591&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=132215&status=done&style=none&taskId=uf6cade34-fe90-4af2-8aca-144fe75acc1&title=&width=472.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686886141096-a8634036-fbe4-4ca5-bc22-703934b9ca15.png#averageHue=%23c0c0c0&clientId=u2fdd0915-c1a2-4&from=paste&height=84&id=ud24c3c36&originHeight=105&originWidth=567&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=39661&status=done&style=none&taskId=ud48ff2de-cd47-433f-8c15-2e19d88cf41&title=&width=453.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686886151420-d85aabc7-b65a-47c9-9bea-b5308c24e9ba.png#averageHue=%23cacbc9&clientId=u2fdd0915-c1a2-4&from=paste&height=115&id=u5960472a&originHeight=144&originWidth=515&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=65545&status=done&style=none&taskId=ua5dfc9f0-928b-4904-bf79-a962e3be3f0&title=&width=412" alt="image.png"></p><h2 id="缓冲区溢出："><a href="#缓冲区溢出：" class="headerlink" title="缓冲区溢出："></a>缓冲区溢出：</h2><h4 id="测试程序a："><a href="#测试程序a：" class="headerlink" title="测试程序a："></a>测试程序a：</h4><p>#include “stdio.h”<br>#include “string.h”<br>char code[]&#x3D;<br>“0123456789abcdef’;<br>int main()<br>{<br>char *arg[3];<br>arg[0]&#x3D;”.&#x2F;b”;<br>arg[1]&#x3D;code;<br>arg[2]&#x3D;NULL;<br>execve(arg[0],arg,NULL);<br>return 0;<br>}</p><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><p>测试程序b：这个程序存在缓冲区溢出漏洞<br>#include “stdio.h”</p><p>#include “string.h”</p><p> void outputs(char *str) </p><p>{</p><p>char buffer[16]; &#x2F;&#x2F;系统对bufff的写入str字符串没有进行越界检查，可能会覆盖返回地址</p><p>strcpy(buffer,str); </p><p>printf(“%s\n”,buffer);<br> }</p><p>void hacker(void)</p><p>{</p><p>printf(“being hacked\n”);</p><p>}</p><p> int main(int argc,char *argv[]) </p><p>{</p><p>outputs(argv[1]);</p><p>printf(“yes\n”);</p><p> return 0;</p><p>}</p><h4 id="编译运行程序："><a href="#编译运行程序：" class="headerlink" title="编译运行程序："></a>编译运行程序：</h4><p>系统为了防范缓冲区溢出漏洞，设置了栈地址空间的随机分配。<br>要实现上面的漏洞，要先关闭系统栈的随机分配<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686890492381-dc94ac22-754d-4dbb-bc41-e462e06ab92b.png#averageHue=%231f2f6f&clientId=u2fdd0915-c1a2-4&from=paste&height=35&id=u94cc8b93&originHeight=44&originWidth=705&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=48752&status=done&style=none&taskId=u6cad27ec-03bb-41ed-9179-a981363363b&title=&width=564" alt="image.png">（这条命令关闭系统栈的随机分配）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686890765935-1d4a4146-db6d-4818-8114-ed8958603e1d.png#averageHue=%23203a7b&clientId=u2fdd0915-c1a2-4&from=paste&height=205&id=u402c5ad1&originHeight=256&originWidth=1014&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=361223&status=done&style=none&taskId=uca3b3e91-17c1-4002-9243-c273824b09a&title=&width=811.2" alt="image.png">（-fno-stack-protector -z execstack 多加的选项是目的是<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686890798134-7282b540-26d9-42be-adc3-216fee0cd5f4.png#averageHue=%23eef1e8&clientId=u2fdd0915-c1a2-4&from=paste&height=37&id=u4d42892f&originHeight=46&originWidth=326&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=13281&status=done&style=none&taskId=ucfd9e1f8-5730-4fe6-9f67-95064632c1b&title=&width=260.8" alt="image.png">）</p><h4 id="调试程序实现缓冲区溢出攻击："><a href="#调试程序实现缓冲区溢出攻击：" class="headerlink" title="调试程序实现缓冲区溢出攻击："></a>调试程序实现缓冲区溢出攻击：</h4><p>a的部分反汇编内容：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686891020076-a3b39667-8dca-4fe1-bfdc-73ad5221c0d8.png#averageHue=%23fbf9f7&clientId=u2fdd0915-c1a2-4&from=paste&height=494&id=u16a4851e&originHeight=617&originWidth=759&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=110940&status=done&style=none&taskId=ub945e1a2-2f44-40b7-b065-8250c43e61e&title=&width=607.2" alt="image.png"><br>b的部分反汇编内容：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686891034999-05b876df-74b5-4c41-ade3-501fc1611dc2.png#averageHue=%23fcfaf9&clientId=u2fdd0915-c1a2-4&from=paste&height=334&id=u21a86cbd&originHeight=417&originWidth=783&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=63973&status=done&style=none&taskId=u125ab2b3-e9aa-45de-a482-9280727ce0f&title=&width=626.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686891512567-62469488-8078-4277-9ca3-f3380023ad50.png#averageHue=%23f9f7f4&clientId=u2fdd0915-c1a2-4&from=paste&height=84&id=u78094252&originHeight=105&originWidth=644&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=20290&status=done&style=none&taskId=u0d0c3e77-7016-4177-b46f-6801949df68&title=&width=515.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686891040837-1b99363b-31d2-43eb-bad1-c5259e1b0866.png#averageHue=%23fbfaf8&clientId=u2fdd0915-c1a2-4&from=paste&height=294&id=ua70ad536&originHeight=367&originWidth=619&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=48005&status=done&style=none&taskId=u0c57b28b-f62d-4a96-8513-6a87f839d26&title=&width=495.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686891046561-919fb184-7d6b-4781-9ac0-a6c623274e71.png#averageHue=%23fbf9f8&clientId=u2fdd0915-c1a2-4&from=paste&height=361&id=uf9103544&originHeight=451&originWidth=757&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=77472&status=done&style=none&taskId=u08240c19-72ae-43c0-9682-583706b4678&title=&width=605.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686891946662-ab0df1ab-4960-480c-8339-82ebc757c1a4.png#averageHue=%231d3f81&clientId=u2fdd0915-c1a2-4&from=paste&height=162&id=u7b28737b&originHeight=202&originWidth=711&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=188427&status=done&style=none&taskId=uec9f8fd0-5a40-435a-9afb-bebb4233c6e&title=&width=568.8" alt="image.png">(设置断点为main（包括a的main和b的main,调试到b的main处，显示的eip是outputs(argv[1]的第一条指令的地址，这里的esp，ebp是b中main过程的栈帧空间,程序下一条要执行的语句是outputs说明main函数的栈空间分配指令已经执行完成了，但是这里的main栈没有outputs过程的参数和返回地址，还有一些必要的寄存器保存的值）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686892139366-216398aa-a229-4791-9eb3-d748a214b7c8.png#averageHue=%232c3e76&clientId=u2fdd0915-c1a2-4&from=paste&height=169&id=ua9a68ec0&originHeight=211&originWidth=624&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=167804&status=done&style=none&taskId=ub62b32cf-ab02-40b7-a539-69c84caf318&title=&width=499.2" alt="image.png">（程序停留在printf函数处，字符串复制函数执行完成。此时显示的栈空间是outputs过程的栈空间(不带参数和返回地址），）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686892954571-489fe000-f1dc-4007-b95d-4b76ef2d6e5a.png#averageHue=%231c3271&clientId=u2fdd0915-c1a2-4&from=paste&height=98&id=u102f3550&originHeight=123&originWidth=756&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=133809&status=done&style=none&taskId=ub5c335bb-3993-43dc-904f-a687999dcc2&title=&width=604.8" alt="image.png">（显示的是mian和outputs的栈帧结构这里的15的由来：(output的esp的值-main的ebp的值+4)&#x2F;4,因为main函数调用output中保存的寄存器和参数等信息不确定）</p><h4 id="修改a中的code指令实现hacker："><a href="#修改a中的code指令实现hacker：" class="headerlink" title="修改a中的code指令实现hacker："></a>修改a中的code指令实现hacker：</h4><p>char code[]&#x3D;<br>“0123456789abcdef’&#x2F;&#x2F;buffer不越界的字节内容<br>“abcdabcd”&#x2F;&#x2F;buffer与ebp旧值之间需填充的内容<br>“\x48\xde\xff\xff”&#x2F;&#x2F;b的main的ebp值<br>“\xe4\x91\x04\x08”;&#x2F;&#x2F;hacker的首地址 </p><h4 id="重写编译a1程序："><a href="#重写编译a1程序：" class="headerlink" title="重写编译a1程序："></a>重写编译a1程序：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686895534209-31665677-3a3c-4e76-8322-4a90f9cedcdb.png#averageHue=%232b3b73&clientId=u2fdd0915-c1a2-4&from=paste&height=113&id=ua86a8cde&originHeight=141&originWidth=941&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=172879&status=done&style=none&taskId=u6d3b81df-59ea-46ad-8e57-db526c168a0&title=&width=752.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686895521459-ab23c4e3-15ec-4eb4-865a-5cef32905f15.png#averageHue=%231c3b7c&clientId=u2fdd0915-c1a2-4&from=paste&height=123&id=u15500cc5&originHeight=154&originWidth=610&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=121905&status=done&style=none&taskId=uf8a00f21-918b-4540-bed6-a8acddfeeef&title=&width=488" alt="image.png">（设置断点为b的main中，查看修改后的a调用b后main的ebp,修改后的ebp的值和原先的值未必一样）</p><h4 id="更新b的main的edp值程序编译a并执行"><a href="#更新b的main的edp值程序编译a并执行" class="headerlink" title="更新b的main的edp值程序编译a并执行:"></a>更新b的main的edp值程序编译a并执行:</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686895659695-57e49382-09cb-488d-ac74-789909133d40.png#averageHue=%231d2f6d&clientId=u2fdd0915-c1a2-4&from=paste&height=94&id=ucaa68e72&originHeight=117&originWidth=986&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=155025&status=done&style=none&taskId=ue428285e-d8a3-4aab-936d-ddf321989ba&title=&width=788.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686895686661-81140518-7f09-4bbf-9a46-5200abe59e03.png#averageHue=%231d3d7c&clientId=u2fdd0915-c1a2-4&from=paste&height=83&id=ufd42769d&originHeight=104&originWidth=405&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=67363&status=done&style=none&taskId=ufb6ea752-79bb-4714-aa1a-34d2e69a60e&title=&width=324" alt="image.png"><br>没有输出yes的原因：<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686895792789-243b225c-c4d1-4b52-96e7-13586308dbc7.png#averageHue=%23a4b7ce&clientId=u2fdd0915-c1a2-4&from=paste&height=67&id=uc893f175&originHeight=84&originWidth=514&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=48065&status=done&style=none&taskId=u1e78b271-1615-4f39-85ef-4eb995c2c81&title=&width=411.2" alt="image.png"></p><h4 id="修改优化更加隐蔽的攻击："><a href="#修改优化更加隐蔽的攻击：" class="headerlink" title="修改优化更加隐蔽的攻击："></a>修改优化更加隐蔽的攻击：</h4><p>原理：上面会报段错误和无法打印yes的原因是hanker过程的ret指令的返回地址是错误的。当执行hanker过程的ret指令的时候，是把此时的栈顶元素当中返回地址送到esp中，而上面的程序在执行到ret指令时此时的main栈帧的栈低元素当中了返回地址，但是这个返回地址是错误的，或者说是非法的（此时可能是把非静态变量或者是保存的寄存器的值当作了返回地址）。只有在复制bufff数组的时候把原本main栈帧中的返回地址+4的内存中写入正确的返回地址，也即是outputs的返回地址：0x8049229<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686926838859-8aad00fc-82b2-44f9-a9b5-e4726fbf64ef.png#averageHue=%23f7f4f1&clientId=u2fdd0915-c1a2-4&from=paste&height=30&id=ube7ac5f2&originHeight=38&originWidth=602&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=8644&status=done&style=none&taskId=u4e2d135b-0896-4757-b522-4168557993b&title=&width=481.6" alt="image.png"></p><h4 id="修改程序执行："><a href="#修改程序执行：" class="headerlink" title="修改程序执行："></a>修改程序执行：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686927209981-65fcf85c-3c28-4968-b1e6-f848b52c4f8e.png#averageHue=%23402145&clientId=u2fdd0915-c1a2-4&from=paste&height=168&id=u6e970b85&originHeight=210&originWidth=545&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=147010&status=done&style=none&taskId=ua04d188a-e930-46c5-976a-882c6ba024d&title=&width=436" alt="image.png"></p><h4 id="执行结果："><a href="#执行结果：" class="headerlink" title="执行结果："></a>执行结果：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686927294742-8de2de6b-8aaa-474d-949c-41c9d4029067.png#averageHue=%231c498c&clientId=u2fdd0915-c1a2-4&from=paste&height=82&id=u28612028&originHeight=103&originWidth=347&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=57466&status=done&style=none&taskId=u7f050ad9-2b8f-4804-ba05-c6a56abca7f&title=&width=277.6" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>课程作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机基础实验三：结构化数据存储</title>
    <link href="/2024/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E5%82%A8%E5%AD%98/"/>
    <url>/2024/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E5%82%A8%E5%AD%98/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="真值和机器数-整数的编码："><a href="#真值和机器数-整数的编码：" class="headerlink" title="真值和机器数-整数的编码："></a>真值和机器数-整数的编码：</h2><h4 id="测试程序："><a href="#测试程序：" class="headerlink" title="测试程序："></a>测试程序：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686796073975-a5e6eebe-2929-4e6e-a1c6-c73a3ff0d1a8.png#averageHue=%233e2957&clientId=u1c57ab6a-d4de-4&from=paste&height=311&id=u75b87c5e&originHeight=389&originWidth=790&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=321897&status=done&style=none&taskId=u844029b0-83fd-4783-a696-46d2e239cdf&title=&width=632" alt="image.png"></p><h4 id="编译执行："><a href="#编译执行：" class="headerlink" title="编译执行："></a>编译执行：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686796125292-0e8b3df7-028a-485d-815c-58b72900438f.png#averageHue=%231c3673&clientId=u1c57ab6a-d4de-4&from=paste&height=78&id=u3cd16f28&originHeight=97&originWidth=557&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=84074&status=done&style=none&taskId=u9f7a3a4e-9e47-4da1-a7af-3492e7fa3fa&title=&width=445.6" alt="image.png"></p><h4 id="bi和cu输出的结果和预期的结果不一样的原因寻找："><a href="#bi和cu输出的结果和预期的结果不一样的原因寻找：" class="headerlink" title="bi和cu输出的结果和预期的结果不一样的原因寻找："></a>bi和cu输出的结果和预期的结果不一样的原因寻找：</h4><h6 id="1-反汇编并查看上面的可执行文件："><a href="#1-反汇编并查看上面的可执行文件：" class="headerlink" title="1.反汇编并查看上面的可执行文件："></a>1.反汇编并查看上面的可执行文件：</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686796453396-04d4d6c1-e605-46c3-ad13-9d4225349bd2.png#averageHue=%231e3171&clientId=u1c57ab6a-d4de-4&from=paste&height=39&id=u344e5dc3&originHeight=49&originWidth=506&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=42212&status=done&style=none&taskId=u2c8f1ffb-d5df-4918-9252-e6fc523a77d&title=&width=404.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686796502017-341e7ca9-8894-4334-8262-91eaeba45694.png#averageHue=%232f346f&clientId=u1c57ab6a-d4de-4&from=paste&height=726&id=uf76f7866&originHeight=907&originWidth=1005&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=1101026&status=done&style=none&taskId=u235c9c58-b3e9-4119-a4a1-0988622445d&title=&width=804" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686796882027-5a85969e-af79-49ad-89dc-e213a93bb071.png#averageHue=%232a3e77&clientId=u1c57ab6a-d4de-4&from=paste&height=179&id=u43dda8bc&originHeight=224&originWidth=724&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=222674&status=done&style=none&taskId=u0c763622-3441-4be7-8afb-28298134ae8&title=&width=579.2" alt="image.png">从上图可以看出不敢是int的-100还是unsigned的-100其机器数都是用补码表示的。</p><h6 id="调试程序："><a href="#调试程序：" class="headerlink" title="调试程序："></a>调试程序：</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686797384644-c3e43a36-acf3-4d97-a3d7-0766e03dbe13.png#averageHue=%23274283&clientId=ub6abaa8e-4d9e-4&from=paste&height=429&id=u353c441b&originHeight=536&originWidth=931&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=632264&status=done&style=none&taskId=u95dd1a4e-2a7d-4aa0-82ac-4ba40822ba5&title=&width=744.8" alt="image.png">s选项输出的是下一条要执行的语句，并且已经执行了。</p><h6 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h6><p>bi&#x3D;2147483648是int数据，它的机器数是0x80000000,当bi当中有符号输出时，会将机器数当中补码转换为真值结果为-2147483648；cu&#x3D;-100,以二进制补码储存，机器数是0xffffff9，当以无符号输出时，机器数被解释为正数其真值为4294967196.<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686797773778-872a5916-7655-4753-94c9-7ce1c8b8b781.png#averageHue=%23e0e0de&clientId=ub6abaa8e-4d9e-4&from=paste&height=126&id=u2d889897&originHeight=158&originWidth=622&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=52736&status=done&style=none&taskId=u460f223e-91b5-4db1-bdb7-68bb7db81ee&title=&width=497.6" alt="image.png"></p><h2 id="真值和机器数-浮点数的编码："><a href="#真值和机器数-浮点数的编码：" class="headerlink" title="真值和机器数-浮点数的编码："></a>真值和机器数-浮点数的编码：</h2><h4 id="相关知识："><a href="#相关知识：" class="headerlink" title="相关知识："></a>相关知识：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686812876834-3bf2627f-8e39-4df7-8aab-4ec568c9b4aa.png#averageHue=%23efbb96&clientId=u7014ed6e-2e1e-4&from=paste&height=81&id=u25eacc76&originHeight=101&originWidth=530&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=58896&status=done&style=none&taskId=u4c801316-420b-4664-98d6-bd1997cbabe&title=&width=424" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686798304164-1af76d35-6f0f-465b-91d4-bd312354f42f.png#averageHue=%23d3dbe1&clientId=ub6abaa8e-4d9e-4&from=paste&height=219&id=u2bdfb0e7&originHeight=274&originWidth=984&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=353360&status=done&style=none&taskId=u9439cf5b-0a5b-4202-96dd-cbfa5cdbf77&title=&width=787.2" alt="image.png"></p><h4 id="测试程序：-1"><a href="#测试程序：-1" class="headerlink" title="测试程序："></a>测试程序：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686797860275-e64c4ba2-0005-42a5-a073-686a969c3ccd.png#averageHue=%233e2958&clientId=ub6abaa8e-4d9e-4&from=paste&height=318&id=u5d6d2906&originHeight=397&originWidth=780&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=321292&status=done&style=none&taskId=uc28e0f2a-3276-4ce8-ab0d-0a6292abe3f&title=&width=624" alt="image.png"></p><h4 id="调试运行程序："><a href="#调试运行程序：" class="headerlink" title="调试运行程序："></a>调试运行程序：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686798083177-12a9121c-b7dc-4931-8cbc-2a4798528334.png#averageHue=%231d3472&clientId=ub6abaa8e-4d9e-4&from=paste&height=99&id=ua6304f32&originHeight=124&originWidth=650&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=117330&status=done&style=none&taskId=u8905bece-e2cc-4d4f-8760-55cdc4357db&title=&width=520" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686812353696-e3e1c9d4-23cd-4cb6-ba1b-fc0fbf5eebca.png#averageHue=%23f3ad93&clientId=u7014ed6e-2e1e-4&from=paste&height=52&id=ua80d6f40&originHeight=65&originWidth=483&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=9542&status=done&style=none&taskId=uf0501c42-1788-47e3-ad98-9404d593d95&title=&width=386.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686812278321-4b026cef-fd52-46fd-80ac-83c4d120bf6d.png#averageHue=%238eb6c9&clientId=u7014ed6e-2e1e-4&from=paste&height=82&id=uf6800bac&originHeight=103&originWidth=846&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=132739&status=done&style=none&taskId=uaf5ebc57-4f1e-44e7-9650-e942b2fa738&title=&width=676.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686812893275-e8b1266f-124d-400d-ba51-4bc05cbfbc10.png#averageHue=%232a3a75&clientId=u7014ed6e-2e1e-4&from=paste&height=594&id=u1392990d&originHeight=742&originWidth=798&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=753417&status=done&style=none&taskId=u4152fc58-2ffd-48ec-9221-263b6272fb7&title=&width=638.4" alt="image.png"><br>这里的0x56557028的由来：由汇编指令：<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686812939339-8105928b-1cae-44b4-92ba-ddc23c569c26.png#averageHue=%23f19979&clientId=u7014ed6e-2e1e-4&from=paste&height=24&id=u748ca8d2&originHeight=30&originWidth=297&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=3515&status=done&style=none&taskId=u05ab46d9-862a-437d-a8da-8fcbfa0b53b&title=&width=237.6" alt="image.png">求出数值100浮点数的位置为：<br>%ebx-0x1fb0&#x3D; 0x56558fd8-0x1fb0</p><h2 id="数据存储的宽度和排列方式："><a href="#数据存储的宽度和排列方式：" class="headerlink" title="数据存储的宽度和排列方式："></a>数据存储的宽度和排列方式：</h2><h4 id="相关知识点："><a href="#相关知识点：" class="headerlink" title="相关知识点："></a>相关知识点：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686813781416-3557fd2b-f0c3-48de-9672-f0535856e8ee.png#averageHue=%23d6dde2&clientId=udaf52dd5-bf16-4&from=paste&height=306&id=ubd183ee1&originHeight=383&originWidth=679&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=221683&status=done&style=none&taskId=u94b0d179-e080-4129-a511-9fddff08ff8&title=&width=543.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686813984841-d7814dfa-1838-4159-ae3c-feb78a244164.png#averageHue=%239fb3ca&clientId=udaf52dd5-bf16-4&from=paste&height=134&id=ucfde651a&originHeight=168&originWidth=507&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=98930&status=done&style=none&taskId=u79b9637a-e9c9-4ccd-bf06-b5dea2f393e&title=&width=405.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686814015272-3ad1d186-1a9e-4181-b771-c51d7a6da3d5.png#averageHue=%23cbd1d5&clientId=udaf52dd5-bf16-4&from=paste&height=63&id=u367b4fec&originHeight=79&originWidth=622&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=73984&status=done&style=none&taskId=u971fbb6d-4d54-4bb2-84af-34543e7e342&title=&width=497.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686814062980-2a4b1052-6300-424f-a13f-244526050ac2.png#averageHue=%23c6ced4&clientId=udaf52dd5-bf16-4&from=paste&height=65&id=u4527f3c9&originHeight=81&originWidth=618&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=75235&status=done&style=none&taskId=u60ebe607-ca6e-4caf-8475-1e4e84772e7&title=&width=494.4" alt="image.png"></p><h4 id="测试程序：-2"><a href="#测试程序：-2" class="headerlink" title="测试程序："></a>测试程序：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686813294878-dba320a1-fe1e-4215-99ad-6adb89fc8819.png#averageHue=%233e2c5e&clientId=udaf52dd5-bf16-4&from=paste&height=323&id=u3b15dc20&originHeight=404&originWidth=994&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=403538&status=done&style=none&taskId=u21a5ee71-6b71-43d8-8770-fd306582a36&title=&width=795.2" alt="image.png"></p><h4 id="编译运行："><a href="#编译运行：" class="headerlink" title="编译运行："></a>编译运行：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686813360913-b2bc62db-07b9-4298-b3ea-84aac6df08a7.png#averageHue=%231d3471&clientId=udaf52dd5-bf16-4&from=paste&height=73&id=ucff8b5f1&originHeight=91&originWidth=554&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=83053&status=done&style=none&taskId=ubf56ce79-1aa7-4f29-8d11-f98ef5e0796&title=&width=443.2" alt="image.png"></p><h4 id="调试："><a href="#调试：" class="headerlink" title="调试："></a>调试：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686813617884-1414df7b-43a1-4f35-9799-8aa1bb18765f.png#averageHue=%2329407e&clientId=udaf52dd5-bf16-4&from=paste&height=495&id=u5bb185ab&originHeight=619&originWidth=908&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=691383&status=done&style=none&taskId=u4ce5c52b-89a1-4141-84d5-73a60de3e32&title=&width=726.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686813625210-9d94ea9d-efdf-4618-91cd-c87f0310c81f.png#averageHue=%23c3c3c3&clientId=udaf52dd5-bf16-4&from=paste&height=81&id=ue28c8592&originHeight=101&originWidth=499&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=35191&status=done&style=none&taskId=u192738fa-8152-4738-9c63-ab6cb34e7ed&title=&width=399.2" alt="image.png">上图的黄色的部分分别是a,b<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686813911061-49ddb522-f7cf-454c-bcae-b3d689f9fbb5.png#averageHue=%231e3476&clientId=udaf52dd5-bf16-4&from=paste&height=136&id=u65db2778&originHeight=170&originWidth=1082&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=229944&status=done&style=none&taskId=u8aad3701-3c69-45c2-8bec-4d40b789147&title=&width=865.6" alt="image.png">上图中黄色的部分是存储int d &#x3D; 0x12345678,可以清楚的看出是小段方式<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686814199420-f4e204b6-5c61-4c0f-953f-dfacfcb50db0.png#averageHue=%23f4b49c&clientId=udaf52dd5-bf16-4&from=paste&height=44&id=ue1e11a01&originHeight=55&originWidth=560&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=8688&status=done&style=none&taskId=uee2f204c-59b8-4341-a779-700b60659d6&title=&width=448" alt="image.png">这里也可以看出是小段方式</p><h2 id="数据存储的对齐方式："><a href="#数据存储的对齐方式：" class="headerlink" title="数据存储的对齐方式："></a>数据存储的对齐方式：</h2><h4 id="相关知识：-1"><a href="#相关知识：-1" class="headerlink" title="相关知识："></a>相关知识：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686815385643-019417ef-881d-429a-b036-dab6e6b90e7f.png#averageHue=%23f6f6f5&clientId=u25fd9309-944c-4&from=paste&height=78&id=u82f9ceda&originHeight=97&originWidth=413&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=40265&status=done&style=none&taskId=u4d628f5f-b032-4b20-a669-6068317985b&title=&width=330.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686815389107-0f9c6622-93cf-438c-85e4-146999f909a9.png#averageHue=%23dfc8c8&clientId=u25fd9309-944c-4&from=paste&height=43&id=u98a2ce45&originHeight=54&originWidth=736&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=42894&status=done&style=none&taskId=ued5f3573-9077-434b-a6ff-7ac8b6aa618&title=&width=588.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686815444804-52e29b33-a26a-4705-98e1-1465d1615b5a.png#averageHue=%23f9fbfa&clientId=u25fd9309-944c-4&from=paste&height=95&id=ubfc891f9&originHeight=119&originWidth=345&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=44222&status=done&style=none&taskId=ua900929c-8603-412d-8426-3db44fa5809&title=&width=276" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686815474645-c639cc46-e61d-4127-be47-613a0b357278.png#averageHue=%23ddd0d0&clientId=u25fd9309-944c-4&from=paste&height=44&id=u39b1a314&originHeight=55&originWidth=811&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=34803&status=done&style=none&taskId=u53c37e71-9108-48bd-b94b-f717ee1f3dc&title=&width=648.8" alt="image.png"></p><h4 id="测试程序：-3"><a href="#测试程序：-3" class="headerlink" title="测试程序："></a>测试程序：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686814504945-10e4d7b3-9561-44be-b640-d33531d518c8.png#averageHue=%233c2854&clientId=udaf52dd5-bf16-4&from=paste&height=337&id=ucfee7846&originHeight=421&originWidth=675&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=302573&status=done&style=none&taskId=u750910b9-7d59-4c9a-9f73-db2a1e6e16e&title=&width=540" alt="image.png"></p><h4 id="编译运行：-1"><a href="#编译运行：-1" class="headerlink" title="编译运行："></a>编译运行：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686814577029-26e0e443-9377-45ad-b4bd-e7af6d896492.png#averageHue=%231d3472&clientId=udaf52dd5-bf16-4&from=paste&height=78&id=u2515b3ac&originHeight=97&originWidth=579&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=93009&status=done&style=none&taskId=u668367b1-3695-4ddf-be3f-708867b7858&title=&width=463.2" alt="image.png"></p><h4 id="调试：-1"><a href="#调试：-1" class="headerlink" title="调试："></a>调试：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686814834119-a934ed87-9664-403e-8941-afd6d0b314de.png#averageHue=%23f3f0ec&clientId=u25fd9309-944c-4&from=paste&height=40&id=u2f8ef860&originHeight=50&originWidth=668&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=13615&status=done&style=none&taskId=uf01327d2-ecfb-4e47-9863-fe55357f54f&title=&width=534.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686814850097-42b074cd-3f20-450f-9cf3-ff586202fe0b.png#averageHue=%23254688&clientId=u25fd9309-944c-4&from=paste&height=322&id=u81b78775&originHeight=402&originWidth=811&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=423695&status=done&style=none&taskId=ue7bff6e3-b00c-4ce2-8d16-6b788d0baa9&title=&width=648.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686814942901-53a39f67-2f73-4b26-b538-6993aa74c6f2.png#averageHue=%232b4480&clientId=u25fd9309-944c-4&from=paste&height=189&id=u9b7a37ef&originHeight=236&originWidth=813&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=255350&status=done&style=none&taskId=u92d79b7a-282d-4148-854a-7eab6ea6ecf&title=&width=650.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686814953895-382d2e92-ee25-4415-b86a-ef98bb190b37.png#averageHue=%23908275&clientId=u25fd9309-944c-4&from=paste&height=242&id=u362074b1&originHeight=302&originWidth=788&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=167854&status=done&style=none&taskId=ub0892ad8-5d97-4c7d-a66d-b3cf9b70979&title=&width=630.4" alt="image.png">（对照上图）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686815516346-f80f32fb-e16b-4e02-a36c-21c23733d555.png#averageHue=%23585752&clientId=u25fd9309-944c-4&from=paste&height=229&id=u73001776&originHeight=286&originWidth=962&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=234196&status=done&style=none&taskId=ubcca80ce-8736-4778-9156-1ae67121dab&title=&width=769.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686815566802-7b83821e-6a0c-476c-b5ae-9681f58271fb.png#averageHue=%23c7d1db&clientId=u25fd9309-944c-4&from=paste&height=67&id=ud707ff71&originHeight=84&originWidth=332&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=50299&status=done&style=none&taskId=u1026de22-8d03-441e-86ce-0e460ed1ddb&title=&width=265.6" alt="image.png"></p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686815603878-cc6ead7e-f9fb-4e36-a7d7-a7278b3e8f5f.png#averageHue=%23a6b8cd&clientId=u25fd9309-944c-4&from=paste&height=137&id=u76010526&originHeight=171&originWidth=459&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=98698&status=done&style=none&taskId=uaa64ecec-4357-41a0-9da8-af96558cd02&title=&width=367.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686815633445-8c079ee6-4d6c-469c-b92f-90e7333007df.png#averageHue=%23b6b6b5&clientId=u25fd9309-944c-4&from=paste&height=248&id=u679a3a5b&originHeight=310&originWidth=645&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=167486&status=done&style=none&taskId=uac83aa76-27ff-4b33-a6e0-e930e18d997&title=&width=516" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686815653579-64517f5c-d8d0-4e24-96a9-4b2331c2c603.png#averageHue=%23acadab&clientId=u25fd9309-944c-4&from=paste&height=122&id=u069730e4&originHeight=153&originWidth=475&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=80608&status=done&style=none&taskId=ubacb066c-d238-41f8-a2b1-69f6db69401&title=&width=380" alt="image.png"> </p><h2 id="整数之间数据类型的转换："><a href="#整数之间数据类型的转换：" class="headerlink" title="整数之间数据类型的转换："></a>整数之间数据类型的转换：</h2><h4 id="相关知识：-2"><a href="#相关知识：-2" class="headerlink" title="相关知识："></a>相关知识：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686816232613-5e51bb6b-9e8b-4d07-9e1e-95f418400d15.png#averageHue=%23dedfdd&clientId=u25fd9309-944c-4&from=paste&height=76&id=u2d15d915&originHeight=95&originWidth=501&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=67537&status=done&style=none&taskId=uc8fca903-5f6a-4cb7-98a3-e3f8367d719&title=&width=400.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686816297127-472c2c5a-838c-4986-9f41-2e12b56fafb3.png#averageHue=%23dbe3ea&clientId=u25fd9309-944c-4&from=paste&height=232&id=u9bfae9c8&originHeight=290&originWidth=762&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=242483&status=done&style=none&taskId=ua37c960b-3492-483c-a750-e660647363a&title=&width=609.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686816375559-93cd5ddb-66e2-4541-9a5b-d63d3a2ea826.png#averageHue=%23d5dee8&clientId=u25fd9309-944c-4&from=paste&height=368&id=ud23ddeda&originHeight=460&originWidth=1065&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=575060&status=done&style=none&taskId=u2012a32a-8003-496a-8c75-cc034ba0c41&title=&width=852" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686816460745-deab3e29-6157-4f92-b41b-b5aa59a6a1a4.png#averageHue=%23d7e0e7&clientId=u25fd9309-944c-4&from=paste&height=221&id=ua1d0cd8f&originHeight=276&originWidth=811&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=250283&status=done&style=none&taskId=u1b67f80f-6468-42f2-8b9f-4c01a7bd0b9&title=&width=648.8" alt="image.png"></p><h4 id="测试程序：-4"><a href="#测试程序：-4" class="headerlink" title="测试程序："></a>测试程序：</h4><p>#include “stdio.h”<br>void main()<br>{<br>    short si &#x3D; -100;<br>    unsigned short usi &#x3D; si;<br>    int i &#x3D;usi;<br>    unsignedui &#x3D; usi;<br>    int       i1 &#x3D; si;<br>    unsignedui1 &#x3D; si;<br>    int i2 &#x3D; 0x12348765;<br>    short si2 &#x3D; i2;<br>    unsigned short usi2 &#x3D; i2;<br>    inti3 &#x3D; si2;<br>     int i4 &#x3D; 4294967296;<br>    printf(“si&#x3D;%d,usi&#x3D;%u,i&#x3D;%d,ui&#x3D;%u,i1&#x3D;%d,ui1&#x3D;%u\n”, si, usi, i, ui, i1, ui1);<br>    printf(“i2&#x3D;%d,si2&#x3D;%d,usi2&#x3D;%u,i3&#x3D;%d,i4&#x3D;%d\n”, i2, si2, usi2, i3, i4);<br>}</p><h4 id="编译运行：-2"><a href="#编译运行：-2" class="headerlink" title="编译运行："></a>编译运行：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686817267517-76125fef-70aa-4f6c-b0f6-61510d0e716d.png#averageHue=%231f3576&clientId=u25fd9309-944c-4&from=paste&height=156&id=ua73db37c&originHeight=195&originWidth=1188&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=307838&status=done&style=none&taskId=u6848f488-39bf-4f61-9290-02d31a093af&title=&width=950.4" alt="image.png"></p><h4 id="调试：-2"><a href="#调试：-2" class="headerlink" title="调试："></a>调试：</h4><p>部分反汇编内容：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686818027959-7de00e1b-4458-4095-863d-dfc57ac0745f.png#averageHue=%23fcfbfa&clientId=u25fd9309-944c-4&from=paste&height=308&id=u27757978&originHeight=385&originWidth=1051&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=64819&status=done&style=none&taskId=ub6fa269c-7386-42f1-aa1f-49f0c499bbc&title=&width=840.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686817570996-217bc61b-6fb8-41cd-aeec-c0faee99e04e.png#averageHue=%23234385&clientId=u25fd9309-944c-4&from=paste&height=272&id=ud7aff3d1&originHeight=340&originWidth=785&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=373459&status=done&style=none&taskId=u347f619a-1bb4-4bfe-8ba8-9eee0f7cb88&title=&width=628" alt="image.png">（图1）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686817832575-0929da60-9d4e-4bae-b8c1-8002f3f2e267.png#averageHue=%23f4f6f4&clientId=u25fd9309-944c-4&from=paste&height=22&id=u715c5c91&originHeight=28&originWidth=241&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=10385&status=done&style=none&taskId=ua0c3467a-e594-45e9-8c8a-4b9c5fe2809&title=&width=192.8" alt="image.png">（对照上图1理解这个赋值语句）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686817813805-04d0c8dd-0120-4a1d-9432-3b3643f59194.png#averageHue=%2372706b&clientId=u25fd9309-944c-4&from=paste&height=114&id=u51846451&originHeight=142&originWidth=404&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=44274&status=done&style=none&taskId=u929920fe-a3fc-4779-860f-bed0b92a444&title=&width=323.2" alt="image.png">(图中的si,usi在栈的内容可以结合反汇编内容计算出来）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686817872311-ac9150e1-3517-4e65-81e1-48f7ff9656f3.png#averageHue=%23d4d4d4&clientId=u25fd9309-944c-4&from=paste&height=25&id=uf42b2954&originHeight=31&originWidth=605&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=15674&status=done&style=none&taskId=ucbae5e6c-594b-46e8-b352-120d972bbd2&title=&width=484" alt="image.png">这里直接复制，不扩展和阶段，si和usi的机器数一样，但是真值根据数据类型不一样。<br>对照上图1理解：<br>int i &#x3D; usi; unsigned ui &#x3D; usi;<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686818055655-d5b4a388-e60d-4abe-aa0d-7accf3a727d7.png#averageHue=%23eeeeee&clientId=u25fd9309-944c-4&from=paste&height=127&id=u4b0f39e0&originHeight=159&originWidth=570&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=36922&status=done&style=none&taskId=ubf7c31d2-0f53-4934-a987-e6ffd518c4a&title=&width=456" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686818264602-1438e85c-d8c9-4ed3-9dc9-7b521764a396.png#averageHue=%23999d8f&clientId=u25fd9309-944c-4&from=paste&height=160&id=ude8a84fa&originHeight=200&originWidth=803&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=131385&status=done&style=none&taskId=u53800679-5177-4833-b36a-8f555e36a75&title=&width=642.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686818281690-923fc740-d590-4095-a2df-2a1d7b584061.png#averageHue=%23f0f0f0&clientId=u25fd9309-944c-4&from=paste&height=96&id=u125acde1&originHeight=120&originWidth=377&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=17948&status=done&style=none&taskId=u4ccce826-284b-43a1-b15e-fe08fd96c38&title=&width=301.6" alt="image.png"><br>理解int i1 &#x3D; si; unsigned ui1&#x3D;si;<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686818315463-deaf92d4-af15-45d9-8c47-5f44242779f3.png#averageHue=%23eeeeee&clientId=u25fd9309-944c-4&from=paste&height=128&id=ue8654cbc&originHeight=160&originWidth=594&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=36379&status=done&style=none&taskId=ud942694e-74f8-470d-8f6a-f7fec0b3f09&title=&width=475.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686818395734-f19f036f-8343-4825-9089-3ee689e25167.png#averageHue=%23b1b1ab&clientId=u25fd9309-944c-4&from=paste&height=174&id=u4bc96c12&originHeight=217&originWidth=780&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=162295&status=done&style=none&taskId=ub234509c-0638-43db-8fa6-5438fa7d858&title=&width=624" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686818410673-c4d69ab1-2e4b-4ef7-add5-d5ae6d50f558.png#averageHue=%23ececec&clientId=u25fd9309-944c-4&from=paste&height=83&id=u0d3a8c72&originHeight=104&originWidth=393&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=19740&status=done&style=none&taskId=ub0d47f65-c428-4239-a7d8-bce28546251&title=&width=314.4" alt="image.png"><br>理解int i2 &#x3D; 0x12345678;short si2 &#x3D; i2;unsigend usi2 &#x3D; i2;<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686818525842-3c1128dd-3f48-48af-ada0-8de28a51ecd9.png#averageHue=%23e8e8e8&clientId=u25fd9309-944c-4&from=paste&height=94&id=uc39242bd&originHeight=117&originWidth=304&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=21707&status=done&style=none&taskId=uf688891b-79f2-4252-8f49-4671de5792a&title=&width=243.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686818539665-b2048638-866a-4271-91c8-6063229b7d0c.png#averageHue=%23dfdfdf&clientId=u25fd9309-944c-4&from=paste&height=34&id=u197fe6d4&originHeight=43&originWidth=521&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=16259&status=done&style=none&taskId=u9b830b35-212b-4bbf-b4c0-24048665561&title=&width=416.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686818559052-c1b29202-3fdd-4726-b10b-2b09a8fa8c6e.png#averageHue=%23808375&clientId=u25fd9309-944c-4&from=paste&height=166&id=u0b5c4cc4&originHeight=207&originWidth=794&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=165652&status=done&style=none&taskId=uac0b7715-ff28-44a7-bbac-a1a7d363498&title=&width=635.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686818575117-982a02c1-dc6e-4334-a4ca-f51043acc27d.png#averageHue=%23eeeeee&clientId=u25fd9309-944c-4&from=paste&height=79&id=u96b4f218&originHeight=99&originWidth=441&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=18369&status=done&style=none&taskId=u39ed6f3f-1f3e-447a-b715-23d7077035b&title=&width=352.8" alt="image.png"><br>理解 short si2 &#x3D; i2;int i3 &#x3D;si2;<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686818662748-55558bf8-e360-447b-bd55-f14d0f46fd31.png#averageHue=%23898e7e&clientId=u25fd9309-944c-4&from=paste&height=190&id=u6df9e8b4&originHeight=238&originWidth=828&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=187373&status=done&style=none&taskId=uaa629582-fb3c-4d91-af8a-77d01be8efe&title=&width=662.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686818691144-4a36f09e-2a1b-4107-a796-e220ae146add.png#averageHue=%23e0e0e0&clientId=u25fd9309-944c-4&from=paste&height=132&id=u86c56662&originHeight=165&originWidth=468&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=58527&status=done&style=none&taskId=u707b19c6-85aa-46d8-bbc5-e2b6f81b715&title=&width=374.4" alt="image.png"><br>理解int i4 &#x3D; i4 &#x3D; 4294967296;输出的值为0；<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686818739523-ef5e9e96-d4c7-4d66-976b-c66b59e7844d.png#averageHue=%23e6e6e6&clientId=u25fd9309-944c-4&from=paste&height=94&id=u9675a3a5&originHeight=117&originWidth=473&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=31257&status=done&style=none&taskId=u1c2dfcc3-1638-4617-8d35-46db9858113&title=&width=378.4" alt="image.png"></p><h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686818765383-e243e1d8-9fba-4d4a-9ae1-c9f88148f157.png#averageHue=%23d6d7d5&clientId=u25fd9309-944c-4&from=paste&height=174&id=u974cce20&originHeight=217&originWidth=594&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=92894&status=done&style=none&taskId=ue44e92dc-994b-48a5-b735-fac9cc18db0&title=&width=475.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686818777921-af41edaa-5771-4d62-86d5-043a82ad039e.png#averageHue=%23dcdddb&clientId=u25fd9309-944c-4&from=paste&height=144&id=ue9010bd0&originHeight=180&originWidth=632&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=87828&status=done&style=none&taskId=u7bb6c1d6-906d-46c0-ae39-2242595ad48&title=&width=505.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686818786631-15488454-81b2-4a4c-b550-3bdbb69118aa.png#averageHue=%23a1a3a3&clientId=u25fd9309-944c-4&from=paste&height=76&id=ua3ad4507&originHeight=95&originWidth=545&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=63214&status=done&style=none&taskId=u211cf06e-e989-4ca1-a607-36bab8ce35b&title=&width=436" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686818795506-2238d6af-7ab3-457c-97eb-e4c0c95ca97d.png#averageHue=%23cfd0ce&clientId=u25fd9309-944c-4&from=paste&height=143&id=u0e4b6ec5&originHeight=179&originWidth=618&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=92718&status=done&style=none&taskId=ue7a9097b-e087-46b1-b1ec-371b7c1db5f&title=&width=494.4" alt="image.png"></p><h2 id="整数和浮点数之间的数据转换："><a href="#整数和浮点数之间的数据转换：" class="headerlink" title="整数和浮点数之间的数据转换："></a>整数和浮点数之间的数据转换：</h2><h4 id="相关知识：-3"><a href="#相关知识：-3" class="headerlink" title="相关知识："></a>相关知识：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686818837670-748be2ce-3da8-4df5-9387-7b9f0811a050.png#averageHue=%23babbba&clientId=u25fd9309-944c-4&from=paste&height=102&id=u9d389491&originHeight=127&originWidth=537&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=58527&status=done&style=none&taskId=u50b8e2a9-2036-4ff1-8087-f67d9decd86&title=&width=429.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686818860945-8bfbcc17-30ed-478c-9b9f-25359f492213.png#averageHue=%23d6d6d5&clientId=u25fd9309-944c-4&from=paste&height=165&id=ud6ab3b48&originHeight=206&originWidth=518&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=71016&status=done&style=none&taskId=ua6207cca-4a0c-4dc4-aad4-73988171864&title=&width=414.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686818868191-9fd491cf-e38f-4266-8e06-2e5601e014fb.png#averageHue=%23adaeac&clientId=u25fd9309-944c-4&from=paste&height=80&id=u9bf77295&originHeight=100&originWidth=552&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=57434&status=done&style=none&taskId=ufdbee61a-8e29-47a7-9ef1-4e51d882dc7&title=&width=441.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686819381074-bbe4bc42-2da8-45fe-a09f-b4580d834a59.png#averageHue=%23979796&clientId=u25fd9309-944c-4&from=paste&height=143&id=uccb558c5&originHeight=179&originWidth=542&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=77610&status=done&style=none&taskId=u69f83c23-a433-4195-ba6d-1537d86d2e7&title=&width=433.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686820074726-528b6422-0a80-4978-a22b-0e13d4d6a9ac.png#averageHue=%23d5d5d4&clientId=udc96cd0c-4a58-4&from=paste&height=123&id=u4bcfe6c4&originHeight=154&originWidth=545&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=62154&status=done&style=none&taskId=u733a049a-a31d-472e-834f-a04f0687543&title=&width=436" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686820085550-42969304-0eb9-4129-9b9b-73993eb129d2.png#averageHue=%23b2b2b2&clientId=udc96cd0c-4a58-4&from=paste&height=106&id=u0d496d0d&originHeight=133&originWidth=513&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=58954&status=done&style=none&taskId=ud269635f-a90e-4765-a4e3-5ceb2fea88f&title=&width=410.4" alt="image.png"></p><h4 id="测试程序：-5"><a href="#测试程序：-5" class="headerlink" title="测试程序："></a>测试程序：</h4><p>#include “stdio.h”<br>int main()<br>{<br>    int i1 &#x3D; 0x7fffffff, i2, itemp;<br>    float f1 &#x3D; 0x987654321, f2, ftemp;<br>    ftemp &#x3D; i1;<br>    i2 &#x3D; ftemp;         &#x2F;&#x2F;i2&#x3D;(int)(float)i1;<br>    itemp &#x3D; f1;<br>    f2 &#x3D; itemp;         &#x2F;&#x2F;f2&#x3D;(float)(int)f1;<br>    printf(“i1&#x3D;%d,i2&#x3D;%d,f1&#x3D;%f,f2&#x3D;%f\n”, i1, i2, f1, f2);<br>}</p><h4 id="编译运行：-3"><a href="#编译运行：-3" class="headerlink" title="编译运行："></a>编译运行：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686819082162-0810aa73-68a2-4fa5-aff1-a43b4632c802.png#averageHue=%231c3271&clientId=u25fd9309-944c-4&from=paste&height=80&id=u95aaae65&originHeight=100&originWidth=741&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=114517&status=done&style=none&taskId=ud93f54d9-392e-45e5-94b2-244b7397b5e&title=&width=592.8" alt="image.png"></p><h4 id="调试：-3"><a href="#调试：-3" class="headerlink" title="调试："></a>调试：</h4><p>部分反汇编内容:<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686819233559-f48a72c7-9bf1-469f-aabb-24179287591b.png#averageHue=%23fcfbfa&clientId=u25fd9309-944c-4&from=paste&height=458&id=uae9b4fcd&originHeight=573&originWidth=1028&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=105371&status=done&style=none&taskId=ubac0b17b-1c82-4134-bcd6-6b4043491e9&title=&width=822.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686819317944-dbe8fb58-e418-424e-9f03-74eab907cf53.png#averageHue=%23233c7f&clientId=u25fd9309-944c-4&from=paste&height=230&id=ub938c9ab&originHeight=288&originWidth=1134&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=420150&status=done&style=none&taskId=ua743d316-0dd1-4323-9675-7445d4f7304&title=&width=907.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686819349925-f9a25f0a-d248-49ee-ae36-9209e0465723.png#averageHue=%2373716a&clientId=u25fd9309-944c-4&from=paste&height=135&id=ub7a83cd0&originHeight=169&originWidth=622&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=108620&status=done&style=none&taskId=u245d7648-b8b4-4e0a-808b-1575944c554&title=&width=497.6" alt="image.png"><br>原因：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686819609608-b7aff42d-c425-49f6-9bce-0dd14de0c31f.png#averageHue=%23d5dee6&clientId=udc96cd0c-4a58-4&from=paste&height=314&id=u7598791d&originHeight=393&originWidth=863&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=402532&status=done&style=none&taskId=u572ca445-2ea8-49b6-b856-9aed409c1b4&title=&width=690.4" alt="image.png"><br>上图的加1操作是浮点数的舍入操作；i2的机器数和i2不一样原因是转换的时候进入舍入操作中加了1近似处理；<br>理解f2&#x3D;(float)(int)f1：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686819765384-7aa0a22c-c2c8-44fc-bbe6-7f63492e9bb6.png#averageHue=%2368675f&clientId=udc96cd0c-4a58-4&from=paste&height=125&id=u9a7e4ce0&originHeight=156&originWidth=851&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=135737&status=done&style=none&taskId=ufb8278df-2c17-4c3a-bc40-fc1284c4ab5&title=&width=680.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686820049491-1f623ba7-3e73-4f71-80ee-906e0223f6d3.png#averageHue=%23cfd8df&clientId=udc96cd0c-4a58-4&from=paste&height=374&id=u2aa94916&originHeight=467&originWidth=707&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=441365&status=done&style=none&taskId=ud5b313ed-9204-4fc0-8397-e6c294de08b&title=&width=565.6" alt="image.png"></p><h2 id="C语言自动类型转换："><a href="#C语言自动类型转换：" class="headerlink" title="C语言自动类型转换："></a>C语言自动类型转换：</h2><h4 id="相关知识：-4"><a href="#相关知识：-4" class="headerlink" title="相关知识："></a>相关知识：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686825718699-873ae8d6-ac35-4aee-87f0-cc321dd846e0.png#averageHue=%23dee1df&clientId=udc96cd0c-4a58-4&from=paste&height=44&id=ucfbecb2a&originHeight=55&originWidth=616&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=47264&status=done&style=none&taskId=u2f1e01b0-a541-4f82-8d42-e0cabcefcdf&title=&width=492.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686825727774-f7572332-3848-4432-b736-399482f2559c.png#averageHue=%23e7eaea&clientId=udc96cd0c-4a58-4&from=paste&height=67&id=ufe441d8d&originHeight=84&originWidth=560&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=40634&status=done&style=none&taskId=u9431e309-6ce7-4486-bc37-bc1917cdb9c&title=&width=448" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686825784091-ae3b003a-1f4e-4398-a440-61ce92425aac.png#averageHue=%23c9cac8&clientId=u11c508af-903e-4&from=paste&height=34&id=u93d7dfb4&originHeight=42&originWidth=595&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=41260&status=done&style=none&taskId=uee153265-9437-4ea0-b7d8-19b019e556d&title=&width=476" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686825787470-5abfe14a-45fc-4e57-b35e-143758f3bcbf.png#averageHue=%23d8d8d6&clientId=u11c508af-903e-4&from=paste&height=66&id=u68f12990&originHeight=83&originWidth=600&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=54350&status=done&style=none&taskId=u2671ddaa-a88b-4bb2-b73a-8a11fd7310f&title=&width=480" alt="image.png"></p><h4 id="测试程序：-6"><a href="#测试程序：-6" class="headerlink" title="测试程序："></a>测试程序：</h4><p>#include “stdio.h”<br>int f1( unsigned int n )<br>{<br>    int sum &#x3D; 1, power &#x3D; 1;<br>    int i;<br>    for ( i &#x3D; 0; i &lt;&#x3D; n - 1; i ++ )<br>    {<br>        power *&#x3D; 2;<br>        sum +&#x3D; power;<br>    }<br>    return sum;<br>}<br>int main()<br>{<br>    int sum;<br>    sum &#x3D; f1(0);<br>    printf(“sum&#x3D;%d\n”, sum);<br>    return 0;<br>}</p><h4 id="编译运行：-4"><a href="#编译运行：-4" class="headerlink" title="编译运行："></a>编译运行：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686820350933-418bf527-05ac-464c-95c9-b174abf41fb0.png#averageHue=%231c3673&clientId=udc96cd0c-4a58-4&from=paste&height=78&id=u53655dd8&originHeight=98&originWidth=556&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=86987&status=done&style=none&taskId=u548c69c9-4f0f-462f-9d1a-fe35d207e17&title=&width=444.8" alt="image.png">执行的时候陷入了死循环，没有输出结果一直执行。</p><h4 id="调试探索陷入死循环的原因："><a href="#调试探索陷入死循环的原因：" class="headerlink" title="调试探索陷入死循环的原因："></a>调试探索陷入死循环的原因：</h4><p>部分反汇编内容：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686820548619-e373d43e-281c-4e96-9bbb-668dc6af7c31.png#averageHue=%23fdfcfb&clientId=udc96cd0c-4a58-4&from=paste&height=501&id=uaefb4ce9&originHeight=626&originWidth=979&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=80313&status=done&style=none&taskId=u44f5084b-deab-444d-b6c3-8af13a05cd5&title=&width=783.2" alt="image.png"><br>注意上面的jae是无符号比较，i和n-1比较的时候会自动转化为无符号比较，<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686825306921-7d714705-f415-4e05-886e-6f0ebd68a618.png#averageHue=%231f3a7d&clientId=udc96cd0c-4a58-4&from=paste&height=192&id=uf8cbbdcd&originHeight=240&originWidth=950&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=270637&status=done&style=none&taskId=u2a38b59d-1d44-48e5-9fb7-297183a4538&title=&width=760" alt="image.png"><br>根据上面的反汇编内容，edx是n-1,eax是i;<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686825358371-89bd8257-e639-4053-b03a-b5631b35721b.png#averageHue=%23fcfefc&clientId=udc96cd0c-4a58-4&from=paste&height=62&id=u8917b7d3&originHeight=77&originWidth=370&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=43734&status=done&style=none&taskId=uf945e82a-d3c7-460f-bed6-b167b7472d8&title=&width=296" alt="image.png">jae的转义指令永远会执行，不会退出循环。</p><h4 id="修改："><a href="#修改：" class="headerlink" title="修改："></a>修改：</h4><p>把无符号n修改为带符号n，修改后执行然后反汇编。<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686825563774-cd11364b-2ad1-487d-9150-74ab0f5622f2.png#averageHue=%23294d85&clientId=udc96cd0c-4a58-4&from=paste&height=108&id=uc298e35f&originHeight=135&originWidth=597&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=105463&status=done&style=none&taskId=ub0de098c-925d-41bc-b759-5b6c0dc53b5&title=&width=477.6" alt="image.png">可以看出jg是有符号比较。<br>修改后运行：<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686825703733-e21f558b-b8db-424b-b5ce-67f848c5ace0.png#averageHue=%231e3a7f&clientId=udc96cd0c-4a58-4&from=paste&height=37&id=ue0026137&originHeight=46&originWidth=331&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=24824&status=done&style=none&taskId=u257f3057-aaf3-45b0-bef0-591c43c311d&title=&width=264.8" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>课程作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机基础实验2：算术运算</title>
    <link href="/2024/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97/"/>
    <url>/2024/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="整数加减法运算的电路："><a href="#整数加减法运算的电路：" class="headerlink" title="整数加减法运算的电路："></a>整数加减法运算的电路：</h2><h4 id="相关知识："><a href="#相关知识：" class="headerlink" title="相关知识："></a>相关知识：</h4><p><strong>补码运算：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686635645026-491a4a9b-e17d-421e-98be-e0be8b3bdf4d.png#averageHue=%23d7e2e9&clientId=uf497cce0-24e8-4&from=paste&height=426&id=ud6900061&originHeight=533&originWidth=1016&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=576485&status=done&style=none&taskId=ub08dc3a0-f76e-4c25-87b4-542d50f06b6&title=&width=812.8" alt="image.png"><br><strong>减法器：当sub等于1，做减法。Y按位取反后送到加法段，同时加上Cin达到末尾加1的效果，这个步骤其实是求Y的补码。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686635714536-adc3490c-3808-4359-bf80-fc716eab44e8.png#averageHue=%23dae4eb&clientId=uf497cce0-24e8-4&from=paste&height=350&id=ub70c074c&originHeight=438&originWidth=1016&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=503999&status=done&style=none&taskId=u801e4926-ffb8-401a-b883-115f76c27ed&title=&width=812.8" alt="image.png"><br><strong>补码加法运算中，不区分符号位和数值位。加法器执行的就是0，1序列的运算，没有符号区分。</strong></p><h4 id="实验程序："><a href="#实验程序：" class="headerlink" title="实验程序："></a>实验程序：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686636315842-382ee28c-1042-4254-a404-15cd6909f6f2.png#averageHue=%234b5545&clientId=uf497cce0-24e8-4&from=paste&height=558&id=u0a4346c7&originHeight=697&originWidth=574&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=775943&status=done&style=none&taskId=u76fd829a-1451-4ce6-bb0d-c0dd6bd03eb&title=&width=459.2" alt="image.png"></p><h4 id="实验过程："><a href="#实验过程：" class="headerlink" title="实验过程："></a>实验过程：</h4><p>1.编译程序和反汇编：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686636682204-48bc497d-7a12-46d7-85df-c5f316c60450.png#averageHue=%23642f1f&clientId=uf497cce0-24e8-4&from=paste&height=41&id=u93b47db1&originHeight=51&originWidth=523&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=47334&status=done&style=none&taskId=u817dbf3e-f587-413d-b207-c3e876bea6c&title=&width=418.4" alt="image.png"><br>2.查看反汇编文件：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686636792211-40768b50-a8b2-4928-a3b7-7b55b234f866.png#averageHue=%23a28068&clientId=uf497cce0-24e8-4&from=paste&height=280&id=ue3394880&originHeight=350&originWidth=695&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=324824&status=done&style=none&taskId=ubf43d476-719a-446a-8c9a-1b3c364662f&title=&width=556" alt="image.png"><br>3.在IA-32中带符号整数的加法和无符号底层采用的机器级的指令是一样的。实现带符号整数的加减运行和去符号整数的加减运算电路只有一个。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686638519778-3e6f4589-6bb0-43ec-9679-408218ec3b2d.png#averageHue=%23404b40&clientId=u20a15d3d-eb79-4&from=paste&height=226&id=uf700421d&originHeight=282&originWidth=639&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=292332&status=done&style=none&taskId=u9459aaa3-084c-454e-9ad4-f8c5611abf0&title=&width=511.2" alt="image.png"><br>MIPS指令系统中无符号加减运算指令不置溢出状态，也即输出的of都是0；<br>不同的指令体系都只有一个加减运算电路，只不过不同的指令体系的标志位的处理不一样。<br>4.调试该程序：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686639711401-d61ac2e5-4826-4d86-b4a0-3a8f5095d51c.png#averageHue=%23434e3e&clientId=u20a15d3d-eb79-4&from=paste&height=187&id=u00d64490&originHeight=234&originWidth=726&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=314724&status=done&style=none&taskId=u4ae490ee-e02f-4dd8-9a1c-15034205657&title=&width=580.8" alt="image.png"><br>5.总结：当sub为0时做减法，当sub为1时做加法，带符号整数的加减法运算采用补码形式让加减运算可以用同一个电路实现，不管无符号还是有符号其加减运算的机械数是一样的。</p><h2 id="整数加减运算的状态标志信息："><a href="#整数加减运算的状态标志信息：" class="headerlink" title="整数加减运算的状态标志信息："></a>整数加减运算的状态标志信息：</h2><h4 id="相关知识：OF-溢出标志，带符号整数是否超出范围；对于加法器来说只有同号相加有溢出；ZF-零标志位；SF：符号标志位，其结果为Sum的最高有效位；Count：加法器的最高有效位，有进位为1，没有为0；CF：进-借位信息；"><a href="#相关知识：OF-溢出标志，带符号整数是否超出范围；对于加法器来说只有同号相加有溢出；ZF-零标志位；SF：符号标志位，其结果为Sum的最高有效位；Count：加法器的最高有效位，有进位为1，没有为0；CF：进-借位信息；" class="headerlink" title="相关知识：OF:溢出标志，带符号整数是否超出范围；对于加法器来说只有同号相加有溢出；ZF:零标志位；SF：符号标志位，其结果为Sum的最高有效位；Count：加法器的最高有效位，有进位为1，没有为0；CF：进&#x2F;借位信息；;"></a>相关知识：OF:溢出标志，带符号整数是否超出范围；对于加法器来说只有同号相加有溢出；ZF:零标志位；SF：符号标志位，其结果为Sum的最高有效位；Count：加法器的最高有效位，有进位为1，没有为0；CF：进&#x2F;借位信息；<img src="https://cdn.nlark.com/yuque/__latex/37564aa9cf2b72dd19a28e0a5529cf5c.svg#card=math&code=CF%3DCount%5Coplus%20Sub%0A&id=yrmh2">;</h4><h4 id="查看标志寄存器："><a href="#查看标志寄存器：" class="headerlink" title="查看标志寄存器："></a>查看标志寄存器：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686641222573-65bb2160-1be0-4ed4-ad98-49619f33e321.png#averageHue=%23769069&clientId=u20a15d3d-eb79-4&from=paste&height=125&id=ucf134a04&originHeight=156&originWidth=559&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=161595&status=done&style=none&taskId=u5ed262aa-c070-4a23-801e-c9824dea6ff&title=&width=447.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686641230310-1fd68715-9f8c-4559-821a-a459dc63a10b.png#averageHue=%23e2e2e2&clientId=u20a15d3d-eb79-4&from=paste&height=109&id=uc340d345&originHeight=136&originWidth=386&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=16661&status=done&style=none&taskId=u06f6b269-6938-4eec-87bc-c12a72ebf75&title=&width=308.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686641319727-58e9beb5-7a32-41b0-b61c-6f98b333540c.png#averageHue=%23d3d2d2&clientId=u20a15d3d-eb79-4&from=paste&height=148&id=u5c7c4c74&originHeight=185&originWidth=387&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=37030&status=done&style=none&taskId=u0ed8559e-824a-4d65-ba38-2de454a1331&title=&width=309.6" alt="image.png"></p><h4 id="调试查看ua-ub运算的寄存器："><a href="#调试查看ua-ub运算的寄存器：" class="headerlink" title="调试查看ua+ub运算的寄存器："></a>调试查看ua+ub运算的寄存器：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686641836745-a860e12f-4bbc-4e9a-8408-b17943ae896f.png#averageHue=%23485440&clientId=u20a15d3d-eb79-4&from=paste&height=252&id=ucafe242f&originHeight=315&originWidth=631&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=377728&status=done&style=none&taskId=u0e113738-40d7-4e4b-a048-f8cdee9b284&title=&width=504.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686641860325-dcfe1c67-e04a-4c0b-87a7-7659dfbd3139.png#averageHue=%23e8e8e8&clientId=u20a15d3d-eb79-4&from=paste&height=128&id=ud03abc6c&originHeight=160&originWidth=377&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=21568&status=done&style=none&taskId=u15a0326f-015b-4dc8-9761-8650fbdf917&title=&width=301.6" alt="image.png"></p><h4 id="调试跟踪a-b的标注为："><a href="#调试跟踪a-b的标注为：" class="headerlink" title="调试跟踪a-b的标注为："></a>调试跟踪a-b的标注为：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686645186237-f2a75a10-32ef-4e0c-9869-7c63c3c7cb56.png#averageHue=%23545e46&clientId=u20a15d3d-eb79-4&from=paste&height=212&id=u934c0ec8&originHeight=265&originWidth=607&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=308049&status=done&style=none&taskId=u5cf09695-4e8e-4cd3-aed5-a92eeb0b3cb&title=&width=485.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686645689625-8c14ee71-f020-41be-86f9-00fcfc4eb174.png#averageHue=%23e4e4e4&clientId=u20a15d3d-eb79-4&from=paste&height=111&id=u9034977b&originHeight=139&originWidth=375&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=21283&status=done&style=none&taskId=u9573ade7-7867-41a4-9fb1-daee3b0e74d&title=&width=300" alt="image.png"></p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686643514521-367d68b2-a937-48e3-8cca-40897a3129d4.png#averageHue=%2376b56d&clientId=u20a15d3d-eb79-4&from=paste&height=50&id=u165aec3c&originHeight=63&originWidth=413&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=47044&status=done&style=none&taskId=ud1df09aa-5c82-4d5e-a2e0-ba3cfbf1c95&title=&width=330.4" alt="image.png">这里的”14 uc&#x3D;ua+ub;表示断点在14行，14行的内容是uc&#x3D;ua+ub;程序会停止在14行，其中14的内容没有执行；键入s会执行这条语句，同时会在屏幕显示是即将执行的语句；s选项是执行下一行语句（会过滤空行），遇到函数的时候进入函数内并停留在函数的第一行；n选项跟s一样，唯一的区别是n选项遇到函数时会直接执行函数；<br><a href="https://blog.csdn.net/qq_28351609/article/details/114855630?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168664212316782427480701%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168664212316782427480701&biz_id=0&spm=1018.2226.3001.4187">GDB调试命令详解_小桥流水人家_的博客-CSDN博客</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686645606274-e845d961-fcca-409c-a19d-33906a002035.png#averageHue=%23a84218&clientId=u20a15d3d-eb79-4&from=paste&height=43&id=u3c226ef0&originHeight=54&originWidth=422&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=37441&status=done&style=none&taskId=u5cebae93-5789-4ebf-aeab-dfb9a775e9d&title=&width=337.6" alt="image.png">这里表示si将要执行的是d&#x3D;a-b这条语句产生的指令的第一个指令。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686645656575-1c3d66a7-a38a-42e2-b3bf-0630577eedf5.png#averageHue=%235a6655&clientId=u20a15d3d-eb79-4&from=paste&height=46&id=ufb01565d&originHeight=57&originWidth=293&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=25625&status=done&style=none&taskId=u9c05a23a-b027-4c3f-b531-789c1f799b5&title=&width=234.4" alt="image.png">ud&#x3D;ua-ub;这条语句没有执行；</p><h2 id="整数加减结果溢出问题："><a href="#整数加减结果溢出问题：" class="headerlink" title="整数加减结果溢出问题："></a>整数加减结果溢出问题：</h2><h4 id="相关程序："><a href="#相关程序：" class="headerlink" title="相关程序："></a>相关程序：</h4><ol><li><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686646156135-684bbcad-8834-4620-a78a-7b2d7ca2a6f7.png#averageHue=%234e5a48&clientId=u20a15d3d-eb79-4&from=paste&height=535&id=u21ff110b&originHeight=669&originWidth=551&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=728595&status=done&style=none&taskId=u44d6ef6a-53c4-4bf4-bc22-a8cb4349aec&title=&width=440.8" alt="image.png"></li><li></li></ol><h4 id="编译运行程序："><a href="#编译运行程序：" class="headerlink" title="编译运行程序："></a>编译运行程序：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686646458419-621e8519-d61c-456f-ade4-4d6aeb91d39b.png#averageHue=%237b5c2f&clientId=u20a15d3d-eb79-4&from=paste&height=114&id=ud9da25ee&originHeight=143&originWidth=638&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=186757&status=done&style=none&taskId=u497c2652-2d9a-45a9-ae0d-68ebc9d915f&title=&width=510.4" alt="image.png"></p><h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686647272682-829784db-abee-47ae-a306-aafa9f408cc8.png#averageHue=%23d9dad9&clientId=u20a15d3d-eb79-4&from=paste&height=277&id=uc90faf0b&originHeight=346&originWidth=628&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=163856&status=done&style=none&taskId=u71ca6d76-fc6b-431d-8798-dcc08982726&title=&width=502.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686647318423-0d44a469-42df-4014-9351-4f19ab2518ad.png#averageHue=%23c4c4c3&clientId=u20a15d3d-eb79-4&from=paste&height=215&id=ub87c4180&originHeight=269&originWidth=542&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=103521&status=done&style=none&taskId=uc1058e39-8606-4236-b3e7-678aca9f25d&title=&width=433.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686647608245-5985da30-fb26-4e8a-8d0f-1160e6396c6b.png#averageHue=%23d3dae0&clientId=u20a15d3d-eb79-4&from=paste&height=266&id=u9b5581ca&originHeight=332&originWidth=717&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=195462&status=done&style=none&taskId=uee967e3d-c611-4e23-93b4-577073142a1&title=&width=573.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686647745257-00c70c26-ba8a-4c2a-aa5b-bd37efcac214.png#averageHue=%23ced6dc&clientId=u20a15d3d-eb79-4&from=paste&height=333&id=u3f1fa853&originHeight=416&originWidth=860&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=409721&status=done&style=none&taskId=u743484d3-3044-4eaa-8e83-4efad337c12&title=&width=688" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686647868554-883381d7-d0d8-48d2-8f52-ab23634c6ab0.png#averageHue=%23c6cdd3&clientId=u20a15d3d-eb79-4&from=paste&height=358&id=ud6a8e5da&originHeight=447&originWidth=736&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=340700&status=done&style=none&taskId=ua890f49e-c3e1-429a-8acd-21656b70271&title=&width=588.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686648523146-3436058e-91e6-4c39-b7b3-977b7c28f715.png#averageHue=%23eee9e8&clientId=u20a15d3d-eb79-4&from=paste&height=209&id=u4f2b76f3&originHeight=261&originWidth=705&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=152563&status=done&style=none&taskId=ub25b2a0c-ae6e-4197-961b-5b587da0c0c&title=&width=564" alt="image.png"><br>整型转换和截断操作本身并不会改变 CF 和 OF 标志位的值。</p><h2 id="IEEE-754浮点数标准："><a href="#IEEE-754浮点数标准：" class="headerlink" title="IEEE 754浮点数标准："></a>IEEE 754浮点数标准：</h2><h4 id="相关知识：-1"><a href="#相关知识：-1" class="headerlink" title="相关知识："></a>相关知识：</h4><p> <img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686649122338-0fae6f93-e922-495d-bd32-2ade9a1e637f.png#averageHue=%23d1dde5&clientId=u20a15d3d-eb79-4&from=paste&height=277&id=ud684c33d&originHeight=346&originWidth=704&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=232114&status=done&style=none&taskId=ucc39b240-f390-4b86-957c-58f8cc6b434&title=&width=563.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686649324498-21c90caa-7ea2-47ae-9c81-5315feb6ef30.png#averageHue=%23dbe3e9&clientId=u20a15d3d-eb79-4&from=paste&height=302&id=u26a5b0c5&originHeight=377&originWidth=783&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=312157&status=done&style=none&taskId=ucbd3a139-e019-4e50-879c-759cea19b16&title=&width=626.4" alt="image.png"><br>规格化数：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686649361681-f6b955a4-fa8e-41a6-9cd4-f8ade23a887c.png#averageHue=%23dbe3e9&clientId=u20a15d3d-eb79-4&from=paste&height=151&id=u2ef0daf6&originHeight=189&originWidth=682&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=132636&status=done&style=none&taskId=ua06bfe29-cc49-4ad2-8e15-95dc1fb9296&title=&width=545.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686649414122-1f252fe3-82d5-4aad-8d07-4880fc934c0d.png#averageHue=%23dae1e6&clientId=u20a15d3d-eb79-4&from=paste&height=128&id=ue5fc6ff8&originHeight=160&originWidth=670&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=115166&status=done&style=none&taskId=u8a3d469b-a6da-45e6-9f6f-8e974baf6e6&title=&width=536" alt="image.png"><br>非规格化数：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686649464472-191f2baa-647e-41db-80ea-fd27d68dca68.png#averageHue=%23dce3e8&clientId=u20a15d3d-eb79-4&from=paste&height=142&id=u2e1d70a4&originHeight=178&originWidth=647&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=118673&status=done&style=none&taskId=u9e820a2b-b044-4a96-a005-bc8ccd3edfe&title=&width=517.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686649483103-c3250154-9c5b-4f97-8115-ef25db9d87c2.png#averageHue=%23d7dfe5&clientId=u20a15d3d-eb79-4&from=paste&height=113&id=ucfb99266&originHeight=141&originWidth=694&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=108768&status=done&style=none&taskId=u77158be9-6018-42bb-95b0-37110eb0c74&title=&width=555.2" alt="image.png"></p><h4 id="测试程序代码："><a href="#测试程序代码：" class="headerlink" title="测试程序代码："></a>测试程序代码：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686658767252-a48bdc28-dbfc-4510-9788-4e31d202c070.png#averageHue=%23926956&clientId=u20a15d3d-eb79-4&from=paste&height=388&id=u259752a2&originHeight=485&originWidth=984&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=668299&status=done&style=none&taskId=u0abb24f3-3737-4c6a-a4de-b5b42151266&title=&width=787.2" alt="image.png"></p><h4 id="编译运行："><a href="#编译运行：" class="headerlink" title="编译运行："></a>编译运行：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686659293043-6550c2c1-a547-45ee-8e8f-78f30ecb53e5.png#averageHue=%23361e42&clientId=u20a15d3d-eb79-4&from=paste&height=34&id=uabe307b3&originHeight=43&originWidth=501&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=26341&status=done&style=none&taskId=u2a02bf70-700c-4662-af59-b89748ef62d&title=&width=400.8" alt="image.png">这里需要选择-g选项，表示生成调试信息，不然后面调试中输入l选项会报：No symbol table is loaded. Use the “file” command.错误<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686658804667-5365fd9e-f756-4eb5-b0c5-7464e72ad75f.png#averageHue=%231e4586&clientId=u20a15d3d-eb79-4&from=paste&height=191&id=uf52ff2be&originHeight=239&originWidth=610&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=213048&status=done&style=none&taskId=ua9cb4717-4847-4b4b-a9d9-7c64f143f5a&title=&width=488" alt="image.png"></p><h4 id="反编译："><a href="#反编译：" class="headerlink" title="反编译："></a>反编译：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686658949718-69920efa-2a59-4751-b298-bb6ed513a5d1.png#averageHue=%2325447c&clientId=u20a15d3d-eb79-4&from=paste&height=46&id=u87e5daee&originHeight=57&originWidth=590&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=47418&status=done&style=none&taskId=u3b5f9014-44bf-4751-b254-ff1a3ac8135&title=&width=472" alt="image.png"></p><h4 id="调试追踪程序："><a href="#调试追踪程序：" class="headerlink" title="调试追踪程序："></a>调试追踪程序：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686660320423-29f47887-cb9f-477a-9305-cda3f9cc0077.png#averageHue=%23303063&clientId=u20a15d3d-eb79-4&from=paste&height=360&id=ufc51f0f7&originHeight=450&originWidth=709&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=418093&status=done&style=none&taskId=uc152b2c3-b50b-41ec-8954-12a66e5fa3c&title=&width=567.2" alt="image.png"><br>x&#x2F;23xw $esp:23是(R[ebp]-R[esp]+4)&#x2F;4得到的，求的是栈的大小，这里的w是4字节显示也即选取4字节然后显示出来，这里显示出来的结果以及处理过了的，显示的内容不是小段方式了。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686660561230-7e690755-ffa8-4647-81ee-7e938d9ad6a2.png#averageHue=%23f4e8e2&clientId=u20a15d3d-eb79-4&from=paste&height=55&id=u184f4d9e&originHeight=69&originWidth=687&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=15302&status=done&style=none&taskId=uf9b537b9-8912-4d48-a78f-38718d3be57&title=&width=549.6" alt="image.png">这里看出-0x4c(%ebp)&#x3D;0xffffd3fc(内容是0x7f8000000阶码全为1，尾数全为0，这里已经处理过了，不用按照小段方式处理了)处的内容是无穷大。</p><h2 id="尾数舍入问题："><a href="#尾数舍入问题：" class="headerlink" title="尾数舍入问题："></a>尾数舍入问题：</h2><h4 id="程序代码：1-与IEEE-754的代码一致"><a href="#程序代码：1-与IEEE-754的代码一致" class="headerlink" title="程序代码：1.与IEEE 754的代码一致"></a>程序代码：1.与IEEE 754的代码一致</h4><h4 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h4><p>1，定义的0.1但是print的结果与0.1有出入？<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686661136042-ab684d26-f88d-444e-9db0-a4a970b599d3.png#averageHue=%233e6c32&clientId=u20a15d3d-eb79-4&from=paste&height=24&id=u86f9bbc4&originHeight=30&originWidth=351&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=17173&status=done&style=none&taskId=u65d3d9b7-1ddc-4f75-8e93-25cb2949527&title=&width=280.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686661147426-d2af6fc8-5df5-438a-8e7a-9ddc9d4e5915.png#averageHue=%231e5b9f&clientId=u20a15d3d-eb79-4&from=paste&height=26&id=ueb118978&originHeight=33&originWidth=349&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=19076&status=done&style=none&taskId=u392876fc-26ad-4560-ae6d-9d166f58839&title=&width=279.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686661207165-87ad4bb8-ec35-4bcb-a761-afc45fd97f37.png#averageHue=%23d3dce4&clientId=u20a15d3d-eb79-4&from=paste&height=292&id=u0b3128b3&originHeight=365&originWidth=1059&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=464760&status=done&style=none&taskId=u12ac06fd-6a3a-4275-b510-9d2cc64c83e&title=&width=847.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686661227252-308fcb49-d122-41be-a96b-cf518b468646.png#averageHue=%23cdd8e1&clientId=u20a15d3d-eb79-4&from=paste&height=47&id=uf1f5ce29&originHeight=59&originWidth=610&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=56470&status=done&style=none&taskId=u0557e27a-25aa-493b-ade3-bdfbb8960d9&title=&width=488" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686661236725-f7fda7b1-75d5-4f74-9cfc-16fa88c98df7.png#averageHue=%23ccd7e0&clientId=u20a15d3d-eb79-4&from=paste&height=46&id=u050a3e12&originHeight=57&originWidth=632&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=56092&status=done&style=none&taskId=u46b4014e-bb21-44da-a0be-44a0dbc8ded&title=&width=505.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686661260710-73ca8cad-5666-40a9-b570-813e2eae8a1a.png#averageHue=%23cfdae3&clientId=u20a15d3d-eb79-4&from=paste&height=109&id=u18ca58bf&originHeight=136&originWidth=572&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=117845&status=done&style=none&taskId=u0f2aa6c1-ac84-4dd2-98ff-13182101f23&title=&width=457.6" alt="image.png">（有隐藏1）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686661284860-f1beda9d-f8da-4325-bfa2-d42979d86643.png#averageHue=%23bdcbd7&clientId=u20a15d3d-eb79-4&from=paste&height=35&id=u00163263&originHeight=44&originWidth=574&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=44432&status=done&style=none&taskId=ufe311036-dfa0-48ad-a5b7-ddc22ca6188&title=&width=459.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686661325119-67e01597-3060-43b5-b236-edfbbada1b3a.png#averageHue=%23ccd7e0&clientId=u20a15d3d-eb79-4&from=paste&height=106&id=ua545bfcb&originHeight=133&originWidth=883&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=209915&status=done&style=none&taskId=u0e2ad06e-445f-4eb9-a5c3-1ebdc45405e&title=&width=706.4" alt="image.png"></p><h4 id="4种舍入标准："><a href="#4种舍入标准：" class="headerlink" title="4种舍入标准："></a>4种舍入标准：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686661376087-fb7cc8d2-f6e4-4b3a-afe3-aa816b43daa1.png#averageHue=%23d1dce5&clientId=u20a15d3d-eb79-4&from=paste&height=151&id=ue0ed86fd&originHeight=189&originWidth=510&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=122289&status=done&style=none&taskId=u1e663fe0-2d28-41bf-9f34-8cdf24df54f&title=&width=408" alt="image.png"><br> <img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686661408195-3a6ab84a-0feb-418f-a613-034c9192622e.png#averageHue=%23dce4eb&clientId=u20a15d3d-eb79-4&from=paste&height=158&id=u0018a924&originHeight=198&originWidth=840&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=172050&status=done&style=none&taskId=u209a0da4-d0d6-4146-b1c0-4136008804f&title=&width=672" alt="image.png"><br>意味着a,b之间的数据只能用a,b近似表示；<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686661451694-8c632b36-a22b-4244-aca8-f29fc2af0c9d.png#averageHue=%23969fa7&clientId=u20a15d3d-eb79-4&from=paste&height=44&id=u88af7bc2&originHeight=55&originWidth=461&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=40320&status=done&style=none&taskId=uf1fed143-aa42-40c6-8795-84b27db9815&title=&width=368.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686661740325-eab301c6-17be-4cc5-8fc3-f28bbc25e722.png#averageHue=%23cad8e3&clientId=u20a15d3d-eb79-4&from=paste&height=446&id=u0d273412&originHeight=558&originWidth=1015&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=709850&status=done&style=none&taskId=u8948f302-de00-4ad5-94a3-3b04209d60d&title=&width=812" alt="image.png"></p><h2 id="浮点数的基本运算："><a href="#浮点数的基本运算：" class="headerlink" title="浮点数的基本运算："></a>浮点数的基本运算：</h2><h4 id="相关知识点："><a href="#相关知识点：" class="headerlink" title="相关知识点："></a>相关知识点：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686662310902-dab74e6d-cc37-4c43-8bab-77011a9f61dc.png#averageHue=%23dcdcdb&clientId=u20a15d3d-eb79-4&from=paste&height=247&id=u5a6ef67e&originHeight=309&originWidth=618&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=123196&status=done&style=none&taskId=ufb486c06-dd50-4292-9074-2f072be9b65&title=&width=494.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686662347830-d402e15c-c983-4dbe-82e2-65bd731f8d9b.png#averageHue=%23c7c7c6&clientId=u20a15d3d-eb79-4&from=paste&height=258&id=ubdd86621&originHeight=323&originWidth=697&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=159707&status=done&style=none&taskId=u085a0fd5-8e79-4b3a-9e18-44ec2509ecb&title=&width=557.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686670221517-0bbc388a-0135-4663-b20a-06f2bd3d1ab4.png#averageHue=%23e4e4e3&clientId=u20a15d3d-eb79-4&from=paste&height=230&id=ub028fdaa&originHeight=288&originWidth=480&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=91905&status=done&style=none&taskId=u2a6050d5-fc57-476b-ba92-0ff0c018791&title=&width=384" alt="image.png"></p><h4 id="模拟0-1相关的爱国者导弹问题程序："><a href="#模拟0-1相关的爱国者导弹问题程序：" class="headerlink" title="模拟0.1相关的爱国者导弹问题程序："></a>模拟0.1相关的爱国者导弹问题程序：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686670797708-d5eaf847-9fc7-4595-be36-f058c2d46467.png#averageHue=%23323066&clientId=u20a15d3d-eb79-4&from=paste&height=601&id=u56dd931f&originHeight=751&originWidth=780&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=702821&status=done&style=none&taskId=ueb2e46e9-4a23-4ca8-8ac2-838e5c35eb5&title=&width=624" alt="image.png"></p><h4 id="编译运行：-1"><a href="#编译运行：-1" class="headerlink" title="编译运行："></a>编译运行：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686670911992-7299be9b-bc8e-4a42-985a-fff91abfd2a7.png#averageHue=%231c3976&clientId=u20a15d3d-eb79-4&from=paste&height=115&id=u869659b4&originHeight=144&originWidth=568&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=130485&status=done&style=none&taskId=ue13ed1ff-65c6-4b0b-8a9a-26b64791089&title=&width=454.4" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>课程作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机基础课后期末复习</title>
    <link href="/2024/01/26/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%9A/"/>
    <url>/2024/01/26/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="第一章："><a href="#第一章：" class="headerlink" title="第一章："></a>第一章：</h2><p>1.冯诺依曼研究的计算机不是第一台存储结构的计算机。<br>2。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687074892884-661239a4-90e7-4bc5-848b-af0a00634894.png#averageHue=%23f3f3f3&clientId=u7a700a2e-d781-4&from=paste&height=169&id=u29502497&originHeight=211&originWidth=641&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=12072&status=done&style=none&taskId=ue3e21772-7861-4217-b942-97cec331463&title=&width=512.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687075672801-d1fb4af4-4fe2-43be-99fa-10a509ea73e5.png#averageHue=%23f5dad0&clientId=u7a700a2e-d781-4&from=paste&height=198&id=uec2c0ed3&originHeight=247&originWidth=1134&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=152121&status=done&style=none&taskId=u790c7516-e2c1-4e4b-aa18-cd199d291a3&title=&width=907.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687076054310-4fb49b11-55db-4dea-ac4f-d09fe8e7f6b6.png#averageHue=%23f8ece8&clientId=u7a700a2e-d781-4&from=paste&height=428&id=u03fb9077&originHeight=535&originWidth=1326&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=343670&status=done&style=none&taskId=u0e20936d-b84b-4241-adc7-ad7d5203f6e&title=&width=1060.8" alt="image.png"><br>1.浮点数的阶码用移码表示是因为移码在比较大小的时候可以改变符号位带来的影响。<br>1.<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687079581752-9dff08b2-1ac6-4215-ab94-8934d57bea63.png#averageHue=%23faf5f4&clientId=u7a700a2e-d781-4&from=paste&height=246&id=u68ac9d12&originHeight=308&originWidth=583&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=28810&status=done&style=none&taskId=u24f86a24-e45b-42fb-874f-76ddf7e5903&title=&width=466.4" alt="image.png">变形补码如果2个符号位相同则没有溢出，不同就溢出了。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687084965957-1f6f0d41-56ad-42ec-9daa-2f28bba2c40f.png#averageHue=%23d5d5d5&clientId=ud1688b1c-f083-4&from=paste&height=60&id=ucf7b6d65&originHeight=75&originWidth=982&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=35798&status=done&style=none&taskId=u872aa925-825e-46f0-8039-8b64f21db7f&title=&width=785.6" alt="image.png"><br>0&#x2F;0的结果为非数。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687085905199-f7015f9b-d86a-4c41-894c-9e54b5aaef81.png#averageHue=%23f6f5f3&clientId=ud1688b1c-f083-4&from=paste&height=282&id=u903d3657&originHeight=352&originWidth=773&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=45445&status=done&style=none&taskId=u10970eca-8b67-43b0-8360-660f9327c74&title=&width=618.4" alt="image.png"><br>浮点数float型的数据类型的有效位数最高为7位。<br>字长是数据通路的宽度（寄存器的宽度，ALU运算的宽度，传输路径上的宽度），IA-32架构字长是32位。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687090831737-aac5d7b4-1405-4e8e-a10e-092c93350f68.png#averageHue=%23f9f8f7&clientId=ud1688b1c-f083-4&from=paste&height=379&id=ud83a47b3&originHeight=474&originWidth=1110&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=65104&status=done&style=none&taskId=u014d3b58-acc3-4f55-9860-2166a72077f&title=&width=888" alt="image.png"><br>对于A选项，是先将f的真值用32位的int表示，其真值位1234.5其小数部分会被截断损失。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687090914398-c2f2e37d-125f-478c-944c-c1cafe94bcbd.png#averageHue=%23faf9f8&clientId=ud1688b1c-f083-4&from=paste&height=283&id=ueb567853&originHeight=354&originWidth=1085&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=42150&status=done&style=none&taskId=u76597a50-f032-4a53-9976-3ef67a03ed5&title=&width=868" alt="image.png"><br>（不同的指令其长度不一样）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687093510841-aed589bc-61e7-42ba-bfbf-061556ab67df.png#averageHue=%23f7d7a3&clientId=ud1688b1c-f083-4&from=paste&height=155&id=u8d734d1f&originHeight=194&originWidth=594&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=79642&status=done&style=none&taskId=u11f9d2f6-ae3a-4f74-96bc-b8140160777&title=&width=475.2" alt="image.png">（若是带符号整数其乘积的结果大于最大的int范围就会反转为负数，得到的高n为全为0或者1则没有溢出，否则溢出）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687094666759-99ee8c53-8d95-486f-bcc2-35fa6bf49805.png#averageHue=%23f8dcb0&clientId=ud1688b1c-f083-4&from=paste&height=131&id=uad12239a&originHeight=164&originWidth=894&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=143626&status=done&style=none&taskId=ub2cdd32a-efe6-4b2f-844b-8f64832ca44&title=&width=715.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687094732935-8a0a5b8d-39f4-479f-82c5-22ec42ca734c.png#averageHue=%23cfcecb&clientId=ud1688b1c-f083-4&from=paste&height=62&id=u798fbfe7&originHeight=78&originWidth=949&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=56232&status=done&style=none&taskId=ua24b490d-9264-4d5f-ad98-9cea0250f25&title=&width=759.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687102280483-b2de2c1d-88a7-4e21-ad65-011abf9c36a1.png#averageHue=%23f9f8f7&clientId=uc67fcce9-c2c2-4&from=paste&height=455&id=u5f4e9dd2&originHeight=569&originWidth=1108&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=81464&status=done&style=none&taskId=u0be441a1-e72b-4268-8ae0-c3a4b8cfa92&title=&width=886.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687102424723-5aab7545-b083-491f-9f15-9f21f2e7fb92.png#averageHue=%23fafaf9&clientId=uc67fcce9-c2c2-4&from=paste&height=377&id=u7ec98900&originHeight=471&originWidth=1054&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=41626&status=done&style=none&taskId=u19444912-60d5-483a-b7a8-78fe638e41f&title=&width=843.2" alt="image.png">（为什么是25为因为在进行尾数相加的时候会保留符号位，附加位，粘位，当移动25位的时候尾数的符号位+附加位+粘位可能是：010，011都是小于100的情况，都是要舍入的，如果是24位或者是23位都会可能发生进位的情况。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687102703442-1bb6cb00-59a6-4eed-bf85-68afa7221ebe.png#averageHue=%23fbf7f6&clientId=uc67fcce9-c2c2-4&from=paste&height=656&id=u0cd6254f&originHeight=820&originWidth=1064&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=95515&status=done&style=none&taskId=uf5f308dd-fc16-439e-88b4-58b59aa029d&title=&width=851.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687136125858-5bcda0df-6619-413c-a4b6-2461cd24f4de.png#averageHue=%23f8f7f6&clientId=uc67fcce9-c2c2-4&from=paste&height=237&id=u2889776e&originHeight=296&originWidth=787&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=27779&status=done&style=none&taskId=u33ded9a3-d8ce-4f53-893a-bdd321d55c0&title=&width=629.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687137049082-b374bd94-9c29-42cc-ab49-413cd389ffe9.png#averageHue=%23fbfaf9&clientId=uc67fcce9-c2c2-4&from=paste&height=325&id=uf5a786d5&originHeight=406&originWidth=920&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=52635&status=done&style=none&taskId=u1bb98632-83ed-499c-b4ee-cbee1495a9a&title=&width=736" alt="image.png">汇编指令是机器指令的助记符号，需要转变位机器指令才能执行。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687137139094-d6b39db8-6d72-404e-a25c-e2589aaaf766.png#averageHue=%23fbfbfa&clientId=uc67fcce9-c2c2-4&from=paste&height=319&id=ua5b02a04&originHeight=399&originWidth=839&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=26721&status=done&style=none&taskId=u4dc38799-d7d3-495a-93ca-2b7fed3c705&title=&width=671.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687137168047-74ba7503-2a45-4801-b731-f633bfb914d1.png#averageHue=%23fbfaf9&clientId=uc67fcce9-c2c2-4&from=paste&height=323&id=uc6fc5904&originHeight=404&originWidth=825&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=49914&status=done&style=none&taskId=ub770d9e1-4884-444a-8d43-d2a2e03fff0&title=&width=660" alt="image.png">指令中的寄存器可能是ax<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687137214095-63f1839f-e11e-4d98-9fd8-f9026effaadb.png#averageHue=%23faf9f8&clientId=uc67fcce9-c2c2-4&from=paste&height=310&id=u78859393&originHeight=388&originWidth=850&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=48714&status=done&style=none&taskId=u84a5f577-e9f1-4852-a9ca-e6bb1402c0c&title=&width=680" alt="image.png">只有EAX,EBX,ECX,ED可以这样，其余通用寄存器保留当中8位寄存器使用。<br>布斯乘法：<br><a href="https://blog.csdn.net/skl4869/article/details/120829532">布斯（booth）乘法详解和例子_booth乘法_某六十九岁合法萝莉的博客-CSDN博客</a><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687151012238-6991f46b-e509-4ace-81a7-88c9ec18591b.png#averageHue=%23fdfaf9&clientId=uc67fcce9-c2c2-4&from=paste&height=342&id=u0259658b&originHeight=428&originWidth=1190&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=36209&status=done&style=none&taskId=u29a96197-7269-4927-bba5-4895586f701&title=&width=952" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687151033074-c5ea92dd-b74d-497c-b97a-aa83dc8226c7.png#averageHue=%23faf9f9&clientId=uc67fcce9-c2c2-4&from=paste&height=381&id=u85e86c6f&originHeight=476&originWidth=1098&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=50347&status=done&style=none&taskId=u26cf64c4-b096-4e2f-9683-9b3cd271692&title=&width=878.4" alt="image.png">（有减法运算时求CF一定将其减数转化为补码在运算）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687151075994-772ff53c-c8b2-475f-be30-c2675b0a6b4d.png#averageHue=%23faf9f8&clientId=uc67fcce9-c2c2-4&from=paste&height=353&id=u97348b65&originHeight=441&originWidth=1081&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=54865&status=done&style=none&taskId=u486d58e9-532b-49a4-b647-9a371e760bc&title=&width=864.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687156162258-a99a2085-5a5b-45fb-a227-507b18acce66.png#averageHue=%23fbfafa&clientId=ue180da2c-b857-4&from=paste&height=361&id=u55668b0c&originHeight=451&originWidth=1075&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=39982&status=done&style=none&taskId=u328ff7d3-9491-46c8-9b30-6546bfb72ae&title=&width=860" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687156182794-a97cc52b-69f3-4521-b03e-20f8d9b190b6.png#averageHue=%23fbfaf9&clientId=ue180da2c-b857-4&from=paste&height=354&id=uafb997b2&originHeight=443&originWidth=1083&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=43606&status=done&style=none&taskId=uc1b3ebc2-9675-451e-8e03-8a097c7875e&title=&width=866.4" alt="image.png"><br>（这里要注意A选项，为了体系else关键字，汇编语句中一定包含无条件跳转指令）<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687159267242-94e41de6-9d00-448f-b733-34b51e9d5a94.png#averageHue=%23fdf9f9&clientId=ue180da2c-b857-4&from=paste&height=354&id=u1ff9efef&originHeight=443&originWidth=1059&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=40585&status=done&style=none&taskId=u3625dce8-8662-4348-966b-a9ed678245d&title=&width=847.2" alt="image.png"><br>（这里要求送的是首地址）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687168489104-82da4674-e4b1-44aa-a2cc-bef1d654ec28.png#averageHue=%23fcf7f6&clientId=ufa541de4-9c4f-4&from=paste&height=301&id=u46e05049&originHeight=376&originWidth=1035&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=38802&status=done&style=none&taskId=u9e810193-76d2-4da2-a071-eeacfcc6e64&title=&width=828" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687168534461-7a8050b7-4953-43a7-8c4b-d6c8eab454e8.png#averageHue=%23f9f9f8&clientId=ufa541de4-9c4f-4&from=paste&height=314&id=u9a67ab8e&originHeight=392&originWidth=1022&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=42163&status=done&style=none&taskId=uef27aff5-3b24-4bc0-861f-0005e38be17&title=&width=817.6" alt="image.png"><br>（还需要指明是动态链接还是静态链接）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687183700317-ea29635d-0826-44da-909f-acdbf2f916f2.png#averageHue=%23fcfbfb&clientId=uc7f32047-918b-4&from=paste&height=633&id=u23375bcd&originHeight=791&originWidth=833&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=49214&status=done&style=none&taskId=uf2b4d17d-c98c-45c0-9c59-890fed64d40&title=&width=666.4" alt="image.png"><br>（ m1中的main()函数和m2中定义的静态变量main是不一样的符号）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687183811809-15300667-de81-44e7-b7fc-d729273262db.png#averageHue=%23fdfdfd&clientId=uc7f32047-918b-4&from=paste&height=675&id=ua924dccf&originHeight=844&originWidth=1179&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=48633&status=done&style=none&taskId=u0a312d08-214e-4659-a199-0b34bbc3f6e&title=&width=943.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687183875756-3747f935-476b-41e9-9ed6-c907ac6a61b6.png#averageHue=%23f3f2f0&clientId=uc7f32047-918b-4&from=paste&height=124&id=u76cfee2a&originHeight=155&originWidth=1022&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=26522&status=done&style=none&taskId=ubae7a322-ba04-41da-94cc-1e1d2469615&title=&width=817.6" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>课程作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机基础课后习题总结</title>
    <link href="/2024/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%A0%E9%A2%98%E5%9F%BA%E7%A1%80%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2024/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%A0%E9%A2%98%E5%9F%BA%E7%A1%80%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1684851467275-00964e2a-5deb-4067-aea0-69b11853d85c.png#averageHue=%23f4f4f4&clientId=u4f1f22a4-8607-4&from=paste&height=378&id=u0b9dadb6&originHeight=473&originWidth=1361&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=243523&status=done&style=none&taskId=u9463a71b-1896-4582-9e7e-1ee1a9f55ce&title=&width=1088.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1684851511250-ecf15526-3444-4862-bbac-c972e9001a12.png#averageHue=%23eeeeed&clientId=u4f1f22a4-8607-4&from=paste&height=571&id=u1e7a0773&originHeight=714&originWidth=522&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=404911&status=done&style=none&taskId=u91f731dd-6a34-411a-a380-132f7e458ec&title=&width=417.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1684851541422-88fd2990-e7b7-428b-ae6d-524f7e779f02.png#averageHue=%23f2f2f2&clientId=u4f1f22a4-8607-4&from=paste&height=462&id=uf4b60017&originHeight=578&originWidth=1336&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=334070&status=done&style=none&taskId=u4a16c27a-eb69-4cf6-8aa2-ccc77741ee6&title=&width=1068.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1684851604529-c79aff0d-931f-467f-9320-025057cc92c1.png#averageHue=%23eeeded&clientId=u4f1f22a4-8607-4&from=paste&height=153&id=ua369e3e1&originHeight=191&originWidth=722&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=123426&status=done&style=none&taskId=u1342e278-b97d-4a48-9ca0-2973edcd0e1&title=&width=577.6" alt="image.png"></p><h4 id="（4）十进制转化为BCD码是每个数对应一个BCD码"><a href="#（4）十进制转化为BCD码是每个数对应一个BCD码" class="headerlink" title="（4）十进制转化为BCD码是每个数对应一个BCD码"></a>（4）十进制转化为BCD码是每个数对应一个BCD码</h4><h4 id="为什么计算机处理汉字时会涉及不同的编码-如，输入码、内码、字模码-？说明这些-编码中哪些用二进制编码，哪些不用二进制编码，为什么？"><a href="#为什么计算机处理汉字时会涉及不同的编码-如，输入码、内码、字模码-？说明这些-编码中哪些用二进制编码，哪些不用二进制编码，为什么？" class="headerlink" title="为什么计算机处理汉字时会涉及不同的编码(如，输入码、内码、字模码)？说明这些 编码中哪些用二进制编码，哪些不用二进制编码，为什么？"></a>为什么计算机处理汉字时会涉及不同的编码(如，输入码、内码、字模码)？说明这些 编码中哪些用二进制编码，哪些不用二进制编码，为什么？</h4><p>计算机处理汉字时会涉及不同的编码，主要是因为汉字有很多，而计算机只能处理二进制数据，因此需要将汉字转换为计算机可以理解的二进制编码。不同的编码方式可以用来表示不同的汉字，以及在不同的应用场景中使用。<br>以下是常见的汉字编码方式：</p><ol><li>输入码：输入码是指用户在输入汉字时所使用的编码，例如五笔、拼音等。输入码不是二进制编码，而是一种文字描述的编码方式，用来表示汉字的发音或笔画。</li><li>内码：内码是计算机内部使用的编码方式，用来表示汉字在计算机内部存储时的二进制编码。内码通常使用16位或32位的二进制数来表示一个汉字。</li><li>字模码：字模码是指将汉字转换为点阵图形所使用的编码方式，也就是将汉字转换为显示在屏幕上的像素图形。字模码通常使用8位或16位的二进制编码来表示一个汉字的点阵图形。</li></ol><p>其中，输入码和字模码不是二进制编码，而是使用文字描述或点阵图形表示汉字，因为它们更加符合人类的直观认知和使用习惯。而内码则是计算机内部使用的二进制编码方式，因为计算机只能处理二进制数据，内码可以直接被计算机处理和运算。<br>不同的编码方式在不同的应用场景中使用，例如输入码用于用户在输入汉字时进行转换，字模码用于在屏幕上显示汉字，而内码用于在计算机内部存储和处理汉字数据。在实际应用中，常常需要进行不同编码之间的转换，以满足不同需求的数据处理和显示。</p><h4 id="整数的移码"><a href="#整数的移码" class="headerlink" title="整数的移码"></a>整数的移码</h4><p><a href="https://blog.csdn.net/u011240016/article/details/53010061">移码的再总结_11位移码最大是多少_DrCrypto的博客-CSDN博客</a></p><h4 id="下述格式浮点数表示"><a href="#下述格式浮点数表示" class="headerlink" title="下述格式浮点数表示"></a>下述格式浮点数表示</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1684853258030-a1276b69-4f3e-4ce7-97f1-810be34249c2.png#averageHue=%23f4f4f4&clientId=ubebfedef-06f8-4&from=paste&height=126&id=uee0b27ba&originHeight=158&originWidth=972&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=55878&status=done&style=none&taskId=u8c1d059f-7eb1-457d-8f16-b19a7e4e56a&title=&width=777.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1684853300147-67acfb2f-c754-4d40-b9e5-571aff65d9db.png#averageHue=%23e5e5e5&clientId=ubebfedef-06f8-4&from=paste&height=141&id=uc89b08a8&originHeight=176&originWidth=718&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=102733&status=done&style=none&taskId=ud057ac1b-61b3-4eaa-a51e-eb8a87c9ab8&title=&width=574.4" alt="image.png"></p><h4 id="IEEE754最大数最小数等相关内容"><a href="#IEEE754最大数最小数等相关内容" class="headerlink" title="IEEE754最大数最小数等相关内容"></a>IEEE754最大数最小数等相关内容</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1684853460679-c014a09f-19ca-4c72-bd16-0ff05a270101.png#averageHue=%23eeeeee&clientId=ubebfedef-06f8-4&from=paste&height=226&id=ucda092ca&originHeight=283&originWidth=714&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=166446&status=done&style=none&taskId=u47b4901d-9dd4-4327-b19e-1035c7a4886&title=&width=571.2" alt="image.png"></p><h4 id="判断是否溢出函数"><a href="#判断是否溢出函数" class="headerlink" title="判断是否溢出函数"></a>判断是否溢出函数</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1684853556242-e746bd33-d537-4d9c-b63f-14c0553d9dba.png#averageHue=%23eeeeee&clientId=ubebfedef-06f8-4&from=paste&height=130&id=ud791e992&originHeight=163&originWidth=1311&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=104888&status=done&style=none&taskId=ua417a440-6104-47ac-aed2-a282f12f343&title=&width=1048.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1684853572398-d0b97512-3752-4669-a255-0317dbe8d8e7.png#averageHue=%23eeeeed&clientId=ubebfedef-06f8-4&from=paste&height=234&id=u39d4bbd4&originHeight=293&originWidth=431&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=121873&status=done&style=none&taskId=u938ab261-6b55-4749-a3b4-97e39319379&title=&width=344.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1684853686129-583edfed-fa60-41af-93cd-db1f4a367a38.png#averageHue=%23f0f0f0&clientId=ubebfedef-06f8-4&from=paste&height=228&id=uc7b93efc&originHeight=285&originWidth=1347&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=173687&status=done&style=none&taskId=u6d9b6332-d8e3-4863-8d92-f40277510b3&title=&width=1077.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1684853712946-86466093-28d6-4c8c-95f7-ff923de448c7.jpeg#averageHue=%234f4f4f&clientId=ubebfedef-06f8-4&from=paste&height=1920&id=u6b2ddd27&originHeight=2400&originWidth=1080&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=354459&status=done&style=none&taskId=udcf1c618-4cdc-415a-a940-fb8752d45fd&title=&width=864" alt="Screenshot_20230523_225451.jpg"><br>因为地址总线运输的32位数据，则内存的大小是32位可以表示的，而这里在分配内存的时候可以分配64位表示的内存，会超过最大内存<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1684853912617-7c39dded-6975-4352-bd11-8b00fbea75cd.png#averageHue=%23f0f0f0&clientId=ubebfedef-06f8-4&from=paste&height=122&id=u34a60b27&originHeight=153&originWidth=1340&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=94797&status=done&style=none&taskId=u67ed8903-cc0d-4e1e-a839-f47e2a249c4&title=&width=1072" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1684854001394-cb4a86ec-9167-43f4-ac74-a1e7cc27dac9.jpeg#averageHue=%23232323&clientId=ubebfedef-06f8-4&from=paste&height=1920&id=u5cf82ef5&originHeight=2400&originWidth=1080&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=206976&status=done&style=none&taskId=uf4e42f3f-5ff9-474e-9d6f-9e35ae5d3a2&title=&width=864" alt="Screenshot_20230523_225938.jpg"><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1684853940591-bbdff6eb-e0ff-473c-b3ec-58e3403ea1e2.jpeg#averageHue=%23333333&clientId=ubebfedef-06f8-4&from=paste&height=1920&id=ud802f266&originHeight=2400&originWidth=1080&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=178939&status=done&style=none&taskId=u97c8950f-ca94-4401-9878-bf6c20f6128&title=&width=864" alt="Screenshot_20230523_225844.jpg"></p><h4 id="c语言运算符优先级"><a href="#c语言运算符优先级" class="headerlink" title="c语言运算符优先级"></a>c语言运算符优先级</h4><p><a href="https://blog.csdn.net/yuliying/article/details/72898132">C语言运算符优先级（超详细）_yuliying的博客-CSDN博客</a></p><h4 id="JAVA为什么0-0会报错而0-0-0输出的是NAN"><a href="#JAVA为什么0-0会报错而0-0-0输出的是NAN" class="headerlink" title="JAVA为什么0&#x2F;0会报错而0.0&#x2F;0输出的是NAN"></a>JAVA为什么0&#x2F;0会报错而0.0&#x2F;0输出的是NAN</h4><p>在Java中，整数类型的除法遵循整数除法规则，即当除数为0时会抛出一个ArithmeticException异常。这是因为在整数除法中，除数为0会导致无法完成除法运算，因此Java会抛出异常以指示此错误。<br>而对于浮点数类型，Java中的规范定义了特殊的结果值，如NaN、正无穷大和负无穷大。当浮点类型的除法中的除数为0时，结果被定义为NaN（Not a Number），表示结果未定义或无法表示。这是因为浮点数类型的除法中存在无穷大或未定义的情况，因此Java使用特殊的值来表示这些情况，而不是抛出异常。</p><h4 id="java除数为0的总结："><a href="#java除数为0的总结：" class="headerlink" title="java除数为0的总结："></a>java除数为0的总结：</h4><p>1.被除数为整数都会抛出异常<br>2.被除数为0.0结果是NAN<br>3.被除数为浮点数结果为Infinity，-Infinity由浮点数的正负决定</p><h4 id="汇编语言过程调用的栈有几个"><a href="#汇编语言过程调用的栈有几个" class="headerlink" title="汇编语言过程调用的栈有几个"></a>汇编语言过程调用的栈有几个</h4><p>在汇编语言中，过程调用（Procedure Call）通常使用栈来传递参数、保存返回地址和局部变量等信息。栈是一种后进先出（Last-In-First-Out，LIFO）的数据结构，可以通过 push 和 pop 指令在栈顶进行入栈和出栈操作。<br>在过程调用中，通常有两个栈：一个是系统栈（System Stack），也称为运行时栈（Run-time Stack），用于保存程序执行过程中的临时变量、函数参数和返回地址等信息；另一个是堆栈（Heap Stack），用于动态分配内存。<br>系统栈是由操作系统自动管理的，通常是在程序启动时分配一段固定大小的内存作为栈空间，程序运行时将栈指针（Stack Pointer）设置为栈的顶部，然后使用 push 和 pop 指令在栈顶进行数据的入栈和出栈操作。在过程调用中，通常使用 call 指令将函数的返回地址入栈，然后使用 ret 指令将返回地址出栈并跳回到调用函数的地方。在函数中，通常使用 ebp 寄存器来保存当前栈帧（Stack Frame）的基址，然后使用 esp 寄存器来指向当前栈顶。<br>堆栈是一种动态分配内存的方式，可以使用 malloc 和 free 函数在堆上分配和释放内存。堆栈通常用于在程序运行时动态创建和销毁对象，例如动态数组、链表等数据结构。<br>需要注意的是，系统栈和堆栈是两个不同的概念，通常不要混淆它们。在过程调用中，通常使用系统栈来传递参数和保存返回地址等信息，而不是使用堆栈。</p><h4 id="AT-Tshr指令"><a href="#AT-Tshr指令" class="headerlink" title="AT&amp;Tshr指令"></a>AT&amp;Tshr指令</h4><p>AT&amp;T 语法中的 shr 指令是用于执行逻辑右移操作的指令，它的基本语法格式如下：<br>Copy</p><div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">shr </span><span class="hljs-built_in">count</span>, destination</code></pre></div><p>其中，count 是要移动的位数，可以是一个立即数或者一个寄存器；destination 是要进行移位操作的目标操作数，可以是一个寄存器或者内存地址。<br>shr 指令将 destination 中的每一个位向右移动 count 位，并将结果存储回 destination 中。移位时，右边多余的位被舍弃，左边空出来的位通过符号位或者零来填充。具体来说，如果 destination 是一个有符号数，则符号位会保持不变；如果 destination 是一个无符号数，则左边空出来的位填充为零。<br>为什么存储器最好按地址对齐方式存放<br>存储器的按地址对齐方式存放是指数据在存储器中的地址应该是数据类型的整数倍。例如，一个32位整数应该从地址0、4、8等整数倍地址开始存放。这种存储方式的好处主要有以下几点：</p><ol><li>提高访问速度：CPU访问存储器时，通常会一次读取一个数据块，如果数据不是按地址对齐方式存放，就需要进行多次读取和拼接，这会降低访问速度。而按地址对齐方式存放可以保证数据始终被读取到相邻的数据块中，提高了访问速度。</li><li>减少内存读写次数：按地址对齐方式存放可以保证每个数据都被存储在一个单独的内存块中，这样就可以减少内存读写次数，从而提高程序的性能。</li><li>硬件要求：某些硬件对数据的存储方式有要求，例如，在一些处理器中，要求double类型的数据必须从8字节对齐的地址开始存放，否则就会发生错误。按地址对齐方式存放可以避免这种错误发生。</li><li>方便编程：按地址对齐方式存放可以使编程更加方便。例如，在C语言中，结构体的成员通常按照它们的类型顺序存储，这样就可以通过指针算术运算来访问结构体的成员。如果成员没有按地址对齐方式存放，就需要进行额外的指针算术运算，从而增加了编程复杂度。</li></ol><p>综上所述，存储器最好按地址对齐方式存放，可以提高访问速度、减少内存读写次数、满足硬件要求，以及方便编程。<br>造成缓冲区溢出的根本原因是什么<br>造成缓冲区溢出的根本原因是程序在处理输入数据时未正确处理输入数据的长度和边界。缓冲区是程序在内存中用于存储数据的一个区域，而缓冲区溢出则是指程序在向缓冲区中写入数据时，超出了缓冲区的边界，将数据写入了其他内存区域，从而导致程序出现错误或者崩溃。<br>缓冲区溢出通常是由以下原因引起的：</p><ol><li>输入数据过长：当程序在读取输入数据时，如果输入数据的长度超出了缓冲区的大小，就会导致缓冲区溢出。这通常是由于程序未正确预估输入数据的长度或者未对输入数据长度进行正确的验证所导致的。</li><li>指针算术错误：当程序在使用指针进行缓冲区操作时，如果指针指向了错误的地址或者进行了错误的算术运算，就会导致缓冲区溢出。</li><li>程序逻辑错误：当程序在处理数据时，如果程序的逻辑出现错误或者漏洞，就有可能导致缓冲区溢出。例如，程序在处理字符串时未正确添加字符串结束符’\0’，就会导致缓冲区溢出。</li></ol><p>为了避免缓冲区溢出，程序员需要在编写程序时，正确预估输入数据的长度，对输入数据进行正确的验证和过滤，避免使用指针算术错误，并且在处理字符串时，正确添加字符串结束符’\0’。此外，还可以使用一些工具和技术，如静态分析工具、内存安全检查工具、代码审查等，来帮助检测和修复缓冲区溢出漏洞。</p>]]></content>
    
    
    <categories>
      
      <category>课程作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机基础解惑</title>
    <link href="/2024/01/26/%E8%A7%A3%E6%83%91%EF%BC%9A/"/>
    <url>/2024/01/26/%E8%A7%A3%E6%83%91%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[<h4 id="1-int的取值范围"><a href="#1-int的取值范围" class="headerlink" title="1.int的取值范围"></a>1.int的取值范围</h4><p>int在32位和64位中的取值范围是-2147483648(2的31幂）~2147483647<br>最小值的补码和原码一样是:1000 0000 0000 0000 0000 0000 0000 0000<br>根据负数的补码求法可以猜测：负数的补码除了符号位，2147483648-后面的二进制代表的数&#x3D; 该负数的绝对值;2147483648是符号位不变，取反加一得出的</p><h4 id="2-根据补码求原码"><a href="#2-根据补码求原码" class="headerlink" title="2.根据补码求原码"></a>2.根据补码求原码</h4><p><strong>0的补码</strong><br>数0的补码表示是<strong>唯一</strong>的。</p><p>[+0]补&#x3D;[+0]反&#x3D;[+0]原&#x3D;00000000<br>[-0]补&#x3D;11111111+1&#x3D;00000000<br><strong>补码求原码</strong><br>已知一个数的补码，求原码的操作其实就是对该补码再求补码：<br>⑴如果补码的符号位为“0”，表示是一个正数，其原码就是补码。<br>⑵如果补码的符号位为“1”，表示是一个负数，那么求给定的这个补码的补码就是要求的原码。<br>例：已知一个补码为11111001，则原码是10000111（-7）。<br>因为符号位为“1”，表示是一个负数，所以该位不变，仍为“1”。<br>其余七位1111001取反后为0000110；再加1，所以是10000111。</p><h4 id="计算机乘除法运算原理："><a href="#计算机乘除法运算原理：" class="headerlink" title="计算机乘除法运算原理："></a>计算机乘除法运算原理：</h4><p><a href="https://www.cnblogs.com/stigerzergold/p/10328472.html">计算机实现乘法和除法的运算规则 - stigerzergold - 博客园</a></p><h4 id="整数溢出和-2147483648-2147483648-时，得到结果是-true"><a href="#整数溢出和-2147483648-2147483648-时，得到结果是-true" class="headerlink" title="整数溢出和-(-2147483648)&#x3D;&#x3D;(-2147483648) 时，得到结果是 true"></a>整数溢出和-(-2147483648)&#x3D;&#x3D;(-2147483648) 时，得到结果是 true</h4><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Hello world!&quot;</span>);        <span class="hljs-built_in">int</span> a = <span class="hljs-number">-2147483648</span>;        <span class="hljs-built_in">int</span> b = <span class="hljs-number">2147483647</span>; <span class="hljs-comment">//</span>        <span class="hljs-built_in">int</span> c = <span class="hljs-number">-1</span>;        <span class="hljs-comment">//int数据溢出后是循环的，最大数溢出的值为最小数+溢出值-1</span>        <span class="hljs-comment"><span class="hljs-doctag">///</span>/从二进制角度思考，有符号负数实际上是有符号正数全部取反然后加1</span>        System.<span class="hljs-keyword">out</span>.println(a<span class="hljs-number">-1</span>);<span class="hljs-comment">//a:1....00,-1的补码：11....11（也就是1的所有位取反加1），2个补码相加：011...1(2147483647)</span>        System.<span class="hljs-keyword">out</span>.println(a<span class="hljs-number">-2</span>);<span class="hljs-comment">//a-1的基础上在减去1</span>        System.<span class="hljs-keyword">out</span>.println(b+<span class="hljs-number">1</span>);<span class="hljs-comment">//b:011...1,1:00...1,b+1:1000000(按照符号位解读是补码，还原是-2147483638)</span>        System.<span class="hljs-keyword">out</span>.println(b+<span class="hljs-number">2</span>);<span class="hljs-comment">//b+1的基础上+1</span>        System.<span class="hljs-keyword">out</span>.println(a/c);<span class="hljs-comment">//a:100...0,c:11...1;a/c a(100..0)中的1和c(111.111)比较,1&gt;c商1,然后求出余数为111..1(31位）</span>        <span class="hljs-comment">//a中的下一个0掉下，组成111.10(32位)小于c(-1)商0,依次类推其后结果一直位0</span>        System.<span class="hljs-keyword">out</span>.println(a/<span class="hljs-number">-1</span>);<span class="hljs-comment">//也可以这样理解-2147483648/-1=2147483648，结果溢出转化位-2147483648</span>        System.<span class="hljs-keyword">out</span>.println(a/<span class="hljs-number">1</span>);        System.<span class="hljs-keyword">out</span>.println(-(<span class="hljs-number">-2147483648</span>)==(<span class="hljs-number">-2147483648</span>) );<span class="hljs-comment">//</span>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-number">-1</span>/<span class="hljs-number">-1</span>);        System.<span class="hljs-keyword">out</span>.println(a/<span class="hljs-number">-2</span>);        <span class="hljs-comment">/*printf(&quot;%d, %d \n&quot;, a, b);</span><span class="hljs-comment">        结果是什么？</span><span class="hljs-comment">*/</span>    &#125;&#125;<span class="hljs-comment">//</span>Hello world!<span class="hljs-number">2147483647</span><span class="hljs-number">2147483646</span><span class="hljs-number">-2147483648</span><span class="hljs-number">-2147483647</span><span class="hljs-number">-2147483648</span><span class="hljs-number">-2147483648</span><span class="hljs-number">-2147483648</span><span class="hljs-literal">true</span><span class="hljs-number">1</span><span class="hljs-number">1073741824</span>Process finished <span class="hljs-keyword">with</span> exit code <span class="hljs-number">0</span><span class="hljs-comment">//</span></code></pre></div><h4 id="浮点数的底层表示方法"><a href="#浮点数的底层表示方法" class="headerlink" title="浮点数的底层表示方法"></a>浮点数的底层表示方法</h4><p><a href="https://www.cnblogs.com/wupeiqi/p/13041139.html">6张图搞懂float浮点型底层存储原理 - 武沛齐 - 博客园</a><br> <a href="https://blog.csdn.net/weixin_45944581/article/details/109896244">汇编语言——ZF、PF、SF、CF、OF寄存器_zf汇编_六神max的博客-CSDN博客</a><br>movsbl<br>movsbl是x86汇编语言中的一条指令，用于将一个带符号字节（8位）从内存中加载到寄存器中，并将其扩展为一个带符号双字（32位）。具体来说，movsbl指令将指定内存地址处的第一个字节加载到目标寄存器中，并将其符号扩展为32位。<br>movsbl指令的语法如下：<br>Copy</p><div class="code-wrapper"><pre><code class="hljs bash">movsbl <span class="hljs-built_in">source</span>, destination</code></pre></div><p>其中，source可以是内存地址或寄存器，表示要加载的源操作数；destination是目标寄存器，表示加载后的结果。<br>例如，下面的代码将一个带符号字节从地址为0x100的内存单元加载到eax寄存器中，并将其符号扩展为32位：<br>Copy</p><div class="code-wrapper"><pre><code class="hljs gcode">mo<span class="hljs-attr">vsbl 0</span>x<span class="hljs-number">100</span>, <span class="hljs-meta">%</span>eax</code></pre></div><p>如果内存地址0x100处的字节是0x8F，则eax寄存器的值将是0xFFFFFFF0。<br>movsbl指令通常用于将带符号字节转换为带符号双字，以便在计算中进行符号扩展和符号运算。<br>movzwl<br>movzwl是x86汇编语言中的一条指令，用于将一个无符号字（16位）从内存中加载到寄存器中，并将其扩展为一个无符号双字（32位）。具体来说，movzwl指令将指定内存地址处的两个字节（一个字）加载到目标寄存器中，并将其零扩展为32位。<br>movzwl指令的语法如下：<br>Copy</p><div class="code-wrapper"><pre><code class="hljs bash">movzwl <span class="hljs-built_in">source</span>, destination</code></pre></div><p>其中，source可以是内存地址或寄存器，表示要加载的源操作数；destination是目标寄存器，表示加载后的结果。<br>例如，下面的代码将一个无符号字从地址为0x100的内存单元加载到eax寄存器中，并将其零扩展为32位：<br>Copy</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">movzwl</span> <span class="hljs-number">0</span>x100, %eax</code></pre></div><p>如果内存地址0x100处的字是0x8F20，则eax寄存器的值将是0x00008F20。<br>movzwl指令通常用于将无符号字转换为无符号双字，以便在计算中进行零扩展和无符号运算。<br>AT&amp;T<br>AT&amp;T是一种常用的汇编语言语法，也称为AT&amp;T汇编语法，因其最初由AT&amp;T Unix系统使用而得名。与之相对的是Intel汇编语法，也称为“x86汇编语法”。<br>AT&amp;T汇编语法和Intel汇编语法在语法结构、寄存器命名、指令格式和操作数顺序等方面存在差异。在AT&amp;T汇编语法中，操作数的顺序是源操作数在前，目标操作数在后，以逗号分隔。例如，将一个字节从al寄存器移动到bl寄存器，使用的指令是：<br>Copy</p><div class="code-wrapper"><pre><code class="hljs cos">movb <span class="hljs-built_in">%al</span>, <span class="hljs-built_in">%bl</span></code></pre></div><p>在Intel汇编语法中，操作数的顺序是目标操作数在前，源操作数在后，也用逗号分隔。因此，使用Intel汇编语法执行相同的操作需要使用不同的语法：<br>Copy</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>, <span class="hljs-built_in">al</span></code></pre></div><p>AT&amp;T汇编语法还使用一些特殊的前缀和后缀来表示操作数的大小、类型和地址模式等信息。例如，“b”表示一个字节操作数，“w”表示一个字操作数，“l”表示一个双字操作数，而“(%eax)”表示以eax寄存器中的地址为基址的间接寻址。<br>尽管AT&amp;T汇编语法与Intel汇编语法存在差异，但它们都是x86汇编语言的变体，都可以用于编写和调试x86汇编代码。<br>AT&amp;T中的％ax和(%edx)的区别<br>AT&amp;T中的％ax和(%edx)的区别<br>在AT&amp;T汇编语法中，”%ax”和”(%edx)”分别表示寄存器ax和以edx寄存器中的值为基址的间接寻址。具体来说，它们的区别如下：</p><ol><li>“%ax”表示寄存器ax，它是x86架构中的通用寄存器，用于存储16位数据。在AT&amp;T汇编语法中，寄存器名称前面加上”%”符号表示该寄存器的值。</li><li>“(%edx)”表示以edx寄存器中的值为基址的间接寻址。在AT&amp;T汇编语法中，内存地址的表示方法为：偏移量（可选）+ 圆括号 + 基址寄存器。圆括号是必需的，用于区分内存地址和寄存器名称。在这个例子中，”(%edx)”表示以edx寄存器中的值作为基址，没有偏移量，进行间接寻址。</li></ol><p>因此，”%ax”和”(%edx)”表示的是不同的东西。”%ax”是寄存器ax的值，而”(%edx)”是以edx寄存器中的值为基址的间接寻址所得到的内存地址中的值。<br>例如，下面的代码将寄存器ax的值加上内存地址为edx+8处的字，并将结果存储回ax寄存器中：<br>Copy<br>在这个例子中，”(%edx,8)”表示以edx寄存器中的值加上8作为基址，进行间接寻址。然后，程序将该内存地址中的值与寄存器ax中的值相加，并将结果存储回ax寄存器中。</p><div class="code-wrapper"><pre><code class="hljs cos">addw (<span class="hljs-built_in">%edx</span>,<span class="hljs-number">8</span>), <span class="hljs-built_in">%ax</span></code></pre></div><p>x86汇编语法<br>x86汇编语法是一种汇编语言语法，用于编写x86架构的汇编代码。x86汇编语法基于指令集架构的不同，可以分为Intel汇编语法和AT&amp;T汇编语法两种。<br>Intel汇编语法在语法结构、寄存器命名、指令格式和操作数顺序等方面与AT&amp;T汇编语法存在差异。在Intel汇编语法中，目标操作数通常在前面，源操作数在后面，使用逗号分隔。例如，将一个字节从al寄存器移动到bl寄存器，使用的指令是：<br>Copy</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>, <span class="hljs-built_in">al</span></code></pre></div><p>在AT&amp;T汇编语法中，操作数的顺序是源操作数在前，目标操作数在后，以逗号分隔。因此，使用AT&amp;T汇编语法执行相同的操作需要使用不同的语法：<br>Copy</p><div class="code-wrapper"><pre><code class="hljs cos">movb <span class="hljs-built_in">%al</span>, <span class="hljs-built_in">%bl</span></code></pre></div><p>x86汇编语法中还包括许多指令、寄存器、内存寻址模式以及标志寄存器等。指令用于执行特定的操作，例如数据传输、算术运算、逻辑运算和控制转移等。常用的寄存器包括通用寄存器、段寄存器和控制寄存器等，用于存储数据、地址和控制信息等。内存寻址模式用于访问内存中的数据，例如直接寻址、寄存器间接寻址和基址加变址寻址等。<br>x86汇编语法是一种强大的工具，用于编写高效、可靠的汇编代码。它可以与高级语言和操作系统API一起使用，用于编写底层的系统软件、驱动程序和嵌入式系统等。<br>pushl<br>pushl是x86汇编语言中的一条指令，用于将一个双字（32位）的值压入堆栈中。具体来说，pushl指令将指定的源操作数压入堆栈中，并将栈指针减4。堆栈是一种后进先出（LIFO）的数据结构，用于存储程序调用的返回地址、局部变量、函数参数和其他数据等。<br>pushl指令的语法如下：<br>Copy</p><div class="code-wrapper"><pre><code class="hljs bash">pushl <span class="hljs-built_in">source</span></code></pre></div><p>其中，source可以是寄存器、内存地址或立即数，表示要压入堆栈的源操作数。<br>例如，下面的代码将32位立即数0x12345678压入堆栈中：<br>Copy</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">pushl</span> <span class="hljs-variable">$0</span>x12345678</code></pre></div><p>如果堆栈指针寄存器（%esp）的值为0x1000，则执行这条指令后，堆栈指针将减4，变为0xFFC，并将0x12345678写入内存地址0xFFC处。<br>pushl指令通常用于将函数参数压入堆栈中，以便在函数中使用。在函数调用过程中，参数通常按照从右到左的顺序依次压入堆栈中。例如，下面的代码将两个参数压入堆栈中，并调用函数foo：<br>Copy</p><div class="code-wrapper"><pre><code class="hljs autoit">pushl $2pushl $1<span class="hljs-built_in">call</span> foo</code></pre></div><p>在这个例子中，首先将值2压入堆栈中，然后将值1压入堆栈中。最后，使用call指令调用函数foo。在函数foo中，可以使用指令”movl (%esp), %eax”将第一个参数（值1）从堆栈中弹出，并将其存储到eax寄存器中；然后再使用指令”addl 4(%esp), %eax”将第二个参数（值2）从堆栈中弹出，并将其加到eax寄存器中。<br>什么是立即数<br>立即数是汇编语言中的一种数据类型，表示一个常数或字面值。它是在汇编代码中直接使用的值，而不是从内存或寄存器中加载的值。立即数通常用于执行算术运算、逻辑运算、数据传输和控制转移等操作，可以用于表示地址、常量、计数器和偏移量等。<br>ip寄存器的值<br>IP寄存器（Instruction Pointer Register）是x86架构中的一个寄存器，用于存储下一条要执行的指令的地址。在实模式下，IP寄存器存储的是16位的地址（偏移量），在保护模式下，IP寄存器存储的是32位的地址（线性地址）。IP寄存器通常与CS寄存器（Code Segment Register）一起使用，以确定下一条指令的地址。<br>在执行指令时，CPU会从当前代码段中读取下一条指令的地址，该地址存储在CS寄存器中。然后，CPU将该地址与IP寄存器中存储的偏移量相加，以确定下一条指令的实际地址。CPU执行该指令后，IP寄存器的值将自动增加，以指向下一条指令的地址。<br>例如，下面的代码使用了jmp指令，将程序的控制权转移到一个标记为”loop”的位置：<br>Copy</p><div class="code-wrapper"><pre><code class="hljs ada"><span class="hljs-keyword">loop</span>:  ; 代码段中的其他指令  jmp <span class="hljs-keyword">loop</span></code></pre></div><p>在这个例子中，jmp指令将IP寄存器的值设置为标记”loop”的地址，从而使程序转移到该位置。当执行到jmp指令时，CPU会从CS寄存器中读取代码段的起始地址，然后将偏移量设置为标记”loop”的地址。CPU执行jmp指令后，程序控制权转移到标记”loop”处。<br>需要注意的是，IP寄存器通常是由CPU自动管理的，程序无法直接修改其值。只有在特殊情况下，如中断处理程序或操作系统内核中，才需要手动修改IP寄存器的值。<br>pc和Ip寄存器的联系<br>PC（Program Counter，程序计数器）和IP（Instruction Pointer，指令指针）寄存器都是用于存储下一条指令地址的寄存器，它们之间有一定的联系。<br>PC寄存器是存储CPU当前正在执行的指令的地址的寄存器。在许多CPU架构中，PC寄存器也称为指令地址寄存器（IAR）。当CPU执行一条指令时，它会将当前指令的地址存储在PC寄存器中。然后CPU执行该指令，将PC寄存器的值自动加上当前指令的长度，以计算下一条指令的地址。<br>IP寄存器是指令指针寄存器，用于存储下一条要执行的指令的地址。在x86架构中，IP寄存器存储的是下一条指令的偏移量。CPU在执行指令时，从当前代码段中读取下一条指令的地址，将其与IP寄存器中的偏移量相加，以确定下一条指令的实际地址。CPU执行该指令后，IP寄存器的值将自动增加，以指向下一条指令的地址。<br>因此，PC寄存器和IP寄存器都用于存储下一条指令的地址，但它们在不同的CPU架构中有不同的实现方式和命名。在x86架构中，CPU使用CS寄存器来存储当前代码段的起始地址，将IP寄存器中的偏移量与CS寄存器中的值相加，以计算下一条指令的实际地址。在其他CPU架构中，可能会使用不同的寄存器来存储代码段的地址和下一条指令的地</p><ul><li>变形补码</li></ul><p><a href="https://blog.csdn.net/sun_boy_boy_sun/article/details/87917020">模4补码（也称为变形补码）详解_变形补码怎么计算_sun_boy_boy_sun的博客-CSDN博客</a></p><ul><li>ieee754</li></ul><p><a href="https://blog.csdn.net/weixin_47713503/article/details/108699001">IEEE754 浮点数：简读+案例&#x3D;秒懂_ieee754浮点数的计算_theRealUnow的博客-CSDN博客</a><br><a href="https://blog.csdn.net/weixin_51760209/article/details/124071247">二进制乘法运算_君知燕云归的博客-CSDN博客</a><br><a href="https://blog.csdn.net/u011240016/article/details/53010061">移码的再总结_11位移码最大是多少_DrCrypto的博客-CSDN博客</a></p><h4 id="endbr32"><a href="#endbr32" class="headerlink" title="endbr32 :"></a>endbr32 :</h4><p> 给技术要求相对跳转的目标地址一定是一条 endbr32 或 endbr64 指令，否则就会异常。该指令并不执行任何操作，只是用于验证目标地址是期望的跳转目标。  </p>]]></content>
    
    
    <categories>
      
      <category>课程作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件工程课堂学习记录</title>
    <link href="/2024/01/26/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    <url>/2024/01/26/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h1 id="软件及软件工程："><a href="#软件及软件工程：" class="headerlink" title="软件及软件工程："></a>软件及软件工程：</h1><p>计算机软件指计算机系统中的<strong>程序</strong>、<strong>数据</strong>及<strong>其相关文档</strong><br>程序：按照特定顺序组织的计算机数据和指令的集合。<br>数据：使程序能正常执行的数据结构<br>文档：为了便于理解程序所需的与开发、维护和使用有关的资料<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686713495060-cdf27133-f9ba-4928-a83a-c41381428958.png#averageHue=%23d6c9c5&clientId=u3a2eaed4-c828-4&from=paste&height=369&id=ue4e721cd&originHeight=461&originWidth=709&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=113642&status=done&style=none&taskId=ue5df6370-8fe5-4bd1-acfc-f101f3f2ba2&title=&width=567.2" alt="image.png"></p><h4 id="生命周期模型"><a href="#生命周期模型" class="headerlink" title="生命周期模型"></a>生命周期模型</h4><p> 软件生命周期模型是指在软件开发过程中，按照一定的时间顺序和阶段性的划分，将软件开发过程分为不同的阶段，并规定各个阶段的任务和交付成果。这些阶段通常包括需求分析、设计、编码、测试、部署和维护等<br>软件生命周期(Software Life Cycle,SLC)是软件的产生直到报废或停止使用的生命周期。软件生命周期内有<strong>问题定义、可行性分析、总体描述、系统设计、编码、调试和测试、验收与运行、维护升级</strong>等阶段。那么如何将上述软件开发过程方法化呢？这就是过程模型。过程模型（Process Models） 意图解决软件过程中的混乱，将软件开发过程中的沟通、计划、建模、构建和部署等活动（activities）有效地组织了起来。<strong>他们之间的线性（linear）、迭代（iterative）、演进（evolutionary）和平行（parallel）关系会产生不同的模型</strong>。常见的过程模型包括：瀑布模型、原型模型、增量模型、<br><a href="https://www.cnblogs.com/qiaoli0726/p/14167524.html">软件开发常见模型（瀑布模型、V模型、W模型、敏捷开发模型） - qiaoli - 博客园</a></p><h4 id="软件过程模型："><a href="#软件过程模型：" class="headerlink" title="软件过程模型："></a>软件过程模型：</h4><p>也称软件开发模型  或 软件生存周期模型<br>    是软件生存周期中一系列有序的软件开发活动的流程，是软件开发全部活动的结构框架。<br>对一个软件的开发无论其大小，都需要选择一个合适的软件过程模型，主要根据软件的类型、规模，开发方法、开发环境等多种因素来确定。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686445217940-edf1f49e-9a0e-4ff0-b457-846d4303aebf.png#averageHue=%23e6d9cc&clientId=udbefbbe5-2d1f-4&from=paste&height=382&id=u363915b6&originHeight=478&originWidth=752&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=122099&status=done&style=none&taskId=u2bc8e8c0-3ba8-4681-a28f-0449ab564b8&title=&width=601.6" alt="image.png"><br>瀑布模型<br>原型模型</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686448315316-db100647-b56f-4ba6-b3e7-8b35a74ee240.png#averageHue=%23ebe8e8&clientId=udbefbbe5-2d1f-4&from=paste&height=418&id=u4db035f4&originHeight=522&originWidth=853&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=174134&status=done&style=none&taskId=u5e50f2b3-ac26-41bb-b285-d8c040890f0&title=&width=682.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686448668857-2c852d99-3d1b-47da-8fdd-f4374c4517b9.png#averageHue=%23fefefd&clientId=udbefbbe5-2d1f-4&from=paste&height=281&id=u1945f7c5&originHeight=351&originWidth=1116&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=28513&status=done&style=none&taskId=u5f592378-a0f4-4c9f-9148-eeaf90b0f64&title=&width=892.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686448749409-73183c2e-79be-468a-97e2-746d9df97348.png#averageHue=%23fefefe&clientId=udbefbbe5-2d1f-4&from=paste&height=289&id=u659a6c6e&originHeight=361&originWidth=1151&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=23067&status=done&style=none&taskId=u595d0ef7-66de-4957-b279-f9e6b544211&title=&width=920.8" alt="image.png"><br>结构化程序设计（Structured Programming）是一种软件开发方法，旨在通过清晰、简洁、易于理解的编码方式来提高软件的可读性、可维护性和可靠性。结构化程序设计通常采用顺序、选择和循环等基本控制结构，避免使用goto语句等不可控制的跳转语句，以便更好地理解和控制程序的执行流程。<br>结构化程序设计的主要特点包括：</p><ol><li>模块化：将程序分解成多个相互独立的模块，每个模块具有清晰的输入和输出，便于维护和修改。</li><li>顺序结构：按照顺序执行程序的不同部分，避免使用不可控制的跳转语句。</li><li>选择结构：根据条件选择不同的执行路径，例如if-else语句、switch语句等。</li><li>循环结构：根据条件重复执行某些操作，例如while循环、for循环等。</li></ol><p>结构化程序设计的优点是程序结构清晰，易于理解和维护，能够提高程序的可读性、可维护性和可靠性。同时，结构化程序设计还可以提高软件开发的效率和质量，减少开发成本和时间。<br> 是“<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/9957246?fromModule=lemma_inlink">面向过程</a>”方法的改进， 结构上将<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/224122?fromModule=lemma_inlink">软件系统</a>划分为若干功能模块， 各模块按要求单独编程， 再由各模块连接， 组合构成相应的软件系统。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686449426922-26349020-c7ea-4b3c-a38f-0c8bb7a92cb1.png#averageHue=%23fefefe&clientId=udbefbbe5-2d1f-4&from=paste&height=257&id=u42c70125&originHeight=321&originWidth=1126&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=22224&status=done&style=none&taskId=u7df85039-2ce0-4f61-9c71-db9e49a096b&title=&width=900.8" alt="image.png"></p><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686449470800-adb9d6e5-af86-4cb5-8717-8391bd5cf58c.png#averageHue=%23fefefd&clientId=udbefbbe5-2d1f-4&from=paste&height=327&id=ub136348b&originHeight=409&originWidth=1098&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=30274&status=done&style=none&taskId=uca03df77-002c-487b-b0f2-5e3c14f9057&title=&width=878.4" alt="image.png"></h1><p>潜在可交付的产品增量是什么<br>在敏捷开发中，潜在可交付的产品增量（Potentially Shippable Product Increment，PSPI）指的是在当前迭代周期结束时，团队完成的一个可用、可测试、可部署、可交付的软件产品版本。它是在迭代周期内完成的所有工作成果的集合，包括新功能、增强功能和修复问题等。PSPI是一个完整的、可用的、可交付的软件产品版本，可以交付给客户或者用于生产环境。<br>潜在可交付的产品增量是敏捷开发中的一个重要概念，它强调了团队在每个迭代周期内需要完成一个可用、可测试、可部署、可交付的软件产品版本。通过这种方式，团队可以更快地响应客户需求和市场变化，提高开发效率和质量，并不断改进和优化软件产品。<br>值得注意的是，潜在可交付的产品增量并不一定需要在迭代周期结束时立即交付给客户或者用于生产环境。它可以在迭代周期结束后进行进一步的测试、评估和优化，直至达到满足交付要求的标准后再进行交付。这有助于确保软件产品的质量和可用性，并避免潜在的风险和问题。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686540999105-c1bab5c6-495b-40ce-b947-3be57b0e84cd.png#averageHue=%23faf9f9&clientId=udbefbbe5-2d1f-4&from=paste&height=150&id=ub06ee257&originHeight=188&originWidth=1012&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=17286&status=done&style=none&taskId=u6965dea2-70dc-43e4-9998-b539b6db3ad&title=&width=809.6" alt="image.png"></p><h1 id="敏捷过程："><a href="#敏捷过程：" class="headerlink" title="敏捷过程："></a>敏捷过程：</h1><h1 id="实施敏捷开发，看这一篇就够了"><a href="#实施敏捷开发，看这一篇就够了" class="headerlink" title="实施敏捷开发，看这一篇就够了"></a><a href="https://zhuanlan.zhihu.com/p/37815239">实施敏捷开发，看这一篇就够了</a></h1><p><a href="https://www.cnblogs.com/jiftle/p/14005715.html#:~:text=%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%B3%95%E9%80%82%E5%90%88%E5%AF%B9,%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%9C%BA%E6%99%AF%E3%80%82">《敏捷开发培训考试》考试题目及答案 - jiftle - 博客园</a><br><strong>迭代计划会议：</strong><a href="https://zhuanlan.zhihu.com/p/405527208#:~:text=%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E8%AE%A1%E5%88%92%E4%BC%9A%E8%AE%AE%EF%BC%9F%20Sprint%E8%AE%A1%E5%88%92%E4%BC%9A%E8%AE%AE%E6%98%AF%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E7%9A%84%E4%BC%9A%E8%AE%AE%E4%B9%8B%E4%B8%80%EF%BC%8C%E5%9C%A8%E6%AF%8F%E4%B8%AA%E8%BF%AD%E4%BB%A3%E5%91%A8%E6%9C%9F%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D%E5%8F%AC%E5%BC%80%E3%80%82,%E7%9B%AE%E7%9A%84%E6%98%AF%E4%B8%BA%E4%BA%86%E5%88%B6%E5%AE%9A%E5%BD%93%E5%89%8D%E8%BF%AD%E4%BB%A3%E5%91%A8%E6%9C%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%9B%AE%E6%A0%87%E4%BB%A5%E5%8F%8A%E9%9C%80%E8%A6%81%E5%AE%8C%E6%88%90%E7%9A%84%E5%B7%A5%E4%BD%9C%E3%80%82%20%E4%B8%BE%E5%8A%9E%20Sprint%E8%AE%A1%E5%88%92%E4%BC%9A%E8%AE%AE%EF%BC%8C%E6%98%AF%E4%B8%BA%E4%BA%86%E8%AE%A9%E5%9B%A2%E9%98%9F%E8%8E%B7%E5%BE%97%E8%B6%B3%E5%A4%9F%E7%9A%84%E4%BF%A1%E6%81%AF%EF%BC%8C%E8%83%BD%E5%A4%9F%E5%9C%A8%E5%87%A0%E4%B8%AA%E6%98%9F%E6%9C%9F%E5%86%85%E4%B8%8D%E5%8F%97%E5%B9%B2%E6%89%B0%E5%9C%B0%E5%B7%A5%E4%BD%9C%E3%80%82">Scrum敏捷管理之”迭代计划会“</a><br><strong>迭代回顾：</strong> 迭代回顾会议是Scrum五个仪式之一，是在迭代评审会议之后对本次迭代的优点与改进点进行复盘的一个活动，其最主要的目的是提升团队的整体能力，持续改进，形成一个自学习的团队。. 通过回顾会议可以使团队每个迭代都能比上个迭代做得更好。. 在很多敏捷团队中，最容易忽略该活动，很多团队没有意识到该活动的重要性。. 为什么呢？. 最主要的原因是开了会议，没有实际效果，大家认为没用，所以也就不开了。. 实践中，在开迭代回顾会议时常犯的错误有：. 把回顾会议开成了吐槽大会，大家只提意见，不提改进措施；.<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686539298682-a4a874fc-4060-4500-a572-17ba29730846.png#averageHue=%23f7f5f4&clientId=udbefbbe5-2d1f-4&from=paste&height=157&id=ue8a1fd34&originHeight=196&originWidth=508&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=14680&status=done&style=none&taskId=u7f8e5852-4d54-4199-8a76-82a06c39c53&title=&width=406.4" alt="image.png"><br>一般来说，迭代回顾会议可以持续1到2小时，以确保充分的讨论和反馈，但也不会过于耗费时间和资源。在会议开始前，团队成员应该准备好相关的数据和材料，如迭代进度报告、测试报告、客户反馈等，以便在会议中进行讨论和分析。<br><strong>燃尽图：</strong><a href="https://zhuanlan.zhihu.com/p/258744550#:~:text=%E4%BB%80%E4%B9%88%E6%98%AF%E7%87%83%E5%B0%BD%E5%9B%BE.%20%E7%87%83%E5%B0%BD%E5%9B%BE%EF%BC%88burn%20down%20chart%EF%BC%89%E6%98%AF%E5%9C%A8%E9%A1%B9%E7%9B%AE%E5%AE%8C%E6%88%90%E4%B9%8B%E5%89%8D%EF%BC%8C%E5%AF%B9%E9%9C%80%E8%A6%81%E5%AE%8C%E6%88%90%E7%9A%84%E5%B7%A5%E4%BD%9C%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%B8%80%E7%A7%8D%E5%8F%AF%E8%A7%86%E5%8C%96%E8%A1%A8%E7%A4%BA%E3%80%82.%20%E7%90%86%E6%83%B3%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E8%AF%A5%E5%9B%BE%E8%A1%A8%E6%98%AF%E4%B8%80%E4%B8%AA%E5%90%91%E4%B8%8B%E7%9A%84%E6%9B%B2%E7%BA%BF%EF%BC%8C%E9%9A%8F%E7%9D%80%E9%A1%B9%E7%9B%AE%E4%BB%BB%E5%8A%A1%E7%9A%84%E9%80%90%E6%B8%90%E5%AE%8C%E6%88%90%E2%80%9C%E7%83%A7%E5%B0%BD%E2%80%9D%E8%87%B3%E9%9B%B6%E3%80%82.,%E7%87%83%E5%B0%BD%E5%9B%BE%E5%B8%B8%E5%B8%B8%E7%94%A8%E4%BA%8E%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E4%BD%9C%E4%B8%BA%E9%A1%B9%E7%9B%AE%E8%BF%9B%E5%B1%95%E7%9A%84%E4%B8%80%E4%B8%AA%E6%8C%87%E7%A4%BA%E5%99%A8%E3%80%82.%20%E5%A6%82%E4%BD%95%E8%A7%A3%E8%AF%BB%E7%87%83%E5%B0%BD%E5%9B%BE.%20%E7%87%83%E5%B0%BD%E5%9B%BE%E6%98%AF%E4%B8%80%E4%B8%AA%E5%9D%90%E6%A0%87%E5%9B%BE%E3%80%82.%20%E5%91%88%E7%8E%B0%E7%9A%84%E6%98%AF%E9%9A%8F%E7%9D%80%E6%97%B6%E9%97%B4%E6%8E%A8%E7%A7%BB%E8%80%8C%E5%89%A9%E4%BD%99%E7%9A%84%E5%B7%A5%E4%BD%9C%E9%87%8F%E3%80%82.%20%E7%87%83%E5%B0%BD%E5%9B%BE%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%9A.%20%E6%A8%AA%E5%9D%90%E6%A0%87%EF%BC%9Asprint%E7%9A%84%E5%B7%A5%E6%9C%9F%EF%BC%88%E4%BB%A5%E5%A4%A9%E8%AE%A1%E7%AE%97%EF%BC%89%E3%80%82.">教你如何用燃尽图做项目管理</a><br><strong>DOD和DOR是什么：</strong><a href="https://blog.csdn.net/LigaAI/article/details/126042526">敏捷开发中的 DoD 和 DoR 是什么？_dod 敏捷_LigaAI的博客-CSDN博客</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686540489194-4617848d-4a61-4dbb-956a-e68a0bb9ccb5.png#averageHue=%23f9f7f6&clientId=udbefbbe5-2d1f-4&from=paste&height=143&id=ube36f8a0&originHeight=179&originWidth=344&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=8620&status=done&style=none&taskId=u8d2a894c-4599-45d0-b096-7eaad560759&title=&width=275.2" alt="image.png">投产文档是软件工程中的一种文档，也称为发布文档、上线文档或部署文档。它是在软件开发过程中最后一个阶段的重要产物，通常是由项目经理、开发团队和运维团队联合编写的。投产文档记录了软件系统的部署、测试、验证和上线等过程中的各种信息和细节，以确保系统能够在生产环境中稳定运行。而DOD是是需求准出的标准表示的是需求，而投产文档是整个步骤完成后要完成的<br>**PSPI:**在敏捷开发中，潜在可交付的产品增量（Potentially Shippable Product Increment，PSPI）指的是在当前迭代周期结束时，团队完成的一个可用、可测试、可部署、可交付的软件产品版本。它是在迭代周期内完成的所有工作成果的集合，包括新功能、增强功能和修复问题等。PSPI是一个完整的、可用的、可交付的软件产品版本，可以交付给客户或者用于生产环境。<br><strong>敏捷开发</strong>法是一种以团队为核心的、迭代式、自下而上的开发方法，与自顶向下的传统开发方法有所不同。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686538236683-abf20531-e1bf-406b-a155-dd7d6fcdab90.png#averageHue=%23fefefe&clientId=udbefbbe5-2d1f-4&from=paste&height=202&id=u7a42e314&originHeight=253&originWidth=1102&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=18249&status=done&style=none&taskId=u1c489adb-b463-4f1d-880b-1295a977b87&title=&width=881.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686539631766-3c21a2e4-fd79-4439-bda7-a88955418a84.png#averageHue=%23f7f5f4&clientId=udbefbbe5-2d1f-4&from=paste&height=153&id=u5f3a55bf&originHeight=191&originWidth=563&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=15390&status=done&style=none&taskId=u3490744d-ba26-4be7-a362-b3d7dcbca84&title=&width=450.4" alt="image.png"><br> 目前存在两种形式的燃尽图，Sprint燃尽图用于显示迭代中的剩余工作量，而产品燃尽图则用于说明整个项目的剩余工作量。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686541330291-059fc930-9d8f-44b3-86f2-f1186d62d224.png#averageHue=%23f8f7f6&clientId=udbefbbe5-2d1f-4&from=paste&height=155&id=u7266ee75&originHeight=194&originWidth=386&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=10104&status=done&style=none&taskId=ue85dd581-5822-4f88-bce9-baf3c05d801&title=&width=308.8" alt="image.png">用户故事（User Story）是敏捷开发中的一种需求描述方式，它描述了用户或利益相关者在使用软件系统时所需要完成的具体任务、目标或需求。用户故事通常由简短的、自然语言的语句组成，用于概括一个或多个特定的用户场景。通常，用户故事通过格式化的语句来描述，例如：<br>“As a [角色], I want to [行动], so that [目标]”在敏捷开发中，用户故事通常由客户或利益相关者提出，并与开发团队共同制定和明确。客户和利益相关者通常是最了解系统使用场景和需求的人，他们可以通过用户故事的方式清晰地描述和传达自己的需求和期望，帮助开发团队更好地理解和满足用户需求。<br>客户和利益相关者通常会参与到敏捷开发的迭代过程中，与开发团队一起讨论和优化用户故事，以确保开发团队理解和满足用户需求。这种协作和沟通方式可以帮助团队更好地把握用户需求和期望，以便更好地设计和开发软件产品。<br>除了客户和利益相关者，开发团队中的其他成员，如产品经理、业务分析师、开发人员等，也可以参与制定用户故事。他们可以提出自己的想法和建议，帮助团队更好地理解和实现用户需求，从而提高软件产品的质量和用户体验。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686541486304-55296cf7-a376-48c8-9527-a2aa62414d12.png#averageHue=%23f8f6f5&clientId=udbefbbe5-2d1f-4&from=paste&height=163&id=u6b064a32&originHeight=204&originWidth=393&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=11371&status=done&style=none&taskId=u4bdb4d40-a0f6-431a-a314-e4636caf9c9&title=&width=314.4" alt="image.png"><br>D选项：有估算的。Product Backlog中的需求应该根据其复杂度、工作量和资源等因素进行估算，并根据其估算结果进行排序和开发。因此，有估算的特点是Product Backlog应该具备的。<br>Product Backlog（产品待办列表）是敏捷开发中的一种需求管理工具，它是一个优先级排序的需求列表，其中包含了所有的产品需求、特性和用户故事等，以及与之相关的任务、缺陷和技术债务等。<br>Product Backlog由产品负责人（Product Owner）维护，并根据需求的优先级和价值进行排序和管理。产品负责人通常会与客户和利益相关者紧密合作，收集和明确需求，并根据需求的重要性和价值，将其添加到Product Backlog中。<br>Product Backlog中的每个需求通常都包含以下信息：</p><ol><li>描述：对需求进行简要描述，例如需求的名称、特性等。</li><li>价值：对需求的重要性和价值进行评估，并根据其价值进行排序。</li><li>优先级：对需求的优先级进行评估，并根据其优先级进行排序。</li><li>状态：对需求的状态进行跟踪，例如已完成、正在进行中、待办等。</li><li>验收标准：对需求的验收标准进行定义，以便在需求完成后进行验收。</li></ol><p>Product Backlog是敏捷开发中的一个重要工具，它可以帮助团队更好地管理和追踪需求，以便更好地满足客户需求和市场变化。团队通常会定期审查和优化Product Backlog，以保持其与产品需求的一致性和实时性。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686541853956-47638bcf-1b9a-4d3f-8152-7bf890be476b.png#averageHue=%23f9f8f7&clientId=udbefbbe5-2d1f-4&from=paste&height=101&id=u0fd8d089&originHeight=126&originWidth=411&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=6019&status=done&style=none&taskId=uae3e5f04-2348-4f5a-8c02-56cc38d7b71&title=&width=328.8" alt="image.png"><br>敏捷开发团队通常由5至9人组成。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686541957388-d50be0f9-56b5-4380-aec0-a11786a9d319.png#averageHue=%23f9f8f7&clientId=udbefbbe5-2d1f-4&from=paste&height=94&id=u46a9d4d5&originHeight=117&originWidth=774&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=8630&status=done&style=none&taskId=u44243042-581d-4c09-ba1a-a10f0e9b948&title=&width=619.2" alt="image.png"><br>错误。虽然敏捷开发可以提高团队的灵活性和响应变化的能力，但是对于极高的关键性、可靠性、安全性要求的项目，敏捷开发不一定是最适合的开发方法。这类项目通常需要更多的计划、设计、测试和验证工作，以确保系统的稳定性、可靠性和安全性，而这些工作在敏捷开发中可能会被忽略或减少。<br>相反，传统的瀑布模型（Waterfall Model）可能更适合这类项目。瀑布模型强调计划、设计、测试和验证等阶段的顺序性和严格性，可以确保系统的稳定性、可靠性和安全性，并在项目初期进行详细的规划和设计，以避免后期的问题和风险。<br>当然，对于某些具有极高可变性的项目，例如创新型项目，敏捷开发可能是更为适合的方法。在这种情况下，敏捷开发可以帮助团队更快地响应变化和市场需求，从而提高创新和竞争力。</p><h1 id="软件需求"><a href="#软件需求" class="headerlink" title="软件需求"></a>软件需求</h1><p>软件需求指用户对目标系统在功能、性能等方面的期望;主要有:功能需求、性能需求、可靠性需求、可用性需求、出错处理需求、接口需求等</p><h4 id="软件需求3层次："><a href="#软件需求3层次：" class="headerlink" title="软件需求3层次："></a>软件需求3层次：</h4><p>软件需求的三个层次:<br><strong>业务需求</strong>：业务需求(business requirement)反映了组织机构或客户对系统、产品高层次的目标要求<br>业务需求从总体上描述了为什么要开发系统（why），组织希望达到什么目标。<br>一般使用前景和范围（vision and scope）文档来记录业务需求，称作项目轮廓图或市场需求文档。<br>这些最高级别的需求数量很少（2－5条）<br><strong>用户需求：</strong>用户需求(user requirement)描述了用户使用产品必须要完成的任务。<br>用例、场景描述和事件―响应表都是表达用户需求的有效途径。<br>在问题定义的基础上进行用户访谈、调查，对用户使用的场景进行整理，从而建立用户角度的需求。<br>描述了用户能使用系统来做些什么（what）。<br><strong>功能需求：</strong>系统分析员描述 开发人员在产品中实现的软件功能，用户利用这些功能来完成任务，满足业务需求。<br>功能需求是需求的主体，它描述的是开发人员如何设计具体的解决方案来实现这些用户需求（how），其数量往往比用户需求高一个数量级。 <br>这些需求记录在软件需求规格说明SRS（Software Requirments Specification）中。</p><h4 id="软件需求的分类"><a href="#软件需求的分类" class="headerlink" title="软件需求的分类"></a>软件需求的分类</h4><p><strong>功能需求：</strong>描述系统预期提供的功能或服务<br>系统应提供的服务<br>系统如何对输入做出反应<br>系统在特定条件下的行为<br>系统不应该做什么<br><strong>非功能需求</strong>：不直接与系统具体功能相关的需求。<br>产品需求：产品行为的需求，包括性能需求、可靠性需求和可用性需求等。<br>机构需求：客户和开发者所在机构中的政策和规定要求，如过程标准、实现要求、交付需求。<br>外部需求：所有的系统外部因素要求，如互操作需求</p><h4 id="需求工程："><a href="#需求工程：" class="headerlink" title="需求工程："></a>需求工程：</h4><p>应用已证实有效的技术、方法进行需求分析，确定客户需求，帮助分析人员理解问题并定义目标系统的所有外部特征的一门学科。<br>它通过合适的工具和记号系统地描述待开发系统及其行为特征和相关约束，形成需求文档，并对用户不断变化的需求演进给予支持。</p><h4 id="需求分析的基本活动："><a href="#需求分析的基本活动：" class="headerlink" title="需求分析的基本活动："></a>需求分析的基本活动：</h4><p>起始—询问一系列问题，以确立：<br>对问题的基本理解<br>谁需要解决方案<br>所期望解决方案的性质<br>导出—从所有利益相关者（ stakeholders）处获取需求（需求获取）<br>精化—创建一个分析模型，定义问题的信息域、功能域和行为域 （需求建模）<br>协商—通过协商过程来调解客户提出的过高的目标要求和相互冲突的需求<br><strong>规格说明</strong>—需求分析师的工作产品，为以下一种或几种:写好的文档、图形化的模型、形式化的数学模型、一组用户场景（用例）、原型<br>两种需求文档<br>需求定义：客户要求的完整列表<br>通常由客户和需求分析师一起编写，是开发人员对系统功能的一个合同，主要给客户阅读<br>需求规格说明：要构建系统的规格化说明<br>由需求分析师编写，并由其他软件开发人员使用<br><strong>确认（需求验证）—通过评审机制，寻找</strong>：<br>内容或解释上的差错<br>可能需要进一步澄清的地方<br>丢失的信息<br>不一致 (开发大型系统时的主要问题)<br>冲突或不现实的需求<br><strong>需求管理</strong><br>在项目执行过程中标识、控制和跟踪需求以及变更需求<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686457764762-77116d6e-3b9d-426f-8be4-35c3189f499c.png#averageHue=%23e6e5e4&clientId=udbefbbe5-2d1f-4&from=paste&height=418&id=u56f7035b&originHeight=522&originWidth=907&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=174007&status=done&style=none&taskId=u552e462a-dadf-4f43-9089-f13f8fabfc2&title=&width=725.6" alt="image.png"></p><h4 id="获取需求的技术："><a href="#获取需求的技术：" class="headerlink" title="获取需求的技术："></a>获取需求的技术：</h4><p><strong>面谈：</strong>面对面交流是理解业务功能和规则的最有效方法<br>该方法比较耗时和资源<br>项目组成员与单个用户或用户组举行会议<br>面谈步骤：<br>阅读背景资料<br>确定面谈目标<br>决定面谈对象<br>和面谈对象沟通。<br>整理面谈报告.<br>非正式面谈和正式面谈<br><strong>调查技术：</strong>向客户组织的相关人员发放调查表<br>关键：确定调查内容<br>非正式会谈<br>制定调查表<br>组织调查<br>使用场合：<br>系统相关者较多<br>地理上分布广<br><strong>观察实际业务过程：</strong>观察并记录业务流程<br>同用户进行交谈。<br>观察：有效收集信息的另一种方法<br>方式：直接在用户工作的地方观察他们的日常活动并记录下观察到的业务操作过程<br>观察方法<br>对办公室进行快速浏览<br>安排一定的时间观察用户的工作过程<br>同用户一道亲身实践体会工作过程<br>使用工作流图来进行记录<br>工作流 – 处理商业事务或客户请求的一系列步骤<br>工作流图：流程图、数据流图、活动图<br><strong>原型法：</strong>软件原型是一种软件系统的局部实现技术，可以帮助软件开发人员、用户和客户更好地理解软件需求。<br>使用原型的主要目的：<br>明确并完善需求<br>探索设计选择方案<br>发展为最终的产品原型<br><strong>基于场景的需求捕获方法：</strong>也称为情景实例的分析方法<br>基于对应用环境的某一特定情景的描述来阐述用户的需求<br>从场景的结构化描述中抽取活动图、场景、角色、数据关系图等，从而形成需求模型。<br><strong>竞争性需求分析法：</strong>1) N (Need 需求)<br>   你的创意解决了用户的什么需求?  <br>2) A (Approach 做法)<br>   你有什么招数, 特别是独特的招数, 来解决用户的痛苦。 <br>3) B (Benefit  好处)<br>   那你这个产品用户带来什么好处呢?<br>4) C (Competitors 竞争)<br>   与竞争对手相比你有什么优势?<br>5) D (Delivery)<br>   你怎么让目标用户都知道你的产品? 并且让产品的用户量快速提高? </p><h4 id="需求建模方法："><a href="#需求建模方法：" class="headerlink" title="需求建模方法："></a>需求建模方法：</h4><p><strong>结构化分析</strong><br>考虑数据和处理的分析建模方法<br>数据作为独立实体转换<br>数据对象定义了对象的属性和关系<br>处理表明数据对象在系统内流动时的数据转换<br><strong>面向对象分析</strong><br>定义类和类之间的协作方式</p><h4 id="结构化分析方法-技术："><a href="#结构化分析方法-技术：" class="headerlink" title="结构化分析方法-技术："></a>结构化分析方法-技术：</h4><p><a href="https://www.zhihu.com/tardis/zm/art/389748904?source_id=1003">如何掌握结构化的分析方法？</a></p><h4 id="数据流图："><a href="#数据流图：" class="headerlink" title="数据流图："></a>数据流图：</h4><p><a href="https://blog.csdn.net/qq_50977450/article/details/121802790">软件工程：数据流图，数据字典的画法，以及如何转化为软件结构图_数据字典怎么画_Brother汤的博客-CSDN博客</a><br><a href="https://blog.csdn.net/Erin_jwx/article/details/121685204">【软件工程】根据数据流图导出程序结构_数据流图转换为软件结构图_AC它真的很香的博客-CSDN博客</a><br><a href="https://blog.csdn.net/shulianghan/article/details/109271777">【软件工程】数据流图 ( 数据流图简介 | 数据流图概念 | 数据流 | 加工 | 数据存储 | 外部实体 | 数据流图分层 | 顶层数据流图 | 中层数据流图 | 底层数据流图 )_韩曙亮的博客-CSDN博客</a><br><strong>数据字典：</strong>数字字典是指一个用来存储和管理数据元素定义和描述信息的集合，它包括了系统中使用到的所有数据元素、数据结构、数据类型、数据格式、数据值域等信息。数字字典通常用于帮助软件开发人员在系统分析、设计和开发中更好地理解和管理数据元素。其基本功能是数据定义。<br>找到变换中心是数据流图导出结构图的关键，一般将数据流划分为交换流和事务流。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686549571777-b09c11ba-4ea8-49d4-96f1-487fab4fff0c.png#averageHue=%23fefefe&clientId=udbefbbe5-2d1f-4&from=paste&height=265&id=ud93c7aa1&originHeight=331&originWidth=837&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=17762&status=done&style=none&taskId=u1f677d85-a4f9-4a0b-a7bb-b099cba043c&title=&width=669.6" alt="image.png"><br> 结构化分析常用工具：数据流图（DFD），数据字典（DD），判定表，判定树。<br> 详细设计阶段常用的工具：程序流程图，N-S图，PAD图，HIP0图。 而需求分析主要是完成总体设计，是结构化分析，需求分析建模是采用结构化分析建模。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686551978053-c8a2111d-f355-45c3-981d-34eed55b29e1.png#averageHue=%23fefefe&clientId=udbefbbe5-2d1f-4&from=paste&height=308&id=u8f734e0a&originHeight=385&originWidth=822&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=17756&status=done&style=none&taskId=u8b97d9cd-3a87-44a1-81a9-b3f7022c08a&title=&width=657.6" alt="image.png"><br>是的，数据流图和数据字典通常被视为系统的逻辑模型的两个主要组成部分。<br>数据流图（Data Flow Diagram，简称DFD）是一种图形化工具，用于描述系统中数据的流动和处理过程。它通过图形符号表示系统中的各种处理过程、数据存储、数据流动和外部实体，形成一个数据流图，用于描述系统的功能和行为。数据流图通常用于识别和定义系统的功能需求、系统流程和数据流动的过程。<br>数据字典（Data Dictionary）是系统中使用的各种数据和信息的集合，包括数据类型、数据格式、数据来源和数据用途等。它用于描述系统中各种数据和信息的定义和用途，从而为系统的设计、开发和测试提供指导和依据。数据字典通常包括数据元素的名称、描述、数据类型、数据长度、数据格式、取值范围等信息。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686552334790-097be0fe-2d23-4e89-950f-d1c771b33c9f.png#averageHue=%23fefefd&clientId=udbefbbe5-2d1f-4&from=paste&height=266&id=ubf99bc76&originHeight=333&originWidth=820&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=19044&status=done&style=none&taskId=u39b31468-86b6-4368-9b34-ddf4e2ce0f4&title=&width=656" alt="image.png"><br>如果在数据流图中出现控制流，将会导致数据流图的复杂度增加，难以理解和维护。此外，过多的控制流可能也会使数据流图变得冗长和混乱，影响对系统的理解和描述。<br>因此，数据流图不允许出现控制流，它应该专注于描述系统中的数据流动和处理过程，从而更好地识别和定义系统的功能需求和功能间的关系。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686552393227-e8ef41d3-01d6-4cab-a63f-d895f101518a.png#averageHue=%23fefefe&clientId=udbefbbe5-2d1f-4&from=paste&height=286&id=u5c97a8f0&originHeight=357&originWidth=1138&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=26325&status=done&style=none&taskId=u826f6d27-19e2-459b-ac50-5223aa40687&title=&width=910.4" alt="image.png"><br>需求规格说明书不包括软件的可行性研究的依据<strong>需求分析</strong>：系统必须做什么？定义时期最后一个阶段，产生软件需求规格说明书。可行性研究是在其上一个步骤<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686552681986-c594759e-7b46-4ddc-90c4-d9cc1c51ed6f.png#averageHue=%23fefefd&clientId=udbefbbe5-2d1f-4&from=paste&height=249&id=u01abc19a&originHeight=311&originWidth=1101&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=25436&status=done&style=none&taskId=ucbe8b250-5486-47f8-bb37-8ff7b3b683b&title=&width=880.8" alt="image.png"><br> 软件需求分析阶段的主要工作包括四个方面：<strong>需求获取、需求分析、编写需求规格说明书和需求评审</strong><a href="https://www.bing.com/ck/a?!&&p=2221036aeb1ef788JmltdHM9MTY4NjQ0MTYwMCZpZ3VpZD0wZDhmZWU2OS01NWY5LTZhMzUtMTYyMi1mY2IwNTRiYzZiZWYmaW5zaWQ9NTQ4MA&ptn=3&hsh=3&fclid=0d8fee69-55f9-6a35-1622-fcb054bc6bef&u=a1aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3F1ZXN0aW9uVGVybWluYWwvNDg3NzEyMTY1MTM0NGMyYmIxNGE0ZWY2YjVjMmVhMjg_dG9Db21tZW50SWQ9OTcwMQ&ntb=1">1</a><a href="https://www.bing.com/ck/a?!&&p=eb950947559c9644JmltdHM9MTY4NjQ0MTYwMCZpZ3VpZD0wZDhmZWU2OS01NWY5LTZhMzUtMTYyMi1mY2IwNTRiYzZiZWYmaW5zaWQ9NTQ4MQ&ptn=3&hsh=3&fclid=0d8fee69-55f9-6a35-1622-fcb054bc6bef&u=a1aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTgyODIzL2FydGljbGUvZGV0YWlscy8xMTEzODcxMDY&ntb=1">2</a><a href="https://www.bing.com/ck/a?!&&p=1f44ead18f68f380JmltdHM9MTY4NjQ0MTYwMCZpZ3VpZD0wZDhmZWU2OS01NWY5LTZhMzUtMTYyMi1mY2IwNTRiYzZiZWYmaW5zaWQ9NTQ4Mg&ptn=3&hsh=3&fclid=0d8fee69-55f9-6a35-1622-fcb054bc6bef&u=a1aHR0cHM6Ly93d3cueWluZ3Bvcy5jb20vc2hlbmdodW9iYWlrZS9LbDhXRG45M1laQjFkYXkuaHRtbA&ntb=1">3</a><a href="https://www.bing.com/ck/a?!&&p=ffeb755af5395b61JmltdHM9MTY4NjQ0MTYwMCZpZ3VpZD0wZDhmZWU2OS01NWY5LTZhMzUtMTYyMi1mY2IwNTRiYzZiZWYmaW5zaWQ9NTQ4Mw&ptn=3&hsh=3&fclid=0d8fee69-55f9-6a35-1622-fcb054bc6bef&u=a1aHR0cHM6Ly9lYXN5bGVhcm4uYmFpZHUuY29tL2VkdS1wYWdlL3RpYW5nb25nL3F1ZXN0aW9uZGV0YWlsP2lkPTE3MzAwMDI4OTQ3MzAxNzE1NTI&ntb=1">4</a><a href="https://www.bing.com/ck/a?!&&p=cb6ca98731c722a8JmltdHM9MTY4NjQ0MTYwMCZpZ3VpZD0wZDhmZWU2OS01NWY5LTZhMzUtMTYyMi1mY2IwNTRiYzZiZWYmaW5zaWQ9NTQ4NA&ptn=3&hsh=3&fclid=0d8fee69-55f9-6a35-1622-fcb054bc6bef&u=a1aHR0cHM6Ly96aGlkYW8uYmFpZHUuY29tL3F1ZXN0aW9uLzI4NDI0OTM5OC5odG1s&ntb=1">5</a>。需求获取是通过与用户接触初步确定系统的功能；需求分析的任务是确定系统必须完成哪些工作，提出完整、准确、清晰、具体的要求；在需求分析阶段结束之前，系统分析员应该编写需求规格说明书；需求评审是根据需求规格说明书来严格审查和验证需求分析的结果<a href="https://www.bing.com/ck/a?!&&p=8a0b79d9bf07db70JmltdHM9MTY4NjQ0MTYwMCZpZ3VpZD0wZDhmZWU2OS01NWY5LTZhMzUtMTYyMi1mY2IwNTRiYzZiZWYmaW5zaWQ9NTQ4NQ&ptn=3&hsh=3&fclid=0d8fee69-55f9-6a35-1622-fcb054bc6bef&u=a1aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3F1ZXN0aW9uVGVybWluYWwvNDg3NzEyMTY1MTM0NGMyYmIxNGE0ZWY2YjVjMmVhMjg_dG9Db21tZW50SWQ9OTcwMQ&ntb=1">1</a>。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686552864351-d5b01c1b-e496-48d4-b9bc-8f7298761c09.png#averageHue=%23fefefd&clientId=udbefbbe5-2d1f-4&from=paste&height=328&id=uc63bd510&originHeight=410&originWidth=1106&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=32259&status=done&style=none&taskId=u6458aabe-8189-42bd-8d76-5b80fc185b9&title=&width=884.8" alt="image.png"><br><strong>数据字典中什么是加工条目：</strong>，加工条目（Processing Entry）是指描述系统中某个数据项的加工过程或转换过程的数据元素。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686563702757-e3ace121-f3eb-4d47-b0ad-b11bf0e5fa1b.png#averageHue=%23fefdfd&clientId=udbefbbe5-2d1f-4&from=paste&height=244&id=u54659413&originHeight=305&originWidth=1091&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=26072&status=done&style=none&taskId=ufb7f1eb4-c95b-4952-a686-2618a7cadbb&title=&width=872.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686563900613-d0c11afc-001a-454c-8215-59087b3c074e.png#averageHue=%23fdfdfc&clientId=udbefbbe5-2d1f-4&from=paste&height=228&id=uaab46eac&originHeight=285&originWidth=960&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=27346&status=done&style=none&taskId=u485d6e82-8bc5-4e4c-a20c-068b0990cba&title=&width=768" alt="image.png"><br><a href="https://blog.csdn.net/I_r_o_n_M_a_n/article/details/121309525">软件工程 – 数据流图的画法_CodeJiao的博客-CSDN博客</a></p><h4 id="数据流转化为软件体系结构："><a href="#数据流转化为软件体系结构：" class="headerlink" title="数据流转化为软件体系结构："></a>数据流转化为软件体系结构：</h4><p><a href="https://blog.csdn.net/lipeijie163/article/details/109703886">软件工程——软件结构图设计（变换分析设计、事务分析设计、混合流设计）_Rucooo的博客-CSDN博客</a></p><h4 id="模块独立："><a href="#模块独立：" class="headerlink" title="模块独立："></a>模块独立：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686618575144-06ecac9e-fa31-4a9a-bfef-076db713306e.png#averageHue=%23fefefe&clientId=udbefbbe5-2d1f-4&from=paste&height=302&id=ub0e4d45d&originHeight=378&originWidth=1102&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=19658&status=done&style=none&taskId=u459cd818-8eae-48c5-be4b-6bb77f59de2&title=&width=881.6" alt="image.png"><br><a href="https://www.cnblogs.com/1002-/p/14643746.html#:~:text=%E7%AD%94%EF%BC%9A%20%E8%BD%AF%E4%BB%B6%E7%BB%93%E6%9E%84%E5%9B%BE%E7%9A%84%E5%BD%A2%E6%80%81%E7%89%B9%E5%BE%81%EF%BC%9A%20%E2%91%A0%E6%B7%B1%E5%BA%A6%EF%BC%9A%E7%BB%93%E6%9E%84%E5%9B%BE%E6%8E%A7%E5%88%B6%E7%9A%84%E5%B1%82%E6%AC%A1%EF%BC%8C%E5%8D%B3%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B1%82%E6%95%B0%E3%80%82,%E2%91%A1%E5%AE%BD%E5%BA%A6%EF%BC%9A%E4%B8%80%E5%B1%82%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E6%A8%A1%E5%9D%97%E4%B8%AA%E6%95%B0%E3%80%82%20%E2%91%A2%E6%89%87%E5%87%BA%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E7%9B%B4%E6%8E%A5%E4%B8%8B%E5%B1%9E%E6%A8%A1%E5%9D%97%E7%9A%84%E4%B8%AA%E6%95%B0%E3%80%82%20%E2%91%A3%E6%89%87%E5%85%A5%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E7%9B%B4%E6%8E%A5%E4%B8%8A%E5%B1%9E%E6%A8%A1%E5%9D%97%E7%9A%84%E4%B8%AA%E6%95%B0%E3%80%82">地信1902李孟雪 第八章思考题 - lmxshelly - 博客园</a><br><a href="https://blog.csdn.net/pikalavender/article/details/102601298">模块独立性_pikalavender的博客-CSDN博客</a></p><h4 id="设计规格说明书："><a href="#设计规格说明书：" class="headerlink" title="设计规格说明书："></a>设计规格说明书：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686618933569-ab00e323-20be-417a-b653-0b95148c179d.png#averageHue=%23fefefe&clientId=udbefbbe5-2d1f-4&from=paste&height=282&id=u4ae3e287&originHeight=352&originWidth=1090&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=18849&status=done&style=none&taskId=u6813e5a7-ccfc-47f4-a077-69b7b515e56&title=&width=872" alt="image.png"><br><a href="https://blog.csdn.net/weiwenhuaming_/article/details/112559628">软件需求规格说明书，概要设计说明书，详细设计说明书（文档）_各自软件系统的需求规格说明书、概要设计以及详细设计。_caiqingheng的博客-CSDN博客</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686619137666-7116228a-4311-427a-86c6-7c71587c83fb.png#averageHue=%23fefefe&clientId=udbefbbe5-2d1f-4&from=paste&height=279&id=u4e80bb11&originHeight=349&originWidth=1075&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=22125&status=done&style=none&taskId=u50b6d64d-de59-4119-8758-638b8fba61e&title=&width=860" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686619211230-3421b178-5e75-453d-9f32-14f21e0088b7.png#averageHue=%23fefefe&clientId=udbefbbe5-2d1f-4&from=paste&height=273&id=ub3fe2739&originHeight=341&originWidth=1108&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=21478&status=done&style=none&taskId=u143e98b3-2a03-44d4-90cb-1de00b0120a&title=&width=886.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686619234158-b1d55f0a-6f1a-4543-80f6-9e1810727f4e.png#averageHue=%23fefefe&clientId=udbefbbe5-2d1f-4&from=paste&height=262&id=u7a7243b9&originHeight=328&originWidth=1088&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=23507&status=done&style=none&taskId=u63b1dd45-1d44-4932-b44d-2007c35a0b0&title=&width=870.4" alt="image.png"><br><a href="https://blog.csdn.net/jerry11112/article/details/79180171">【软件工程】 软件设计阶段_光哥_帅的博客-CSDN博客</a>软件设计阶段分为总体设计和详细设计，总体设计是结构设计：（确定软件系统的整体结构和组成方式，包括模块划分、模块之间的关系和接口等。)和模块过程设计（模块的具体实现）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686633566619-abeef38f-c8f1-4c82-866d-ccb591261967.png#averageHue=%23fefefe&clientId=udbefbbe5-2d1f-4&from=paste&height=248&id=uc1becde7&originHeight=310&originWidth=759&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=17369&status=done&style=none&taskId=u61721e2c-3f30-499c-8bc4-942b66db3b1&title=&width=607.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686633773954-1cb65e21-5215-4541-8b8f-9c008a91c68e.png#averageHue=%23fefefd&clientId=udbefbbe5-2d1f-4&from=paste&height=259&id=ua7eeab71&originHeight=324&originWidth=999&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=23277&status=done&style=none&taskId=u95ef2090-eb95-4a58-a944-b3055b0470b&title=&width=799.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686633960092-403a6d6b-2021-4417-a3a9-d0a13dc6ab9c.png#averageHue=%23fefefd&clientId=udbefbbe5-2d1f-4&from=paste&height=268&id=ucc9ca45e&originHeight=335&originWidth=1094&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=23912&status=done&style=none&taskId=ua6785c19-0f0e-4e78-bb72-0944fe8c76e&title=&width=875.2" alt="image.png"><br><a href="https://blog.51cto.com/u_15060513/3490901">结构化设计_51CTO博客_结构化设计的目标是</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686634089945-f7d3ef38-db3c-46a1-b037-20ef03e8c0bb.png#averageHue=%23fefefe&clientId=udbefbbe5-2d1f-4&from=paste&height=256&id=uaa46df2c&originHeight=320&originWidth=699&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=17194&status=done&style=none&taskId=uee881a98-3a80-4ddb-bb74-8f729df3a1d&title=&width=559.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686634386242-d71b8c2d-8381-49dc-9b33-d7b0021ea9b7.png#averageHue=%23fefefe&clientId=udbefbbe5-2d1f-4&from=paste&height=267&id=u502437e2&originHeight=334&originWidth=741&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=15609&status=done&style=none&taskId=ue9499935-5e6b-4656-88dd-ec71fbcfa76&title=&width=592.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686634515392-9b731269-7cb2-43f8-bab1-9b47f8968e74.png#averageHue=%23fefefe&clientId=udbefbbe5-2d1f-4&from=paste&height=283&id=uef6ce70e&originHeight=354&originWidth=798&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=17546&status=done&style=none&taskId=u5960706e-5542-4d26-abd1-013f0ab9a01&title=&width=638.4" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686473616949-cb4bf435-faa5-4b31-8bf0-211f0e084dda.png#averageHue=%23eae8e8&clientId=udbefbbe5-2d1f-4&from=paste&height=609&id=ue313cdf9&originHeight=761&originWidth=1305&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=194651&status=done&style=none&taskId=uc37a4559-8fde-4918-a3ac-b20a9444b9c&title=&width=1044" alt="image.png">Beta测试是一种软件测试方式，旨在通过让最终用户或特定用户群体使用软件产品的测试版本，以帮助开发人员收集用户反馈和识别潜在问题。Beta测试通常是软件开发周期中的最后一个测试阶段，在正式发布之前进行。<br>Beta测试通常包括以下几个步骤：</p><ol><li>选定测试用户：在Beta测试阶段，开发团队会选定一些最终用户或特定用户群体来测试软件产品的测试版本，以获得真实的用户反馈和使用情况。</li><li>发布测试版本：开发团队会将软件产品的测试版本发布给测试用户，让他们使用并提供反馈和建议。</li><li>收集用户反馈：测试用户使用测试版本后，会向开发团队提供反馈和建议，包括软件的使用体验、功能问题、性能问题等。</li><li>分析和修复问题：开发团队会分析用户反馈和测试结果，识别潜在问题并进行修复和改进。</li><li>发布正式版本：经过多次Beta测试和问题修复后，开发团队会发布正式版本的软件产品。</li></ol><p>Beta测试可以帮助开发人员在软件发布之前获得真实的用户反馈和使用情况，从而识别和修复潜在问题，提高软件的质量和用户体验。同时，Beta测试也可以建立用户与开发团队之间的沟通渠道，促进开发团队和用户之间的合作和沟通。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686474058809-31514159-14a6-4e2a-abb8-097533b525fa.png#averageHue=%23e9e7e7&clientId=udbefbbe5-2d1f-4&from=paste&height=610&id=uf3429016&originHeight=763&originWidth=1372&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=194117&status=done&style=none&taskId=ufcf7d794-0327-4c73-889a-454c7a56232&title=&width=1097.6" alt="image.png"><br><strong>条件覆盖</strong>：判定中每个条件的所有可能结果至少出现一次，但未必能覆盖全部分支<br><strong>判定条件覆盖</strong>：判定&#x2F;条件覆盖是使判定中每个条件的所有可能结果至少出现一次，并且每个判定本身的所有可能结果也至少出现一次；<br><a href="https://www.cnblogs.com/jerry19880126/articles/2623433.html">条件覆盖，路径覆盖，语句覆盖，分支覆盖 - Jerry19880126 - 博客园</a></p><h4 id="软件设计阶段："><a href="#软件设计阶段：" class="headerlink" title="软件设计阶段："></a>软件设计阶段：</h4><p><a href="https://blog.csdn.net/jerry11112/article/details/79180171">【软件工程】 软件设计阶段_光哥_帅的博客-CSDN博客</a><br>软件设计阶段输出的主要是设计规格说明书</p><h4 id="程序的正确性：是程序能够满足规格说明书和用户目标的程度"><a href="#程序的正确性：是程序能够满足规格说明书和用户目标的程度" class="headerlink" title="程序的正确性：是程序能够满足规格说明书和用户目标的程度"></a>程序的正确性：是程序能够满足规格说明书和用户目标的程度</h4><h4 id="等价类的划分：等价类划分法-案例剖析-设计测试用例-等价类划分法举例-chde2Wang的博客-CSDN博客"><a href="#等价类的划分：等价类划分法-案例剖析-设计测试用例-等价类划分法举例-chde2Wang的博客-CSDN博客" class="headerlink" title="等价类的划分：等价类划分法-案例剖析-设计测试用例_等价类划分法举例_chde2Wang的博客-CSDN博客"></a>等价类的划分：<a href="https://blog.csdn.net/weixin_38383877/article/details/124909626#:~:text=%E6%9C%89%E6%95%88%E7%AD%89%E4%BB%B7%E7%B1%BB%EF%BC%9A%20%E5%8F%AA%E5%AE%8C%E5%85%A8%E6%BB%A1%E8%B6%B3%E4%BA%A7%E5%93%81%E8%A7%84%E5%88%99%E8%AF%B4%E6%98%8E%E7%9A%84%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%8D%B3%E6%9C%89%E6%95%88%E7%9A%84%E3%80%81%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E9%9B%86%E5%90%88%E3%80%82%20%E5%88%A9%E7%94%A8%E6%9C%89%E6%95%88%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%8F%AF%E4%BB%A5%E6%A3%80%E9%AA%8C%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%90%A6%E6%BB%A1%E8%B6%B3%E8%A7%84%E5%88%99%E8%AF%B4%E6%98%8E%E6%89%80%E8%A7%84%E5%AE%9A%E7%9A%84%E5%8A%9F%E8%83%BD%E6%80%A7%E8%A6%81%E6%B1%82%E3%80%82,%E6%97%A0%E6%95%88%E7%AD%89%E4%BB%B7%E7%B1%BB%EF%BC%9A%20%E4%B8%8D%E6%BB%A1%E8%B6%B3%E7%A8%8B%E5%BA%8F%E8%BE%93%E5%85%A5%E8%A6%81%E6%B1%82%E6%88%96%E8%80%85%E6%97%A0%E6%95%88%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9E%84%E6%88%90%E7%9A%84%E9%9B%86%E5%90%88%E3%80%82%20%E5%88%A9%E7%94%A8%E6%97%A0%E6%95%88%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%8F%AF%E4%BB%A5%E6%A3%80%E6%B5%8B%E7%A8%8B%E5%BA%8F%E5%AF%B9%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E8%83%BD%E5%8A%9B%E3%80%82">等价类划分法-案例剖析-设计测试用例_等价类划分法举例_chde2Wang的博客-CSDN博客</a></h4><h4 id="代码审查：代码审查-Code-Review-代码审核-夕刃的博客-CSDN博客"><a href="#代码审查：代码审查-Code-Review-代码审核-夕刃的博客-CSDN博客" class="headerlink" title="代码审查：代码审查(Code Review)_代码审核_夕刃的博客-CSDN博客"></a>代码审查：<a href="https://blog.csdn.net/czyying123/article/details/115585466">代码审查(Code Review)_代码审核_夕刃的博客-CSDN博客</a></h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686710551367-b9495301-ae5e-4796-9a74-61644dba51e0.png#averageHue=%23fefdfb&clientId=u3a2eaed4-c828-4&from=paste&height=226&id=ua819d004&originHeight=282&originWidth=629&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=23295&status=done&style=none&taskId=u4f0328e3-62da-4b25-9b5e-958e7468d66&title=&width=503.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686634734519-7308ebf3-fbf6-499e-8b01-789589b63a49.png#averageHue=%23fefefe&clientId=udbefbbe5-2d1f-4&from=paste&height=271&id=u8bab60e9&originHeight=339&originWidth=821&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=16719&status=done&style=none&taskId=ua6b63e6b-45f5-44b7-a2c3-446e319915b&title=&width=656.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686635158558-a5442631-0890-41b4-b631-4bcb0b8d5678.png#averageHue=%23fefefe&clientId=u385899d5-e87f-4&from=paste&height=280&id=ub4825c3f&originHeight=350&originWidth=846&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=20345&status=done&style=none&taskId=u675040ea-7f29-45bd-aaf9-b0a998f4b8c&title=&width=676.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686739851791-a0c70b1e-4121-448c-95b2-655e2c808a2b.png#clientId=u3a2eaed4-c828-4&from=paste&height=164&id=u1fa264d8&originHeight=205&originWidth=406&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=9769&status=done&style=none&taskId=u1cbfba7d-d89d-4357-b079-9fbc9d3ebbf&title=&width=324.8" alt="image.png"></p><h4 id="功能点方法（FPA）："><a href="#功能点方法（FPA）：" class="headerlink" title="功能点方法（FPA）："></a>功能点方法（FPA）：</h4><div class="code-wrapper"><pre><code class="hljs">  （Function Point Analysis） 功能点分析法，简称FPA，与代码行分析法是近年来最流行的两种基础软件规模估算和度量方法。是从用户角度出发度量软件规模的一种方法。它从用户的角度出发，将**系统分为数据功能和事物功能两大类（这是要依靠**信息域值），分别根据具体的规则来计算功能点，最后结合系统的特征因子来调整功能点数， 从而得到最终的系统规模。</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686635441241-e78c5f84-6c8b-4242-a920-f75d2a0c2f50.png#averageHue=%23fefefd&clientId=u385899d5-e87f-4&from=paste&height=258&id=u49f04be9&originHeight=323&originWidth=543&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=19561&status=done&style=none&taskId=ue17c0ccd-2dbf-49d8-b287-abf654e4f36&title=&width=434.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686710447316-018fcbd4-074e-45dc-b6fc-8903aad3a658.png#averageHue=%23fefdfc&clientId=u3a2eaed4-c828-4&from=paste&height=256&id=u710982f9&originHeight=320&originWidth=615&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=22870&status=done&style=none&taskId=ueeb0fa0e-7664-405e-a2d5-14f3b898407&title=&width=492" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686710658820-567a7a7b-094f-40f3-b58f-4b05a5f00821.png#averageHue=%23fefefd&clientId=u3a2eaed4-c828-4&from=paste&height=242&id=u1293cf65&originHeight=303&originWidth=817&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=18872&status=done&style=none&taskId=u9c6bd04c-4e94-4dc6-95d0-4b2ae6bed7f&title=&width=653.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686710730505-71b977f3-4348-41a0-a27e-e843149aecf8.png#averageHue=%23fefefd&clientId=u3a2eaed4-c828-4&from=paste&height=247&id=u5b24152b&originHeight=309&originWidth=772&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=15844&status=done&style=none&taskId=u466be684-b76e-4c20-9fec-7bce1df3763&title=&width=617.6" alt="image.png"><br>A. 计算机辅助静态分析是软件测试方法中的静态测试方法之一。静态测试是在代码执行之前对软件进行检查，以发现潜在的缺陷和错误。计算机辅助静态分析是使用计算机工具对软件代码进行分析，以检测潜在的缺陷和错误。这种方法可以自动化地执行许多常见的静态测试任务，例如语法检查、类型检查、代码风格检查等。因此，它可以提高软件开发的效率和质量。其他静态测试方法包括代码审查、故障模拟和需求分析等。</p><p> <img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686710826326-20c09ba3-98a4-4cbd-ba5c-7ee756caedce.png#averageHue=%23fefefd&clientId=u3a2eaed4-c828-4&from=paste&height=266&id=u95edfa8c&originHeight=333&originWidth=843&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=18690&status=done&style=none&taskId=ud0077091-89db-4ed8-9bc5-c6c4041723a&title=&width=674.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686710833984-b514a7f8-0002-4c76-9788-e9e5730e4a70.png#averageHue=%23ededee&clientId=u3a2eaed4-c828-4&from=paste&height=230&id=u6a8790b4&originHeight=288&originWidth=1092&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=148165&status=done&style=none&taskId=u19594ae1-dc21-461e-96c1-bbab693dc03&title=&width=873.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686728511727-84fa4f31-25a6-4fd8-9612-2f6a0dbb393b.png#averageHue=%23f5f5f5&clientId=u3a2eaed4-c828-4&from=paste&height=80&id=u52228a7a&originHeight=100&originWidth=725&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=9883&status=done&style=none&taskId=u229ba343-dfb3-44b0-a723-9e184c6032e&title=&width=580" alt="image.png">详细设计阶段可以利用判定树和判定表。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686728690735-7b389dc3-fc77-4b89-b3bb-e548a1e17f18.png#averageHue=%23efefef&clientId=u3a2eaed4-c828-4&from=paste&height=87&id=ucc78fef8&originHeight=109&originWidth=716&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=16752&status=done&style=none&taskId=uf94b5fb1-9523-4ffc-8903-6084dd41b36&title=&width=572.8" alt="image.png"><br>软件重用是指在开发新软件时，利用已有的可重复使用的软件组件、模块或库，以便更快地、更经济地开发出高质量的软件。它可以降低软件开发成本、缩短开发周期、提高软件的可靠性、可维护性和可重用性。<br>具体来说，通过软件重用可以实现以下优点：</p><ol><li>提高软件开发效率：软件重用可以避免重复开发已有的功能，减少了开发时间和成本。</li><li>提高软件质量：经过多次测试和验证的可重用组件，具有高质量和稳定性，能够提高新软件的可靠性和稳定性。</li><li>提高软件可维护性：可重用的软件组件通常具有良好的文档和接口规范，易于维护和更新。</li><li>提高软件可重用性：重用软件组件可以使开发人员积累更多的经验和技能，并促进软件组件的共享和发展。</li></ol><p>因此，软件重用是降低软件成本和提高软件质量的合理方法之一<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686729006361-c491cd54-8545-4a30-87ae-de83dbffdd47.png#averageHue=%23f5f5f5&clientId=u3a2eaed4-c828-4&from=paste&height=74&id=u316440cc&originHeight=92&originWidth=801&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=10582&status=done&style=none&taskId=u45f97c6d-217d-4457-ba92-eacf5efb12e&title=&width=640.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686729162422-2bddcd9d-3453-408e-9756-53d209e0c96a.png#averageHue=%23ededed&clientId=u3a2eaed4-c828-4&from=paste&height=60&id=u22604e80&originHeight=75&originWidth=813&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=13763&status=done&style=none&taskId=ucfa16dcd-76d6-43ad-a1c9-3b539f9f576&title=&width=650.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686729420936-5d622115-b97d-4eb5-a911-efa5e71fcd8e.png#averageHue=%23ececec&clientId=u3a2eaed4-c828-4&from=paste&height=50&id=u649ce2b3&originHeight=63&originWidth=820&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=14046&status=done&style=none&taskId=u259ee7d7-bfae-4fe7-b033-1632597f256&title=&width=656" alt="image.png"><br>对的，盒图的特点是取<br>消了传统流程图中的流程线，而是使用缩进和嵌套的方式来表示程序的结构和控制流程。这种表达方式强迫程序员以结构化方式思考和解决问题，避免了不必要的跳转和分支，使程序更易于理解和维护。、</p><h4 id="McCall的质量模型"><a href="#McCall的质量模型" class="headerlink" title="McCall的质量模型"></a>McCall的质量模型</h4><p><a href="https://blog.csdn.net/gz153016/article/details/50483417">McCall的软件质量模型_gz153016的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>课程作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uml错题</title>
    <link href="/2024/01/26/%E9%94%99%E9%A2%98%EF%BC%9A/"/>
    <url>/2024/01/26/%E9%94%99%E9%A2%98%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1680535573589-32c160cf-aff8-49a5-aea8-d5cef700a45d.png#averageHue=%23fefefe&clientId=uf51f3b15-4e6e-4&from=paste&height=234&id=u6d79fc2d&originHeight=293&originWidth=997&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27485&status=done&style=none&taskId=u278d8c92-3005-46ff-ac19-16c33088158&title=&width=797.6" alt="image.png"></p><h2 id="线程是-的一个动作流，能够与其他线程并发执行。"><a href="#线程是-的一个动作流，能够与其他线程并发执行。" class="headerlink" title="线程是_____的一个动作流，能够与其他线程并发执行。"></a><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1680535713726-4519ebdf-3f3f-4d4f-80e7-c6214d991311.png#averageHue=%23fefefe&clientId=uf51f3b15-4e6e-4&from=paste&height=238&id=uf0b3298c&originHeight=298&originWidth=936&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28490&status=done&style=none&taskId=u7c5d56ce-9b78-433f-bdc9-d0193c3c8d2&title=&width=748.8" alt="image.png">线程是_____的一个动作流，能够与其他线程并发执行。</h2><p>线程是进程的一个动作流，能够与其他线程并发执行。一个进程可以包含多个线程，每个线程都有自己的执行路径，可以独立地执行代码。线程之间可以共享进程的资源，如内存、文件句柄等，这使得线程之间的通信变得更加容易。线程的并发执行可以提高系统的处理能力和资源利用率，但也需要开发人员特别注意线程安全问题。</p><h2 id="动作流，控制流，数据字典分别是什么？"><a href="#动作流，控制流，数据字典分别是什么？" class="headerlink" title="动作流，控制流，数据字典分别是什么？"></a>动作流，控制流，数据字典分别是什么？</h2><p>动作流（Action Flow）是指描述系统中各种操作和动作之间的执行顺序和依赖关系的一种模型。动作流通常用于描述业务流程、工作流程等，可以帮助人们更好地理解和管理复杂的业务逻辑。<br>控制流（Control Flow）是指程序中各种语句之间的执行顺序和流程控制，例如条件语句、循环语句、跳转语句等。<strong>控制流描述了程序的执行路径</strong>，可以帮助开发人员更好地理解和控制程序的执行逻辑。<br>数据字典（Data Dictionary）是指系统中各种数据元素的定义、属性和关系的说明文档。数据字典通常包括数据元素的名称、数据类型、长度、取值范围、含义、来源、关系等信息，可以帮助开发人员更好地理解和管理系统中的数据。数据字典也是数据库设计和维护中常用的工具之一。</p><h2 id="什么是主动对象"><a href="#什么是主动对象" class="headerlink" title="什么是主动对象"></a>什么是主动对象</h2><p>主动对象模式是一种非常常见的并发编程模式，它可以使系统更加健壮、稳定和高效。<br>它将对象的状态和行为分离，将行为封装在一个独立</p><ul><li>主动类（活动类）：实例应为一个或多个进程或线程，可以和其他类元素的行为并发工作。</li></ul><p>的线程中执行，从而实现异步、非阻塞的调用方式。<br><a href="https://www.timsrc.com/article/97/uml-active-class">【UML简明教程】主动类 - Tim的资源站</a><br>主动对象：不再外部刺激下可以改变自身状态,通常用进程或线程实现，如：定时器<br>被动对象：不改变自身状态，除非接收外部信息<br>在UML（统一建模语言）中，主动对象和被动对象是两种不同的对象模型，它们分别描述了对象的行为模式和角色。下面是它们的具体含义：</p><p>主动对象（Active Object）：指具有主动行为能力的对象，它通常具有自主性和主导性，能够主动发起交互和执行操作。主动对象通常拥有独立的执行线程，并通过消息队列等机制来实现异步和非阻塞的调用方式。</p><p>被动对象（Passive Object）：指缺乏主动行为能力的对象，它通常是被动响应其他对象的请求和操作，不具有独立的执行线程和消息队列。被动对象通常是同步和阻塞的，它的行为由其他对象发起并控制。</p><p>在UML中，主动对象和被动对象通常使用不同的符号来表示，以便于区分和理解。主动对象通常使用带有双下划线的矩形框来表示，例如：</p><p>+———————–+<br>| <strong>ActiveObject</strong>       |<br>| +doSomething()         |<br>| +handleMessage(message)|<br>+———————–+<br>在上面的示例中，ActiveObject表示一个主动对象，它具有doSomething()和handleMessage()两个公共方法，用于执行某些操作和处理消息。主动对象通常具有自主性和主导性，能够通过消息队列等机制来实现异步和非阻塞的调用方式。</p><p>被动对象通常使用普通的矩形框来表示，例如：</p><p>+———————–+<br>| PassiveObject         |<br>| +processRequest()      |<br>+———————–+<br>在上面的示例中，PassiveObject表示一个被动对象，它具有一个公共方法processRequest()，用于处理其他对象发起的请求。被动对象通常是同步和阻塞的，它的行为由其他对象发起并控制。<br>1.面向对象的基本建模原则：抽象，封装，继承，多态性，消息通信。泛化描述的是子类与父类之间的关系，属于类的关系特征的内容。所以答案D不是对象具有的特征。<br>2.</p>]]></content>
    
    
    <categories>
      
      <category>课程作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c#课程作业</title>
    <link href="/2024/01/26/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%EF%BC%9A/"/>
    <url>/2024/01/26/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="QQ项目："><a href="#QQ项目：" class="headerlink" title="QQ项目："></a>QQ项目：</h1><h4 id="C-imageList如何上传key对应的图片"><a href="#C-imageList如何上传key对应的图片" class="headerlink" title="C#imageList如何上传key对应的图片"></a>C#imageList如何上传key对应的图片</h4><p>string key &#x3D; “myImageKey”; &#x2F;&#x2F; 替换为您要上传的键 Image image &#x3D; imageList1.Images[key]; &#x2F;&#x2F; 获取与键关联的图像 </p><h4 id="C-实现接口的语法"><a href="#C-实现接口的语法" class="headerlink" title="C#实现接口的语法"></a>C#实现接口的语法</h4><p>在 C# 中，实现接口的语法如下：</p><p>&#x2F;&#x2F; 定义接口<br>public interface IMyInterface {<br>void MyMethod(); &#x2F;&#x2F; 接口方法<br>}</p><p>&#x2F;&#x2F; 实现接口<br>public class MyClass : <strong>IMyInterface</strong> {<br>public void MyMethod() {<br>&#x2F;&#x2F; 实现接口方法的代码<br>}<br>}<br>以上代码中，我们首先定义了一个名为 IMyInterface 的接口，其中包含一个无返回值、无参数的方法 MyMethod()。</p><p>接下来，我们定义了一个名为 MyClass 的类，并使用冒号 : 后面跟随接口名称的方式来实现 IMyInterface 接口。这意味着 MyClass 类必须实现 IMyInterface 接口中定义的所有方法。</p><p>在 MyClass 类中，我们重写了 MyMethod() 方法并提供了具体的实现代码。现在，MyClass 类就可以被视为 IMyInterface 接口的实现类，可以使用 IMyInterface 类型来引用 MyClass 的实例并调用 MyMethod() 方法。</p><p>需要注意的是，接口中定义的方法必须在实现类中被重写为公共访问级别（public）的方法。此外，如果实现类没有实现接口中的所有方法，那么它必须被标记为抽象类（abstract class）或虚拟类（virtual class）。</p><p>另外，<strong>C# 中的类可以实现多个接口，只需要在类名后面使用逗号分隔多个接口名称即可。例如：</strong></p><p>**public class MyClass : IMyInterface1, IMyInterface2 **{<br>&#x2F;&#x2F; 实现 IMyInterface1 和 IMyInterface2 接口中定义的方法<br>}</p><h4 id="item1-Tag，ListView中的item-Tag是什么？"><a href="#item1-Tag，ListView中的item-Tag是什么？" class="headerlink" title="item1.Tag，ListView中的item.Tag是什么？"></a>item1.Tag，ListView中的item.Tag是什么？</h4><p>ListView 控件中的 Item 对象具有一个名为 Tag 的属性，它允许您将任意对象与该 Item 相关联。可以使用 Tag 属性存储与 Item 相关的其他数据，例如数据库记录的 ID 或其他自定义对象。<br>在 ListView 控件中，每个 Item 表示一行数据。例如，如果您正在显示一个包含员工信息的表格，那么每一行可能代表一个员工。您可以使用 Item.Tag 属性将每个 Item 与相应的员工对象关联起来，以方便在处理表格数据时进行引用和处理。<br>以下是一个示例，演示如何在 ListView 中使用 Item.Tag 属性：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个包含员工信息的对象 </span><span class="hljs-type">Employee</span> <span class="hljs-variable">employee</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>() &#123;     ID = <span class="hljs-number">1</span>,     Name = <span class="hljs-string">&quot;John Doe&quot;</span>,     Department = <span class="hljs-string">&quot;Sales&quot;</span> &#125;; <span class="hljs-comment">// 创建一个新的 ListView Item，并将其与员工对象关联</span><span class="hljs-type">ListViewItem</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListViewItem</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">string</span>[] &#123;      employee.ID.ToString(),      employee.Name,      employee.Department  &#125;); item.Tag = employee; <span class="hljs-comment">// 将新的 Item 添加到 ListView 中 </span>listView1.Items.Add(item); <span class="hljs-comment">// 处理选中的 Item 中的 Tag 属性 </span><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listView1_SelectedIndexChanged</span><span class="hljs-params">(object sender, EventArgs e)</span> &#123;     <span class="hljs-keyword">if</span> (listView1.SelectedItems.Count &gt; <span class="hljs-number">0</span>)&#123;         <span class="hljs-type">Employee</span> <span class="hljs-variable">selectedEmployee</span> <span class="hljs-operator">=</span> (Employee)listView1.SelectedItems[<span class="hljs-number">0</span>].Tag;     <span class="hljs-comment">// 处理 selectedEmployee 对象     </span>&#125; &#125;</code></pre></div><p>在上面的示例中，我们创建了一个 Employee 对象，然后创建了一个新的 ListViewItem 对象，并将其与 Employee 对象相关联。我们将 Employee 对象存储在 Item.Tag 属性中，以便在需要时可以轻松地访问该对象。<br>在 listView1_SelectedIndexChanged 事件处理程序中，我们检查是否选择了一个 Item，并从选定的 Item 的 Tag 属性中检索与之相关联的 Employee 对象。然后，您可以使用 selectedEmployee 对象来进行进一步的处理。<br>总之，Item.Tag 属性为 ListView 控件中的 Item 对象提供了一种方便的方法，可以将任意对象与每个 Item 相关联。</p><h4 id="C-比较器"><a href="#C-比较器" class="headerlink" title="C#比较器"></a>C#比较器</h4><p>在 C# 中，可以使用比较器（comparer）来比较两个对象的相对大小或相等性。比较器通常用于对集合中的元素进行排序或搜索操作。<br>C# 中有两种类型的比较器：比较器类和委托比较器。<br>比较器类<br><strong>比较器类是实现了 IComparer 接口的类</strong>，<strong>它定义了一个 Compare 方法</strong>，用于比较两个对象的相对大小。Compare 方法返回一个整数值，表示第一个对象与第二个对象之间的关系。如果第一个对象小于第二个对象，则返回一个负数；如果第一个对象大于第二个对象，则返回一个正数；如果两个对象相等，则返回零。<br>以下是一个比较器类的示例，用于比较两个 Person 对象的年龄：<br>public class PersonAgeComparer : IComparer<Person> {     public int Compare(Person x, Person y) {         return x.Age - y.Age;     } }<br>在上面的示例中，我们定义了一个名为 PersonAgeComparer 的比较器类，它实现了 IComparer<Person> 接口，并重写了 Compare 方法。该方法比较两个 Person 对象的年龄，并返回一个整数值，表示它们之间的关系。<br>委托比较器<br>委托比较器是一个函数，它接受两个参数并返回一个整数值，表示这两个参数之间的关系。委托比较器通常使用匿名方法或 lambda 表达式来定义。<br>以下是一个使用委托比较器的示例，用于比较两个 Person 对象的姓名：<br>List<Person> people &#x3D; new List<Person>(); &#x2F;&#x2F; 添加 Person 对象到 people 列表中 people.Sort(delegate (Person x, Person y) {     return string.Compare(x.Name, y.Name); });<br>在上面的示例中，我们使用了 List<Person> 类的 Sort 方法来对 people 列表中的元素进行排序。我们传递了一个委托比较器作为参数，该比较器使用 string.Compare 方法比较两个 Person 对象的姓名，并返回一个整数值，表示它们之间的关系。<br>除了使用匿名方法，还可以使用 lambda 表达式来定义委托比较器。例如：<br>people.Sort((x, y) &#x3D;&gt; string.Compare(x.Name, y.Name));<br>在上面的示例中，我们使用了一个 lambda 表达式来定义委托比较器。该表达式接受两个参数 x 和 y，并比较它们的姓名。它返回一个整数值，表示它们之间的关系。<br>总之，比较器是 C# 中一种重要的概念，用于比较两个对象的相对大小或相等性。您可以使用比较器类或委托比较器来定义比较器，并将其用于对集合中的元素进行排序或搜索操作。</p><h4 id="C-如何把动图作为某个控件的背景图片"><a href="#C-如何把动图作为某个控件的背景图片" class="headerlink" title="C#如何把动图作为某个控件的背景图片"></a>C#如何把动图作为某个控件的背景图片</h4><p>你可以使用 PictureBox 控件来显示动态图像，并把它作为某个控件的背景图片。貌似其他控件设置动图为背景图片无法展示动图效果，picbox也是一样的，动图设置为背景图片也是不行的</p><h4 id="C-如何修改Form"><a href="#C-如何修改Form" class="headerlink" title="C#如何修改Form"></a>C#如何修改Form</h4><p>在 C# 中，可以使用 Form 类来创建和修改窗体（Form）。以下是修改窗体的一些常见操作：</p><ol><li>修改窗体标题：可以使用 Text 属性来设置窗体标题。例如：</li></ol><p>this.Text &#x3D; “My Form Title”; </p><ol><li>修改窗体大小和位置：可以使用 Size 和 Location 属性来设置窗体大小和位置。例如：</li></ol><p>this.Size &#x3D; new Size(800, 600); this.Location &#x3D; new Point(100, 100); </p><ol><li>修改窗体背景颜色：可以使用 BackColor 属性来设置窗体的背景颜色。例如：</li></ol><p>this.BackColor &#x3D; Color.LightBlue; </p><ol><li>添加控件到窗体中：可以使用 Controls 属性来添加控件到窗体中。例如，假设你要添加一个按钮控件到窗体中：</li></ol><p>Button myButton &#x3D; new Button(); myButton.Text &#x3D; “Click Me”; myButton.Location &#x3D; new Point(10, 10); this.Controls.Add(myButton); </p><ol><li>修改窗体样式和行为：可以使用 FormBorderStyle 和 WindowState 属性来设置窗体的样式和行为。例如，如果你想要设置窗体为无边框窗体并最大化显示：</li></ol><p>this.FormBorderStyle &#x3D; FormBorderStyle.None; this.WindowState &#x3D; FormWindowState.Maximized;<br>以上仅是一些常见的窗体修改操作，你可以根据需要使用 Form 类的其他属性和方法来进行更多的窗体修改操作。</p><h4 id="C-背景图片颜色的transparent"><a href="#C-背景图片颜色的transparent" class="headerlink" title="C#背景图片颜色的transparent"></a>C#背景图片颜色的transparent</h4><p>当设置控件的 BackColor 属性为 Color.Transparent 时，<strong>控件的透明背景颜色将会显示父容器的背景图片或颜色</strong>，或者<strong>如果父容器也是透明背景色，则会显示其祖先容器的背景色，一直到有非透明背景色的容器为止。</strong></p><h4 id="C-窗体如何隐藏边框"><a href="#C-窗体如何隐藏边框" class="headerlink" title="C#窗体如何隐藏边框"></a>C#窗体如何隐藏边框</h4><p>在 C# 中，可以通过设置窗体的 FormBorderStyle 属性来隐藏窗体的边框。具体来说，可以将 FormBorderStyle 属性设置为 None 来隐藏窗体的边框。<br>注意：当窗体的边框被隐藏时，窗体将无法通过拖动边框来改变大小和位置。因此，你需要通过其他方式来控制窗体的大小和位置，例如在代码中设置窗体的 Size 和 Location 属性。</p><h4 id="c-点击图片关闭窗口实现"><a href="#c-点击图片关闭窗口实现" class="headerlink" title="c#点击图片关闭窗口实现"></a>c#点击图片关闭窗口实现</h4><p>private void pictureBox1_Click(object sender, EventArgs e) {     this.Close(); }</p><h4 id="C-点击图片最小化"><a href="#C-点击图片最小化" class="headerlink" title="C#点击图片最小化"></a>C#点击图片最小化</h4><p>private void pictureBox1_Click(object sender, EventArgs e) {     this.WindowState &#x3D; FormWindowState.Minimized; }<br>我们将窗体的 WindowState 属性设置为 FormWindowState.Minimized，以实现最小化窗口的操作。</p><h4 id="panel如何表现为一条线"><a href="#panel如何表现为一条线" class="headerlink" title="panel如何表现为一条线"></a>panel如何表现为一条线</h4><p>如果您想让 Panel 控件在界面上表现为一条线，可以按照以下步骤进行设置：</p><ol><li>在窗体上添加一个 Panel 控件，并设置其 Dock 属性为 Top 或 Bottom。这将使 Panel 控件沿着窗体的顶部或底部固定，占据整个窗体的宽度。</li><li>设置 Panel 控件的高度为您想要的线条粗细。例如，如果您想要一条高度为 2 像素的线条，可以将 Panel 控件的高度设置为 2 像素。</li><li>将 Panel 控件的背景色设置为您想要的线条颜色。例如，如果您想要一条黑色的线条，可以将 Panel 控件的背景色设置为黑色。</li><li>确保将 Panel 控件的边框样式（BorderStyle）设置为 None，以避免显示不必要的边框。</li></ol><p>如果您想要更细的线条，可以将 Panel 控件的高度设置为 1 像素，并在其上方或下方添加一个与窗体背景色相同的 Panel 控件，以使线条看起来更细。</p><h4 id="文本框如何让输入的密码显示为圆点"><a href="#文本框如何让输入的密码显示为圆点" class="headerlink" title="文本框如何让输入的密码显示为圆点"></a>文本框如何让输入的密码显示为圆点</h4><p>您可以通过将文本框控件的 UseSystemPasswordChar 属性设置为 true，来让输入的密码显示为圆点。<br>以下是一个示例代码：<br>textBox1.UseSystemPasswordChar &#x3D; true;<br>在这个示例代码中，我们将 textBox1 控件的 UseSystemPasswordChar 属性设置为 true，这样输入的密码就会显示为圆点。</p><h4 id="C-为什么启动后的文本框里面的默认值是蓝色"><a href="#C-为什么启动后的文本框里面的默认值是蓝色" class="headerlink" title="C#为什么启动后的文本框里面的默认值是蓝色"></a>C#为什么启动后的文本框里面的默认值是蓝色</h4><p>您可以通过将文本框控件的 Select 方法应用于其他控件来解决文本框控件默认值显示为蓝色的问题。这将取消文本框控件的选中状态，从而避免默认背景颜色的出现。<br>以下是一个示例代码：<br>private void Form1_Load(object sender, EventArgs e) {     &#x2F;&#x2F; 在窗体加载时将焦点设置到另一个控件上     button1.Focus();     &#x2F;&#x2F; 使用 Select 方法取消文本框的选中状态     textBox1.Select(0, 0); }</p><h4 id="MouseEnter事件"><a href="#MouseEnter事件" class="headerlink" title="MouseEnter事件"></a>MouseEnter事件</h4><p>MouseEnter 事件是 C# 中的一个事件，用于在鼠标进入控件时触发。当鼠标指针进入控件的可见区域时，MouseEnter 事件会被触发一次。</p><h4 id="MouseLeave"><a href="#MouseLeave" class="headerlink" title="MouseLeave"></a>MouseLeave</h4><p>MouseLeave 事件是 C# 中的一个事件，用于在鼠标离开控件时触发。当鼠标指针离开控件的可见区域时，MouseLeave 事件会被触发一次。</p><h4 id="MouseHover"><a href="#MouseHover" class="headerlink" title="MouseHover"></a>MouseHover</h4><p>MouseHover 事件是 C# 中的一个事件，用于在鼠标在控件上悬停时触发。当鼠标指针在控件的可见区域内停留一段时间时，MouseHover 事件会被触发一次。</p><h4 id="MousrMove"><a href="#MousrMove" class="headerlink" title="MousrMove"></a>MousrMove</h4><p>MouseMove 事件是 C# 中的一个事件，用于在鼠标在控件内移动时触发。当鼠标指针在控件的可见区域内移动时，MouseMove 事件会被触发多次。</p><h4 id="如何把文本框的信息储存在JSON文件当中？"><a href="#如何把文本框的信息储存在JSON文件当中？" class="headerlink" title="如何把文本框的信息储存在JSON文件当中？"></a>如何把文本框的信息储存在JSON文件当中？</h4><p>要将文本框的信息储存在 JSON 文件中，可以使用 .NET 中的 Newtonsoft.Json 库来实现。该库提供了一组 API，用于将对象序列化为 JSON 格式的字符串，并将 JSON 格式的字符串反序列化为对象。<br>以下是一个示例代码，演示如何将文本框的信息储存在 JSON 文件中：</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> Newtonsoft.Json; <span class="hljs-keyword">using</span> System.IO; <span class="hljs-comment">// 定义一个类，用于储存文本框的信息 </span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TextBoxInfo</span>&#123;     <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Text &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125; &#125; <span class="hljs-comment">// 在保存按钮的 Click 事件中执行以下代码</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnSave_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span>&#123;    <span class="hljs-comment">// 创建一个 TextBoxInfo 对象，储存文本框的信息 </span>TextBoxInfo textBoxInfo = <span class="hljs-keyword">new</span> TextBoxInfo &#123; Text = textBox1.Text &#125;;    <span class="hljs-comment">// 将 TextBoxInfo 对象序列化为 JSON 格式的字符串     </span><span class="hljs-built_in">string</span> jsonString = JsonConvert.SerializeObject(textBoxInfo);    <span class="hljs-comment">// 将 JSON 格式的字符串写入文件中     </span><span class="hljs-built_in">string</span> filePath = <span class="hljs-string">&quot;textBoxInfo.json&quot;</span>;    File.WriteAllText(filePath, jsonString); &#125;</code></pre></div><p>在上述代码中，定义了一个 TextBoxInfo 类，用于储存文本框的信息。在保存按钮的 Click 事件中，创建了一个 TextBoxInfo 对象，储存了文本框的信息。然后，使用 JsonConvert.SerializeObject 方法将 TextBoxInfo 对象序列化为 JSON 格式的字符串，并使用 File.WriteAllText 方法将 JSON 格式的字符串写入文件中。<br>要从 JSON 文件中读取文本框的信息，可以执行以下代码：</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">// 在窗口加载时执行以下代码 </span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Form1_Load</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span> &#123;    <span class="hljs-comment">// 从文件中读取 JSON 格式的字符串 </span><span class="hljs-built_in">string</span> filePath = <span class="hljs-string">&quot;textBoxInfo.json&quot;</span>;  <span class="hljs-built_in">string</span> jsonString = File.ReadAllText(filePath);   <span class="hljs-comment">// 将 JSON 格式的字符串反序列化为 TextBoxInfo 对象   </span>TextBoxInfo textBoxInfo = JsonConvert.DeserializeObject&lt;TextBoxInfo&gt;(jsonString);  <span class="hljs-comment">// 将 TextBoxInfo 对象中的信息显示在文本框中     </span>textBox1.Text = textBoxInfo.Text; &#125;</code></pre></div><p>在上述代码中，使用 File.ReadAllText 方法从文件中读取 JSON 格式的字符串。然后，使用 JsonConvert.DeserializeObject 方法将 JSON 格式的字符串反序列化为 TextBoxInfo 对象，并将 TextBoxInfo 对象中的信息显示在文本框中。</p><h4 id="timer控件"><a href="#timer控件" class="headerlink" title="timer控件"></a>timer控件</h4><p>Timer 控件是 C# 中的一个计时器控件，<strong>用于在指定的时间间隔内周期性地触发事件。</strong>Timer 控件可以用于实现各种计时功能，例如定期更新界面、执行后台任务等。设置Enable启动timer控件，然后间断着执行timer控件中的代码</p><h4 id="C-当中的sln文件是什么？"><a href="#C-当中的sln文件是什么？" class="headerlink" title="C#当中的sln文件是什么？"></a>C#当中的sln文件是什么？</h4><p>在 C# 中，.<strong>sln 文件是一个解决方案文件，用于组织和管理一个或多个项目。.sln 文件是 Visual Studio 的一部分，它包含了该解决方案中的所有项目、引用以及其他相关文件。</strong><br>每个 C# 项目都包含一个 .csproj 文件，它定义了项目的结构和内容。但是，当您需要同时管理多个项目时，.sln 文件就变得非常有用。.sln 文件实际上是一个 XML 文件，其中包含有关解决方案的信息，例如项目列表、构建配置等。<br>在 Visual Studio 中，您可以使用“新建项目”向导来创建新的项目。创建项目时，Visual Studio 会自动生成一个 .sln 文件。您可以在“解决方案资源管理器”中查看 .sln 文件，它位于解决方案的顶级目录中。<br>使用 .sln 文件的好处是可以方便地管理多个项目。如果您需要添加、删除或重命名项目，只需编辑 .sln 文件即可。.sln 文件还可以包含预定义的构建配置，例如“Debug”和“Release”，这样您就可以轻松地在不同的环境中构建应用程序。<br>总之，.sln 文件是 Visual Studio 中用于管理多个项目的解决方案文件。它包含有关解决方案的信息，例如项目列表、构建配置等。使用 .sln 文件可以方便地组织和管理项目，从而提高开发效率。</p><h4 id="C-如何实现点击一个label跳转到一个网页"><a href="#C-如何实现点击一个label跳转到一个网页" class="headerlink" title="C#如何实现点击一个label跳转到一个网页"></a>C#如何实现点击一个label跳转到一个网页</h4><p>您可以使用C#中的Label控件的Click事件来实现这个功能。在Click事件处理程序中，您可以使用System.Diagnostics命名空间中的Process对象来打开网页。<br>以下是一个简单的示例代码：<br>private void label1_Click(object sender, EventArgs e) {     System.Diagnostics.Process.Start(“<a href="https://www.example.com/">https://www.example.com/</a>“); }</p><h1 id="酷我音乐盒："><a href="#酷我音乐盒：" class="headerlink" title="酷我音乐盒："></a>酷我音乐盒：</h1><p>1.C#下如果想打开一个项目并窗口化编辑选择项目中的.sln文件</p><h4 id="C-如何设置窗口可以自动调整大小"><a href="#C-如何设置窗口可以自动调整大小" class="headerlink" title="C#如何设置窗口可以自动调整大小"></a>C#如何设置窗口可以自动调整大小</h4><p>在 C# 中，您可以通过设置窗体的 AutoSize、AutoSizeMode 和 MinimumSize 属性来实现窗口自动调整大小的功能。</p><ol><li>AutoSize 属性：此属性指示窗体是否根据其内容自动调整大小。将其设置为 true 可以启用自动调整大小功能。默认情况下，AutoSize 属性为 false。</li><li>AutoSizeMode 属性：此属性指定窗体自动调整大小的方式。可以将其设置为以下值之一：<ul><li>GrowOnly：窗体仅在其内容增加时才会增加大小。</li><li>None：窗体不会自动调整大小。</li><li>GrowAndShrink：窗体可以根据其内容增加或减小大小。</li></ul></li><li>MinimumSize 属性：此属性指定窗体的最小大小。如果窗体的大小小于此值，则窗体将自动调整大小以适应其内容。</li></ol><h4 id="C-Substring"><a href="#C-Substring" class="headerlink" title="C#Substring"></a>C#Substring</h4><p>Substring 方法用于从字符串中提取部分子字符串。该方法有多个重载形式，可以根据需要提取子字符串。<br>以下是 Substring 方法的几种常见用法：</p><ol><li>Substring(int startIndex)：从指定的开始位置 startIndex 提取子字符串。子字符串包括 startIndex 和之后的所有字符。</li></ol><p>string str &#x3D; “Hello world”; string subStr &#x3D; str.Substring(6); &#x2F;&#x2F; subStr &#x3D; “world” </p><ol><li>Substring(int startIndex, int length)：从指定的开始位置 startIndex 提取长度为 length 的子字符串。</li></ol><p>string str &#x3D; “Hello world”; string subStr &#x3D; str.Substring(0, 5); &#x2F;&#x2F; subStr &#x3D; “Hello” </p><ol><li>Substring(int startIndex, int endIndex - startIndex)：从指定的开始位置 startIndex 提取到指定的结束位置 endIndex（不包括 endIndex）的子字符串。</li></ol><p>string str &#x3D; “Hello world”; string subStr &#x3D; str.Substring(6, 5); &#x2F;&#x2F; subStr &#x3D; “world”<br>需要注意的是，如果 startIndex 或 endIndex 超出了字符串的范围，则会引发 ArgumentOutOfRangeException 异常。<br>另外，Substring 方法返回的是一个新的字符串对象，原始字符串不会受到影响。如果需要修改原始字符串，可以使用 StringBuilder 类。<br>string str &#x3D; “Hello world”; string subStr &#x3D; str.Substring(6); &#x2F;&#x2F; subStr &#x3D; “world” StringBuilder sb &#x3D; new StringBuilder(str); sb.Remove(0, 6); &#x2F;&#x2F; 移除 “Hello “ string modifiedStr &#x3D; sb.ToString(); &#x2F;&#x2F; modifiedStr &#x3D; “world”</p><h4 id="axWindowsMediaPlayer-Ctlcontrols-currentPositionString"><a href="#axWindowsMediaPlayer-Ctlcontrols-currentPositionString" class="headerlink" title="axWindowsMediaPlayer.Ctlcontrols.currentPositionString"></a>axWindowsMediaPlayer.Ctlcontrols.currentPositionString</h4><p>axWindowsMediaPlayer.Ctlcontrols.currentPositionString 是在使用 AxWindowsMediaPlayer 控件时，用于获取当前媒体播放位置的字符串表示形式的属性。<br>AxWindowsMediaPlayer 控件可以用于在 Windows 窗体应用程序中播放音频和视频文件。该控件有一个名为 Ctlcontrols 的属性，该属性返回一个 WMPLib.IWMPControls 接口的实例，可用于控制媒体的播放、暂停、停止等操作。<br>currentPositionString 属性是 WMPLib.IWMPControls 接口的一个成员，用于获取当前媒体播放位置的字符串表示形式。该属性返回一个格式为 mm:ss 的字符串，其中 mm 表示分钟数，ss 表示秒数。</p><h4 id="axWindowsMediaPlayer-currentMedia-durationString"><a href="#axWindowsMediaPlayer-currentMedia-durationString" class="headerlink" title="axWindowsMediaPlayer.currentMedia.durationString"></a>axWindowsMediaPlayer.currentMedia.durationString</h4><p>axWindowsMediaPlayer.currentMedia.durationString 是在使用 AxWindowsMediaPlayer 控件时，用于获取当前媒体总时长的字符串表示形式的属性。<br>AxWindowsMediaPlayer 控件可以用于在 Windows 窗体应用程序中播放音频和视频文件。该控件有一个名为 currentMedia 的属性，该属性返回一个 WMPLib.IWMPMedia 接口的实例，可用于获取当前媒体的信息，如标题、作者、时长等。<br>durationString 属性是 WMPLib.IWMPMedia 接口的一个成员，用于获取当前媒体总时长的字符串表示形式。该属性返回一个格式为 hh:mm:ss 的字符串，其中 hh 表示小时数，mm 表示分钟数，ss 表示秒</p><h4 id="axWindowsMediaPlayer-URL-”song”-songName-currentSong-“-mp3”-这句-是什么"><a href="#axWindowsMediaPlayer-URL-”song”-songName-currentSong-“-mp3”-这句-是什么" class="headerlink" title="axWindowsMediaPlayer.URL &#x3D; @”song” + songName[currentSong] + “.mp3”;这句@是什么"></a>axWindowsMediaPlayer.URL &#x3D; @”song” + songName[currentSong] + “.mp3”;这句@是什么</h4><h4 id="在这句代码中，-符号是C-语言中的字符串字面量前缀符号，它告诉编译器将紧随其后的字符串视为字面量，而不需要进行转义。在这个例子中，字符串字面量是-”song”-songName-currentSong-“-mp3”，它表示一个包含歌曲名称的字符串，用于指定Windows-Media-Player控件播放的音频文件。"><a href="#在这句代码中，-符号是C-语言中的字符串字面量前缀符号，它告诉编译器将紧随其后的字符串视为字面量，而不需要进行转义。在这个例子中，字符串字面量是-”song”-songName-currentSong-“-mp3”，它表示一个包含歌曲名称的字符串，用于指定Windows-Media-Player控件播放的音频文件。" class="headerlink" title="在这句代码中，@符号是C#语言中的字符串字面量前缀符号，它告诉编译器将紧随其后的字符串视为字面量，而不需要进行转义。在这个例子中，字符串字面量是@”song” + songName[currentSong] + “.mp3”，它表示一个包含歌曲名称的字符串，用于指定Windows Media Player控件播放的音频文件。"></a>在这句代码中，@符号是C#语言中的字符串字面量前缀符号，它告诉编译器将紧随其后的字符串视为字面量，而不需要进行转义。在这个例子中，字符串字面量是@”song” + songName[currentSong] + “.mp3”，它表示一个包含歌曲名称的字符串，用于指定Windows Media Player控件播放的音频文件。</h4><h1 id="ppt模仿"><a href="#ppt模仿" class="headerlink" title="ppt模仿"></a>ppt模仿</h1><h4 id="Graphics-g-pictureBoxCanvas-CreateGraphics-解读这个"><a href="#Graphics-g-pictureBoxCanvas-CreateGraphics-解读这个" class="headerlink" title="Graphics g &#x3D; pictureBoxCanvas.CreateGraphics();解读这个"></a>Graphics g &#x3D; pictureBoxCanvas.CreateGraphics();解读这个</h4><p>这段代码的含义是创建了一个Graphics对象g，并将其绑定到PictureBox控件pictureBoxCanvas上的绘图表面上。<br>具体来说，CreateGraphics()是PictureBox控件的一个方法，用于创建一个Graphics对象，该对象可以用于在PictureBox控件上绘制图形。在这个例子中，通过调用CreateGraphics()方法，创建了一个与pictureBoxCanvas控件关联的Graphics对象g。<br>在绘制图形时，需要使用该Graphics对象g来进行绘制操作。例如，可以使用g.DrawRectangle()方法绘制一个矩形，或使用g.DrawEllipse()方法绘制一个椭圆，等等。<br>需要注意的是，使用CreateGraphics()方法创建的Graphics对象只在当前窗体重绘时有效，即在窗体重绘后，所有绘制的图形都会被清空。如果需要将绘制的图形保留，可以在创建Graphics对象时，将其与一个Bitmap对象关联。这样，在绘制图形时，先将图形绘制到Bitmap对象上，然后再将Bitmap对象绘制到PictureBox控件上，就可以保留绘制的图形了。<br>g.DrawBezier(pen, curvePoints[0], curvePoints[1], curvePoints[2], curvePoints[3]);解读这个命令<br>这段代码的含义是使用指定的画笔pen，在PictureBox控件上绘制一条Bezier曲线，曲线的控制点分别为curvePoints[0]、curvePoints[1]、curvePoints[2]、curvePoints[3]。<br>具体来说，DrawBezier()是Graphics对象g的一个方法，用于绘制Bezier曲线。该方法需要传入以下参数：</p><ul><li>pen：一个Pen对象，用于指定绘制的画笔。</li><li>curvePoints[0]：Bezier曲线的起始点。</li><li>curvePoints[1]：Bezier曲线的第一个控制点。</li><li>curvePoints[2]：Bezier曲线的第二个控制点。</li><li>curvePoints[3]：Bezier曲线的终止点。</li></ul><p>这些参数都是必须的，否则会出现编译错误。<br>需要注意的是，Bezier曲线是一种二次或三次曲线，其形状由控制点决定。在绘制Bezier曲线时，需要指定控制点的位置，以确定曲线的形状。在这个例子中，curvePoints数组保存了四个控制点的位置，用于绘制一条Bezier曲线。<br>另外，需要确保Graphics对象g与PictureBox控件pictureBoxCanvas关联，否则无法在控件上绘制图形。可以使用pictureBoxCanvas.CreateGraphics()方法创建一个Graphics对象，并将其与PictureBox控件关联。<br>Bezier曲线是什么<br>Bezier曲线是一种数学上的曲线，由法国工程师Pierre Bézier在20世纪50年代发明。它是一种插值曲线，用于平滑地连接多个控制点。<br>Bezier曲线通常被用于计算机图形学中的图形设计和绘制，因为它们可以通过少量的控制点创建平滑的曲线。它们也被广泛用于计算机辅助设计（CAD）、计算机动画和计算机游戏中。<br>在二维空间中，Bezier曲线通常由四个点组成，分别称为起始点、终止点和两个控制点。这些点的位置决定了曲线的形状和方向。Bezier曲线可以是二次曲线或三次曲线，具体取决于控制点的数量。<br>Bezier曲线的优点是可以通过少量的控制点来创建平滑的曲线，同时它们也比其他类型的曲线更容易在计算机上计算和绘制。此外，Bezier曲线还可以通过插值来进行曲线的平滑处理，使得曲线更加自然和平滑。<br>g.Dispose();解读这个命令<br>这段代码的含义是释放Graphics对象g占用的资源，并将其销毁。<br>具体来说，Dispose()是Graphics对象g的一个方法，用于释放该对象占用的资源，包括绑定的所有GDI+对象（如画笔、画刷等）。该方法在使用完Graphics对象后，应该及时调用，以避免资源泄漏和性能问题。<br>在这个例子中，使用Dispose()方法释放了Graphics对象g所占用的所有资源。需要注意的是，释放Graphics对象后，就不能再使用它来绘制图像，否则会抛出异常。<br>在.NET Framework中，许多类型都实现了IDisposable接口，包括Graphics对象、文件流、网络连接等等。这些类型在使用完毕后，应该及时调用Dispose()方法来释放占用的资源，以避免程序运行过程中出现资源泄漏和性能问题。另外，可以使用using语句来自动释放实现IDisposable接口的对象，以简化代码和提高可读性。</p><h4 id="pictureBoxCanvas-Image-Save-saveFileDialog-FileName-解读这个"><a href="#pictureBoxCanvas-Image-Save-saveFileDialog-FileName-解读这个" class="headerlink" title="pictureBoxCanvas.Image.Save(saveFileDialog.FileName);解读这个"></a>pictureBoxCanvas.Image.Save(saveFileDialog.FileName);解读这个</h4><p>这段代码的含义是将PictureBox控件pictureBoxCanvas上显示的图像保存到指定的文件中。<br>具体来说，pictureBoxCanvas是一个PictureBox控件，它可以用来显示图像。在这个例子中，pictureBoxCanvas上显示了一个图像，并且用户选择了一个保存文件对话框saveFileDialog，用于指定保存的文件名和文件路径。<br>Image是PictureBox控件的一个属性，用于获取或设置PictureBox控件上显示的图像。在这个例子中，使用pictureBoxCanvas.Image获取PictureBox控件上显示的图像。<br>Image对象具有Save()方法，该方法可以将图像保存到指定的文件中。在这个例子中，使用pictureBoxCanvas.Image.Save()方法将PictureBox控件上显示的图像保存到用户指定的文件中，文件名和路径由saveFileDialog.FileName属性指定。<br>需要注意的是，如果PictureBox控件上没有显示任何图像，或者PictureBox控件的Image属性为null，则会抛出NullReferenceException异常。另外，如果指定的文件已经存在，Save()方法会覆盖原来的文件，因此需要谨慎使用。</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">comboBoxColor_SelectedIndexChanged</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span>&#123;<span class="hljs-keyword">switch</span> (comboBoxColor.SelectedIndex)&#123;<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:currentColor = Color.Black;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:currentColor = Color.Red;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:currentColor = Color.Blue;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:currentColor = Color.Green;<span class="hljs-keyword">break</span>;<span class="hljs-literal">default</span>:<span class="hljs-keyword">break</span>;&#125;&#125;&#125;</code></pre></div><p>这段代码是一个事件处理方法，用于响应ComboBox控件comboBoxColor的SelectedIndexChanged事件。当用户选择ComboBox中的某一项时，就会触发该事件，从而执行该方法。<br>具体来说，该方法的作用是根据用户选择的颜色，更新currentColor变量的值。currentColor是一个Color类型的变量，用于指定当前画笔的颜色。在该方法中，根据用户选择的颜色，将currentColor变量更新为相应的颜色值。<br>使用switch语句，根据comboBoxColor控件中选中的项的索引值，判断用户选择的颜色。如果用户选择了黑色，则将currentColor设置为Color.Black；如果用户选择了红色，则将currentColor设置为Color.Red；如果用户选择了蓝色，则将currentColor设置为Color.Blue；如果用户选择了绿色，则将currentColor设置为Color.Green。如果用户选择的是其他颜色，则不做任何操作。<br>需要注意的是，comboBoxColor控件中各项的索引值从0开始计数。因此，第一项的索引值为0，第二项的索引值为1，依此类推。<br>在完成currentColor的更新后，该方法的执行就结束了。currentColor的值会在后续的绘图操作中被使用，以指定当前画笔的颜色。ComboBox控件中各项的索引值是从0开始计数的整数，表示该项在ComboBox中的位置。例如，ComboBox中第一项的索引值为0，第二项的索引值为1，依此类推。<br>在ComboBox的数据源中，每个项都有一个关联的索引值。当用户选择ComboBox中的某一项时，就会触发SelectedIndexChanged事件，并将所选项的索引值传递给相关的事件处理方法。<br>在事件处理方法中，可以使用Switch语句或其他条件语句根据索引值来判断用户选择了哪个项，并执行相应的操作。<br>需要注意的是，在设置ComboBox中的数据源时，可以为每个项指定一个显示文本和一个值（Value）。在这种情况下，所选项的值可以通过ComboBox控件的SelectedValue属性来获取，而不是使用索引值。<br><a href="https://blog.csdn.net/qq_29406323/article/details/86488248">C# ComboBox 下拉选项框_c#中下拉框添加选项_渐进的冰山的博客-CSDN博客</a></p><h4 id="ComboBox如何添加数据源"><a href="#ComboBox如何添加数据源" class="headerlink" title="ComboBox如何添加数据源"></a>ComboBox如何添加数据源</h4><p>可以通过以下步骤向ComboBox控件添加数据源：</p><ol><li>在设计模式下，在Visual Studio的工具箱中选择ComboBox控件，将其拖放到窗体中。</li><li>选中ComboBox控件，打开其属性窗口。</li><li>在属性窗口中，找到DataSource属性，将其设置为要作为数据源的对象。可以选择一个数据表、数组、集合等。</li><li>在属性窗口中，找到DisplayMember属性，将其设置为要在ComboBox中显示的值的属性名。例如，如果数据源是一个包含”姓名”和”年龄”两列的表格，而你想在ComboBox中显示”姓名”列的值，那么应该将DisplayMember属性设置为”姓名”。</li><li>可选的步骤：如果要在ComboBox中显示的值不是数据源中的某个属性，而是根据数据源动态生成的值，可以使用ComboBox控件的DataBindings属性来绑定一个方法或表达式，以生成所需的值。</li><li>运行程序，ComboBox控件就会显示来自数据源的值了。</li></ol><p>需要注意的是，如果数据源是一个集合或数组，ComboBox控件会自动将其元素添加为ComboBox的项。但是，如果数据源是一个数据表，则需要手动向ComboBox中添加项。可以使用ComboBox控件的Items属性，通过代码向ComboBox中添加项。例如：<br>comboBox1.Items.Clear(); &#x2F;&#x2F;先清空原来的项 foreach (DataRow row in dataTable.Rows) {     comboBox1.Items.Add(row[“Name”].ToString()); &#x2F;&#x2F;向ComboBox中添加项 }<br>在上面的示例中，dataTable是一个数据表，包含”Name”和”Age”两列。使用foreach语句遍历表中的每一行，将”Name”列的值添加到ComboBox控件中。</p><h4 id="C-如何将一个数组添加为ComBox控件的下拉选项"><a href="#C-如何将一个数组添加为ComBox控件的下拉选项" class="headerlink" title="C#如何将一个数组添加为ComBox控件的下拉选项"></a>C#如何将一个数组添加为ComBox控件的下拉选项</h4><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Form1</span> : <span class="hljs-title">Form</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Form1</span>()</span>    &#123;        InitializeComponent();        <span class="hljs-comment">//数据源为一个string数组</span>        <span class="hljs-built_in">string</span> [] colors =            <span class="hljs-keyword">new</span>[]&#123; <span class="hljs-string">&quot;Black&quot;</span>, <span class="hljs-string">&quot;Red&quot;</span>, <span class="hljs-string">&quot;Blue&quot;</span>,                    <span class="hljs-string">&quot;Green&quot;</span> &#125;;          <span class="hljs-comment">// 初始化cmb,注意这里的comboBoxColor是已经存在于Form中的</span>                 comboBoxColor.DataSource = colors;<span class="hljs-comment">//下面这部不能少</span>         comboBoxColor.DropDownStyle = ComboBoxStyle.DropDownList; <span class="hljs-comment">//</span>         <span class="hljs-comment">// 添加cmb到Form中</span>         <span class="hljs-keyword">this</span>.Controls.Add(comboBoxColor);    &#125;&#125;</code></pre></div><h4 id="pictureBox1-Invalidate解读这个方法"><a href="#pictureBox1-Invalidate解读这个方法" class="headerlink" title="pictureBox1.Invalidate解读这个方法"></a>pictureBox1.Invalidate解读这个方法</h4><p>Invalidate() 方法是 Control 类的一个成员，它用于使控件的整个区域无效，从而要求窗体系统重新绘制该控件。在 PictureBox 控件中，Invalidate() 方法可以用于更新控件的绘图表面，以便显示新的绘制内容。<br>当 Invalidate() 方法被调用时，它会引发 Paint 事件，从而通知窗体系统重新绘制控件。在 PictureBox 控件中，Paint 事件通常用于在控件上绘制图形或图像。如果控件的 Paint 事件处理程序中修改了控件的绘图表面，那么需要调用 Invalidate() 方法来通知窗体系统重新绘制控件，以便更新显示内容。<br>在上面的示例中，当鼠标移动或松开时，控件的绘图表面需要更新，以便显示矩形轮廓。因此，在 MouseMove 和 MouseUp 事件处理程序中，我们调用了 Invalidate() 方法来刷新控件的绘图表面。然后，在 Paint 事件处理程序中，我们根据当前的绘制状态绘制矩形轮廓。这样，每当控件的绘图表面需要更新时，都会引发 Paint 事件，从而调用 Paint 事件处理程序来重新绘制控件。</p><h4 id="C-如何清除picbox上面的绘画"><a href="#C-如何清除picbox上面的绘画" class="headerlink" title="C#如何清除picbox上面的绘画"></a>C#如何清除picbox上面的绘画</h4><p>您可以使用 PictureBox 的 Invalidate 方法来清除其上的绘图。Invalidate 方法将触发 PictureBox 的 Paint 事件，从而使 PictureBox 重新绘制其内容。<br>以下是一个简单的示例代码，演示如何使用 Invalidate 方法清除 PictureBox 上的绘图：<br>&#x2F;&#x2F; 清除 PictureBox 上的绘画 pictureBox1.Invalidate();<br>如果您想要清除 PictureBox 上的所有绘图，您可以在 Paint 事件中使用 Graphics 对象的 Clear 方法来实现。以下是一个示例代码：<br>private void pictureBox1_Paint(object sender, PaintEventArgs e) {     &#x2F;&#x2F; 清除 PictureBox 上的绘画     e.Graphics.Clear(Color.White); }<br>在这个示例中，我们将 PictureBox 的 Paint 事件与一个名为 pictureBox1_Paint 的方法关联。在该方法中，我们使用 Graphics 对象的 Clear 方法来清除 PictureBox 上的所有绘图。当 PictureBox 的 Invalidate 方法被调用时，Paint 事件将被触发，从而导致 pictureBox1_Paint 方法被调用，清除 PictureBox 上的所有绘图。</p><h1 id="图片处理："><a href="#图片处理：" class="headerlink" title="图片处理："></a>图片处理：</h1><h4 id="灰白化原理："><a href="#灰白化原理：" class="headerlink" title="灰白化原理："></a>灰白化原理：</h4><p>图片灰白化处理是一种常见的图像处理方法，它将彩色图像转换为灰度图像，使图像失去颜色信息，只保留亮度信息。其原理是利用 RGB 颜色模型中的亮度公式，将每个像素点的 RGB 值转化为相同的灰度值，从而使图像呈现出黑白灰度的效果。<br>RGB 颜色模型中的亮度公式如下：<br>L &#x3D; 0.299R + 0.587G + 0.114B<br>其中，L 表示亮度值，R、G、B 分别表示红、绿、蓝三个颜色通道的值。在灰白化处理中，将每个像素点的 R、G、B 值分别代入上述公式，得到一个灰度值，然后将这个灰度值赋给该像素点的 R、G、B 三个通道，即可实现灰白化处理。<br>例如，对于一个 RGB 值为 (100, 150, 200) 的像素点，根据亮度公式计算得到的灰度值为：<br>L &#x3D; 0.299 × 100 + 0.587 × 150 + 0.114 × 200 ≈ 147<br>然后将这个灰度值赋给该像素点的 R、G、B 三个通道，即可得到灰度值为 147 的灰白化像素点。<br>灰白化处理可以去除图像中的颜色信息，突出图像的亮度信息，适用于一些只需分析亮度信息的图像处理任务，如图像边缘检测、图像识别等。灰白化处理也是一些图像处理算法的前置处理步骤，如二值化、图像增强等。</p><h4 id="C-浮雕化原理"><a href="#C-浮雕化原理" class="headerlink" title="C#浮雕化原理"></a>C#浮雕化原理</h4><p>浮雕化是一种图像处理技术，基本原理是将图片中像素的点与相邻点的RGB值进行相减，然后加上128，得到中间值灰色。因为相邻点基本上都是RGB比较相似的，所以相似的点的处理结果基本上临近128，而不相近颜色的值则偏离128较远，所以可以得到一个类似于浮雕的图像。</p><h4 id="马赛克化原理："><a href="#马赛克化原理：" class="headerlink" title="马赛克化原理："></a>马赛克化原理：</h4><p>图片处理马赛克化原理<br>马赛克化是一种图像处理技术，基本原理是将图片中的像素点分块，然后用同一颜色代替这个块中的所有像素点，从而达到模糊化的效果。马赛克化的实现原理是把图像上某个像素点一定范围邻域内的所有点用邻域内左上像素点的颜色代替，这样可以模糊细节，但是可以保留大体的轮廓</p><h1 id="girl"><a href="#girl" class="headerlink" title="girl"></a>girl</h1><h4 id="为什么程序刚运行的时候effect的默认值是None"><a href="#为什么程序刚运行的时候effect的默认值是None" class="headerlink" title="为什么程序刚运行的时候effect的默认值是None"></a>为什么程序刚运行的时候effect的默认值是None</h4><p>在 C# 中，枚举类型的默认值是第一个成员的值，因此在该程序中，Effect 枚举类型的默认值是 None。</p><h4 id="负数取余"><a href="#负数取余" class="headerlink" title="负数取余"></a>负数取余</h4><p>对于两个整数 a 和 b，可以使用 % 运算符对它们进行取模运算，即 a % b。当 a 和 b 都是正整数时，取模运算的结果是 a 除以 b 的余数。<br>如果 a 或 b 中存在负数，那么取模运算的结果会和不同的编程语言和算法实现有关。在 C# 中，取模运算的结果与 a 的符号相同，即：</p><ul><li>当 a 和 b 都是正整数时，结果为 a 对 b 取余的结果。</li><li>当 a 是负整数时，结果为 a 对 b 取余的结果减去 b 的绝对值。</li><li>当 b 是负整数时，结果为 a 对 b 取余的结果加上 b 的绝对值。</li><li>当 a 和 b 都是负整数时，结果为 a 对 b 取余的结果减去 b 的绝对值。</li></ul><p>下面是一些示例：<br>int a &#x3D; 7, b &#x3D; 3; int result1 &#x3D; a % b;   &#x2F;&#x2F; 结果为 1 a &#x3D; -7; b &#x3D; 3; int result2 &#x3D; a % b;   &#x2F;&#x2F; 结果为 -1 a &#x3D; 7; b &#x3D; -3; int result3 &#x3D; a % b;   &#x2F;&#x2F; 结果为 1 a &#x3D; -7; b &#x3D; -3; int result4 &#x3D; a % b;   &#x2F;&#x2F; 结果为 -1<br>需要注意的是，当 b 的绝对值大于 a 的绝对值时，取模运算的结果为 a 的值。例如：<br>int a &#x3D; 7, b &#x3D; 10; int result &#x3D; a % b;   &#x2F;&#x2F; 结果为 7<br>这是因为在这种情况下，a 对 b 取余的结果等于 a 本身，并且 a 的符号与 b 的符号相同。</p><h4 id="C-如何实现读取一个目录的所有文件"><a href="#C-如何实现读取一个目录的所有文件" class="headerlink" title="C#如何实现读取一个目录的所有文件"></a>C#如何实现读取一个目录的所有文件</h4><p>可以使用 Directory 类和 File 类实现读取一个目录的所有文件。具体实现步骤如下：</p><ol><li>导入 System.IO 命名空间，以便使用 Directory 类和 File 类。using System.IO; </li><li>使用 Directory.GetFiles() 方法获取指定目录中的所有文件路径。string[] fileNames &#x3D; Directory.GetFiles(@”C:\example\directory”); 其中，@”C:\example\directory” 为指定的目录路径。该方法返回一个字符串数组，包含指定目录中的所有文件路径。</li><li>遍历文件路径数组，使用 File.ReadAllText() 方法逐个读取文件内容。foreach (string fileName in fileNames) {     string content &#x3D; File.ReadAllText(fileName);     Console.WriteLine(content); } 其中，fileName 为每个文件的路径。该方法返回一个字符串，包含指定文件的所有文本内容。</li></ol><p>完整代码示例：</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<span class="hljs-keyword">using</span> System.IO;<span class="hljs-keyword">namespace</span> <span class="hljs-title">FileExample</span>&#123;    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>    &#123;        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>        &#123;            <span class="hljs-built_in">string</span>[] fileNames = Directory.GetFiles(<span class="hljs-string">@&quot;C:\example\directory&quot;</span>);            <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">string</span> fileName <span class="hljs-keyword">in</span> fileNames)            &#123;                <span class="hljs-built_in">string</span> content = File.ReadAllText(fileName);                Console.WriteLine(content);            &#125;        &#125;    &#125;&#125;</code></pre></div><p>上述代码将遍历指定目录中的所有文件，并输出每个文件的文本内容到控制台。你可以根据实际需要修改代码，例如修改文件读取方式、输出方式等。</p><h4 id="什么时候会触发picbox中的paint事件"><a href="#什么时候会触发picbox中的paint事件" class="headerlink" title="什么时候会触发picbox中的paint事件"></a>什么时候会触发picbox中的paint事件</h4><p>PictureBox 控件的 Paint 事件在以下情况下会被触发：</p><ol><li>当控件被显示或重绘时（例如，当窗体被最小化或最大化，或者当其他控件被移动时）。</li><li>当控件的 Invalidate() 方法或 Refresh() 方法被调用时，这些方法会强制控件进行重新绘制操作。</li><li>当控件的 BackgroundImage 属性被设置为一个有效的图像时，系统会自动进行绘制操作，从而触发 Paint 事件。</li><li>当控件的 Image 属性被设置为一个有效的图像时，系统也会自动进行绘制操作，从而触发 Paint 事件。</li></ol><p>需要注意的是，当控件的 Image 或 BackgroundImage 属性被设置时，如果图片的尺寸超出了控件的大小，那么图片可能会被裁剪或缩放以适应控件的大小。在这种情况下，绘制的效果可能与预期不同。<br>因此，为了确保绘制效果正确，建议在绘制之前先检查控件的尺寸和图片的尺寸，并根据需要进行缩放或裁剪操作。</p><h1 id="PPM文件转化"><a href="#PPM文件转化" class="headerlink" title="PPM文件转化"></a>PPM文件转化</h1><h4 id="PPM是什么文件"><a href="#PPM是什么文件" class="headerlink" title="PPM是什么文件"></a>PPM是什么文件</h4><p>PM（Portable Pixmap）是一种简单的、可移植的图像文件格式，它是Unix系统中常用的一种图像格式。PPM文件由一系列的ASCII码或二进制代码表示的像素构成，它们按照从左到右、从上到下的顺序排列，每个像素用RGB三元组表示，即红、绿、蓝三个颜色分量。PPM文件可以表示灰度图像、彩色图像和真彩色图像。<br>PPM文件的格式比较简单，每个像素采用纯文本或二进制方式表示，因此容易读取和处理。但是，由于每个像素都用RGB三元组表示，所以PPM文件的文件大小比较大，不适合存储大型图像。此外，PPM文件也不支持压缩，因此文件大小随着图像分辨率的增加而呈线性增长。<br>PPM文件通常用于图像处理、计算机视觉和计算机图形学等领域中，例如在算法测试中，可以将算法处理前后的图像保存为PPM文件，方便比较和分析。</p><h2 id="羊了个羊"><a href="#羊了个羊" class="headerlink" title="羊了个羊"></a>羊了个羊</h2>]]></content>
    
    
    <categories>
      
      <category>课程作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程作业</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell命令</title>
    <link href="/2024/01/26/Shell%E5%91%BD%E4%BB%A4%EF%BC%88%E7%BA%A2%E5%B8%BD%EF%BC%89%EF%BC%9A/"/>
    <url>/2024/01/26/Shell%E5%91%BD%E4%BB%A4%EF%BC%88%E7%BA%A2%E5%B8%BD%EF%BC%89%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h4 id="1-ps1命令："><a href="#1-ps1命令：" class="headerlink" title="1.ps1命令："></a>1.ps1命令：</h4><p>用于定义用户的命令行显示：</p><h4 id="2-创建链接：https-cloud-tencent-com-developer-article-1392619-from-15425-areaSource-102001-2-traceId-UcK5hJ3TZF5NAsnSbGkMx"><a href="#2-创建链接：https-cloud-tencent-com-developer-article-1392619-from-15425-areaSource-102001-2-traceId-UcK5hJ3TZF5NAsnSbGkMx" class="headerlink" title="2.创建链接：https://cloud.tencent.com/developer/article/1392619?from=15425&areaSource=102001.2&traceId=UcK5hJ3TZF5NAsnSbGkMx"></a>2.创建链接：<a href="https://cloud.tencent.com/developer/article/1392619?from=15425&areaSource=102001.2&traceId=UcK5hJ3TZF5NAsnSbGkMx">https://cloud.tencent.com/developer/article/1392619?from=15425&areaSource=102001.2&traceId=UcK5hJ3TZF5NAsnSbGkMx</a></h4><p>语法： ln -d source_path target_path 硬链接文件  ；In:info in 命令；<br> ln -s  source_file softlink_file  创建软链接<br>软链接类似window的快捷方式，里面储存的是目的地址的路径，对软链接文件的读写操作就是对源文件的读写，删除软链接，不会影响源文件。<br>硬链接：源文件的另外一个文件名， 不允许给目录创建硬链接； 只有在同一文件系统中的文件之间才能创建链接。 对硬链接文件进行读写和删除操作时候，结果和软链接相同,这里可以看出硬链接和cp文件的区别是，硬链接是同步变化的。但如果我们删除硬链接文件的源文件，硬链接文件仍然存在，而且保留了原有的内容。     这时，系统就“忘记”了它曾经是硬链接文件。而把他当成一个普通文件。  </p><h4 id="3-tar命令：https-www-cnblogs-com-newcaoguo-p-9678162-html"><a href="#3-tar命令：https-www-cnblogs-com-newcaoguo-p-9678162-html" class="headerlink" title="3.tar命令：https://www.cnblogs.com/newcaoguo/p/9678162.html"></a>3.tar命令：<a href="https://www.cnblogs.com/newcaoguo/p/9678162.html">https://www.cnblogs.com/newcaoguo/p/9678162.html</a></h4><p>打包命令， 使用 tar 命令归档的包通常称为 tar 包（tar 包文件都是以“.tar”结尾的）。<br>语法： tar [选项] 源文件或目录  ，选项：-c:compross 打包，压缩,将多个文件和目录打包；-f:自动包的扩展名；-x:解压</p><h4 id="4-gzip命令："><a href="#4-gzip命令：" class="headerlink" title="4.gzip命令："></a>4.gzip命令：</h4><p><a href="http://c.biancheng.net/view/783.html">链接</a><br>对打包的目录进行压缩，如果目录没有打包，就会对子文件进行压缩</p><h4 id="5-修改文件名："><a href="#5-修改文件名：" class="headerlink" title="5.修改文件名："></a>5.修改文件名：</h4><p>方法：mv命令，rename命令； rename oldName  newName;</p><h4 id="6-apt-advance-package-tool-高级打包工具"><a href="#6-apt-advance-package-tool-高级打包工具" class="headerlink" title="6.apt:advance package tool 高级打包工具"></a>6.<a href="https://blog.csdn.net/m0_46278037/article/details/120232679">apt</a>:advance package tool 高级打包工具</h4><h4 id="7-配置c语言配置环境："><a href="#7-配置c语言配置环境：" class="headerlink" title="7.配置c语言配置环境："></a>7.配置c语言配置环境：</h4><p>1.安装编译器： apt  install gcc<br>2.编译链接程序： gcc 程序.c  -o 程序<br>3.运行程序： .&#x2F;程序名</p><h4 id="8-用户组管理："><a href="#8-用户组管理：" class="headerlink" title="8.用户组管理："></a>8.用户组管理：</h4><h6 id="groups-可以显示-正在登录用户所属的用户组"><a href="#groups-可以显示-正在登录用户所属的用户组" class="headerlink" title="groups:可以显示 正在登录用户所属的用户组"></a>groups:可以显示 正在登录用户所属的用户组</h6>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell编程</title>
    <link href="/2024/01/26/shell%E7%BC%96%E7%A8%8B%EF%BC%88ubuntu%EF%BC%89%EF%BC%9A/"/>
    <url>/2024/01/26/shell%E7%BC%96%E7%A8%8B%EF%BC%88ubuntu%EF%BC%89%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><p><a href="https://wangdoc.com/bash/intro">Bash 简介</a></p><h4 id="查看shell环境："><a href="#查看shell环境：" class="headerlink" title="查看shell环境："></a>查看shell环境：</h4><p>1.cat&#x2F;etc&#x2F;shells:查看系统中可用的shells，注意前面的文件路径；<br>2.echo $SHELL:查看现在允许的shell，注意后面必须要大写，echo 是回声的意思，这里可以看出回应<br>3.ps -p $$:查看当前进程的的shell<br>4.echo ${a}:查看变量并显示在屏幕，但是{}中不能有空格<br>5.在声明和定义变量的时候，&#x3D;号2边不能有空格。否则就会把等号左边的空格的前面当做一个命令来解释了<br>6.只读变量无法用unset命令删除<br>7.按 <strong>Ctrl-C</strong> 组合键来取消当前命令的输入。然后，您可以重新开始输入该命令。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习札记</title>
    <link href="/2024/01/26/Linux%E5%AD%A6%E4%B9%A0%E6%89%8E%E8%AE%B0%EF%BC%9A/"/>
    <url>/2024/01/26/Linux%E5%AD%A6%E4%B9%A0%E6%89%8E%E8%AE%B0%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id="磁盘："><a href="#磁盘：" class="headerlink" title="磁盘："></a>磁盘：</h2><h4 id="磁盘物理结构："><a href="#磁盘物理结构：" class="headerlink" title="磁盘物理结构："></a>磁盘物理结构：</h4><p><a href="https://www.cnblogs.com/cyx-b/p/14095057.html">硬盘结构(图文展示) - chuyaoxin - 博客园</a><br>越是外面的柱面，线速度越大，读取信息越快</p><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>Linux中的&#x2F;表示什么？<br>在Linux中，&#x2F;表示根目录。根目录是Linux系统中的最顶层目录，所有其他目录和文件都是在根目录下的子目录或文件。在Linux中，根目录是所有文件系统的起点，包括硬盘、光驱、USB设备等等，因此所有文件和目录都是相对于根目录的路径来表示的。例如，&#x2F;etc表示根目录下的etc目录，&#x2F;home&#x2F;user表示根目录下的home目录下的user目录，以此类推。在Linux中，根目录还包含其他特殊的目录，例如&#x2F;dev、&#x2F;proc、&#x2F;sys等等，分别用于存储设备文件、进程信息、系统信息等等。</p><h4 id="主引导扇区："><a href="#主引导扇区：" class="headerlink" title="主引导扇区："></a>主引导扇区：</h4><p>主引导扇区（Master Boot Record，MBR）是硬盘上的第一个扇区，大小为512字节。MBR中包含了硬盘的分区表以及引导程序。当计算机开机时，BIOS会读取MBR中的引导程序，将控制权交给引导程序执行。引导程序会根据分区表找到操作系统所在的分区，并将操作系统的引导程序加载到内存中，最终启动操作系统。 MBR分为三个部分：引导程序（bootLoad)、分区表和MBR签名。其中，引导程序位于MBR的前446字节，用于加载操作系统的引导程序。分区表位于MBR的接下来64字节，用于记录硬盘分区的信息，包括分区的起始位置、结束位置、分区类型等等。MBR签名位于MBR的最后两个字节，用于验证MBR的合法性。 MBR只支持最多4个主分区或3个主分区和1个扩展分区。如果需要更多的分区，可以将一个主分区设置为扩展分区，并在其中创建逻辑分区。近年来，由于MBR的局限性，逐渐被GPT（GUID Partition Table）所取代。</p><h4 id="计算机启动："><a href="#计算机启动：" class="headerlink" title="计算机启动："></a>计算机启动：</h4><p><a href="https://www.initroot.com/linuxintroduction/computerbootprocess.html">计算机启动过程</a><br>DBR和激活分区的区别<br>DBR（DOS Boot Record）和激活分区是两个不同的概念。 DBR是可引导分区的引导扇区，也就是分区内的第一个扇区。DBR中包含了分区的文件系统信息和引导程序，用于启动分区内的操作系统。每个可引导分区都有自己的DBR。 而激活分区是硬盘上被指定为启动分区的分区，也就是系统启动时将要启动的分区。在MBR中，分区表记录了硬盘上所有分区的信息，其中被标记为“激活”的分区就是硬盘的启动分区。一个硬盘只能有一个激活分区。 在启动计算机时，BIOS会读取硬盘的MBR，并将控制权交给MBR中被标记为激活的分区。然后，该分区的DBR会被读取，引导程序会加载操作系统的引导文件，并将其加载到内存中，最终启动操作系统。 因此，DBR和激活分区是两个不同的概念，但它们是相互关联的，共同完成了操作系统的启动。<br>那什么是可引导分区<br>可引导分区是指可以安装操作系统并进行启动的硬盘分区。在硬盘上，每个分区都有自己的文件系统和分区表，其中一个或多个分区可以被指定为可引导分区。通常情况下，每个硬盘只有一个可引导分区，它被称为系统分区，用于安装操作系统和启动计算机。 可引导分区的引导扇区（DBR）是分区内的第一个扇区，它包含了分区的文件系统信息和引导程序。当计算机启动时，BIOS会读取硬盘的MBR（Master Boot Record），找到系统分区并将控制权交给系统分区的DBR，引导程序会根据文件系统信息找到操作系统的引导文件，并将其加载到内存中，最终启动操作系统。 需要注意的是，不是所有的分区都可以被指定为可引导分区。只有基本分区和主分区才能被指定为可引导分区，扩展分区和逻辑分区则不能被指定为可引导分区。因此，在分区硬盘时需要注意分区类型，确保系统分区被正确地分配和指定。</p><p>DBR和MBR的区别？<br>DBR（DOS Boot Record）和MBR（Master Boot Record）都是硬盘上的扇区，但它们有以下不同点：</p><ol><li>位置不同：MBR位于硬盘的第一个扇区，而DBR位于可引导分区的第一个扇区。</li><li>功能不同：MBR主要包含硬盘的分区表以及引导程序，用于找到操作系统所在的分区并启动操作系统；而DBR主要包含分区的文件系统信息以及引导程序，用于找到操作系统的引导文件并启动操作系统。</li><li>结构不同：MBR和DBR的结构类似，但有所不同。MBR包含了分区表和MBR签名，而DBR包含了文件系统信息和DBR签名。</li><li>作用不同：MBR是硬盘的引导扇区，控制整个硬盘的启动过程；而DBR是分区的引导扇区，控制分区内的启动过程。 需要注意的是，MBR和DBR的结构和作用是相互关联的。MBR中的分区表记录了可引导分区的信息，而DBR中的引导程序则是由MBR中的引导程序加载的。因此，在硬盘启动过程中，MBR和DBR是相互配合的，共同完成操作系统的启动。</li></ol><p>什么是可引导分区的引导扇区DBR？<br>可引导分区的引导扇区也称为DBR（DOS Boot Record），它是可引导分区的第一个扇区，大小为512字节。DBR中包含了分区的引导程序以及分区的文件系统信息。当计算机开机时，BIOS会读取分区表中的分区信息，找到可引导分区的DBR，并将控制权交给DBR中的引导程序执行。引导程序会根据文件系统信息找到操作系统的引导文件，并将其加载到内存中，最终启动操作系统。 DBR的结构与MBR类似，也包含了引导程序和DBR签名。引导程序位于DBR的前446字节，用于加载操作系统的引导程序。DBR签名位于DBR的最后两个字节，用于验证DBR的合法性。 DBR中的引导程序有多种，例如Windows操作系统使用的NTLDR或BOOTMGR程序，Linux操作系统使用的GRUB或LILO程序等等。不同的引导程序支持的操作系统和文件系统也有所不同。</p><h4 id="文件系统基础知识："><a href="#文件系统基础知识：" class="headerlink" title="文件系统基础知识："></a>文件系统基础知识：</h4><p><a href="https://www.cnblogs.com/wkfvawl/p/11847413.html#2%E3%80%81%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E2%80%94%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D">操作系统——文件系统概述、文件逻辑地址、目录、物理地址 - 王陸 - 博客园</a><br><a href="https://blog.csdn.net/yuexiaxiaoxi27172319/article/details/45241923">Linux文件系统详解(文件系统层次、分类、存储结构、存储介质、文件节点inode)_mooncreek的博客-CSDN博客</a></p><h4 id="虚拟文件系统："><a href="#虚拟文件系统：" class="headerlink" title="虚拟文件系统："></a>虚拟文件系统：</h4><p><a href="https://www.cnblogs.com/orange-CC/p/12720341.html">存储系列之 VFS虚拟文件系统简介 - orange-C - 博客园</a><br>虚拟文件系统（Virtual File System）是操作系统内核中的一种机制，它用于抽象不同文件系统的底层实现细节，为应用程序提供一个统一的文件系统接口。虚拟文件系统将不同的文件系统（如ext4、NTFS、FAT等）抽象为一个统一的文件系统层次结构，使得应用程序可以使用相同的系统调用（如open、read、write、close等）来访问不同类型的文件系统，而不需要关心底层文件系统的具体实现。 虚拟文件系统的实现通常包括以下几个组件：</p><ol><li>VFS层：虚拟文件系统的核心，负责管理所有文件系统的挂载和卸载，以及提供统一的文件系统接口。</li><li>文件系统驱动：每种文件系统都有自己的文件系统驱动，用于将底层文件系统的操作转换为VFS层的统一接口。</li><li>文件系统缓存：用于缓存文件系统的元数据和数据，提高文件系统的访问效率。</li><li>文件系统对象：VFS层维护了文件、目录、超级块等多种文件系统对象，用于描述文件系统的层次结构和属性。 虚拟文件系统的优点在于可以屏蔽不同文件系统之间的差异，使得应用程序可以使用统一的接口来处理不同类型的文件系统。此外，虚拟文件系统也为系统管理员提供了更灵活的管理方式，可以在运行时动态挂载和卸载不同类型的文件系统，以满足不同的需求。</li></ol><h4 id="主流文件系统："><a href="#主流文件系统：" class="headerlink" title="主流文件系统："></a>主流文件系统：</h4><p><a href="https://www.51cto.com/article/609405.html">Linux文件系统：Ext、XFS、Btrfs等，选择适合自己的文件系统-51CTO.COM</a><br><a href="https://www.cnblogs.com/bangerlee/archive/2012/03/31/2426069.html">Linux文件系统介绍 - bangerlee - 博客园</a></p><h4 id="磁盘分区："><a href="#磁盘分区：" class="headerlink" title="磁盘分区："></a>磁盘分区：</h4><p><a href="https://www.cnblogs.com/renshengdezheli/p/13941563.html">linux下使用fdisk进行磁盘分区详解 - 人生的哲理 - 博客园</a></p><h4 id="为什么要给不同的分区创建不一样的文件系统"><a href="#为什么要给不同的分区创建不一样的文件系统" class="headerlink" title="为什么要给不同的分区创建不一样的文件系统"></a>为什么要给不同的分区创建不一样的文件系统</h4><p>给不同的分区创建不同的文件系统类型是因为不同的应用场景需要不同的文件系统类型来优化性能、提高可靠性和满足特定的需求。以下是一些例子：</p><ol><li>根分区：Linux操作系统的根分区通常采用ext4等文件系统类型，因为这些文件系统类型具有高性能和可靠性，并支持快速数据访问和文件系统扩展。</li><li>数据分区：数据分区通常需要支持大容量数据存储和高速数据访问，因此可以采用如NTFS、FAT、exFAT等文件系统类型。</li><li>交换分区：交换分区是Linux系统用来交换内存数据的一种特殊分区，通常采用Linux Swap文件系统类型，因为这种文件系统类型可以支持快速的内存数据交换操作。</li><li>备份分区：备份分区通常需要支持数据快速备份和恢复操作，因此可以采用如NTFS、FAT、exFAT、ext4等文件系统类型。 总之，根据不同的应用场景和需求，选择不同的文件系统类型可以帮助优化系统性能、提高数据可靠性和满足特定的需求。</li></ol><h4 id="tune2fs"><a href="#tune2fs" class="headerlink" title="tune2fs"></a>tune2fs</h4><p><a href="https://www.cnblogs.com/yaobai609/archive/2012/11/21/2781292.html">tune2fs命令详解 - 我想叫晴朗 - 博客园</a><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1678673169268-b600099d-9341-433a-8b00-cfe152516215.png#averageHue=%23faf9f9&clientId=u7a7618ef-de57-4&from=paste&height=274&id=u507bf137&originHeight=342&originWidth=654&originalType=binary&ratio=1&rotation=0&showTitle=false&size=136503&status=done&style=none&taskId=u4fe61dc9-8c68-4abc-a3f9-b14efebd1b1&title=&width=523.2" alt="image.png"></p><h4 id="挂载和卸载文件系统"><a href="#挂载和卸载文件系统" class="headerlink" title="挂载和卸载文件系统"></a>挂载和卸载文件系统</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1678673220974-79677498-e5ab-4bba-a800-5a198579c32c.png#averageHue=%23f5f0d3&clientId=u7a7618ef-de57-4&from=paste&height=325&id=ue7a0496a&originHeight=406&originWidth=761&originalType=binary&ratio=1&rotation=0&showTitle=false&size=231058&status=done&style=none&taskId=uccf8c4f1-e23c-4ae3-ad01-2646e77339d&title=&width=608.8" alt="image.png"><br>&#x2F;dev目录下所有Linux系统中使用的外部设备。但是这里并不是放的外部设备的驱动程序，<br>&#x2F;dev 目录下的设备文件只是对硬件设备的抽象，并不能直接使用（仅仅包括一些文件的相关属性，并没有和Linux系统创建联系）。在 Linux 中，为了能够对硬件设备进行操作，需要先将其挂载到文件系统中。挂载操作会把设备文件与文件系统中的一个目录建立关联，使得文件系统中的应用程序可以通过该目录来访问设备文件。 具体来说，挂载操作会将设备文件的数据块映射到文件系统中的一个目录下，并将该目录作为设备文件的访问入口。这样，当应用程序访问该目录中的文件时，系统就会将其转发到与其映射的设备文件中，从而实现对设备的访问和控制。<br>外部设备的驱动程序放在哪的？<br>外部设备的驱动程序通常是由设备制造商提供的，可以从设备制造商的官方网站或光盘中下载到相应的驱动程序。驱动程序通常被编写为动态链接库（.so 文件）或内核模块（.ko 文件）的形式，并包含了设备与操作系统之间的接口，以及设备所支持的各种功能和特性。 在 Linux 系统中，驱动程序通常被安装到 <strong>&#x2F;lib&#x2F;modules</strong> 目录下，其中 <strong>&#x2F;lib&#x2F;modules&#x2F;<kernel_version>&#x2F;kernel&#x2F;drivers</strong> 目录下存储的是内核自带的驱动程序，而 <strong>&#x2F;lib&#x2F;modules&#x2F;<kernel_version>&#x2F;extra</strong> 目录下存储的是额外的驱动程序。当系统启动时，内核会自动加载相应的驱动程序模块，以便操作系统可以访问并控制相应的外部设备。 除了从设备制造商处获取驱动程序之外，一些开源社区也为一些常见的外部设备提供了通用的驱动程序，例如 Linux USB 设备驱动程序、Linux 网络设备驱动程序等等。这些通用驱动程序通常已经被包含在 Linux 内核中，因此不需要额外下载和安装。<br><a href="https://blog.csdn.net/maopig/article/details/7195048">Linux &#x2F;dev目录详解和Linux系统各个目录的作用_linux dev目录_maopig的博客-CSDN博客</a><br><a href="https://www.cnblogs.com/cangqinglang/p/12170828.html">什么是挂载，Linux挂载如何实现详解 - 苍青浪 - 博客园</a></p><h4 id="如何创建交换文件"><a href="#如何创建交换文件" class="headerlink" title="如何创建交换文件"></a>如何创建交换文件</h4><p><a href="https://developer.aliyun.com/article/842822">Linux创建swap分区（用文件作为Swap分区）-阿里云开发者社区</a><br>在 Linux 中，可以通过创建交换文件（swap file）来扩展系统的虚拟内存空间。以下是创建交换文件的步骤：</p><ol><li><p>确定需要创建的交换文件大小。一般来说，交换文件大小应该为系统内存大小的 2 倍。例如，如果系统内存为 2GB，则交换文件大小应该为 4GB。</p></li><li><p>使用以下命令创建一个指定大小的空文件：</p><div class="code-wrapper"><pre><code class="hljs arduino">plaintextCopy codesudo fallocate -l size /swapfile</code></pre></div><p>其中，<strong>size</strong> 是需要创建的交换文件大小，可以使用 <strong>M</strong> 表示单位为 MB，使用 <strong>G</strong> 表示单位为 GB。例如，要创建一个大小为 4GB 的交换文件，可以使用以下命令：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">plaintextCopy</span> code<span class="hljs-attribute">sudo</span> fallocate -l <span class="hljs-number">4</span>G /swapfile</code></pre></div></li><li><p>使用以下命令将文件格式化为交换文件：</p><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">plaintextCopy</span> <span class="hljs-meta">code</span><span class="hljs-symbol">sudo</span> mkswap /swapfile</code></pre></div></li><li><p>使用以下命令启用交换文件：</p><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">plaintextCopy</span> <span class="hljs-meta">code</span><span class="hljs-symbol">sudo</span> swapon /swapfile</code></pre></div></li><li><p>使用以下命令将交换文件添加到 <strong>&#x2F;etc&#x2F;fstab</strong> 文件中，以便系统在启动时自动挂载：</p><div class="code-wrapper"><pre><code class="hljs bash">plaintextCopy codesudo <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/swapfile none swap sw 0 0&quot;</span> &gt;&gt; /etc/fstab</code></pre></div><p>至此，交换文件创建完成。可以使用以下命令来查看系统的交换空间情况：</p><div class="code-wrapper"><pre><code class="hljs css">plaintextCopy <span class="hljs-selector-tag">code</span>sudo swapon <span class="hljs-attr">--show</span></code></pre></div><p>需要注意的是，创建交换文件可能会影响系统的性能，因此应该谨慎使用。如果系统内存不足，建议考虑升级硬件或者优化应用程序，而不是通过创建交换文件来扩展虚拟内存空间。</p></li></ol><h4 id="Hex-代码-输入-L-列出所有代码-：82"><a href="#Hex-代码-输入-L-列出所有代码-：82" class="headerlink" title="Hex 代码(输入 L 列出所有代码)：82"></a>Hex 代码(输入 L 列出所有代码)：82</h4><p>根据所给的 Hex 代码 82，无法确定其对应的字符或者含义。如果您需要查看 Hex 代码对应的字符或者含义，可以使用 Linux 终端中的 <strong>hexdump</strong> 命令或者在线 Hex 转换工具来实现。具体步骤如下： 使用 <strong>hexdump</strong> 命令： 在 Linux 终端中，可以使用 <strong>hexdump</strong> 命令来查看 Hex 代码对应的字符或者含义。具体命令如下：</p><div class="code-wrapper"><pre><code class="hljs 1c">bashCopy codeecho -n &#x27;\x82&#x27; <span class="hljs-string">| hexdump -C</span></code></pre></div><p>执行上述命令后，终端会输出类似以下的结果：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">plaintextCopy</span> code<span class="hljs-attribute">00000000</span>  <span class="hljs-number">82</span>                                                |.| <span class="hljs-number">00000001</span></code></pre></div><p>其中，第一行的 <strong>82</strong> 是所给的 Hex 代码，第二行中的 <strong>.</strong> 则表示对应的字符为空格。 使用在线 Hex 转换工具： 除了使用 Linux 终端中的 <strong>hexdump</strong> 命令外，还可以使用在线 Hex 转换工具来查看 Hex 代码对应的字符或者含义。具体步骤如下：</p><ol><li>打开任意一个在线 Hex 转换工具，如 <a href="https://www.rapidtables.com/convert/number/hex-to-ascii.html%E3%80%82">https://www.rapidtables.com/convert/number/hex-to-ascii.html。</a></li><li>在 Hex 代码输入框中输入所给的 Hex 代码 <strong>82</strong>。</li><li>点击转换按钮，工具会自动将 Hex 代码转换成对应的字符或者含义。在该工具中，对应的字符为空格。 综上所述，所给的 Hex 代码 <strong>82</strong> 对应的字符或者含义是空格。</li></ol><h4 id="Linux出现乱码怎么解决"><a href="#Linux出现乱码怎么解决" class="headerlink" title="Linux出现乱码怎么解决"></a>Linux出现乱码怎么解决</h4><h4 id="在-Linux-中出现乱码的原因可能有很多，可以根据具体情况采取不同的解决方法。以下是一些常见的乱码问题及其解决方法："><a href="#在-Linux-中出现乱码的原因可能有很多，可以根据具体情况采取不同的解决方法。以下是一些常见的乱码问题及其解决方法：" class="headerlink" title="在 Linux 中出现乱码的原因可能有很多，可以根据具体情况采取不同的解决方法。以下是一些常见的乱码问题及其解决方法："></a>在 Linux 中出现乱码的原因可能有很多，可以根据具体情况采取不同的解决方法。以下是一些常见的乱码问题及其解决方法：</h4><p>终端乱码：如果在终端中出现了乱码，可以尝试修改终端的字符编码设置。可以使用以下命令来查看当前终端的字符编码：</p><p>plaintext<br>Copy code<br>echo $LANG</p><p>如果输出的结果不是 UTF-8 编码，可以使用以下命令来修改终端的字符编码：</p><p>plaintext<br>Copy code<br>export LANG&#x3D;en_US.UTF-8</p><p>文件名乱码：如果在文件管理器中或命令行中出现了文件名乱码，可以尝试修改文件名的字符编码。可以使用以下命令来查看文件名的字符编码：</p><p>plaintext<br>Copy code<br>file -i filename</p><p>如果输出的结果不是 UTF-8 编码，可以使用以下命令来修改文件名的字符编码：</p><p>plaintext<br>Copy code<br>convmv -f old_charset -t utf8 –notest filename</p><p>其中，old_charset 是当前文件名的字符编码。<br>3. 应用程序乱码：如果某个应用程序出现了乱码，可以尝试修改应用程序的字符编码设置。具体方法可以参考应用程序的官方文档或社区支持论坛。<br>需要注意的是，修改字符编码设置可能会影响其他应用程序或系统组件的正常运行，因此在修改前应该先备份相关配置文件，并谨慎操作。如果无法解决乱码问题，可以考虑使用其他字符编码转换工具，如 iconv、enca 等。</p><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><p>Linux如何查看pdf文档</p><h4 id="在-Linux-中，可以使用多种工具来查看-PDF-文档，以下是一些常用的工具："><a href="#在-Linux-中，可以使用多种工具来查看-PDF-文档，以下是一些常用的工具：" class="headerlink" title="在 Linux 中，可以使用多种工具来查看 PDF 文档，以下是一些常用的工具："></a>在 Linux 中，可以使用多种工具来查看 PDF 文档，以下是一些常用的工具：</h4><ol><li><p>Evince：Evince 是 GNOME 桌面环境自带的 PDF 阅读器，支持多种文档格式，包括 PDF、PostScript、DjVu 等。使用以下命令来安装 Evince：</p><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">plaintextCopy</span> <span class="hljs-meta">code</span><span class="hljs-symbol">sudo</span> apt install evince</code></pre></div><p>安装完成后，可以使用以下命令来打开 PDF 文档：</p><div class="code-wrapper"><pre><code class="hljs applescript">plaintextCopy codeevince /path/<span class="hljs-keyword">to</span>/<span class="hljs-built_in">file</span>.pdf</code></pre></div></li><li><p>Okular：Okular 是 KDE 桌面环境自带的 PDF 阅读器，也支持多种文档格式。使用以下命令来安装 Okular：</p><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">plaintextCopy</span> <span class="hljs-meta">code</span><span class="hljs-symbol">sudo</span> apt install okular</code></pre></div><p>安装完成后，可以使用以下命令来打开 PDF 文档：</p><div class="code-wrapper"><pre><code class="hljs applescript">plaintextCopy codeokular /path/<span class="hljs-keyword">to</span>/<span class="hljs-built_in">file</span>.pdf</code></pre></div></li><li><p>Xpdf：Xpdf 是一款轻量级的 PDF 阅读器，可以在终端中使用。使用以下命令来安装 Xpdf：</p><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">plaintextCopy</span> <span class="hljs-meta">code</span><span class="hljs-symbol">sudo</span> apt install xpdf</code></pre></div><p>安装完成后，可以使用以下命令来打开 PDF 文档：</p><div class="code-wrapper"><pre><code class="hljs applescript">plaintextCopy codexpdf /path/<span class="hljs-keyword">to</span>/<span class="hljs-built_in">file</span>.pdf</code></pre></div></li><li><p>Foxit Reader：Foxit Reader 是一款跨平台的 PDF 阅读器，可以在 Linux、Windows、MacOS 等系统中使用。可以从 Foxit 官网下载并安装 Linux 版本的 Foxit Reader，安装完成后可以使用 GUI 界面来打开 PDF 文档。 上述工具中，Evince 和 Okular 是 Linux 系统自带的 PDF 阅读器，Xpdf 则是一款轻量级的 PDF 阅读器，Foxit Reader 则是一款跨平台的 PDF 阅读器，用户可以根据自己的需求选择适合自己的工具来查看 PDF 文档。</p></li></ol><h4 id="成功挂载u盘后-怎么访问里面的文件"><a href="#成功挂载u盘后-怎么访问里面的文件" class="headerlink" title="成功挂载u盘后,怎么访问里面的文件"></a>成功挂载u盘后,怎么访问里面的文件</h4><h4 id="在成功挂载-U-盘后，可以使用-cd-命令进入-U-盘的挂载点目录，然后使用-ls-命令列出-U-盘中的文件和目录，最后使用-cat、vi、less-等命令来访问和编辑文件。具体步骤如下："><a href="#在成功挂载-U-盘后，可以使用-cd-命令进入-U-盘的挂载点目录，然后使用-ls-命令列出-U-盘中的文件和目录，最后使用-cat、vi、less-等命令来访问和编辑文件。具体步骤如下：" class="headerlink" title="在成功挂载 U 盘后，可以使用 cd 命令进入 U 盘的挂载点目录，然后使用 ls 命令列出 U 盘中的文件和目录，最后使用 cat、vi、less 等命令来访问和编辑文件。具体步骤如下："></a>在成功挂载 U 盘后，可以使用 <strong>cd</strong> 命令进入 U 盘的挂载点目录，然后使用 <strong>ls</strong> 命令列出 U 盘中的文件和目录，最后使用 <strong>cat</strong>、<strong>vi</strong>、<strong>less</strong> 等命令来访问和编辑文件。具体步骤如下：</h4><ol><li><p>使用 <strong>cd</strong> 命令进入 U 盘的挂载点目录。例如，如果 U 盘被挂载到 <strong>&#x2F;mnt&#x2F;myusb</strong> 目录下，可以使用以下命令进入该目录：</p><div class="code-wrapper"><pre><code class="hljs bash">plaintextCopy code<span class="hljs-built_in">cd</span> /mnt/myusb</code></pre></div></li><li><p>使用 <strong>ls</strong> 命令列出 U 盘中的文件和目录。例如，可以使用以下命令来查看 U 盘中的文件和目录：</p><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">plaintextCopy</span> <span class="hljs-meta">code</span><span class="hljs-symbol">ls</span></code></pre></div></li><li><p>使用 <strong>cat</strong> 命令来查看文件内容。例如，可以使用以下命令来查看 <strong>example.txt</strong> 文件的内容：</p><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">plaintextCopy</span> <span class="hljs-meta">code</span><span class="hljs-symbol">cat</span> example.txt</code></pre></div></li><li><p>使用 <strong>vi</strong>、<strong>nano</strong>、<strong>emacs</strong> 等命令来编辑文件。例如，可以使用以下命令来编辑 <strong>example.txt</strong> 文件：</p><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">plaintextCopy</span> <span class="hljs-meta">code</span><span class="hljs-symbol">vi</span> example.txt</code></pre></div></li><li><p>使用 <strong>less</strong> 命令来查看长文件内容。例如，可以使用以下命令来查看 <strong>longfile.log</strong> 文件的内容：</p><div class="code-wrapper"><pre><code class="hljs 1c">plaintextCopy codeless longfile.<span class="hljs-built_in">log</span></code></pre></div><p>在使用以上命令访问和编辑 U 盘中的文件时，需要注意 U 盘的读写权限问题。如果 U 盘的文件系统是 NTFS、FAT32 等 Windows 系统常用的文件系统，则需要在挂载 U 盘时添加 <strong>uid</strong> 和 <strong>gid</strong> 参数来指定 U 盘的读写权限。具体方法可以参考挂载 U 盘的相关文档。</p></li></ol><h4 id="如何实现文件系统的自动挂载"><a href="#如何实现文件系统的自动挂载" class="headerlink" title="如何实现文件系统的自动挂载"></a>如何实现文件系统的自动挂载</h4><h4 id="在-Linux-中，可以通过修改-etc-fstab-文件来实现文件系统的自动挂载。-etc-fstab-文件是系统中用于描述文件系统挂载信息的配置文件，其中包含了每个文件系统的设备文件名、挂载点、文件系统类型、挂载选项等信息。-具体来说，要实现文件系统的自动挂载，需要在-etc-fstab-文件中添加相应的挂载信息。例如，如果要将-dev-sdb1-分区自动挂载到-mnt-myusb-目录下，可以在-etc-fstab-文件中添加以下一行："><a href="#在-Linux-中，可以通过修改-etc-fstab-文件来实现文件系统的自动挂载。-etc-fstab-文件是系统中用于描述文件系统挂载信息的配置文件，其中包含了每个文件系统的设备文件名、挂载点、文件系统类型、挂载选项等信息。-具体来说，要实现文件系统的自动挂载，需要在-etc-fstab-文件中添加相应的挂载信息。例如，如果要将-dev-sdb1-分区自动挂载到-mnt-myusb-目录下，可以在-etc-fstab-文件中添加以下一行：" class="headerlink" title="在 Linux 中，可以通过修改 &#x2F;etc&#x2F;fstab 文件来实现文件系统的自动挂载。**&#x2F;etc&#x2F;fstab** 文件是系统中用于描述文件系统挂载信息的配置文件，其中包含了每个文件系统的设备文件名、挂载点、文件系统类型、挂载选项等信息。 具体来说，要实现文件系统的自动挂载，需要在 &#x2F;etc&#x2F;fstab 文件中添加相应的挂载信息。例如，如果要将 &#x2F;dev&#x2F;sdb1 分区自动挂载到 &#x2F;mnt&#x2F;myusb 目录下，可以在 &#x2F;etc&#x2F;fstab 文件中添加以下一行："></a>在 Linux 中，可以通过修改 <strong>&#x2F;etc&#x2F;fstab</strong> 文件来实现文件系统的自动挂载。**&#x2F;etc&#x2F;fstab** 文件是系统中用于描述文件系统挂载信息的配置文件，其中包含了每个文件系统的设备文件名、挂载点、文件系统类型、挂载选项等信息。 具体来说，要实现文件系统的自动挂载，需要在 <strong>&#x2F;etc&#x2F;fstab</strong> 文件中添加相应的挂载信息。例如，如果要将 <strong>&#x2F;dev&#x2F;sdb1</strong> 分区自动挂载到 <strong>&#x2F;mnt&#x2F;myusb</strong> 目录下，可以在 <strong>&#x2F;etc&#x2F;fstab</strong> 文件中添加以下一行：</h4><div class="code-wrapper"><pre><code class="hljs awk">plaintextCopy code<span class="hljs-regexp">/dev/</span>sdb1   <span class="hljs-regexp">/mnt/myu</span>sb   ext4   defaults   <span class="hljs-number">0</span>   <span class="hljs-number">0</span></code></pre></div><p>其中，第一列为设备文件名，第二列为挂载点，第三列为文件系统类型，第四列为挂载选项，第五列为备份标志，第六列为自检顺序。在这个例子中，<strong>defaults</strong> 是一个常用的挂载选项，表示使用系统默认的挂载选项。 保存 <strong>&#x2F;etc&#x2F;fstab</strong> 文件后，系统会在每次启动时自动读取该文件，并根据其中的挂载信息来挂载文件系统。如果需要立即挂载文件系统，可以使用 <strong>mount -a</strong> 命令来让系统重新读取 <strong>&#x2F;etc&#x2F;fstab</strong> 文件并挂载其中的文件系统。</p><h4 id="etc-cron-deny这是什么文件"><a href="#etc-cron-deny这是什么文件" class="headerlink" title="&#x2F;etc&#x2F;cron.deny这是什么文件"></a>&#x2F;etc&#x2F;cron.deny这是什么文件</h4><p>&#x2F;etc&#x2F;cron.deny是一个用于限制用户使用计划任务（crontab）的文件。如果一个用户的用户名在该文件中列出，那么该用户将被禁止使用crontab命令来创建和管理定时任务。 当用户尝试使用crontab命令时，系统会首先检查&#x2F;etc&#x2F;cron.deny文件，如果该文件中包含该用户的用户名，则系统会拒绝该用户使用crontab命令。如果该文件不存在，则系统会检查&#x2F;etc&#x2F;cron.allow文件，如果该文件中包含该用户的用户名，则系统允许该用户使用crontab命令。如果两个文件都不存在，则系统默认允许所有用户使用crontab命令。 需要注意的是，&#x2F;etc&#x2F;cron.deny文件的作用范围仅限于本地系统。如果用户可以通过其他方式远程登录到系统，那么该用户仍然可以使用计划任务来执行定时任务。因此，在安全性要求较高的环境中，建议禁用远程登录，或限制只允许受信任的用户远程登录。</p><h4 id="ps-kill-top命令"><a href="#ps-kill-top命令" class="headerlink" title="ps,kill,top命令"></a>ps,kill,top命令</h4><h4 id="以下是ps、kill和top命令的简要介绍："><a href="#以下是ps、kill和top命令的简要介绍：" class="headerlink" title="以下是ps、kill和top命令的简要介绍："></a>以下是ps、kill和top命令的简要介绍：</h4><ol><li>ps命令：用于显示当前系统中正在运行的进程信息。ps命令可以显示进程的PID、进程名、运行状态、CPU占用率、内存占用率等信息。常用的选项包括：<ul><li><strong>ps aux</strong>：显示所有用户的所有进程。</li><li><strong>ps -ef</strong>：显示所有进程。</li><li>**ps -u <username>**：显示指定用户的进程。</li></ul></li><li>kill命令：用于终止进程。可以使用进程的PID或者进程名来指定要终止的进程。常用的选项包括：<ul><li>**kill <PID>**：根据进程PID终止进程。</li><li>**killall &lt;进程名&gt;**：根据进程名终止进程。</li></ul></li><li>top命令：用于动态地展示系统中正在运行的进程信息。top命令会实时更新进程的CPU占用率、内存占用率等信息，同时还会显示系统的负载情况、进程数、CPU使用情况等。常用的选项包括：<ul><li><strong>top</strong>：默认情况下，top命令会按照CPU占用率降序排列进程信息。</li><li>**top -u <username>**：显示指定用户的进程信息。</li><li>**top -p <PID>**：显示指定PID的进程信息。 这三个命令经常被系统管理员用于进程管理和性能监控。</li></ul></li></ol><h4 id="sbin"><a href="#sbin" class="headerlink" title="&#x2F;sbin"></a>&#x2F;sbin</h4><p>&#x2F;sbin是Linux系统中的一个目录，它包含了一些系统管理员使用的二进制可执行文件。&#x2F;sbin目录通常包含一些用于系统管理和维护的工具和命令，这些工具和命令只有root用户才能够执行。 在默认的Linux文件系统层次结构中，&#x2F;sbin目录通常包含以下一些命令和工具：</p><ul><li><strong>&#x2F;sbin&#x2F;shutdown</strong>：用于关闭系统。</li><li><strong>&#x2F;sbin&#x2F;ifconfig</strong>：用于配置网络接口。</li><li><strong>&#x2F;sbin&#x2F;route</strong>：用于配置网络路由。</li><li><strong>&#x2F;sbin&#x2F;fdisk</strong>：用于磁盘分区。</li><li><strong>&#x2F;sbin&#x2F;mkfs</strong>：用于创建文件系统。</li><li><strong>&#x2F;sbin&#x2F;fsck</strong>：用于检查和修复文件系统。</li><li><strong>&#x2F;sbin&#x2F;service</strong>：用于启动、停止和查询系统服务的状态。 总的来说，**&#x2F;sbin<strong>目录包含了一些系统管理员常用的命令和工具，这些命令和工具对于系统的管理、维护和修复是非常重要的。在一些Linux系统中，</strong>&#x2F;sbin<strong>目录的内容可能会被合并到</strong>&#x2F;usr&#x2F;sbin**目录中，以便于管理和维护。</li></ul><h4 id="usr-sbin-service"><a href="#usr-sbin-service" class="headerlink" title="&#x2F;usr&#x2F;sbin&#x2F;service"></a>&#x2F;usr&#x2F;sbin&#x2F;service</h4><p><strong>&#x2F;usr&#x2F;sbin&#x2F;service</strong>是一个命令，用于在Linux系统上启动、停止、重启和查询系统服务的状态。通过使用<strong>service</strong>命令，可以方便地管理系统服务，而无需记住每个服务的具体命令和参数。 <strong>service</strong>命令的语法如下：</p><div class="code-wrapper"><pre><code class="hljs xml">plaintextCopy codeservice <span class="hljs-tag">&lt;<span class="hljs-name">服务名</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">命令</span>&gt;</span></code></pre></div><p>其中，**&lt;服务名&gt;<strong>是要操作的服务的名称，</strong>&lt;命令&gt;**可以是以下之一：</p><ul><li>start：启动服务</li><li>stop：停止服务</li><li>restart：重启服务</li><li>reload：重新加载服务配置文件</li><li>status：查询服务状态 例如，要启动Apache HTTP Server服务，可以使用以下命令：<div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">plaintextCopy</span> <span class="hljs-meta">code</span><span class="hljs-symbol">service</span> httpd start</code></pre></div>在不同的Linux发行版中，<strong>service</strong>命令可能会被替换为其他命令，例如<strong>systemctl</strong>。</li></ul><h4 id="每天早上7-50自动开启sshd服务，22点50时关闭--每隔5天清空一次FTP服务器公共目录-var-ftp-pub--每周六的7-30时，重新启动httpd服务--每周一、三、五的17-30时，打包备份-etc-httpd目录--每天晚上9：30重启linux系统，并删除-var-www-user1下的所有文件--周一到周五下午五点半自动关机。"><a href="#每天早上7-50自动开启sshd服务，22点50时关闭--每隔5天清空一次FTP服务器公共目录-var-ftp-pub--每周六的7-30时，重新启动httpd服务--每周一、三、五的17-30时，打包备份-etc-httpd目录--每天晚上9：30重启linux系统，并删除-var-www-user1下的所有文件--周一到周五下午五点半自动关机。" class="headerlink" title="每天早上7:50自动开启sshd服务，22点50时关闭  每隔5天清空一次FTP服务器公共目录&#x2F;var&#x2F;ftp&#x2F;pub  每周六的7:30时，重新启动httpd服务  每周一、三、五的17:30时，打包备份&#x2F;etc&#x2F;httpd目录  每天晚上9：30重启linux系统，并删除&#x2F;var&#x2F;www&#x2F;user1下的所有文件  周一到周五下午五点半自动关机。"></a>每天早上7:50自动开启sshd服务，22点50时关闭  每隔5天清空一次FTP服务器公共目录&#x2F;var&#x2F;ftp&#x2F;pub  每周六的7:30时，重新启动httpd服务  每周一、三、五的17:30时，打包备份&#x2F;etc&#x2F;httpd目录  每天晚上9：30重启linux系统，并删除&#x2F;var&#x2F;www&#x2F;user1下的所有文件  周一到周五下午五点半自动关机。</h4><p>You can set up these tasks using a tool called <strong>cron</strong> on your Linux server. <strong>cron</strong> allows you to schedule tasks to run automatically at specified times and dates. You can edit the <strong>crontab</strong> file to specify the tasks and their schedules.<br>For example, to automatically start the <strong>sshd</strong> service at 7:50 AM every day and stop it at 10:50 PM, you can add the following lines to your <strong>crontab</strong> file:<br>50 7 * * * &#x2F;usr&#x2F;sbin&#x2F;service sshd start 50 22 * * * &#x2F;usr&#x2F;sbin&#x2F;service sshd stop<br>Here are the cron entries for the other tasks in your list:</p><p>To clear the &#x2F;var&#x2F;ftp&#x2F;pub directory on the FTP server every 5 days:<br>0 0 <em>&#x2F;5 _ _ rm -rf &#x2F;var&#x2F;ftp&#x2F;pub&#x2F;</em><br>To restart the httpd service at 7:30 AM every Saturday:<br>30 7 _ _ 6 &#x2F;usr&#x2F;sbin&#x2F;service httpd restart<br>To create a backup of the &#x2F;etc&#x2F;httpd directory at 5:30 PM every Monday, Wednesday, and Friday:<br>30 17 _ _ 1,3,5 tar -czf &#x2F;path&#x2F;to&#x2F;backup&#x2F;httpd-$(date +%Y%m%d).tar.gz &#x2F;etc&#x2F;httpd<br>To restart the Linux system at 9:30 PM every day and delete all files in the &#x2F;var&#x2F;www&#x2F;user1 directory:<br>30 21 _ _ _ rm -rf &#x2F;var&#x2F;www&#x2F;user1&#x2F;_ &amp;&amp; &#x2F;sbin&#x2F;shutdown -r now<br>To automatically shut down the system at 5:30 PM from Monday to Friday:<br>30 17 _ _ 1-5 &#x2F;sbin&#x2F;shutdown -h now<br>You can add these lines to your crontab file to set up these tasks. Make sure to replace &#x2F;path&#x2F;to&#x2F;backup with the actual path where you want to store the backup files.</p><p>Is there anything else you would like to know?</p><p>已收到消息. Here are the <code>cron</code> entries for the other tasks in your list: - To clear the <code>/var/ftp/pub</code> directory on the FTP server every 5 days: <code>0 0 */5 * * rm -rf /var/ftp/pub/*</code> - To restart the <code>httpd</code> service at 7:30 AM every Saturday: <code>30 7 * * 6 /usr/sbin/service httpd restart</code> - To create a backup of the <code>/etc/httpd</code> directory at 5:30 PM every Monday, Wednesday, and Friday: <code>30 17 * * 1,3,5 tar -czf /path/to/backup/httpd-$(date +\%Y\%m\%d).tar.gz /etc/httpd</code> - To restart the Linux system at 9:30 PM every day and delete all files in the <code>/var/www/user1</code> directory: <code>30 21 * * * rm -rf /var/www/user1/* &amp;&amp; /sbin/shutdown -r now</code> - To automatically shut down the system at 5:30 PM from Monday to Friday: <code>30 17 * * 1-5 /sbin/shutdown -h now</code> You can add these lines to your <code>crontab</code> file to set up these tasks. Make sure to replace <code>/path/to/backup</code> with the actual path where you want to store the backup files. Is there anything else you would like to know?<br>&#x2F;sbin&#x2F;shutdown<br>已发送电子邮件. &#x2F;sbin&#x2F;shutdown<br>&#x2F;sbin&#x2F;shutdown is a command used to shut down or restart the Linux system. In the cron entries I provided earlier, it is used to automatically shut down the system at 5:30 PM from Monday to Friday and to restart the system at 9:30 PM every day.</p><p>You can use the -h option with the shutdown command to halt the system (i.e., shut it down), and the -r option to restart it. For example, &#x2F;sbin&#x2F;shutdown -h now will shut down the system immediately, while &#x2F;sbin&#x2F;shutdown -r now will restart it immediately.</p><p>Is there anything else you would like to know about this command or any other aspect of your tasks?</p><p>已收到消息. <code>/sbin/shutdown</code> is a command used to shut down or restart the Linux system. In the <code>cron</code> entries I provided earlier, it is used to automatically shut down the system at 5:30 PM from Monday to Friday and to restart the system at 9:30 PM every day. You can use the <code>-h</code> option with the <code>shutdown</code> command to halt the system (i.e., shut it down), and the <code>-r</code> option to restart it. For example, <code>/sbin/shutdown -h now</code> will shut down the system immediately, while <code>/sbin/shutdown -r now</code> will restart it immediately. Is there anything else you would like to know about this command or any other aspect of your tasks?<br>2. 设置natasha用户的计划任务：  每周日晚上23:55时将“&#x2F;etc&#x2F;passwd”文件的内容复制到用户主目录中，保存为pwd.txt文件<br>已发送电子邮件. 2. 设置natasha用户的计划任务：  每周日晚上23:55时将“&#x2F;etc&#x2F;passwd”文件的内容复制到用户主目录中，保存为pwd.txt文件<br>To set up a cron job for the natasha user to copy the contents of the &#x2F;etc&#x2F;passwd file to their home directory as a pwd.txt file at 11:55 PM every Sunday, you can do the following:</p><p>Open the crontab file for the natasha user by running the command crontab -u natasha -e.<br>Add the following line to the file:<br>55 23 _ _ 0 cp &#x2F;etc&#x2F;passwd &#x2F;home&#x2F;natasha&#x2F;pwd.txt<br>Save and close the file.<br>This will set up the task to run automatically at the specified time. Make sure that the natasha user has permission to read the &#x2F;etc&#x2F;passwd file and write to their home directory.</p><p>Is there anything else you would like to know?</p><p>已收到消息. To set up a <code>cron</code> job for the <code>natasha</code> user to copy the contents of the <code>/etc/passwd</code> file to their home directory as a <code>pwd.txt</code> file at 11:55 PM every Sunday, you can do the following: 1. Open the <code>crontab</code> file for the <code>natasha</code> user by running the command <code>crontab -u natasha -e</code>. 2. Add the following line to the file: <code>55 23 * * 0 cp /etc/passwd /home/natasha/pwd.txt</code> 3. Save and close the file. This will set up the task to run automatically at the specified time. Make sure that the <code>natasha</code> user has permission to read the <code>/etc/passwd</code> file and write to their home directory. Is there anything else you would like to know?<br>3. 分别使用ps，kill和top命令，实现其操作：  确定内存使用最多的进程，将其nice优先级调整为15  确定cpu使用最多的进程，终止该进程<br>已发送电子邮件. 3. 分别使用ps，kill和top命令，实现其操作：  确定内存使用最多的进程，将其nice优先级调整为15  确定cpu使用最多的进程，终止该进程<br>To determine the process that is using the most memory and adjust its nice priority to 15, you can use the ps and renice commands. Here is an example command that will do this:</p><p>ps -eo pid,pmem –sort&#x3D;-pmem | head -n 2 | tail -n 1 | awk ‘{print $1}’ | xargs sudo renice -n 15<br>This command uses ps to list all processes along with their memory usage (pmem) and sorts them by memory usage in descending order. The head and tail commands are used to extract the second line of the output, which contains the PID of the process with the highest memory usage. The awk command extracts the PID from this line, and xargs passes it as an argument to the renice command, which adjusts the nice value of the process to 15.</p><p>To determine the process that is using the most CPU and terminate it, you can use the ps and kill commands. Here is an example command that will do this:</p><p>ps -eo pid,pcpu –sort&#x3D;-pcpu | head -n 2 | tail -n 1 | awk ‘{print $1}’ | xargs kill<br>This command is similar to the previous one but uses the pcpu field to sort processes by CPU usage instead of memory usage. The extracted PID is passed to the kill command to terminate the process.</p><p>The top command can also be used to view system information and manage processes interactively. When you run top, it displays a real-time view of system activity, including information about processes and their resource usage. You can use various commands within top to sort processes by different criteria (e.g., memory or CPU usage), change their priority, or send signals to them (e.g., to terminate them).</p><p>Is there anything else you would like to know?</p><p>已收到消息. To determine the process that is using the most memory and adjust its <code>nice</code> priority to 15, you can use the <code>ps</code> and <code>renice</code> commands. Here is an example command that will do this: <code>ps -eo pid,pmem --sort=-pmem | head -n 2 | tail -n 1 | awk &#39;&#123;print $1&#125;&#39; | xargs sudo renice -n 15</code> This command uses <code>ps</code> to list all processes along with their memory usage (<code>pmem</code>) and sorts them by memory usage in descending order. The <code>head</code> and <code>tail</code> commands are used to extract the second line of the output, which contains the PID of the process with the highest memory usage. The <code>awk</code> command extracts the PID from this line, and <code>xargs</code> passes it as an argument to the <code>renice</code> command, which adjusts the <code>nice</code> value of the process to 15. To determine the process that is using the most CPU and terminate it, you can use the <code>ps</code> and <code>kill</code> commands. Here is an example command that will do this: <code>ps -eo pid,pcpu --sort=-pcpu | head -n 2 | tail -n 1 | awk &#39;&#123;print $1&#125;&#39; | xargs kill</code> This command is similar to the previous one but uses the <code>pcpu</code> field to sort processes by CPU usage instead of memory usage. The extracted PID is passed to the <code>kill</code> command to terminate the process. The <code>top</code> command can also be used to view system information and manage processes interactively. When you run <code>top</code>, it displays a real-time view of system activity, including information about processes and their resource usage. You can use various commands within <code>top</code> to sort processes by different criteria (e.g., memory or CPU usage), change their priority, or send signals to them (e.g., to terminate them). Is there anything else you would like to know?<br>4. 挂起和恢复进程  按Ctrl+z键，挂起进程cat  输入jobs命令，查看作业  输入bg，把cat切换到后台执行  输入fg，把cat切换到前台执行  按Ctrl+c键，结束进程cat<br>已发送电子邮件.<br>Yes, you can use the Ctrl+z key combination to suspend a running process in the foreground (e.g., cat) and send it to the background. Once suspended, you can use the jobs command to view the status of background jobs.</p><p>To resume a suspended process in the background, you can use the bg command followed by the job number (e.g., bg %1). This will allow the process to continue running in the background while you can continue using the terminal for other tasks.</p><p>To bring a background process back to the foreground, you can use the fg command followed by the job number (e.g., fg %1). This will bring the process back to the foreground and allow you to interact with it directly.</p><p>To terminate a foreground process, you can use the Ctrl+c key combination. This will send an interrupt signal to the process and cause it to terminate.</p><p>Is there anything else you would like to know?</p><p>已收到消息. Yes, you can use the <code>Ctrl+z</code> key combination to suspend a running process in the foreground (e.g., <code>cat</code>) and send it to the background. Once suspended, you can use the <code>jobs</code> command to view the status of background jobs. To resume a suspended process in the background, you can use the <code>bg</code> command followed by the job number (e.g., <code>bg %1</code>). This will allow the process to continue running in the background while you can continue using the terminal for other tasks. To bring a background process back to the foreground, you can use the <code>fg</code> command followed by the job number (e.g., <code>fg %1</code>). This will bring the process back to the foreground and allow you to interact with it directly. To terminate a foreground process, you can use the <code>Ctrl+c</code> key combination. This will send an interrupt signal to the process and cause it to terminate. Is there anything else you would like to know?<br>5. 使用at命令 (1) 登记一个一次性运行命令 ps –aux 的作业，使其在3:00am执行。 (2) 登记一条计划任务在三八妇女节当天九点广播祝贺所有人节日快乐。 (3) 登记一条计划任务6小时后查找&#x2F;root目录下所有扩展名为.txt的文件。<br>已发送电子邮件.<br>The at command can be used to schedule one-time tasks to run at a specific time in the future. Here’s how you can use it to perform the tasks you mentioned:</p><p>To schedule a one-time job to run the ps -aux command at 3:00 AM, you can use the following command:<br>echo “ps -aux” | at 3:00 AM<br>This will create an at job that will run the specified command at the specified time.</p><p>To schedule a one-time job to broadcast a message to all users at 9:00 AM on International Women’s Day (March 8), you can use the following command:<br>echo “wall ‘Happy International Women’s Day!’” | at 9:00 AM Mar 8<br>This will create an at job that will run the wall command with the specified message at the specified time.</p><p>To schedule a one-time job to find all .txt files in the &#x2F;root directory 6 hours from now, you can use the following command:<br>echo “find &#x2F;root -name ‘*.txt’” | at now + 6 hours<br>This will create an at job that will run the find command with the specified options at the specified time.</p><p>After creating an at job, you can use the atq command to view the list of scheduled jobs and their execution times. You can also use the atrm command followed by a job number to remove a scheduled job.</p><p>Is there anything else you would like to know?</p><p>已收到消息. The <code>at</code> command can be used to schedule one-time tasks to run at a specific time in the future. Here’s how you can use it to perform the tasks you mentioned: 1. To schedule a one-time job to run the <code>ps -aux</code> command at 3:00 AM, you can use the following command: <code>echo &quot;ps -aux&quot; | at 3:00 AM</code> This will create an <code>at</code> job that will run the specified command at the specified time. 2. To schedule a one-time job to broadcast a message to all users at 9:00 AM on International Women’s Day (March 8), you can use the following command: <code>echo &quot;wall &#39;Happy International Women&#39;s Day!&#39;&quot; | at 9:00 AM Mar 8</code> This will create an <code>at</code> job that will run the <code>wall</code> command with the specified message at the specified time. 3. To schedule a one-time job to find all <code>.txt</code> files in the <code>/root</code> directory 6 hours from now, you can use the following command: <code>echo &quot;find /root -name &#39;*.txt&#39;&quot; | at now + 6 hours</code> This will create an <code>at</code> job that will run the <code>find</code> command with the specified options at the specified time. After creating an <code>at</code> job, you can use the <code>atq</code> command to view the list of scheduled jobs and their execution times. You can also use the <code>atrm</code> command followed by a job number to remove a scheduled job. Is there anything else you would like to know?<br>6. 禁止harry用户执行计划任务，其他用户不受限制<br>已发送电子邮件. 6. 禁止harry用户执行计划任务，其他用户不受限制<br>To prevent a specific user (e.g., harry) from running cron jobs while allowing other users to do so, you can use the &#x2F;etc&#x2F;cron.deny file. This file contains a list of usernames, one per line, that are not allowed to use cron.</p><p>To add the harry user to this file and prevent them from running cron jobs, you can use the following command:</p><p>echo “harry” | sudo tee -a &#x2F;etc&#x2F;cron.deny<br>This will append the username harry to the &#x2F;etc&#x2F;cron.deny file. After this change, the harry user will not be able to use cron to schedule jobs.</p><p>If you want to allow the harry user to use cron again in the future, you can remove their username from the &#x2F;etc&#x2F;cron.deny file.</p><p>Is there anything else you would like to know?</p><h4 id="inux分区的id是什么？"><a href="#inux分区的id是什么？" class="headerlink" title="inux分区的id是什么？"></a>inux分区的id是什么？</h4><p><a href="http://c.biancheng.net/view/891.html">Linux分区的id是一个用来表示分区内文件系统类型的数字</a><a href="http://c.biancheng.net/view/891.html">1</a><a href="http://c.biancheng.net/view/891.html">。不同的id对应不同的文件系统，例如，83表示Linux本地文件系统，82表示Linux交换分区，c表示FAT32文件系统等</a><a href="http://c.biancheng.net/view/891.html">1</a><a href="http://c.biancheng.net/view/891.html">。您可以使用fdisk命令的i选项查看所有可用的id</a><a href="http://c.biancheng.net/view/891.html">1</a>。<br><a href="https://zhuanlan.zhihu.com/p/62459117">如果您想知道如何获取Linux分区的UUID（通用唯一识别码），您可以参考第一个搜索结果</a><a href="https://zhuanlan.zhihu.com/p/62459117">2</a>，它介绍了七种方法。<br>df -h I grep data<br>Hello, this is Bing. It seems like you are looking for information about a Linux command. <a href="https://www.redhat.com/sysadmin/Linux-df-command">According to the web search results</a><a href="https://www.redhat.com/sysadmin/Linux-df-command">1</a>, <strong>df -h</strong> is a command that displays the amount of disk space available on the filesystem with each file name’s argument. The <strong>-h</strong> option makes the output human-readable by using units like MB and GB. The <strong>I</strong> symbol is a pipe that connects the output of one command to the input of another command. The <strong>grep data</strong> command filters the output of <strong>df -h</strong> by only showing lines that contain the word “data”. So, the whole command <strong>df -h I grep data</strong> will show you how much disk space is available on the filesystems that have “data” in their file names.</p><h4 id="slash在计算机专业上是什么意思？"><a href="#slash在计算机专业上是什么意思？" class="headerlink" title="slash在计算机专业上是什么意思？"></a>slash在计算机专业上是什么意思？</h4><p><a href="https://www.zhihu.com/question/20374919">根据网络搜索结果，快照在计算机专业上是什么意思？</a><a href="https://www.zhihu.com/question/20374919">1</a><a href="https://blog.csdn.net/Rex_WUST/article/details/96349878">2</a></p><ul><li>快照是数据存储的某一时刻的状态记录，它可以用来恢复数据到之前的状态。</li><li>快照与备份有一些区别，例如：<ul><li>备份是数据存储的某一个时刻的副本，它可以在原始数据损坏时恢复数据，而快照不能。</li><li>快照的速度比备份快得多，它只需要记录数据变化的部分，而不需要复制整个数据。</li><li>快照占用的空间比备份少得多，它只需要存储数据变化的部分，而不需要存储整个数据。查看分区大小的命令</li></ul></li></ul><p>思？</p><h4 id="查看分区大小的命令"><a href="#查看分区大小的命令" class="headerlink" title="查看分区大小的命令"></a>查看分区大小的命令</h4><p>According to Bing Translator<a href="https://bing.com/search?q=translate+%22%E6%9F%A5%E7%9C%8B%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%91%BD%E4%BB%A4%22+to+English">1</a>, your message means “command to view partition size” in English. I assume you are asking about Linux partitions. Here are some commands from the web search results that may help you:</p><ul><li><a href="https://blog.csdn.net/a1010256340/article/details/76691495">df -h: This command shows the disk space usage of each partition in a human-readable format</a><a href="https://blog.csdn.net/a1010256340/article/details/76691495">2</a><a href="https://zhuanlan.zhihu.com/p/398961609">3</a>.</li><li><a href="https://zhuanlan.zhihu.com/p/398961609">fdisk -l: This command shows the disk partitions and their sizes in sectors</a><a href="https://zhuanlan.zhihu.com/p/398961609">3</a><a href="https://blog.csdn.net/xudailong_blog/article/details/80850228">4</a>.</li><li><a href="https://blog.csdn.net/xudailong_blog/article/details/80850228">lsblk: This command shows the block devices and their sizes in a tree-like format</a><a href="https://blog.csdn.net/xudailong_blog/article/details/80850228">4</a>.</li></ul><h4 id="查看文件系统"><a href="#查看文件系统" class="headerlink" title="查看文件系统"></a>查看文件系统</h4><p>According to Bing Translator<a href="https://bing.com/search?q=translate+%22%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%22+to+English">1</a>, your message means “view the file system” in English. I assume you are asking about Linux file systems. Here are some commands from the web search results that may help you:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/166557307">mount: This command shows all the mounted file systems and their types</a><a href="https://zhuanlan.zhihu.com/p/166557307">2</a>.</li><li><a href="https://blog.csdn.net/weixin_46239293/article/details/112072319">df -h: This command shows the disk space usage of each mounted file system in a human-readable format</a><a href="https://blog.csdn.net/weixin_46239293/article/details/112072319">3</a><a href="https://blog.csdn.net/dinghua_xuexi/article/details/108959620">4</a>.</li><li><a href="https://blog.csdn.net/dinghua_xuexi/article/details/108959620">lsblk -f: This command shows the file system type of each block device</a><a href="https://blog.csdn.net/dinghua_xuexi/article/details/108959620">4</a></li></ul><h4 id="useradd和adduser的区别："><a href="#useradd和adduser的区别：" class="headerlink" title="useradd和adduser的区别："></a>useradd和adduser的区别：</h4><p><a href="https://blog.csdn.net/beitiandijun/article/details/41678251?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-41678251-blog-52397014.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-41678251-blog-52397014.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=2">linux用户管理（1）—-创建用户（adduser和useradd）和删除用户（userdel）_adduser建在&#x2F;home目录下_录事参军的博客-CSDN博客</a></p><h4 id="useradd-m-d-users-archlinux-archlinux"><a href="#useradd-m-d-users-archlinux-archlinux" class="headerlink" title="useradd -m -d &#x2F;users&#x2F;archlinux archlinux"></a>useradd -m -d &#x2F;users&#x2F;archlinux archlinux</h4><p>这里的-m选项是如果没有用户没有家目录就创建家里面，-d选项指定了家目录的路径</p><h4 id="lsblk命令"><a href="#lsblk命令" class="headerlink" title="lsblk命令"></a>lsblk命令</h4><p><strong>lsblk</strong>命令可以列出所有块设备的信息，包括磁盘分区、磁盘、软盘、CD-ROM等等。这个命令会显示设备的名称、大小、挂载点等信息</p><h4 id="新建用户archlinux，要求其家目录为-users-archlinux，而后su切换至archlinux用户，复制-etc-pam-d目录至自己的家目录。-1-创建用户并指定其家目录。-2-切换用户，并复制文件。-3-查看文件个数。"><a href="#新建用户archlinux，要求其家目录为-users-archlinux，而后su切换至archlinux用户，复制-etc-pam-d目录至自己的家目录。-1-创建用户并指定其家目录。-2-切换用户，并复制文件。-3-查看文件个数。" class="headerlink" title="新建用户archlinux，要求其家目录为&#x2F;users&#x2F;archlinux，而后su切换至archlinux用户，复制&#x2F;etc&#x2F;pam.d目录至自己的家目录。 1) 创建用户并指定其家目录。 2) 切换用户，并复制文件。 3) 查看文件个数。"></a>新建用户archlinux，要求其家目录为&#x2F;users&#x2F;archlinux，而后su切换至archlinux用户，复制&#x2F;etc&#x2F;pam.d目录至自己的家目录。 1) 创建用户并指定其家目录。 2) 切换用户，并复制文件。 3) 查看文件个数。</h4><p>To create a new user <strong>archlinux</strong> with home directory <strong>&#x2F;users&#x2F;archlinux</strong>, you can use the following command:<br>sudo useradd -m -d &#x2F;users&#x2F;archlinux archlinux<br>Here, <strong>-m</strong> creates the home directory if it doesn’t exist and <strong>-d</strong> specifies the home directory path.<br>To switch to the <strong>archlinux</strong> user, you can use the following command:<br>su - archlinux<br>To copy the <strong>&#x2F;etc&#x2F;pam.d</strong> directory to the home directory of the <strong>archlinux</strong> user, you can use the following command:<br>cp -r &#x2F;etc&#x2F;pam.d &#x2F;users&#x2F;archlinux&#x2F;<br>To check the number of files in the directory, you can use the following command:<br>ls &#x2F;users&#x2F;archlinux&#x2F;pam.d | wc -l<br>Here, <strong>ls &#x2F;users&#x2F;archlinux&#x2F;pam.d</strong> lists all the files in the directory and <strong>wc -l</strong> counts the number of files.<br>I hope that helps! Let me know if you have any other questions.</p><h4 id="收缩testlv至3G，要求archlinux用户的文件不能丢失。-1-卸载文件系统。-2-检查文件系统是否完好。-3-设置文件系统大小。-4-缩减逻辑卷。-5-再次查看逻辑卷大小。-6-再次挂载。-7-查看pam-d目录中文件个数。"><a href="#收缩testlv至3G，要求archlinux用户的文件不能丢失。-1-卸载文件系统。-2-检查文件系统是否完好。-3-设置文件系统大小。-4-缩减逻辑卷。-5-再次查看逻辑卷大小。-6-再次挂载。-7-查看pam-d目录中文件个数。" class="headerlink" title="收缩testlv至3G，要求archlinux用户的文件不能丢失。 1) 卸载文件系统。 2) 检查文件系统是否完好。 3) 设置文件系统大小。 4) 缩减逻辑卷。 5) 再次查看逻辑卷大小。 6) 再次挂载。 7) 查看pam.d目录中文件个数。"></a>收缩testlv至3G，要求archlinux用户的文件不能丢失。 1) 卸载文件系统。 2) 检查文件系统是否完好。 3) 设置文件系统大小。 4) 缩减逻辑卷。 5) 再次查看逻辑卷大小。 6) 再次挂载。 7) 查看pam.d目录中文件个数。</h4><h2 id="网路设置"><a href="#网路设置" class="headerlink" title="网路设置;"></a>网路设置;</h2><p><a href="https://blog.csdn.net/weixin_51486343/article/details/110728913">Linux–网络设置（查看及测试网络、使用网络配置命令及修改网络配置文件）_查看某目录下使用一致的网络设备命名的配置文件,打开该文件,查看网络接口配置文件_Xucf1的博客-CSDN博客</a></p><h4 id="vsftp"><a href="#vsftp" class="headerlink" title="vsftp:"></a>vsftp:</h4><p><a href="https://blog.csdn.net/founderznd/article/details/103462976">Linux使用笔记：配置FTP服务器（vsftp）_古月河图的博客-CSDN博客</a><br><a href="https://zhuanlan.zhihu.com/p/454199786">【linux运维】玩转vsftpd安装与配置</a></p><h4 id="如何测试vsftp"><a href="#如何测试vsftp" class="headerlink" title="如何测试vsftp"></a>如何测试vsftp</h4><p>You can test your vsftp setup using a command line on a machine and test access to the machine using FTP. <a href="https://docs.rockylinux.org/guides/file_sharing/secure_ftp_server_vsftpd/">Another way to test is by using an FTP client such as FileZilla</a><a href="https://docs.rockylinux.org/guides/file_sharing/secure_ftp_server_vsftpd/">1</a>. <a href="https://docs.rockylinux.org/guides/file_sharing/secure_ftp_server_vsftpd/">When you test with a virtual user to the server running vsftp, you should get an SSL certificate trust message</a><a href="https://docs.rockylinux.org/guides/file_sharing/secure_ftp_server_vsftpd/">1</a>. Is there anything specific you would like to know more about?</p><h4 id="chmod-777"><a href="#chmod-777" class="headerlink" title="chmod 777"></a>chmod 777</h4><p><strong>chmod 777</strong> is a command that changes the permissions of a file or directory to allow read, write and execute access for the owner, group and others. However, it is generally not recommended to use <strong>chmod 777</strong> as it can create security risks by allowing anyone to read, write and execute the file or directory. It’s usually better to set more restrictive permissions that only allow access to the users who need it.</p><h4 id="vsftpd中什么是匿名访问？"><a href="#vsftpd中什么是匿名访问？" class="headerlink" title="vsftpd中什么是匿名访问？"></a>vsftpd中什么是匿名访问？</h4><p>在vsftpd中，匿名访问是指允许用户不使用用户名和密码就能登录FTP服务器。这种方式通常用于公开共享文件，但也可能带来安全风险。如果您希望启用或禁用匿名访问，可以在vsftpd的配置文件中进行设置。</p><h4 id="如何禁止匿名用户上传文件？"><a href="#如何禁止匿名用户上传文件？" class="headerlink" title="如何禁止匿名用户上传文件？"></a>如何禁止匿名用户上传文件？</h4><p>如果您希望禁止匿名用户上传文件，可以在vsftpd的配置文件中设置 <strong>anon_upload_enable&#x3D;NO</strong>。这样，匿名用户将无法使用FTP协议上传文件到服务器。请注意，您需要重启vsftpd服务以使更改生效。</p><h4 id="Linux-etc-passwd下面的一行：reda-x-1000-1000-reda-home-reda-bin-bash-每个字段的含义是什么？"><a href="#Linux-etc-passwd下面的一行：reda-x-1000-1000-reda-home-reda-bin-bash-每个字段的含义是什么？" class="headerlink" title="Linux &#x2F;etc&#x2F;passwd下面的一行：reda:x:1000:1000:reda:&#x2F;home&#x2F;reda:&#x2F;bin&#x2F;bash 每个字段的含义是什么？"></a>Linux &#x2F;etc&#x2F;passwd下面的一行：reda:x:1000:1000:reda:&#x2F;home&#x2F;reda:&#x2F;bin&#x2F;bash 每个字段的含义是什么？</h4><p>这行是一个 Linux 系统中 &#x2F;etc&#x2F;passwd 文件中的一行，它描述了一个用户账户的信息。这个文件中包含了所有的用户账户，每个用户占据一行，每行由七个字段组成，字段之间使用冒号分隔。以下是每个字段的含义：</p><ol><li>用户名：在这个例子中，用户名为 reda，这个字段是用来标识用户的唯一标识符。</li><li>密码占位符：在这个例子中，这个字段是 “x”，它表示用户的密码存储在 &#x2F;etc&#x2F;shadow 文件中，而不是明文存储在 &#x2F;etc&#x2F;passwd 文件中。</li><li>用户ID：在这个例子中，这个字段是 “1000”，它是用户的数字标识符。Linux 中每个用户都有一个唯一的数字 ID。</li><li>组ID：在这个例子中，这个字段也是 “1000”，它是用户所属的主要组的数字标识符。</li><li>用户描述：在这个例子中，这个字段是 “reda”，它是一个简短的用户描述，通常是用户的全名或其他有用的信息。</li><li>家目录：在这个例子中，这个字段是 “&#x2F;home&#x2F;reda”，它是用户的主目录，这是用户登录后所在的默认目录。</li><li>登录Shell：在这个例子中，这个字段是 “&#x2F;bin&#x2F;bash”，它是用户登录后默认使用的 Shell 程序。</li></ol><h4 id="root-useradd-u-6000-G-usergrp-user1-root-grep-user1-etc-passwd-user1-x-6000-6001-home-user1-bin-bash-上面我usergrp的组ID是6000，为什么user1-x-6000-6001-home-user1-bin-bash显示的组ID是6001"><a href="#root-useradd-u-6000-G-usergrp-user1-root-grep-user1-etc-passwd-user1-x-6000-6001-home-user1-bin-bash-上面我usergrp的组ID是6000，为什么user1-x-6000-6001-home-user1-bin-bash显示的组ID是6001" class="headerlink" title="[root &#x2F;:]#useradd -u 6000 -G usergrp user1 [root &#x2F;:]#grep user1 &#x2F;etc&#x2F;passwd user1:x:6000:6001::&#x2F;home&#x2F;user1:&#x2F;bin&#x2F;bash 上面我usergrp的组ID是6000，为什么user1:x:6000:6001::&#x2F;home&#x2F;user1:&#x2F;bin&#x2F;bash显示的组ID是6001"></a>[root &#x2F;:]#useradd -u 6000 -G usergrp user1 [root &#x2F;:]#grep user1 &#x2F;etc&#x2F;passwd user1:x:6000:6001::&#x2F;home&#x2F;user1:&#x2F;bin&#x2F;bash 上面我usergrp的组ID是6000，为什么user1:x:6000:6001::&#x2F;home&#x2F;user1:&#x2F;bin&#x2F;bash显示的组ID是6001</h4><p>在Linux系统中，每个用户都有一个主要组和一个或多个辅助组。在你的命令中，通过 <strong>-G</strong> 选项将用户添加到 <strong>usergrp</strong> 组的辅助组中，但是你没有指定一个主要组，因此 <strong>user1</strong> 用户会默认分配一个新的组ID。这个新的组ID是根据系统中已经存在的组ID的最大值来自动分配的，通常会选择当前最大的组ID加1。<br>在这个例子中，<strong>user1</strong> 的组ID是 <strong>6001</strong>，因为在你执行命令时，<strong>6001</strong> 是系统中最大的组ID。当你使用 <strong>grep</strong> 命令在 <strong>&#x2F;etc&#x2F;passwd</strong> 文件中查找 <strong>user1</strong> 时，你看到的就是这个自动分配的组ID。如果你想将 <strong>user1</strong> 分配到 <strong>usergrp</strong> 组作为主要组，可以使用 <strong>-g</strong> 选项指定主要组，如下所示：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">yamlCopy</span> code<span class="hljs-attribute">useradd</span> -u <span class="hljs-number">6000</span> -g usergrp -G usergrp user1</code></pre></div><p>这将使 <strong>usergrp</strong> 成为 <strong>user1</strong> 的主要组，并将 <strong>user1</strong> 添加到 <strong>usergrp</strong> 组的辅助组中。在 <strong>&#x2F;etc&#x2F;passwd</strong> 文件中，你会看到类似这样的行：</p><div class="code-wrapper"><pre><code class="hljs ruby">rubyCopy code<span class="hljs-symbol">user1:</span><span class="hljs-symbol">x:</span><span class="hljs-number">6000</span><span class="hljs-symbol">:</span><span class="hljs-number">6000</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:/home/user1</span><span class="hljs-symbol">:/bin/bash</span></code></pre></div><p>在这种情况下，<strong>user1</strong> 的组ID是 <strong>6000</strong>，与主要组的组ID相同，<strong>usergrp</strong> 组的组ID也是 <strong>6000</strong>。</p><h4 id="Linux什么是初始组什么是附属组？"><a href="#Linux什么是初始组什么是附属组？" class="headerlink" title="Linux什么是初始组什么是附属组？"></a>Linux什么是初始组什么是附属组？</h4><p>在Linux系统中，每个用户都有一个主要组和一个或多个附属组。</p><ul><li>初始组：是指当用户登录到系统时，用户所属的主要组。用户创建文件或目录时，默认情况下，该文件或目录将分配给用户的初始组。</li><li>附属组：是指用户所属的除了初始组之外的其他组。用户可以通过将其添加到附属组中，从而获得其他组的访问权限。用户在登录时，会同时成为自己的初始组和所有附属组的成员。</li></ul><p>可以通过<strong>id</strong>命令查看当前用户的初始组和附属组。输出结果中，<strong>uid</strong>表示用户ID，<strong>gid</strong>表示初始组ID，<strong>groups</strong>列出了用户所属的所有附属组。<br>例如：</p><div class="code-wrapper"><pre><code class="hljs gcode">scssCopy code$ id uid=<span class="hljs-number">1000</span><span class="hljs-comment">(username)</span> gid=<span class="hljs-number">1000</span><span class="hljs-comment">(username)</span> groups=<span class="hljs-number">1000</span><span class="hljs-comment">(username)</span>,<span class="hljs-number">4</span><span class="hljs-comment">(adm)</span>,<span class="hljs-number">27</span><span class="hljs-comment">(sudo)</span>,<span class="hljs-number">30</span><span class="hljs-comment">(dip)</span>,<span class="hljs-number">46</span><span class="hljs-comment">(plugdev)</span>,<span class="hljs-number">116</span><span class="hljs-comment">(lpadmin)</span>,<span class="hljs-number">126</span><span class="hljs-comment">(sambashare)</span></code></pre></div><p>在这个例子中，初始组ID是 <strong>1000</strong>，而用户还属于其他6个附属组，包括 <strong>adm</strong>、<strong>sudo</strong>、<strong>dip</strong>、<strong>plugdev</strong>、<strong>lpadmin</strong>和<strong>sambashare</strong>。</p><h4 id="Linux如何实现多命令？"><a href="#Linux如何实现多命令？" class="headerlink" title="Linux如何实现多命令？"></a>Linux如何实现多命令？</h4><p>在Linux中，可以使用以下方法实现多个命令的组合执行：</p><ol><li><p>分号 (<strong>;</strong>)：用于将多个命令分开，顺序执行这些命令。例如：</p><div class="code-wrapper"><pre><code class="hljs gcode">Copy codecomma<span class="hljs-symbol">nd1</span> ; comma<span class="hljs-symbol">nd2</span> ; comma<span class="hljs-symbol">nd3</span></code></pre></div><p>这将依次执行 <strong>command1</strong>、<strong>command2</strong>和<strong>command3</strong>。</p></li><li><p>双引号 (<strong>“</strong>) 或 单引号 (<strong>‘</strong>)：将多个命令用双引号或单引号括起来，形成一个命令组，然后将其作为一个单独的命令执行。例如：</p><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">pythonCopy</span> <span class="hljs-meta">code</span><span class="hljs-string">&quot;command1 &amp;&amp; command2 &amp;&amp; command3&quot;</span></code></pre></div><p>这将执行 <strong>command1</strong>，如果它成功，继续执行 <strong>command2</strong>，然后执行 <strong>command3</strong>。</p></li><li><p>逻辑运算符：使用逻辑运算符 <strong>&amp;&amp;</strong> 和 <strong>||</strong> 来实现条件执行。例如：</p><div class="code-wrapper"><pre><code class="hljs gcode">Copy codecomma<span class="hljs-symbol">nd1</span> &amp;&amp; comma<span class="hljs-symbol">nd2</span> || comma<span class="hljs-symbol">nd3</span></code></pre></div><p>这将执行 <strong>command1</strong>，如果它成功，继续执行 <strong>command2</strong>，如果 <strong>command2</strong> 失败，执行 <strong>command3</strong>。</p></li><li><p>管道 (<strong>|</strong>)：将一个命令的输出传递给另一个命令。例如：</p><div class="code-wrapper"><pre><code class="hljs gcode">Copy codecomma<span class="hljs-symbol">nd1</span> | comma<span class="hljs-symbol">nd2</span></code></pre></div><p>这将将 <strong>command1</strong> 的输出作为输入传递给 <strong>command2</strong>，并执行 <strong>command2</strong>。<br>以上方法可以组合使用，形成更加复杂的命令组合。例如：</p><div class="code-wrapper"><pre><code class="hljs gcode">Copy codecomma<span class="hljs-symbol">nd1</span> ; comma<span class="hljs-symbol">nd2</span> | comma<span class="hljs-symbol">nd3</span> &amp;&amp; comma<span class="hljs-symbol">nd4</span></code></pre></div><p>这将依次执行 <strong>command1</strong>，然后将 <strong>command2</strong> 的输出传递给 <strong>command3</strong> 执行，如果 <strong>command3</strong> 成功，继续执行 <strong>command4</strong>。</p></li></ol><h4 id="如何将一个用户加入到多个附属组？"><a href="#如何将一个用户加入到多个附属组？" class="headerlink" title="如何将一个用户加入到多个附属组？"></a>如何将一个用户加入到多个附属组？</h4><p>在Linux中，可以使用以下命令将一个用户添加到多个附属组：</p><div class="code-wrapper"><pre><code class="hljs smali">sudo usermod -G group1,group2,group3 username</code></pre></div><p>其中，<strong>group1,group2,group3</strong>是要添加用户的附属组列表，用逗号分隔。**-G<strong>选项表示将用户添加到附属组中而不删除原有附属组。<br>例如，如果要将用户 <strong>alice</strong> 添加到附属组 <strong>group1</strong>、</strong>group2** 和 <strong>group3</strong> 中，可以使用以下命令：</p><div class="code-wrapper"><pre><code class="hljs smali">sudo usermod -G group1,group2,group3 alice</code></pre></div><p>添加完成后，需要注销并重新登录用户 <strong>alice</strong>，以使更改生效。可以使用 <strong>id</strong> 命令检查用户的附属组是否已更新。例如：</p><div class="code-wrapper"><pre><code class="hljs applescript"><span class="hljs-built_in">id</span> alice</code></pre></div><p>这将显示用户 <strong>alice</strong> 的 UID、主要组 ID 和附属组列表。</p><h4 id="如果一个用户有多个附属组，那么它在-etc-passwd的文件显示是什么样的？"><a href="#如果一个用户有多个附属组，那么它在-etc-passwd的文件显示是什么样的？" class="headerlink" title="如果一个用户有多个附属组，那么它在&#x2F;etc&#x2F;passwd的文件显示是什么样的？"></a>如果一个用户有多个附属组，那么它在&#x2F;etc&#x2F;passwd的文件显示是什么样的？</h4><p>在 <strong>&#x2F;etc&#x2F;passwd</strong> 文件中，一个用户只有一个主要组，即 GID (Group ID) 与 <strong>&#x2F;etc&#x2F;group</strong> 中的一项相匹配的组。但是，一个用户可以属于多个附属组，这些信息存储在 <strong>&#x2F;etc&#x2F;group</strong> 文件中。<br>例如，如果一个用户 <strong>bob</strong> 属于附属组 <strong>group1</strong> 和 <strong>group2</strong>，那么在 <strong>&#x2F;etc&#x2F;passwd</strong> 文件中，他的条目应该只有一个主要组 ID，与 <strong>&#x2F;etc&#x2F;group</strong> 中的一项相对应：</p><div class="code-wrapper"><pre><code class="hljs elixir">rubyCopy code<span class="hljs-symbol">bob:</span><span class="hljs-symbol">x:</span><span class="hljs-number">1000</span><span class="hljs-symbol">:</span><span class="hljs-number">1000</span><span class="hljs-symbol">:Bob</span><span class="hljs-symbol">:/home/bob</span><span class="hljs-symbol">:/bin/bash</span></code></pre></div><p>这里的 <strong>1000</strong> 是 <strong>bob</strong> 的主要组 ID。<br>而在 <strong>&#x2F;etc&#x2F;group</strong> 文件中，<strong>group1</strong> 和 <strong>group2</strong> 的条目将包含 <strong>bob</strong> 的用户名，如下所示：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">makefileCopy</span> code<span class="hljs-attribute">group1</span>:x:<span class="hljs-number">1001</span>:bob group2:x:<span class="hljs-number">1002</span>:bob</code></pre></div><p>这里的 <strong>bob</strong> 表示用户 <strong>bob</strong> 是这两个组的成员。<br>因此，如果想查看一个用户属于哪些组，可以查看 <strong>&#x2F;etc&#x2F;group</strong> 文件或者运行 <strong>id</strong> 命令。</p><h4 id="新增user3用户，不为用户建立并初始化宿主目录，用户不允许登陆到系统的shell"><a href="#新增user3用户，不为用户建立并初始化宿主目录，用户不允许登陆到系统的shell" class="headerlink" title="新增user3用户，不为用户建立并初始化宿主目录，用户不允许登陆到系统的shell"></a>新增user3用户，不为用户建立并初始化宿主目录，用户不允许登陆到系统的shell</h4><p>可以使用 <strong>useradd</strong> 命令创建一个新用户，并指定不为用户建立宿主目录，并将其 shell 设置为 <strong>&#x2F;usr&#x2F;sbin&#x2F;nologin</strong>，从而禁止用户登录到系统的 shell。<br>下面是创建名为 <strong>user3</strong> 的用户，不为其创建宿主目录，并将其 shell 设置为 <strong>&#x2F;usr&#x2F;sbin&#x2F;nologin</strong> 的命令：</p><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">bashCopy</span> <span class="hljs-meta">code</span><span class="hljs-symbol">sudo</span> useradd -M -s /usr/sbin/nologin user3</code></pre></div><p>其中，**-M** 选项表示不为用户创建宿主目录，**-s** 选项表示将用户的 shell 设置为 <strong>&#x2F;usr&#x2F;sbin&#x2F;nologin</strong>，即禁止用户登录到系统的 shell。<br>如果需要为用户设置密码，可以使用 <strong>passwd</strong> 命令，例如：</p><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">Copy</span> <span class="hljs-meta">code</span><span class="hljs-symbol">sudo</span> passwd user3</code></pre></div><p>输入密码并确认即可为 <strong>user3</strong> 用户设置密码。</p><h4 id="user3-x-6002-6003-home-user3-usr-sbin-nologin-user3的宿主目录是哪个？"><a href="#user3-x-6002-6003-home-user3-usr-sbin-nologin-user3的宿主目录是哪个？" class="headerlink" title="user3:x:6002:6003::&#x2F;home&#x2F;user3:&#x2F;usr&#x2F;sbin&#x2F;nologin user3的宿主目录是哪个？"></a>user3:x:6002:6003::&#x2F;home&#x2F;user3:&#x2F;usr&#x2F;sbin&#x2F;nologin user3的宿主目录是哪个？</h4><p>根据给出的 <strong>&#x2F;etc&#x2F;passwd</strong> 文件行：</p><div class="code-wrapper"><pre><code class="hljs ruby">rubyCopy code<span class="hljs-symbol">user3:</span><span class="hljs-symbol">x:</span><span class="hljs-number">6002</span><span class="hljs-symbol">:</span><span class="hljs-number">6003</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:/home/user3</span><span class="hljs-symbol">:/usr/sbin/nologin</span></code></pre></div><p>可以看到 <strong>user3</strong> 用户的宿主目录是 <strong>&#x2F;home&#x2F;user3</strong>。但是需要注意的是，在创建该用户时使用了 <strong>-M</strong> 选项，该选项指示不为用户创建宿主目录，因此实际上并没有为 <strong>user3</strong> 用户创建 <strong>&#x2F;home&#x2F;user3</strong> 目录。此时，如果尝试登录到 <strong>user3</strong> 用户，会提示 “Cannot access your home directory” 错误。</p><h4 id="su-user3-This-account-is-currently-not-available"><a href="#su-user3-This-account-is-currently-not-available" class="headerlink" title="su user3 This account is currently not available."></a>su user3 This account is currently not available.</h4><p>当尝试使用 <strong>su</strong> 命令切换到 <strong>user3</strong> 用户时，如果提示 “This account is currently not available.”，这通常意味着该用户的 shell 被设置为 <strong>&#x2F;usr&#x2F;sbin&#x2F;nologin</strong> 或 <strong>&#x2F;bin&#x2F;false</strong>，即禁止该用户登录系统 shell。<br>这通常是出于安全考虑，例如禁止特定用户登录系统 shell，只允许其通过 SSH 访问远程主机。<br>如果需要允许 <strong>user3</strong> 用户登录到系统 shell，可以使用 <strong>usermod</strong> 命令修改其 shell 设置，例如：</p><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">pythonCopy</span> <span class="hljs-meta">code</span><span class="hljs-symbol">sudo</span> usermod -s /bin/bash user3</code></pre></div><p>该命令将 <strong>user3</strong> 用户的 shell 设置为 <strong>&#x2F;bin&#x2F;bash</strong>，从而允许其登录到系统 shell。</p><h4 id="设置user1用户，在下次登录时必须强制更改密码。-设置user2用户，密码30天必须更改密码，密码在2017年10月10日过期。"><a href="#设置user1用户，在下次登录时必须强制更改密码。-设置user2用户，密码30天必须更改密码，密码在2017年10月10日过期。" class="headerlink" title="设置user1用户，在下次登录时必须强制更改密码。 设置user2用户，密码30天必须更改密码，密码在2017年10月10日过期。"></a>设置user1用户，在下次登录时必须强制更改密码。 设置user2用户，密码30天必须更改密码，密码在2017年10月10日过期。</h4><ol><li>设置user1用户，在下次登录时必须强制更改密码。</li></ol><p>可以使用 <strong>chage</strong> 命令为 <strong>user1</strong> 用户设置强制更改密码的选项，例如：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Copy</span> code<span class="hljs-attribute">sudo</span> chage -d <span class="hljs-number">0</span> user1</code></pre></div><p>该命令中，**-d 0** 选项表示设置用户的上次密码更改时间为 1970 年 1 月 1 日，即下次用户登录时必须更改密码。</p><ol><li>设置user2用户，密码30天必须更改密码，密码在2017年10月10日过期。</li></ol><p>可以使用 <strong>chage</strong> 命令为 <strong>user2</strong> 用户设置密码过期时间和最大密码使用期限，例如：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">yamlCopy</span> code<span class="hljs-attribute">sudo</span> chage -m <span class="hljs-number">0</span> -M <span class="hljs-number">30</span> -E <span class="hljs-number">2017</span>-<span class="hljs-number">10</span>-<span class="hljs-number">10</span> user2</code></pre></div><p>该命令中，**-m 0** 选项表示最小密码使用期限为 0 天，即用户随时可以更改密码；**-M 30** 选项表示最大密码使用期限为 30 天，即用户必须在 30 天内更改密码；**-E 2017-10-10** 选项表示密码过期时间为 2017 年 10 月 10 日。<br>这样，<strong>user2</strong> 用户在登录时会提示更改密码，并且在 30 天后密码过期。如果在 2017 年 10 月 10 日之后还未更改密码，则无法登录到该用户账户。</p><h4 id="如何更改用户密码信息"><a href="#如何更改用户密码信息" class="headerlink" title="如何更改用户密码信息"></a>如何更改用户密码信息</h4><p>在 Linux 系统中，为了保护用户密码的安全性，用户密码通常以加密形式存储在系统中，因此不能直接查看用户的密码信息。但是，可以通过以下几种方式查看与密码相关的信息：</p><ol><li><p>查看用户密码最后更改时间：可以使用 <strong>chage</strong> 命令查看用户密码的最后更改时间，例如：</p><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">Copy</span> <span class="hljs-meta">code</span><span class="hljs-symbol">sudo</span> chage -l username</code></pre></div><p>其中 <strong>username</strong> 是要查看信息的用户名，该命令会列出用户的密码相关信息，包括密码最后更改时间。</p></li><li><p>查看系统密码策略：可以使用 <strong>pam_tally2</strong> 命令查看系统的密码策略，例如：</p><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">Copy</span> <span class="hljs-meta">code</span><span class="hljs-symbol">sudo</span> pam_tally2</code></pre></div><p>该命令会列出系统中所有用户的密码策略，包括密码最大使用期限、密码最小使用期限等信息。</p></li><li><p>查看密码文件：可以查看 <strong>&#x2F;etc&#x2F;passwd</strong> 文件中的密码字段，但是该字段通常是加密后的密码字符串，无法直接查看。可以查看 <strong>&#x2F;etc&#x2F;shadow</strong> 文件中的密码信息，该文件中包含了系统中所有用户的密码相关信息，包括加密后的密码字符串、密码最后更改时间等。但是需要注意的是，该文件通常只能由超级用户访问，且修改该文件可能会导致系统无法正常工作，因此在操作时需要非常谨慎。可以使用以下命令查看 <strong>&#x2F;etc&#x2F;shadow</strong> 文件：</p><div class="code-wrapper"><pre><code class="hljs bash">bashCopy codesudo <span class="hljs-built_in">cat</span> /etc/shadow</code></pre></div></li></ol><h4 id="etc-passwd-文件中的密码字段个字段的含义"><a href="#etc-passwd-文件中的密码字段个字段的含义" class="headerlink" title="&#x2F;etc&#x2F;passwd 文件中的密码字段个字段的含义"></a>&#x2F;etc&#x2F;passwd 文件中的密码字段个字段的含义</h4><p>在 Linux 系统中， <strong>&#x2F;etc&#x2F;passwd</strong> 文件是用于存储系统中所有用户的账户信息的文件。该文件的每一行对应一个用户账户，由多个字段组成，其中包括一个密码字段。每个字段的含义如下：</p><ol><li>用户名字段：该字段包含用户的登录名，通常由小写字母、数字和特殊符号组成。</li><li>密码字段：该字段在早期的 Linux 系统中用于存储用户密码，但现在该字段通常被设置为一个占位符或者为空，实际的密码信息存储在 <strong>&#x2F;etc&#x2F;shadow</strong> 文件中。如果该字段以 <strong>x</strong> 开头，则表示密码信息存储在 <strong>&#x2F;etc&#x2F;shadow</strong> 文件中；如果该字段以 <strong>!</strong> 开头，则表示该用户账户已被禁用。</li><li>用户 ID（UID）字段：该字段包含用户的唯一标识符，通常为一个整数值。在 Linux 系统中，每个用户都有一个唯一的 UID，用于区分不同的用户。</li><li>组 ID（GID）字段：该字段包含用户所属的主组的唯一标识符，通常为一个整数值。在 Linux 系统中，每个用户都有一个唯一的主组，用于确定用户的基本权限。</li><li>用户信息字段：该字段包含用户的详细信息，例如真实姓名、联系方式等。</li><li>宿主目录（Home directory）字段：该字段包含用户的主目录的路径。用户在登录系统时，会自动进入该目录。</li><li>登录 shell 字段：该字段包含用户登录系统时使用的 shell 程序的路径。在 Linux 系统中，有多种不同的 shell 可以选择，例如 Bash、Zsh 等。</li></ol><h4 id="如何查看用户密码设置信息？"><a href="#如何查看用户密码设置信息？" class="headerlink" title="如何查看用户密码设置信息？"></a>如何查看用户密码设置信息？</h4><p>在 Linux 系统中，可以使用以下命令查看用户的密码设置信息：</p><ul><li>**passwd -S <username>**：该命令可以查看指定用户的密码设置信息，包括密码状态、最近修改密码的日期、密码过期时间等。</li></ul><p>例如，要查看用户名为 <strong>user1</strong> 的用户的密码设置信息，可以使用以下命令：</p><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">Copy</span> <span class="hljs-meta">code</span><span class="hljs-symbol">passwd</span> -S user1</code></pre></div><p>该命令将输出类似以下内容的信息：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">cssCopy</span> code<span class="hljs-attribute">user1</span> P <span class="hljs-number">03</span>/<span class="hljs-number">18</span>/<span class="hljs-number">2023</span> <span class="hljs-number">0</span> <span class="hljs-number">99999</span> <span class="hljs-number">7</span> -<span class="hljs-number">1</span></code></pre></div><p>其中，各字段的含义如下：</p><ul><li>第一个字段：表示用户的用户名。</li><li>第二个字段：表示密码状态。<strong>P</strong> 表示该用户设置了密码，<strong>NP</strong> 表示该用户没有设置密码，<strong>LK</strong> 表示该用户账户已被锁定。</li><li>第三个字段：表示最近一次修改密码的日期。</li><li>第四个字段：表示两次修改密码之间必须等待的最短时间，单位为天数。如果该字段的值为 <strong>0</strong>，则表示不设置等待时间。</li><li>第五个字段：表示两次修改密码之间必须等待的最长时间，单位为天数。如果该字段的值为 <strong>99999</strong>，则表示密码不会过期。</li><li>第六个字段：表示密码过期前的警告期，单位为天数。在密码过期前，系统会给用户发送警告通知。</li><li>第七个字段：表示密码过期后的宽限期，单位为天数。如果该字段的值为 <strong>-1</strong>，则表示密码过期后，用户账户将被锁定，无法登录系统。</li></ul><p>如果要查看所有用户的密码设置信息，可以使用以下命令：</p><div class="code-wrapper"><pre><code class="hljs css">pythonCopy <span class="hljs-selector-tag">code</span>sudo chage -l <span class="hljs-attr">--all-users</span></code></pre></div><p>该命令将输出系统中所有用户的密码设置信息。</p><h4 id="如何查看用户密码具体过期时间"><a href="#如何查看用户密码具体过期时间" class="headerlink" title="如何查看用户密码具体过期时间"></a>如何查看用户密码具体过期时间</h4><p>在 Linux 系统中，可以使用以下命令查看用户密码的具体过期时间：</p><ul><li>**chage -l <username>**：该命令可以查看指定用户的密码过期时间，以及密码最近一次修改的时间、密码失效时间等。</li></ul><p>例如，要查看用户名为 <strong>user1</strong> 的用户的密码具体过期时间，可以使用以下命令：</p><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">Copy</span> <span class="hljs-meta">code</span><span class="hljs-symbol">chage</span> -l user1</code></pre></div><p>该命令将输出类似以下内容的信息：</p><div class="code-wrapper"><pre><code class="hljs pgsql">yamlCopy codeLast <span class="hljs-keyword">password</span> change                                 : Mar <span class="hljs-number">18</span>, <span class="hljs-number">2023</span> <span class="hljs-keyword">Password</span> expires                                     : never <span class="hljs-keyword">Password</span> inactive                                    : never Account expires                                      : never Minimum number <span class="hljs-keyword">of</span> days <span class="hljs-keyword">between</span> <span class="hljs-keyword">password</span> change       : <span class="hljs-number">0</span> Maximum number <span class="hljs-keyword">of</span> days <span class="hljs-keyword">between</span> <span class="hljs-keyword">password</span> change       : <span class="hljs-number">99999</span> Number <span class="hljs-keyword">of</span> days <span class="hljs-keyword">of</span> <span class="hljs-built_in">warning</span> <span class="hljs-keyword">before</span> <span class="hljs-keyword">password</span> expires    : <span class="hljs-number">7</span></code></pre></div><p>其中，各字段的含义如下：</p><ul><li><strong>Last password change</strong>：表示密码最近一次修改的时间。</li><li><strong>Password expires</strong>：表示密码的过期时间。如果该字段的值为 <strong>never</strong>，则表示密码永不过期。</li><li><strong>Password inactive</strong>：表示密码失效的时间。如果该字段的值为 <strong>never</strong>，则表示密码永不失效。</li><li><strong>Account expires</strong>：表示用户账户的过期时间。如果该字段的值为 <strong>never</strong>，则表示账户永不过期。</li><li><strong>Minimum number of days between password change</strong>：表示两次修改密码之间必须等待的最短时间，单位为天数。如果该字段的值为 <strong>0</strong>，则表示不设置等待时间。</li><li><strong>Maximum number of days between password change</strong>：表示两次修改密码之间必须等待的最长时间，单位为天数。如果该字段的值为 <strong>99999</strong>，则表示密码不会过期。</li><li><strong>Number of days of warning before password expires</strong>：表示密码过期前的警告期，单位为天数。在密码过期前，系统会给用户发送警告通知。</li></ul><p>如果要查看所有用户的密码过期时间，可以使用以下命令：</p><div class="code-wrapper"><pre><code class="hljs css">pythonCopy <span class="hljs-selector-tag">code</span>sudo chage -l <span class="hljs-attr">--all-users</span></code></pre></div><p>该命令将输出系统中所有用户的密码过期时间信息。<br><a href="https://zhuanlan.zhihu.com/p/97931380">U盘格式化后容量变小了怎么恢复</a></p><h4 id="yum源的配置和安装"><a href="#yum源的配置和安装" class="headerlink" title="yum源的配置和安装:"></a>yum源的配置和安装:</h4><p><a href="https://blog.csdn.net/KingveyLee/article/details/114981036">RedHat7配置本地yum源（超详细过程）_redhat7 yum源配置_KingveyLee的博客-CSDN博客</a><br><a href="https://www.cnblogs.com/gaoBlog/p/10944138.html">深入理解yum工作原理 - 豁然高 - 博客园</a><br><a href="https://blog.csdn.net/guohaosun/article/details/81481848">YUM工作原理及使用_$releaserver_Galaxy_hao的博客-CSDN博客</a><br><a href="https://blog.51cto.com/silian20122/1791447">刨根问底：什么是yum源,yum的工作原理又是什么_51CTO博客_linux的yum源是什么</a><br><a href="https://blog.csdn.net/CenCenNA/article/details/102748845">linux配置本地yum源及网络yum源详细步骤_CEnCenNA的博客-CSDN博客</a><br><a href="https://blog.csdn.net/KingveyLee/article/details/114981036">RedHat7配置本地yum源（超详细过程）_redhat7 yum源配置_KingveyLee的博客-CSDN博客</a><br><a href="https://blog.csdn.net/qq_43596002/article/details/104567426">红帽上安装wireshark_雕沙的博客-CSDN博客</a></p><h2 id="磁盘创建问题："><a href="#磁盘创建问题：" class="headerlink" title="磁盘创建问题："></a>磁盘创建问题：</h2><h4 id="mke2fs-1-42-9-28-Dec-2013"><a href="#mke2fs-1-42-9-28-Dec-2013" class="headerlink" title="mke2fs 1.42.9 (28-Dec-2013)"></a>mke2fs 1.42.9 (28-Dec-2013)</h4><p>&#x2F;dev&#x2F;sdc1 is apparently in use by the system; will not make a 文件系统 here!<br>这个错误信息通常是因为你正在尝试创建一个文件系统，但该设备当前正在被系统使用，因此无法进行操作。这可能是因为该设备已经被挂载或正在被其他进程使用。<br>要解决这个问题，你可以尝试以下步骤：</p><ol><li>确认设备是否已经挂载：可以使用命令 mount 来查看设备是否已经挂载。如果设备已经挂载，请卸载设备并重试。</li><li>检查是否有其他进程使用该设备：有时，其他进程可能会占用该设备，例如正在进行备份或复制操作。可以使用命令 lsof &#x2F;dev&#x2F;sdc1 来查看哪些进程正在使用该设备。如果有进程使用该设备，请停止该进程并重试。</li><li>确认设备是否正确连接：有时设备连接不良会导致系统无法正确识别设备。可以尝试重新连接设备并重试。</li><li>如果上述方法都无法解决问题，可以尝试重启系统并重试创建文件系统的操作。</li></ol><p>总之，要解决设备正在被系统使用的问题，需要先确认设备是否已经被挂载或被其他进程使用，并采取相应的措施来停止这些进程或卸载设备。如果问题仍然存在，可以尝试重新连接设备或重启系统。</p><h4 id="echo-“-dev-sdb1-swap-ext3-defaults-0-0-“-etc-fstab"><a href="#echo-“-dev-sdb1-swap-ext3-defaults-0-0-“-etc-fstab" class="headerlink" title="echo “ &#x2F;dev&#x2F;sdb1 &#x2F;swap ext3 defaults 0 0 “ &gt; &#x2F;etc&#x2F;fstab"></a>echo “ &#x2F;dev&#x2F;sdb1 &#x2F;swap ext3 defaults 0 0 “ &gt; &#x2F;etc&#x2F;fstab</h4><p>为什么这样操作后原理的&#x2F;etc&#x2F;fstab的信息没了<br>这个命令会将一行文本（&#x2F;dev&#x2F;sdb1 &#x2F;swap ext3 defaults 0 0）写入 &#x2F;etc&#x2F;fstab 文件中，覆盖原有的内容。如果你只写入了这一行文本，则 &#x2F;etc&#x2F;fstab 文件的其他内容将被清除掉，只剩下这一行新的内容。<br>如果你想保留 &#x2F;etc&#x2F;fstab 文件中原有的内容，可以使用重定向运算符 &gt;&gt; 来将新的内容追加到文件末尾，而不是覆盖原有的内容。例如，可以使用以下命令向 &#x2F;etc&#x2F;fstab 文件中添加新的一行内容：<br>echo “&#x2F;dev&#x2F;sdb1 &#x2F;swap ext3 defaults 0 0” &gt;&gt; &#x2F;etc&#x2F;fstab<br>这将在 &#x2F;etc&#x2F;fstab 文件的末尾添加一行新的内容，而不会覆盖原有的内容。</p><h4 id="dev-sdb1-UUID-”f812f15f-e1c1-4c5c-a02e-503fadcf3873”-SEC-TYPE-”ext2”-TYPE-”ext3”"><a href="#dev-sdb1-UUID-”f812f15f-e1c1-4c5c-a02e-503fadcf3873”-SEC-TYPE-”ext2”-TYPE-”ext3”" class="headerlink" title="&#x2F;dev&#x2F;sdb1: UUID&#x3D;”f812f15f-e1c1-4c5c-a02e-503fadcf3873” SEC_TYPE&#x3D;”ext2” TYPE&#x3D;”ext3”"></a>&#x2F;dev&#x2F;sdb1: UUID&#x3D;”f812f15f-e1c1-4c5c-a02e-503fadcf3873” SEC_TYPE&#x3D;”ext2” TYPE&#x3D;”ext3”</h4><p>其中的type和sec_type是什么？<br>TYPE 和 SEC_TYPE 都是文件系统类型的标识符，用于指定文件系统的类型和安全属性。</p><ul><li>TYPE 标识符指定文件系统的类型，表示文件系统的格式和结构。在你的例子中，TYPE&#x3D;”ext3” 表示该设备使用的是 ext3 文件系统。常见的文件系统类型还包括 ext4、NTFS、FAT32 等。</li><li>SEC_TYPE 标识符指定文件系统的安全属性，表示文件系统的安全级别和访问控制。在你的例子中，SEC_TYPE&#x3D;”ext2” 表示该设备的安全属性与 ext2 文件系统相同。SEC_TYPE 通常用于启用文件系统的 SELinux 安全策略。</li></ul><p>这些标识符通常由操作系统自动识别和设置，但也可以手动指定。在 &#x2F;etc&#x2F;fstab 中，你可以使用 type 和 sec_type 选项来指定文件系统的类型和安全属性。例如：<br>&#x2F;dev&#x2F;sdb1 &#x2F;mnt&#x2F;data ext4 defaults,type&#x3D;ext4,sec_type&#x3D;ext2 0 0<br>这将将 &#x2F;dev&#x2F;sdb1 设备挂载到 &#x2F;mnt&#x2F;data 目录，使用 ext4 文件系统，并指定类型为 ext4，安全属性为 ext2。<br>dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;swap&#x2F;back.swap bs&#x3D;1M count&#x3D;256这句话是什么意思<br>这句命令的作用是在文件系统中创建一个大小为256MB的文件 &#x2F;swap&#x2F;back.swap，其中内容全部由0填充，相当于创建了一个空文件。<br>具体解释如下：</p><ul><li>dd 命令是一个复制命令，可以用来复制文件、设备或者数据流。</li><li>if&#x3D;&#x2F;dev&#x2F;zero 表示输入文件是 &#x2F;dev&#x2F;zero，这是一个特殊的文件，它会不断输出0。</li><li>of&#x3D;&#x2F;swap&#x2F;back.swap 表示输出文件是 &#x2F;swap&#x2F;back.swap，即创建一个名为 back.swap 的文件。</li><li>bs&#x3D;1M 表示每次读写的块大小为1MB，这样可以提高数据传输速度。</li><li>count&#x3D;256 表示复制256个块，即总共复制256MB的数据。因为每个块的大小为1MB，所以总文件大小为256MB。</li></ul><p>因此，这句命令的作用是在 &#x2F;swap 目录下创建一个名为 back.swap 的文件，大小为256MB，用于作为交换分区。这个文件的内容全部由0填充，因为交换分区是用来存储内存中暂时不需要的数据，所以里面的内容可以是任意的。<br>&#x2F;swap&#x2F;back.swap none swap sw 0 0这个是什么意思<br>这是一条用于描述交换分区的 &#x2F;etc&#x2F;fstab 文件中的行。具体解释如下：</p><ul><li>&#x2F;swap&#x2F;back.swap 表示交换分区所在的文件路径。</li><li>none 表示该交换分区没有对应的磁盘分区，而是使用一个文件来模拟交换分区。</li><li>swap 表示文件系统类型为交换分区。</li><li>sw 表示挂载选项，其中 sw 表示启用交换分区。</li><li>0 和 0 是用于指定文件系统检查时的参数，分别表示在启动时不检查该文件系统，并且不进行备份。</li></ul><p>这条 &#x2F;etc&#x2F;fstab 文件中的行的作用是将 &#x2F;swap&#x2F;back.swap 文件作为交换分区挂载到系统中，并在系统启动时自动加载该交换分区。</p><h4 id="如何查看交换分区"><a href="#如何查看交换分区" class="headerlink" title="如何查看交换分区"></a>如何查看交换分区</h4><p>你可以使用 swapon 命令来查看当前系统中已经启用的交换分区。具体操作如下：</p><ol><li>打开终端，在命令行中输入以下命令：swapon –show 这会列出系统中所有已经启用的交换分区的信息，包括文件名、类型、大小等。</li><li>如果你只想查看某一个交换分区的信息，可以在命令后面加上交换分区的路径，例如：swapon –show &#x2F;swap&#x2F;back.swap 这会仅显示名为 &#x2F;swap&#x2F;back.swap 的交换分区的信息。</li></ol><p>另外，你也可以使用 free 命令来查看系统的内存和交换分区使用情况。在终端中输入以下命令：<br>free -h<br>这会显示系统中的内存和交换分区的使用情况，包括已用、可用和总大小等信息。<br>&#x2F;dev&#x2F;sdb2 swap swap defaults 0 0什么意思这是 &#x2F;etc&#x2F;fstab 文件中一行用于定义交换分区的条目，具体解释如下：</p><ul><li>&#x2F;dev&#x2F;sdb2 表示交换分区所对应的磁盘设备或文件的路径。在这个例子中，交换分区对应的是 &#x2F;dev&#x2F;sdb2 设备。</li><li>swap 表示文件系统的类型为交换分区。</li><li>swap 表示挂载点的名称，也就是交换分区的标识符。</li><li>defaults 表示挂载选项，其中包含了一些默认的选项，比如读写权限、文件系统检查等。</li><li>0 和 0 是用于指定文件系统检查时的参数，分别表示在启动时不检查该文件系统，并且不进行备份。</li></ul><p>因此，这条条目的作用是将 &#x2F;dev&#x2F;sdb2 设备上的交换分区挂载到系统中，并在系统启动时自动加载该交换分区。<br>&#x2F;swap&#x2F;back.swap none swap sw 0 0那这个了？这是 &#x2F;etc&#x2F;fstab 文件中另一行用于定义交换分区的条目，具体解释如下：</p><ul><li>&#x2F;swap&#x2F;back.swap 表示交换分区所对应的文件的路径。在这个例子中，交换分区对应的是 &#x2F;swap&#x2F;back.swap 文件。</li><li>none 表示该交换分区没有对应的磁盘分区，而是使用一个文件来模拟交换分区。</li><li>swap 表示文件系统的类型为交换分区。</li><li>sw 表示挂载选项，其中 sw 表示启用交换分区。</li><li>0 和 0 是用于指定文件系统检查时的参数，分别表示在启动时不检查该文件系统，并且不进行备份。</li></ul><p>因此，这条条目的作用是将 &#x2F;swap&#x2F;back.swap 文件作为交换分区挂载到系统中，并在系统启动时自动加载该交换分区。<br>&#x2F;dev&#x2F;sdb2 swap swap defaults 0 0写入&#x2F;etc&#x2F;fstab会马上生效吗？<br>sudo mount -a sudo swapon -a<br>在将交换分区的信息写入 &#x2F;etc&#x2F;fstab 文件后，需要手动执行以下命令才能使其生效：<br>这个命令会将 &#x2F;etc&#x2F;fstab 文件中定义的所有文件系统挂载到系统中。如果没有出现错误，那么交换分区就已经成功地挂载到了系统中。也可以使用以下命令单独挂载交换分区：<br>这个命令会启用 &#x2F;etc&#x2F;fstab 文件中定义的所有交换分区，包括新添加的交换分区。如果想要禁用某个交换分区，可以使用 swapoff 命令。<br>将网卡(eth0)配置成ip地址为192.168.1.13同时激活此网卡的命令是<br>sudo ifconfig eth0 192.168.1.13 up sudo ip addr add 192.168.1.13&#x2F;24 dev eth0 sudo ip link set eth0 up<br>可以使用以下命令将网卡 eth0 配置为 IP 地址为 192.168.1.13，并激活该网卡：<br>这个命令会使用 ifconfig 工具来配置网卡 eth0 的 IP 地址，将其设置为 192.168.1.13，并激活该网卡。如果 eth0 网卡已经被配置过 IP 地址，那么这个命令会更新该网卡的 IP 地址。<br>请注意，ifconfig 命令已经被弃用，建议使用 ip 命令来管理网络接口。使用 ip 命令来配置网卡 eth0 的 IP 地址和激活该网卡的命令如下：<br>这个命令会使用 ip 命令来配置网卡 eth0 的 IP 地址，将其设置为 192.168.1.13，并激活该网卡。如果 eth0 网卡已经被配置过 IP 地址，那么这个命令会更新该网卡的 IP 地址。<br><a href="https://blog.csdn.net/weixin_53946852/article/details/125542849">Linux进程和进程优先级（top+ps+kill+renice+df+free命令）_linux查看进程优先级命令_爱敲代码的三毛的博客-CSDN博客</a></p><p><a href="https://www.cnblogs.com/yxd1308243944/p/13920434.html">Linux Sever简单笔记（第十堂课）之linux下的任务计划及相关的命令 - 我杨晓东太难了 - 博客园</a><br> <a href="https://www.jianshu.com/p/ea566208dca6">FTP server vsftpd配置文件详解</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux期末复习</title>
    <link href="/2024/01/26/Linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0_/"/>
    <url>/2024/01/26/Linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0_/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1680405197847-4493cbce-372d-4000-8163-0143fc323272.png#averageHue=%23fefefe&clientId=ue6ba8912-0f7b-4&from=paste&height=246&id=u62741752&originHeight=308&originWidth=595&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17380&status=done&style=none&taskId=u9e2fa2ed-0c2c-49e2-a227-faa5b30379b&title=&width=476" alt="image.png"></p><p>在Linux系统中，通常需要创建以下两个分区：</p><ol><li>根分区（&#x2F;）：根分区是Linux系统中最重要的分区，它包含了系统的所有文件和目录。在安装Linux系统时，必须创建根分区。通常建议将根分区单独分配一个分区，以便在系统出现问题时更容易维护和恢复。</li><li>交换分区（swap）：交换分区是Linux系统用于虚拟内存的一种机制，用于在物理内存不足时暂时存储内存中的数据。在安装Linux系统时，也需要创建交换分区。通常，交换分区的大小应该是物理内存大小的2倍，但是如果系统内存非常大（例如64GB或更多），则可以考虑将交换分区的大小设置为物理内存的1.5倍或1倍。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1680405258020-b831a7d6-6158-4bf3-ab49-5baf63988013.png#averageHue=%23fefdfd&clientId=ue6ba8912-0f7b-4&from=paste&height=268&id=u77579e28&originHeight=335&originWidth=587&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17644&status=done&style=none&taskId=udc8037ad-84c4-468f-8167-6feca899250&title=&width=469.6" alt="image.png"><br>-r:删除用户时删除用户的主目录及其中所有内容，如果不加这个选项，只删除此用户账号<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1680405285077-0eddd97f-3c42-4a08-ba45-e6b69707be4d.png#averageHue=%23fefefe&clientId=ue6ba8912-0f7b-4&from=paste&height=250&id=ua8fe7a11&originHeight=312&originWidth=835&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22413&status=done&style=none&taskId=u7304fba1-7ce3-47f1-98f4-e6cb00a996e&title=&width=668" alt="image.png"><br>在Red Hat公司发布的Linux版本中，用户密码通常存储在&#x2F;etc&#x2F;shadow文件中。要启用用户登录验证，管理员需要修改PAM脚本来指定身份验证模块和参数，以便将用户输入的密码与&#x2F;etc&#x2F;shadow中存储的密码进行比较。如果密码匹配，则用户可以成功登录系统，否则登录将被拒绝。因此，在Red Hat公司发布的Linux版本中，要使得用户登录验证，需要修改&#x2F;etc&#x2F;shadow文件中的用户密码以及&#x2F;etc&#x2F;pam.d目录下相应的PAM脚本。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1680405573885-3b80a874-8799-4e40-9079-f4207c9a7895.png#averageHue=%23fefefe&clientId=ue6ba8912-0f7b-4&from=paste&height=260&id=u320f6706&originHeight=325&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14537&status=done&style=none&taskId=u11a5a5f7-48ec-4b60-80f5-ba2a390ead1&title=&width=443.2" alt="image.png"><br>ps -all 并不是一个合法的Linux命令，正确的参数应该是 ps -a 或 ps -l。ps aux 命令的输出格式更加详细，包括了进程所属的用户、占用的CPU和内存资源等信息。其中，a 参数表示显示所有用户的进程，u 参数表示显示详细的进程信息，x 参数表示显示没有控制终端的进程。ps -ef<br>该命令可以列出当前所有正在运行的进程信息，包括进程ID（PID）、进程所属用户、进程占用的CPU和内存资源等。其中，-e参数表示列出所有进程，-f参数表示显示详细的进程信息。也可以使用ps aux命令来获得相同的结果。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1680405685456-91abf9ce-3cc7-4801-abfb-50b3b959f91a.png#averageHue=%23fefefe&clientId=ue6ba8912-0f7b-4&from=paste&height=254&id=u0f1d4508&originHeight=317&originWidth=490&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16950&status=done&style=none&taskId=u84bd2fd6-6b70-4c78-abf2-5318f2b0e21&title=&width=392" alt="image.png"><br>在Linux中，&#x2F;etc&#x2F;init.d&#x2F;crond 是一个服务脚本文件，用于管理系统的定时任务服务 cron。该服务脚本文件通常用于启动、停止、重启或重新加载 cron 服务。<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1680405726079-43d4e0c9-a37c-40ae-8a52-a038f9367fc6.png#averageHue=%23fefefe&clientId=ue6ba8912-0f7b-4&from=paste&height=255&id=u1ec6ecb0&originHeight=319&originWidth=778&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17823&status=done&style=none&taskId=uee0e8b8c-ea83-4983-a441-e5c2fa87694&title=&width=622.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1680405876288-9508fe5e-b114-4a8e-95d6-0800d9c3b88e.png#averageHue=%23fefefe&clientId=ue6ba8912-0f7b-4&from=paste&height=285&id=u7bb74d0d&originHeight=356&originWidth=1098&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19875&status=done&style=none&taskId=u021cf1e1-cdaa-4e61-912d-2aca7df7270&title=&width=878.4" alt="image.png"><br>more是最早的文本文件查看器之一，它按页显示文本，每次显示一页，当文本超过一页时，它会在底部显示一个提示符，等待用户按空格键或 Enter 键来继续向下查看。more命令只能向前翻页，不能向后翻页或搜索文本。<br>相比之下，less则提供了更多的交互性和功能。它也按页显示文本，但可以向前或向后翻页，搜索文本、高亮显示匹配的文本、跳转到指定行等等。与more相比，less不需要在显示文本时等待用户按键，而是直接响应用户的命令。<br>另外，less还具有一些其他的优点。由于它只加载当前显示的文本，所以可以快速打开大型文本文件，而且占用的系统资源更少。此外，less还支持鼠标操作和自定义配置文件等功能。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1680405902143-fac7ff7b-0760-4df8-948d-d29507c2af41.png#averageHue=%23fefefd&clientId=ue6ba8912-0f7b-4&from=paste&height=266&id=ufb957c27&originHeight=333&originWidth=1036&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23633&status=done&style=none&taskId=uf8cb43ca-230f-4b4b-908a-6f97e4ce6b4&title=&width=828.8" alt="image.png"><br>&#x2F;etc&#x2F;inittab是一个文件，用于定义系统的运行级别和默认的进程配置。运行级别指的是系统启动时所处的状态，比如单用户模式、多用户模式等。在&#x2F;etc&#x2F;inittab文件中，可以设置系统启动时需要运行哪些进程，以及针对不同的运行级别需要加载哪些服务。<br>&#x2F;etc&#x2F;inittab文件的格式为：<br>id:runlevels:action:process<br>其中，各字段的含义如下：</p><ul><li>id：进程的标识符，通常为一个字母或数字；</li><li>runlevels：进程所在的运行级别，可以是单个运行级别，也可以是多个运行级别的组合；</li><li>action：指定该进程在运行级别发生变化时的动作，可以是 respawn（进程死亡后自动重启）、wait（等待进程完成再开始下一步操作）、once（只运行一次）等；</li><li>process：需要运行的进程或命令。</li><li>在较早版本的Linux系统中，默认启动是字符页面，可以通过修改&#x2F;etc&#x2F;inittab文件来实现。具体方法如下：</li></ul><ol><li>使用root用户登录Linux系统。</li><li>打开&#x2F;etc&#x2F;inittab文件。可以使用命令行文本编辑器（如vi或nano）或图形化文本编辑器（如gedit或kate）打开该文件。</li><li>找到以”initdefault”开头的行，并将其后面的数字改为3。例如，将以下行：</li></ol><p>id:5:initdefault:<br>修改为：<br>id:3:initdefault:<br>这样，当系统启动时，它会默认进入运行级别3，即字符界面模式。</p><ol><li>保存并退出&#x2F;etc&#x2F;inittab文件。</li><li>重新启动Linux系统。此时，系统应该会进入字符界面模式。</li></ol><p>需要注意的是，在一些新的Linux发行版中，如Ubuntu等，已经使用了systemd等新的init系统，&#x2F;etc&#x2F;inittab文件可能已经被弃用或不再使用。在这种情况下，需要使用相应的工具来实现类似的设置，例如使用systemctl命令来设置默认运行级别。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1680405937479-0a03b72f-4500-4762-b975-fbefebba9ee9.png#averageHue=%23fefefe&clientId=ue6ba8912-0f7b-4&from=paste&height=254&id=uae7e9a5c&originHeight=317&originWidth=913&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17328&status=done&style=none&taskId=u3766c290-d89e-4b21-b5bc-46fd86876ca&title=&width=730.4" alt="image.png"><br>cd命令切换目录，没有指定目录就切换到用户的主目录；cd <del>是一个命令，用于将当前工作目录切换到当前用户的主目录（也称为home目录）。</del>符号代表当前用户的主目录，因此cd ~命令实际上等同于cd $HOME命令，其中$HOME是一个环境变量，它表示当前用户的主目录的路径。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1680406062981-f56eb5c7-683d-45ab-9773-12573b6a5f81.png#averageHue=%23fefefd&clientId=ue6ba8912-0f7b-4&from=paste&height=250&id=u67137237&originHeight=312&originWidth=990&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27993&status=done&style=none&taskId=ub82b447d-4ca4-4a70-bf25-03d1939e096&title=&width=792" alt="image.png"><br>这是一个在Linux系统中使用RPM包管理器安装软件包的命令，其中各选项的含义如下：</p><ul><li>rpm：RPM包管理器命令；</li><li>-ivh：选项，表示安装并显示详细的安装过程（i），同时显示进度和进一步的提示信息（v），以及在安装过程中遇到错误时停止安装（h）；</li><li>–nodeps：选项，表示忽略软件包依赖性检查，即不检查安装软件包所依赖的其他包是否已经安装。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1680406177590-2323b842-4cd0-4ba4-8221-33acb3ed348f.png#averageHue=%23fefefe&clientId=ue6ba8912-0f7b-4&from=paste&height=358&id=u9dae7b74&originHeight=447&originWidth=784&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16796&status=done&style=none&taskId=u6f96ac2e-b154-4749-84ef-a46e12e63e7&title=&width=627.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1680406310748-17ef5e92-c041-4c6b-bd2a-b8174c2424e1.png#averageHue=%23fefefd&clientId=ue6ba8912-0f7b-4&from=paste&height=264&id=u346a2b1e&originHeight=330&originWidth=1052&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24276&status=done&style=none&taskId=uccdceed3-1ad7-4313-853a-ff4b0d90d4d&title=&width=841.6" alt="image.png"><br>chmod用a表示所有用户<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1680406972167-bee58e58-6f69-45a5-8273-fb86b363c18d.png#averageHue=%23fefefe&clientId=ue6ba8912-0f7b-4&from=paste&height=173&id=u617aa331&originHeight=216&originWidth=955&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14782&status=done&style=none&taskId=ue2e1faa7-ab35-4a8a-86ca-f3e44fbbf9c&title=&width=764" alt="image.png"><br>文件系统是一种用于组织和管理文件的结构化方式<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1680407047179-c160c65c-1261-453f-aea9-ce135e1cb8bd.png#averageHue=%23fefefe&clientId=ue6ba8912-0f7b-4&from=paste&height=161&id=u8771a80c&originHeight=201&originWidth=672&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10450&status=done&style=none&taskId=u1f0ce2d7-de3d-47ea-8849-e41896bce45&title=&width=537.6" alt="image.png"><br>在Linux系统中，&#x2F;boot分区用于存储引导加载程序和内核映像等启动相关文件。由于引导加载程序需要在系统启动时读取&#x2F;boot分区中的文件，因此&#x2F;boot分区需要使用标准的分区格式，而不能使用LVM（逻辑卷管理器）格式。<br>LVM是Linux系统中一种用于管理磁盘分区的技术，它可以将多个物理磁盘或分区组合成一个逻辑卷，并对其进行管理。使用LVM可以方便地对存储空间进行扩展、快速备份和恢复等操作，<strong>但是LVM本身需要在系统启动之后才能启用，需要加载相应的内核模块和LVM元数据等信息</strong>。因此，如果将&#x2F;boot分区格式化为LVM格式，就会导致引导加载程序无法在系统启动之前读取&#x2F;boot分区中的文件，从而无法正常启动系统。<br>因此，在Linux系统中，&#x2F;boot分区必须使用标准的分区格式，不能使用LVM格式。而其他分区（如根分区、数据分区等）可以选择使用LVM格式，以方便管理和扩展存储空间。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1680407276327-4c5c2608-6ae3-4b04-a1c3-85f775caf5f7.png#averageHue=%23fefefe&clientId=ue6ba8912-0f7b-4&from=paste&height=250&id=ub6aaca4c&originHeight=313&originWidth=490&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13122&status=done&style=none&taskId=uf56a49c3-8ed0-4bad-88c9-69901c39ab3&title=&width=392" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1680407353185-12a6e250-5db6-4958-a2b4-464f789ccfab.png#averageHue=%23fefefe&clientId=ue6ba8912-0f7b-4&from=paste&height=261&id=ud14dab86&originHeight=326&originWidth=567&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13743&status=done&style=none&taskId=ue024306b-4565-4aff-8eb3-a72f814dc68&title=&width=453.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1680407428753-8c9a58f6-993a-4955-9f09-3bdd9d087250.png#averageHue=%23fefefd&clientId=ue6ba8912-0f7b-4&from=paste&height=258&id=ua7e930a3&originHeight=322&originWidth=612&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17297&status=done&style=none&taskId=u48cf95fd-ea22-4a3e-a705-431a6113bfe&title=&width=489.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1680407500973-97d92890-3ae1-42bb-b151-f2edd654d65d.png#averageHue=%23fefefd&clientId=ue6ba8912-0f7b-4&from=paste&height=269&id=u9b4c0c10&originHeight=336&originWidth=933&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19640&status=done&style=none&taskId=ud25b03e1-8df0-44f8-bcfa-a820060cef6&title=&width=746.4" alt="image.png"></p><ul><li>bash-3.1-16.1.i386.rpm：要安装的软件包文件名和路径。其中，bash表示软件包名称，3.1表示软件包版本号，16.1表示软件包的发布号，i386表示软件包适用的处理器架构（这里为Intel x86架构），.rpm表示软件包的格式。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1680407628126-af9f7c9e-49a0-4865-9ab0-91db58d35ddf.png#averageHue=%23fefefe&clientId=ue6ba8912-0f7b-4&from=paste&height=266&id=u3353f2fa&originHeight=333&originWidth=630&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19513&status=done&style=none&taskId=ue9f108ad-1fc5-4215-a163-a02d9404853&title=&width=504" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1680407647795-01fc92a9-71cd-4df6-ab35-ddd70fdfeafa.png#averageHue=%23fefefe&clientId=ue6ba8912-0f7b-4&from=paste&height=168&id=u62fec6e1&originHeight=210&originWidth=847&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11878&status=done&style=none&taskId=u8d92b5fc-66b9-4842-b1f8-0dbab17c98f&title=&width=677.6" alt="image.png"><br>tail命令默认显示文件的<strong>最后</strong>10行内容，<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1680407679803-24e13b98-0ea7-4171-a324-7210dbb34fbb.png#averageHue=%23fefefd&clientId=ue6ba8912-0f7b-4&from=paste&height=158&id=ueb2ff25e&originHeight=198&originWidth=827&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12771&status=done&style=none&taskId=ua2dcbd4f-9918-4387-81f9-21a62bb4b4b&title=&width=661.6" alt="image.png"><br>ls -l 命令通常无法显示隐藏文件，而ls -a可以。</p>]]></content>
    
    
    <categories>
      
      <category>课程作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Linux课程作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javaWeb</title>
    <link href="/2024/01/26/javaWeb%EF%BC%9A/"/>
    <url>/2024/01/26/javaWeb%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery:"></a>JQuery:</h2><h4 id="什么是JQuery："><a href="#什么是JQuery：" class="headerlink" title="什么是JQuery："></a>什么是JQuery：</h4><p>JQuery实际上就是对现有的JavaScript的一种扩展，它非常轻量级，压缩后大概32KB，它兼容于各种浏览器，这样就可以非常方便地添加适用于多种浏览器的特效。<a href="https://zhuanlan.zhihu.com/p/132561105">1</a><a href="https://zhuanlan.zhihu.com/p/132561105">2</a> 它是一个轻量级的”写的少，做的多”的JavaScript库<a href="https://www.runoob.com/jquery/jquery-intro.html">3</a></p><h4 id="helloworld示例"><a href="#helloworld示例" class="headerlink" title="helloworld示例:"></a>helloworld示例:</h4><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="hljs-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Insert title here<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-comment">&lt;!--src=&quot;../script/jquery-1.7.2.js&quot;是JQuery的路径--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../script/jquery-1.7.2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">   <span class="hljs-comment">//alert($)</span></span><span class="language-javascript">   <span class="hljs-comment">//这里的$是一个函数：function( selector, context ) &#123;</span></span><span class="language-javascript">   <span class="hljs-comment">//The jQuery object is actually just the init constructor &#x27;enhanced&#x27;</span></span><span class="language-javascript">   <span class="hljs-comment">//return new jQuery.fn.init( selector, context, rootjQuery );</span></span><span class="language-javascript">   <span class="hljs-comment">//&#125;</span></span><span class="language-javascript">   <span class="hljs-comment">//使用$()代替window.onload</span></span><span class="language-javascript">   $(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><span class="language-javascript">      <span class="hljs-comment">//使用选择器获取按钮对象，随后绑定单击响应函数</span></span><span class="language-javascript">      $(<span class="hljs-string">&quot;#btnId&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><span class="language-javascript">         <span class="hljs-comment">//弹出Hello</span></span><span class="language-javascript">         <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>);</span><span class="language-javascript">      &#125;);</span><span class="language-javascript">   &#125;);</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btnId&quot;</span>&gt;</span>SayHello<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id=""><a href="#" class="headerlink" title="$ :"></a>$ :</h4><h4 id="1jQuery函数-jQuery中-函数的7种用法汇总-jq-塞北狼烟的博客-CSDN博客"><a href="#1jQuery函数-jQuery中-函数的7种用法汇总-jq-塞北狼烟的博客-CSDN博客" class="headerlink" title="1jQuery函数.jQuery中$()函数的7种用法汇总_jq $()_塞北狼烟的博客-CSDN博客"></a>1jQuery函数.<a href="https://blog.csdn.net/qq_28775437/article/details/80321711">jQuery中$()函数的7种用法汇总_jq $()_塞北狼烟的博客-CSDN博客</a></h4><p><a href="https://blog.csdn.net/qq_28775437/article/details/80321711">在jQuery中，$是jQuery函数的别称。</a><a href="https://blog.csdn.net/qq_28775437/article/details/80321711">1</a><a href="https://blog.csdn.net/qq_28775437/article/details/80321711">它用于将任何DOM对象包裹成jQuery对象，接着你就被允许调用定义在jQuery对象上的多个不同方法。</a><a href="https://blog.csdn.net/qq_28775437/article/details/80321711">1</a><a href="https://blog.csdn.net/qq_28775437/article/details/80321711">你可以将一个选择器字符串传入$函数，它会返回一个包含所有匹配的DOM元素数组的jQuery对象。</a><a href="https://blog.csdn.net/qq_28775437/article/details/80321711">1</a><a href="https://blog.csdn.net/weixin_52255418/article/details/109631421">例如，$(document)就是选取整个文档对象。</a><a href="https://blog.csdn.net/weixin_52255418/article/details/109631421">2</a><br>传入参数为[HTML字符串]的时候，根据这个字符串创建元素节点对象；传入参数为[函数]时，在文档加载完成后执行这个节点对象。<br>注意：$（dom）当里面的参数是dom的时候，不用加引号。如果加了就会把其解析为选择器。当然如果不是dom对象（选择器，html元素）就加引号。</p><h4 id="浏览器对javascript的解析："><a href="#浏览器对javascript的解析：" class="headerlink" title="浏览器对javascript的解析："></a>浏览器对javascript的解析：</h4><p>浏览器解析HTML，CSS，JavaScript的原理大致如下：</p><ul><li>浏览器首先从服务器获取HTML文档，并将其分割成不同的标记（tokens）。</li><li>然后，浏览器将这些标记转换成节点（nodes），并构建一个表示文档结构的DOM树（Document Object Model）。</li><li>同时，浏览器也会获取CSS文件，并将其分割成不同的规则（rules）。</li><li>然后，浏览器将这些规则转换成节点，并构建一个表示样式信息的CSSOM树（CSS Object Model）。</li><li>接下来，浏览器将DOM树和CSSOM树结合起来，生成一个渲染树（render tree），这个树包含了每个可见元素的位置和样式。</li><li>最后，浏览器根据渲染树绘制（paint）页面，并显示给用户。</li><li>浏览器在解析HTML的过程中，如果遇到<script>标签，会暂停解析，并执行JavaScript代码，除非该标签有async或defer属性。</li><li>这是因为JavaScript代码可能会修改DOM树或CSSOM树，所以浏览器必须等待JavaScript执行完毕，才能继续解析HTML。</li><li>为了提高性能，建议将JavaScript代码放在页面的底部，或者使用async或defer属性来异步加载JavaScript代码。<a href="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work">1</a><a href="https://stackoverflow.com/questions/3326494/parsing-css-in-javascript-jquery">2</a><a href="https://medium.com/jspoint/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969">3</a></li><li>如果<script>为嵌入式，会阻塞DOM的构建，如果<script>里面是函数，则就把函数放在一边，根据其作用域来处理；如果不是函数就解析。这说明了，如果<script>里面只是全局函数（var,或者function声明的）那么这个<script>放在与其关联元素的上面和下面都ok,如果不是就就可能会导致<script>的操作会失效。</li></ul><p>例子：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-comment">&lt;!--script里面的内容是一个函数，这个函数与button元素关联，运行script时，会把这个函数单独放在一边，不会执行的。这个script放在button</span><span class="hljs-comment">的后面和前面都可以--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">   <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeText</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;myHeading&quot;</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;New Heading&quot;</span>;</span><span class="language-javascript"><span class="hljs-comment">//是获取一个元素然后在把这个元素修改了，就是先删除然后在添加</span></span><span class="language-javascript">  &#125;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myHeading&quot;</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;changeText()&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;../script/jquery-1.7.2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>body span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>body span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>body span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>wrap span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>wrap span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>wrap span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!--script的必须在后边，因为这个script里面的不全是函数，只是一个jquery类型的类数组变量，在前面无法对上面的html进行渲染；当然如果scrip里面对上面元素的渲染是在函数里面的，就不用担心了；解析器会在--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    $(<span class="hljs-string">&#x27;span&#x27;</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;background-color&#x27;</span>,<span class="hljs-string">&#x27;red&#x27;</span>);<span class="hljs-comment">//所有的span都会变红</span></span><span class="language-javascript">    <span class="hljs-comment">// $(&#x27;span&#x27;,&#x27;.wrap&#x27;).css(&#x27;background-color&#x27;,&#x27;red&#x27;);//只有.wrap中的span会变红</span></span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs xquery"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span></span><span class="language-xml">  </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;../script/jquery-1.7.2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml">    /*    $(&#x27;</span><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>11111<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span></span><span class="language-xml">&#x27;).appendTo(&#x27;body&#x27;);//11111会显示在helloworld的前面，是因为，在解析的时候上面已经解析了body元素，</span><span class="language-xml">        //这句话的意思是把</span><span class="language-xml"><span class="language-javascript">&lt;div&gt;元素添加到body元素的后面，也就是把div当中body的子节点</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 多标签嵌套*/</span></span></span><span class="language-javascript"><span class="language-xml">    $(<span class="hljs-string">&#x27;</span></span></span><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span></span><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>dfsg<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span></span></span><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span></span><span class="language-xml">&#x27;).appendTo(&#x27;h1&#x27;);//只会显示helloworld；放在h1元素后面就可以正常显示了</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>helloworld<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre></div><p><a href="https://api.jquery.com/append/">1</a><a href="https://www.bold.ne.jp/engineer-club/jquery-append">2</a><a href="https://www.tutorialspoint.com/What-is-the-difference-between-append-and-appendTo-in-jQuery">3</a><a href="http://w3schools.cn/faq/how-to-move-an-element-into-another-element-using-jquery.asp">4</a><a href="https://api.jquery.com/appendTo/">5</a><a href="https://www.w3school.com.cn/jquery/manipulation_appendto.asp">6</a>，appendTo是jQuery的一个方法，它可以将一个元素或内容追加到另一个元素的结尾（仍然在内部）。</p><ul><li>例如，$(‘<div><span>dfsg</span></div>’).appendTo(‘body’)这句代码的意思是，将一个包含<span>dfsg</span>的<div>元素追加到<body>元素的最后。</li><li>appendTo方法的参数可以是一个选择器，一个元素，一个HTML字符串，一个元素数组，或者一个jQuery对象，它们都表示要追加到的目标元素。</li><li>appendTo方法和append方法执行的任务相同，不同之处在于：内容和选择器的位置，以及append方法能够使用函数来附加内容。</li></ul><h4 id="jQuery-html-props-："><a href="#jQuery-html-props-：" class="headerlink" title="jQuery(html,props)："></a>jQuery(html,props)：</h4><p><a href="https://www.educba.com/jquery-prop/">1</a><a href="https://www.educba.com/jquery-prop/">2</a><a href="https://www.w3schools.com/jquery/html_prop.asp">3</a><a href="https://api.jquery.com/prop/">4</a><a href="https://www.runoob.com/jquery/html-prop.html">5</a>，jQuery(html,props)是一个jQuery的构造函数，它可以创建一个包含指定HTML字符串的jQuery对象，并为其设置一些属性。</p><ul><li>例如，jQuery(‘<div></div>’,{id:‘mydiv’,text:‘Hello World’})这句代码的意思是，创建一个包含<div></div>的jQuery对象，并为其设置id属性为’mydiv’，text属性为’Hello World’。</li><li>jQuery(html,props)构造函数的第一个参数html可以是一个HTML字符串，一个元素，一个元素数组，或者一个jQuery对象，它们都表示要创建的jQuery对象的内容。</li><li>jQuery(html,props)构造函数的第二个参数props可以是一个对象，它包含一些属性名和属性值的键值对，它们表示要设置的jQuery对象的属性。属性名可以是任何有效的HTML属性，也可以是一些特殊的属性，如text,html,val,css,data等。属性值可以是一个字符串，一个数字，一个布尔值，或者一个函数，它们表示要设置的属性的值。</li></ul><h4 id="区分dom和·JQuery："><a href="#区分dom和·JQuery：" class="headerlink" title="区分dom和·JQuery："></a>区分dom和·JQuery：</h4><p>1.DOM对象和jQuery对象之间可以相互转换，例如，可以用$(dom)将一个DOM对象转换为一个jQuery对象，也可以用$(jquery)[0]或$(jquery).get(0)将一个jQuery对象转换为一个DOM对象。<br>2.javascript的类数组：<br> JavaScript的类数组（Array-like object）是指一个对象，它看起来像一个数组，因为它具有数字键和length属性，但它不具有数组的所有方法，如push()、pop()、slice()等。常见的类数组包括arguments对象、DOM集合（如document.getElementsByTagName()返回的结果）等。 类数组可以使用类似数组的语法来访问它们的元素，例如obj[0]、obj[1]等，也可以使用length属性来获取它们的长度。但是，它们不具有数组的所有方法，因此无法直接使用类似obj.push()、obj.pop()等数组方法。 类数组可以遍历，可以使用for循环或forEach()方法来遍历它们的元素。例如：<br>``function printArguments() {<br>  for (var i = 0; i < arguments.length; i++) {<br>    console.log(arguments[i]);<br>  }<br>}<br>printArguments(1, 2, 3); // 输出1, 2, 3<br>3.jquery是DOM（数组）+一些方法：<br>$id[0]通常表示从jQuery对象中获取原生DOM元素。当使用$()或jQuery()方法选择DOM元素时，返回的是jQuery对象，该对象封装了一个或多个DOM元素，并提供了一组易于使用的API来操作这些元素  。</p><h4 id="jQuery和DOM的转换："><a href="#jQuery和DOM的转换：" class="headerlink" title="jQuery和DOM的转换："></a>jQuery和DOM的转换：</h4><ul><li>使用数组下标：可以使用$()[index]或者$().get(index)方法，其中index表示需要获取的DOM元素在jQuery对象中的索引。例如，$("#myDiv")[0]将返回myDiv元素的DOM对象。</li><li>使用get()方法：可以使用$().get()方法获取包含jQuery对象中所有DOM元素的数组，然后根据索引获取具体的DOM元素。例如，$("#myDiv").get(0)将返回myDiv元素的DOM对象。</li></ul><ol><li>将DOM元素转换为jQuery对象 可以使用$()或jQuery()方法将DOM元素转换为jQuery对象。例如，$(document)将返回一个包含整个文档的jQuery对象，其中包含了document对象的所有方法和属性。 需要注意的是，将DOM元素转换为jQuery对象后，可以使用jQuery提供的一些方便的API来操作它们，但是不能使用原生的DOM方法或属性来操作它们，因为此时jQuery对象已经封装了DOM元素，并提供了一组不同于原生DOM的API。</li></ol><h4 id="jQuery选择器："><a href="#jQuery选择器：" class="headerlink" title="jQuery选择器："></a>jQuery选择器：</h4><p><a href="https://www.w3cschool.cn/jquery/jquery_selectors.html">jQuery 选择器_w3cschool</a></p><h6 id="jQuery中选择器有哪几种-js教程-PHP中文网"><a href="#jQuery中选择器有哪几种-js教程-PHP中文网" class="headerlink" title="jQuery中选择器有哪几种-js教程-PHP中文网"></a><a href="https://www.php.cn/js-tutorial-378052.html">jQuery中选择器有哪几种-js教程-PHP中文网</a></h6><h4 id="元素筛选方法："><a href="#元素筛选方法：" class="headerlink" title="元素筛选方法："></a>元素筛选方法：</h4><ul><li>:first：选择第一个匹配元素，例如$("div:first")将选择文档中第一个<div>元素。</li><li>:last：选择最后一个匹配元素，例如$("div:last")将选择文档中最后一个<div>元素。</li><li>:even：选择所有偶数位置的元素，例如$("div:even")将选择文档中所有偶数位置的<div>元素。</li><li>:odd：选择所有奇数位置的元素，例如$("div:odd")将选择文档中所有奇数位置的<div>元素。</li><li>:eq(index)：选择索引为index的匹配元素，例如$("div:eq(2)")将选择文档中第三个<div>元素。</li><li>:gt(index)：选择索引大于index的匹配元素，例如$("div:gt(2)")将选择文档中第三个以后的所有<div>元素。</li><li>:lt(index)：选择索引小于index的匹配元素，例如$("div:lt(2)")将选择文档中前两个<div>元素。</li><li>:not(selector)：选择不匹配selector的所有元素，例如$("div:not(.myClass)")将选择所有不具有myClass类名的<div>元素。</li><li>:has(selector)：选择包含匹配selector的元素，例如$("div:has(p)")将选择所有包含<p>元素的<div>元素。</li><li>:contains(text)：选择包含文本text的元素，例如$("div:contains('Hello')")将选择所有包含Hello文本的<div>元素。</li></ul><h4 id="jQuery属性操作："><a href="#jQuery属性操作：" class="headerlink" title="jQuery属性操作："></a>jQuery属性操作：</h4><ul><li>attr(name)：获取元素的属性值，例如$("img").attr("src")将获取所有<img>元素的src属性值。</li><li>attr(name, value)：设置元素的属性值，例如$("img").attr("src", "newSrc.jpg")将把所有<img>元素的src属性值设置为newSrc.jpg。</li><li>removeAttr(name)：删除元素的属性，例如$("img").removeAttr("src")将删除所有<img>元素的src属性。</li><li>prop(name)：获取元素的属性值，例如$("input").prop("checked")将获取所有<input>元素的checked属性值。</li><li>prop(name, value)：设置元素的属性值，例如$("input").prop("checked", true)将把所有<input>元素的checked属性设置为true。</li><li>removeProp(name)：删除元素的属性，例如$("input").removeProp("checked")将删除所有<input>元素的checked属性。</li><li>val()：获取元素的值，例如$("input").val()将获取所有<input>元素的值。</li><li>val(value)：设置元素的值，例如$("input").val("new value")将把所有<input>元素的值设置为new value。</li><li>addClass(className)：为元素添加类名，例如$("div").addClass("myClass")将为所有<div>元素添加myClass类名。</li><li>removeClass(className)：移除元素的类名，例如$("div").removeClass("myClass")将删除所有<div>元素的myClass类名。</li></ul><p><a href="https://www.yisu.com/zixun/688974.html#:~:text=jQuery%E7%9A%84%E6%93%8D%E4%BD%9C%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%201%20%E4%B8%80%E3%80%81%E6%93%8D%E4%BD%9C%E5%B1%9E%E6%80%A7%201%E3%80%81%E8%AF%BB%E5%8F%96%E5%B1%9E%E6%80%A7%E5%80%BC%EF%BC%9Aattr%20%28%E5%B1%9E%E6%80%A7%E5%90%8D%29%20%E5%8F%96%E5%BE%97%E4%BB%A5%E7%AC%AC%E4%B8%80%E5%8C%B9%E9%85%8D%E5%85%83%E7%B4%A0%E7%9A%84%E5%B1%9E%E6%80%A7%E5%80%BC%E3%80%82%20%E9%80%9A%E8%BF%87%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E6%96%B9%E4%BE%BF%E5%9C%B0%E4%BB%8E%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E5%85%83%E7%B4%A0%E4%B8%AD%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E7%9A%84%E5%80%BC%E3%80%82%20...,...%206%20%E5%85%AD%E3%80%81%E6%93%8D%E4%BD%9C%E5%80%BC--%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%E7%9A%84value%E5%B1%9E%E6%80%A7%201%E3%80%81%E8%8E%B7%E5%8F%96%E5%80%BC%EF%BC%9Aval%20%28%29%202%E3%80%81%E8%AE%BE%E7%BD%AE%E5%80%BC%EF%BC%9Aval%20%28%E5%80%BC%29%20">jQuery的操作属性有哪些 - 开发技术 - 亿速云</a><br><a href="https://www.w3school.com.cn/jquery/attributes_val.asp">jQuery 属性操作 - val() 方法</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1678163639573-5a19e485-ee20-4c37-bee9-a31dd592ec1b.png#averageHue=%23f1f0ef&clientId=u4cf51470-223a-4&from=paste&height=33&id=ud11414a0&originHeight=41&originWidth=332&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1797&status=done&style=none&taskId=u42693934-147e-41db-b88b-43e09e74e62&title=&width=265.6" alt="image.png">这个文本框的值属性不是text是val;<br>attre和prop有什么区别？<br><a href="https://www.cnblogs.com/lmjZone/p/8760232.html">https://www.cnblogs.com/lmjZone/p/8760232.html</a><br>attr()和prop()是jQuery中用于获取和设置元素属性的两个方法，它们的主要区别在于：</p><ul><li><p>attr()可以获取和设置元素的HTML属性，而prop()可以获取和设置元素的DOM属性。HTML属性是写在标签上的属性，而DOM属性是通过JavaScript对象获取和设置的属性。</p></li><li><p>attr()可以获取和设置非布尔类型属性的值，例如src、href、title等，而prop()只能获取和设置布尔类型属性的值，例如checked、disabled等。如果使用prop()来获取非布尔类型属性的值，返回的可能是undefined或默认值，而不是实际的属性值。</p></li><li><p>attr()可以用于操作自定义属性，例如data-*属性，而prop()不能操作自定义属性。</p></li><li><p>attr()返回的是属性值的字符串，而prop()返回的是属性值的实际类型，例如布尔、数字、对象等。 因此，在操作HTML属性时，应该使用attr()方法；在操作DOM属性时，应该使用prop()方法。如果不确定使用哪个方法，可以根据具体的属性类型和需求进行选择。</p></li><li><p>假设我们有一个<input>元素和一个<img>元素，它们的属性如下：</p><div class="code-wrapper"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> checked&gt; &lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;image.jpg&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;image&quot;</span>&gt;</code></pre></div><p>在这个例子中，type和checked属性是HTML属性，而src和alt属性是DOM属性。我们可以使用attr()和prop()方法来获取和设置这些属性的值。</p><div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-comment">// 获取input元素的type属性和checked属性</span> <span class="hljs-keyword">var</span> inputType = $(<span class="hljs-string">&quot;input&quot;</span>).attr(<span class="hljs-string">&quot;type&quot;</span>); <span class="hljs-comment">// &quot;checkbox&quot;</span> <span class="hljs-keyword">var</span> inputChecked = $(<span class="hljs-string">&quot;input&quot;</span>).attr(<span class="hljs-string">&quot;checked&quot;</span>); <span class="hljs-comment">// &quot;checked&quot;</span> <span class="hljs-comment">// 获取img元素的src属性和alt属性</span> <span class="hljs-keyword">var</span> imgSrc = $(<span class="hljs-string">&quot;img&quot;</span>).prop(<span class="hljs-string">&quot;src&quot;</span>); <span class="hljs-comment">// &quot;image.jpg&quot;</span> <span class="hljs-keyword">var</span> imgAlt = $(<span class="hljs-string">&quot;img&quot;</span>).prop(<span class="hljs-string">&quot;alt&quot;</span>); <span class="hljs-comment">// &quot;image&quot;</span> <span class="hljs-comment">// 修改input元素的checked属性</span> $(<span class="hljs-string">&quot;input&quot;</span>).attr(<span class="hljs-string">&quot;checked&quot;</span>, <span class="hljs-literal">false</span>); $(<span class="hljs-string">&quot;input&quot;</span>).prop(<span class="hljs-string">&quot;checked&quot;</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 修改img元素的src属性</span> $(<span class="hljs-string">&quot;img&quot;</span>).attr(<span class="hljs-string">&quot;src&quot;</span>, <span class="hljs-string">&quot;newImage.jpg&quot;</span>); $(<span class="hljs-string">&quot;img&quot;</span>).prop(<span class="hljs-string">&quot;src&quot;</span>, <span class="hljs-string">&quot;newImage.jpg&quot;</span>);</code></pre></div><p>在以上示例中，我们可以看到使用attr()方法可以获取和设置HTML属性的值，而使用prop()方法可以获取和设置DOM属性的值。注意在修改checked属性时，attr()方法需要传入false来取消选中，而prop()方法需要传入true来选中。<br> HTML属性和DOM属性有什么区别？  </p></li><li><p>定义位置不同：HTML属性是在HTML标签中定义的，而DOM属性是在JavaScript中通过元素对象访问的。</p></li><li><p>包含内容不同：HTML属性包含在HTML文档中，而DOM属性包含在内存中的JavaScript对象中。</p></li><li><p>赋值方式不同：HTML属性只能通过HTML文档进行赋值，而DOM属性可以通过JavaScript代码进行赋值。</p></li><li><p>可操作性不同：HTML属性是字符串类型，只能通过字符串的方式进行操作，而DOM属性可以是任何JavaScript数据类型，可以通过JavaScript代码进行更复杂的操作。 举个例子，假设有如下HTML代码：</p></li></ul><input type="text" value="hello">在这个例子中，type和value是HTML属性，可以通过getAttribute()方法获取它们的值，也可以通过setAttribute()方法修改它们的值。 当使用JavaScript创建一个<input>元素后，我们可以使用DOM属性来操作它：<div class="code-wrapper"><pre><code class="hljs abnf">var input <span class="hljs-operator">=</span> document.createElement(<span class="hljs-string">&quot;input&quot;</span>)<span class="hljs-comment">;</span> input.type <span class="hljs-operator">=</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-comment">;</span> input.value <span class="hljs-operator">=</span> <span class="hljs-string">&quot;world&quot;</span><span class="hljs-comment">;</span></code></pre></div>在这个例子中，type和value是DOM属性，可以直接使用JavaScript赋值语句来操作它们。 总之，HTML属性和DOM属性都是用于描述HTML元素的属性，但它们的定义位置、包含内容、赋值方式和可操作性都不同。<p>html（）方法是获取元素内部的html文档，不包括元素标记。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="hljs-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Insert title here<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../script/jquery-1.7.2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span>/**HTML代码/文本/值html([val|fn])    a.html()取出a的html值    a.html(val)  让a的html值变为valtext([val|fn])       a.text()取出a的text值    a.text(val)  让a的文本值变为valval([val|fn|arr]) a.val()  取出a的val值（input）   a.val(v)  设置a的value值为v 属性attr(name|pro|key,val|fn)   1、a.attr(&#x27;name&#x27;)取出a的name值   2、a.attr(&quot;name&quot;,&quot;username&quot;)把a的name值设置为username removeAttr(name) a.removeAttr(&#x27;class&#x27;)    移除a的class属性prop(name|pro|key,val|fn)1.6+ 1、a.prop(&#x27;id&#x27;)  取出a的id值   2、a.prop(&#x27;id&#x27;,&quot;bj&quot;)  设置a的id值为bjremoveProp(name)1.6+a.removeProp(&#x27;class&#x27;) 移除a的class属性 */<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span><span class="language-xml"><span class="language-handlebars">$(function()&#123;</span></span><span class="language-xml"><span class="language-handlebars">   $(&quot;#btn1&quot;).click(function()&#123;</span></span><span class="language-xml"><span class="language-handlebars">   //alert($(&quot;form&quot;).html());输出为</span></span><span class="language-xml"><span class="language-handlebars">      /*文本框:<span class="hljs-tag">&lt;<span class="hljs-name">input</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;abc&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span></span><span class="language-xml"><span class="language-handlebars">      多选框:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interest&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;篮球&quot;</span>&gt;</span></span></span><span class="language-xml"><span class="language-handlebars">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interest&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;zuqiu&quot;</span>&gt;</span></span></span><span class="language-xml"><span class="language-handlebars">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interest&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;乒乓&quot;</span>&gt;</span></span></span><span class="language-xml"><span class="language-handlebars">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interest&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;御马&quot;</span>&gt;</span>*/</span></span><span class="language-xml"><span class="language-handlebars">      //alert($(&quot;inout:first&quot;).html());//输出为空，因为input标签里面没有其他html元素。</span></span><span class="language-xml"><span class="language-handlebars">      $(&quot;input:first&quot;).val(111);//设置属性value值</span></span><span class="language-xml"><span class="language-handlebars">   &#125;)</span></span><span class="language-xml"><span class="language-handlebars">&#125;)</span></span><span class="language-xml"><span class="language-handlebars"></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn1&quot;</span>&gt;</span>获取文本框的name值<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;form1&quot;</span>&gt;</span>   文本框:<span class="hljs-tag">&lt;<span class="hljs-name">input</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;abc&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>   多选框:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interest&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;篮球&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interest&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;zuqiu&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interest&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;乒乓&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interest&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;御马&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="DOM增删改："><a href="#DOM增删改：" class="headerlink" title="DOM增删改："></a>DOM增删改：</h4><h6 id="常规操作："><a href="#常规操作：" class="headerlink" title="常规操作："></a>常规操作：</h6><div class="code-wrapper"><pre><code class="hljs isbl"><span class="hljs-comment">/**</span><span class="hljs-comment">文档处理</span><span class="hljs-comment">内部插入</span><span class="hljs-comment">appendTo(content)     a.appendTo(b);  把a加到b里面            添加到最后面</span><span class="hljs-comment">prependTo(content)    a.prependTo(b); 把a添加到b里面                添加到最前面</span><span class="hljs-comment">外部插入</span><span class="hljs-comment">insertAfter(content)   a.insertAfter(b);  把a插入到b的后面</span><span class="hljs-comment">insertBefore(content)  a.insertBefore(b); 把a插入到b的前面</span><span class="hljs-comment">替换</span><span class="hljs-comment">replaceWith(content|fn) a.replaceWith(b)  把a用b替换</span><span class="hljs-comment">replaceAll(selector)   a.replaceAll(b)      用a替换所有的b</span><span class="hljs-comment">删除</span><span class="hljs-comment">empty()             a.empty()   把a掏空，把a里面的所有元素都删除</span><span class="hljs-comment">remove([expr])           a.remove(b)  所有的a，是b的话就会删除 a.remove()删除a</span><span class="hljs-comment">改：</span><span class="hljs-comment">html()          a.html()获取a中的html代码</span><span class="hljs-comment">html(content)   a.html（）修改a中的html代码,也就是删除a中原有的html代码，用content代替。</span><span class="hljs-comment">*/</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs haxe">$(<span class="hljs-string">&quot;#btn02&quot;</span>).click(<span class="hljs-title function_"><span class="hljs-keyword">function</span></span>()&#123;<span class="hljs-keyword">var</span>  <span class="hljs-keyword">new</span><span class="hljs-type">Node</span> = document.createElement(<span class="hljs-string">&quot;li&quot;</span>);<span class="hljs-keyword">new</span><span class="hljs-type">Node</span>.textContent=<span class="hljs-string">&quot;广州&quot;</span>;$(<span class="hljs-keyword">new</span><span class="hljs-type">Node</span>).appendTo(<span class="hljs-string">&quot;#city&quot;</span>);<span class="hljs-comment">//注意这里的newnode,是创建的一个dom对象，$使用的时候不用加引号，</span>   <span class="hljs-comment">//添加的话就认为是选择器了</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs haxe">$(<span class="hljs-string">&quot;#btn03&quot;</span>).click(<span class="hljs-title function_"><span class="hljs-keyword">function</span></span>()&#123;   <span class="hljs-comment">//将&quot;广州&quot;节点插入到#bj前面[insertBefore()]</span>   <span class="hljs-comment">//前边.insertBefore(后边的)</span>   <span class="hljs-keyword">var</span>  <span class="hljs-keyword">new</span><span class="hljs-type">Node</span> = document.createElement(<span class="hljs-string">&quot;li&quot;</span>);   <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>.textContent=<span class="hljs-string">&quot;广州&quot;</span>;   $(<span class="hljs-keyword">new</span><span class="hljs-type">Node</span>).insertBefore(<span class="hljs-string">&quot;#bj&quot;</span>);<span class="hljs-comment">//注意这里的newnode,是创建的一个dom对象，$使用的时候不用加引号，</span>   <span class="hljs-comment">//添加的话就认为是选择器了</span>&#125;);</code></pre></div><h6 id="上面的代码var声明的变量是局部变量还是全局变量？"><a href="#上面的代码var声明的变量是局部变量还是全局变量？" class="headerlink" title="上面的代码var声明的变量是局部变量还是全局变量？"></a>上面的代码var声明的变量是局部变量还是全局变量？</h6><p>var声明的变量的作用域是它当前的执行上下文，也就是包含它的函数或者全局对象（如果在任何函数外声明）。如果给一个未声明的变量赋值，它会隐式地创建为一个全局变量（它会成为全局对象的一个属性）。<br>所以，在你给出的代码中，var声明的newNode是一个局部变量，它只在click函数内部可见。它不会污染全局作用域或者其他函数作用域。<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/var">1</a><a href="https://www.geeksforgeeks.org/difference-between-var-let-and-const-keywords-in-javascript/">2</a><a href="https://www.w3schools.com/js/js_scope.asp">3</a><br><a href="https://www.geeksforgeeks.org/difference-between-var-let-and-const-keywords-in-javascript/">Difference between var, let and const keywords in JavaScript - GeeksforGeeks</a></p><h6 id="在HTML中的body标签中var声明的变量是局部变量，还是全局变量？它的作用域是哪个？"><a href="#在HTML中的body标签中var声明的变量是局部变量，还是全局变量？它的作用域是哪个？" class="headerlink" title="在HTML中的body标签中var声明的变量是局部变量，还是全局变量？它的作用域是哪个？"></a>在HTML中的body标签中var声明的变量是局部变量，还是全局变量？它的作用域是哪个？</h6><p><a href="https://stackoverflow.com/questions/40858456/how-to-display-a-javascript-var-in-html-body">1</a><a href="https://www.w3schools.com/tags/tag_body.asp">2</a>，在HTML中的body标签中var声明的变量是全局变量，它的作用域是整个网页。这是因为JavaScript代码在浏览器中运行时，会被包含在一个全局对象（window）中，所以var声明的变量会成为window对象的属性。<br><a href="https://stackoverflow.com/questions/40858456/how-to-display-a-javascript-var-in-html-body">如果你想在HTML中显示一个JavaScript变量的值，你可以使用document.write()方法或者操作DOM元素</a><a href="https://stackoverflow.com/questions/40858456/how-to-display-a-javascript-var-in-html-body">1</a><br>总结：var声明的变量如果是在函数里面作用域就是函数，不是在函数里面作用域就是全局；let，const作用域是块。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">         <span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span> ()</span><span class="language-javascript">         &#123;</span><span class="language-javascript">             <span class="hljs-keyword">var</span>  num =<span class="hljs-number">10</span>;</span><span class="language-javascript">             <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(num);</span><span class="language-javascript">         &#125;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>    the value for number is:    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;a()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>//运行结果：the value for number is :10;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs xquery"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">var</span> number = <span class="hljs-number">123</span>;<span class="hljs-comment">//这个var声明的变量是全局变量，</span></span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 也就是整个窗口</span></span></span><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><span class="language-xml">    the value for number is:</span><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(number);</span></span><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span>//显示结果：the <span class="hljs-keyword">value</span> <span class="hljs-keyword">for</span><span class="hljs-built_in"> number</span> is: <span class="hljs-number">123</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs xquery"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">         number = <span class="hljs-number">123</span>;<span class="hljs-comment">//没有使用关键字默认为是全局变量，</span></span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 也就是整个窗口</span></span></span><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><span class="language-xml">    the value for number is:</span><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(number);</span></span><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span>//the <span class="hljs-keyword">value</span> <span class="hljs-keyword">for</span><span class="hljs-built_in"> number</span> is: <span class="hljs-number">123</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs xquery"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>) </span></span><span class="language-xquery">&#123;</span><span class="language-xquery">            <span class="hljs-keyword">let</span><span class="hljs-built_in"> number</span> = <span class="hljs-string">&quot;123&quot;</span>;//一个变量的作用域是它的上下文和其嵌套的上下文</span><span class="language-xquery">           <span class="hljs-built_in"> document</span>.getElementById(<span class="hljs-string">&quot;myText&quot;</span>).innerHTML =<span class="hljs-built_in"> number</span>;</span><span class="language-xquery">        &#125;</span><span class="language-xml"></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;myFunction()&quot;</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&quot;The value for number is: &quot; </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myText&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre></div><p>数据属性有：Configurable:重新定义设为false就不能修改内部特征了，使用方法修改会报错，特性，访问器属性；Enumerable:是否可通过for-in循环返回。Writeable:表示值是否可修改；Vaule:属性的值<br>2.可以通过：Object.defineProperty（传入2个参数的时候表示是对多个属性操作）方法修改属性的内部特征：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person =  &#123;    name : <span class="hljs-string">&quot;tom&quot;</span>,    age :<span class="hljs-number">10</span>  &#125;;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(person,<span class="hljs-string">&quot;name&quot;</span>,&#123;<span class="hljs-attr">writable</span>:<span class="hljs-literal">false</span>,<span class="hljs-attr">value</span>:<span class="hljs-string">&quot;66&quot;</span>&#125;);<span class="hljs-comment">//这个方法只能在对象外面使用</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);<span class="hljs-comment">//66</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">age</span>);<span class="hljs-comment">//10</span></code></pre></div><p>3.对象访问器属性的get和set属性，可以通过上面的方法修改；对象的添加是先配置set和get内部特征，然后在添加的：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">let</span> person =</span><span class="language-javascript">        &#123;</span><span class="language-javascript">          name : <span class="hljs-string">&quot;tom&quot;</span>,</span><span class="language-javascript">          age :<span class="hljs-number">10</span>,</span><span class="language-javascript">          <span class="hljs-attr">salary_</span>:<span class="hljs-number">500</span></span><span class="language-javascript">        &#125;;</span><span class="language-javascript">      person.<span class="hljs-property">salary_</span>=<span class="hljs-number">200</span>;</span><span class="language-javascript">      person.<span class="hljs-property">jod</span> = <span class="hljs-number">66</span>;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">jod</span>);<span class="hljs-comment">//66</span></span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person);<span class="hljs-comment">//没有的属性会创建一个属性</span></span><span class="language-javascript">      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(person,<span class="hljs-string">&quot;salary&quot;</span>,</span><span class="language-javascript">                            &#123;</span><span class="language-javascript">                              <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)</span><span class="language-javascript">                                &#123;</span><span class="language-javascript">                                  <span class="hljs-comment">// return person.salary_+100;//return是无法作运算的，但是可以返回一个数值</span></span><span class="language-javascript">                                  <span class="hljs-keyword">return</span> <span class="hljs-number">600</span>;<span class="hljs-comment">//这样设置后，表示这个属性是不可变的</span></span><span class="language-javascript">                                  <span class="hljs-comment">// return this.salary;会报错，salary属性是在set和get方式配置后才添加的。</span></span><span class="language-javascript"></span><span class="language-javascript">                                &#125;,</span><span class="language-javascript">                              set (newSalary)</span><span class="language-javascript">                                &#123;</span><span class="language-javascript">                                  <span class="hljs-variable language_">this</span>.<span class="hljs-property">salary_</span> = newSalary;<span class="hljs-comment">//这里的this的后面只能是person声明时候有的属性，this.报错</span></span><span class="language-javascript">                                &#125;</span><span class="language-javascript"></span><span class="language-javascript"></span><span class="language-javascript">                            &#125;);<span class="hljs-comment">//重新修改属性salary,get和set内部特征；如果重新设置没有的属性，</span></span><span class="language-javascript">      <span class="hljs-comment">// 会新添加这个属性，这个属性是先设置set和get方法，然后添加到person对象里面的</span></span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">salary_</span>);<span class="hljs-comment">//200</span></span><span class="language-javascript">      person.<span class="hljs-property">salary</span> = <span class="hljs-number">100</span>;<span class="hljs-comment">//</span></span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">salary_</span>);<span class="hljs-comment">//600，注意这里返回的是salary_</span></span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">salary</span>);<span class="hljs-comment">//100</span></span><span class="language-javascript"></span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="CSS样式："><a href="#CSS样式：" class="headerlink" title="CSS样式："></a>CSS样式：</h4><p><a href="https://api.jquery.com/css/">JQuery的css是指使用JQuery来操作CSS类或属性的方法。根据搜索结果</a><a href="https://api.jquery.com/css/">1</a>，JQuery提供了以下几种css方法：</p><ul><li>addClass() - 向被选元素添加一个或多个类</li><li>removeClass() - 从被选元素删除一个或多个类</li><li>toggleClass() - 对被选元素进行添加/删除类的切换操作</li><li>css() - 设置或返回样式属性</li></ul><h4 id="load事件："><a href="#load事件：" class="headerlink" title="load事件："></a>load事件：</h4><p>load事件是指当指定的元素或页面已加载时触发的事件。根据搜索结果<a href="https://bing.com/search?q=load%E4%BA%8B%E4%BB%B6">1</a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/load_event">，load事件适用于任何带有URL的元素（比如图像、脚本、框架、内联框架）以及window对象。</a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/load_event">2</a><a href="https://www.cnblogs.com/yesyes/p/15356343.html">但是，不同的浏览器可能对缓存的资源有不同的处理方式，导致load事件不一定会触发。</a><a href="https://bing.com/search?q=load%E4%BA%8B%E4%BB%B6">1</a><a href="https://www.cnblogs.com/yesyes/p/15356343.html">3</a></p><h4 id="function-和-window-onload-function-的区别"><a href="#function-和-window-onload-function-的区别" class="headerlink" title="$($(function(){}) 和 window.onload = function(){}的区别"></a>$($(function(){}) 和 window.onload = function(){}的区别</h4><p>$(function(){}) 和 window.onload = function(){}的区别有以下几点：</p><ul><li><a href="https://www.cnblogs.com/xfcao/p/6514438.html">$(function(){}) 是JQuery的入口函数，相当于 $(document).ready(function(){})，表示当页面的DOM树加载完成后就执行。</a><a href="https://www.cnblogs.com/xfcao/p/6514438.html">2</a><a href="https://blog.csdn.net/HHHelloForWorld/article/details/79997857">3</a></li><li><a href="https://blog.csdn.net/csdnluolei/article/details/83930943">window.onload = function(){} 是原生JavaScript的事件处理函数，表示当页面及所有依赖资源（如图片、脚本、样式表等）加载完成后才执行。</a><a href="https://blog.csdn.net/csdnluolei/article/details/83930943">4</a></li><li>$(function(){}) 不会被覆盖，而 window.onload = function(){} 会被覆盖，如果有多个同名的函数，只会执行最后一个。<a href="https://bing.com/search?q=$(function()%7B%7D)+%E5%92%8C++window.onload+=+function()%7B%7D%E7%9A%84%E5%8C%BA%E5%88%AB">1</a></li><li><a href="https://blog.csdn.net/csdnluolei/article/details/83930943">$(function(){}) 的执行时机一般早于 window.onload = function(){}，因为前者不需要等待资源加载完毕。</a><a href="https://blog.csdn.net/csdnluolei/article/details/83930943">4</a></li></ul><h4 id="事件绑定："><a href="#事件绑定：" class="headerlink" title="事件绑定："></a>事件绑定：</h4><p><a href="https://www.php.cn/js-tutorial-463234.html">jquery绑定事件有几种方式？-js教程-PHP中文网</a></p><div class="code-wrapper"><pre><code class="hljs haskell">//*<span class="hljs-number">2</span>.jQuery提供的绑定方式：bind(<span class="hljs-class"><span class="hljs-keyword">type</span>,[<span class="hljs-keyword">data</span>],fn)函数把元素和事件绑定起来</span>   //<span class="hljs-class"><span class="hljs-keyword">type</span>表示要绑定的事件   [<span class="hljs-keyword">data</span>]表示传入的数据   fn表示事件的处理方法</span>   //bind(事件字符串,回调函数),后来添加的元素不会绑定事件   //使用bind()绑定多个事件   <span class="hljs-class"><span class="hljs-keyword">type</span>可以接受多个事件类型，使用空格分割多个事件</span>   /* $(<span class="hljs-string">&quot;.head&quot;</span>).bind(<span class="hljs-string">&quot;click mouseover&quot;</span>,function()&#123;      $(<span class="hljs-string">&quot;.content&quot;</span>).toggle();   &#125;); */   //<span class="hljs-number">3</span>.one()只绑定一次,绑定的事件只会发生一次one(<span class="hljs-class"><span class="hljs-keyword">type</span>,[<span class="hljs-keyword">data</span>],fn)函数把元素和事件绑定起来</span>   //<span class="hljs-class"><span class="hljs-keyword">type</span>表示要绑定的事件   [<span class="hljs-keyword">data</span>]表示传入的数据   fn表示事件的处理方法</span>/*     $(<span class="hljs-string">&quot;.head&quot;</span>).one(<span class="hljs-string">&quot;click mouseover&quot;</span>,function()&#123;      $(<span class="hljs-string">&quot;.content&quot;</span>).toggle();   &#125;); */   //<span class="hljs-number">4</span>.live方法会为现在及以后添加的元素都绑定上相应的事件/**    $(<span class="hljs-string">&quot;.head&quot;</span>).live(<span class="hljs-string">&quot;click&quot;</span>,function()&#123;      $(<span class="hljs-string">&quot;.content&quot;</span>).toggle();   &#125;);   $(<span class="hljs-string">&quot;#panel&quot;</span>).before(<span class="hljs-string">&quot;&lt;h5 class=&#x27;head&#x27;&gt;什么是jQuery?&lt;/h5&gt;&quot;</span>);*/</code></pre></div><h4 id="事件移除："><a href="#事件移除：" class="headerlink" title="事件移除："></a>事件移除：</h4><div class="code-wrapper"><pre><code class="hljs haskell">//unbind()可以移除指定的事件，只需要传一个事件名作为参数//unbind(<span class="hljs-class"><span class="hljs-keyword">type</span>,[<span class="hljs-keyword">data</span>|fn]])</span>//<span class="hljs-class"><span class="hljs-keyword">type</span>事件类型  当传入<span class="hljs-keyword">type</span>的时候会解除<span class="hljs-keyword">type</span>事件</span>//如果没有传入<span class="hljs-class"><span class="hljs-keyword">type</span>值，会移除所有事件</span></code></pre></div><h4 id="事件冒泡："><a href="#事件冒泡：" class="headerlink" title="事件冒泡："></a>事件冒泡：</h4><p><a href="https://blog.csdn.net/One_And_One/article/details/89307504">js事件冒泡详解_js冒泡事件_壹加贰的博客-CSDN博客</a></p><div class="code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span>冒泡就是事件的向上传导，子元素的事件被触发，父元素的响应事件也会触发<span class="hljs-string">//</span>解决冒泡问题：return <span class="hljs-literal">false</span>;</code></pre></div><h4 id="动画："><a href="#动画：" class="headerlink" title="动画："></a>动画：</h4><p><a href="https://www.yisu.com/zixun/696410.html">jquery动画函数有哪些 - web开发 - 亿速云</a></p><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat:"></a>Tomcat:</h2><h4 id="tomcat的目录说明："><a href="#tomcat的目录说明：" class="headerlink" title="tomcat的目录说明："></a>tomcat的目录说明：</h4><p>bin:可执行文件目录；conf:配置文件目录;lib:存放lib的目录；logs：日志文件(<a href="https://baike.baidu.com/item/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/1505348">日志文件是一个记录操作系统或其他软件运行中发生的事件或在通信软件的不同用户之间的消息的文件</a><a href="https://baike.baidu.com/item/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/1505348">1</a>。它可以用于记录各种服务运行消息，例如系统日志文件，用户登录文件等<a href="https://blog.csdn.net/qq_42534026/article/details/104280006">2</a><a href="https://zhuanlan.zhihu.com/p/298335887">。日志文件对于诊断和解决问题很有帮助，因为它通常把系统的消息记录下来</a><a href="https://zhuanlan.zhihu.com/p/298335887">3</a>。);webapp:项目部署文件;work：工作目录;temp:临时目录;<br>配置Tomcat的环境变量的时候要配置java jdk的环境变量，因为Tomcat是用java和c写的。</p><h4 id="Tomcat和web的关系："><a href="#Tomcat和web的关系：" class="headerlink" title="Tomcat和web的关系："></a>Tomcat和web的关系：</h4><p>Tomcat是一个免费的开源Web应用服务器<a href="https://www.cnblogs.com/xs-yqz/p/4512970.html">1</a>。它是一种独立的JavaWeb容器，只能运行Web程序，也被称为Web服务器<a href="https://blog.csdn.net/qq_36025972/article/details/100128871">2</a>。它技术先进、性能稳定且免费，深受Java爱好者喜爱，并得到了部分软件开发商的认可，成为目前比较流行的Web应用服务器<a href="https://www.cnblogs.com/xs-yqz/p/4512970.html">1</a>。</p><h4 id="IntelliJ-IDEA-2022-1-3-如何利用Tomcat创建一个web："><a href="#IntelliJ-IDEA-2022-1-3-如何利用Tomcat创建一个web：" class="headerlink" title="IntelliJ IDEA 2022.1.3 如何利用Tomcat创建一个web："></a>IntelliJ IDEA 2022.1.3 如何利用Tomcat创建一个web：</h4><p>下面的链接不是很正确的，正确的可以去b站上看相关视频，跟着视频配置<br><a href="https://blog.csdn.net/m0_64351669/article/details/127309413">IDEA 2022专业版创建Java Web项目（保姆式小白讲义，强烈建议入手！）_idea专业版_Tony_Chen_0725的博客-CSDN博客</a></p><h6 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h6><p>1.注意Tomcat所支持的JDK<br>2.步骤简述：新建项目->选择项目框架:WebAPP->在设置里面添加Maven->在配置里面选择Tomcat->运行（如果不先运行自己在IDEA右上角点击浏览器图标会把“未找到配置的/正在运行的 web 服务器! 请运行任意一个 web 配置并点击“刷新”按钮!”这个错误。<br>3.WEB-INF、index.jsp是什么？、<br>indeWEB-INF是Java的WEB应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问<a href="https://baike.baidu.com/item/web-inf/4476359">1</a>。<br>index.jsp通常是一个Web应用程序的默认主页。当您在浏览器中输入Web应用程序的URL时，服务器会自动查找并显示index.jsp页面。<br>4.Maven是什么？为什么web应用程序要配置它？b应用程序要配置它？<br>Maven是一个项目管理工具，它包含了一个对象模型、一组标准集合和一个依赖管理系统<a href="https://cloud.tencent.com/developer/article/1705945">1</a>。开发人员只需做一些简单的配置，就可以批量完成项目的构建、报告和文档的生成工作<a href="https://bing.com/search?q=Maven%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%A6%81%E9%85%8D%E7%BD%AE%E5%AE%83">2</a><a href="https://blog.csdn.net/weixin_45151795/article/details/106138391">3</a>。<br>Maven的核心功能是合理叙述项目间的依赖关系，通俗点就是通过pom.xml文件的配置获取jar包<a href="https://cloud.tencent.com/developer/article/1705945">1</a>。使用Maven配置好项目后，输入简单的命令，如:mvn clean install,Maven会帮我们处理那些繁琐的任务<a href="https://blog.csdn.net/MacWx/article/details/95205828">4</a>。<br>JProfiler :性能诊断利器<br>Artifact:<a href="https://www.cnblogs.com/cmyBlog/p/10892713.html">idea中artifacts、facets、modules是什么意思？ - 超人不会飞1996 - 博客园</a></p><h4 id="web资源分类："><a href="#web资源分类：" class="headerlink" title="web资源分类："></a>web资源分类：</h4><p>web资源分类是指将存放在web服务器上的文件按照实现的技术和呈现的效果的不同分为两种：静态web资源和动态web资源<a href="https://www.cnblogs.com/fate-/p/14737096.html">1</a><a href="https://www.cnblogs.com/penguin1024/p/16331832.html">2</a>。<br>静态web资源是指供用户浏览的web页面中的数据始终是固定不变的，如html、css、js、txt、MP4视频、jpg图片等<a href="https://www.cnblogs.com/fate-/p/14737096.html">1</a><a href="https://www.cnblogs.com/penguin1024/p/16331832.html">2</a>。<br>动态web资源是指供用户浏览的web页面中的数据随着时间或者不同用户会发生变化的，如jsp页面、Servlet程序等<a href="https://www.cnblogs.com/fate-/p/14737096.html">1</a></p><h4 id="那什么是jsp文件？"><a href="#那什么是jsp文件？" class="headerlink" title="那什么是jsp文件？"></a>那什么是jsp文件？</h4><p><a href="https://www.runoob.com/jsp/jsp-tutorial.html">JSP（Java Server Pages）是一种动态网页开发技术</a><a href="https://www.runoob.com/jsp/jsp-tutorial.html">1</a><a href="http://c.biancheng.net/jsp2/what-is-jsp.html">。JSP文件就是在传统的HTML文件中插入Java代码和JSP标签，后缀名为.jsp</a><a href="https://bing.com/search?q=jsp%E6%96%87%E4%BB%B6">2</a><a href="http://c.biancheng.net/jsp2/what-is-jsp.html">3</a><a href="https://www.runoob.com/jsp/jsp-tutorial.html">1</a><a href="https://www.runoob.com/jsp/jsp-tutorial.html">。JSP与PHP、ASP、ASP.NET等语言类似，都运行在服务端</a><a href="https://bing.com/search?q=jsp%E6%96%87%E4%BB%B6">2</a><a href="https://www.runoob.com/jsp/jsp-tutorial.html">1</a><a href="http://c.biancheng.net/jsp2/what-is-jsp.html">。通常返回给客户端的就是一个HTML文件，因此只要有浏览器就能查看JSP页面</a><a href="https://bing.com/search?q=jsp%E6%96%87%E4%BB%B6">2</a><a href="http://c.biancheng.net/jsp2/what-is-jsp.html">3</a></p><h4 id="为什么我的root不在webapps下？"><a href="#为什么我的root不在webapps下？" class="headerlink" title="为什么我的root不在webapps下？"></a>为什么我的root不在webapps下？</h4><p><a href="https://blog.csdn.net/weixin_44556968/article/details/107828605">IDEA 使用Tomcat部署的项目在哪里,为什么不在Tomcat的webapps目录下面_博_采_众_长的博客-CSDN博客</a><br>intellij idea使用Tomcat部署项目后并不会把编译后的项目复制到tomcat的webapps目录下,但是它会把编译好的项目路径告诉Tomcat,让Tomcat来找到这个项目,其它的项目比如Tomcat的主页项目ROOT是打不开的,因为intellij idea 只让Tomcat运行了一个项目.</p><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet:"></a>Servlet:</h2><p><a href="https://www.w3cschool.cn/servlet/servlet-server-response.html">Servlet 服务器 HTTP 响应_w3cschool</a><br><a href="https://blog.csdn.net/caqjeryy/article/details/122095308">Java Web 基础之Servlet概念详解（Servlet是什么？主要功能？基础重点运用？）_代码之狐的博客-CSDN博客</a><br><a href="http://c.biancheng.net/servlet2/what-is-servlet.html">Servlet到底是什么（非常透彻）</a><br>Servlet 是一种运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页<a href="https://www.runoob.com/servlet/servlet-intro.html">1</a>。<br>简单来讲：Servlet 其实就是一个遵循 Servlet 开发的 java 类，Servlet 是由服务器调用的，运行在服务器端<a href="https://bing.com/search?q=Servlet%E6%98%AF%E4%BB%80%E4%B9%88">2</a></p><h4 id="创建Servlet："><a href="#创建Servlet：" class="headerlink" title="创建Servlet："></a>创建Servlet：</h4><p>错误分析：<br>1.页面出现404:<br><a href="https://blog.csdn.net/weixin_54678689/article/details/115356622?spm=1001.2101.3001.6650.2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-115356622-blog-115649604.pc_relevant_aa">Servlet 初学遇到的问题：idea 运行Servlet网页总是出现404_idea servlet404_低调的骏马的博客-CSDN博客</a><br>Tomcat日志乱码解决？<br><a href="https://developer.aliyun.com/article/896440">关于解决Tomcat日志乱码问题，有几种解决方案。一种是将Tomcat安装目录下的/conf/logging.properties中的控制台日志编码由默认的UTF-8改为GBK</a><a href="https://bing.com/search?q=Tomcat%E6%97%A5%E5%BF%97%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3">1</a><a href="https://developer.aliyun.com/article/896440">2</a><a href="https://developer.aliyun.com/article/896440">。另一种方法是修改IDEA中控制台使用字符集为UTF-8</a><a href="https://bing.com/search?q=Tomcat%E6%97%A5%E5%BF%97%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3">1</a><a href="https://developer.aliyun.com/article/896440">2</a>。<br>web.xlm是什么？<br><a href="https://www.cnblogs.com/mytJava/p/13143449.html">web.xml是web项目的配置文件，一般的web工程都会用到web.xml来配置，主要用来配置Listener，Filter，Servlet等</a><a href="https://www.cnblogs.com/mytJava/p/13143449.html">1</a><a href="https://www.cnblogs.com/mytJava/p/13143449.html">。但需要注意的是：web.xml并不是必须的，一个web工程可以没有web.xml文件</a><a href="https://www.cnblogs.com/mytJava/p/13143449.html">1</a><a href="https://blog.csdn.net/qq_40726316/article/details/95366650">2</a>。<br>505错误：<br><a href="https://cloud.tencent.com/developer/article/1502462">找不到servlet对应的class - 腾讯云开发者社区-腾讯云</a></p><h4 id="Servlet的get和post请求："><a href="#Servlet的get和post请求：" class="headerlink" title="Servlet的get和post请求："></a>Servlet的get和post请求：</h4><h4 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig:"></a>ServletConfig:</h4><p><a href="https://blog.csdn.net/durenniu/article/details/81066817">ServletConfig讲解_durenniu的博客-CSDN博客</a></p><h4 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext:"></a>ServletContext:</h4><p><a href="https://www.cnblogs.com/gllegolas/p/11804105.html#:~:text=%E8%BF%99%E9%87%8C%E8%A6%81%E8%AF%B4%E6%98%8E%E7%9A%84%E6%98%AF%EF%BC%8CServletContext%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%EF%BC%9A%20this.getServletContext%20%28%29.getRequestDispatcher,%28%22%2Furl%22%29.forward%20%28request%2C%20response%29%3B">servlet学习（五）--HttpServletContext - GLLegolas - 博客园</a></p><h4 id="什么是TomcatLocation日志和什么是Tomcat-Catalina日志和他们编码问题"><a href="#什么是TomcatLocation日志和什么是Tomcat-Catalina日志和他们编码问题" class="headerlink" title="什么是TomcatLocation日志和什么是Tomcat Catalina日志和他们编码问题"></a>什么是TomcatLocation日志和什么是Tomcat Catalina日志和他们编码问题</h4><p><a href="https://blog.csdn.net/fly910905/article/details/78463909">认识Tomcat的日志：catalina.out、localhost、manager、localhost_access_log_catalina.out日志_琦彦的博客-CSDN博客</a></p><h2 id="IDEA-tomcat日志乱码-idea-tomcat-日志乱码-梅西库里RNG的博客-CSDN博客"><a href="#IDEA-tomcat日志乱码-idea-tomcat-日志乱码-梅西库里RNG的博客-CSDN博客" class="headerlink" title="IDEA--tomcat日志乱码_idea tomcat 日志乱码_梅西库里RNG的博客-CSDN博客"></a><a href="https://blog.csdn.net/Derek7117/article/details/122998894?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-122998894-blog-98752464.pc_relevant_3mothn_strategy_recovery&spm=1001.2101.3001.4242.1&utm_relevant_index=3">IDEA--tomcat日志乱码_idea tomcat 日志乱码_梅西库里RNG的博客-CSDN博客</a></h2><p> TomcatLocation日志是指Tomcat在启动过程中输出的日志信息，主要包括Tomcat的安装路径、JVM的版本、Tomcat的配置信息等。这些日志信息对于调试和排查Tomcat启动问题非常有帮助。TomcatLocation日志的输出通常是在控制台中，也可以通过Tomcat的日志文件进行配置。 Tomcat Catalina日志是指Tomcat在运行过程中输出的日志信息，主要包括HTTP请求、响应、异常等详细信息。这些日志信息对于定位和解决Tomcat运行中的问题非常有帮助。Tomcat Catalina日志的输出通常是在Tomcat的日志文件中，可以通过Tomcat的日志配置文件进行配置。 Tomcat默认的日志文件编码是UTF-8，可以在Tomcat的配置文件中进行设置。如果出现中文乱码等问题，可以检查Tomcat的日志文件编码是否正确。在Windows系统中，Tomcat的日志文件编码默认是GBK，需要将其设置为UTF-8才能正确输出中文。  </p><h2 id="JSP："><a href="#JSP：" class="headerlink" title="JSP："></a>JSP：</h2><h4 id="访问js访问jsp页面浏览器不是加载它，而是下载它？"><a href="#访问js访问jsp页面浏览器不是加载它，而是下载它？" class="headerlink" title="访问js访问jsp页面浏览器不是加载它，而是下载它？"></a>访问js访问jsp页面浏览器不是加载它，而是下载它？</h4><h4 id="JSP重定向："><a href="#JSP重定向：" class="headerlink" title="JSP重定向："></a>JSP重定向：</h4><h4 id="web中context-param和listener这两个结点是什么？"><a href="#web中context-param和listener这两个结点是什么？" class="headerlink" title="web中context-param和listener这两个结点是什么？"></a>web中context-param和listener这两个结点是什么？</h4><p><a href="https://blog.csdn.net/qq_42303709/article/details/81624724">1</a><a href="https://blog.csdn.net/CatEatApple/article/details/112393498">2</a><a href="https://blog.csdn.net/u011047968/article/details/108094213">3</a>，web中context-param和listener这两个结点是什么的简单解释如下：</p><ul><li>context-param是用来配置web应用的全局参数，它可以被web应用中的所有组件（如servlet，filter，listener等）共享。它是一个键值对的形式，可以在web.xml中定义多个context-param。</li><li>listener是用来监听web应用的生命周期事件或属性变化的组件，它可以实现javax.servlet.ServletContextListener接口或其他相关接口，并在web.xml中注册。listener可以在web应用启动或停止时执行一些初始化或清理操作。</li></ul><h4 id="web-xml的刨析："><a href="#web-xml的刨析：" class="headerlink" title="web.xml的刨析："></a>web.xml的刨析：</h4><p><a href="https://www.cnblogs.com/mytJava/p/13143449.html">web.xml详解 及 web.xml模板 - mellisa&myt - 博客园</a><br><a href="https://www.cnblogs.com/linhuaming/p/9464356.html">web.xml 配置文件 超详细说明！！！ - 吴川华仔博客 - 博客园</a></p><h4 id="什么是编译器输出路径？："><a href="#什么是编译器输出路径？：" class="headerlink" title="什么是编译器输出路径？："></a>什么是编译器输出路径？：</h4><p><a href="https://www.cnblogs.com/qianbixin/p/10992660.html">1</a><a href="https://blog.csdn.net/baidu_41553551/article/details/124381769">2</a><a href="https://blog.csdn.net/weixin_41821317/article/details/107640638">3</a><a href="https://blog.csdn.net/a704397849/article/details/103353886">4</a>，编译器输出路径是指编译器将源代码编译后生成的文件存放的位置。不同的编译器和开发工具可能有不同的方式设置编译器输出路径，一般可以在项目属性或者配置中进行修改。编译器输出路径通常包括以下几种：</p><ul><li>输出目录：存放中间生成的链接器用的文件，如.ilk和.pdb等。</li><li>输出文件：存放最终生成的可执行文件，如.exe等。</li><li>工作目录：存放运行时需要用到的资源文件，如图片、音频等。</li></ul><h4 id="jsp常用脚本？"><a href="#jsp常用脚本？" class="headerlink" title="jsp常用脚本？"></a>jsp常用脚本？</h4><p><a href="https://blog.csdn.net/qq_45821251/article/details/110577846">1</a><a href="https://blog.csdn.net/weixin_48112109/article/details/124764545">2</a><a href="https://www.runoob.com/jsp/jsp-syntax.html">3</a><a href="https://www.runoob.com/jsp/jsp-tutorial.html">4</a>，JSP常用脚本有以下三种：</p><ul><li>声明脚本：用于在JSP页面中声明变量或方法，以<%!和%>包围，例如<%! int i = 0; %></li><li>表达式脚本：用于在JSP页面中输出一个值，以<%=和%>包围，例如<%= i %></li><li>代码脚本：用于在JSP页面中嵌入Java代码段，以<%和%>包围，例如<% i++; %></li></ul><h4 id="jsp注释："><a href="#jsp注释：" class="headerlink" title="jsp注释："></a>jsp注释：</h4><p>1.html:<!----><br>2.java://,/**/<br>3.jsp:<%----%></p><h4 id="JSP四大域对象"><a href="#JSP四大域对象" class="headerlink" title="JSP四大域对象"></a>JSP四大域对象</h4><p><a href="https://bing.com/search?q=JSP%E5%9B%9B%E5%A4%A7%E5%9F%9F%E5%AF%B9%E8%B1%A1">1</a><a href="https://baijiahao.baidu.com/s?id=1721272767055844324">2</a><a href="https://blog.csdn.net/w405722907/article/details/77530002">3</a><a href="https://www.php.cn/java-article-418934.html">4</a><a href="https://juejin.cn/post/7183323776929497125">5</a><a href="https://www.cnblogs.com/neuhao/p/7290570.html">6</a>，JSP四大域对象是指JSP中用于保存和获取数据的四个内置对象，它们分别是：</p><ul><li>pageContext：当前页面上下文对象，只在当前页面中有效。</li><li>request：请求对象，只在一次请求中有效，服务端跳转有效，客户端跳转无效。</li><li>session：会话对象，只在一次会话中有效，服务端客户端跳转都有效。</li><li>application：应用对象，只在同一个web应用中有效</li></ul><h4 id="在idea里jsp文件pageContext-setAttribute报红"><a href="#在idea里jsp文件pageContext-setAttribute报红" class="headerlink" title="在idea里jsp文件pageContext.setAttribute报红"></a>在idea里jsp文件pageContext.setAttribute报红</h4><p><a href="https://blog.csdn.net/weixin_46254970/article/details/121433684">这个问题可能是由于没有导入JSP相关依赖。解决方案是找到下载的Tomcat文件夹，再进入lib文件夹，复制jsp-api.jar，然后回到项目中将此依赖导入。一般导入依赖的方法是在web目录下创建一个lib目录，将jar包复制进去后即</a>可</p><h4 id="文-件-web-WEB-INF-a-jsp-未找到"><a href="#文-件-web-WEB-INF-a-jsp-未找到" class="headerlink" title="文.件[/web/WEB-INF/a.jsp] 未找到"></a>文.件[/web/WEB-INF/a.jsp] 未找到</h4><p>我把a.jsp放在WEB-INF里面了，而WEB-INF是对外不可见的<br><a href="https://blog.csdn.net/weixin_38111957/article/details/90815591">Spring-boot访问JSP页面变成文件下载日常踩坑_IT贱男的博客-CSDN博客</a>   </p><h4 id="jsp中的out输出和response-getWriter-的区别：-jsp中的out输出和response-getWriter-的区别：-必应"><a href="#jsp中的out输出和response-getWriter-的区别：-jsp中的out输出和response-getWriter-的区别：-必应" class="headerlink" title="jsp中的out输出和response.getWriter()的区别：                                                                                                                                                                 jsp中的out输出和response.getWriter()的区别： - 必应"></a>jsp中的out输出和response.getWriter()的区别：                                                                                                                                                                 <a href="https://www.bing.com/search?pc=U528&q=jsp%E4%B8%AD%E7%9A%84out%E8%BE%93%E5%87%BA%E5%92%8Cresponse.getWriter()%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A&form=U528DF">jsp中的out输出和response.getWriter()的区别： - 必应</a></h4><p><a href="https://blog.csdn.net/shenqueying/article/details/80841347">jsp中out跟response.getWriter()的区别_shenqueying的博客-CSDN博客</a></p><h4 id="jsp静态包含和动态包含："><a href="#jsp静态包含和动态包含：" class="headerlink" title="jsp静态包含和动态包含："></a>jsp静态包含和动态包含：</h4><p><a href="https://blog.csdn.net/Rao_Limon/article/details/82867782">JSP静态包含和动态包含的区别_LaoYe - IT的博客-CSDN博客</a></p><h4 id="路径的-和-是什么意思？"><a href="#路径的-和-是什么意思？" class="headerlink" title="路径的/和../是什么意思？"></a>路径的/和../是什么意思？</h4><p><a href="https://blog.csdn.net/rabbit_ding0810/article/details/50911295">路径中的‘.’和‘..‘还有‘./‘和’../’都是什么意思_。_司徒游的博客-CSDN博客</a></p><h4 id="Servlet页面重定向："><a href="#Servlet页面重定向：" class="headerlink" title="Servlet页面重定向："></a>Servlet页面重定向：</h4><p><a href="https://blog.csdn.net/weixin_43524214/article/details/122765871">Servlet之页面重定向_重定向页面_是席木木啊的博客-CSDN博客</a></p><h4 id="新建的web项目为什么默认访问index-jsp"><a href="#新建的web项目为什么默认访问index-jsp" class="headerlink" title="新建的web项目为什么默认访问index.jsp"></a>新建的web项目为什么默认访问index.jsp</h4><p><a href="https://blog.csdn.net/shuair/article/details/86645707">新建的web项目为什么默认访问index.jsp_shuair的博客-CSDN博客</a></p><h4 id="JavaWeb三大组件之监听器-Listener"><a href="#JavaWeb三大组件之监听器-Listener" class="headerlink" title="JavaWeb三大组件之监听器(Listener)"></a>JavaWeb三大组件之监听器(Listener)</h4><p><a href="https://blog.csdn.net/qq_44981526/article/details/123616675">监听器是JavaWeb的三大组件之一，另外两个组件分别是Servlet程序和Filter过滤器</a><a href="https://blog.csdn.net/qq_44981526/article/details/123616675">1</a><a href="https://blog.csdn.net/qq_44981526/article/details/123616675">。监听器是JavaEE的规范，就是接口。它的作用是监听某种变化（一般就是对象创建/销毁、属性变化），触发对应方法完成相应的任务</a><a href="https://blog.csdn.net/qq_44981526/article/details/123616675">1</a>。       </p><h4 id="EL表达式："><a href="#EL表达式：" class="headerlink" title="EL表达式："></a>EL表达式：</h4><p><a href="https://zhuanlan.zhihu.com/p/79643824">EL表达式（Expression Language）主要用于替换JSP页面中的脚本表达式，以从各种类型的web域中检索java对象、获取数据</a><a href="https://zhuanlan.zhihu.com/p/79643824">1</a><a href="https://blog.csdn.net/weixin_58657334/article/details/129426372">。它简化了代码的书写量</a><a href="https://blog.csdn.net/weixin_58657334/article/details/129426372">2</a><a href="http://c.biancheng.net/jsp2/el.html">。例如，${param.name}表示获取参数 name 的值，它等同于<%=request.getParameter('name') %></a><a href="http://c.biancheng.net/jsp2/el.html">3</a>。          </p><h4 id="什么是JavaBean"><a href="#什么是JavaBean" class="headerlink" title="什么是JavaBean"></a>什么是JavaBean</h4><p><a href="https://www.runoob.com/jsp/jsp-javabean.html">JavaBean是一种特殊的Java类，使用Java语言书写，并且遵守JavaBean API规范</a><a href="https://www.runoob.com/jsp/jsp-javabean.html">1</a><a href="https://cloud.tencent.com/developer/article/2107112">。它是一种可重用组件</a><a href="https://cloud.tencent.com/developer/article/2107112">2</a>。<br><a href="https://blog.csdn.net/weixin_43217564/article/details/100051029">一个Java类满足以下2点 ，就可以称为JavaBean：public修饰的类，public无参构造；所有属性（如果有）都是private，并且提供set/get（如果boolean则get可以替换成is）</a><a href="https://blog.csdn.net/weixin_43217564/article/details/100051029">3</a>。</p><h4 id="jstl标签库："><a href="#jstl标签库：" class="headerlink" title="jstl标签库："></a>jstl标签库：</h4><p><a href="http://c.biancheng.net/jstl/">JSTL（JSP Standard Tag Library，核心标签库）是 JSP 标签的集合，它封装了 JSP 应用的通用核心功能。 JSP 标签是一组与 HTML 标签相似，但又比 HTML 标签强大的功能标签。 JSTL 用来简化 JSP 开发，可以使我们不用嵌入 Java 代码就能够开发出复杂的 JSP 页面</a><a href="https://bing.com/search?q=jstl%E6%A0%87%E7%AD%BE%E5%BA%93">1</a><a href="http://c.biancheng.net/jstl/">2</a>。<br><a href="https://www.runoob.com/jsp/jsp-jstl.html">根据JSTL标签所提供的功能，可以将其分为5个类别：通用的、结构化的任务，比如迭代、条件判断、XML文档操作、国际化标签、SQL标签。除了这些，它还提供了一个框架来使用集成JSTL的自定义标签</a><a href="https://www.runoob.com/jsp/jsp-jstl.html">3</a>。</p><h4 id="cook和session"><a href="#cook和session" class="headerlink" title="cook和session"></a>cook和session</h4><p><a href="https://blog.51cto.com/u_15349906/3714889">JavaWeb：Cookie和Session_51CTO博客_cookie token 和 session 的区别</a></p><h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter:"></a>Filter:</h4><div class="code-wrapper"><pre><code class="hljs">[Filter 是 JavaWeb 中的过滤器，它是 JavaWeb 的三大组件之一（Servlet 程序、Listener 监听器、Filter 过滤器）](https://blog.csdn.net/yuzhiqiang_1993/article/details/81288912)[1](https://blog.csdn.net/yuzhiqiang_1993/article/details/81288912)[。当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。过滤器一般用于完成通用的操作，如登录验证、统一编码处理、敏感字符过滤等等](https://developer.aliyun.com/article/44741)[2](https://developer.aliyun.com/article/44741)。     </code></pre></div><h2 id="JSON-Ajax"><a href="#JSON-Ajax" class="headerlink" title="JSON & Ajax:"></a>JSON & Ajax:</h2><h2 id="Java-Web之Ajax-XeonYu的博客-CSDN博客"><a href="#Java-Web之Ajax-XeonYu的博客-CSDN博客" class="headerlink" title="Java Web之Ajax_XeonYu的博客-CSDN博客"></a><a href="https://yuzhiqiang.blog.csdn.net/article/details/81284684">Java Web之Ajax_XeonYu的博客-CSDN博客</a></h2>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大话HTTP</title>
    <link href="/2024/01/26/%E5%A4%A7%E8%AF%9Dhttp_/"/>
    <url>/2024/01/26/%E5%A4%A7%E8%AF%9Dhttp_/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id="1-了解http协议："><a href="#1-了解http协议：" class="headerlink" title="1.了解http协议："></a>1.了解http协议：</h2><p>http:超文本传输协议，允许将超文本标记语言从web服务器传送到客户端浏览器，是属于应用层的面向对象协议。</p><h4 id="TCP3次握手："><a href="#TCP3次握手：" class="headerlink" title="TCP3次握手："></a><a href="https://blog.csdn.net/qq_34827674/article/details/105331617">TCP3次握手</a>：</h4><h4 id="DNS域名解析："><a href="#DNS域名解析：" class="headerlink" title="DNS域名解析："></a>DNS域名解析：</h4><p>当我们在浏览器键入一个网址的时候，浏览器会在本地hosts文件找有没有，该域名和网址的映射，没有就在DNS服务器寻找，也没有就在上级的DNS服务器，直达根服务器<br><a href="https://zh.wikipedia.org/zh-hans/Hosts%E6%96%87%E4%BB%B6">hosts文件</a>:host查询到的ip和域名的映射关系高于dns；</p><h2 id="http协议结构和通信原理："><a href="#http协议结构和通信原理：" class="headerlink" title="http协议结构和通信原理："></a>http协议结构和通信原理：</h2><h4 id="http协议特点：深入理解HTTP协议"><a href="#http协议特点：深入理解HTTP协议" class="headerlink" title="http协议特点：深入理解HTTP协议"></a>http协议特点：<a href="https://zhuanlan.zhihu.com/p/45173862">深入理解HTTP协议</a></h4><p>1.简单快速：<br>客户向服务器发送请求时，只需要传输路径和方法；请求方法有get,head,post，每种方法规定了客户与服务器联系的类型不同；http协议简单，服务器程序规模小，通信速度快。<br>2.灵活：http允许传递任意类型的数据对象，正在传输的类型用,<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type">Content-Type</a>标志<br>3.无连接：无连接的含义是限制每次连接只处理一个请求，服务器处理完客户的请求并收到应答后就断开连接，节省传输时间<br>4.无状态：是指对于事务的处理能力没有记忆能力，如果后面的内容需要前面的内容，则必须重新传送</p><h4 id="http报文结构：HTTP报文（面试会问开发时常用的报文头格式）-每天都要学进去一些-博客园"><a href="#http报文结构：HTTP报文（面试会问开发时常用的报文头格式）-每天都要学进去一些-博客园" class="headerlink" title="http报文结构：HTTP报文（面试会问开发时常用的报文头格式） - 每天都要学进去一些 - 博客园"></a>http报文结构：<a href="https://www.cnblogs.com/chenguangliang/p/6708592.html">HTTP报文（面试会问开发时常用的报文头格式） - 每天都要学进去一些 - 博客园</a></h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677750686459-c74a6d54-94d1-4fab-a5be-ff1ab7e65b46.png#averageHue=%23dcd9d6&clientId=u7887007a-fbef-4&from=paste&height=344&id=u2c1ad97e&originHeight=430&originWidth=928&originalType=binary&ratio=1&rotation=0&showTitle=false&size=254955&status=done&style=none&taskId=u17c24382-4261-4789-88d4-7ac5a23fbb1&title=&width=742.4" alt="image.png"></p><h4 id="http报文头：HTTP报文头部字段大全-Go-技术论坛"><a href="#http报文头：HTTP报文头部字段大全-Go-技术论坛" class="headerlink" title="http报文头：HTTP报文头部字段大全 | Go 技术论坛"></a>http报文头：<a href="https://learnku.com/articles/75429">HTTP报文头部字段大全 | Go 技术论坛</a></h4><p>可分为4类，通用（请求响应报文都适用），请求，响应，实体。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677751297927-bbe2fc0f-724e-4e7b-9341-bf1140aacde6.png#averageHue=%23e9e9e7&clientId=u7887007a-fbef-4&from=paste&height=254&id=uc1bac5ec&originHeight=317&originWidth=711&originalType=binary&ratio=1&rotation=0&showTitle=false&size=110483&status=done&style=none&taskId=uf65ab8bb-b999-49fb-8fcf-5893733dce2&title=&width=568.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677751442440-3e9b9731-669f-4c0e-b7de-97175c5e171a.png#averageHue=%23edecea&clientId=u7887007a-fbef-4&from=paste&height=394&id=u0d98c253&originHeight=493&originWidth=814&originalType=binary&ratio=1&rotation=0&showTitle=false&size=183195&status=done&style=none&taskId=u6bc33f8b-cd70-4e96-9fba-e865d9b1b89&title=&width=651.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677751461298-383464f0-16cd-42ae-969f-b6a5d5622c5b.png#averageHue=%23dededb&clientId=u7887007a-fbef-4&from=paste&height=278&id=uc8d3bd80&originHeight=348&originWidth=796&originalType=binary&ratio=1&rotation=0&showTitle=false&size=130843&status=done&style=none&taskId=uf1bce824-c460-4f96-a904-61f50083c02&title=&width=636.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677751475332-3a14fe5d-9146-4c15-9165-fc68738a18ee.png#averageHue=%23e6e6e4&clientId=u7887007a-fbef-4&from=paste&height=316&id=u680ab071&originHeight=395&originWidth=738&originalType=binary&ratio=1&rotation=0&showTitle=false&size=159997&status=done&style=none&taskId=ub1bb7900-b75a-4bc9-b2b3-c692a70fce4&title=&width=590.4" alt="image.png"><br>accept:浏览器可以接收的媒体类型；<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept">Accept - HTTP | MDN</a><br>Accept:text&#x2F;html 代表浏览器可以接收服务器回发的html文档，如果服务器无法返回html文档就返回一个406错误。<br>Accept:*&#x2F;*代表浏览器可以处理任意数据的媒体类型；<br>如果想要给显示的媒体类型增加优先级，则使用q,q的范围是0~1，1最大，没有默认为1.0，当服务器提供多种内容的时候，返回最高的媒体类型最高的媒体类型。<br>Accept-Language:浏览器声明自己接收的语言。<br>Accept-Language:zh-cn,zh;q&#x3D;0.7,en-us,en;q&#x3D;0.3 客户端在服务器有中文版的资源下，会优先返回中文版的响应，没有就返回英文版的。<br>Connection:keep-alive 当一个网页打开完全后，客户端和服务端之间用于传输HTTP数据的TCP连接不会断开，如果客户端再次访问这个服务器的网页，就会继续使用一条已经建立的连接。<br>Connection:close 一个Request完成后，客户端和服务端之间用于传输HTTP数据的TCP连接会关闭，当客户端再次发送Request，需要重新建立TCP连接<br>  Host:<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677753061304-a328b174-095c-43bc-9070-e29d5ee8f210.png#averageHue=%23f1f1f1&clientId=u7887007a-fbef-4&from=paste&height=266&id=ufc34ae2c&originHeight=332&originWidth=882&originalType=binary&ratio=1&rotation=0&showTitle=false&size=91299&status=done&style=none&taskId=ufccf7dcb-1566-40a8-93e5-a894975fc1b&title=&width=705.6" alt="image.png"> Referer:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677753140834-de9c6939-a6c4-48dc-b89d-22d5275108ca.png#averageHue=%23efefef&clientId=u7887007a-fbef-4&from=paste&height=152&id=u75f241ca&originHeight=190&originWidth=830&originalType=binary&ratio=1&rotation=0&showTitle=false&size=54358&status=done&style=none&taskId=ua50ba59a-11c3-4450-a20f-35077d48965&title=&width=664" alt="image.png">User-Agent:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677753182984-f255c974-6761-421b-a716-fb8ada5109b2.png#averageHue=%23f5f4f4&clientId=u7887007a-fbef-4&from=paste&height=144&id=ue1e47074&originHeight=180&originWidth=840&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47156&status=done&style=none&taskId=u067df328-4eb9-440f-9342-21298d2edf4&title=&width=672" alt="image.png"><br>Content-Type:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677753282897-e0559545-9ed9-4020-8809-90c106b0d201.png#averageHue=%23ededed&clientId=u7887007a-fbef-4&from=paste&height=290&id=u38be556f&originHeight=363&originWidth=877&originalType=binary&ratio=1&rotation=0&showTitle=false&size=132433&status=done&style=none&taskId=u1892726f-1479-4694-94e0-0e871761859&title=&width=701.6" alt="image.png"><br>http响应报文：<a href="https://cloud.tencent.com/developer/article/1953222">Http请求报文格式和响应报文格式 - 腾讯云开发者社区-腾讯云</a></p><h4 id="http请求方法："><a href="#http请求方法：" class="headerlink" title="http请求方法："></a>http请求方法：</h4><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">HTTP request methods - HTTP | MDN</a><br>get提交的请求作为url的一部分，这就表示它提交的请求不能过大（浏览器的url有长度限制）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677754360040-37c9f38a-1ab8-4c60-89fa-ab6a7bd148d6.png#averageHue=%23f7f6f6&clientId=u7887007a-fbef-4&from=paste&height=299&id=u95859447&originHeight=374&originWidth=824&originalType=binary&ratio=1&rotation=0&showTitle=false&size=91491&status=done&style=none&taskId=u3cb8b1b3-2d46-44c7-a2c5-9380c1c352e&title=&width=659.2" alt="image.png"><br>上面链接后面的？是参数，用来给web服务器进行某些处理的<br><a href="https://developer.mozilla.org/en-US/docs/Learn/Common_questions/Web_mechanics/What_is_a_URL">What is a URL? - Learn web development | MDN</a><br>url区分大小写吗？<br><a href="https://webmasters.stackexchange.com/questions/5157/is-it-ok-to-have-a-case-insensitive-uri">根据网络搜索结果，URL的大小写敏感性取决于URL的不同部分和服务器的操作系统。一般来说，域名和协议（如https:&#x2F;&#x2F;）是不区分大小写的，但路径（如&#x2F;en-US&#x2F;docs&#x2F;Learn）和参数（如?key1&#x3D;value1）可能是区分大小写的</a><a href="https://webmasters.stackexchange.com/questions/5157/is-it-ok-to-have-a-case-insensitive-uri">1</a><a href="https://techpenny.com/are-domains-urls-case-sensitive/">2</a><a href="https://abramillar.com/2017/01/25/are-urls-case-sensitive/">3</a><a href="https://techpenny.com/are-domains-urls-case-sensitive/">。如果您使用Linux或Unix系统的服务器，那么您的URL路径可能是区分大小写的</a><a href="https://techpenny.com/are-domains-urls-case-sensitive/">2</a><a href="https://webmasters.stackexchange.com/questions/5157/is-it-ok-to-have-a-case-insensitive-uri">。如果您使用Windows系统的服务器，那么您的URL路径可能是不区分大小写的</a><a href="https://webmasters.stackexchange.com/questions/5157/is-it-ok-to-have-a-case-insensitive-uri">1</a>。<br><a href="https://abramillar.com/2017/01/25/are-urls-case-sensitive/">为了避免重复内容或链接错误的问题，建议您在创建和分享URL时使用统一的大小写规则，并且尽量避免使用大写字母</a><a href="https://abramillar.com/2017/01/25/are-urls-case-sensitive/">3</a><a href="https://webmasters.stackexchange.com/questions/90339/why-are-urls-case-sensitive">4</a><a href="https://stackoverflow.com/questions/15641694/are-uris-case-insensitive">。如果您想让您的网站自动将不同大小写的URL重定向到一个标准版本，您可以使用.htaccess文件或其他方法来实现</a><a href="https://stackoverflow.com/questions/15641694/are-uris-case-insensitive">5</a>。<br>希望这些信息对您有所帮助。<br>post:<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677754428239-e5ecbe48-620f-43c9-8994-0ebf0f068b20.png#averageHue=%23f5f5f5&clientId=u7887007a-fbef-4&from=paste&height=412&id=ua0feed1a&originHeight=515&originWidth=897&originalType=binary&ratio=1&rotation=0&showTitle=false&size=190115&status=done&style=none&taskId=uff0ad16f-5284-4ed8-b112-95025284bfa&title=&width=717.6" alt="image.png"><br>get请求数据放在url里面（没安全性），大小有限制，post请求数据放在 请求头里面，大小无限制。<br>put:<br>从客户端向服务器传送的数据指定文档的内容，和post最大的区别是：put是幂等（<a href="https://www.jianshu.com/p/178da1e2903c">一个HTTP方法是幂等的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的</a><a href="https://bing.com/search?q=http%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%82%E7%AD%89">1</a><a href="https://www.jianshu.com/p/178da1e2903c">2</a><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Idempotent">3</a><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Idempotent">。换句话说就是，幂等方法不应该具有副作用（统计用途除外）</a><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Idempotent">3</a><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Idempotent">。在正确实现的条件下，GET，HEAD，PUT和DELETE等方法都是幂等的，而POST方法不是</a><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Idempotent">3</a>）的，而post是不幂等的，我们更多时候用put传送资源<br>head&#x2F;delete:<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD">HTTP HEAD方法请求资源的头部信息，并且这些头部与HTTP GET方法请求时返回的一致</a><a href="https://bing.com/search?q=head%E6%96%B9%E6%B3%95">1</a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD">2</a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD">。HEAD方法不会返回实体主体，只用于获取资源的元信息，比如修改日期，内容类型等</a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD">2</a><a href="https://www.runoob.com/http/http-methods.html">3</a><a href="https://www.runoob.com/http/http-methods.html">。HEAD方法是幂等的，也就是说多次请求同一个资源不会改变服务器的状态</a><a href="https://www.runoob.com/http/http-methods.html">3</a>。<br>delete:请求服务器删除指定的资源<br>options:用来查询针对请求url指定资源支持的方法<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677764213599-787cb398-1e5e-4523-b61e-f4626dd57a20.png#averageHue=%23f6f6f6&clientId=u7887007a-fbef-4&from=paste&height=258&id=u24051475&originHeight=323&originWidth=858&originalType=binary&ratio=1&rotation=0&showTitle=false&size=66569&status=done&style=none&taskId=u55bebc9b-2972-448e-a013-b7ef8f5eb18&title=&width=686.4" alt="image.png"></p><h4 id="状态码："><a href="#状态码：" class="headerlink" title="状态码："></a>状态码：</h4><p>是用来表示网页服务器超文本传输协议响应状态的3为数字代码，<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677764466345-b5dd5a0d-69aa-42c2-bd8c-bf936a6fd768.png#averageHue=%23bfc1bf&clientId=u7887007a-fbef-4&from=paste&height=343&id=u884bd248&originHeight=429&originWidth=817&originalType=binary&ratio=1&rotation=0&showTitle=false&size=314238&status=done&style=none&taskId=u3d8eef72-ddf4-4904-943d-c098225660c&title=&width=653.6" alt="image.png"><br> <img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677764575420-3b4cb7e4-0c39-4870-b653-0d0998987e01.png#averageHue=%23e5e7e9&clientId=u7887007a-fbef-4&from=paste&height=232&id=u7592fba7&originHeight=290&originWidth=859&originalType=binary&ratio=1&rotation=0&showTitle=false&size=109851&status=done&style=none&taskId=u71cc218e-0dbd-4ece-9f39-01391e1fc1c&title=&width=687.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677764697905-95e793e0-9684-4d38-9036-89f9a92b4b60.png#averageHue=%23fcfcfa&clientId=u7887007a-fbef-4&from=paste&height=265&id=u6b9a3364&originHeight=331&originWidth=746&originalType=binary&ratio=1&rotation=0&showTitle=false&size=143544&status=done&style=none&taskId=u25e538aa-b021-4302-8c44-37d87e75e23&title=&width=596.8" alt="image.png"><br><a href="https://seo.juziseo.com/doc/http_code/206">HTTP状态码206表示该服务器已经成功处理了部分GET请求</a><a href="https://bing.com/search?q=http%E7%8A%B6%E6%80%81%E7%A0%81206">1</a><a href="https://seo.juziseo.com/doc/http_code/206">2</a><a href="https://www.php.cn/http/http-http206.html">3</a><a href="https://seo.juziseo.com/doc/http_code/206">。这种响应通常用于实现断点续传或者将一个大文档分解为多个下载段同时下载</a><a href="https://bing.com/search?q=http%E7%8A%B6%E6%80%81%E7%A0%81206">1</a><a href="https://seo.juziseo.com/doc/http_code/206">2</a><a href="https://www.cnblogs.com/chenpingzhao/p/5797506.html">。响应中会包含一个Content-Range头部，指明返回的数据范围和资源的总大小</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677764887922-d0d0c1fe-fd16-4a31-a7f8-23500327f4c7.png#averageHue=%23e2e4e2&clientId=u7887007a-fbef-4&from=paste&height=294&id=udee882bd&originHeight=368&originWidth=799&originalType=binary&ratio=1&rotation=0&showTitle=false&size=137747&status=done&style=none&taskId=ud34683c9-4596-40de-81e6-1ad8afcdfc5&title=&width=639.2" alt="image.png"><br><a href="https://www.nss.com.tw/301-redirect/">HTTP状态码301表示永久重定向，即请求的资源已经被永久地移动到了另一个URL，客户端应该使用新的URL来访问资源</a><a href="https://www.nss.com.tw/301-redirect/">1</a><a href="https://www.php.cn/http/http-http301.html">2</a><a href="https://www.jianshu.com/p/e82fbca7f682">3</a><a href="https://www.nss.com.tw/301-redirect/">。这种响应通常用于网站域名变更或者页面合并等情况</a><a href="https://www.nss.com.tw/301-redirect/">1</a><a href="https://www.jianshu.com/p/e82fbca7f682">3</a><a href="https://www.php.cn/http/http-http301.html">。使用301重定向可以使得搜索引擎在抓取新内容的同时将旧的网址替换为重定向后的网址</a><a href="https://www.php.cn/http/http-http301.html">2</a><a href="https://www.jianshu.com/p/e82fbca7f682">3</a>。<br><a href="https://www.nss.com.tw/301-redirect/">HTTP状态码302表示临时重定向，即请求的资源暂时地移动到了另一个URL，客户端应该继续使用原有的URL来访问资源</a><a href="https://www.nss.com.tw/301-redirect/">1</a><a href="https://www.php.cn/http/http-http301.html">2</a><a href="https://www.jianshu.com/p/e82fbca7f682">3</a><a href="https://www.nss.com.tw/301-redirect/">。这种响应通常用于临时性的跳转或者负载均衡等情况</a><a href="https://www.nss.com.tw/301-redirect/">1</a><a href="https://stackoverflow.com/questions/1393280/http-redirect-301-permanent-vs-302-temporary">4</a><a href="https://www.php.cn/http/http-http301.html">。使用302重定向可以使得搜索引擎会抓取新的内容却保留旧的网址</a><a href="https://www.php.cn/http/http-http301.html">2</a><a href="https://www.jianshu.com/p/e82fbca7f682">3</a>。<a href="https://blog.csdn.net/ai2000ai/article/details/80242193">http状态码301和302详解及区别_302状态码_幽雨雨幽的博客-CSDN博客</a><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677765766541-463f2a75-2100-4fde-9df9-fef8fe6192a3.png#averageHue=%23fffffd&clientId=u7887007a-fbef-4&from=paste&height=270&id=ue1cb4860&originHeight=338&originWidth=774&originalType=binary&ratio=1&rotation=0&showTitle=false&size=81057&status=done&style=none&taskId=u64375e59-53ad-4763-8392-c91d6d7cbf6&title=&width=619.2" alt="image.png"></p><h4 id="Cookie和Session："><a href="#Cookie和Session：" class="headerlink" title="Cookie和Session："></a>Cookie和Session：</h4><p> <img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677766633861-a7a070ec-ba72-4e9e-9755-33d360ed314c.png#averageHue=%23efefef&clientId=u7887007a-fbef-4&from=paste&height=282&id=u8aee65f0&originHeight=352&originWidth=817&originalType=binary&ratio=1&rotation=0&showTitle=false&size=108631&status=done&style=none&taskId=u3e4abd7e-4eec-4c38-81e8-9ec22de9e74&title=&width=653.6" alt="image.png"><br>查看cookie的方法：f12打开开发者模式，在Console 输入javascript:alert(document.cookie)然后回车。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677768390595-e36d7d71-db48-4bfe-b931-49e12ad7ad25.png#averageHue=%23faf9f9&clientId=u7887007a-fbef-4&from=paste&height=326&id=ua56fbf09&originHeight=407&originWidth=657&originalType=binary&ratio=1&rotation=0&showTitle=false&size=74341&status=done&style=none&taskId=u7b7a270e-6502-44b5-84f2-a08571258c0&title=&width=525.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677768490148-59334cb7-1fce-4fc8-9c38-a1578d3cce60.png#averageHue=%23f6f6f5&clientId=u7887007a-fbef-4&from=paste&height=218&id=u442fbede&originHeight=272&originWidth=972&originalType=binary&ratio=1&rotation=0&showTitle=false&size=140027&status=done&style=none&taskId=u95b79575-9824-4931-b65f-a13d892f12b&title=&width=777.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677768548919-f8bbb08a-d319-41a9-9d91-edaf3ca46cf2.png#averageHue=%23f2f1f1&clientId=u7887007a-fbef-4&from=paste&height=298&id=u85d49e1c&originHeight=372&originWidth=921&originalType=binary&ratio=1&rotation=0&showTitle=false&size=110290&status=done&style=none&taskId=u202cec5b-c7ca-4619-9134-01e608c26ca&title=&width=736.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677768568178-7f37220c-1306-4bd9-ab7b-7848486cd96c.png#averageHue=%23f5f3f3&clientId=u7887007a-fbef-4&from=paste&height=338&id=u5e17fe6d&originHeight=423&originWidth=979&originalType=binary&ratio=1&rotation=0&showTitle=false&size=94012&status=done&style=none&taskId=u91099fea-ca01-43a2-9166-4ea73e26a44&title=&width=783.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677768642573-4ba70cff-6014-4886-b9f6-b1722718ff9a.png#averageHue=%23f7f4f3&clientId=u7887007a-fbef-4&from=paste&height=255&id=ubc89c6ff&originHeight=319&originWidth=953&originalType=binary&ratio=1&rotation=0&showTitle=false&size=81138&status=done&style=none&taskId=ucd94f1aa-cf15-4f0e-aae0-000df67db1b&title=&width=762.4" alt="image.png">  <img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677768857410-8a0ecb6a-1b29-4bd4-bd58-1242d762a6b0.png#averageHue=%23f7f4f4&clientId=u7887007a-fbef-4&from=paste&height=253&id=u660905ce&originHeight=316&originWidth=761&originalType=binary&ratio=1&rotation=0&showTitle=false&size=67413&status=done&style=none&taskId=u19f16db6-6e1c-41b2-b81e-1d83b03505c&title=&width=608.8" alt="image.png"></p><h2 id="HTTP协议结构和通讯原理："><a href="#HTTP协议结构和通讯原理：" class="headerlink" title="HTTP协议结构和通讯原理："></a>HTTP协议结构和通讯原理：</h2><h4 id="字符集和编码："><a href="#字符集和编码：" class="headerlink" title="字符集和编码："></a>字符集和编码：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677818600523-1fa1ab32-9bc8-42b7-babd-91305ed12fd9.png#averageHue=%23c56b55&clientId=ua7347f47-9661-4&from=paste&height=314&id=uc3510ad9&originHeight=392&originWidth=660&originalType=binary&ratio=1&rotation=0&showTitle=false&size=83533&status=done&style=none&taskId=u394a59c1-0323-453d-8d39-8d4bdb61690&title=&width=528" alt="image.png"></p><h5 id="字符表，字符集，编码方式："><a href="#字符表，字符集，编码方式：" class="headerlink" title="字符表，字符集，编码方式："></a>字符表，字符集，编码方式：</h5><p><a href="https://blog.csdn.net/m0_65931372/article/details/123636069">根据搜索结果</a><a href="https://blog.csdn.net/m0_65931372/article/details/123636069">1</a><a href="https://blog.csdn.net/weixin_44198965/article/details/93125017">2</a><a href="https://www.zhihu.com/question/21887246">3</a>，字符集，字符表可以简单地理解为：</p><ul><li>字符集是一些自然语言中的字符组成的集合，例如ASCII字符集包括了英文字母、数字、标点符号等。</li><li>字符表是字符集中的每个字符对应的一个唯一编号，例如ASCII字符表中A对应65，B对应66等。</li><li>编码方式是将字符表中的编号转换为二进制或其他形式的数据，以便在计算机中存储和传输。例如ASCII编码方式是将每个编号用一个字节（8位）来表示，UTF-8编码方式是将每个编号用不同长度的字节序列来表示。</li></ul><p>简单地说，字符集是定义了哪些字符存在，字符表是给每个字符分配了一个编号，编码方式是给每个编号分配了一个数据表示。</p><h5 id="编码方式："><a href="#编码方式：" class="headerlink" title="编码方式："></a>编码方式：</h5><p><a href="https://zhuanlan.zhihu.com/p/165989439">编码方式的编码规范是指在使用某种字符集时，如何将字符转换为二进制数据的规则。不同的编码方式可能对应不同的字符集，也可能对应同一种字符集。例如，ASCII、ISO-8859-1、GB2312、GBK等都是既表示了字符集又表示了对应的编码方式，但Unicode字符集是特例，它对应的编码方式有UTF-8、UTF-16、UTF-32等</a><a href="https://bing.com/search?q=%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%E7%9A%84%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83">1</a><a href="https://zhuanlan.zhihu.com/p/165989439">2</a>。<br><a href="https://zhuanlan.zhihu.com/p/165989439">遵循编码方式的编码规范可以帮助程序员保证数据的正确传输和存储，避免出现乱码或数据丢失的问题。</a><br><a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1">ISO-8859-1是一种字符编码方式，它对应的字符集是ISO&#x2F;IEC 8859的第一部，也称为“拉丁字母第1部”。它包含了191个拉丁字母，可以用于表示美洲、西欧、大洋洲和非洲的多种语言。它也是一些流行的8位字符集和Unicode字符集的前两个区块的基础</a><a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1">1</a><a href="https://qastack.jp/programming/7048745/what-is-the-difference-between-utf-8-and-iso-8859-1">2</a>。<br><a href="https://qastack.jp/programming/7048745/what-is-the-difference-between-utf-8-and-iso-8859-1">ISO-8859-1在1999年被更新为ISO-8859-15，它增加了一些法语和芬兰语所需的字符和欧元符号€，这些在ISO-8859-1中缺失。为了腾出空间，它删除了一些不常用的字符，如¤、¦、¨、´、¸、¼、½和¾等</a><a href="https://qastack.jp/programming/7048745/what-is-the-difference-between-utf-8-and-iso-8859-1">2</a></p><h4 id="URL的编码和解码："><a href="#URL的编码和解码：" class="headerlink" title="URL的编码和解码："></a>URL的编码和解码：</h4><h5 id="编码："><a href="#编码：" class="headerlink" title="编码："></a>编码：</h5><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677819647684-bf6f2006-1121-4af0-b70a-8a259340bf5c.png#averageHue=%23eeeeee&clientId=ua7347f47-9661-4&from=paste&height=212&id=uefe00083&originHeight=265&originWidth=878&originalType=binary&ratio=1&rotation=0&showTitle=false&size=95674&status=done&style=none&taskId=uc77532a4-fab3-49cb-a206-5bea7056202&title=&width=702.4" alt="image.png"></p><h5 id="URL编码是一种将URL中的字符转换为可通过因特网传输的格式的方法。URL只能使用ASCII字符集通过因特网进行发送，但URL通常包含ASCII集之外的字符，例如中文、空格、符号等。因此，必须将这些字符替换为以-开头后跟十六进制数字的编码12。"><a href="#URL编码是一种将URL中的字符转换为可通过因特网传输的格式的方法。URL只能使用ASCII字符集通过因特网进行发送，但URL通常包含ASCII集之外的字符，例如中文、空格、符号等。因此，必须将这些字符替换为以-开头后跟十六进制数字的编码12。" class="headerlink" title="URL编码是一种将URL中的字符转换为可通过因特网传输的格式的方法。URL只能使用ASCII字符集通过因特网进行发送，但URL通常包含ASCII集之外的字符，例如中文、空格、符号等。因此，必须将这些字符替换为以%开头后跟十六进制数字的编码12。"></a><a href="https://www.w3school.com.cn/tags/html_ref_urlencode.asp">URL编码是一种将URL中的字符转换为可通过因特网传输的格式的方法。URL只能使用ASCII字符集通过因特网进行发送，但URL通常包含ASCII集之外的字符，例如中文、空格、符号等。因此，必须将这些字符替换为以%开头后跟十六进制数字的编码</a><a href="https://www.w3school.com.cn/tags/html_ref_urlencode.asp">1</a><a href="http://www.esjson.com/urlEncode.html">2</a>。</h5><p>例如，URL <a href="https://www.bing.com/search?q=%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F">https://www.bing.com/search?q=编码方式</a> 的编码方式是 https%3A%2F%2F<a href="http://www.bing.com%2Fsearch%3Fq%3D%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F">www.bing.com%2Fsearch%3Fq%3D%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F</a> 。可以看到，冒号、斜杠、等号和中文都被转换为了编码<a href="https://bing.com/search?q=URL%E7%BC%96%E7%A0%81">3</a></p><h5 id="编码规范："><a href="#编码规范：" class="headerlink" title="%编码规范："></a>%编码规范：</h5><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677819820193-71dc3dd0-62b1-4a4c-a9a4-fb1c3f036598.png#averageHue=%23ececec&clientId=ua7347f47-9661-4&from=paste&height=217&id=u8fcdebac&originHeight=271&originWidth=877&originalType=binary&ratio=1&rotation=0&showTitle=false&size=108723&status=done&style=none&taskId=ub35e9faa-17dc-4c85-a568-bced276238b&title=&width=701.6" alt="image.png"><a href="https://zhuanlan.zhihu.com/p/138433466">%编码规范是一种将URL中的特殊字符转换为以%开头后跟十六进制数字的编码的方法。这样可以避免URL中的字符被误解或损坏，同时也可以支持多种语言和字符集</a><a href="https://zhuanlan.zhihu.com/p/138433466">1</a>。<br>%编码规范遵循以下原则：</p><ul><li>保留字符：有些字符在URL中有特殊含义，例如冒号、斜杠、问号等。这些字符不应该被编码，除非它们作为数据出现在URL中。保留字符的编码方式是将它们的ASCII值转换为十六进制，并在前面加上%。</li><li>非保留字符：有些字符在URL中没有特殊含义，例如字母、数字、下划线等。这些字符不需要被编码，但如果要编码，也可以使用和保留字符相同的方法。</li><li>不安全字符：有些字符在URL中可能会引起歧义或错误，例如空格、引号、加号等。这些字符必须被编码，使用和保留字符相同的方法。</li><li><a href="https://zhuanlan.zhihu.com/p/372986600">国际化字符：有些语言使用非ASCII的字符集，例如中文、日文等。这些字符不能直接出现在URL中，必须先转换为UTF-8格式，并按照每个字节进行%编码</a><a href="https://zhuanlan.zhihu.com/p/372986600">2</a></li></ul><h4 id="http身份认证："><a href="#http身份认证：" class="headerlink" title="http身份认证："></a>http身份认证：</h4><p>HTTP身份认证是一种HTTP协议提供的身份验证机制，用于保护服务器上的资源，只允许合法的客户端访问。HTTP身份认证有四种类型：</p><ul><li>基本认证（Basic Authentication）：客户端向服务器发送用户名和密码，经过Base64编码后放在Authorization头中。这种方式简单易用，但不安全，因为用户名和密码容易被截获或破解。</li><li>摘要认证（Digest Authentication）：客户端向服务器发送用户名和一个加密后的摘要（digest），包含了请求方法、URL、随机数等信息。这种方式比基本认证更安全，因为不需要传输明文密码，但仍然存在一些缺陷，如重放攻击等。</li><li>NTLM认证（NT LAN Manager Authentication）：客户端和服务器之间进行三次握手，交换随机数、散列值等信息，以验证彼此的身份。这种方式是微软开发的一种专有协议，主要用于Windows系统中，具有较高的安全性和效率。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Authentication">OAuth认证（Open Authorization）：客户端通过第三方授权服务（如Google、Facebook等）获取一个令牌（token），然后将令牌发送给服务器，以表明自己拥有访问资源的权限。这种方式是目前最流行的一种认证方式，可以实现跨平台、跨域的授权访问</a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Authentication">1</a><a href="https://blog.csdn.net/weweeeeeeee/article/details/95339186">2</a><a href="https://www.cnblogs.com/chenrong/articles/5818498.html">3</a><a href="https://zhuanlan.zhihu.com/p/64584734">4</a>。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677821772382-37a5a5b4-7268-4c27-b112-1e45f3d685d2.png#averageHue=%23f0f0f0&clientId=ua7347f47-9661-4&from=paste&height=237&id=u411dbd80&originHeight=296&originWidth=305&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28500&status=done&style=none&taskId=udfd94152-1801-43e3-bae3-6eb0877d832&title=&width=244" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677821811010-449d44d6-1d3e-41b2-9509-d88745acaa54.png#averageHue=%23f8f7f6&clientId=ua7347f47-9661-4&from=paste&height=360&id=ue4d2f3f3&originHeight=450&originWidth=754&originalType=binary&ratio=1&rotation=0&showTitle=false&size=71468&status=done&style=none&taskId=ue850e651-9090-438c-91b1-d464fff9d55&title=&width=603.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677821844183-43c03732-cfdd-43bb-943d-769dfda8f2c8.png#averageHue=%23dbd5d0&clientId=ua7347f47-9661-4&from=paste&height=254&id=u8b851a15&originHeight=318&originWidth=680&originalType=binary&ratio=1&rotation=0&showTitle=false&size=79393&status=done&style=none&taskId=udec5302f-dff2-490a-a218-4529b6845c2&title=&width=544" alt="image.png"></p><h5 id="Basic认证："><a href="#Basic认证：" class="headerlink" title="Basic认证："></a>Basic认证：</h5><p>Basic认证是一种较为简单的HTTP认证方式，客户端通过明文（Base64编码格式）传输用户名和密码到服务端进行认证，通常需要配合HTTPS来保证信息传输的安全<a href="https://www.cnblogs.com/xiaoxiaotank/p/11009796.html">1</a><a href="https://www.cnblogs.com/xy-ouyang/p/12600055.html">2</a><a href="https://www.cnblogs.com/xiaoxiaotank/p/11009796.html">3</a>。Basic认证的过程如下：</p><ul><li>客户端发送HTTP请求给服务器，请求受保护的资源。</li><li>服务器返回401状态码，要求客户端提供用户名和密码进行认证，并在WWW-Authenticate头中指定认证类型为Basic。</li><li>客户端将用户名和密码用冒号连接，然后用Base64编码，放在Authorization头中，再次发送请求给服务器。</li><li>服务器验证Authorization头中的用户名和密码是否正确，如果正确则返回200状态码和请求的资源，否则返回401状态码并拒绝访问<a href="https://www.cnblogs.com/xy-ouyang/p/12600055.html">2</a><a href="https://blog.csdn.net/Dontla/article/details/124339406">4</a><a href="https://juejin.cn/post/6844903586405564430">5</a>。</li></ul><h5 id="DIGEST认证："><a href="#DIGEST认证：" class="headerlink" title="DIGEST认证："></a>DIGEST认证：</h5><p><a href="https://www.cnblogs.com/xy-ouyang/p/12609387.html">http digest认证是一种HTTP协议的认证方式，它是为了修复基本认证的缺陷而设计的，不会通过明文发送密码，而是通过密码摘要进行认证</a><a href="https://www.cnblogs.com/xy-ouyang/p/12609387.html">1</a><a href="https://www.codenong.com/cs109691608/">2</a><a href="https://www.cnblogs.com/xiaoxiaotank/p/11078571.html">3</a><a href="https://www.cnblogs.com/xy-ouyang/p/12609387.html">。它的认证过程大致如下</a><a href="https://www.cnblogs.com/xy-ouyang/p/12609387.html">1</a><a href="https://www.codenong.com/cs109691608/">2</a><a href="https://blog.csdn.net/u013238950/article/details/51392992">4</a>：</p><ul><li>客户端发送请求到服务器</li><li>服务器返回401状态码，并在WWW-Authenticate头中包含一个随机数nonce，一个域realm和一个算法列表</li><li>客户端根据算法列表和nonce计算出密码摘要，并在Authorization头中发送给服务器</li><li>服务器根据相同的算法和nonce验证密码摘要是否正确，如果正确则返回200状态码和请求的资源</li></ul><p>httpdigest认证相比基本认证更安全，但仍然有一些局限性，例如不能保护其他内容，容易受到重放攻击等。</p><h5 id="SSL客户端认证："><a href="#SSL客户端认证：" class="headerlink" title="SSL客户端认证："></a>SSL客户端认证：</h5><p><a href="https://blog.csdn.net/soarheaven/article/details/78784848">SSL客户端认证是一种SSL协议的认证方式，它是在服务器认证的基础上，增加了客户端的身份验证，实现了双向认证</a><a href="https://blog.csdn.net/soarheaven/article/details/78784848">1</a><a href="https://zhuanlan.zhihu.com/p/143590936">2</a><a href="https://zhuanlan.zhihu.com/p/330393659">3</a><a href="https://blog.csdn.net/soarheaven/article/details/78784848">。它的认证过程大致如下</a><a href="https://blog.csdn.net/soarheaven/article/details/78784848">1</a><a href="https://zhuanlan.zhihu.com/p/143590936">2</a>:</p><ul><li>客户端发送请求到服务器</li><li>服务器返回自己的服务器证书给客户端，并要求客户端提供客户端证书</li><li>客户端验证服务器证书是否有效，如果有效则选择一个密码算法和随机数，并用服务器公钥加密发送给服务器</li><li>客户端从本地或浏览器中选择一个合适的客户端证书，并用私钥签名发送给服务器</li><li>服务器验证客户端证书是否有效，如果有效则用私钥解密得到密码算法和随机数，并用这些信息生成对称密钥</li><li>服务器和客户端使用对称密钥进行加密通信</li></ul><p>SSL客户端认证相比单向认证更安全，但也更复杂，需要为每个客户端颁发和管理数字证书</p><h5 id="基于表单的验证方法："><a href="#基于表单的验证方法：" class="headerlink" title="基于表单的验证方法："></a>基于表单的验证方法：</h5><p><a href="https://www.cnblogs.com/mengdd/p/3151098.html">基于表单的验证方法是一种常见的Web应用程序的身份验证方式，它是通过用户在表单中输入用户名和密码等信息，然后提交给服务器进行验证，如果验证通过则允许用户访问受保护的资源</a><a href="https://www.cnblogs.com/mengdd/p/3151098.html">1</a><a href="https://www.runoob.com/js/js-validation.html">2</a><a href="https://cloud.tencent.com/developer/article/2219902">3</a>。它的验证过程大致如下<a href="https://www.cnblogs.com/mengdd/p/3151098.html">1</a>:</p><ul><li>用户访问需要身份验证的页面</li><li>服务器返回一个包含表单的页面，要求用户输入用户名和密码等信息</li><li>用户在表单中填写信息，并点击提交按钮</li><li>服务器接收到表单数据，并与数据库或其他存储方式进行比对，如果匹配则返回成功页面，否则返回失败页面</li></ul><p>基于表单的验证方法相比其他方法更灵活和易用，但也需要注意一些安全问题，例如防止跨站脚本攻击、跨站请求伪造攻击、暴力破解攻击等。</p><h4 id="长连接和短链接："><a href="#长连接和短链接：" class="headerlink" title="长连接和短链接："></a>长连接和短链接：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677822863812-1b22c583-b4d5-47e5-8c4a-badab568c1d5.png#averageHue=%23f1f1f1&clientId=ua7347f47-9661-4&from=paste&height=188&id=ub2c638c2&originHeight=235&originWidth=873&originalType=binary&ratio=1&rotation=0&showTitle=false&size=58085&status=done&style=none&taskId=ueabc2f26-3028-42ef-841d-bb263593ed5&title=&width=698.4" alt="image.png"></p><h5 id="长连接："><a href="#长连接：" class="headerlink" title="长连接："></a>长连接：</h5><h5 id="HTTP长连接是一种HTTP协议的连接方式，它是指在一次TCP连接中可以完成多个HTTP请求和响应，而不需要每次都重新建立和断开连接123。它的优点是可以减少网络延迟和资源消耗，提高效率和性能123。它的缺点是可能会占用过多的服务器资源，导致其他客户端无法访问3。"><a href="#HTTP长连接是一种HTTP协议的连接方式，它是指在一次TCP连接中可以完成多个HTTP请求和响应，而不需要每次都重新建立和断开连接123。它的优点是可以减少网络延迟和资源消耗，提高效率和性能123。它的缺点是可能会占用过多的服务器资源，导致其他客户端无法访问3。" class="headerlink" title="HTTP长连接是一种HTTP协议的连接方式，它是指在一次TCP连接中可以完成多个HTTP请求和响应，而不需要每次都重新建立和断开连接123。它的优点是可以减少网络延迟和资源消耗，提高效率和性能123。它的缺点是可能会占用过多的服务器资源，导致其他客户端无法访问3。"></a><a href="https://zhuanlan.zhihu.com/p/45139114">HTTP长连接是一种HTTP协议的连接方式，它是指在一次TCP连接中可以完成多个HTTP请求和响应，而不需要每次都重新建立和断开连接</a><a href="https://zhuanlan.zhihu.com/p/45139114">1</a><a href="https://segmentfault.com/a/1190000015821798">2</a><a href="https://www.jianshu.com/p/56881801d02c">3</a><a href="https://zhuanlan.zhihu.com/p/45139114">。它的优点是可以减少网络延迟和资源消耗，提高效率和性能</a><a href="https://zhuanlan.zhihu.com/p/45139114">1</a><a href="https://segmentfault.com/a/1190000015821798">2</a><a href="https://www.jianshu.com/p/56881801d02c">3</a><a href="https://www.jianshu.com/p/56881801d02c">。它的缺点是可能会占用过多的服务器资源，导致其他客户端无法访问</a><a href="https://www.jianshu.com/p/56881801d02c">3</a>。</h5><p><a href="https://segmentfault.com/a/1190000015821798">在HTTP&#x2F;1.1版本中，默认的连接都是长连接，我们可以通过Connection: keep-alive字段进行指定</a><a href="https://bing.com/search?q=HTTP%E9%95%BF%E8%BF%9E%E6%8E%A5">4</a><a href="https://segmentfault.com/a/1190000015821798">2</a><a href="https://juejin.cn/post/6923887573861564423">5</a><a href="https://segmentfault.com/a/1190000015821798">。如果要关闭长连接，可以通过Connection: close字段进行指定</a><a href="https://segmentfault.com/a/1190000015821798">2</a><a href="https://segmentfault.com/a/1190000015821798">。长连接不会永久保持，它有一个保持时间，可以在不同的服务器软件中设定这个时间</a><a href="https://segmentfault.com/a/1190000015821798">2</a>.</p><h4 id="HTTP中介代理："><a href="#HTTP中介代理：" class="headerlink" title="HTTP中介代理："></a>HTTP中介代理：</h4><h5 id="代理是什么："><a href="#代理是什么：" class="headerlink" title="代理是什么："></a>代理是什么：</h5><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677895427900-26210ad9-aae6-4394-bccc-75536168735a.png#averageHue=%23fcf9f8&clientId=u531a6c9d-5dd2-4&from=paste&height=274&id=uf1d8f538&originHeight=343&originWidth=926&originalType=binary&ratio=1&rotation=0&showTitle=false&size=149537&status=done&style=none&taskId=u2bd42d31-ce00-4cd4-a022-2a89cd45adb&title=&width=740.8" alt="image.png"><br><a href="https://juejin.cn/post/6995454464119275551">HTTP中介代理是一种在客户端和服务器之间传递HTTP请求和响应的中间人</a><a href="https://juejin.cn/post/6995454464119275551">1</a><a href="https://juejin.cn/post/6963266939447836709">2</a><a href="https://juejin.cn/post/6998351770871152653">3</a><a href="https://juejin.cn/post/6998351770871152653">。HTTP代理可以用于实现缓存、过滤、负载均衡等功能</a><a href="https://juejin.cn/post/6998351770871152653">3</a>。</p><h5 id="代理的作用：抓包，FQ-匿名访问，过滤器："><a href="#代理的作用：抓包，FQ-匿名访问，过滤器：" class="headerlink" title="代理的作用：抓包，FQ,匿名访问，过滤器："></a>代理的作用：抓包，FQ,匿名访问，过滤器：</h5><p>HTTP代理的作用有以下几点<a href="https://blog.csdn.net/m0_66268916/article/details/123006916">1</a><a href="https://blog.csdn.net/mengdie666/article/details/104996122">2</a><a href="https://blog.csdn.net/weixin_40757930/article/details/124177622">3</a><a href="https://developer.mozilla.org/zh-CN/docs/web/http/overview">4</a><a href="https://www.zhihu.com/question/388303662">5</a>：</p><ul><li>突破自身IP访问限制，访问一些平时无法访问的网站或资源。</li><li>缓存常用的网页，提高访问速度和效率。</li><li>过滤不安全或不合适的网页内容，保护用户隐私和安全。</li><li>负载均衡，分担服务器压力，提高响应能力。</li><li>隐藏用户真实IP地址，保护用户身份和信息。</li></ul><h4 id="HTTP网关："><a href="#HTTP网关：" class="headerlink" title="HTTP网关："></a>HTTP网关：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677895943704-4bde1d1c-28bc-4a6b-b281-06eed830afeb.png#averageHue=%23eaeaea&clientId=u531a6c9d-5dd2-4&from=paste&height=150&id=ua03d6fe3&originHeight=188&originWidth=790&originalType=binary&ratio=1&rotation=0&showTitle=false&size=59925&status=done&style=none&taskId=u1af74c94-3632-401e-93dc-f4bcb6401e8&title=&width=632" alt="image.png"></p><p>网关连接的是使用多个不同协议。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677895995205-624db8f2-dd0f-4b0c-b03a-1400a591f899.png#averageHue=%23fbfbfb&clientId=u531a6c9d-5dd2-4&from=paste&height=258&id=u96e0f39b&originHeight=322&originWidth=665&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47808&status=done&style=none&taskId=u11268705-aafe-45a0-87ac-c6da022ceed&title=&width=532" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677896039451-5f7a7799-7afd-4169-9f18-46c53aafd438.png#averageHue=%23ededed&clientId=u531a6c9d-5dd2-4&from=paste&height=278&id=u5c97fc68&originHeight=347&originWidth=818&originalType=binary&ratio=1&rotation=0&showTitle=false&size=108521&status=done&style=none&taskId=u94ec7ce2-fa8c-49cc-af7e-9659d85b955&title=&width=654.4" alt="image.png"><br><a href="https://juejin.cn/post/6995454464119275551">HTTP网关是一种HTTP中介，它可以将HTTP请求转换为其他协议，并将响应转换回HTTP</a><a href="https://juejin.cn/post/6995454464119275551">1</a><a href="https://blog.csdn.net/B_boy_hong10/article/details/80489177">。HTTP网关可以用于连接不同的网络或系统，例如Web服务器和数据库服务器</a><a href="https://blog.csdn.net/B_boy_hong10/article/details/80489177">2</a>。<br>常见的网关：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677896357893-ea3366e7-e42a-4101-b42c-bbca69a9d206.png#averageHue=%23f4f4f4&clientId=u531a6c9d-5dd2-4&from=paste&height=276&id=u3d45bc44&originHeight=345&originWidth=635&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49244&status=done&style=none&taskId=ub8c908ec-55e0-4f83-aa9c-e117e500e04&title=&width=508" alt="image.png"></p><h4 id="HTTP缓存："><a href="#HTTP缓存：" class="headerlink" title="HTTP缓存："></a>HTTP缓存：</h4><p> <a href="https://segmentfault.com/a/1190000021716418">HTTP缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当Web缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样做可以优化浏览器性能，避免重复请求</a><a href="https://segmentfault.com/a/1190000021716418">1</a><a href="https://juejin.cn/post/6995819662558625799">2</a>。<br><a href="https://segmentfault.com/a/1190000021716418">HTTP缓存主要是通过请求和响应报文头中的对应Header信息来控制缓存策略</a><a href="https://segmentfault.com/a/1190000021716418">1</a></p><h5 id="缓存头部字段："><a href="#缓存头部字段：" class="headerlink" title="缓存头部字段："></a>缓存头部字段：</h5><p>Cache-Control:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677905626617-995ba3bd-41e5-4aff-91c0-28b48b4821f0.png#averageHue=%23f2f2f2&clientId=u531a6c9d-5dd2-4&from=paste&height=286&id=u1cacd69a&originHeight=357&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=98135&status=done&style=none&taskId=uf488712f-6a42-4f8e-a27a-4353a6dffc5&title=&width=680" alt="image.png"></p><h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires:"></a>Expires:</h5><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires">Expires是一个HTTP响应头，它包含日期&#x2F;时间，即在此时候之后，响应过期。无效的日期，比如0，代表着过去的日期，即该资源已经过期。如果在Cache-Control响应头设置了max-age或者s-max-age指令，那么Expires头会被忽略</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677905693377-74f3b005-8b4c-490e-b9d6-8ca893ec4e1e.png#averageHue=%23f2f2f2&clientId=u531a6c9d-5dd2-4&from=paste&height=161&id=u22493cd8&originHeight=201&originWidth=868&originalType=binary&ratio=1&rotation=0&showTitle=false&size=48314&status=done&style=none&taskId=u60f0dc09-9e2f-4894-a6b8-cb534e534ff&title=&width=694.4" alt="image.png"></p><h5 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified:"></a>Last-Modified:</h5><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677905752777-fd2e742f-dbd8-4ce3-9b46-dd4081d85354.png#averageHue=%23f3f3f3&clientId=u531a6c9d-5dd2-4&from=paste&height=280&id=udbca4ce7&originHeight=350&originWidth=826&originalType=binary&ratio=1&rotation=0&showTitle=false&size=76528&status=done&style=none&taskId=uaa3cb008-4e97-4096-9b7a-d2efc0f5c5f&title=&width=660.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677905907721-e3da1b86-973d-495a-9b3d-eeced75b16b8.png#averageHue=%23f3f3f3&clientId=u531a6c9d-5dd2-4&from=paste&height=270&id=u9ca63906&originHeight=337&originWidth=868&originalType=binary&ratio=1&rotation=0&showTitle=false&size=75742&status=done&style=none&taskId=udea7b5a1-5064-4af8-a0b6-6cc26aea7cd&title=&width=694.4" alt="image.png"><br><a href="https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/ETag">ETag（或称为实体标签）是HTTP响应头中的一个字段，它是资源特定版本的标识符。当内容未更改时，Web服务器不需要重新发送整个响应，因此缓存更加高效，可以节省通信带宽</a><a href="https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/ETag">1</a>。</p><h5 id="缓存工作方式："><a href="#缓存工作方式：" class="headerlink" title="缓存工作方式："></a>缓存工作方式：</h5><p><a href="https://www.jianshu.com/p/9dd577a5eae9">HTTP缓存根据工作方式分为强缓存和协商缓存。浏览器首先会判断强缓存是否命中，命中失败才会尝试进行协商缓存</a><a href="https://bing.com/search?q=HTTP%E7%BC%93%E5%AD%98%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F">1</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677906150975-4d1bd0bb-ffc7-4571-b0cb-2cb37925a21b.png#averageHue=%23f3f2f1&clientId=u531a6c9d-5dd2-4&from=paste&height=298&id=ua1426d18&originHeight=373&originWidth=882&originalType=binary&ratio=1&rotation=0&showTitle=false&size=180177&status=done&style=none&taskId=u7f95b083-fcde-4b36-bd42-c5e3e70af49&title=&width=705.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677906306259-df00a04a-a65e-496a-a1ba-d638f5f40ed1.png#averageHue=%23eeecec&clientId=u531a6c9d-5dd2-4&from=paste&height=330&id=u935207f0&originHeight=412&originWidth=923&originalType=binary&ratio=1&rotation=0&showTitle=false&size=236644&status=done&style=none&taskId=u990702c8-4685-456e-8374-18614ab7555&title=&width=738.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677906424050-a0f20371-93de-42e2-ae9e-2e34bbd97457.png#averageHue=%23eeecec&clientId=u531a6c9d-5dd2-4&from=paste&height=314&id=u2e940020&originHeight=393&originWidth=896&originalType=binary&ratio=1&rotation=0&showTitle=false&size=212607&status=done&style=none&taskId=u3b286bd1-6939-42b4-9635-44d5a3f8504&title=&width=716.8" alt="image.png"></p><h5 id="缓存改进："><a href="#缓存改进：" class="headerlink" title="缓存改进："></a>缓存改进：</h5><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677906823643-91888130-1938-49eb-9397-711e4e8e7872.png#averageHue=%23f2f2f2&clientId=u531a6c9d-5dd2-4&from=paste&height=185&id=u5b5a66f4&originHeight=231&originWidth=897&originalType=binary&ratio=1&rotation=0&showTitle=false&size=72794&status=done&style=none&taskId=u3110c9ec-ecc2-4587-8951-a80f25e96be&title=&width=717.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677906893832-ff4c6c35-c0fe-45a0-af54-b3e00a4b2702.png#averageHue=%23eaeaea&clientId=u531a6c9d-5dd2-4&from=paste&height=190&id=u3ee6d914&originHeight=238&originWidth=871&originalType=binary&ratio=1&rotation=0&showTitle=false&size=91878&status=done&style=none&taskId=u30e7c7dd-7aab-481f-a409-b6a0632dd9e&title=&width=696.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677907003895-4cff8e49-9f1a-41b8-97c3-ce07f9824b3f.png#averageHue=%23f8f4f4&clientId=u531a6c9d-5dd2-4&from=paste&height=354&id=u931ce397&originHeight=443&originWidth=962&originalType=binary&ratio=1&rotation=0&showTitle=false&size=188454&status=done&style=none&taskId=u52cff456-903c-4c4d-8d5e-01243fd540e&title=&width=769.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677907020104-24dcbc2b-9c4c-47e3-9a5e-41a73405b06e.png#averageHue=%23f7f4f4&clientId=u531a6c9d-5dd2-4&from=paste&height=300&id=uace6c0fb&originHeight=375&originWidth=951&originalType=binary&ratio=1&rotation=0&showTitle=false&size=193588&status=done&style=none&taskId=ua1ac08e1-ae96-4d3f-a4ea-0c7f0e386d8&title=&width=760.8" alt="image.png"></p><h5 id="浏览器操作对缓存的影响："><a href="#浏览器操作对缓存的影响：" class="headerlink" title="浏览器操作对缓存的影响："></a>浏览器操作对缓存的影响：</h5><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677907116199-e0c69d69-6e39-4f6c-ab41-0a8de8d159cc.png#averageHue=%23ded9d8&clientId=u531a6c9d-5dd2-4&from=paste&height=333&id=u0aac7339&originHeight=416&originWidth=957&originalType=binary&ratio=1&rotation=0&showTitle=false&size=157829&status=done&style=none&taskId=u07b31b2d-3cb4-4311-adad-daf8509fff2&title=&width=765.6" alt="image.png"></p><h4 id="内容协商机制："><a href="#内容协商机制：" class="headerlink" title="内容协商机制："></a>内容协商机制：</h4><p>HTTP内容协商机制是指通过为相同URI指向的资源提供不同的展现形式，可以使用户代理选择与用户需求相适应的最佳匹配（例如：文档使用的自然语言、图片的格式或者内容编码形式）<a href="https://bing.com/search?q=HTTP%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86%E6%9C%BA%E5%88%B6">1</a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Content_negotiation">。这种机制用于为同一URI提供资源不同的表示形式，以帮助用户代理指定最适合用户的表示形式</a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Content_negotiation">2</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677907711593-a620330a-1f7f-4f81-b127-d9a43e91719e.png#averageHue=%23e6e6e6&clientId=u531a6c9d-5dd2-4&from=paste&height=123&id=u92168ec9&originHeight=154&originWidth=860&originalType=binary&ratio=1&rotation=0&showTitle=false&size=65081&status=done&style=none&taskId=ub7d5b3e2-5e82-4d7f-b77e-3fa9b942e97&title=&width=688" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677907769066-47c7894c-0416-4431-afd7-9527deba9b30.png#averageHue=%23f3f1f1&clientId=u531a6c9d-5dd2-4&from=paste&height=381&id=u32814523&originHeight=476&originWidth=932&originalType=binary&ratio=1&rotation=0&showTitle=false&size=139582&status=done&style=none&taskId=uc8d64e65-d1c7-4e66-997c-9434b3a7a99&title=&width=745.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677907866188-33adc6b7-345d-4ca9-8628-f120cf88d4ae.png#averageHue=%23f4efef&clientId=u531a6c9d-5dd2-4&from=paste&height=370&id=u4ff8fafa&originHeight=462&originWidth=848&originalType=binary&ratio=1&rotation=0&showTitle=false&size=147849&status=done&style=none&taskId=u79028afa-77f6-462d-b6c0-0f41a1e8c5d&title=&width=678.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677907892291-771789b6-9ea3-4098-96b8-caf6cd18c73d.png#averageHue=%23f8f8f8&clientId=u531a6c9d-5dd2-4&from=paste&height=262&id=uca4d7964&originHeight=327&originWidth=531&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29536&status=done&style=none&taskId=u738fb861-a81e-4530-896d-9a73d5f1b63&title=&width=424.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677907904100-5eff3925-58c6-4bf2-91f1-0823323a033a.png#averageHue=%23faf5f4&clientId=u531a6c9d-5dd2-4&from=paste&height=282&id=u391c1a13&originHeight=353&originWidth=855&originalType=binary&ratio=1&rotation=0&showTitle=false&size=82409&status=done&style=none&taskId=u96cd708f-6822-4a2e-b113-bb32d9fd760&title=&width=684" alt="image.png"></p><h4 id="HTTP断点续传和多线程下载："><a href="#HTTP断点续传和多线程下载：" class="headerlink" title="HTTP断点续传和多线程下载："></a>HTTP断点续传和多线程下载：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677908143083-1c55e684-2a91-432d-b78d-69f0f805e64b.png#averageHue=%23e6e6e6&clientId=u531a6c9d-5dd2-4&from=paste&height=92&id=udea5cda2&originHeight=115&originWidth=815&originalType=binary&ratio=1&rotation=0&showTitle=false&size=44350&status=done&style=none&taskId=uf2836aa9-36f3-4d19-b0f2-923eb0084c7&title=&width=652" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677908182044-69914006-376c-4ef2-8d92-df124924378c.png#averageHue=%23f6f6f6&clientId=u531a6c9d-5dd2-4&from=paste&height=219&id=u21fdbd57&originHeight=274&originWidth=863&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47659&status=done&style=none&taskId=uf19f3b55-2921-4496-ba53-d29b1073032&title=&width=690.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677908223676-464c7388-b97a-43f6-b048-1869b04145e3.png#averageHue=%23f7f7f7&clientId=u531a6c9d-5dd2-4&from=paste&height=324&id=u5b6a42ea&originHeight=405&originWidth=683&originalType=binary&ratio=1&rotation=0&showTitle=false&size=52171&status=done&style=none&taskId=u1c1e9dea-525c-42b3-93cb-d40ae07ab66&title=&width=546.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677908285130-661c5d57-8693-4d48-9877-6fd75e8c6a1e.png#averageHue=%23f2f2f2&clientId=u531a6c9d-5dd2-4&from=paste&height=275&id=u09e5b27d&originHeight=344&originWidth=865&originalType=binary&ratio=1&rotation=0&showTitle=false&size=82165&status=done&style=none&taskId=u900ea7df-b1bf-4691-bbeb-3b42b066bc4&title=&width=692" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677908302076-c658d227-da8d-4a2e-8699-ec1a1641cd4b.png#averageHue=%23f3f3f3&clientId=u531a6c9d-5dd2-4&from=paste&height=242&id=u4458cb3c&originHeight=303&originWidth=745&originalType=binary&ratio=1&rotation=0&showTitle=false&size=58244&status=done&style=none&taskId=u0bc83369-5453-487a-a170-01b2bc43f1b&title=&width=596" alt="image.png"> <img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1677908369785-6b9480f0-5325-442c-a6b2-1a20f8ef6f2b.png#averageHue=%23e8e8e8&clientId=u531a6c9d-5dd2-4&from=paste&height=291&id=u552def40&originHeight=364&originWidth=860&originalType=binary&ratio=1&rotation=0&showTitle=false&size=149742&status=done&style=none&taskId=uddde50d8-f686-406b-abf7-80c1dc21d70&title=&width=688" alt="image.png"><br>多线程下载：<br>HTTP多线程下载是一种使用多个线程同时从服务器下载文件的技术。这种方法可以提高下载速度，因为它允许客户端同时从服务器请求多个数据块。<br><a href="https://chrome.google.com/webstore/detail/download-tools-multi-thre/beklnljhbalhpnbkllnbladeopnhnnfc">有几种方法可以实现HTTP多线程下载。一种方法是使用支持多线程下载的浏览器扩展程序，如Chrome的Download Tools</a><a href="https://chrome.google.com/webstore/detail/download-tools-multi-thre/beklnljhbalhpnbkllnbladeopnhnnfc">1</a><a href="https://addons.mozilla.org/en-US/firefox/addon/multithreaded-download-manager/">或Firefox的Multithreaded Download Manager</a><a href="https://addons.mozilla.org/en-US/firefox/addon/multithreaded-download-manager/">2</a><a href="https://chrome.google.com/webstore/detail/download-tools-multi-thre/beklnljhbalhpnbkllnbladeopnhnnfc">。另一种方法是使用支持多线程下载的命令行工具，如aria2</a><a href="https://chrome.google.com/webstore/detail/download-tools-multi-thre/beklnljhbalhpnbkllnbladeopnhnnfc">1</a></p><h4 id="实验使用HTTP协议的构建："><a href="#实验使用HTTP协议的构建：" class="headerlink" title="实验使用HTTP协议的构建："></a>实验使用HTTP协议的构建：</h4>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring杂项</title>
    <link href="/2024/01/26/springboot2%E6%9D%82%E9%A1%B9%EF%BC%9A/"/>
    <url>/2024/01/26/springboot2%E6%9D%82%E9%A1%B9%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h1 id="1-springboot自定义start讲解-使用SpringBoot自定义一个starter启动包，超详细-自定义starter-如何导入目标工程-CSDN博客"><a href="#1-springboot自定义start讲解-使用SpringBoot自定义一个starter启动包，超详细-自定义starter-如何导入目标工程-CSDN博客" class="headerlink" title="1.springboot自定义start讲解:使用SpringBoot自定义一个starter启动包，超详细_自定义starter 如何导入目标工程-CSDN博客"></a>1.springboot自定义start讲解:<a href="https://blog.csdn.net/languageStudent/article/details/119794955">使用SpringBoot自定义一个starter启动包，超详细_自定义starter 如何导入目标工程-CSDN博客</a></h1><h1 id="InitializingBean的作用是什么？"><a href="#InitializingBean的作用是什么？" class="headerlink" title="InitializingBean的作用是什么？"></a>InitializingBean的作用是什么？</h1><div class="code-wrapper"><pre><code class="hljs java">InitializingBean的作用是Bean注入到Spring容器且初始化后，执行特定业务化的操作。Spring允许容器中的Bean，在Bean初始化完成后或者Bean销毁前，执行特定业务化的操作，常用的实现方式有以下三种：通过实现InitializingBean/DisposableBean接口来处理初始化后/销毁前的操作；通过标签的init-method/destroy-method属性处理初始化后/销毁前的操作；在指定方法上加上<span class="hljs-meta">@PostConstruct</span>或<span class="hljs-meta">@PreDestroy</span>注解来处理初始化后/销毁前的操作。</code></pre></div><h1 id="XXXAware相关的接口："><a href="#XXXAware相关的接口：" class="headerlink" title="XXXAware相关的接口："></a>XXXAware相关的接口：</h1><h1 id="SpringBoot项目的目录结构及名规范："><a href="#SpringBoot项目的目录结构及名规范：" class="headerlink" title="SpringBoot项目的目录结构及名规范："></a>SpringBoot项目的目录结构及名规范：</h1><h2 id="目录说明"><a href="#目录说明" class="headerlink" title="目录说明"></a>目录说明</h2><div class="code-wrapper"><pre><code class="hljs java">servicex                 <span class="hljs-comment">// 项目名</span>    |- admin-ui          <span class="hljs-comment">// 管理服务前端代码(一般将UI和SERVICE放到一个工程中，便于管理)</span>    |- servicex-auth     <span class="hljs-comment">// 模块1</span>    |- servicex-common   <span class="hljs-comment">// 模块2</span>    |- servicex-gateway  <span class="hljs-comment">// 模块3</span>    |- servicex-system   <span class="hljs-comment">// 模块4</span>        |- src            |- main                  <span class="hljs-comment">// 业务逻辑</span>                |- assembly          <span class="hljs-comment">// 基于maven assembly插件的服务化打包方案</span>                    |- bin           <span class="hljs-comment">// 模块脚本(启动、停止、重启)</span>                    |- sbin          <span class="hljs-comment">// 管理员角色使用的脚本(环境检查、系统检测等等)</span>                    |- assembly.xml  <span class="hljs-comment">// 配置文件</span>                |- java              <span class="hljs-comment">// 源码</span>                    |- com                        |- hadoopx                            |- servicex                                |- system                                    |- annotation     <span class="hljs-comment">// 注解</span>                                    |- aspect         <span class="hljs-comment">// 面向切面编程</span>                                    |- config         <span class="hljs-comment">// 配置文件POJO</span>                                    |- filter         <span class="hljs-comment">// 过滤器</span>                                    |- constant       <span class="hljs-comment">// 存放常量</span>                                    |- utils          <span class="hljs-comment">// 工具</span>                                    |- exception      <span class="hljs-comment">// 异常</span>                                    |- controller     <span class="hljs-comment">// 控制层(将请求通过URL匹配，分配到不同的接收器/方法进行处理，然后返回结果)</span>                                    |- service        <span class="hljs-comment">// 服务层接口</span>                                        |- impl       <span class="hljs-comment">// 服务层实现</span>                                    |- mapper/repository <span class="hljs-comment">// 数据访问层，与数据库交互为service提供接口</span>                                    |- entity/domain     <span class="hljs-comment">// 实体对象</span>                                        |- dto <span class="hljs-comment">// 持久层需要的实体对象(用于服务层与持久层之间的数据传输对象)</span>                                        |- vo <span class="hljs-comment">// 视图层需要的实体对象(用于服务层与视图层之间的数据传输对象)</span>                                    |- *Application.java  <span class="hljs-comment">// 入口启动类</span>                |- resources         <span class="hljs-comment">// 资源</span>                    |- <span class="hljs-keyword">static</span>        <span class="hljs-comment">// 静态资源(html、css、js、图片等)</span>                    |- templates     <span class="hljs-comment">// 视图模板(jsp、thymeleaf等)</span>                    |- mapper        <span class="hljs-comment">// 存放数据访问层对应的XML配置</span>                        |- *Mapper.xml                        |- ...                    |- application.yml        <span class="hljs-comment">// 公共配置</span>                    |- application-dev.yml    <span class="hljs-comment">// 开发环境配置</span>                    |- application-prod.yml   <span class="hljs-comment">// 生产环境配置</span>                    |- banner.txt                        |- logback.xml            <span class="hljs-comment">// 日志配置</span>            |- test                  <span class="hljs-comment">// 测试源码</span>               |- java                                   |- com                        |- hadoopx                            |- servicex                                |- system                                    |- 根据具体情况按源码目录结构存放编写的测试用例        |- target     <span class="hljs-comment">// 编译打包输出目录(自动生成，不需要创建)</span>        |- pom.xml    <span class="hljs-comment">// 该模块的POM文件</span>    |- sql            <span class="hljs-comment">// 项目需要的SQL脚本</span>    |- doc            <span class="hljs-comment">// 精简版的开发、运维手册</span>    |- .gitignore     <span class="hljs-comment">// 哪些文件不用传到版本管控工具中</span>    |- pom.xml        <span class="hljs-comment">// 工程总POM文件</span>    |- README.md      <span class="hljs-comment">// 注意事项</span>External Libraries    <span class="hljs-comment">// 相关JAR包依赖</span></code></pre></div><p>(1). mapper&#x2F;repository，数据访问层，与数据库交互为service提供接口(对某个表进行增删改查，一个’<em>Mapper.java’和一个’</em>Mapper.xml’对应一张表(存在关联查询的情况)；Mybatis使用的是mapper，JPA使用的是repository)<br>(2). entity&#x2F;domain，数据实体类(Mybatis使用的是entity，JPA使用的是domain)<br>(3). POJO，VO，DTO，DO，PO，BO的含义：</p><p>POJO：是一个简单的、普通的JAVA对象，它包含业务逻辑处理或持久化逻辑等。但不是JavaBean、EntityBean等，不具有任何特殊角色，不继承或不实现任何其它JAVA框架的类或接口。可以包含类似与JavaBean属性和对属性访问的setter和getter方法的对象。<br>VO(View Object)：视图对象，用于展示层显示，代表展示层需要显示的数据。它的作用是把某个指定页面&#x2F;组件需要的所有数据封装起来。<br>DTO(Data Transfer Object)：数据传输对象，用于服务层与持久层之间的数据传输对象，代表服务层需要接收&#x2F;返回的数据。<br>DO(Domain Object)： 领域对象，就是从现实世界中抽象出来的有形或无形的实体对象。<br>PO(Persistent Object)：持久化对象，它跟持久层(通常是关系型数据库)的数据结构形成一一对应的映射关系，数据表中的每个字段(或若干个)就对应PO的一个(或若干个)属性。<br>BO(Business Object)： 业务对象，用于把业务逻辑封装为一个对象，这个对象可以包括一个或多个其它的对象。<br>POJO持久化之后 -&gt; PO；POJO传输过程中 -&gt; DTO；POJO用作表示层 -&gt; VO<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1706256016594-c1001dcc-4f05-42a9-9447-53fec5e30fba.png#averageHue=%23fafafa&clientId=u92023ef0-aba6-4&from=paste&id=u8bd8c265&originHeight=584&originWidth=876&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u92d69530-4aca-4ef1-a7e7-1236793206d&title="></p>]]></content>
    
    
    <categories>
      
      <category>springboot2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring常见注解</title>
    <link href="/2024/01/26/spring%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A/"/>
    <url>/2024/01/26/spring%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h1 id="Bean注解详解："><a href="#Bean注解详解：" class="headerlink" title="@Bean注解详解："></a>@Bean注解详解：</h1><h2 id="1-常见问题思考："><a href="#1-常见问题思考：" class="headerlink" title="1.常见问题思考："></a>1.常见问题思考：</h2><p>问题1：为啥下面我们明明使用了@Bean  注解但是在spring容器中却找不到该catDemo啊？</p><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">config</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span>  Cat catDemo()&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Cat</span>(<span class="hljs-string">&quot;小猫！&quot;</span>);    &#125;&#125;</code></pre></div><p>原因：单独一个@Bean修饰的  只是一个bean的定义，并没有注册到spring容器中！spring中要使用@Bean修饰  的bean需要将该bean注册到spring容器中！可以使用@Componet 注解  或者该注解修饰的注解将该类注册到容器中的同时连带注册@Bean 修饰的bean  .<br>解决方法：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-number">1.</span>在类上加入<span class="hljs-meta">@Componet</span>注解或者是<span class="hljs-meta">@Componet</span>注解修饰的注解，把该类注入到spring容器，然后由spring容器扫描处理<span class="hljs-meta">@Bean</span>注解修饰的方法！<span class="hljs-comment">//@Configuration</span><span class="hljs-comment">//    @Component</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">config</span> &#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span>  <span class="hljs-title class_">Cat</span> <span class="hljs-title function_">catDemo</span>(<span class="hljs-params"></span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;小猫！&quot;</span>);    &#125;&#125;<span class="hljs-comment">//其实上面的@Configuration注解其也是被@Componet注解修饰了的</span></code></pre></div><h2 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h2><p><a href="https://blog.csdn.net/goodjava2007/article/details/126961787">SpringBoot - @Bean注解详解_springboot @bean注解-CSDN博客</a><br>1.@Bean注解就是把我们将要实例化的对象转化成一个Bean，放在Spring容器中，等我们使用时，就会和@Autowired、@Resource配合到使用拿到该实例。注册BEAN的方法有@ComponentScan、@Bean、@Import、@Component、@Repository、@ Controller、@Service 、 @Configration等等。<br>2.@Bean 注解：作用在方法上，声明当前方法的返回值是一个Bean对象；单独只有这个注解修饰的方法，只是实现了对bean的一种定义，其类没有注册到spring容器中，那么该方法返回的bean也没有注册到spring容器中！<br>3.注解@Bean被声明在方法上，该方法都需要有一个返回类型，这个方法的返回类型就是注册到IOC容器中的类型，接口和类都是可以作为返回类型，介于面向接口原则，提倡返回类型为接口。该注解主要用在@Configuration注解的类的方法上，也可以用在@Component注解的类的方法上，添加的bean的id为方法名。<br>4.使用要点<br>（1）@Bean 注解：作用在方法上，方法都需要有一个返回类型；<br>（2）@Bean 注解：用于表示当前方法返回一个 Spring 容器管理的 Bean；<br>（3）@Bean 的默认的名字和方法名一致(一般Bean都是首字母小写，因为方法名的首字母一般都是小写的)；<br>（4）@Bean 注解：一般和 @Component 或者 @Configuration 一起使用；<br>（5）@Bean 注解：默认作用域为单例作用域，可通过 @Scope(“prototype”) 设置为原型作用域；<br>（6）@Bean 注解：可以接受一个 String 数组来设置多个别名；<br>（7）@Configration 注解类中可以声明多个 @Bean 的方法，并且声明的 Bean 与 Bean 之间是可以有依赖关系的；<br>5.组合使用<br>@Bean 注解常常与 @Scope、@Lazy，@DependsOn 和 @link Primary 注解一起使用：<br>（1）@Profile 注解：为不同环境下不同的配置提供了支持，如开发和生产环境的数配置是不同的；<br>（2）@Scope 注解：将 Bean 的作用域从单例改变为指定的作用域；<br>（3）@Lazy 注解：只有在默认单例作用域的情况下才有实际效果；<br>（4）@DependsOn 注解：表示在当前 Bean 创建之前需要先创建特定的其他 Bean的场景时，添加该注解。</p><h2 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHello</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;初始化...&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;销毁...&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;获取信息...&quot;</span>;    &#125;&#125;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">config</span> &#123;<span class="hljs-comment">// 下面的bean注解声明了改bean的初始化方法和销毁方法！</span>    <span class="hljs-meta">@Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)</span>    <span class="hljs-keyword">public</span> MyHello <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyHello</span>();    &#125;&#125;<span class="hljs-meta">@RestController</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<span class="hljs-comment">// 下面使用的是构造器注入bean依赖方法！当类中只有一个构造器方法时，可以省略@Autowied注解</span>    <span class="hljs-keyword">private</span> MyHello hello;    <span class="hljs-meta">@GetMapping(&quot;/test&quot;)</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;        hello.get();        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;    &#125;&#125;</code></pre></div><h1 id="Configuration："><a href="#Configuration：" class="headerlink" title="@Configuration："></a>@Configuration：</h1><p><a href="https://juejin.cn/post/7133149726592991263">【Spring注解必知必会】深度解析@Configuration注解 - 掘金</a><br>注解源码：<br>一般修饰在类上！</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Documented</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Configuration &#123;<span class="hljs-meta">@AliasFor(annotation = Component.class)</span>String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-type">boolean</span> <span class="hljs-title function_">proxyBeanMethods</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div><p><strong>属性说明：</strong></p><ul><li>value: 自定义当前组件或者说bean的名称，实际就是@Component的value属性。</li><li>proxyBeanMethods： 判断是否bean的方法应该被代理，默认是true，后面原理解析中重点分析。</li></ul><p><strong>元注解说明：</strong></p><ul><li>该注解只能使用在类，接口、枚举、其他注解上</li><li>该注解的生命周期是运行时JVM</li><li>@Component元注解，相当于拥有了@Component注解的能力，可以被ComponentScan扫描到，变成spring中的Bean。</li></ul><h3 id="proxyBeanMethods-属性："><a href="#proxyBeanMethods-属性：" class="headerlink" title="proxyBeanMethods()属性："></a>proxyBeanMethods()属性：</h3><p>1.proxyBeanMethods属性默认为true，当其值为false时，将不会进行代理处理，并且每次调用@Bean注解标注的方法时都会创建一个新的Bean实例。</p><h1 id="Component注解："><a href="#Component注解：" class="headerlink" title="@Component注解："></a>@Component注解：</h1><p>说明：<br>用来标记的类是一个“组件”或者说是一个Bean，Spring会自动扫描标记；注解的类作为一个Spring Bean对象。；该注解只能使用在类，接口，枚举，和其他注解上！<br>注解源码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Documented</span><span class="hljs-meta">@Indexed</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Component &#123;    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;&#125;</code></pre></div><p>属性说明：<br>value:自定义当前组件或者说bean的名称！如果不配置，默认为组件的首字母小写的类名！</p><h1 id="Scope："><a href="#Scope：" class="headerlink" title="@Scope："></a>@Scope：</h1><p><a href="https://juejin.cn/post/7128685478164824095">【Spring注解必知必会】全面了解@Scope - 掘金</a><br>源码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Scope &#123;<span class="hljs-meta">@AliasFor(&quot;scopeName&quot;)</span>String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-meta">@AliasFor(&quot;value&quot;)</span>String <span class="hljs-title function_">scopeName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;ScopedProxyMode <span class="hljs-title function_">proxyMode</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ScopedProxyMode.DEFAULT;&#125;</code></pre></div><p>注解有3个属性，value和scopeName一样，用来表示注解的作用于范围。proxyMode用来为spring bean设置代理。<br><strong>作用域（value或者scopeName）属性范围</strong></p><ul><li>singleton: 默认值，单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例。</li><li>prototype: 原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例。</li><li>request: 对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效。</li><li>session: 对于每次HTTP Session，使用session定义的Bean都将产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效。</li></ul><p>默认的作用域范围为singleton。<br><strong>proxyMethod属性：</strong></p><ul><li>DEFAULT：proxyMode的默认值，一般情况下等同于NO，即不需要动态代理。</li><li>NO：不需要动态代理，即返回的是Bean的实例对象。</li><li>INTERFACES：代理的对象是一个接口，即@Scope的作用对象是接口，这种情况是基于jdk实现的动态代理。</li><li>TARGET_CLASS：代理的对象是一个类，即@Scope的作用对象是一个类，上面例子中的ClassB就可以用这种代理，是以生成目标类扩展的方式创建代理，基于CGLib实现动态代理。</li></ul><p>后面通过实例来讲解下我们为什么要有这个属性。</p><h2 id="使用注解："><a href="#使用注解：" class="headerlink" title="使用注解："></a>使用注解：</h2><p>前面讲了该注解作用在类上或者方法上，但是其实它前提必须是一个Bean,所以存在下面两种情况：<br><strong>作用在类上</strong><br>搭配@Component、@Service注解</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;实例化学生对象~~~&quot;</span>);    &#125;&#125;</code></pre></div><p><strong>作用在方法上</strong><br>搭配@Bean注解使用</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScopeConfig</span> &#123;        <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span>    <span class="hljs-keyword">public</span> Student <span class="hljs-title function_">getStudent</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();    &#125;&#125;</code></pre></div><p>通常我们不配置Scope情况下的Bean的作用域都是单例模式singleton，不进行任何代理。</p><h2 id="实例演示："><a href="#实例演示：" class="headerlink" title="实例演示："></a>实例演示：</h2><p>我们前面讲解了通过Bean如何控制我们Bean的作用域范围，那我们通过例子演示验证下。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrototypeBean</span> &#123;    PrototypeBean() &#123;        System.out.println(<span class="hljs-string">&quot;实例化 PrototypeBean&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;初始化 PrototypeBean&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;销毁 PrototypeBean&quot;</span>);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)</span><span class="hljs-meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><span class="hljs-keyword">public</span> PrototypeBean <span class="hljs-title function_">prototypeBean</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrototypeBean</span>();&#125;</code></pre></div><p><strong>验证代码：</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">PrototypeBean</span> <span class="hljs-variable">prototypeBean1</span> <span class="hljs-operator">=</span> context.getBean(PrototypeBean.class);System.out.println(prototypeBean1);<span class="hljs-type">PrototypeBean</span> <span class="hljs-variable">prototypeBean2</span> <span class="hljs-operator">=</span> context.getBean(PrototypeBean.class);System.out.println(prototypeBean2);System.out.println(prototypeBean1 == prototypeBean2);context.close();</code></pre></div><p><strong>执行结果：</strong></p><div class="code-wrapper"><pre><code class="hljs java">实例化 PrototypeBean初始化 PrototypeBeancom.alvinlkk.scope.PrototypeBean@26a94fa5实例化 PrototypeBean初始化 PrototypeBeancom.alvinlkk.scope.PrototypeBean@464a4442<span class="hljs-literal">false</span></code></pre></div><p><strong>小结：</strong></p><ol><li>prototype多例模式，每次在调用getBean() 获取实例时，都会重新实例化，初始化。</li><li>prototype多例模式，它的Bean实例对象则不受IOC容器的管理，最终由GC来销毁。</li><li>ingleton单实例模式下，多次getBean()取到的对象是一样的。</li><li>针对单实例bean的话，容器启动的时候，bean的对象就创建了，而且容器销毁的时候，也会调用Bean的销毁方法。</li></ol><h1 id="ConfigurationProperties："><a href="#ConfigurationProperties：" class="headerlink" title="@ConfigurationProperties："></a>@ConfigurationProperties：</h1><p><strong>@ConfigurationProperties注解的作用是什么？</strong><br>将标注了@ConfigurationProperties注解的Spring容器中的Bean与配置文件中的属性进行一一绑定，用于更加快速、方便的读取配置文件的内容。<br>也就是：先将属性对象注册到Spring容器中，再进行属性的绑定。（正是因为该特性，即使在方法走set了某些属性，其也会被配置文件中的属性覆盖）<br><strong>@ConfigurationProperties注解可以搭配使用的注解有哪些？</strong><br>只要能够将属性对象注册到Spring容器中的注解都可以搭配使用。<br>@RestController、@Service、@Repository、@Component、@Configuration、@Bean都可以和@ConfigurationProperties注解搭配使用。<br><strong>@ConfigurationProperties注解如何使用？：</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1.</span>需要将配置对象类注入到Spring容器中，一般使用<span class="hljs-meta">@Component(组件类)</span>进行注入，当然<span class="hljs-meta">@RestController</span>、<span class="hljs-meta">@Service</span>、<span class="hljs-meta">@Repository</span>都属于<span class="hljs-meta">@Component</span>，因为他们有更准确的意义，所以一般使用<span class="hljs-meta">@Component</span>；或者不使用组件类，而是在启动类上使用<span class="hljs-meta">@EnableConfigurationProperties(DroolsProperties.class)</span>，将配置对象类注入到Spring容器中；或者在定义Bean的时候将配置信息和配置对象的属性进行一一绑定。<span class="hljs-number">2.</span>需要指定前缀，用于表示该前缀下面的配置信息需要和配置对象的属性进行一一绑定；<span class="hljs-number">3.</span>只能加载全局配置文件(application.yml/.properties，application-XXX.yml/.properties)；<span class="hljs-number">4.</span>支持 数据校验，如：不能为空，长度，正则等校验；<span class="hljs-number">5.</span>支持复杂的数据类型，如：list、map；</code></pre></div><p>①. 使用@Component + @ConfigurationProperties(prefix &#x3D; “spring.drools”)，这两个注解都标注在配置对象上。</p><div class="code-wrapper"><pre><code class="hljs java">DroolsProperties.java如下：<span class="hljs-meta">@Data</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.drools&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DroolsProperties</span> &#123;&#125;</code></pre></div><p>②. @EnableConfigurationProperties(DroolsProperties.class) + @ConfigurationProperties(prefix &#x3D; “spring.drools”) ，注意：配置对象上的注解只有@ConfigurationProperties，@EnableConfigurationProperties标注在启动类上。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.drools&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DroolsProperties</span> &#123;...&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java">MySpringApplication.java如下：<span class="hljs-meta">@EnableCustomSwagger2</span><span class="hljs-meta">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</span><span class="hljs-meta">@EnableConfigurationProperties(DroolsProperties.class)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySpringApplication</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        SpringApplication.run(MySpringApplication.class, args);    &#125;&#125;</code></pre></div><p>③. @Bean + @ConfigurationProperties(prefix &#x3D; “spring.drools”)，配置类上没有注解，在定义Bean时将将配置信息和配置对象的属性进行一一绑定。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DroolsProperties</span> &#123;...&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@EnableCustomSwagger2</span><span class="hljs-meta">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySpringApplication</span>&#123;<span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span>    <span class="hljs-keyword">public</span> DroolsProperties <span class="hljs-title function_">droolsProperties</span> <span class="hljs-params">()</span>&#123;        <span class="hljs-type">DroolsProperties</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DroolsProperties</span>();        <span class="hljs-keyword">return</span> p;    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        SpringApplication.run(MySpringApplication.class, args);    &#125;&#125;</code></pre></div><h1 id="EnableConfigurationProperties："><a href="#EnableConfigurationProperties：" class="headerlink" title="@EnableConfigurationProperties："></a>@EnableConfigurationProperties：</h1><p>@EnableConfigurationProperties注解的作用是什么？<br>将标注了@ConfigurationProperties注解的类注入到Spring容器中。该注解是用来开启对@ConfigurationProperties注解的支持。也就是@EnableConfigurationProperties注解告诉Spring容器能支持@ConfigurationProperties注解。</p><h4 id="EnableConfigurationProperties注解如何使用？"><a href="#EnableConfigurationProperties注解如何使用？" class="headerlink" title="@EnableConfigurationProperties注解如何使用？"></a>@EnableConfigurationProperties注解如何使用？</h4><p>一般情况下会定义两个文件，一个用于绑定application.xml中的配置信息，一个用于定义配置类。一般情况下@EnableConfigurationProperties搭配@Configuration和@SpringBootApplication使用！<br>①. 定义一个属性类用于绑定配置信息：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.drools&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DroolsProperties</span> &#123;    <span class="hljs-comment">// 规则文件和决策表的路径(多个目录使用逗号分割)</span>    <span class="hljs-keyword">private</span> String path;    <span class="hljs-comment">// 更新缓存的轮询周期 - 单位：秒(默认30秒)</span>    <span class="hljs-keyword">private</span> Long update;    <span class="hljs-comment">// 模式: stream 或 cloud(默认stream模式)</span>    <span class="hljs-keyword">private</span> String mode;    <span class="hljs-comment">// 是否开启监听器：true = 开, false = 关闭(默认开启)</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> listener;    <span class="hljs-comment">// 是否自动更新：true = 开, false = 关闭(默认开启)</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> autoUpdate;    <span class="hljs-comment">// 是否开启DRL的语法检查: true = 开, false = 关闭(默认开启)</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> verify;    <span class="hljs-comment">// 是否开启REDIS的缓存: true = 开, false = 关闭(默认开启)</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> useRedis;&#125;</code></pre></div><p>②. 定义一个配置类用于开启文件属性的绑定功能：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 配置类</span><span class="hljs-meta">@Configuration</span><span class="hljs-comment">// 开启属性文件绑定功能</span><span class="hljs-meta">@EnableConfigurationProperties(DroolsProperties.class)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DroolsConfig</span> &#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConditionalOnMissingBean(name = &quot;kieTemplate&quot;)</span>    <span class="hljs-keyword">public</span> KieTemplate <span class="hljs-title function_">kieTemplate</span><span class="hljs-params">(DroolsProperties droolsProperties)</span> &#123;        <span class="hljs-type">KieTemplate</span> <span class="hljs-variable">kieTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KieTemplate</span>();        kieTemplate.setPath(droolsProperties.getPath());        kieTemplate.setMode(droolsProperties.getMode());        <span class="hljs-keyword">if</span> (droolsProperties.isAutoUpdate()) &#123;            <span class="hljs-comment">// 启用自动更新</span>            kieTemplate.setUpdate(droolsProperties.getUpdate());        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 关闭自动更新</span>            kieTemplate.setUpdate(<span class="hljs-number">999999L</span>);        &#125;        kieTemplate.setListener(droolsProperties.isListener());        kieTemplate.setVerify(droolsProperties.isVerify());        kieTemplate.setUseRedis(droolsProperties.isUseRedis());        <span class="hljs-keyword">return</span> kieTemplate;    &#125;&#125;</code></pre></div><h1 id="Import-注解："><a href="#Import-注解：" class="headerlink" title="@Import  注解："></a>@Import  注解：</h1><p><a href="https://juejin.cn/post/6844904035212853255">spring注解之@Import注解的三种使用方式 - 掘金</a></p><h2 id="Import注解须知："><a href="#Import注解须知：" class="headerlink" title="@Import注解须知："></a>@Import注解须知：</h2><p>1、@Import只能用在类上 ，@Import通过快速导入的方式实现把实例加入spring的IOC容器中<br> 2、加入IOC容器的方式有很多种，@Import注解就相对很牛皮了，@Import注解可以用于导入第三方包 ，当然@Bean注解也可以，但是@Import注解快速导入的方式更加便捷<br>3、@Import注解有三种用法<br>该注解主要是将第三方包注入IOC容器中！@Import  注入的容器明明都有相关注解了为什么还需要额外的@Import  的注解了？<br>那是因为spring启动类能扫描到的注范围有限！使用该注解可以让spring启动类扫描到第三方包里面的相关注解！</p><h2 id="简单示例分析："><a href="#简单示例分析：" class="headerlink" title="简单示例分析："></a>简单示例分析：</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1706236949138-31227e0f-85e0-4ad7-adf3-aa268aa0bd25.png#averageHue=%2338412f&clientId=u6dce0a89-1589-4&from=paste&height=542&id=ue181bef1&originHeight=678&originWidth=1513&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=280744&status=done&style=none&taskId=uac5270f1-4578-4320-ac05-3f57b81380c&title=&width=1210.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1706236967445-7bac6f8f-73fa-482e-bc87-16c1d9e60933.png#averageHue=%2327282b&clientId=u6dce0a89-1589-4&from=paste&height=82&id=u738d1ee4&originHeight=102&originWidth=743&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=29588&status=done&style=none&taskId=uea926173-eff2-4e85-92a1-923cabd8a43&title=&width=594.4" alt="image.png"></p><h2 id="Import的三种用法"><a href="#Import的三种用法" class="headerlink" title="@Import的三种用法:"></a>@Import的三种用法:</h2><p>1、直接填class数组方式 2、ImportSelector方式【重点】 3、ImportBeanDefinitionRegistrar方式</p><h4 id="第一种用法：直接填class数组"><a href="#第一种用法：直接填class数组" class="headerlink" title="第一种用法：直接填class数组:"></a>第一种用法：直接填class数组:</h4><p><strong>直接填对应的class数组，class数组可以有0到多个。</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Import(&#123; 类名.class , 类名.class... &#125;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span> &#123;&#125;</code></pre></div><p>对应的import的bean都将加入到spring容器中，这些在容器中bean名称是该类的<strong>全类名</strong></p><h4 id="第二种用法：ImportSelector方式"><a href="#第二种用法：ImportSelector方式" class="headerlink" title="第二种用法：ImportSelector方式"></a>第二种用法：ImportSelector方式</h4><p>这种方式的前提就是一个类要实现ImportSelector接口，假如我要用这种方法，目标对象是Myclass这个类，分析具体如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportSelector</span> &#123;<span class="hljs-comment">//既然是接口肯定要实现这个接口的方法</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">0</span>];    &#125;&#125;</code></pre></div><p>分析实现接口的selectImports方法中的：</p><ul><li>1、返回值： 就是我们实际上要导入到容器中的组件全类名【<strong>重点</strong> 】</li><li>2、参数： AnnotationMetadata表示当前被@Import注解给标注的所有注解信息【不是重点】</li></ul><p>需要注意的是selectImports方法可以返回空数组但是不能返回null，否则会报空指针异常！</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportSelector</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;com.yc.Test.TestDemo3&quot;</span>&#125;;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Import(&#123;TestDemo2.class,Myclass.class&#125;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span> &#123;        <span class="hljs-meta">@Bean</span>        <span class="hljs-keyword">public</span> AccountDao2 <span class="hljs-title function_">accountDao2</span><span class="hljs-params">()</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountDao2</span>();        &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 打印容器中的组件测试</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationTestDemo</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        AnnotationConfigApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(TestDemo.class);  <span class="hljs-comment">//这里的参数代表要做操作的类</span>        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();        <span class="hljs-keyword">for</span> (String name : beanDefinitionNames)&#123;            System.out.println(name);        &#125;    &#125;&#125;</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1706237214771-919eec07-d755-4b67-ae79-23178c870d1e.png#averageHue=%23f9f7f6&clientId=u6dce0a89-1589-4&from=paste&id=u6f855391&originHeight=515&originWidth=1904&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=103279&status=done&style=none&taskId=uf3323c8a-7efb-418d-b74d-a40b172bb25&title=" alt="image.png"></p><h4 id="第三种用法：ImportBeanDefinitionRegistrar方式"><a href="#第三种用法：ImportBeanDefinitionRegistrar方式" class="headerlink" title="第三种用法：ImportBeanDefinitionRegistrar方式:"></a>第三种用法：ImportBeanDefinitionRegistrar方式:</h4><p>这种用法比较自定义化注册:</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportBeanDefinitionRegistrar</span> &#123;<span class="hljs-comment">//该实现方法默认为空</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry)</span> &#123;          &#125;&#125;</code></pre></div><p>参数分析：</p><ul><li>第一个参数：annotationMetadata 和之前的ImportSelector参数一样都是表示当前被@Import注解给标注的所有注解信息</li><li>第二个参数表示用于注册定义一个bean<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportBeanDefinitionRegistrar</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry)</span> &#123;        <span class="hljs-comment">//指定bean定义信息（包括bean的类型、作用域...）</span>        <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">rootBeanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(TestDemo4.class);        <span class="hljs-comment">//注册一个bean指定bean名字（id）</span>        beanDefinitionRegistry.registerBeanDefinition(<span class="hljs-string">&quot;TestDemo4444&quot;</span>,rootBeanDefinition);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Import(&#123;TestDemo2.class,Myclass.class,Myclass2.class&#125;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span> &#123;        <span class="hljs-meta">@Bean</span>        <span class="hljs-keyword">public</span> AccountDao2 <span class="hljs-title function_">accountDao222</span><span class="hljs-params">()</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountDao2</span>();        &#125;&#125;</code></pre></div><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1706237309967-823a14e5-2d45-4a84-93f5-9a477217ea5b.png#averageHue=%23f7f7f6&clientId=u6dce0a89-1589-4&from=paste&id=u3b5511cc&originHeight=394&originWidth=1919&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=70817&status=done&style=none&taskId=u95fbcefc-dc8c-4b6e-940c-20bcc2b9ca5&title=" alt="image.png"></li></ul><h1 id="ConditionalOnMissingBean："><a href="#ConditionalOnMissingBean：" class="headerlink" title="@ConditionalOnMissingBean："></a>@ConditionalOnMissingBean：</h1><p>对比说明：<br>@ConditionalOnBean有则注入；@ConditionalOnMissBean没有则注入；@Conditional条件满足则注入。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ConditionalOnMissingBean</span>注解只作用在<span class="hljs-meta">@Bean</span>定义的方法上建议仅仅在自动配置类中使用此注解，虽然放在其他类中也不会报错该注解仅能匹配已经被当前应用上下文管控的Bean定义若候选Bean是被其他配置类创建的，需要使用<span class="hljs-meta">@AutoConfigureBefore</span> 或<span class="hljs-meta">@AutoConfigureOrder</span>进行配置类先后注入顺序的控制，确保这个条件在其后运行Condition相关的处理是在包扫描的时候执行的，因此Bean的添加顺序和包扫描的顺序有关，而包扫描的顺序依赖包名和类名的字符排序，同时和maven的pom文件中包引入的顺序也有关系，先引入的包先被扫描到，所以在实际的项目中，我们可以修改类路径或者调整包引入顺序来调整Bean的添加顺序</code></pre></div><h1 id="Autowired："><a href="#Autowired：" class="headerlink" title="@Autowired："></a>@Autowired：</h1><p>@Autowired是一种注解，可以对构造器、方法、参数、字段和注解进行标注，源码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Autowired &#123;<span class="hljs-comment">// @Autowired 只有一个required元素，默认是true</span><span class="hljs-comment">// require=ture 时，表示解析被标记的属性/方法，在容器中一定有对应的bean存在，否则报错。</span><span class="hljs-comment">// require=false时，表示解析被标记的属性/方法，在容器中没有找到对应的bean依然不会报错。</span>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">required</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div><p>(1). @Autowired一般用在Controller层中用来装配Service对象，当同一个Service接口对象有多个实现时，需要使用@Qualifier来制定具体的装载依赖，否则会报错，除非用@Autowired标注的属性&#x2F;方法的类型是Map或者List：No qualifying bean of type ‘com.hadoopx.file.service.ISysFileService’ available: expected single matching bean but found 2: LocalSysFileServiceImpl,FastDfsSysFileServiceImpl，当然这个问题也可以使用@Primary来解决。<br>NoUniqueBeanDefinitionException，说明有多个满足条件的bean进行自动装配，程序无法正确做出判断使用哪一个，通过将@Qualifier注解与我们想要使用的特定Spring bean的名称一起进行装配，Spring框架就能从多个相同类型并满足装配要求的bean中找到我们想要的<br>(2). @Autowired根据类型进行自动装配，如果需要按名称进行装配，则需要配合@Qualifier使用。<br>(3). @Autowired在装配依赖对象时，默认要求依赖对象必须存在，如果允许为NULL，需要设置required属性为false。<br>(4). 被@Autowired标注的属性&#x2F;方法所在的类，需要是Spring容器中的bean。<br>(5). 被@Autowired标注的属性&#x2F;方法的类型是Map且Key为String类型，Spring则会把所有符合该类型的bean装载到Map中，key是bean名称，value则为该bean的实例。在简单工程模式中，可以使用该特性替换传统的将服务实现存入Map的方式。<br>(6). 被@Autowired标注的属性&#x2F;方法的类型是List，Spring则会把所有符合该类型的bean装载到List集合中。<br>(7). @Autowired与@Resource都可以用来装配bean，都可以写在字段上。@Autowired默认按类型装配，@Resource（这个注解属于J2EE的），默认安照名称进行装配，名称可以通过name属性进行指定。</p>]]></content>
    
    
    <categories>
      
      <category>springboot2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot集成连接池</title>
    <link href="/2024/01/25/SpringBoot%E9%9B%86%E6%88%90%E8%BF%9E%E6%8E%A5%E6%B1%A0%EF%BC%9A/"/>
    <url>/2024/01/25/SpringBoot%E9%9B%86%E6%88%90%E8%BF%9E%E6%8E%A5%E6%B1%A0%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="什么是数据库连接池？"><a href="#什么是数据库连接池？" class="headerlink" title="什么是数据库连接池？"></a>什么是数据库连接池？</h3><p> 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。</p><h3 id="数据库连接池基本原理？"><a href="#数据库连接池基本原理？" class="headerlink" title="数据库连接池基本原理？"></a>数据库连接池基本原理？</h3><p>连接池基本的思想是在系统初始化的时候，将数据库连接作为对象存储在内存中，当用户需要访问数据库时，并非建立一个新的连接，而是从连接池中取出一个已建立的空闲连接对象。使用完毕后，用户也并非将连接关闭，而是将连接放回连接池中，以供下一个请求访问使用。而连接的建立、断开都由连接池自身来管理。同时，还可以通过设置连接池的参数来控制连接池中的初始连接数、连接的上下限数以及每个连接的最大使用次数、最大空闲时间等等。也可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。<br>数据库连接池的最小连接数和最大连接数的设置要考虑到下列几个因素：</p><ul><li>最小连接数</li></ul><p>是连接池一直保持的数据库连接，所以如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费。</p><ul><li>最大连接数</li></ul><p>是连接池能申请的最大连接数，如果数据库连接请求超过此数，后面的数据库连接请求将被加入到等待队列中，这会影响之后的数据库操作。</p><ul><li>最小连接数与最大连接数差距</li></ul><p>最小连接数与最大连接数相差太大，那么最先的连接请求将会获利，之后超过最小连接数量的连接请求等价于建立一个新的数据库连接。不过，这些大于最小连接数的数据库连接在使用完不会马上被释放，它将被放到连接池中等待重复使用或是空闲超时后被释放。</p><h3 id="HikariCP："><a href="#HikariCP：" class="headerlink" title="HikariCP："></a>HikariCP：</h3><p>springboot默认连接池是这个：直接导入springboot的JDBC就可以导入相关依赖了！</p><div class="code-wrapper"><pre><code class="hljs java">spring:  datasource:    url: jdbc:mysql:<span class="hljs-comment">//localhost:3306/mp?useSSL=false&amp;autoReconnect=true&amp;characterEncoding=utf8</span>    driver-class-name: com.mysql.cj.jdbc.Driver    username: root    password: A86789234    # 指定为HikariDataSource    type: com.zaxxer.hikari.HikariDataSource    # hikari连接池配置    hikari:      #连接池名      pool-name: HikariCP      #最小空闲连接数      minimum-idle: <span class="hljs-number">5</span>      # 空闲连接存活最大时间，默认<span class="hljs-number">10</span>分钟      idle-timeout: <span class="hljs-number">600000</span>      # 连接池最大连接数，默认是<span class="hljs-number">10</span>      maximum-pool-size: <span class="hljs-number">10</span>      # 此属性控制从池返回的连接的默认自动提交行为,默认值：<span class="hljs-literal">true</span>      auto-commit: <span class="hljs-literal">true</span>      # 此属性控制池中连接的最长生命周期，值<span class="hljs-number">0</span>表示无限生命周期，默认<span class="hljs-number">30</span>分钟      max-lifetime: <span class="hljs-number">1800000</span>      # 数据库连接超时时间,默认<span class="hljs-number">30</span>秒      connection-timeout: <span class="hljs-number">30000</span>      # 连接测试query      connection-test-query: SELECT <span class="hljs-number">1</span></code></pre></div><p>重要参数<br>1.maximum-pool-size   池中最大连接数（包括空闲和正在使用的连接）<br>2.minimum-idle   池中最小空闲连接数量。默认值10<br>3.pool-name   连接池的名字<br>4.auto-commit   当auto-commit设置为true时（这是默认值），意味着对于每一个通过连接池执行的SQL语句，默认都会自动提交事务。也就是说，每一条单独的SQL查询或数据修改操作都会立即持久化到数据库中。果将auto-commit设置为false，则应用程序需要显式地管理事务，即在一系列数据库操作完成后调用connection.commit()来提交事务<br>5.idle-timeout    空闲时间。仅在minimum-idle小于maximum-poop-size的时候才会起作用。默认值10分钟。<br>6.max-lifetime   连接池中连接的最大生命周期。当连接一致处于闲置状态时，数据库可能会主动断开连接。<br>7.connection-timeout   连接超时时间。默认值为30s，可以接收的最小超时时间为250ms。但是连接池请求也可以自定义超时时间</p><h3 id="Druid："><a href="#Druid：" class="headerlink" title="Druid："></a>Druid：</h3><p><a href="https://blog.csdn.net/weixin_44002151/article/details/134901357">Spring Boot 3 集成 Druid 连接池详解_springboot3 druid-CSDN博客</a><br>为监控而生的连接池：<br>导入依赖：springboot3</p><div class="code-wrapper"><pre><code class="hljs java">&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;druid-spring-boot-<span class="hljs-number">3</span>-starter&lt;/artifactId&gt;  &lt;version&gt;<span class="hljs-number">1.2</span><span class="hljs-number">.20</span>&lt;/version&gt;&lt;/dependency&gt;</code></pre></div><p><strong>测试数据源是否指定成功：</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest(args = &quot;--mpw.key=fbc9c2430668ee2b&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DdTest</span> &#123;    <span class="hljs-meta">@Autowired</span>    DataSource dataSource;    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">//查看数据源</span>        System.out.println(dataSource.getClass());        <span class="hljs-comment">//获得数据库连接</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();            System.out.println(connection);            <span class="hljs-comment">//关闭连接</span>            connection.close();        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>springboot3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatisPlus多租户</title>
    <link href="/2024/01/25/mybatisPlus%E5%A4%9A%E7%A7%9F%E6%88%B7%EF%BC%9A/"/>
    <url>/2024/01/25/mybatisPlus%E5%A4%9A%E7%A7%9F%E6%88%B7%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="关联知识点："><a href="#关联知识点：" class="headerlink" title="关联知识点："></a>关联知识点：</h2><h4 id="1-configuration-注解的理解："><a href="#1-configuration-注解的理解：" class="headerlink" title="1.@configuration   注解的理解："></a>1.@configuration   注解的理解：</h4><ol><li>标有@Configuration注解类中方法标有@Bean注解方法的返回值就可以注入IoC容器，并且还是单例的，所以肯定是经过某种方式增强方法了，并且还是对类的增强，所以肯定是使用到Cglib动态代理技术。</li><li>@Configuration注解类和那么的@Bean  注解的类都被注入到容器中了的！</li><li>定义配置类：通过在类上添加@Configuration注解，Spring容器会将该类视为一个配置源，其中包含Bean的定义和配置信息。</li></ol><p>  4.定义Bean：在配置类中，可以编写方法并使用@Bean注解来指示这些方法应当被Spring容器调用以生成和初始化Bean。这样，配置类中的@Bean注解的方法所返回的对象就会被注册到Spring IoC容器中，并可以在应用程序的其他地方通过依赖注入（DI）的方式进行使用。<br>5.不可缺少该注解！配置类只有单独的该@Bean  注解而没有@Configuration 注解！那么该配置类是无法注入到Spring容器中的！一般框架里面会有一个默认的配置类注入到容器中！<br>6.该注解类似于以前的xml配置bean，里面的bean就是以前的bean标签<br>7.该注解修饰的类可以理解为一个小容器！</p><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p>多租户（Multi Tenancy&#x2F;Tenant） 是一种软件架构，其定义是：在一台服务器上运行单个应用实例，它为多个租户提供服务，且保证用户间数据隔离<br>多租户架构的概念是<strong>针对数据存储</strong>的，假设我们是一个<strong>数据服务提供商</strong>，需要给所有的学校提供服务，对于我们来说，分组是按照<strong>学校</strong>为单位的，而且学校与学校之间互相没有任何关系，也就说学校与学校之间是<strong>隔离</strong>的，对于不同学校的数据我们需要将它们隔离开来。这种数据的分组就是多租户架构要研究的问题。</p><h2 id="模式："><a href="#模式：" class="headerlink" title="模式："></a>模式：</h2><h3 id="独立数据库："><a href="#独立数据库：" class="headerlink" title="独立数据库："></a>独立数据库：</h3><p>即<strong>一个租户一个数据库，</strong></p><h3 id="共享数据库，独立Schema："><a href="#共享数据库，独立Schema：" class="headerlink" title="共享数据库，独立Schema："></a>共享数据库，独立Schema：</h3><p>**共享数据库，独立 Schema **将每个租户关联到同一个数据库的不同 Schema，租户间数据彼此逻辑不可见，上层应用程序的实现和独立数据库一样简单。也可以这样理解：就是所有租户共用一个数据库系统，但是每个租户在数据库系统中拥有一个独立的表空间。<br>缺点：<br>1、由于是每个租户一个库可以在库表设计上做单独扩展，但这也引起了应用程序的兼容问题；<br>2、数据库维护成本和高。</p><h3 id="共享数据库，共享数据架构："><a href="#共享数据库，共享数据架构：" class="headerlink" title="共享数据库，共享数据架构："></a>共享数据库，共享数据架构：</h3><p>这种方案是多租户方案中最简单的数据隔离方法，即在每张表中都添加一个用于区分租户的字段（如tenant_id或org_id啥的）来标识每条数据属于哪个租户，当进行查询的时候每条语句都要添加该字段作为过滤条件，其特点是所有租户的数据全都存放在同一个表中，数据的隔离性是最低的，完全是通过字段来区分的，很容易把数据搞串或者误操作。</p><table><thead><tr><th>隔离方案</th><th>成本</th><th>支持租户数量</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>独立数据库系统</td><td>高</td><td>少</td><td>数据隔离级别高，安全性，可以针对单个租户开发个性化需求</td><td>数据库独立安装，物理成本和维护成本都比较高</td></tr><tr><td>独立的表空间</td><td>中</td><td>较多</td><td>提供了一定程度的逻辑数据隔离，一个数据库系统可支持多个租户</td><td>数据库管理比较困难，表繁多，同时数据修复稍复杂</td></tr><tr><td>按租户id字段区分</td><td>低</td><td>多</td><td>维护和购置成本最低，每个数据库能够支持的租户数量最多</td><td>隔离级别最低，安全性也最低</td></tr></tbody></table><h2 id="MyBatis-Plus的基于字段的隔离方式："><a href="#MyBatis-Plus的基于字段的隔离方式：" class="headerlink" title="MyBatis-Plus的基于字段的隔离方式："></a>MyBatis-Plus的基于字段的隔离方式：</h2><ul><li>多租户 !&#x3D; 权限过滤,不要乱用,租户之间是完全隔离的!!!</li><li>启用多租户后所有执行的method的sql都会进行处理.</li><li>自写的sql请按规范书写(sql涉及到多个表的每个表都要给别名,特别是 inner join 的要写标准的 inner join)</li></ul><p>MyBatis-Plus基于字段的多租户是通过插件机制拦截实现的，因为还有很多其它的拦截器，比如:</p><ul><li>自动分页: PaginationInnerInterceptor</li><li>多租户: TenantLineInnerInterceptor<ul><li>动态表名: DynamicTableNameInnerInterceptor</li></ul></li><li>乐观锁: OptimisticLockerInnerInterceptor</li><li>sql 性能规范: IllegalSQLInnerInterceptor</li><li>防止全表更新与删除: BlockAttackInnerInterceptor</li></ul><p>所以需要注意顺序: 使用多个功能需要注意顺序关系,建议使用如下顺序</p><ul><li>多租户,动态表名</li><li>分页,乐观锁</li><li>sql 性能规范,防止全表更新与删除</li></ul><p>总结: 对 sql 进行单次改造的优先放入,不对 sql 进行改造的最后放入</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>mybatisPlus实现多租户实际上是通过在表中放入一个特定的tenantId来区分不同的用户！然后在mybatisPlus添加拦截器拦截我们写的sql语句添加对应的tenantId进行优化来实现对不同的租户的信息进行操作的！<br><a href="https://www.cnblogs.com/gtnotgod/p/17498103.html">mybatisPlus多租户</a></p>]]></content>
    
    
    <categories>
      
      <category>springboot3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA使用技巧</title>
    <link href="/2024/01/23/IDEA%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A/"/>
    <url>/2024/01/23/IDEA%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id="1-IDEA视图不小心设置让设置无法显示出来？"><a href="#1-IDEA视图不小心设置让设置无法显示出来？" class="headerlink" title="1.IDEA视图不小心设置让设置无法显示出来？"></a>1.IDEA视图不小心设置让设置无法显示出来？</h2><p>其实双按shift可以打开搜索模式，这里的搜索模式输入View是可以进入View设置的<br>2.<a href="https://blog.csdn.net/xiao_yi_xiao/article/details/119142118">ERROR:JAVA: 错误: 不支持发行版本 5 解决方法_欧晨eli的博客-CSDN博客</a><br><a href="https://blog.csdn.net/df1067/article/details/106567084?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">IDEA的junit单元测试Scanner输入无效-CSDN博客</a></p><h2 id="3-maven创建spring发生版本不兼容问题："><a href="#3-maven创建spring发生版本不兼容问题：" class="headerlink" title="3.maven创建spring发生版本不兼容问题："></a>3.maven创建spring发生版本不兼容问题：</h2><p><a href="https://blog.csdn.net/angelbeautiful/article/details/131182554">解决：java: 警告: 源发行版 17 需要目标发行版 17-CSDN博客</a><a href="https://blog.csdn.net/qq_49619863/article/details/128047256">Springbot启动报错-类文件具有错误的版本 61.0, 应为 52.0_&#x2F;d:&#x2F;java&#x2F;apache-maven-3.8.6&#x2F;repository&#x2F;org&#x2F;springf-CSDN博客</a></p><h2 id="4-pom-xml问题："><a href="#4-pom-xml问题：" class="headerlink" title="4.pom.xml问题："></a>4.pom.xml问题：</h2><p><a href="https://blog.csdn.net/hkzuz/article/details/132006743?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-4-132006743-blog-114698522.235%5Ev38%5Epc_relevant_default_base&spm=1001.2101.3001.4242.3&utm_relevant_index=7">idea模块的pom.xml被划横线，不识别的解决办法_idea pom 划线_八戒，你又涨价了哎的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDEA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS改变原生样式:---改变radio,checkbox等选择框的颜色</title>
    <link href="/2024/01/23/CSS%E6%94%B9%E5%8F%98%E5%8E%9F%E7%94%9F%E6%A0%B7%E5%BC%8F_---%E6%94%B9%E5%8F%98radio,checkbox%E7%AD%89%E9%80%89%E6%8B%A9%E6%A1%86%E7%9A%84%E9%A2%9C%E8%89%B2%EF%BC%9A/"/>
    <url>/2024/01/23/CSS%E6%94%B9%E5%8F%98%E5%8E%9F%E7%94%9F%E6%A0%B7%E5%BC%8F_---%E6%94%B9%E5%8F%98radio,checkbox%E7%AD%89%E9%80%89%E6%8B%A9%E6%A1%86%E7%9A%84%E9%A2%9C%E8%89%B2%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="方法1：使用accent-color"><a href="#方法1：使用accent-color" class="headerlink" title="方法1：使用accent-color:"></a>方法1：使用accent-color:</h2><div class="code-wrapper"><pre><code class="hljs javascript">accent-color能修改 input 默认控件的颜色（也就是修改选中后的颜色）。</code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span>&gt;</span>radio    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span>checkbox<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html">input[type=radio]&#123;       accent-color: red;   &#125; input[type=checkbox]&#123;     accent-color: blue; &#125;</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697618263372-f1249af9-ea74-44c4-acf3-ddb03e00f143.png#averageHue=%23daae68&clientId=ud398c746-c1b4-4&from=paste&height=42&id=u68fb0b6e&originHeight=52&originWidth=219&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=2154&status=done&style=none&taskId=u97a645d3-6329-4e81-ac17-9a1c7948d41&title=&width=175.2" alt="image.png"></p><h2 id="方法二：通过伪元素来实现"><a href="#方法二：通过伪元素来实现" class="headerlink" title="方法二：通过伪元素来实现"></a>方法二：通过伪元素来实现</h2><div class="code-wrapper"><pre><code class="hljs javascript">&lt;body&gt;       <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myCheckbox&quot;</span>&gt;</span></span><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;myCheckbox&quot;</span>&gt;</span>checkbox<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript">&lt;style&gt;   <span class="hljs-comment">/*隐藏默认复选框  */</span>   input[type=checkbox]&#123;    <span class="hljs-attr">display</span>: none;   &#125;   <span class="hljs-comment">/*  创建自定义复选框*/</span>   input[type=checkbox]+<span class="hljs-attr">label</span>::before&#123;    <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;    <span class="hljs-attr">display</span>: inline-block;    <span class="hljs-attr">width</span>: 16px;    <span class="hljs-attr">height</span>: 16px;    <span class="hljs-attr">border</span>: 1px solid #ccc;    background-<span class="hljs-attr">color</span>: #fff;    margin-<span class="hljs-attr">right</span>: 8px;   &#125;   <span class="hljs-comment">/* 自定义选中后的效果 */</span>   input[type=checkbox]:checked+<span class="hljs-attr">label</span>::before&#123;     background-<span class="hljs-attr">color</span>: red;   &#125;    &lt;/style&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript">input后面的lable标签：&lt;label&gt; 标签为 input 元素定义标注（标记）。label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果您在 label 元素内点击文本，就会触发此控件。就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。&lt;label&gt; 标签的 <span class="hljs-keyword">for</span> 属性应当与相关元素的 id 属性相同。<span class="hljs-attr">label</span>::before是伪元素用法，并不是表示label前面的一个元素，而是在label元素之前添加内容</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript">ss的伪元素，之所以被称为伪元素，是因为他们不是真正的页面元素，html没有对应的元素，但是其所有用法和表现行为与真正的页面元素一样，可以对其使用诸如页面元素一样的css样式，表面上看上去貌似是页面的某些元素来展现，实际上是css样式展现的行为，因此被称为伪元素。伪元素:before和:after用法：这个两个伪元素在真正页面元素内部之前和之后添加新内容（当然了，可以对伪元素应用定位可以置于任何位置）伪元素:before和:after添加的内容默认是inline元素伪元素不属于文档，所以js无法操作它伪元素属于主元素的一部分，因此点击伪元素触发的是主元素的click事件</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件体系结构实验1</title>
    <link href="/2024/01/23/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%84%E4%B8%80%EF%BC%9A/"/>
    <url>/2024/01/23/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%84%E4%B8%80%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="一、-实验内容"><a href="#一、-实验内容" class="headerlink" title="一、     实验内容"></a>一、     实验内容</h1><p>噪声监测系统通常由声级计（声音传感器）、采集单元和传输单元、PC计算机等部分组成。采集单元从传感器采集声音信息并转换为数字，然后通过传输单元上传到PC端（暂定采用串口通讯方式），PC端通过技术分析后将数据上传至数据库服务器，并在PC端以合适方式展示噪声信息。<br>（1）    采集单元由单片机构成，负责数据采集，并通过串口通讯方式上传给PC端；<br>（2）    PC端软件需要使用RS232 SDK来与采集单元通讯（将来可能更换为其它通讯方式）。<br>（3）    操作员即可以实时查看当前采集到的噪声信息，也可以分析数据库服务器中保存的任意时段噪声数据并打印输出分析报告。<br>任务：<br>（1）    利用“4+1”视图建模方法对以上描述的“噪声监测系统”进行软件体系结构设计。<br>（2）    请说明当PC端与采集单元的通讯方式发生变化，你设计的体系结构如何应对？</p><h1 id="二-实验步骤："><a href="#二-实验步骤：" class="headerlink" title="二.实验步骤："></a>二.实验步骤：</h1><h3 id="UML图形工具："><a href="#UML图形工具：" class="headerlink" title="UML图形工具："></a>UML图形工具：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698159226042-a739b842-f60f-4298-82db-642960693b27.png#averageHue=%23a9b8cf&clientId=u801801c7-a9c6-4&from=paste&height=37&id=u0da0c52a&originHeight=46&originWidth=118&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=4001&status=done&style=none&taskId=ue0c9bcfd-3f49-4bf5-8a93-6a3d9ef0124&title=&width=94.4" alt="image.png"></p><h3 id="设计考虑："><a href="#设计考虑：" class="headerlink" title="设计考虑："></a>设计考虑：</h3><ul><li>可维护性：软件应该易于维护和修改。</li><li>可重用性：软件应该易于重用。</li><li>可扩展性：软件应该易于扩展。</li><li>可移植性：软件应该易于移植到不同的平台。</li><li>可靠性：软件应该具有高可靠性，即在面对各种异常情况时，仍能保持正常运行。</li><li>性能：软件应该具有良好的性能，即能够在合理的时间内完成所需的任务。</li><li>安全性：软件应该具有良好的安全性，即能够保护用户数据和系统安全。</li></ul><p>在该系统中当PC端与采集单元的通讯方式发生变化时，只修改传输单元构件就可以了。</p><h3 id="场景视图："><a href="#场景视图：" class="headerlink" title="场景视图："></a>场景视图：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698153699112-7fa93cdc-222a-4d16-874d-5e78cd61d2a3.png#averageHue=%23fbfafa&clientId=u801801c7-a9c6-4&from=paste&height=402&id=ua6eec258&originHeight=502&originWidth=1087&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=47190&status=done&style=none&taskId=u7855be2e-7411-42d6-91d1-7220a19b188&title=&width=869.6" alt="image.png"></p><h3 id="逻辑视图："><a href="#逻辑视图：" class="headerlink" title="逻辑视图："></a>逻辑视图：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698152866585-0dfa1d1a-ae1a-4d27-b982-26c93d615da4.png#averageHue=%23fbfbfb&clientId=u801801c7-a9c6-4&from=paste&height=557&id=ue708415f&originHeight=696&originWidth=836&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=60052&status=done&style=none&taskId=u328a519f-dea8-4bcb-95b1-898928bfb89&title=&width=668.8" alt="image.png"></p><h3 id="开发视图："><a href="#开发视图：" class="headerlink" title="开发视图："></a>开发视图：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698155637140-036debb3-55ce-43d1-b09c-5638bc865989.png#averageHue=%23fbfafa&clientId=u801801c7-a9c6-4&from=paste&height=369&id=u566380b8&originHeight=461&originWidth=982&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=30739&status=done&style=none&taskId=u0c7f7c31-b7e0-4240-8cb1-ad5cb429857&title=&width=785.6" alt="image.png"></p><h3 id="过程视图："><a href="#过程视图：" class="headerlink" title="过程视图："></a>过程视图：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698157462151-a983e627-1103-40d7-934b-774a9610190e.png#averageHue=%23fbfbfb&clientId=u801801c7-a9c6-4&from=paste&height=531&id=ub5b52c72&originHeight=664&originWidth=945&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=32263&status=done&style=none&taskId=u5670c9a1-a54e-437c-91f8-88b97f71786&title=&width=756" alt="image.png"></p><h3 id="物理视图："><a href="#物理视图：" class="headerlink" title="物理视图："></a>物理视图：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698158529311-9b819f7c-d9c4-4b22-9876-26fa35905f40.png#averageHue=%23fcfcfc&clientId=u801801c7-a9c6-4&from=paste&height=478&id=ueec8c875&originHeight=597&originWidth=1180&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=25775&status=done&style=none&taskId=ub53983ef-ec4a-4da0-9a8e-86748cce8e0&title=&width=944" alt="image.png"></p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>逻辑视图和开发视图描述系统的静态结构，而进程视图和物理视图描述系统的动态结构。<br>对于不同的软件系统来说，侧重的角度也有所不同。例如，对于管理信息系统来说，比较侧重于从逻辑视图和开发视图来描述系统，而对于实时控制系统来说，则比较注重于从进程视图和物理视图来描述系统。<br>“4+1”视图模型已经成功使用在几个大型项目中，无论是否在术语4中有一些本地定制和调整。它的确能使不同利益相关者找到他们想了解的软件架构信息。系统工程师使用物理视图，再到过程视图。最终用户、客户、数据专家使用逻辑视图。项目经理、软件配置人员使用开发视图。</p>]]></content>
    
    
    <categories>
      
      <category>课程作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程作业</tag>
      
      <tag>软件体系结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件体系结构实验2</title>
    <link href="/2024/01/23/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A/"/>
    <url>/2024/01/23/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="一：实验内容："><a href="#一：实验内容：" class="headerlink" title="一：实验内容："></a>一：实验内容：</h1><p>任务1：仔细阅读文献<a href="https://blog.csdn.net/weixin_43853097/article/details/110943379?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-110943379-blog-82871259.t5_download_50w&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-110943379-blog-82871259.t5_download_50w&utm_relevant_index=1">“主程序-子程序、面向对象、事件系统和管道-过滤软件体系结构实现KWIC”</a><br>任务2：实现文献中的所有程序并调试通过。<br>任务3：参考和整合以上参考文献，开发“经典软件体系结构教学软件”，用于向用户展示主程序-子程序、面向对象、事件系统和管道-过滤器等软件体系结构风格的基本原理。软件功能及界面可自由设计，但应包括如下内容：<br>（1） 用户可选择四种方法之一对指定的输入文件进行处理，结果可显示在界面上；<br>（2） 能够分别显示各种“体系结构风格”的原理图或文字说明、源程序代码结构、关键函数的程序代码等；</p><h1 id="二-软件开发："><a href="#二-软件开发：" class="headerlink" title="二.软件开发："></a>二.软件开发：</h1><h2 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h2><p>1.JDK8，maven，IDEA<br>2.springboot+thymeleaf<br>3.源代码地址：<a href="https://gitee.com/fanshanshui/architecture-experiment.git">晓晨&#x2F; Sa-experiment2</a></p><h2 id="源代码结构："><a href="#源代码结构：" class="headerlink" title="源代码结构："></a>源代码结构：</h2><p>总体上采用MVC的结构开发<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698234665556-84cbfcec-e244-4337-b7d3-d017dbb8fa5f.png#averageHue=%23536268&clientId=u877b6732-74b4-4&from=paste&height=429&id=ubb371b37&originHeight=536&originWidth=747&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=197557&status=done&style=none&taskId=uc0ca482f-3a9a-47e8-874f-9c3704d4417&title=&width=597.6" alt="image.png"></p><h2 id="运行截图："><a href="#运行截图：" class="headerlink" title="运行截图："></a>运行截图：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698234725788-c45e761c-74fb-40b3-a776-58a10a9a960d.png#averageHue=%23f8f7f6&clientId=u877b6732-74b4-4&from=paste&height=460&id=u03d42cbc&originHeight=575&originWidth=895&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=66407&status=done&style=none&taskId=uec95920a-a594-417c-81a8-de7371b3142&title=&width=716" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698234765228-25385136-a354-4f30-8362-bf9803d163b6.png#averageHue=%23f9f9f9&clientId=u877b6732-74b4-4&from=paste&height=691&id=u7455a5cd&originHeight=864&originWidth=1062&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=137092&status=done&style=none&taskId=u8b241396-23af-4f0e-81d8-d9a2bb84831&title=&width=849.6" alt="image.png"><br>查看代码功能：<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698234879261-3c23de92-5852-4e21-8ab7-99759e33561f.png#averageHue=%23f9f8f6&clientId=u877b6732-74b4-4&from=paste&height=567&id=u35382cfd&originHeight=709&originWidth=834&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=57216&status=done&style=none&taskId=ucf1ce82a-1ba7-4e1c-a51f-b64c8759f79&title=&width=667.2" alt="image.png"><br>测试其他体系结构：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698234930262-3ee8b732-4f15-4ad9-bd02-66942c85530a.png#averageHue=%23f8f7f7&clientId=u877b6732-74b4-4&from=paste&height=680&id=u796df42e&originHeight=850&originWidth=995&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=123152&status=done&style=none&taskId=ub30051ab-dee9-4c81-9c51-fcf8ba3e6bf&title=&width=796" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698234937075-62502cb5-5cb3-40ba-8f95-922195995ade.png#averageHue=%23f8f8f8&clientId=u877b6732-74b4-4&from=paste&height=690&id=u991882cc&originHeight=862&originWidth=986&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=124221&status=done&style=none&taskId=u96a57ed2-bacd-4dbc-ba27-504b792f2c7&title=&width=788.8" alt="image.png"></p><h1 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h1><p>1.IDEA文件相对路径写对了但是却找不到的问题：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698235681601-a66b317a-554e-4f0f-a750-7551025d20c3.png#averageHue=%2335445c&clientId=u877b6732-74b4-4&from=paste&height=458&id=ue394ae0a&originHeight=573&originWidth=1656&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=400404&status=done&style=none&taskId=ub7150a54-bd54-45df-8eeb-f161a7a2059&title=&width=1324.8" alt="image.png"><br>原因是：..&#x2F;表示上级目录是Linucx下的表示方法<br>解决方法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>);<span class="hljs-comment">//获取当前程序运行的目录，</span><span class="hljs-comment">// 它通常是启动 Java 程序的命令行或应用程序所在的目录。</span><span class="hljs-type">FileReader</span> <span class="hljs-variable">fileReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(root+File.separator+<span class="hljs-string">&quot;test.txt&quot;</span>);<span class="hljs-comment">//File.separator</span><span class="hljs-comment">//是产生文件分割符号，Linucx和window的文件分割符是不一样的。</span></code></pre></div><p>2.添加了devtools依赖并不能实现真正意义上的修改代码不用重新加载就可以看到变化，还需要设置IDEA自动编译<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698236724532-84392022-ec93-4264-8026-d0e9b9a0011b.png#averageHue=%23303337&clientId=u877b6732-74b4-4&from=paste&height=613&id=uc3c35123&originHeight=766&originWidth=716&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=67616&status=done&style=none&taskId=ud5c01a0c-9053-4345-9514-c3b4be91c29&title=&width=572.8" alt="image.png"></p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>主程序-子程序风格是一种结构化的软件体系结构，它从功能的角度设计系统，通过逐步分解和细化，形成整个系统的体系结构。主程序是系统的入口和控制中心，它调用各种子程序来完成具体的任务。子程序是一些独立的功能模块，它们可以被主程序或其他子程序重复调用。主程序-子程序风格的特点有：<br>•  简单：它遵循自顶向下、逐步求精的设计原则，易于理解和实现。<br>•  模块化：它将系统划分为若干相对独立的模块，提高了代码的重用性和可维护性。<br>•  局限性：它不能很好地处理数据和行为的耦合问题，也不适合处理并发和分布式的情况。<br>面向对象风格是一种封装的软件体系结构，它从数据的角度设计系统，通过抽象和多态，形成整个系统的体系结构。对象是系统的基本单位，它包含了数据和作用在数据上的操作。对象之间通过接口进行消息传递和协作。面向对象风格的特点有：<br>•  灵活：它可以通过继承和组合来实现代码的复用和扩展，也可以通过多态来实现动态绑定和行为变化。<br>•  隐蔽性：它可以通过封装来隐藏对象的内部细节，只暴露必要的接口给外界，提高了系统的安全性和稳定性。<br>•  复杂性：它需要考虑对象之间的关系和协作，以及对象生命周期和状态管理等问题，增加了系统的设计难度和开发成本。<br> 事件系统风格是一种异步的软件体系结构，它从交互的角度设计系统，通过事件驱动和回调函数，形成整个系统的体系结构。事件是系统中发生的各种情况或变化，它们可以由用户、设备或其他源产生。事件处理器是响应事件并执行相应操作的模块，它们可以注册到事件源或事件分发器上。事件系统风格的特点有：<br>•  响应性：它可以实现非阻塞式的通信和处理，提高了系统的并发性能和用户体验。<br>•  解耦性：它可以将事件源和事件处理器分离开来，降低了系统各部分之间的依赖性。<br>•  不确定性：它需要处理事件之间的时序、优先级、冲突等问题，也需要考虑事件丢失、重复、延迟等问题，增加了系统的复杂性和不可预测性。<br> 管道-过滤器风格是一种流式的软件体系结构，它从数据流的角度设计系统，通过连续处理和数据转换，形成整个系统的体系结构。过滤器是对输入数据流进行某种变换或增量计算，并产生输出数据流的模块。管道是将一个过滤器的输出传递到另一个过滤器输入的连接件。管道-过滤器风格的特点有：<br>•  可重用性：它可以将系统任务分解为若干个过滤器，每个过滤器都是一个独立的实体，可以在不同的系统中重用。<br>•  可组合性：它可以将不同的过滤器通过管道连接起来，形成不同的功能和行为。<br>•  可并行性：它可以将每个过滤器作为一个单独的任务执行，实现系统的并行处理和分布式计算。<br>•  局限性：它要求过滤器之间的数据格式和传输方式相匹配，也要求过滤器之间没有共享数据和状态信息，否则会影响系统的正确性和效率。</p>]]></content>
    
    
    <categories>
      
      <category>课程作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程作业</tag>
      
      <tag>软件体系结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件体系结构实验3</title>
    <link href="/2024/01/23/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A/"/>
    <url>/2024/01/23/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="一、-实验内容"><a href="#一、-实验内容" class="headerlink" title="一、 实验内容"></a>一、 实验内容</h2><p>个人通讯录系统的设计目标是能够轻松地管理个人的联系人信息，包括添加、修改和删除操作。联系人信息包括姓名、住址、电话。整个系统的功能图如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698393517486-f9c653d0-3e66-4310-b2b0-1db18abb2e74.png#averageHue=%23f1f1f1&clientId=u537b546b-41d6-4&from=paste&height=229&id=u7cf32b4e&originHeight=286&originWidth=469&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=20685&status=done&style=none&taskId=u25459ff4-e299-49d1-9bc7-f913de031eb&title=&width=375.2" alt="image.png"><br>任务1：采用二层C&#x2F;S结构实现“个人通讯录系统”；<br>任务2：采用三层C&#x2F;S结构实现“个人通讯录系统”；<br>任务3：采用B&#x2F;S结构实现“个人通讯录系统”。</p><h2 id="二：实验结果："><a href="#二：实验结果：" class="headerlink" title="二：实验结果："></a>二：实验结果：</h2><h3 id="实验源代码："><a href="#实验源代码：" class="headerlink" title="实验源代码："></a>实验源代码：</h3><p><a href="https://github.com/Redbiga/SA3.git">https://github.com/Redbiga/SA3.git</a><br>开发环境是：JDK:1.8，tomcat:9.0.65</p><h3 id="数据库结构："><a href="#数据库结构：" class="headerlink" title="数据库结构："></a>数据库结构：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698395792024-cc50c10e-0515-4055-bbbf-e8adf6bc3693.png#averageHue=%232d2f33&clientId=uef4eb324-706d-4&from=paste&height=194&id=uad8b6b4c&originHeight=243&originWidth=1044&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=86604&status=done&style=none&taskId=u2ce16b00-4d93-40ac-9984-3c5f8b2fc8a&title=&width=835.2" alt="image.png"></p><h3 id="两层CS体系结构："><a href="#两层CS体系结构：" class="headerlink" title="两层CS体系结构："></a>两层CS体系结构：</h3><h4 id="逻辑结构："><a href="#逻辑结构：" class="headerlink" title="逻辑结构："></a>逻辑结构：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698394568833-1263846d-20c4-494e-9131-17846d10dd43.png#averageHue=%23ebcba0&clientId=ua3da19bb-144d-4&from=paste&height=79&id=u7bd416f0&originHeight=99&originWidth=681&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=16154&status=done&style=none&taskId=ucbba3221-ee1a-4a15-a7f6-6691a4715ec&title=&width=544.8" alt="image.png"></p><h4 id="源程序代码结构："><a href="#源程序代码结构：" class="headerlink" title="源程序代码结构："></a>源程序代码结构：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698395687317-b8376a9f-5212-4081-b3a1-3b2de8231884.png#averageHue=%2339455c&clientId=uef4eb324-706d-4&from=paste&height=204&id=u12029e66&originHeight=255&originWidth=869&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=135580&status=done&style=none&taskId=u9f1e979b-c5fc-4c06-98c9-6d4dcbb683d&title=&width=695.2" alt="image.png"></p><h4 id="运行界面截图："><a href="#运行界面截图：" class="headerlink" title="运行界面截图："></a>运行界面截图：</h4><p>查询：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698395872221-73d5649f-b1e5-4803-a72d-c12cb6691834.png#averageHue=%23f6f6f6&clientId=uef4eb324-706d-4&from=paste&height=358&id=u23b91da1&originHeight=447&originWidth=1216&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=26954&status=done&style=none&taskId=udfa04e85-a36b-4696-865b-ab911626494&title=&width=972.8" alt="image.png"></p><h3 id="三层体系结构："><a href="#三层体系结构：" class="headerlink" title="三层体系结构："></a>三层体系结构：</h3><h4 id="逻辑结构：-1"><a href="#逻辑结构：-1" class="headerlink" title="逻辑结构："></a>逻辑结构：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698396423699-15d9f800-804b-4fdf-8042-4724c8d7f64b.png#averageHue=%23ead5b1&clientId=uef4eb324-706d-4&from=paste&height=114&id=u0327e6df&originHeight=143&originWidth=822&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=23537&status=done&style=none&taskId=u4f58f4b4-f848-4052-96e2-6fc8323ec91&title=&width=657.6" alt="image.png"></p><h4 id="源程序代码结构：-1"><a href="#源程序代码结构：-1" class="headerlink" title="源程序代码结构："></a>源程序代码结构：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698396611575-ad53412e-fa9a-4ecc-9723-a3dc400bf9f3.png#averageHue=%233a4865&clientId=uef4eb324-706d-4&from=paste&height=130&id=u1e77be3c&originHeight=162&originWidth=759&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=71431&status=done&style=none&taskId=u6b0a5785-41ba-4b68-ab68-72c278b9a4e&title=&width=607.2" alt="image.png"></p><h4 id="运行界面截图：运行结果同两层体系结构，只不过业务逻辑层放在服务层处理了。"><a href="#运行界面截图：运行结果同两层体系结构，只不过业务逻辑层放在服务层处理了。" class="headerlink" title="运行界面截图：运行结果同两层体系结构，只不过业务逻辑层放在服务层处理了。"></a>运行界面截图：运行结果同两层体系结构，只不过业务逻辑层放在服务层处理了。</h4><h3 id="BS结构："><a href="#BS结构：" class="headerlink" title="BS结构："></a>BS结构：</h3><h4 id="逻辑架构："><a href="#逻辑架构：" class="headerlink" title="逻辑架构："></a>逻辑架构：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698396961933-0f10f519-0bb2-460e-b39e-6350a2366c34.png#averageHue=%23f8f8f7&clientId=uef4eb324-706d-4&from=paste&height=315&id=uaf2c5d5b&originHeight=394&originWidth=896&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=77311&status=done&style=none&taskId=u2ad79267-6702-4de2-b4ca-07e5b5c48eb&title=&width=716.8" alt="image.png"></p><h4 id="源代码程序结构："><a href="#源代码程序结构：" class="headerlink" title="源代码程序结构："></a>源代码程序结构：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698397073870-0b79da1a-d207-4e59-ac44-d3b3c43105fb.png#averageHue=%233a3f46&clientId=uef4eb324-706d-4&from=paste&height=326&id=u65b19eae&originHeight=407&originWidth=1046&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=196033&status=done&style=none&taskId=u6c63aab0-a3e6-4d9d-ac4c-eed0ccf38b6&title=&width=836.8" alt="image.png"></p><h3 id="方案比较："><a href="#方案比较：" class="headerlink" title="方案比较："></a>方案比较：</h3><p>三层C&#x2F;S结构相对于二层C&#x2F;S结构更加灵活，可以更好地实现应用功能的独立性，提高系统和软件的可维护性和可扩展性； 二层C&#x2F;S结构相对于三层C&#x2F;S结构来说，缺点在于其数据处理能力较弱；B&#x2F;S架构相对于C&#x2F;S架构来说，具有以下优点：①跨平台性好；②客户端零维护；③易于维护4. B&#x2F;S架构相对于C&#x2F;S架构来说，缺点在于其个性化能力低，响应速度较慢。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>C&#x2F;S结构是一种常见的软件体系结构，它将整个系统分为客户端和服务器端。二层C&#x2F;S结构是指只有一个服务器，且以局域网为中心的结构。三层C&#x2F;S结构是指分为两类服务器（数据库服务器和应用服务器）和用户的结构。三层C&#x2F;S结构相对于二层C&#x2F;S结构更加灵活，可以更好地实现应用功能的独立性，提高系统和软件的可维护性和可扩展性； 三层C&#x2F;S结构的优点包括：①允许合理地划分三层结构的功能，使之在逻辑上保持相对独立性，能提高系统和软件的可维护性和可扩展性；②允许更灵活有效地选用相应的平台和硬件系统，使之在处理负荷能力上与处理特性上分别适应于结构清晰的三层；③应用的各层可以并行开发，可以选择各自最适合的开发语言；④利用功能层有效地隔离开表示层与数据层，未授权的用户难以绕过功能层而利用数据库工具或黑客手段去非法地访问数据层1. 二层C&#x2F;S结构相对于三层C&#x2F;S结构来说，缺点在于其数据处理能力较弱，安全性难以控制。<br>B&#x2F;S架构是指浏览器-服务器架构。B&#x2F;S架构相对于C&#x2F;S架构来说，具有以下优点：①跨平台性好；②客户端零维护；③易于维护4. B&#x2F;S架构相对于C&#x2F;S架构来说，缺点在于其个性化能力低，响应速度较慢。<br>总体而言，二层C&#x2F;S架构、三层C&#x2F;S架构、B&#x2F;S架构各有优缺点。选择何种架构需要根据实际情况进行权衡。</p>]]></content>
    
    
    <categories>
      
      <category>课程作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程作业</tag>
      
      <tag>软件体系结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件体系结构实验4</title>
    <link href="/2024/01/23/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9A/"/>
    <url>/2024/01/23/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="一、-实验内容"><a href="#一、-实验内容" class="headerlink" title="一、 实验内容"></a>一、 实验内容</h2><p>任务1：Web Service服务器端程序开发<br>        开发个人所得税计算程序，并发布为Web服务。<br>Idea参考：<a href="https://blog.csdn.net/C1041067258/article/details/86543099">idea搭建WebService HelloWorld程序_helloworld wsdl-CSDN博客</a><br>任务2：Web Servic客户端程序开发<br>    网站<a href="http://www.webxml.com.cn/">http://www.webxml.com.cn/</a>提供了诸如天气预报、航班时刻表、中英文翻译等许多公共web service功能，请利用这些web service功能开发一小型应用软件（比如：XXX天气预报系统、XXX航班查询系统等），软件名称自定。</p><h2 id="任务1："><a href="#任务1：" class="headerlink" title="任务1："></a>任务1：</h2><h3 id="源代码地址："><a href="#源代码地址：" class="headerlink" title="源代码地址："></a>源代码地址：</h3><p><a href="https://github.com/Redbiga/SA4.git">https://github.com/Redbiga/SA4.git</a></p><h3 id="源代码结构："><a href="#源代码结构：" class="headerlink" title="源代码结构："></a>源代码结构：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698500885228-956579fd-588f-43a3-b330-92ce62b2f88d.png#averageHue=%23414a52&clientId=ue18db17b-c587-4&from=paste&height=370&id=u36f606c9&originHeight=463&originWidth=928&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=266515&status=done&style=none&taskId=u4f3023b8-b940-419b-80d0-9ca87880647&title=&width=742.4" alt="image.png"></p><h3 id="运行截图："><a href="#运行截图：" class="headerlink" title="运行截图："></a>运行截图：</h3><p>web配置启动成功：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698501049454-7f1324c6-c0cc-4294-b162-4f8c842d7c58.png#averageHue=%23fefdfd&clientId=ue18db17b-c587-4&from=paste&height=364&id=uadfe4268&originHeight=455&originWidth=669&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=21136&status=done&style=none&taskId=u4a08b796-d0da-47b2-8ea5-badb0bcfa93&title=&width=535.2" alt="image.png"><br>成功发布服务截图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698501069837-2a3bec51-36d6-4503-93c5-30f57f401b31.png#averageHue=%23f8f7f6&clientId=ue18db17b-c587-4&from=paste&height=367&id=ue14fbe12&originHeight=459&originWidth=697&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=40531&status=done&style=none&taskId=u1165bf43-2945-47e4-a5fa-06bf6ad5d60&title=&width=557.6" alt="image.png"><br>使用服务截图：<br>输入不合法：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698501470365-57e3455f-adcf-481d-bba9-f6407354709f.png#averageHue=%23242427&clientId=ue18db17b-c587-4&from=paste&height=262&id=u983455a5&originHeight=327&originWidth=1054&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=171258&status=done&style=none&taskId=ude2ff205-c575-4278-9602-99fe1a71ae1&title=&width=843.2" alt="image.png"><br>输入合法：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698502063675-f92161ab-a9c7-4596-bb67-9572dba2a0bd.png#averageHue=%23242325&clientId=ue18db17b-c587-4&from=paste&height=219&id=uc60d96e8&originHeight=274&originWidth=691&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=70952&status=done&style=none&taskId=u46fef8c5-a301-4196-9adc-b82db4789f0&title=&width=552.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698502085421-43b9f5f1-fe0e-4377-ae54-4c256412d8ea.png#averageHue=%23252426&clientId=ue18db17b-c587-4&from=paste&height=171&id=u1d5041bc&originHeight=214&originWidth=617&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=51011&status=done&style=none&taskId=u4c803333-1cb0-46f4-aa76-1dd966584e1&title=&width=493.6" alt="image.png"></p><h2 id="任务2：Web-Service客户端天气查询客户端"><a href="#任务2：Web-Service客户端天气查询客户端" class="headerlink" title="任务2：Web Service客户端天气查询客户端"></a>任务2：Web Service客户端天气查询客户端</h2><h4 id="源代码地址：-1"><a href="#源代码地址：-1" class="headerlink" title="源代码地址："></a>源代码地址：</h4><p><a href="https://github.com/Redbiga/SA4Weather-inquiry.git">https://github.com/Redbiga/SA4Weather-inquiry.git</a></p><h3 id="功能需求："><a href="#功能需求：" class="headerlink" title="功能需求："></a>功能需求：</h3><p>查询天气</p><h3 id="服务介绍："><a href="#服务介绍：" class="headerlink" title="服务介绍："></a>服务介绍：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698503030903-56b2d015-24c3-44a1-9504-b8ad1fd6eb7a.png#averageHue=%23f9f8f6&clientId=ue18db17b-c587-4&from=paste&height=668&id=u01d76181&originHeight=835&originWidth=1029&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=237053&status=done&style=none&taskId=u61b7b747-a335-423c-86e2-5e7a8abbe48&title=&width=823.2" alt="image.png"></p><h4 id="源程序代码结构："><a href="#源程序代码结构：" class="headerlink" title="源程序代码结构："></a>源程序代码结构：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698503175453-56d8e332-533e-4886-be81-f36fc0f9912a.png#averageHue=%2348545b&clientId=ue18db17b-c587-4&from=paste&height=379&id=ubc0ef041&originHeight=474&originWidth=880&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=256041&status=done&style=none&taskId=u1c12743e-2544-4cdc-8bfe-b223599d06c&title=&width=704" alt="image.png"></p><h4 id="运行截图：-1"><a href="#运行截图：-1" class="headerlink" title="运行截图："></a>运行截图：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698503376791-b7a26bd4-face-4793-b956-59f6e10a2561.png#averageHue=%23f7f6f5&clientId=ue18db17b-c587-4&from=paste&height=641&id=u83035804&originHeight=801&originWidth=1031&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=112962&status=done&style=none&taskId=u1722f247-b24d-422c-9bc3-23d7f446dca&title=&width=824.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698503386868-52979d14-6f28-4091-8cb7-08160f2eb280.png#averageHue=%23ebeae9&clientId=ue18db17b-c587-4&from=paste&height=607&id=u022c6f12&originHeight=759&originWidth=927&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=135928&status=done&style=none&taskId=u0496e468-2457-40e3-99c5-1e2d6befbe6&title=&width=741.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698503407460-b6e433ca-62ad-4cf6-8d18-fa87a997ffeb.png#averageHue=%23f6f5f4&clientId=ue18db17b-c587-4&from=paste&height=595&id=u09973d0d&originHeight=744&originWidth=1017&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=86708&status=done&style=none&taskId=u11116a06-7287-4352-add0-f865de0e500&title=&width=813.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698503429291-45190d30-2d80-43de-880c-2e65c3b19041.png#averageHue=%23f8f7f7&clientId=ue18db17b-c587-4&from=paste&height=615&id=u4178433e&originHeight=769&originWidth=994&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=64801&status=done&style=none&taskId=ua18e17d6-2cca-4c2d-87b1-fd4f5bbd10e&title=&width=795.2" alt="image.png"></p><h2 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h2><p>1.<a href="https://segmentfault.com/q/1010000042900375">Maven 错误：模块的 Maven 项目配置不可用</a><br>解决方法：右键单击 pom.xml，然后单击“添加为 Maven 项目”。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><a href="https://zhuanlan.zhihu.com/p/126507013">Web Service是一种可以接收从Internet或者Intranet上的其它系统中传递过来的请求，轻量级的独立的通讯技术</a><a href="https://zhuanlan.zhihu.com/p/126507013">。它是通过SOAP在Web上提供的软件服务，使用WSDL文件进行说明，并通过UDDI进行注册</a><a href="https://zhuanlan.zhihu.com/p/126507013">。WebService是一种跨编程语言和跨操作系统平台的远程调用技术</a><a href="https://zhuanlan.zhihu.com/p/126507013">1</a><a href="https://zhuanlan.zhihu.com/p/126507013">。WebService三要素是SOAP、WSDL、UDDI</a>。<br><a href="https://zhuanlan.zhihu.com/p/126507013">SOAP是WebService通过HTTP协议发送请求和接收结果时，发送的请求内容和结果内容都采用XML格式封装，并增加了一些特定的HTTP消息头，以说明HTTP消息的内容格式，这些特定的HTTP消息头和XML内容格式就是SOAP协议</a><a href="https://zhuanlan.zhihu.com/p/126507013">。SOAP提供了标准的RPC (远程调用技术)方法来调用Web Service</a>。<br><a href="https://zhuanlan.zhihu.com/p/126507013">WSDL是WebService客户端要调用一个WebService服务，首先要有知道这个服务的地址在哪，以及这个服务里有什么方法可以调用，所以，WebService务器端首先要通过一个WSDL文件来说明自己家里有啥服务可以对外调用，服务是什么（服务中有哪些方法，方法接受的参数是什么，返回值是什么），服务的网络地址用哪个url地址表示，服务通过什么方式来调用。WSDL ( Web Services Description Language)就是这样一个基于XML的语言，用于描述Web Service及其函数、参数和返回值</a>。<br><a href="https://zhuanlan.zhihu.com/p/126507013">UDDI是一个跨产业、跨平台的开放性架构，可以帮助 Web 服务提供商在互联网上发布 Web 服务的信息。UDDI 是一种目录服务，企业可以通过 UDDI 来注册和搜索 Web 服务。简单来说，UDDI 就是一个目录，只不过在这个目录中存放的是一些关于 Web 服务的信息而已</a>。</p>]]></content>
    
    
    <categories>
      
      <category>课程作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程作业</tag>
      
      <tag>软件体系结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spirngboot3整合swagger3</title>
    <link href="/2024/01/23/springboot3%E7%BB%93%E5%90%88swagger3%E5%B9%B6%E5%AF%BC%E5%85%A5%E5%88%B0APIfox_/"/>
    <url>/2024/01/23/springboot3%E7%BB%93%E5%90%88swagger3%E5%B9%B6%E5%AF%BC%E5%85%A5%E5%88%B0APIfox_/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><p>SpringBoot3.x使用Swagger - 掘金](<a href="https://juejin.cn/post/7299800370489966630#heading-22">https://juejin.cn/post/7299800370489966630#heading-22</a>)</p><h3 id="导入依赖："><a href="#导入依赖：" class="headerlink" title="导入依赖："></a>导入依赖：</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springdoc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springdoc-openapi-starter-webmvc-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h3><ul><li><p>开发环境</p></li><li><p>开发环境通常会开启Swagger文档，方便前端查阅文档</p><div class="code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">springdoc:</span>  api-docs:<span class="hljs-symbol">    enabled:</span> true <span class="hljs-meta"># 开启OpenApi接口</span><span class="hljs-symbol">    path:</span> <span class="hljs-keyword">/user-service/</span>v3/api-docs  <span class="hljs-meta"># 自定义文档接口路径，默认为 <span class="hljs-string">&quot;/v3/api-docs&quot;</span></span>  swagger-ui:<span class="hljs-symbol">    enabled:</span> true <span class="hljs-meta"># 开启swagger界面，依赖OpenApi，需要OpenApi同时开启</span><span class="hljs-symbol">    path:</span> <span class="hljs-keyword">/user-service/</span>swagger-ui/index.html <span class="hljs-meta"># 自定义UI路径，默认为<span class="hljs-string">&quot;/swagger-ui/index.html&quot;</span></span></code></pre></div></li><li><p>生产环境</p></li><li><p>切记生产环境要关闭文档</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">springdoc:</span>  <span class="hljs-attr">api-docs:</span>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 关闭OpenApi接口</span>  <span class="hljs-attr">swagger-ui:</span>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 关闭swagger界面</span></code></pre></div></li></ul><h3 id="向spring容器中注入swagger配置类："><a href="#向spring容器中注入swagger配置类：" class="headerlink" title="向spring容器中注入swagger配置类："></a>向spring容器中注入swagger配置类：</h3><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> OpenAPI swaggerOpenApi() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">OpenAPI</span>()                .info(<span class="hljs-keyword">new</span> <span class="hljs-type">Info</span>().title(<span class="hljs-string">&quot;XXX平台YYY微服务&quot;</span>)                        .description(<span class="hljs-string">&quot;描述平台多牛逼&quot;</span>)                        .version(<span class="hljs-string">&quot;v1.0.0&quot;</span>))                .externalDocs(<span class="hljs-keyword">new</span> <span class="hljs-type">ExternalDocumentation</span>()                        .description(<span class="hljs-string">&quot;设计文档&quot;</span>)                        .url(<span class="hljs-string">&quot;https://juejin.cn/user/254742430749736/posts&quot;</span>));    &#125;&#125;</code></pre></div><p>上面配置后暂时的界面为：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705912047289-0a11942a-5e70-46ef-9578-64ee5795c1ce.png#averageHue=%23f9f9f9&clientId=u7b97a79a-fc79-4&from=paste&height=215&id=u80bf11bd&originHeight=269&originWidth=760&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=18465&status=done&style=none&taskId=u92aff4d4-0083-4091-a0e5-3df05047719&title=&width=608" alt="image.png"></p><h3 id="常用注解："><a href="#常用注解：" class="headerlink" title="常用注解："></a>常用注解：</h3><table><thead><tr><th>注解</th><th>标注位置</th><th>作用</th></tr></thead><tbody><tr><td>@Tag</td><td>controller 类</td><td>标识 controller 作用</td></tr><tr><td>@Parameter</td><td>参数</td><td>标识参数作用</td></tr><tr><td>@Parameters</td><td>参数</td><td>参数多重说明</td></tr><tr><td>@Schema</td><td>model 层的 JavaBean</td><td>描述模型作用及每个属性</td></tr><tr><td>@Operation</td><td>方法</td><td>描述方法作用</td></tr><tr><td>@ApiResponse</td><td>方法</td><td>描述响应状态码等</td></tr></tbody></table><p>@Schema: Swagger文档的注解，用于说明类&#x2F;字段 </p><ul><li>title: 类&#x2F;字段说明</li><li>example: 示例，Swagger中会将这个字段作为示例</li><li>minLength&#x2F;maxLength: 最小&#x2F;最大长度，字段为String类型时生效(仅用于文档说明，不会抛出异常)</li><li>minimum&#x2F;maximum: 最小&#x2F;最大值，字段为数字时有效(仅用于文档说明，不会抛出异常)</li><li>@Tag: 控制器说明 </li><li>name: 名称</li><li>description: 描述说明</li><li>@PostMapping: 使用post方法，一般用于新增记录</li><li>@Operation: 请求说明 </li><li>summary: 说明，Swagger页面在方法后面，不会被折叠</li><li>descirption: 描述，会被折叠到方法说明中</li></ul><h3 id="导入APIfox"><a href="#导入APIfox" class="headerlink" title="导入APIfox:"></a>导入APIfox:</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705912284460-46e461c3-dbac-46c2-bfb0-5298fde545ff.png#averageHue=%23eac493&clientId=u7b97a79a-fc79-4&from=paste&height=727&id=ua527c034&originHeight=909&originWidth=1706&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=129559&status=done&style=none&taskId=ucd65ff91-9088-4d92-9113-81cb506f766&title=&width=1364.8" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>springboot3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatisPlus</title>
    <link href="/2024/01/23/mybatis-plus/"/>
    <url>/2024/01/23/mybatis-plus/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>采用的是黑马的mybatisPlus教程!<br><a href="https://b11et3un53m.feishu.cn/wiki/PsyawI04ei2FQykqfcPcmd7Dnsc">mybatis教程！</a><br>使用的springboot3和JDK17完成的！和黑马的有点区别！</p><h2 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h2><p>1.Hutool 是一个由 Java 编写的强大、完善且易用的 Java 工具类库，它封装了很多常用的 Java 方法，包括但不限于日期时间处理、字符串处理、文件操作、网络请求、加密解密、数据验证、反射工具等。通过引入 hutool-all 依赖，开发者可以方便地在项目中使用 Hutool 提供的各种便捷工具方法，以减少重复造轮子的工作，提高开发效率<br>2.@RequiredArgsConstructor 是 Lombok 库中的一个注解，它能够自动生成构造方法。当类中包含 final 或者非 null 的不可变字段时，Lombok 会为这些字段生成一个构造器，确保在创建对象实例时必须为这些字段提供值。<br>3.接口中可以有default修饰的方法！default修饰的方法为默认方法可以不用重写！</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserService</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductBalance</span><span class="hljs-params">(Long id, Integer money)</span> &#123;        <span class="hljs-comment">// 1.查询用户</span>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.getById(id);        <span class="hljs-comment">// 2.判断用户状态</span>        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span> || user.getStatus() == UserStatus.FROZEN) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;用户状态异常&quot;</span>);        &#125;        <span class="hljs-comment">// 3.判断用户余额</span>        <span class="hljs-keyword">if</span> (user.getBalance() &lt; money) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;用户余额不足&quot;</span>);        &#125;        <span class="hljs-comment">// 4.扣减余额</span>        baseMapper.deductMoneyById(id, money);    &#125;&#125;<span class="hljs-comment">// 上面是mybatisPlus中的代码片段；其中的IUserService接口继承了IService接口，IService中</span><span class="hljs-comment">// 有一个default修饰的getById方法，我们可以super.getById(id);调用该方法实现查询效果！</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.RequiredArgsConstructor;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String username; <span class="hljs-comment">// final 字段或 @NonNull 注解的字段</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> age;    <span class="hljs-comment">// Lombok 会自动生成以下构造方法：</span>    <span class="hljs-comment">// public User(String username, int age) &#123;</span>    <span class="hljs-comment">//     this.username = username;</span>    <span class="hljs-comment">//     this.age = age;</span>    <span class="hljs-comment">// &#125;</span>&#125;</code></pre></div><p>在这个例子中，由于 username 和 age 都是 final 字段，@RequiredArgsConstructor 会生成一个构造方法，要求在创建 User 类的新实例时必须传入这两个参数的值。这样可以确保这些关键字段在对象初始化时就具有有效的值，有助于防止 NullPointerException 等问题的发生。<br>3.@RequestParam 和@PathVariable的区别：<br>@RequestParam从请求中提取查询参数，也就是从url后面的？开始的数据：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span><span class="hljs-meta">@Operation(summary = &quot;根据id集合查询用户&quot;)</span><span class="hljs-keyword">public</span> List&lt;UserVO&gt; <span class="hljs-title function_">queryUserByIds</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;ids&quot;z List&lt;Long&gt; ids)</span></span><span class="hljs-params">// <span class="hljs-meta">@RequestParam(&quot;ids&quot;)</span>注解处理的是请求路径后面的参数：</span><span class="hljs-params">// http://localhost:<span class="hljs-number">8080</span>/users?ids=<span class="hljs-number">1</span>,<span class="hljs-number">2</span></span></code></pre></div><p>@PathVariable是以路径中某段为参数：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span>    <span class="hljs-meta">@Operation(summary = &quot;根据id查询用户&quot;)</span>    <span class="hljs-keyword">public</span> UserVO <span class="hljs-title function_">queryUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long userId)</span><span class="hljs-comment">// http://localhost:8080/users/1</span></code></pre></div><p>4.主键，外键，虚拟外键：<br><a href="https://www.cnblogs.com/dgp-zjz/p/16470132.html">https://www.cnblogs.com/dgp-zjz/p/16470132.html</a></p><div class="code-wrapper"><pre><code class="hljs">主键：用来保证数据完整性 外键：用来和其他表建立联系用的 索引：是提高查询排序的速度</code></pre></div><div class="code-wrapper"><pre><code class="hljs">主键：主键只能有一个外键：一个表可以有多个外键索引：一个表可以有多个唯一索引</code></pre></div><div class="code-wrapper"><pre><code class="hljs autohotkey">PRIMARY KEY设置主键 (&#x27;设置的主键字段&#x27;),KEY `自定义KEY名` (`定义外键字段名`),CONSTRAINT限制 `自定义KEY名` FOREIGN KEY外键 (`自定外键字段名`) REFERENCES 引用 `引用表` (`引用字段设为外键`))<span class="hljs-comment">;</span></code></pre></div><p>外键和主键建立了关系，那么外键所在的表中数据和主键表有关联关系就无法删除外键中的数据的！<br>虚拟外键表示的是表之间有逻辑上的关联关系！其实际上并没有实际的强制性约束！<br>5.mybatis-plus 开启与关闭 SQL 日志打印<br><a href="https://blog.csdn.net/jiangchao858/article/details/115676371">mybatis-plus 开启与关闭 SQL 日志打印_mybatis plus 开启sql记录-CSDN博客</a><br><a href="https://so.csdn.net/so/search?q=Mybatis&spm=1001.2101.3001.7020">Mybatis</a>-plus 需要通过下面的方式开启控制台 SQL 日志打印：</p><div class="code-wrapper"><pre><code class="hljs stylus">mybatis-plus:  configuration:    log-impl: org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.ibatis</span><span class="hljs-selector-class">.logging</span><span class="hljs-selector-class">.stdout</span><span class="hljs-selector-class">.StdOutImpl</span></code></pre></div><p>6.DTO(Data Transfer Object）是数据传输对象！一般用来映射传输过程中的数据的！<br>7.@Date  :</p><div class="code-wrapper"><pre><code class="hljs less">使用<span class="hljs-variable">@Data</span>注解可以简化Java类的编写，减少样板代码，并提高代码的可读性和可维护性。当在类级别上使用<span class="hljs-variable">@Data</span>注解时，Lombok会自动为该类的所有非静态字段生成以下方法：Getter方法：自动生成所有非静态字段的对应getter方法。Setter方法：自动生成所有非静态字段的对应setter方法。<span class="hljs-built_in">toString</span>()方法：生成一个包含所有字段的字符串表示，方便调试和日志输出。<span class="hljs-built_in">equals</span>()方法：自动生成基于所有字段的相等比较方法。<span class="hljs-built_in">hashCode</span>()方法：自动生成基于所有字段的散列码计算方法。</code></pre></div><h2 id="MyBatis-Plus的特性"><a href="#MyBatis-Plus的特性" class="headerlink" title="MyBatis Plus的特性:"></a>MyBatis Plus的特性:</h2><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作.</li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门:"></a>快速入门:</h2><h4 id="引入依赖："><a href="#引入依赖：" class="headerlink" title="引入依赖："></a>引入依赖：</h4><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-spring-boot3-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--由于springboot3和mybatisplus兼容性的问题这里引入的依赖最好是这样的！  --&gt;</span></code></pre></div><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>mapper接口要继承BaseMapper<User> 这里的User对应查询结果的类型！同时要注意在启动类上添加组件@Mapper注解 不然spring扫描不到Mapper接口类就无法注入到容器中了！当然也可以在Mapper接口上添加@Mapper 注解  ；</p><div class="code-wrapper"><pre><code class="hljs xml">MybatisPlus就是根据PO实体的信息来推断出表的信息，从而生成SQL的。默认情况下：- MybatisPlus会把PO实体的类名驼峰转下划线作为表名- MybatisPlus会把PO实体的所有变量名驼峰转下划线作为表的字段名，并根据变量类型推断字段类型- MybatisPlus会把名为id的字段作为主键</code></pre></div><h4 id="常见注解："><a href="#常见注解：" class="headerlink" title="常见注解："></a>常见注解：</h4><h5 id="TableName："><a href="#TableName：" class="headerlink" title="@TableName："></a>@TableName：</h5><ul><li>描述：表名注解，标识实体类对应的表</li><li>使用位置：实体类</li></ul><p>TableName注解除了指定表名以外，还可以指定很多其它属性：</p><table><thead><tr><th><strong>属性</strong></th><th><strong>类型</strong></th><th><strong>必须指定</strong></th><th><strong>默认值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>value</td><td>String</td><td>否</td><td>“”</td><td>表名</td></tr><tr><td>schema</td><td>String</td><td>否</td><td>“”</td><td>schema</td></tr><tr><td>keepGlobalPrefix</td><td>boolean</td><td>否</td><td>false</td><td>是否保持使用全局的 tablePrefix 的值（当全局 tablePrefix 生效时）</td></tr><tr><td>resultMap</td><td>String</td><td>否</td><td>“”</td><td>xml 中 resultMap 的 id（用于满足特定类型的实体类对象绑定）</td></tr><tr><td>autoResultMap</td><td>boolean</td><td>否</td><td>false</td><td>是否自动构建 resultMap 并使用（如果设置 resultMap 则不会进行 resultMap 的自动构建与注入）</td></tr><tr><td>excludeProperty</td><td>String[]</td><td>否</td><td>{}</td><td>需要排除的属性名 @since 3.3.1</td></tr></tbody></table><h5 id="TableId："><a href="#TableId：" class="headerlink" title="@TableId："></a>@TableId：</h5><ul><li>描述：主键注解，标识实体类中的主键字段</li><li>使用位置：实体类的主键字段</li></ul><p>TableId注解支持两个属性：</p><table><thead><tr><th><strong>属性</strong></th><th><strong>类型</strong></th><th><strong>必须指定</strong></th><th><strong>默认值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>value</td><td>String</td><td>否</td><td>“”</td><td>表名</td></tr><tr><td>type</td><td>Enum</td><td>否</td><td>IdType.NONE</td><td>指定主键类型</td></tr></tbody></table><p>IdType支持的类型有：</p><table><thead><tr><th><strong>值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>AUTO</td><td>数据库 ID 自增</td></tr><tr><td>NONE</td><td>无状态，该类型为未设置主键类型（注解里等于跟随全局，全局里约等于 INPUT）</td></tr><tr><td>INPUT</td><td>insert 前自行 set 主键值</td></tr><tr><td>ASSIGN_ID</td><td>分配 ID(主键类型为 Number(Long 和 Integer)或 String)(since 3.3.0),使用接口IdentifierGenerator的方法nextId(默认实现类为DefaultIdentifierGenerator雪花算法)</td></tr><tr><td>ASSIGN_UUID</td><td>分配 UUID,主键类型为 String(since 3.3.0),使用接口IdentifierGenerator的方法nextUUID(默认 default 方法)</td></tr><tr><td><del>ID_WORKER</del></td><td>分布式全局唯一 ID 长整型类型(please use ASSIGN_ID)</td></tr><tr><td><del>UUID</del></td><td>32 位 UUID 字符串(please use ASSIGN_UUID)</td></tr><tr><td><del>ID_WORKER_STR</del></td><td>分布式全局唯一 ID 字符串类型(please use ASSIGN_ID)</td></tr></tbody></table><p>这里比较常见的有三种：</p><ul><li>AUTO：利用数据库的id自增长</li><li>INPUT：手动生成id</li><li>ASSIGN_ID：雪花算法生成Long类型的全局唯一id，这是默认的ID策略</li></ul><h5 id="TableField："><a href="#TableField：" class="headerlink" title="@TableField："></a>@TableField：</h5><p>描述：普通字段注解<br>一般情况下我们并不需要给字段添加@TableField注解，一些特殊情况除外：</p><ul><li>成员变量名与数据库字段名不一致</li><li>成员变量是以isXXX命名，按照JavaBean的规范，MybatisPlus识别字段时会把is去除，这就导致与数据库不符。</li><li>成员变量名与数据库一致，但是与数据库的关键字冲突。使用@TableField注解给字段名添加转义字符：&#96;&#96;</li></ul><h4 id="常见配置："><a href="#常见配置：" class="headerlink" title="常见配置："></a>常见配置：</h4><p>大多数的配置都有默认值，因此我们都无需配置。但还有一些是没有默认值的，例如:</p><ul><li>实体类的别名扫描包</li><li>全局id类型<div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.itheima.mp.domain.po</span>  <span class="hljs-attr">global-config:</span>    <span class="hljs-attr">db-config:</span>      <span class="hljs-attr">id-type:</span> <span class="hljs-string">auto</span> <span class="hljs-comment"># 全局id类型为自增长</span></code></pre></div>需要注意的是，MyBatisPlus也支持手写SQL的，而mapper文件的读取地址可以自己配置：<div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">mybatis-plus:</span>  mapper-locations: <span class="hljs-string">&quot;classpath*:/mapper/**/*.xml&quot;</span> <span class="hljs-comment"># Mapper.xml文件地址，当前这个是默认值。</span></code></pre></div>可以看到默认值是classpath*:&#x2F;mapper&#x2F;**&#x2F;*.xml，也就是说我们只要把mapper.xml文件放置这个目录下就一定会被加载。<br>xml书写样式：<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.itheima.mp.mapper.UserMapper&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span>        SELECT * FROM user WHERE id = #&#123;id&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div>上面的resuletType需要在spring的mybatis-plus配置中配置如下配置才能使用：<div class="code-wrapper"><pre><code class="hljs xml">mybatis-plus:  mapper-locations: &quot;classpath*:/mapper/**/*.xml&quot; # Mapper.xml文件地址，当前这个是默认值。  type-aliases-package: com.example.mp.po<span class="hljs-comment">&lt;!-- mapper-locations该配置是让resultType可以直接使用类名，而不是全类名</span><span class="hljs-comment">mapper-locations是为了定位mapper.xml文件的位置</span><span class="hljs-comment">--&gt;</span></code></pre></div></li></ul><h2 id="核心功能："><a href="#核心功能：" class="headerlink" title="核心功能："></a>核心功能：</h2><h4 id="QueryWrapper："><a href="#QueryWrapper：" class="headerlink" title="QueryWrapper："></a>QueryWrapper：</h4><p>无论是修改、删除、查询，都可以使用QueryWrapper来构建查询条件。接下来看一些例子： <strong>查询</strong>：查询出名字中带o的，存款大于等于1000元的人。代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">void</span> <span class="hljs-title function_">testQueryWrapper</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">// 1.构建查询条件 where name like &quot;%o%&quot; AND balance &gt;= 1000</span>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;()    .select(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-string">&quot;balance&quot;</span>)    .like(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>)    .ge(<span class="hljs-string">&quot;balance&quot;</span>, <span class="hljs-number">1000</span>);    <span class="hljs-comment">// 2.查询数据</span>    List&lt;User&gt; users = userMapper.selectList(wrapper);    users.forEach(System.out::println);&#125;<span class="hljs-comment">// Wrapper是包装的意思；上面使用的select表示是一个select语句的包装！上面采用的是链式编程；</span><span class="hljs-comment">// .like对应sql语句中的like关键字！ge对应的是大于和等于！</span></code></pre></div><p><strong>更新</strong>：更新用户名为jack的用户的余额为2000，代码如下：：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdateByQueryWrapper</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">// 1.构建查询条件 where name = &quot;Jack&quot;</span>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;().eq(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>);    <span class="hljs-comment">// 2.更新数据，user中非null字段都会作为set语句</span>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();    user.setBalance(<span class="hljs-number">2000</span>);    userMapper.update(user, wrapper);&#125;</code></pre></div><h4 id="UpdateWrapper："><a href="#UpdateWrapper：" class="headerlink" title="UpdateWrapper："></a>UpdateWrapper：</h4><p>基于BaseMapper中的update方法更新时只能直接赋值，对于一些复杂的需求就难以实现。 例如：更新id为1,2,4的用户的余额，扣200，对应的SQL应该是：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">UPDATE</span> user SET balance = balance - <span class="hljs-number">200</span> WHERE id in (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)</code></pre></div><p>SET的赋值结果是基于字段现有值的，这个时候就要利用UpdateWrapper中的setSql功能了：</p><div class="code-wrapper"><pre><code class="hljs pgsql">@Test<span class="hljs-type">void</span> testUpdateWrapper() &#123;    List&lt;Long&gt; ids = List.<span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>L, <span class="hljs-number">2</span>L, <span class="hljs-number">4</span>L);    // <span class="hljs-number">1.</span>生成<span class="hljs-keyword">SQL</span>    UpdateWrapper&lt;<span class="hljs-keyword">User</span>&gt; <span class="hljs-keyword">wrapper</span> = <span class="hljs-built_in">new</span> UpdateWrapper&lt;<span class="hljs-keyword">User</span>&gt;()            .setSql(&quot;balance = balance - 200&quot;) // <span class="hljs-keyword">SET</span> balance = balance - <span class="hljs-number">200</span>            .<span class="hljs-keyword">in</span>(&quot;id&quot;, ids); // <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)        // <span class="hljs-number">2.</span>更新，注意第一个参数可以给<span class="hljs-keyword">null</span>，也就是不填更新字段和数据，    // 而是基于UpdateWrapper中的setSQL来更新    userMapper.<span class="hljs-keyword">update</span>(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">wrapper</span>);&#125;</code></pre></div><h4 id="LambdaQueryWrapper："><a href="#LambdaQueryWrapper：" class="headerlink" title="LambdaQueryWrapper："></a>LambdaQueryWrapper：</h4><p>无论是QueryWrapper还是UpdateWrapper在构造条件的时候都需要写死字段名称，会出现字符串魔法值。这在编程规范中显然是不推荐的。 那怎么样才能不写字段名，又能知道字段名呢？<br>其中一种办法是基于变量的gettter方法结合反射技术。因此我们只要将条件对应的字段的getter方法传递给MybatisPlus，它就能计算出对应的变量名了。而传递方法可以使用JDK8中的方法引用和Lambda表达式。 因此MybatisPlus又提供了一套基于Lambda的Wrapper，包含两个：</p><ul><li>LambdaQueryWrapper</li><li>LambdaUpdateWrapper</li></ul><p>分别对应QueryWrapper和UpdateWrapper<br>其使用方式如下：</p><div class="code-wrapper"><pre><code class="hljs pgsql">@Test<span class="hljs-type">void</span> testLambdaQueryWrapper() &#123;    // <span class="hljs-number">1.</span>构建条件 <span class="hljs-keyword">WHERE</span> username <span class="hljs-keyword">LIKE</span> &quot;%o%&quot; <span class="hljs-keyword">AND</span> balance &gt;= <span class="hljs-number">1000</span>    QueryWrapper&lt;<span class="hljs-keyword">User</span>&gt; <span class="hljs-keyword">wrapper</span> = <span class="hljs-built_in">new</span> QueryWrapper&lt;&gt;();    <span class="hljs-keyword">wrapper</span>.lambda()            .<span class="hljs-keyword">select</span>(<span class="hljs-keyword">User</span>::getId, <span class="hljs-keyword">User</span>::getUsername, <span class="hljs-keyword">User</span>::getInfo, <span class="hljs-keyword">User</span>::getBalance)            .<span class="hljs-keyword">like</span>(<span class="hljs-keyword">User</span>::getUsername, &quot;o&quot;)            .ge(<span class="hljs-keyword">User</span>::getBalance, <span class="hljs-number">1000</span>);    // <span class="hljs-number">2.</span>查询    List&lt;<span class="hljs-keyword">User</span>&gt; users = userMapper.selectList(<span class="hljs-keyword">wrapper</span>);    users.<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>::println);&#125;</code></pre></div><h2 id="自定义SQL："><a href="#自定义SQL：" class="headerlink" title="自定义SQL："></a>自定义SQL：</h2><h4 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h4><p>以当前案例来说，我们可以这样写：</p><div class="code-wrapper"><pre><code class="hljs pgsql">@Test<span class="hljs-type">void</span> testCustomWrapper() &#123;    // <span class="hljs-number">1.</span>准备自定义查询条件    List&lt;Long&gt; ids = List.<span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>L, <span class="hljs-number">2</span>L, <span class="hljs-number">4</span>L);    QueryWrapper&lt;<span class="hljs-keyword">User</span>&gt; <span class="hljs-keyword">wrapper</span> = <span class="hljs-built_in">new</span> QueryWrapper&lt;<span class="hljs-keyword">User</span>&gt;().<span class="hljs-keyword">in</span>(&quot;id&quot;, ids);    // <span class="hljs-number">2.</span>调用mapper的自定义方法，直接传递<span class="hljs-keyword">Wrapper</span>    userMapper.deductBalanceByIds(<span class="hljs-number">200</span>, <span class="hljs-keyword">wrapper</span>);&#125;</code></pre></div><p>然后在UserMapper中自定义SQL：</p><div class="code-wrapper"><pre><code class="hljs pgsql">package com.itheima.mp.mapper;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;<span class="hljs-keyword">import</span> com.itheima.mp.<span class="hljs-keyword">domain</span>.po.<span class="hljs-keyword">User</span>;<span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Param;<span class="hljs-keyword">import</span> org.apache.ibatis.annotations.<span class="hljs-keyword">Update</span>;<span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Param;<span class="hljs-built_in">public</span> interface UserMapper extends BaseMapper&lt;<span class="hljs-keyword">User</span>&gt; &#123;    @<span class="hljs-keyword">Select</span>(&quot;UPDATE user SET balance = balance - #&#123;money&#125; $&#123;ew.customSqlSegment&#125;&quot;)    <span class="hljs-type">void</span> deductBalanceByIds(@Param(&quot;money&quot;) <span class="hljs-type">int</span> <span class="hljs-type">money</span>, @Param(&quot;ew&quot;) QueryWrapper&lt;<span class="hljs-keyword">User</span>&gt; <span class="hljs-keyword">wrapper</span>);&#125;</code></pre></div><h4 id="多表关联："><a href="#多表关联：" class="headerlink" title="多表关联："></a>多表关联：</h4><p>理论上来讲MyBatisPlus是不支持多表查询的，不过我们可以利用Wrapper中自定义条件结合自定义SQL来实现多表查询的效果。 例如，我们要查询出所有收货地址在北京的并且用户id在1、2、4之中的用户 要是自己基于mybatis实现SQL，大概是这样的：</p><div class="code-wrapper"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">select</span> id=&quot;queryUserByIdAndAddr&quot; resultType=&quot;com.itheima.mp.domain.po.User&quot;&gt;      <span class="hljs-keyword">SELECT</span> *      <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> u      <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> address a <span class="hljs-keyword">ON</span> u.id = a.user_id      <span class="hljs-keyword">WHERE</span> u.id      &lt;<span class="hljs-keyword">foreach</span> collection=&quot;ids&quot; separator=&quot;,&quot; item=&quot;id&quot; <span class="hljs-keyword">open</span>=&quot;IN (&quot; <span class="hljs-keyword">close</span>=&quot;)&quot;&gt;          #&#123;id&#125;      &lt;/<span class="hljs-keyword">foreach</span>&gt;      <span class="hljs-keyword">AND</span> a.city = #&#123;city&#125;  &lt;/<span class="hljs-keyword">select</span>&gt;</code></pre></div><p>可以看出其中最复杂的就是WHERE条件的编写，如果业务复杂一些，这里的SQL会更变态。<br>但是基于自定义SQL结合Wrapper的玩法，我们就可以利用Wrapper来构建查询条件，然后手写SELECT及FROM部分，实现多表查询。<br>查询条件这样来构建：</p><div class="code-wrapper"><pre><code class="hljs pgsql">@Test<span class="hljs-type">void</span> testCustomJoinWrapper() &#123;    // <span class="hljs-number">1.</span>准备自定义查询条件    QueryWrapper&lt;<span class="hljs-keyword">User</span>&gt; <span class="hljs-keyword">wrapper</span> = <span class="hljs-built_in">new</span> QueryWrapper&lt;<span class="hljs-keyword">User</span>&gt;()            .<span class="hljs-keyword">in</span>(&quot;u.id&quot;, List.<span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>L, <span class="hljs-number">2</span>L, <span class="hljs-number">4</span>L))            .eq(&quot;a.city&quot;, &quot;北京&quot;);    // <span class="hljs-number">2.</span>调用mapper的自定义方法    List&lt;<span class="hljs-keyword">User</span>&gt; users = userMapper.queryUserByWrapper(<span class="hljs-keyword">wrapper</span>);    users.<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>::println);&#125;</code></pre></div><p>然后在UserMapper中自定义方法：</p><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@Select</span>(<span class="hljs-string">&quot;SELECT u.* FROM user u INNER JOIN address a ON u.id = a.user_id $&#123;ew.customSqlSegment&#125;&quot;</span>)List&lt;User&gt; <span class="hljs-built_in">queryUserByWrapper</span>(<span class="hljs-variable">@Param</span>(<span class="hljs-string">&quot;ew&quot;</span>)QueryWrapper&lt;User&gt; wrapper);</code></pre></div><p>当然，也可以在UserMapper.xml中写SQL：</p><div class="code-wrapper"><pre><code class="hljs n1ql">&lt;<span class="hljs-keyword">select</span> id=<span class="hljs-string">&quot;queryUserByIdAndAddr&quot;</span> resultType=<span class="hljs-string">&quot;com.itheima.mp.domain.po.User&quot;</span>&gt;    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> u <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> address a <span class="hljs-keyword">ON</span> u.id = a.user_id $&#123;ew.customSqlSegment&#125;&lt;/<span class="hljs-keyword">select</span>&gt;</code></pre></div><h2 id="Service接口："><a href="#Service接口：" class="headerlink" title="Service接口："></a>Service接口：</h2><p>MybatisPlus不仅提供了BaseMapper，还提供了通用的Service接口及默认实现，封装了一些常用的service模板方法。 通用接口为IService，默认实现为ServiceImpl，其中封装的方法可以分为以下几类：</p><ul><li>save：新增</li><li>remove：删除</li><li>update：更新</li><li>get：查询单个结果</li><li>list：查询集合结果</li><li>count：计数</li><li>page：分页查询</li></ul><h4 id="CRUD："><a href="#CRUD：" class="headerlink" title="CRUD："></a>CRUD：</h4><p>我们先俩看下基本的CRUD接口。 <strong>新增</strong>：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705901761781-cd483668-f2f2-4e2e-9107-9b3c1e65c8f3.png#averageHue=%23f9f8f5&clientId=ue5cba3c3-0ee1-4&from=paste&id=u3498b97f&originHeight=291&originWidth=890&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u859b1b5c-be7d-4bf6-88b6-e2c4b7549cb&title="></p><ul><li>save是新增单个元素</li><li>saveBatch是批量新增</li><li>saveOrUpdate是根据id判断，如果数据存在就更新，不存在则新增</li><li>saveOrUpdateBatch是批量的新增或修改</li></ul><p><strong>删除：</strong><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705901761807-7b419342-257a-443d-a087-4178259ba765.png#averageHue=%23f9f7f2&clientId=ue5cba3c3-0ee1-4&from=paste&id=u67a1f4d5&originHeight=409&originWidth=913&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u09c5315b-cd84-42e9-a3e7-c3f07669fa8&title="></p><ul><li>removeById：根据id删除</li><li>removeByIds：根据id批量删除</li><li>removeByMap：根据Map中的键值对为条件删除</li><li>remove(Wrapper<T>)：根据Wrapper条件删除</li><li><del>removeBatchByIds</del>：暂不支持</li></ul><p><strong>修改：</strong><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705901761834-e548c4a8-f6e7-4111-a4ad-23fb41d62502.png#averageHue=%23faf6f2&clientId=ue5cba3c3-0ee1-4&from=paste&id=ua1459dfb&originHeight=444&originWidth=931&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u8a5e5127-d5df-434b-94c5-a9fdf3fe20d&title="></p><ul><li>updateById：根据id修改</li><li>update(Wrapper<T>)：根据UpdateWrapper修改，Wrapper中包含set和where部分</li><li>update(T，Wrapper<T>)：按照T内的数据修改与Wrapper匹配到的数据</li><li>updateBatchById：根据id批量修改</li></ul><p><strong>Get：</strong><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705901761918-9986dfba-97fa-4d47-9cfa-f116723710ec.png#averageHue=%23f9f3f1&clientId=ue5cba3c3-0ee1-4&from=paste&id=ua23839c7&originHeight=287&originWidth=897&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ue708b657-e910-4553-bffa-bd944058cd2&title="></p><ul><li>getById：根据id查询1条数据</li><li>getOne(Wrapper<T>)：根据Wrapper查询1条数据</li><li>getBaseMapper：获取Service内的BaseMapper实现，某些时候需要直接调用Mapper内的自定义SQL时可以用这个方法获取到Mapper</li></ul><p><strong>List：</strong><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705901761862-198d733d-3b92-46d6-8467-649a229dd802.png#averageHue=%23f9f5f2&clientId=ue5cba3c3-0ee1-4&from=paste&id=u27975eb9&originHeight=375&originWidth=919&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ud8364a94-27a9-47ab-a8d6-a24c82c60e9&title="></p><ul><li>listByIds：根据id批量查询</li><li>list(Wrapper<T>)：根据Wrapper条件查询多条数据</li><li>list()：查询所有</li></ul><p><strong>Count</strong>：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705901762451-7759b2ce-c219-4a44-bdcf-363e1d09a656.png#averageHue=%23dbc789&clientId=ue5cba3c3-0ee1-4&from=paste&id=uee4df41f&originHeight=134&originWidth=775&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ud373cd64-264c-4314-a3d2-6c85025dc95&title="></p><ul><li>count()：统计所有数量</li><li>count(Wrapper<T>)：统计符合Wrapper条件的数据数量</li></ul><p><strong>getBaseMapper</strong>： 当我们在service中要调用Mapper中自定义SQL时，就必须获取service对应的Mapper，就可以通过这个方法：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705901762655-114bb9d6-350b-492a-9c6c-b68f5224a2d2.png#averageHue=%23f4f4f1&clientId=ue5cba3c3-0ee1-4&from=paste&id=u91305962&originHeight=124&originWidth=529&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uce5abd52-11e2-436a-a76f-fae5d7bf134&title="></p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h3><p>由于Service中经常需要定义与业务有关的自定义方法，因此我们不能直接使用IService，而是自定义Service接口，然后继承IService以拓展方法。同时，让自定义的Service实现类继承ServiceImpl，这样就不用自己实现IService中的接口了。<br>首先，定义IUserService，继承IService：</p><div class="code-wrapper"><pre><code class="hljs angelscript">package com.itheima.mp.service;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;<span class="hljs-keyword">import</span> com.itheima.mp.domain.po.User;<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">IUserService</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">IService</span>&lt;<span class="hljs-symbol">User</span>&gt; &#123;    <span class="hljs-comment">// 拓展自定义方法</span>&#125;</code></pre></div><p>然后，编写UserServiceImpl类，继承ServiceImpl，实现UserService：</p><div class="code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.itheima.mp.service.impl;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.<span class="hljs-type">ServiceImpl</span>;<span class="hljs-keyword">import</span> com.itheima.mp.domain.po.<span class="hljs-type">User</span>;<span class="hljs-keyword">import</span> com.itheima.mp.domain.po.service.<span class="hljs-type">IUserService</span>;<span class="hljs-keyword">import</span> com.itheima.mp.mapper.<span class="hljs-type">UserMapper</span>;<span class="hljs-keyword">import</span> org.springframework.stereotype.<span class="hljs-type">Service</span>;<span class="hljs-meta">@Service</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceImpl&lt;UserMapper</span>, <span class="hljs-title">User&gt;</span> <span class="hljs-title">implements</span> <span class="hljs-title">IUserService</span></span>&#123;&#125;</code></pre></div><h3 id="项目结构如下："><a href="#项目结构如下：" class="headerlink" title="项目结构如下："></a>项目结构如下：</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705918523933-50ecb3ce-9a82-4e92-8af8-516cbcc11a97.png#averageHue=%23f9fbf8&clientId=uc58b97f9-a395-4&from=paste&id=u6a26501b&originHeight=558&originWidth=875&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u8ba7e3f5-2848-400a-9ab3-6115c4fc29b&title="><br>接下来，我们快速实现下面4个接口：</p><table><thead><tr><th><strong>编号</strong></th><th><strong>接口</strong></th><th><strong>请求方式</strong></th><th><strong>请求路径</strong></th><th><strong>请求参数</strong></th><th><strong>返回值</strong></th></tr></thead><tbody><tr><td>1</td><td>新增用户</td><td>POST</td><td>&#x2F;users</td><td>用户表单实体</td><td>无</td></tr><tr><td>2</td><td>删除用户</td><td>DELETE</td><td>&#x2F;users&#x2F;{id}</td><td>用户id</td><td>无</td></tr><tr><td>3</td><td>根据id查询用户</td><td>GET</td><td>&#x2F;users&#x2F;{id}</td><td>用户id</td><td>用户VO</td></tr><tr><td>4</td><td>根据id批量查询</td><td>GET</td><td>&#x2F;users</td><td>用户id集合</td><td>用户VO集合</td></tr></tbody></table><p>首先，我们在项目中引入几个依赖：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--swagger--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.xiaoymin<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>knife4j-openapi2-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--web--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>然后需要配置swagger信息：</p><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">knife4j</span><span class="hljs-punctuation">:</span>  <span class="hljs-attribute">enable</span><span class="hljs-punctuation">:</span> <span class="hljs-string">true</span>  <span class="hljs-attribute">openapi</span><span class="hljs-punctuation">:</span>    <span class="hljs-attribute">title</span><span class="hljs-punctuation">:</span> <span class="hljs-string">用户管理接口文档</span>    <span class="hljs-attribute">description</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;用户管理接口文档&quot;</span>    <span class="hljs-attribute">email</span><span class="hljs-punctuation">:</span> <span class="hljs-string">zhanghuyi@itcast.cn</span>    <span class="hljs-attribute">concat</span><span class="hljs-punctuation">:</span> <span class="hljs-string">虎哥</span>    <span class="hljs-attribute">url</span><span class="hljs-punctuation">:</span> <span class="hljs-string">https://www.itcast.cn</span>    <span class="hljs-attribute">version</span><span class="hljs-punctuation">:</span> <span class="hljs-string">v1.0.0</span>    <span class="hljs-attribute">group</span><span class="hljs-punctuation">:</span>      <span class="hljs-attribute">default</span><span class="hljs-punctuation">:</span>        <span class="hljs-attribute">group-name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">default</span>        <span class="hljs-attribute">api-rule</span><span class="hljs-punctuation">:</span> <span class="hljs-string">package</span>        <span class="hljs-attribute">api-rule-resources</span><span class="hljs-punctuation">:</span>          <span class="hljs-bullet">-</span> <span class="hljs-string">com.itheima.mp.controller</span></code></pre></div><p>然后，接口需要两个实体：</p><ul><li>UserFormDTO：代表新增时的用户表单</li><li>UserVO：代表查询的返回结果</li></ul><p>首先是UserFormDTO：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.itheima.mp.domain.dto;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.<span class="hljs-keyword">annotation</span>.TableField;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.handlers.JacksonTypeHandler;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModel;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModelProperty;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-meta">@ApiModel(description = <span class="hljs-string">&quot;用户表单实体&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserFormDTO</span> &#123;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;id&quot;</span>)</span>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> id;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;用户名&quot;</span>)</span>    <span class="hljs-keyword">private</span> String username;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;密码&quot;</span>)</span>    <span class="hljs-keyword">private</span> String password;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;注册手机号&quot;</span>)</span>    <span class="hljs-keyword">private</span> String phone;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;详细信息，JSON风格&quot;</span>)</span>    <span class="hljs-keyword">private</span> String info;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;账户余额&quot;</span>)</span>    <span class="hljs-keyword">private</span> Integer balance;&#125;</code></pre></div><p>然后是UserVO：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.itheima.mp.domain.vo;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModel;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModelProperty;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-meta">@ApiModel(description = <span class="hljs-string">&quot;用户VO实体&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserVO</span> &#123;        <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;用户id&quot;</span>)</span>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> id;        <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;用户名&quot;</span>)</span>    <span class="hljs-keyword">private</span> String username;        <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;详细信息&quot;</span>)</span>    <span class="hljs-keyword">private</span> String info;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;使用状态（1正常 2冻结）&quot;</span>)</span>    <span class="hljs-keyword">private</span> Integer status;        <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;账户余额&quot;</span>)</span>    <span class="hljs-keyword">private</span> Integer balance;&#125;</code></pre></div><p>最后，按照Restful风格编写Controller接口方法：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.itheima.mp.controller;<span class="hljs-keyword">import</span> cn.hutool.core.bean.BeanUtil;<span class="hljs-keyword">import</span> com.itheima.mp.domain.dto.UserFormDTO;<span class="hljs-keyword">import</span> com.itheima.mp.domain.po.User;<span class="hljs-keyword">import</span> com.itheima.mp.domain.vo.UserVO;<span class="hljs-keyword">import</span> com.itheima.mp.service.IUserService;<span class="hljs-keyword">import</span> io.swagger.annotations.Api;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiOperation;<span class="hljs-keyword">import</span> lombok.RequiredArgsConstructor;<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.*;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-meta">@Api(tags = <span class="hljs-string">&quot;用户管理接口&quot;</span>)</span><span class="hljs-meta">@RequiredArgsConstructor</span><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping(<span class="hljs-string">&quot;users&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IUserService userService;    <span class="hljs-meta">@PostMapping</span>    <span class="hljs-meta">@ApiOperation(<span class="hljs-string">&quot;新增用户&quot;</span>)</span>    <span class="hljs-keyword">public</span> void saveUser(<span class="hljs-meta">@RequestBody</span> UserFormDTO userFormDTO)&#123;        <span class="hljs-comment">// 1.转换DTO为PO</span>        User user = BeanUtil.copyProperties(userFormDTO, User.<span class="hljs-keyword">class</span>);        <span class="hljs-comment">// 2.新增</span>        userService.save(user);    &#125;    <span class="hljs-meta">@DeleteMapping(<span class="hljs-string">&quot;/&#123;id&#125;&quot;</span>)</span>    <span class="hljs-meta">@ApiOperation(<span class="hljs-string">&quot;删除用户&quot;</span>)</span>    <span class="hljs-keyword">public</span> void removeUserById(<span class="hljs-meta">@PathVariable(<span class="hljs-string">&quot;id&quot;</span>)</span> <span class="hljs-built_in">Long</span> userId)&#123;        userService.removeById(userId);    &#125;    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/&#123;id&#125;&quot;</span>)</span>    <span class="hljs-meta">@ApiOperation(<span class="hljs-string">&quot;根据id查询用户&quot;</span>)</span>    <span class="hljs-keyword">public</span> UserVO queryUserById(<span class="hljs-meta">@PathVariable(<span class="hljs-string">&quot;id&quot;</span>)</span> <span class="hljs-built_in">Long</span> userId)&#123;        <span class="hljs-comment">// 1.查询用户</span>        User user = userService.getById(userId);        <span class="hljs-comment">// 2.处理vo</span>        <span class="hljs-keyword">return</span> BeanUtil.copyProperties(user, UserVO.<span class="hljs-keyword">class</span>);    &#125;    <span class="hljs-meta">@GetMapping</span>    <span class="hljs-meta">@ApiOperation(<span class="hljs-string">&quot;根据id集合查询用户&quot;</span>)</span>    <span class="hljs-keyword">public</span> List&lt;UserVO&gt; queryUserByIds(<span class="hljs-meta">@RequestParam(<span class="hljs-string">&quot;ids&quot;</span>)</span> List&lt;<span class="hljs-built_in">Long</span>&gt; ids)&#123;        <span class="hljs-comment">// 1.查询用户</span>        List&lt;User&gt; users = userService.listByIds(ids);        <span class="hljs-comment">// 2.处理vo</span>        <span class="hljs-keyword">return</span> BeanUtil.copyToList(users, UserVO.<span class="hljs-keyword">class</span>);    &#125;&#125;</code></pre></div><p>可以看到上述接口都直接在controller即可实现，无需编写任何service代码，非常方便。<br>不过，一些带有业务逻辑的接口则需要在service中自定义实现了。例如下面的需求：</p><ul><li>根据id扣减用户余额</li></ul><p>这看起来是个简单修改功能，只要修改用户余额即可。但这个业务包含一些业务逻辑处理：</p><ul><li>判断用户状态是否正常</li><li>判断用户余额是否充足</li></ul><p>这些业务逻辑都要在service层来做，另外更新余额需要自定义SQL，要在mapper中来实现。因此，我们除了要编写controller以外，具体的业务还要在service和mapper中编写。<br> 首先在UserController中定义一个方法：</p><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@PutMapping</span>(<span class="hljs-string">&quot;&#123;id&#125;/deduction/&#123;money&#125;&quot;</span>)<span class="hljs-variable">@ApiOperation</span>(<span class="hljs-string">&quot;扣减用户余额&quot;</span>)public void <span class="hljs-built_in">deductBalance</span>(<span class="hljs-variable">@PathVariable</span>(<span class="hljs-string">&quot;id&quot;</span>) Long id, <span class="hljs-variable">@PathVariable</span>(<span class="hljs-string">&quot;money&quot;</span>)Integer money)&#123;    <span class="hljs-selector-tag">userService</span><span class="hljs-selector-class">.deductBalance</span>(id, money);&#125;</code></pre></div><p>然后是UserService接口：</p><div class="code-wrapper"><pre><code class="hljs pgsql">package com.itheima.mp.service;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.<span class="hljs-keyword">extension</span>.service.IService;<span class="hljs-keyword">import</span> com.itheima.mp.<span class="hljs-keyword">domain</span>.po.<span class="hljs-keyword">User</span>;<span class="hljs-built_in">public</span> interface IUserService extends IService&lt;<span class="hljs-keyword">User</span>&gt; &#123;    <span class="hljs-type">void</span> deductBalance(Long id, <span class="hljs-type">Integer</span> <span class="hljs-type">money</span>);&#125;</code></pre></div><p>最后是UserServiceImpl实现类：</p><div class="code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.itheima.mp.service.impl;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.<span class="hljs-type">ServiceImpl</span>;<span class="hljs-keyword">import</span> com.itheima.mp.domain.po.<span class="hljs-type">User</span>;<span class="hljs-keyword">import</span> com.itheima.mp.mapper.<span class="hljs-type">UserMapper</span>;<span class="hljs-keyword">import</span> com.itheima.mp.service.<span class="hljs-type">IUserService</span>;<span class="hljs-keyword">import</span> org.springframework.stereotype.<span class="hljs-type">Service</span>;<span class="hljs-meta">@Service</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceImpl&lt;UserMapper</span>, <span class="hljs-title">User&gt;</span> <span class="hljs-title">implements</span> <span class="hljs-title">IUserService</span> </span>&#123;    <span class="hljs-meta">@Override</span>    public void deductBalance(<span class="hljs-type">Long</span> id, <span class="hljs-type">Integer</span> money) &#123;        <span class="hljs-comment">// 1.查询用户</span>        <span class="hljs-type">User</span> user = getById(id);        <span class="hljs-comment">// 2.判断用户状态</span>        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span> || user.getStatus() == <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>(<span class="hljs-string">&quot;用户状态异常&quot;</span>);        &#125;        <span class="hljs-comment">// 3.判断用户余额</span>        <span class="hljs-keyword">if</span> (user.getBalance() &lt; money) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>(<span class="hljs-string">&quot;用户余额不足&quot;</span>);        &#125;        <span class="hljs-comment">// 4.扣减余额</span>        baseMapper.deductMoneyById(id, money);    &#125;&#125;</code></pre></div><p>最后是mapper：</p><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@Update</span>(<span class="hljs-string">&quot;UPDATE user SET balance = balance - #&#123;money&#125; WHERE id = #&#123;id&#125;&quot;</span>)void <span class="hljs-built_in">deductMoneyById</span>(<span class="hljs-variable">@Param</span>(<span class="hljs-string">&quot;id&quot;</span>) Long id, <span class="hljs-variable">@Param</span>(<span class="hljs-string">&quot;money&quot;</span>) Integer money);</code></pre></div><h3 id="2-3-3-Lambda"><a href="#2-3-3-Lambda" class="headerlink" title="2.3.3.Lambda"></a><strong>2.3.3.Lambda</strong></h3><p>IService中还提供了Lambda功能来简化我们的复杂查询及更新功能。我们通过两个案例来学习一下。<br>案例一：实现一个根据复杂条件查询用户的接口，查询条件如下：</p><ul><li>name：用户名关键字，可以为空</li><li>status：用户状态，可以为空</li><li>minBalance：最小余额，可以为空</li><li>maxBalance：最大余额，可以为空</li></ul><p>可以理解成一个用户的后台管理界面，管理员可以自己选择条件来筛选用户，因此上述条件不一定存在，需要做判断。<br>我们首先需要定义一个查询条件实体，UserQuery实体：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.itheima.mp.domain.query;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModel;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModelProperty;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-meta">@ApiModel(description = <span class="hljs-string">&quot;用户查询条件实体&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserQuery</span> &#123;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;用户名关键字&quot;</span>)</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;用户状态：1-正常，2-冻结&quot;</span>)</span>    <span class="hljs-keyword">private</span> Integer status;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;余额最小值&quot;</span>)</span>    <span class="hljs-keyword">private</span> Integer minBalance;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;余额最大值&quot;</span>)</span>    <span class="hljs-keyword">private</span> Integer maxBalance;&#125;</code></pre></div><p>接下来我们在UserController中定义一个controller方法：</p><div class="code-wrapper"><pre><code class="hljs pgsql">@GetMapping(&quot;/list&quot;)@ApiOperation(&quot;根据id集合查询用户&quot;)<span class="hljs-built_in">public</span> List&lt;UserVO&gt; queryUsers(UserQuery query)&#123;    // <span class="hljs-number">1.</span>组织条件    String username = query.getName();    <span class="hljs-type">Integer</span> status = query.getStatus();    <span class="hljs-type">Integer</span> minBalance = query.getMinBalance();    <span class="hljs-type">Integer</span> maxBalance = query.getMaxBalance();    LambdaQueryWrapper&lt;<span class="hljs-keyword">User</span>&gt; <span class="hljs-keyword">wrapper</span> = <span class="hljs-built_in">new</span> QueryWrapper&lt;<span class="hljs-keyword">User</span>&gt;().lambda()            .<span class="hljs-keyword">like</span>(username != <span class="hljs-keyword">null</span>, <span class="hljs-keyword">User</span>::getUsername, username)            .eq(status != <span class="hljs-keyword">null</span>, <span class="hljs-keyword">User</span>::getStatus, status)            .ge(minBalance != <span class="hljs-keyword">null</span>, <span class="hljs-keyword">User</span>::getBalance, minBalance)            .le(maxBalance != <span class="hljs-keyword">null</span>, <span class="hljs-keyword">User</span>::getBalance, maxBalance);    // <span class="hljs-number">2.</span>查询用户    List&lt;<span class="hljs-keyword">User</span>&gt; users = userService.list(<span class="hljs-keyword">wrapper</span>);    // <span class="hljs-number">3.</span>处理vo    <span class="hljs-keyword">return</span> BeanUtil.copyToList(users, UserVO.<span class="hljs-keyword">class</span>);&#125;</code></pre></div><p>在组织查询条件的时候，我们加入了 username !&#x3D; null 这样的参数，意思就是当条件成立时才会添加这个查询条件，类似Mybatis的mapper.xml文件中的<if>标签。这样就实现了动态查询条件效果了。<br>不过，上述条件构建的代码太麻烦了。 因此Service中对LambdaQueryWrapper和LambdaUpdateWrapper的用法进一步做了简化。我们无需自己通过new的方式来创建Wrapper，而是直接调用lambdaQuery和lambdaUpdate方法：<br>基于Lambda查询：</p><div class="code-wrapper"><pre><code class="hljs lasso">@GetMapping(<span class="hljs-string">&quot;/list&quot;</span>)@ApiOperation(<span class="hljs-string">&quot;根据id集合查询用户&quot;</span>)<span class="hljs-keyword">public</span> <span class="hljs-built_in">List</span>&lt;UserVO&gt; queryUsers(UserQuery query)&#123;    <span class="hljs-comment">// 1.组织条件</span>    <span class="hljs-built_in">String</span> username = query.getName();    <span class="hljs-built_in">Integer</span> status = query.getStatus();    <span class="hljs-built_in">Integer</span> minBalance = query.getMinBalance();    <span class="hljs-built_in">Integer</span> maxBalance = query.getMaxBalance();    <span class="hljs-comment">// 2.查询用户</span>    <span class="hljs-built_in">List</span>&lt;User&gt; users = userService.lambdaQuery()            .like(username != <span class="hljs-built_in">null</span>, User<span class="hljs-type">::getUsername</span>, username)            .<span class="hljs-literal">eq</span>(status != <span class="hljs-built_in">null</span>, User<span class="hljs-type">::getStatus</span>, status)            .ge(minBalance != <span class="hljs-built_in">null</span>, User<span class="hljs-type">::getBalance</span>, minBalance)            .le(maxBalance != <span class="hljs-built_in">null</span>, User<span class="hljs-type">::getBalance</span>, maxBalance)            .<span class="hljs-built_in">list</span>();    <span class="hljs-comment">// 3.处理vo</span>    <span class="hljs-keyword">return</span> BeanUtil.copyToList(users, UserVO.class);&#125;</code></pre></div><p>可以发现lambdaQuery方法中除了可以构建条件，还需要在链式编程的最后添加一个list()，这是在告诉MP我们的调用结果需要是一个list集合。这里不仅可以用list()，可选的方法有：</p><ul><li>.one()：最多1个结果</li><li>.list()：返回集合结果</li><li>.count()：返回计数结果</li></ul><p>MybatisPlus会根据链式编程的最后一个方法来判断最终的返回结果。<br>与lambdaQuery方法类似，IService中的lambdaUpdate方法可以非常方便的实现复杂更新业务。<br>例如下面的需求：<br>需求：改造根据id修改用户余额的接口，要求如下</p><ul><li>如果扣减后余额为0，则将用户status修改为冻结状态（2）</li></ul><p>也就是说我们在扣减用户余额时，需要对用户剩余余额做出判断，如果发现剩余余额为0，则应该将status修改为2，这就是说update语句的set部分是动态的。<br>实现如下：</p><div class="code-wrapper"><pre><code class="hljs pgsql">@Override@Transactional<span class="hljs-built_in">public</span> <span class="hljs-type">void</span> deductBalance(Long id, <span class="hljs-type">Integer</span> <span class="hljs-type">money</span>) &#123;    // <span class="hljs-number">1.</span>查询用户    <span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span> = getById(id);    // <span class="hljs-number">2.</span>校验用户状态    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">user</span> == <span class="hljs-keyword">null</span> || <span class="hljs-keyword">user</span>.getStatus() == <span class="hljs-number">2</span>) &#123;        throw <span class="hljs-built_in">new</span> RuntimeException(&quot;用户状态异常！&quot;);    &#125;    // <span class="hljs-number">3.</span>校验余额是否充足    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">user</span>.getBalance() &lt; <span class="hljs-type">money</span>) &#123;        throw <span class="hljs-built_in">new</span> RuntimeException(&quot;用户余额不足！&quot;);    &#125;    // <span class="hljs-number">4.</span>扣减余额 <span class="hljs-keyword">update</span> tb_user <span class="hljs-keyword">set</span> balance = balance - ?    <span class="hljs-type">int</span> remainBalance = <span class="hljs-keyword">user</span>.getBalance() - <span class="hljs-type">money</span>;    lambdaUpdate()            .<span class="hljs-keyword">set</span>(<span class="hljs-keyword">User</span>::getBalance, remainBalance) // 更新余额            .<span class="hljs-keyword">set</span>(remainBalance == <span class="hljs-number">0</span>, <span class="hljs-keyword">User</span>::getStatus, <span class="hljs-number">2</span>) // 动态判断，是否更新status            .eq(<span class="hljs-keyword">User</span>::getId, id)            .eq(<span class="hljs-keyword">User</span>::getBalance, <span class="hljs-keyword">user</span>.getBalance()) // 乐观锁            .<span class="hljs-keyword">update</span>();&#125;</code></pre></div><h3 id="2-3-4-批量新增"><a href="#2-3-4-批量新增" class="headerlink" title="2.3.4.批量新增"></a><strong>2.3.4.批量新增</strong></h3><p>IService中的批量新增功能使用起来非常方便，但有一点注意事项，我们先来测试一下。 首先我们测试逐条插入数据：</p><div class="code-wrapper"><pre><code class="hljs pgsql">@Test<span class="hljs-type">void</span> testSaveOneByOne() &#123;    long b = <span class="hljs-keyword">System</span>.currentTimeMillis();    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100000</span>; i++) &#123;        userService.save(buildUser(i));    &#125;    long e = <span class="hljs-keyword">System</span>.currentTimeMillis();    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;耗时：&quot; + (e - b));&#125;private <span class="hljs-keyword">User</span> buildUser(<span class="hljs-type">int</span> i) &#123;    <span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">User</span>();    <span class="hljs-keyword">user</span>.setUsername(&quot;user_&quot; + i);    <span class="hljs-keyword">user</span>.setPassword(&quot;123&quot;);    <span class="hljs-keyword">user</span>.setPhone(&quot;&quot; + (<span class="hljs-number">18688190000</span>L + i));    <span class="hljs-keyword">user</span>.setBalance(<span class="hljs-number">2000</span>);    <span class="hljs-keyword">user</span>.setInfo(&quot;&#123;\&quot;age\&quot;: 24, \&quot;intro\&quot;: \&quot;英文老师\&quot;, \&quot;gender\&quot;: \&quot;female\&quot;&#125;&quot;);    <span class="hljs-keyword">user</span>.setCreateTime(LocalDateTime.now());    <span class="hljs-keyword">user</span>.setUpdateTime(<span class="hljs-keyword">user</span>.getCreateTime());    <span class="hljs-keyword">return</span> <span class="hljs-keyword">user</span>;&#125;</code></pre></div><p>执行结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705918577491-79c47877-5315-47bf-986f-b40df37aea6c.png#averageHue=%23f6f8f4&clientId=uc58b97f9-a395-4&from=paste&id=u700a36e1&originHeight=303&originWidth=1525&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uc2e4f0cd-5997-4672-8194-d029834d05f&title="><br> 可以看到速度非常慢。<br>然后再试试MybatisPlus的批处理：</p><div class="code-wrapper"><pre><code class="hljs csharp">@Test<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testSaveBatch</span>()</span> &#123;    <span class="hljs-comment">// 准备10万条数据</span>    List&lt;User&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">1000</span>);    <span class="hljs-built_in">long</span> b = System.currentTimeMillis();    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100000</span>; i++) &#123;        list.<span class="hljs-keyword">add</span>(buildUser(i));        <span class="hljs-comment">// 每1000条批量插入一次</span>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>) &#123;            userService.saveBatch(list);            list.clear();        &#125;    &#125;    <span class="hljs-built_in">long</span> e = System.currentTimeMillis();    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;耗时：&quot;</span> + (e - b));&#125;</code></pre></div><p>执行最终耗时如下：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705918577541-ae31e891-bb24-4ac0-a50f-d225b65174cd.png#averageHue=%23f6f8f4&clientId=uc58b97f9-a395-4&from=paste&id=u11a679bf&originHeight=305&originWidth=1528&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u34d7fc95-cce8-4391-9aa3-cb3a5a64452&title="><br> 可以看到使用了批处理以后，比逐条新增效率提高了10倍左右，性能还是不错的。<br>不过，我们简单查看一下MybatisPlus源码：</p><div class="code-wrapper"><pre><code class="hljs livescript">@Transactional(rollbackFor = Exception.<span class="hljs-keyword">class</span>)@Overridepublic boolean saveBatch(Collection&lt;T&gt; entityList, int batchSize) &#123;    <span class="hljs-built_in">String</span> sqlStatement = getSqlStatement(SqlMethod.INSERT_ONE);    <span class="hljs-keyword">return</span> executeBatch<span class="hljs-function"><span class="hljs-params">(entityList, batchSize, (sqlSession, entity) -&gt; sqlSession.insert(sqlStatement, entity))</span>;</span><span class="hljs-function">&#125;</span><span class="hljs-function">// ...<span class="hljs-title">SqlHelper</span></span><span class="hljs-function"><span class="hljs-title">public</span> <span class="hljs-title">static</span> &lt;<span class="hljs-title">E</span>&gt; <span class="hljs-title">boolean</span> <span class="hljs-title">executeBatch</span><span class="hljs-params">(Class&lt;?&gt; entityClass, Log log, Collection&lt;E&gt; <span class="hljs-keyword">list</span>, int batchSize, BiConsumer&lt;SqlSession, E&gt; consumer)</span> &#123;</span><span class="hljs-function">    <span class="hljs-title">Assert</span>.<span class="hljs-title">isFalse</span><span class="hljs-params">(batchSize &lt; <span class="hljs-number">1</span>, <span class="hljs-string">&quot;batchSize must not be less than one&quot;</span>)</span>;</span><span class="hljs-function">    <span class="hljs-title">return</span> !<span class="hljs-title">CollectionUtils</span>.<span class="hljs-title">isEmpty</span><span class="hljs-params">(<span class="hljs-keyword">list</span>)</span> &amp;&amp; <span class="hljs-title">executeBatch</span><span class="hljs-params">(entityClass, log, sqlSession -&gt; &#123;</span></span><span class="hljs-params"><span class="hljs-function">        int size = <span class="hljs-keyword">list</span>.size();</span></span><span class="hljs-params"><span class="hljs-function">        int idxLimit = <span class="hljs-built_in">Math</span>.min(batchSize, size);</span></span><span class="hljs-params"><span class="hljs-function">        int i = <span class="hljs-number">1</span>;</span></span><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span> (E element : <span class="hljs-keyword">list</span>) &#123;</span></span><span class="hljs-params"><span class="hljs-function">            consumer.accept(sqlSession, element);</span></span><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">if</span> (i == idxLimit) &#123;</span></span><span class="hljs-params"><span class="hljs-function">                sqlSession.flushStatements();</span></span><span class="hljs-params"><span class="hljs-function">                idxLimit = <span class="hljs-built_in">Math</span>.min(idxLimit + batchSize, size);</span></span><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><span class="hljs-params"><span class="hljs-function">            i++;</span></span><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><span class="hljs-params"><span class="hljs-function">    &#125;)</span>;</span><span class="hljs-function">&#125;</span></code></pre></div><p>可以发现其实MybatisPlus的批处理是基于PrepareStatement的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。SQL类似这样：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Preparing</span>: INSERT INTO user ( username, password, phone, info, balance, create_time, update_time ) VALUES ( ?, ?, ?, ?, ?, ?, ? )<span class="hljs-attribute">Parameters</span>: user_1, <span class="hljs-number">123</span>, <span class="hljs-number">18688190001</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">2023</span>-<span class="hljs-number">07</span>-<span class="hljs-number">01</span>, <span class="hljs-number">2023</span>-<span class="hljs-number">07</span>-<span class="hljs-number">01</span><span class="hljs-attribute">Parameters</span>: user_2, <span class="hljs-number">123</span>, <span class="hljs-number">18688190002</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">2023</span>-<span class="hljs-number">07</span>-<span class="hljs-number">01</span>, <span class="hljs-number">2023</span>-<span class="hljs-number">07</span>-<span class="hljs-number">01</span><span class="hljs-attribute">Parameters</span>: user_3, <span class="hljs-number">123</span>, <span class="hljs-number">18688190003</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">2023</span>-<span class="hljs-number">07</span>-<span class="hljs-number">01</span>, <span class="hljs-number">2023</span>-<span class="hljs-number">07</span>-<span class="hljs-number">01</span></code></pre></div><p>而如果想要得到最佳性能，最好是将多条SQL合并为一条，像这样：</p><div class="code-wrapper"><pre><code class="hljs subunit">INSERT INTO user ( username, password, phone, info, balance, create_time, update_time )VALUES (user_1, 123, 18688190001, &quot;&quot;, 2000, 2023<span class="hljs-string">-07</span><span class="hljs-string">-01</span>, 2023<span class="hljs-string">-07</span><span class="hljs-string">-01</span>),(user_2, 123, 18688190002, &quot;&quot;, 2000, 2023<span class="hljs-string">-07</span><span class="hljs-string">-01</span>, 2023<span class="hljs-string">-07</span><span class="hljs-string">-01</span>),(user_3, 123, 18688190003, &quot;&quot;, 2000, 2023<span class="hljs-string">-07</span><span class="hljs-string">-01</span>, 2023<span class="hljs-string">-07</span><span class="hljs-string">-01</span>),(user_4, 123, 18688190004, &quot;&quot;, 2000, 2023<span class="hljs-string">-07</span><span class="hljs-string">-01</span>, 2023<span class="hljs-string">-07</span><span class="hljs-string">-01</span>);</code></pre></div><p>该怎么做呢？<br>MySQL的客户端连接参数中有这样的一个参数：rewriteBatchedStatements。顾名思义，就是重写批处理的statement语句。参考文档：<br><a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-performance-extensions.html#cj-conn-prop_rewriteBatchedStatements">https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-performance-extensions.html#cj-conn-prop_rewriteBatchedStatements</a><br> 这个参数的默认值是false，我们需要修改连接参数，将其配置为true<br>修改项目中的application.yml文件，在jdbc的url后面添加参数&amp;rewriteBatchedStatements&#x3D;true:</p><div class="code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span><span class="hljs-symbol">  datasource:</span><span class="hljs-symbol">    url:</span> jdbc:mysql:<span class="hljs-comment">//127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span>    driver-class-name: com.mysql.cj.jdbc.Driver<span class="hljs-symbol">    username:</span> root<span class="hljs-symbol">    password:</span> MySQL123</code></pre></div><p>再次测试插入10万条数据，可以发现速度有非常明显的提升：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705918577520-0196506b-bff1-45dc-8c7a-fac4dc56a512.png#averageHue=%23f6f9f4&clientId=uc58b97f9-a395-4&from=paste&id=u8a36e49b&originHeight=338&originWidth=1450&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ua6f0112b-2d06-4e96-bc5e-c12e199f055&title="><br>在ClientPreparedStatement的executeBatchInternal中，有判断rewriteBatchedStatements值是否为true并重写SQL的功能：<br> 最终，SQL被重写了：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705918589951-a039f0bf-7969-47b9-bae6-54aba517d7d1.png#averageHue=%23f4f4f3&clientId=uc58b97f9-a395-4&from=paste&id=ud31f44f4&originHeight=820&originWidth=1438&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uebc23129-0353-41c2-a242-d2d48624d16&title="></p><h2 id="3-扩展功能："><a href="#3-扩展功能：" class="headerlink" title="3.扩展功能："></a>3.扩展功能：</h2><p>在使用MybatisPlus以后，基础的Mapper、Service、PO代码相对固定，重复编写也比较麻烦。因此MybatisPlus官方提供了代码生成器根据数据库表结构生成PO、Mapper、Service等相关代码。只不过代码生成器同样要编码使用，也很麻烦。<br>这里推荐大家使用一款MybatisPlus的插件，它可以基于图形化界面完成MybatisPlus的代码生成，非常简单。</p><h2 id="3-1-代码生成"><a href="#3-1-代码生成" class="headerlink" title="3.1.代码生成"></a><strong>3.1.代码生成</strong></h2><p>在使用MybatisPlus以后，基础的Mapper、Service、PO代码相对固定，重复编写也比较麻烦。因此MybatisPlus官方提供了代码生成器根据数据库表结构生成PO、Mapper、Service等相关代码。只不过代码生成器同样要编码使用，也很麻烦。<br>这里推荐大家使用一款MybatisPlus的插件，它可以基于图形化界面完成MybatisPlus的代码生成，非常简单。</p><h3 id="3-1-1-安装插件"><a href="#3-1-1-安装插件" class="headerlink" title="3.1.1.安装插件"></a><strong>3.1.1.安装插件</strong></h3><p>在Idea的plugins市场中搜索并安装MyBatisPlus插件：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705925803243-c463bddd-90b6-4f00-82f9-07248f3be296.png#averageHue=%23f6f5f5&clientId=uc58b97f9-a395-4&from=paste&id=u10f22e01&originHeight=766&originWidth=1507&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u774fac4c-a63b-4b5d-b790-d376bfa45ec&title="><br> 然后重启你的Idea即可使用。</p><h3 id="3-1-2-使用"><a href="#3-1-2-使用" class="headerlink" title="3.1.2.使用"></a><strong>3.1.2.使用</strong></h3><p>刚好数据库中还有一张address表尚未生成对应的实体和mapper等基础代码。我们利用插件生成一下。 首先需要配置数据库地址，在Idea顶部菜单中，找到other，选择Config Database：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705925803207-e850f164-0ed0-424c-900f-3fedb6538a55.png#averageHue=%23d9ceb7&clientId=uc58b97f9-a395-4&from=paste&id=u1a5ced54&originHeight=236&originWidth=1221&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ue1f50f4e-facf-40db-a0b7-ba521b9bba9&title="><br> 在弹出的窗口中填写数据库连接的基本信息：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705925803342-1dfc56be-849e-4f50-bca8-ab9a57c51b8d.png#averageHue=%23f4f4f4&clientId=uc58b97f9-a395-4&from=paste&id=u901ce6ea&originHeight=393&originWidth=629&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u3bc246b2-fd70-4532-bbfc-a70f583f4fd&title="><br> 点击OK保存。<br>然后再次点击Idea顶部菜单中的other，然后选择Code Generator:<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705925803246-a0166ea0-af7e-4fcb-a752-12fe9b94dc51.png#averageHue=%23d7cbb2&clientId=uc58b97f9-a395-4&from=paste&id=u11e4b452&originHeight=190&originWidth=1109&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u82c0dc6d-49f5-4b79-9b08-722b1889191&title="><br> 在弹出的表单中填写信息：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705925803280-c0d3829d-83a0-42ce-a02e-3e145b64069f.png#averageHue=%23f3e9e8&clientId=uc58b97f9-a395-4&from=paste&id=u553b6e7b&originHeight=606&originWidth=1376&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u13c55ac9-9403-4bec-9fb6-9d460c8fffc&title="><br> 最终，代码自动生成到指定的位置了：但是要注意上面的代码生成的mapper文件缺少@Mapper注解的！</p><h2 id="3-2-静态工具"><a href="#3-2-静态工具" class="headerlink" title="3.2.静态工具"></a><strong>3.2.静态工具</strong></h2><p>有的时候Service之间也会相互调用，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：Db，其中的一些静态方法与IService中方法签名基本一致，也可以帮助我们实现CRUD功能：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705925805432-f717e42a-c354-420b-9431-ce96c43cec8f.png#averageHue=%23fbf9f8&clientId=uc58b97f9-a395-4&from=paste&id=ud46ade48&originHeight=899&originWidth=1028&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uf48cddd7-fed5-4b09-8ce7-d6e314ca6ae&title="><br>示例：</p><div class="code-wrapper"><pre><code class="hljs pgsql">@Test<span class="hljs-type">void</span> testDbGet() &#123;    <span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span> = Db.getById(<span class="hljs-number">1</span>L, <span class="hljs-keyword">User</span>.<span class="hljs-keyword">class</span>);    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">user</span>);&#125;@Test<span class="hljs-type">void</span> testDbList() &#123;    // 利用Db实现复杂条件查询    List&lt;<span class="hljs-keyword">User</span>&gt; list = Db.lambdaQuery(<span class="hljs-keyword">User</span>.<span class="hljs-keyword">class</span>)            .<span class="hljs-keyword">like</span>(<span class="hljs-keyword">User</span>::getUsername, &quot;o&quot;)            .ge(<span class="hljs-keyword">User</span>::getBalance, <span class="hljs-number">1000</span>)            .list();    list.<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>::println);&#125;@Test<span class="hljs-type">void</span> testDbUpdate() &#123;    Db.lambdaUpdate(<span class="hljs-keyword">User</span>.<span class="hljs-keyword">class</span>)            .<span class="hljs-keyword">set</span>(<span class="hljs-keyword">User</span>::getBalance, <span class="hljs-number">2000</span>)            .eq(<span class="hljs-keyword">User</span>::getUsername, &quot;Rose&quot;);&#125;</code></pre></div><p>需求：改造根据id用户查询的接口，查询用户的同时返回用户收货地址列表<br>首先，我们要添加一个收货地址的VO对象：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.itheima.mp.domain.vo;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModel;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModelProperty;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-meta">@ApiModel(description = <span class="hljs-string">&quot;收货地址VO&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AddressVO</span>&#123;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;id&quot;</span>)</span>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> id;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;用户ID&quot;</span>)</span>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> userId;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;省&quot;</span>)</span>    <span class="hljs-keyword">private</span> String province;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;市&quot;</span>)</span>    <span class="hljs-keyword">private</span> String city;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;县/区&quot;</span>)</span>    <span class="hljs-keyword">private</span> String town;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;手机&quot;</span>)</span>    <span class="hljs-keyword">private</span> String mobile;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;详细地址&quot;</span>)</span>    <span class="hljs-keyword">private</span> String street;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;联系人&quot;</span>)</span>    <span class="hljs-keyword">private</span> String contact;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;是否是默认 1默认 0否&quot;</span>)</span>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Boolean</span> isDefault;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;备注&quot;</span>)</span>    <span class="hljs-keyword">private</span> String notes;&#125;</code></pre></div><p>然后，改造原来的UserVO，添加一个地址属性：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705925806370-0ff19fa7-2686-4d7f-ba8e-449c203787f9.png#averageHue=%23f6f9f3&clientId=uc58b97f9-a395-4&from=paste&id=u9a4dd936&originHeight=804&originWidth=929&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u3f51cddc-ab65-46fc-aa76-8fe5e8c0efc&title="><br>接下来，修改UserController中根据id查询用户的业务接口：</p><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/&#123;id&#125;&quot;</span>)<span class="hljs-variable">@ApiOperation</span>(<span class="hljs-string">&quot;根据id查询用户&quot;</span>)public UserVO <span class="hljs-built_in">queryUserById</span>(<span class="hljs-variable">@PathVariable</span>(<span class="hljs-string">&quot;id&quot;</span>) Long userId)&#123;    <span class="hljs-comment">// 基于自定义service方法查询</span>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">userService</span><span class="hljs-selector-class">.queryUserAndAddressById</span>(userId);&#125;</code></pre></div><p>由于查询业务复杂，所以要在service层来实现。首先在IUserService中定义方法：</p><div class="code-wrapper"><pre><code class="hljs pgsql">package com.itheima.mp.service;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.<span class="hljs-keyword">extension</span>.service.IService;<span class="hljs-keyword">import</span> com.itheima.mp.<span class="hljs-keyword">domain</span>.po.<span class="hljs-keyword">User</span>;<span class="hljs-keyword">import</span> com.itheima.mp.<span class="hljs-keyword">domain</span>.vo.UserVO;<span class="hljs-built_in">public</span> interface IUserService extends IService&lt;<span class="hljs-keyword">User</span>&gt; &#123;    <span class="hljs-type">void</span> deduct(Long id, <span class="hljs-type">Integer</span> <span class="hljs-type">money</span>);    UserVO queryUserAndAddressById(Long userId);&#125;</code></pre></div><p>然后，在UserServiceImpl中实现该方法：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> UserVO queryUserAndAddressById(<span class="hljs-built_in">Long</span> userId) &#123;    <span class="hljs-comment">// 1.查询用户</span>    User user = getById(userId);    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-comment">// 2.查询收货地址</span>    List&lt;Address&gt; addresses = Db.lambdaQuery(Address.<span class="hljs-keyword">class</span>)            .eq(Address::getUserId, userId)            .list();    <span class="hljs-comment">// 3.处理vo</span>    UserVO userVO = BeanUtil.copyProperties(user, UserVO.<span class="hljs-keyword">class</span>);    userVO.setAddresses(BeanUtil.copyToList(addresses, AddressVO.<span class="hljs-keyword">class</span>));    <span class="hljs-keyword">return</span> userVO;&#125;</code></pre></div><p>在查询地址时，我们采用了Db的静态方法，因此避免了注入AddressService，减少了循环依赖的风险。<br>（如果AdressService需要查询User的时候，如果采用注入各自的Service就会产生循环依赖的问题了）<br>再来实现一个功能：</p><ul><li>根据id批量查询用户，并查询出用户对应的所有地址</li></ul><h2 id="3-3-逻辑删除"><a href="#3-3-逻辑删除" class="headerlink" title="3.3.逻辑删除"></a><strong>3.3.逻辑删除</strong></h2><p>对于一些比较重要的数据，我们往往会采用逻辑删除的方案，即：</p><ul><li>在表中添加一个字段标记数据是否被删除</li><li>当删除数据时把标记置为true</li><li>查询时过滤掉标记为true的数据</li></ul><p>一旦采用了逻辑删除，所有的查询和删除逻辑都要跟着变化，非常麻烦。<br>为了解决这个问题，MybatisPlus就添加了对逻辑删除的支持。<br><strong>注意</strong>，只有MybatisPlus生成的SQL语句才支持自动的逻辑删除，自定义SQL需要自己手动处理逻辑删除。<br>例如，我们给address表添加一个逻辑删除字段：</p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> address <span class="hljs-keyword">add</span> deleted <span class="hljs-type">bit</span> <span class="hljs-keyword">default</span> b<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">comment</span> <span class="hljs-string">&#x27;逻辑删除&#x27;</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">ADD</span> deleted <span class="hljs-type">bit</span>: 在表&quot;address&quot;中添加一个名为&quot;deleted&quot;的列，数据类型为<span class="hljs-type">bit</span>。<span class="hljs-type">Bit</span>数据类型用于存储<span class="hljs-number">0</span>或<span class="hljs-number">1</span>的布尔值。<span class="hljs-keyword">DEFAULT</span> b<span class="hljs-string">&#x27;0&#x27;</span>: 设置&quot;deleted&quot;列的默认值为二进制表示的<span class="hljs-number">0</span>，即<span class="hljs-keyword">false</span>。当插入新记录时，如果未提供&quot;deleted&quot;列的值，将自动使用默认值<span class="hljs-number">0</span>。<span class="hljs-keyword">NULL</span>: 指定&quot;deleted&quot;列允许为空值。这表示在插入新记录时，可以将&quot;deleted&quot;列设置为<span class="hljs-keyword">NULL</span>，表示未知或未设置。</code></pre></div><p>然后给Address实体添加deleted字段：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705929828756-e0994712-53c6-4b5a-bee4-9b834c96b6cc.png#averageHue=%23f6f8f3&clientId=uc58b97f9-a395-4&from=paste&id=u60328773&originHeight=482&originWidth=856&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u2cad5426-4646-46fd-bd0e-0af0591c6f8&title="><br>接下来，我们要在application.yml中配置逻辑删除字段：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span>  <span class="hljs-attr">global-config:</span>    <span class="hljs-attr">db-config:</span>      <span class="hljs-attr">logic-delete-field:</span> <span class="hljs-string">deleted</span> <span class="hljs-comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span>      <span class="hljs-attr">logic-delete-value:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 逻辑已删除值(默认为 1)</span>      <span class="hljs-attr">logic-not-delete-value:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 逻辑未删除值(默认为 0)</span></code></pre></div><p>测试： 首先，我们执行一个删除操作：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-meta">@Test</span><span class="hljs-built_in">void</span> <span class="hljs-title function_">testDeleteByLogic</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 删除方法与以前没有区别</span>    addressService.<span class="hljs-title function_">removeById</span>(59L);&#125;</code></pre></div><p>方法与普通删除一模一样，但是底层的SQL逻辑变了：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705929828740-fd1337a1-66af-4424-9b11-e048d081e91b.png#averageHue=%23f9fcf7&clientId=uc58b97f9-a395-4&from=paste&id=uc0061475&originHeight=387&originWidth=1347&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uc5e559a3-b475-4939-8e40-34d7b5e5a77&title="><br>查询一下试试：</p><div class="code-wrapper"><pre><code class="hljs pgsql">@Test<span class="hljs-type">void</span> testQuery() &#123;    List&lt;Address&gt; list = addressService.list();    list.<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>::println);&#125;</code></pre></div><p>会发现id为59的确实没有查询出来，而且SQL中也对逻辑删除字段做了判断：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705929828967-15c00aed-218b-4c65-87c3-00e4accf5dc6.png#averageHue=%23f9fcf7&clientId=uc58b97f9-a395-4&from=paste&id=u337c364c&originHeight=560&originWidth=1328&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u7b0c1730-31af-4f6a-9ee3-8419cf75303&title="><br>综上， 开启了逻辑删除功能以后，我们就可以像普通删除一样做CRUD，基本不用考虑代码逻辑问题。还是非常方便的。<br><strong>注意</strong>： 逻辑删除本身也有自己的问题，比如：</p><ul><li>会导致数据库表垃圾数据越来越多，从而影响查询效率</li><li>SQL中全都需要对逻辑删除字段做判断，影响查询效率</li></ul><p>因此，我不太推荐采用逻辑删除功能，如果数据不能删除，可以采用把数据迁移到其它表的办法。</p><h2 id="3-3-通用枚举"><a href="#3-3-通用枚举" class="headerlink" title="3.3.通用枚举"></a><strong>3.3.通用枚举</strong></h2><p>User类中有一个用户状态字段：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978249509-aa2d04fe-4b98-4ac9-980f-5fa85c7d6b50.png#averageHue=%23f5f7f4&clientId=uc58b97f9-a395-4&from=paste&id=ub07561b7&originHeight=432&originWidth=688&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u8666f78e-7686-4c6e-81c7-da8a49a01fc&title="><br> 像这种字段我们一般会定义一个枚举，做业务判断的时候就可以直接基于枚举做比较。但是我们数据库采用的是int类型，对应的PO也是Integer。因此业务操作时必须手动把枚举与Integer转换，非常麻烦。<br>因此，MybatisPlus提供了一个处理枚举的类型转换器，可以帮我们<strong>把枚举类型与数据库类型自动转换</strong>。</p><h3 id="3-3-1-定义枚举"><a href="#3-3-1-定义枚举" class="headerlink" title="3.3.1.定义枚举"></a><strong>3.3.1.定义枚举</strong></h3><p>我们定义一个用户状态的枚举：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978249556-e6a77e68-d8e7-4491-893d-62acee59bfe6.png#averageHue=%23f9fbf8&clientId=uc58b97f9-a395-4&from=paste&id=ufe2f95ae&originHeight=499&originWidth=915&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ub92043d0-5495-4ccf-be03-817c41feb25&title="><br> 代码如下：</p><div class="code-wrapper"><pre><code class="hljs pgsql">package com.itheima.mp.enums;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.annotation.EnumValue;<span class="hljs-keyword">import</span> lombok.Getter;@Getter<span class="hljs-built_in">public</span> enum UserStatus &#123;    NORMAL(<span class="hljs-number">1</span>, &quot;正常&quot;),    <span class="hljs-keyword">FREEZE</span>(<span class="hljs-number">2</span>, &quot;冻结&quot;)    ;    private final <span class="hljs-type">int</span> <span class="hljs-keyword">value</span>;    private final String <span class="hljs-keyword">desc</span>;    UserStatus(<span class="hljs-type">int</span> <span class="hljs-keyword">value</span>, String <span class="hljs-keyword">desc</span>) &#123;        this.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>;        this.<span class="hljs-keyword">desc</span> = <span class="hljs-keyword">desc</span>;    &#125;&#125;</code></pre></div><p>然后把User类中的status字段改为UserStatus 类型：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978249521-ed97e27c-6924-4aa2-8be3-86de331de227.png#averageHue=%23f6f7f2&clientId=uc58b97f9-a395-4&from=paste&id=u61339fb0&originHeight=422&originWidth=714&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u1c8fd25d-379b-450f-9b37-a94dd7f887e&title="><br>要让MybatisPlus处理枚举与数据库类型自动转换，我们必须告诉MybatisPlus，枚举中的哪个字段的值作为数据库值。 MybatisPlus提供了@EnumValue注解来标记枚举属性：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978322926-f9cac0e4-9432-423d-9c15-bc8e780b2ad8.png#averageHue=%23f8fbf6&clientId=uc58b97f9-a395-4&from=paste&id=u998367e5&originHeight=518&originWidth=635&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ub0d8a87b-4703-4ada-a444-3a91345589e&title="><br>上面的@Enumvalue修饰的属性，表示该属性对应的是数据库中的字段！然后数据库查询出来的值会自动转换为对应的枚举类型！<br>枚举类也是一种类，只是它是一种比较特殊的类，因此它一样可以使用属性和方法。<br>枚举类通常应该设计成不可变类，也就说它的属性值不应该允许改变，这样会更安全，而且代码更加简洁。为此，我们应该将枚举类的属性都使用private final修饰。<br>一旦为枚举类显式定义了带参数的构造器，则列出枚举值时也必须对应地传入参数。<br>上面的枚举属性是一种类似方法的值,必须含有构造方法！</p><h3 id="3-3-2-配置枚举处理器"><a href="#3-3-2-配置枚举处理器" class="headerlink" title="3.3.2.配置枚举处理器"></a><strong>3.3.2.配置枚举处理器</strong></h3><p>在application.yaml文件中添加配置：</p><div class="code-wrapper"><pre><code class="hljs stylus">mybatis-plus:  configuration:    default-enum-type-handler: com<span class="hljs-selector-class">.baomidou</span><span class="hljs-selector-class">.mybatisplus</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.handlers</span>.MybatisEnumTypeHandler</code></pre></div><h3 id="3-3-3-测试"><a href="#3-3-3-测试" class="headerlink" title="3.3.3.测试"></a><strong>3.3.3.测试</strong></h3><div class="code-wrapper"><pre><code class="hljs pgsql">@Test<span class="hljs-type">void</span> testService() &#123;    List&lt;<span class="hljs-keyword">User</span>&gt; list = userService.list();    list.<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>::println);&#125;</code></pre></div><p>最终，查询出的User类的status字段会是枚举类型：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978322948-63901170-fb58-44aa-8ead-e3f718a83e42.png#averageHue=%23f7faf3&clientId=uc58b97f9-a395-4&from=paste&id=u5b431e2c&originHeight=337&originWidth=758&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uc2b81bb7-1a6c-4d0f-8f77-81fa6d06e08&title="><br>同时，为了使页面查询结果也是枚举格式，我们需要修改UserVO中的status属性：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978322908-020fb44c-2198-4d67-838c-2dbe552d3e29.png#averageHue=%23f6f8f1&clientId=uc58b97f9-a395-4&from=paste&id=u900af5c6&originHeight=488&originWidth=1256&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u85d7767a-5cdd-43a0-8f9f-81884259c1b&title="><br>并且，在UserStatus枚举中通过@JsonValue注解标记JSON序列化时展示的字段：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978322910-47a9761a-b929-4a31-a381-e5e106aa8c46.png#averageHue=%23f6f9f4&clientId=uc58b97f9-a395-4&from=paste&id=uf8aa82ad&originHeight=491&originWidth=1199&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u254bda76-28e1-4176-9676-49b08313b9a&title="><br>最后，在页面查询，结果如下：<br>如果上面的枚举类没有用@JsonValue  修饰的话，那么前端查询的时候返回的是枚举类型的字符串，也就是返回的是NORMAL或者其他的！如果添加了该注解修饰返回给前端的值就是枚举属性中的desc部分！<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978322928-bfcd70d6-c8cb-4006-83fa-96ec1a7bfe84.png#averageHue=%23b1b0aa&clientId=uc58b97f9-a395-4&from=paste&id=ub21689de&originHeight=764&originWidth=1752&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ud60dc59f-3df9-4430-85a3-cb56404fa2f&title="></p><h2 id="3-4-JSON类型处理器"><a href="#3-4-JSON类型处理器" class="headerlink" title="3.4.JSON类型处理器"></a><strong>3.4.JSON类型处理器</strong></h2><p>数据库的user表中有一个info字段，是JSON类型：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978323486-e2b7191e-8602-4502-abc1-093453bbb30f.png#averageHue=%23f7f6f4&clientId=uc58b97f9-a395-4&from=paste&id=u634e6503&originHeight=304&originWidth=761&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u3f92d5cc-eb85-4d7e-8c03-c0ea7202ed1&title="><br> 格式像这样：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;intro&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;佛系青年&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;gender&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;male&quot;</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>而目前User实体类中却是String类型：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978323508-679d8806-0c1f-458b-b9b8-1738c6d07b55.png#averageHue=%23f5f8f4&clientId=uc58b97f9-a395-4&from=paste&id=uee0b7401&originHeight=384&originWidth=814&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u0ca78c3a-2df7-45c6-8dbc-4c28f87d205&title="><br>这样一来，我们要读取info中的属性时就非常不方便。如果要方便获取，info的类型最好是一个Map或者实体类。<br> 而一旦我们把info改为对象类型，就需要在写入数据库时手动转为String，再读取数据库时，手动转换为对象，这会非常麻烦。<br>因此MybatisPlus提供了很多特殊类型字段的类型处理器，解决特殊字段类型与数据库类型转换的问题。例如处理JSON就可以使用JacksonTypeHandler处理器。<br>接下来，我们就来看看这个处理器该如何使用。</p><h3 id="3-4-1-定义实体"><a href="#3-4-1-定义实体" class="headerlink" title="3.4.1.定义实体"></a><strong>3.4.1.定义实体</strong></h3><p>首先，我们定义一个单独实体类来与info字段的属性匹配：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978323584-9c4d490e-b0af-4e55-a95a-5c471ce3804e.png#averageHue=%23f9fbf8&clientId=uc58b97f9-a395-4&from=paste&id=u98815d56&originHeight=437&originWidth=860&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u7eb18b57-145c-478a-b26c-150b875da44&title="><br> 代码如下：</p><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> com.itheima.mp.domain.po;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> intro;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> gender;&#125;</code></pre></div><h3 id="3-4-2-使用类型处理器"><a href="#3-4-2-使用类型处理器" class="headerlink" title="3.4.2.使用类型处理器"></a><strong>3.4.2.使用类型处理器</strong></h3><p>接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978323692-de784ab0-b4d2-422d-b25c-ba041423cb52.png#averageHue=%23f6f8f4&clientId=uc58b97f9-a395-4&from=paste&id=uc328c190&originHeight=383&originWidth=978&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u0dbfe6ed-814e-4893-843e-efc5903b0e0&title="><br>测试可以发现，所有数据都正确封装到UserInfo当中了：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978324097-a9bb9dfe-60b6-4a97-92d5-aae0c01e1c9a.png#averageHue=%23f9fbf6&clientId=uc58b97f9-a395-4&from=paste&id=ue9d7303b&originHeight=345&originWidth=1034&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u94a9f33f-ce94-45f6-9d93-58f8cfa15b2&title="><br>同时，为了让页面返回的结果也以对象格式返回，我们要修改UserVO中的info字段：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978324170-549eb331-de5d-4f45-bb15-cef0f3591856.png#averageHue=%23f5f7f0&clientId=uc58b97f9-a395-4&from=paste&id=uc69a9dc2&originHeight=383&originWidth=945&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uf5214c5c-5d51-4903-b322-46aa93c75d4&title="><br>此时，在页面查询结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978324181-87b36754-e3eb-41a0-a756-52a23712e354.png#averageHue=%23b9b9b1&clientId=uc58b97f9-a395-4&from=paste&id=uccac1623&originHeight=755&originWidth=1722&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u19c62568-d3b6-4f9d-a17d-d3ce4f6642b&title="></p><h2 id="3-5-配置加密（选学）"><a href="#3-5-配置加密（选学）" class="headerlink" title="3.5.配置加密（选学）"></a><del><strong>3.5.配置加密（选学）</strong></del></h2><p>目前我们配置文件中的很多参数都是明文，如果开发人员发生流动，很容易导致敏感信息的泄露。所以MybatisPlus支持配置文件的加密和解密功能。<br>我们以数据库的用户名和密码为例。</p><h3 id="3-5-1-生成秘钥"><a href="#3-5-1-生成秘钥" class="headerlink" title="3.5.1.生成秘钥"></a><strong>3.5.1.生成秘钥</strong></h3><p>首先，我们利用AES工具生成一个随机秘钥，然后对用户名、密码加密：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.mp;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.toolkit.AES;<span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<span class="hljs-keyword">class</span> <span class="hljs-title class_">MpDemoApplicationTests</span> &#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// 生成 16 位随机 AES 密钥</span>        <span class="hljs-type">String</span> <span class="hljs-variable">randomKey</span> <span class="hljs-operator">=</span> AES.generateRandomKey();        System.out.println(<span class="hljs-string">&quot;randomKey = &quot;</span> + randomKey);        <span class="hljs-comment">// 利用密钥对用户名加密</span>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> AES.encrypt(<span class="hljs-string">&quot;root&quot;</span>, randomKey);        System.out.println(<span class="hljs-string">&quot;username = &quot;</span> + username);        <span class="hljs-comment">// 利用密钥对用户名加密</span>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> AES.encrypt(<span class="hljs-string">&quot;MySQL123&quot;</span>, randomKey);        System.out.println(<span class="hljs-string">&quot;password = &quot;</span> + password);    &#125;&#125;</code></pre></div><p>打印结果如下：</p><div class="code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">randomKey</span> <span class="hljs-operator">=</span> <span class="hljs-number">6234633</span>a66fb399f<span class="hljs-attribute">username</span> <span class="hljs-operator">=</span> px2bAbnUfiY8K/IgsKvscg<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-attribute">password</span> <span class="hljs-operator">=</span> FGvCSEaOuga3ulDAsxw68Q<span class="hljs-operator">=</span><span class="hljs-operator">=</span></code></pre></div><h3 id="3-5-2-修改配置"><a href="#3-5-2-修改配置" class="headerlink" title="3.5.2.修改配置"></a><strong>3.5.2.修改配置</strong></h3><p>修改application.yaml文件，把jdbc的用户名、密码修改为刚刚加密生成的密文：</p><div class="code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span><span class="hljs-symbol">  datasource:</span><span class="hljs-symbol">    url:</span> jdbc:mysql:<span class="hljs-comment">//127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span>    driver-class-name: com.mysql.cj.jdbc.Driver<span class="hljs-symbol">    username:</span> mpw:QWWVnk1Oal3258x5rVhaeQ== <span class="hljs-meta"># 密文要以 mpw:开头</span><span class="hljs-symbol">    password:</span> mpw:EUFmeH3cNAzdRGdOQcabWg== <span class="hljs-meta"># 密文要以 mpw:开头</span></code></pre></div><h3 id="3-5-3-测试"><a href="#3-5-3-测试" class="headerlink" title="3.5.3.测试"></a><strong>3.5.3.测试</strong></h3><p>在启动项目的时候，需要把刚才生成的秘钥添加到启动参数中，像这样：<br>–mpw.key&#x3D;6234633a66fb399f<br>单元测试的时候不能添加启动参数，所以要在测试类的注解上配置：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705978324367-3cf813ab-499d-4dd1-9c88-bcd8cfbff7d7.png#averageHue=%23f5f7f3&clientId=uc58b97f9-a395-4&from=paste&id=u801e8006&originHeight=486&originWidth=1089&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ub52ae623-c40f-4e91-a659-422267810fb&title="><br>然后随意运行一个单元测试，可以发现数据库查询正常。<br>注意：如果是springboot项目启动的时候，我们需要在程序启动的时候添加程序实参：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705980172566-7324763d-c5bc-4a83-a25d-d01a67bc22f9.png#averageHue=%232f3136&clientId=uc58b97f9-a395-4&from=paste&height=486&id=uc3036a07&originHeight=608&originWidth=940&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=47414&status=done&style=none&taskId=u76007036-4392-4644-b0cc-ec8d7d6b2c7&title=&width=752" alt="image.png"></p><h1 id="4-插件功能"><a href="#4-插件功能" class="headerlink" title="4.插件功能"></a><strong>4.插件功能</strong></h1><p>MybatisPlus提供了很多的插件功能，进一步拓展其功能。目前已有的插件有：</p><ul><li>PaginationInnerInterceptor：自动分页</li><li>TenantLineInnerInterceptor：多租户</li><li>DynamicTableNameInnerInterceptor：动态表名</li><li>OptimisticLockerInnerInterceptor：乐观锁</li><li>IllegalSQLInnerInterceptor：sql 性能规范</li><li>BlockAttackInnerInterceptor：防止全表更新与删除</li></ul><p><strong>注意：</strong> 使用多个分页插件的时候需要注意插件定义顺序，建议使用顺序如下：</p><ul><li>多租户,动态表名</li><li>分页,乐观锁</li><li>sql 性能规范,防止全表更新与删除</li></ul><p>这里我们以分页插件为里来学习插件的用法。</p><h2 id="4-1-分页插件"><a href="#4-1-分页插件" class="headerlink" title="4.1.分页插件"></a><strong>4.1.分页插件</strong></h2><p>在未引入分页插件的情况下，MybatisPlus是不支持分页功能的，IService和BaseMapper中的分页方法都无法正常起效。 所以，我们必须配置分页插件。</p><h3 id="4-1-1-配置分页插件"><a href="#4-1-1-配置分页插件" class="headerlink" title="4.1.1.配置分页插件"></a><strong>4.1.1.配置分页插件</strong></h3><p>在项目中新建一个配置类：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705980258700-4c8de4e9-4dc7-455b-b608-e924034c14ac.png#averageHue=%23f9fbf8&clientId=uc58b97f9-a395-4&from=paste&id=PaeBj&originHeight=405&originWidth=896&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u367f4c69-5009-432f-9107-ad4c148b8e4&title="><br>其代码如下：<br>注意不要忘记了下面的@Configuration注解：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.itheima.mp.config;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.<span class="hljs-keyword">annotation</span>.DbType;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.<span class="hljs-keyword">inner</span>.PaginationInnerInterceptor;<span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Bean;<span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Configuration;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisConfig</span> &#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor mybatisPlusInterceptor() &#123;        <span class="hljs-comment">// 初始化核心插件</span>        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();        <span class="hljs-comment">// 添加分页插件</span>        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));        <span class="hljs-keyword">return</span> interceptor;    &#125;&#125;</code></pre></div><h3 id="4-1-2-分页API"><a href="#4-1-2-分页API" class="headerlink" title="4.1.2.分页API"></a><strong>4.1.2.分页API</strong></h3><p>编写一个分页查询的测试：</p><div class="code-wrapper"><pre><code class="hljs pgsql">@Test<span class="hljs-type">void</span> testPageQuery() &#123;    // <span class="hljs-number">1.</span>分页查询，<span class="hljs-built_in">new</span> Page()的两个参数分别是：页码、每页大小    Page&lt;<span class="hljs-keyword">User</span>&gt; p = userService.page(<span class="hljs-built_in">new</span> Page&lt;&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>));    // <span class="hljs-number">2.</span>总条数    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;total = &quot; + p.getTotal());    // <span class="hljs-number">3.</span>总页数    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;pages = &quot; + p.getPages());    // <span class="hljs-number">4.</span>数据    List&lt;<span class="hljs-keyword">User</span>&gt; records = p.getRecords();    records.<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>::println);&#125;</code></pre></div><p>运行的SQL如下：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705982335825-7802f5fa-5a4e-4d72-88d1-5e1e6dea399f.png#averageHue=%2326282c&clientId=uc58b97f9-a395-4&from=paste&height=478&id=uc760cf8c&originHeight=598&originWidth=1338&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=425307&status=done&style=none&taskId=u506701e7-7820-4a5e-bc4a-0c08fa0289f&title=&width=1070.4" alt="image.png"><br>这里用到了分页参数，Page，即可以支持分页参数，也可以支持排序参数。常见的API如下：</p><div class="code-wrapper"><pre><code class="hljs nsis">@Test    void testPageQueryOrder() &#123;        int pageNo = <span class="hljs-number">3</span>, pageSize = <span class="hljs-number">2</span><span class="hljs-comment">;</span>// 分页参数        <span class="hljs-keyword">Page</span>&lt;<span class="hljs-literal">User</span>&gt; <span class="hljs-keyword">page</span> = <span class="hljs-keyword">Page</span>.of(pageNo, pageSize)<span class="hljs-comment">;</span>// 排序参数, 通过OrderItem来指定        <span class="hljs-keyword">page</span>.addOrder(OrderItem.asc(<span class="hljs-string">&quot;balance&quot;</span>))<span class="hljs-comment">;</span>        <span class="hljs-keyword">Page</span>&lt;<span class="hljs-literal">User</span>&gt; p=userService.<span class="hljs-keyword">page</span>(<span class="hljs-keyword">page</span>)<span class="hljs-comment">;</span>        List&lt;<span class="hljs-literal">User</span>&gt; records = p.getRecords()<span class="hljs-comment">;</span>        records.forEach(<span class="hljs-params">System</span>.<span class="hljs-title function_">out::println</span>)<span class="hljs-comment">;</span>    &#125;&#125;</code></pre></div><h2 id="4-2-通用分页实体"><a href="#4-2-通用分页实体" class="headerlink" title="4.2.通用分页实体"></a><strong>4.2.通用分页实体</strong></h2><p>现在要实现一个用户分页查询的接口，接口规范如下：</p><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>请求方式</td><td>GET</td></tr><tr><td>请求路径</td><td>&#x2F;users&#x2F;page</td></tr><tr><td>请求参数</td><td>&#96;&#96;&#96;</td></tr><tr><td>{</td><td></td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs">&quot;pageNo&quot;: 1,&quot;pageSize&quot;: 5,&quot;sortBy&quot;: &quot;balance&quot;,&quot;isAsc&quot;: false,&quot;name&quot;: &quot;o&quot;,&quot;status&quot;: 1</code></pre></div><p>}</p><div class="code-wrapper"><pre><code class="hljs 1c"> <span class="hljs-string">|</span><span class="hljs-string">| 返回值 | ```</span>&#123;    <span class="hljs-string">&quot;total&quot;</span>: <span class="hljs-number">100006</span>,    <span class="hljs-string">&quot;pages&quot;</span>: <span class="hljs-number">50003</span>,    <span class="hljs-string">&quot;list&quot;</span>: [        &#123;            <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">1685100878975279298</span>,            <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;user_9****&quot;</span>,            <span class="hljs-string">&quot;info&quot;</span>: &#123;                <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">24</span>,                <span class="hljs-string">&quot;intro&quot;</span>: <span class="hljs-string">&quot;英文老师&quot;</span>,                <span class="hljs-string">&quot;gender&quot;</span>: <span class="hljs-string">&quot;female&quot;</span>            &#125;,            <span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;正常&quot;</span>,            <span class="hljs-string">&quot;balance&quot;</span>: <span class="hljs-number">2000</span>        &#125;    ]&#125;</code></pre></div><p> |<br>| 特殊说明 | </p><ul><li>如果排序字段为空，默认按照更新时间排序</li><li>排序字段不为空，则按照排序字段排序<br> |</li></ul><p>这里需要定义3个实体：</p><ul><li>UserQuery：分页查询条件的实体，包含分页、排序参数、过滤条件</li><li>PageDTO：分页结果实体，包含总条数、总页数、当前页数据</li><li>UserVO：用户页面视图实体</li></ul><h3 id="4-2-1-实体"><a href="#4-2-1-实体" class="headerlink" title="4.2.1.实体"></a><strong>4.2.1.实体</strong></h3><p>由于UserQuery之前已经定义过了，并且其中已经包含了过滤条件，具体代码如下：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.itheima.mp.domain.query;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModel;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModelProperty;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-meta">@ApiModel(description = <span class="hljs-string">&quot;用户查询条件实体&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserQuery</span> &#123;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;用户名关键字&quot;</span>)</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;用户状态：1-正常，2-冻结&quot;</span>)</span>    <span class="hljs-keyword">private</span> Integer status;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;余额最小值&quot;</span>)</span>    <span class="hljs-keyword">private</span> Integer minBalance;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;余额最大值&quot;</span>)</span>    <span class="hljs-keyword">private</span> Integer maxBalance;&#125;</code></pre></div><p>其中缺少的仅仅是分页条件，而分页条件不仅仅用户分页查询需要，以后其它业务也都有分页查询的需求。因此建议将分页查询条件单独定义为一个PageQuery实体：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705982946365-213d9c2d-1007-4676-a0f3-006903863076.png#averageHue=%23f9fbf8&clientId=uc58b97f9-a395-4&from=paste&id=ubdfd514f&originHeight=530&originWidth=842&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u97557790-4a94-4a71-80e3-e0413c41d19&title="><br>PageQuery是前端提交的查询参数，一般包含四个属性：</p><ul><li>pageNo：页码</li><li>pageSize：每页数据条数</li><li>sortBy：排序字段</li><li>isAsc：是否升序<div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ApiModel(description = <span class="hljs-string">&quot;分页查询实体&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageQuery</span> &#123;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;页码&quot;</span>)</span>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> pageNo;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;页码&quot;</span>)</span>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> pageSize;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;排序字段&quot;</span>)</span>    <span class="hljs-keyword">private</span> String sortBy;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;是否升序&quot;</span>)</span>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Boolean</span> isAsc;&#125;</code></pre></div>然后，让我们的UserQuery继承这个实体：<div class="code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.itheima.mp.domain.query;<span class="hljs-keyword">import</span> io.swagger.annotations.<span class="hljs-type">ApiModel</span>;<span class="hljs-keyword">import</span> io.swagger.annotations.<span class="hljs-type">ApiModelProperty</span>;<span class="hljs-keyword">import</span> lombok.<span class="hljs-type">Data</span>;<span class="hljs-keyword">import</span> lombok.<span class="hljs-type">EqualsAndHashCode</span>;<span class="hljs-meta">@EqualsAndHashCode</span>(callSuper = <span class="hljs-literal">true</span>)<span class="hljs-meta">@Data</span><span class="hljs-meta">@ApiModel</span>(description = <span class="hljs-string">&quot;用户查询条件实体&quot;</span>)public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserQuery</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PageQuery</span> </span>&#123;    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">&quot;用户名关键字&quot;</span>)    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> name;    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">&quot;用户状态：1-正常，2-冻结&quot;</span>)    <span class="hljs-keyword">private</span> <span class="hljs-type">Integer</span> status;    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">&quot;余额最小值&quot;</span>)    <span class="hljs-keyword">private</span> <span class="hljs-type">Integer</span> minBalance;    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">&quot;余额最大值&quot;</span>)    <span class="hljs-keyword">private</span> <span class="hljs-type">Integer</span> maxBalance;&#125;</code></pre></div>返回值的用户实体沿用之前定一个UserVO实体：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705982946305-c7813c4d-6144-4982-8eb9-7807479b450a.png#averageHue=%23f9fbf8&clientId=uc58b97f9-a395-4&from=paste&id=ubef00504&originHeight=440&originWidth=834&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ud2c5b538-2586-42eb-84af-ab2a2ddfbc8&title="><br>最后，则是分页实体PageDTO:<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705982946275-20df474d-bf03-421c-b42e-bfff8fa44fe3.png#averageHue=%23f9fbf8&clientId=uc58b97f9-a395-4&from=paste&id=u4bb1d438&originHeight=499&originWidth=900&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ub99d7679-e884-4ccd-a3f2-a09fc3b6ae7&title="><br>代码如下：<div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.itheima.mp.domain.dto;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModel;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModelProperty;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-meta">@Data</span><span class="hljs-meta">@ApiModel(description = <span class="hljs-string">&quot;分页结果&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageDTO</span>&lt;<span class="hljs-type">T</span>&gt; &#123;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;总条数&quot;</span>)</span>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> total;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;总页数&quot;</span>)</span>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> pages;    <span class="hljs-meta">@ApiModelProperty(<span class="hljs-string">&quot;集合&quot;</span>)</span>    <span class="hljs-keyword">private</span> List&lt;T&gt; list;&#125;</code></pre></div></li></ul><h3 id="4-2-2-开发接口"><a href="#4-2-2-开发接口" class="headerlink" title="4.2.2.开发接口"></a><strong>4.2.2.开发接口</strong></h3><p>我们在UserController中定义分页查询用户的接口：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.itheima.mp.controller;<span class="hljs-keyword">import</span> com.itheima.mp.domain.dto.PageDTO;<span class="hljs-keyword">import</span> com.itheima.mp.domain.query.PageQuery;<span class="hljs-keyword">import</span> com.itheima.mp.domain.vo.UserVO;<span class="hljs-keyword">import</span> com.itheima.mp.service.UserService;<span class="hljs-keyword">import</span> lombok.RequiredArgsConstructor;<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.GetMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestController;<span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping(<span class="hljs-string">&quot;users&quot;</span>)</span><span class="hljs-meta">@RequiredArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserService userService;    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/page&quot;</span>)</span>    <span class="hljs-keyword">public</span> PageDTO&lt;UserVO&gt; queryUsersPage(UserQuery query)&#123;        <span class="hljs-keyword">return</span> userService.queryUsersPage(query);    &#125;    <span class="hljs-comment">// 。。。 略</span>&#125;</code></pre></div><p>然后在IUserService中创建queryUsersPage方法：</p><div class="code-wrapper"><pre><code class="hljs erlang">PageDTO&lt;UserVO&gt; <span class="hljs-keyword">query</span>UsersPage(PageQuery <span class="hljs-keyword">query</span>);</code></pre></div><p>接下来，在UserServiceImpl中实现该方法：</p><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> PageDTO&lt;UserVO&gt; queryUsersPage(PageQuery query) &#123;    <span class="hljs-comment">// 1.构建条件</span>    <span class="hljs-comment">// 1.1.分页条件</span>    Page&lt;User&gt; page = Page.of(query.getPageNo(), query.getPageSize());    <span class="hljs-comment">// 1.2.排序条件</span>    <span class="hljs-keyword">if</span> (query.getSortBy() != <span class="hljs-literal">null</span>) &#123;        page.addOrder(<span class="hljs-keyword">new</span> <span class="hljs-type">OrderItem</span>(query.getSortBy(), query.getIsAsc()));    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-comment">// 默认按照更新时间排序</span>        page.addOrder(<span class="hljs-keyword">new</span> <span class="hljs-type">OrderItem</span>(<span class="hljs-string">&quot;update_time&quot;</span>, <span class="hljs-literal">false</span>));    &#125;    <span class="hljs-comment">// 2.查询</span>    page(page);    <span class="hljs-comment">// 3.数据非空校验</span>    List&lt;User&gt; records = page.getRecords();    <span class="hljs-keyword">if</span> (records == <span class="hljs-literal">null</span> || records.size() &lt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 无数据，返回空结果</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">PageDTO</span>&lt;&gt;(page.getTotal(), page.getPages(), Collections.emptyList());    &#125;    <span class="hljs-comment">// 4.有数据，转换</span>    List&lt;UserVO&gt; list = BeanUtil.copyToList(records, UserVO.class);    <span class="hljs-comment">// 5.封装返回</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">PageDTO</span>&lt;UserVO&gt;(page.getTotal(), page.getPages(), list);&#125;</code></pre></div><p> 启动项目，在页面查看：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705982946491-8d9ec7ae-8722-4dfa-84b5-ec4396913351.png#averageHue=%23f8f8fe&clientId=uc58b97f9-a395-4&from=paste&id=u72a864c9&originHeight=748&originWidth=749&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u955da69a-cdfd-4edd-9af0-c589a53b0d4&title="></p><h3 id="4-2-3-改造PageQuery实体"><a href="#4-2-3-改造PageQuery实体" class="headerlink" title="4.2.3.改造PageQuery实体"></a><strong>4.2.3.改造PageQuery实体</strong></h3><p>在刚才的代码中，从PageQuery到MybatisPlus的Page之间转换的过程还是比较麻烦的。<br> 我们完全可以在PageQuery这个实体中定义一个工具方法，简化开发。 像这样：</p><div class="code-wrapper"><pre><code class="hljs typescript">package com.<span class="hljs-property">itheima</span>.<span class="hljs-property">mp</span>.<span class="hljs-property">domain</span>.<span class="hljs-property">query</span>;<span class="hljs-keyword">import</span> com.<span class="hljs-property">baomidou</span>.<span class="hljs-property">mybatisplus</span>.<span class="hljs-property">core</span>.<span class="hljs-property">metadata</span>.<span class="hljs-property">OrderItem</span>;<span class="hljs-keyword">import</span> com.<span class="hljs-property">baomidou</span>.<span class="hljs-property">mybatisplus</span>.<span class="hljs-property">extension</span>.<span class="hljs-property">plugins</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">Page</span>;<span class="hljs-keyword">import</span> lombok.<span class="hljs-property">Data</span>;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageQuery</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Integer</span> pageNo;    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Integer</span> pageSize;    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> sortBy;    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Boolean</span> isAsc;    <span class="hljs-keyword">public</span> &lt;T&gt;  <span class="hljs-title class_">Page</span>&lt;T&gt; <span class="hljs-title function_">toMpPage</span>(<span class="hljs-params">OrderItem ... orders</span>)&#123;        <span class="hljs-comment">// 1.分页条件</span>        <span class="hljs-title class_">Page</span>&lt;T&gt; p = <span class="hljs-title class_">Page</span>.<span class="hljs-title function_">of</span>(pageNo, pageSize);        <span class="hljs-comment">// 2.排序条件</span>        <span class="hljs-comment">// 2.1.先看前端有没有传排序字段</span>        <span class="hljs-keyword">if</span> (sortBy != <span class="hljs-literal">null</span>) &#123;            p.<span class="hljs-title function_">addOrder</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderItem</span>(sortBy, isAsc));            <span class="hljs-keyword">return</span> p;        &#125;        <span class="hljs-comment">// 2.2.再看有没有手动指定排序字段</span>        <span class="hljs-keyword">if</span>(orders != <span class="hljs-literal">null</span>)&#123;            p.<span class="hljs-title function_">addOrder</span>(orders);        &#125;        <span class="hljs-keyword">return</span> p;    &#125;    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-title class_">Page</span>&lt;T&gt; <span class="hljs-title function_">toMpPage</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> defaultSortBy, <span class="hljs-built_in">boolean</span> isAsc</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toMpPage</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderItem</span>(defaultSortBy, isAsc));    &#125;    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-title class_">Page</span>&lt;T&gt; <span class="hljs-title function_">toMpPageDefaultSortByCreateTimeDesc</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-title function_">toMpPage</span>(<span class="hljs-string">&quot;create_time&quot;</span>, <span class="hljs-literal">false</span>);    &#125;    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-title class_">Page</span>&lt;T&gt; <span class="hljs-title function_">toMpPageDefaultSortByUpdateTimeDesc</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-title function_">toMpPage</span>(<span class="hljs-string">&quot;update_time&quot;</span>, <span class="hljs-literal">false</span>);    &#125;&#125;</code></pre></div><p>这样我们在开发也时就可以省去对从PageQuery到Page的的转换：</p><div class="code-wrapper"><pre><code class="hljs nsis">// <span class="hljs-number">1</span>.构建条件<span class="hljs-keyword">Page</span>&lt;<span class="hljs-literal">User</span>&gt; <span class="hljs-keyword">page</span> = query.toMpPageDefaultSortByCreateTimeDesc()<span class="hljs-comment">;</span></code></pre></div><h3 id="4-2-4-改造PageDTO实体"><a href="#4-2-4-改造PageDTO实体" class="headerlink" title="4.2.4.改造PageDTO实体"></a><strong>4.2.4.改造PageDTO实体</strong></h3><p>在查询出分页结果后，数据的非空校验，数据的vo转换都是模板代码，编写起来很麻烦。<br>我们完全可以将其封装到PageDTO的工具方法中，简化整个过程：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.mp.domain.dto;<span class="hljs-keyword">import</span> cn.hutool.core.bean.BeanUtil;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;<span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<span class="hljs-keyword">import</span> java.util.Collections;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.function.Function;<span class="hljs-keyword">import</span> java.util.stream.Collectors;<span class="hljs-meta">@Data</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageDTO</span>&lt;V&gt; &#123;    <span class="hljs-keyword">private</span> Long total;    <span class="hljs-keyword">private</span> Long pages;    <span class="hljs-keyword">private</span> List&lt;V&gt; list;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 返回空分页结果</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> p MybatisPlus的分页结果</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;V&gt; 目标VO类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;P&gt; 原始PO类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> VO的分页对象</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="hljs-title function_">empty</span><span class="hljs-params">(Page&lt;P&gt; p)</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), Collections.emptyList());    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将MybatisPlus分页结果转为 VO分页结果</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> p MybatisPlus的分页结果</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> voClass 目标VO类型的字节码</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;V&gt; 目标VO类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;P&gt; 原始PO类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> VO的分页对象</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(Page&lt;P&gt; p, Class&lt;V&gt; voClass)</span> &#123;        <span class="hljs-comment">// 1.非空校验</span>        List&lt;P&gt; records = p.getRecords();        <span class="hljs-keyword">if</span> (records == <span class="hljs-literal">null</span> || records.size() &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 无数据，返回空结果</span>            <span class="hljs-keyword">return</span> empty(p);        &#125;        <span class="hljs-comment">// 2.数据转换</span>        List&lt;V&gt; vos = BeanUtil.copyToList(records, voClass);        <span class="hljs-comment">// 3.封装返回</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), vos);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将MybatisPlus分页结果转为 VO分页结果，允许用户自定义PO到VO的转换方式</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> p MybatisPlus的分页结果</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> convertor PO到VO的转换函数</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;V&gt; 目标VO类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;P&gt; 原始PO类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> VO的分页对象</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(Page&lt;P&gt; p, Function&lt;P, V&gt; convertor)</span> &#123;        <span class="hljs-comment">// 1.非空校验</span>        List&lt;P&gt; records = p.getRecords();        <span class="hljs-keyword">if</span> (records == <span class="hljs-literal">null</span> || records.size() &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 无数据，返回空结果</span>            <span class="hljs-keyword">return</span> empty(p);        &#125;        <span class="hljs-comment">// 2.数据转换</span>        List&lt;V&gt; vos = records.stream().map(convertor).collect(Collectors.toList());        <span class="hljs-comment">// 3.封装返回</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), vos);    &#125;&#125;</code></pre></div><p>最终，业务层的代码可以简化为：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> PageDTO&lt;UserVO&gt; queryUserByPage(PageQuery query) &#123;    <span class="hljs-comment">// 1.构建条件</span>    Page&lt;User&gt; page = query.toMpPageDefaultSortByCreateTimeDesc();    <span class="hljs-comment">// 2.查询</span>    page(page);    <span class="hljs-comment">// 3.封装返回</span>    <span class="hljs-keyword">return</span> PageDTO.of(page, UserVO.<span class="hljs-keyword">class</span>);&#125;</code></pre></div><p>如果是希望自定义PO到VO的转换过程，可以这样做：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> PageDTO&lt;UserVO&gt; <span class="hljs-title function_">queryUserByPage</span><span class="hljs-params">(PageQuery query)</span> &#123;    <span class="hljs-comment">// 1.构建条件</span>    Page&lt;User&gt; page = query.toMpPageDefaultSortByCreateTimeDesc();    <span class="hljs-comment">// 2.查询</span>    page(page);    <span class="hljs-comment">// 3.封装返回</span>    <span class="hljs-keyword">return</span> PageDTO.of(page, user -&gt; &#123;        <span class="hljs-comment">// 拷贝属性到VO</span>        <span class="hljs-type">UserVO</span> <span class="hljs-variable">vo</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserVO.class);        <span class="hljs-comment">// 用户名脱敏</span>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> vo.getUsername();        vo.setUsername(username.substring(<span class="hljs-number">0</span>, username.length() - <span class="hljs-number">2</span>) + <span class="hljs-string">&quot;**&quot;</span>);        <span class="hljs-keyword">return</span> vo;    &#125;);&#125;</code></pre></div><p>最终查询的结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705982946301-b3ee830d-8b1f-4789-8e85-be8fef78530b.png#averageHue=%23f8f9fe&clientId=uc58b97f9-a395-4&from=paste&id=u0b1f8043&originHeight=761&originWidth=891&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u3925a6d3-72fc-4a78-a25a-f6ea9571e4a&title="></p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    <categories>
      
      <category>springboot3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>githubPage阿里云绑定域名</title>
    <link href="/2024/01/20/Github%20Pages%20%E7%BB%91%E5%AE%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D/"/>
    <url>/2024/01/20/Github%20Pages%20%E7%BB%91%E5%AE%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<h5 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h5><p><strong>CNAME:</strong></p><p><strong>使用场景</strong>：</p><div class="code-wrapper"><pre><code class="hljs dns">当需要将域名指向另一个域名，再由另一个域名提供 IP 地址，就需要添加 <span class="hljs-keyword">CNAME</span> 记录，最常用到 <span class="hljs-keyword">CNAME</span> 的场景包括做 CDN、企业邮箱、全局流量管理等。</code></pre></div><p><strong>设置方法</strong>:</p><div class="code-wrapper"><pre><code class="hljs dns">记录类型：选择 <span class="hljs-keyword">CNAME</span> 。主机记录：一般是指子域名的前缀（如需创建子域名为www.dns-example.com的解析, 主机记录输入 “ www” ；如需实现dns-example.com的解析，主机记录输入“@”）。解析线路：默认为必填项，否则会导致部分用户无法解析。记录值：记录值为 <span class="hljs-keyword">CNAME</span> 指向的域名，只可以填写域名。TTL：为缓存时间，数值越小，修改记录各地生效时间越快，默认为<span class="hljs-number">10</span>分钟。</code></pre></div><h5 id="Github-Pages-绑定阿里云域名："><a href="#Github-Pages-绑定阿里云域名：" class="headerlink" title="Github Pages 绑定阿里云域名："></a>Github Pages 绑定阿里云域名：</h5><p>1.阿里云购买的域名添加CNAME记录：</p><p><img src="/../images/image-20240120194744304-17058446004831.png" alt="image-20240120194744304"></p><p>2.在github page的页面添加域名：</p><p><img src="/../images/image-20240120194819452.png" alt="image-20240120194819452"></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis总结</title>
    <link href="/2024/01/16/mybits/"/>
    <url>/2024/01/16/mybits/</url>
    
    <content type="html"><![CDATA[<h1 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h1><p>1.mybatis是一款半自动的ORM框架</p><p>2.ORM是对象关系映射</p><h1 id="MyBatis的CRUD操作："><a href="#MyBatis的CRUD操作：" class="headerlink" title="MyBatis的CRUD操作："></a>MyBatis的CRUD操作：</h1><h2 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h2><p>标签：&lt; select id&#x3D;”” resultType&#x3D;”” &gt;</p><p>id与接口中的相关方法是同名的，表示该方法对应的mapper中的sql语句为上面的！</p><p>resultType是查询返回结果的类型！</p><h3 id="序号参数绑定："><a href="#序号参数绑定：" class="headerlink" title="序号参数绑定："></a>序号参数绑定：</h3><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;<span class="hljs-comment">//使用原生参数绑定</span>    <span class="hljs-keyword">public</span> User selectUserByIdAndPwd(Integer id , <span class="hljs-keyword">String</span> pwd);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserByIdAndPwd&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span></span><span class="language-xml">    SELECT * FROM t_users</span><span class="language-xml">    WHERE id = #</span><span class="hljs-template-variable">&#123;arg0&#125;</span><span class="language-xml"> AND password = #</span><span class="hljs-template-variable">&#123;arg1&#125;</span><span class="language-xml"> <span class="hljs-comment">&lt;!--arg0 arg1 arg2 ...--&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserByIdAndPwd&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span></span><span class="language-xml">SELECT * FROM t_users</span><span class="language-xml">    WHERE id = #</span><span class="hljs-template-variable">&#123;param1&#125;</span><span class="language-xml"> AND password = #</span><span class="hljs-template-variable">&#123;param2&#125;</span><span class="language-xml"> <span class="hljs-comment">&lt;!--param1 param2 param3 ...--&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span></code></pre></div><h3 id="注解参数绑定"><a href="#注解参数绑定" class="headerlink" title="注解参数绑定:"></a>注解参数绑定:</h3><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.ibatis</span><span class="hljs-selector-class">.annotations</span><span class="hljs-selector-class">.Param</span>; <span class="hljs-comment">//引入注解</span><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">interface</span> <span class="hljs-selector-tag">UserDao</span> &#123;    <span class="hljs-comment">//使用MyBatis提供的@Param进行参数绑定</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">User</span> <span class="hljs-selector-tag">selectUserByIdAndPwd</span>(<span class="hljs-variable">@Param</span>(<span class="hljs-string">&quot;id&quot;</span>) Integer id , <span class="hljs-variable">@Param</span>(<span class="hljs-string">&quot;pwd&quot;</span>) String pwd);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserByIdAndPwd&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span></span><span class="language-xml">    SELECT * FROM t_users</span><span class="language-xml">    WHERE id = #</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml"> AND password = #</span><span class="hljs-template-variable">&#123;pwd&#125;</span><span class="language-xml"> <span class="hljs-comment">&lt;!-- 使用注解值 @Param(&quot;pwd&quot;) --&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span></code></pre></div><h3 id="Map参数绑定"><a href="#Map参数绑定" class="headerlink" title="Map参数绑定:"></a>Map参数绑定:</h3><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">UserDao</span> &#123;    <span class="hljs-comment">//添加Map进行参数绑定</span><span class="hljs-keyword">public</span> User selectUserByIdAndPwd_map(Map values);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs maxima">Map <span class="hljs-built_in">values</span> = <span class="hljs-built_in">new</span> HashMap(); //测试类创建Map<span class="hljs-built_in">values</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;myId&quot;</span>,<span class="hljs-number">1</span>); //自定义<span class="hljs-built_in">key</span>，绑定参数<span class="hljs-built_in">values</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;myPwd&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);User user = userDao.selectUserByIdAndPwd_map(<span class="hljs-built_in">values</span>);</code></pre></div><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserByIdAndPwd_map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span></span><span class="language-xml">    SELECT * FROM t_users </span><span class="language-xml">  WHERE id = #</span><span class="hljs-template-variable">&#123;myId&#125;</span><span class="language-xml"> AND password = #</span><span class="hljs-template-variable">&#123;myPwd&#125;</span><span class="language-xml"> <span class="hljs-comment">&lt;!-- 通过key获得value --&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span></code></pre></div><h3 id="对象参数绑定"><a href="#对象参数绑定" class="headerlink" title="对象参数绑定:"></a>对象参数绑定:</h3><div class="code-wrapper"><pre><code class="hljs crmsh">public interface UserDao &#123;    //使用对象属性进行参数绑定    public <span class="hljs-keyword">User</span> <span class="hljs-title">selectUserByUserInfo</span>(<span class="hljs-keyword">User</span> <span class="hljs-title">user</span>);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserByUserInfo&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span></span><span class="language-xml">    SELECT * FROM t_users</span><span class="language-xml">    WHERE id = #</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml"> AND password = #</span><span class="hljs-template-variable">&#123;password&#125;</span><span class="language-xml"> <span class="hljs-comment">&lt;!-- #</span></span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml"><span class="hljs-comment">取User对象的id属性值、#</span></span><span class="hljs-template-variable">&#123;password&#125;</span><span class="language-xml"><span class="hljs-comment">同理 --&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span></code></pre></div><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询:"></a>模糊查询:</h3><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;User&gt; selectUsersByKeyword(<span class="hljs-meta">@Param</span>(<span class="hljs-string">&quot;keyword&quot;</span>) <span class="hljs-keyword">String</span> keyword);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.qf.mybatis.part1.different.UserDao&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUsersByKeyword&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span></span><span class="language-xml">        SELECT * FROM t_users </span><span class="language-xml">  WHERE name LIKE concat(&#x27;%&#x27;,#</span><span class="hljs-template-variable">&#123;keyword&#125;</span><span class="language-xml">,&#x27;%&#x27;) <span class="hljs-comment">&lt;!-- 拼接&#x27;%&#x27; --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span></code></pre></div><h2 id="删除"><a href="#删除" class="headerlink" title="删除:"></a>删除:</h2><p>标签：&lt; delete id&#x3D;”” parameterType&#x3D;”” &gt;</p><p>parameterType：指定sql语句中的参数类型</p><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span></span><span class="language-xml">    DELETE FROM t_users</span><span class="language-xml">    WHERE id = #</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml"> <span class="hljs-comment">&lt;!--只有一个参数时，#</span></span><span class="hljs-template-variable">&#123;任意书写&#125;</span><span class="language-xml"><span class="hljs-comment">--&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span></span></code></pre></div><h2 id="修改"><a href="#修改" class="headerlink" title="修改:"></a>修改:</h2><p>标签：&lt; update id&#x3D;”” parameterType&#x3D;”” &gt;</p><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span></span><span class="language-xml">    UPDATE t_users SET name=#</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml">, password=#</span><span class="hljs-template-variable">&#123;password&#125;</span><span class="language-xml">, sex=#</span><span class="hljs-template-variable">&#123;sex&#125;</span><span class="language-xml">, birthday=#</span><span class="hljs-template-variable">&#123;birthday&#125;</span><span class="language-xml"></span><span class="language-xml">    WHERE id = #</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml"> <span class="hljs-comment">&lt;!--方法参数为对象时，可直接使用#</span></span><span class="hljs-template-variable">&#123;属性名&#125;</span><span class="language-xml"><span class="hljs-comment">进行获取--&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></span></code></pre></div><h2 id="添加"><a href="#添加" class="headerlink" title="添加:"></a>添加:</h2><p>标签：&lt; insert id&#x3D;”” parameterType&#x3D;”” &gt;</p><p>这里的id和mapper相关接口同名，表示其相关方法对应！</p><div class="code-wrapper"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">insert</span> id=&quot;insertUser&quot; parameterType=&quot;user&quot;&gt;    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_users <span class="hljs-keyword">VALUES</span>(#&#123;id&#125;,#&#123;<span class="hljs-type">name</span>&#125;,#&#123;<span class="hljs-keyword">password</span>&#125;,#&#123;sex&#125;,#&#123;birthday&#125;,<span class="hljs-keyword">NULL</span>);&lt;/<span class="hljs-keyword">insert</span>&gt;</code></pre></div><h1 id="主键回填："><a href="#主键回填：" class="headerlink" title="主键回填："></a>主键回填：</h1><h2 id="通过last-insert-id-查询主键"><a href="#通过last-insert-id-查询主键" class="headerlink" title="通过last_insert_id()查询主键:"></a>通过last_insert_id()查询主键:</h2><p>标签：&lt; selectKey id&#x3D;”” parameterType&#x3D;”” order&#x3D;”AFTER|BEFORE”&gt;</p><p>一些情况下，新增一条数据信息，但其主键（id）是数据库自动在数据库生成（自增），而有些业务逻辑的处理是需要要到这个生成的主键（id）。上面的标签就是用来获取这个生成的主键（id）；</p><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;add&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.demo.pojo.User&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-comment">&lt;!--通过mybatis框架提供的selectKey标签获得自增产生的ID值--&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;AFTER&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span></span><span class="language-xml">select LAST_INSERT_ID()</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span></span><span class="language-xml">insert into user(code,name,remark,sex)</span><span class="language-xml">values</span><span class="language-xml">(#</span><span class="hljs-template-variable">&#123;code&#125;</span><span class="language-xml">,#</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml">,#</span><span class="hljs-template-variable">&#123;remark&#125;</span><span class="language-xml">,#</span><span class="hljs-template-variable">&#123;sex&#125;</span><span class="language-xml">)</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span></code></pre></div><p>1.selectKey 会将 SELECT LAST_INSERT_ID()的结果放入到传入的model的主键里面，即获取数据库里自动生成的id。</p><p>2.keyProperty：对应的model（这里的model就是User对象，这里表示User对象中的id对应数据库中的id）中的主键的属性名，跟数据库的主键对应。</p><p>3.order：AFTER 表示 SELECT LAST_INSERT_ID() 在insert执行之后执行,多用与自增主键；</p><p>4.BEFORE 表示 SELECT LAST_INSERT_ID() 在insert执行之前执行，这样的话就拿不到主键了，适合那种主键不是自增的类型<br>resultType：主键类型；</p><p>测试：</p><div class="code-wrapper"><pre><code class="hljs xquery"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;add&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.demo.pojo.User&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-comment">&lt;!--通过mybatis框架提供的selectKey标签获得自增产生的ID值；下面标签的意思是将插入后的主键值赋值给model也就是User的id--&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;AFTER&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span></span><span class="language-xml">select LAST_INSERT_ID()</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">insert into user(code,name,remark,sex)</span><span class="language-xml">values</span><span class="language-xml">(#</span><span class="language-xquery">&#123;code&#125;</span><span class="language-xml">,#</span><span class="language-xquery"><span class="hljs-built_in">&#123;name</span>&#125;</span><span class="language-xml">,#</span><span class="language-xquery">&#123;remark&#125;</span><span class="language-xml">,#</span><span class="language-xquery">&#123;sex&#125;</span><span class="language-xml">)</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span>UserServiceImpl:@Overridepublic void add(User user) &#123;//新增UserDao.add(user);Integer userId = user.getId();//其查询结果的主键值是赋值给model也就是User<span class="hljs-built_in">的id</span>的！System.out.println(<span class="hljs-string">&quot;添加信息的id为：&quot;</span> + userId);</code></pre></div><h2 id="通过uuid-查询主键："><a href="#通过uuid-查询主键：" class="headerlink" title="通过uuid()查询主键："></a>通过uuid()查询主键：</h2><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_order(  id <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">primary key</span>, # 字符型主键  <span class="hljs-type">name</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>))<span class="hljs-keyword">default</span> charset = utf8;</code></pre></div><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> id;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name;    <span class="hljs-comment">//set+get ...</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.qf.mybatis.part1.basic.OrderDao&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertOrder&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;order&quot;</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;BEFORE&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 插入之前,之所以选择插入之前是因为我们的目的是先生成UUID然后把该uuid作为主键插入到表中 --&gt;</span></span><span class="language-xml">            SELECT REPLACE(UUID(),&#x27;-&#x27;,&#x27;&#x27;) </span><span class="language-xml">            <span class="hljs-comment">&lt;!-- 适用于字符类型主键 ;</span></span><span class="hljs-comment"><span class="language-xml">            SELECT REPLACE(UUID(),&#x27;-&#x27;,&#x27;&#x27;)：这是实际的SQL语句。它使用MySQL的UUID()函数生成一个通用唯一标识符（UUID），然后使用REPLACE()函数将其中的破折号（-）替换为空字符串，从而生成一个没有破折号的字符串类型的主键。--&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span></span><span class="language-xml">        INSERT INTO t_order(id,name) VALUES(#</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml">,#</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml">)</span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span></code></pre></div><h1 id="MyBatis自动（反射-get和set）ORM失效："><a href="#MyBatis自动（反射-get和set）ORM失效：" class="headerlink" title="MyBatis自动（反射  get和set）ORM失效："></a><strong>MyBatis自动（反射  get和set）ORM失效：</strong></h1><p>MyBatis只能自动维护库表”列名“与”属性名“相同时的一一对应关系，二者不同时，无法自动ORM。</p><p><img src="/../images/image-20240121190543443-17058454788323.png" alt="image-20240121190543443"></p><h2 id="方案一：列的别名"><a href="#方案一：列的别名" class="headerlink" title="方案一：列的别名:"></a>方案一：列的别名:</h2><p>在SQL中使用 as 为查询字段添加列别名，以匹配属性名。</p><div class="code-wrapper"><pre><code class="hljs pgsql">&lt;mapper namespace=&quot;com.qf.mybatis.part2.orm.ManagerDao&quot;&gt;    &lt;<span class="hljs-keyword">select</span> id=&quot;selectManagerByIdAndPwd&quot; resultType=&quot;com.qf.mybatis.part2.orm.Manager&quot;&gt;        <span class="hljs-keyword">SELECT</span> mgr_id <span class="hljs-keyword">AS</span> id , mgr_name <span class="hljs-keyword">AS</span> username , mgr_pwd <span class="hljs-keyword">AS</span> <span class="hljs-keyword">password</span>        <span class="hljs-keyword">FROM</span> t_managers        <span class="hljs-keyword">WHERE</span> mgr_id = #&#123;id&#125; <span class="hljs-keyword">AND</span> mgr_pwd = #&#123;pwd&#125;    &lt;/<span class="hljs-keyword">select</span>&gt;&lt;/mapper&gt;</code></pre></div><h2 id="方案二：结果映射（ResultMap-查询结果的封装规则）"><a href="#方案二：结果映射（ResultMap-查询结果的封装规则）" class="headerlink" title="方案二：结果映射（ResultMap - 查询结果的封装规则）:"></a>方案二：结果映射（ResultMap - 查询结果的封装规则）:</h2><p>通过&lt; resultMap id&#x3D;”” type&#x3D;”” &gt;映射，匹配列名与属性名。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.qf.mybatis.part2.orm.ManagerDao&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!--定义resultMap标签--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;managerResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.qf.mybatis.part2.orm.Manager&quot;</span>&gt;</span>      <span class="hljs-comment">&lt;!--关联主键与列名--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;mgr_id&quot;</span> /&gt;</span>      <span class="hljs-comment">&lt;!--关联属性与列名--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;mgr_name&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;mgr_pwd&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>     <span class="hljs-comment">&lt;!--使用resultMap作为ORM映射依据--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAllManagers&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;managerResultMap&quot;</span>&gt;</span>        SELECT mgr_id , mgr_name , mgr_pwd        FROM t_managers    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><h1 id="MyBatis处理关联关系-多表连接"><a href="#MyBatis处理关联关系-多表连接" class="headerlink" title="MyBatis处理关联关系-多表连接:"></a>MyBatis处理关联关系-多表连接:</h1><h2 id="使用对象关系查询"><a href="#使用对象关系查询" class="headerlink" title="使用对象关系查询:"></a>使用对象关系查询:</h2><h3 id="OneToOne"><a href="#OneToOne" class="headerlink" title="OneToOne:"></a>OneToOne:</h3><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.qf.mybatis.part2.one2one.PassengerDao&quot;</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">  <span class="hljs-comment">&lt;!-- 结果映射（查询结果的封装规则） --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;passengerResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.qf.mybatis.part2.one2one.Passenger&quot;</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> /&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span> /&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;birthday&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;birthday&quot;</span> /&gt;</span></span><span class="language-xml"></span><span class="language-xml">      <span class="hljs-comment">&lt;!-- 关系表中数据的封装规则 --&gt;</span> <span class="hljs-comment">&lt;!-- 指定关系表的实体类型 --&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;passport&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;com.qf.mybatis.part2.one2one.Passport&quot;</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;passport_id&quot;</span> /&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;nationality&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;nationality&quot;</span> /&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;expire&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;expire&quot;</span> /&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;passenger_id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;passenger_id&quot;</span> /&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">  <span class="hljs-comment">&lt;!-- 多表连接查询 --&gt;</span>  <span class="hljs-comment">&lt;!-- 结果映射（查询结果的封装规则）--&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectPassengerById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;passengerResultMap&quot;</span>&gt;</span></span><span class="language-xml">        <span class="hljs-comment">&lt;!-- 别名（避免与p1.id冲突） --&gt;</span></span><span class="language-xml">        SELECT p1.id , p1.name , p1.sex , p1.birthday , p2.id as passport_id , p2.nationality , p2.expire , p2.passenger_id</span><span class="language-xml">        FROM t_passengers p1 LEFT JOIN t_passports p2</span><span class="language-xml">        ON p1.id = p2.passenger_id</span><span class="language-xml">        WHERE p1.id = #</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml"></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span></code></pre></div><ul><li>注意：指定“一方”关系时（对象），使用&lt; association javaType&#x3D;”” &gt;</li></ul><h3 id="OneToMany"><a href="#OneToMany" class="headerlink" title="OneToMany:"></a>OneToMany:</h3><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.qf.mybatis.part2.one2many.DepartmentDao&quot;</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">  <span class="hljs-comment">&lt;!-- 封装规则 --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;departmentResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.qf.mybatis.part2.one2many.Department&quot;</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> /&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> /&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;location&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;location&quot;</span> /&gt;</span></span><span class="language-xml">        </span><span class="language-xml">      <span class="hljs-comment">&lt;!-- 关系表中数据的封装规则 --&gt;</span><span class="hljs-comment">&lt;!-- 指定关系表的实体类型 --&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;emps&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;com.qf.mybatis.part2.one2many.Employee&quot;</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_id&quot;</span> /&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_name&quot;</span> /&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;salary&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;salary&quot;</span> /&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept_id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span> /&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></span><span class="language-xml">  <span class="hljs-comment">&lt;!-- 多表连接查询 --&gt;</span>      <span class="hljs-comment">&lt;!-- 封装规则 --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectDepartmentById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;departmentResultMap&quot;</span> &gt;</span></span><span class="language-xml">      <span class="hljs-comment">&lt;!-- 别名（避免与d.id、d.name冲突）--&gt;</span></span><span class="language-xml">        SELECT d.id , d.name , d.location , e.id AS emp_id , e.name emp_name , e.salary , e.dept_id</span><span class="language-xml">        FROM t_departments d LEFT JOIN t_employees e</span><span class="language-xml">        ON d.id = e.dept_id</span><span class="language-xml">        WHERE d.id = #</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml"></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span></code></pre></div><ul><li>注意：指定“多方”关系时（集合），使用&lt; collection ofType&#x3D;”” &gt;</li></ul><h3 id="关系总结"><a href="#关系总结" class="headerlink" title="关系总结:"></a>关系总结:</h3><h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL:"></a>动态SQL:</h1><h2 id="sql"><a href="#sql" class="headerlink" title="&lt; sql &gt;:"></a>&lt; sql &gt;:</h2><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.qf.mybatis.part2.dynamic.BookDao&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BOOKS_FIELD&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!-- 定义SQL片段 --&gt;</span>        SELECT id,name,author,publish,sort    <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectBookByCondition&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.qf.mybatis.part2.dynamic.Book&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;BOOKS_FIELD&quot;</span> /&gt;</span> <span class="hljs-comment">&lt;!-- 通过ID引用SQL片段 --&gt;</span>        FROM t_books    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><h2 id="if"><a href="#if" class="headerlink" title="&lt; if &gt;:"></a>&lt; if &gt;:</h2><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectBookByCondition&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.qf.mybatis.part2.dynamic.Book&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;BOOKS_FIELD&quot;</span> /&gt;</span> <span class="hljs-comment">&lt;!-- 通过ID引用SQL片段 --&gt;</span></span><span class="language-xml">    FROM t_books</span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name!=null&quot;</span>&gt;</span></span><span class="language-xml">        name=#</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml"></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author!=null&quot;</span>&gt;</span></span><span class="language-xml">        and author=#</span><span class="hljs-template-variable">&#123;author&#125;</span><span class="language-xml"></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span></code></pre></div><h2 id="where"><a href="#where" class="headerlink" title="&lt; where &gt;:"></a>&lt; where &gt;:</h2><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectBookByCondition&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.qf.mybatis.part2.dynamic.Book&quot;</span>&gt;</span></span><span class="language-xml">    SELECT id , name , author , publish , sort</span><span class="language-xml">    FROM t_books</span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span> </span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;id != null&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!-- WHERE，会自动忽略前后缀（如：and | or） --&gt;</span></span><span class="language-xml">            id = #</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span></span><span class="language-xml">            and name = #</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span></span><span class="language-xml">            and author = #</span><span class="hljs-template-variable">&#123;author&#125;</span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;publish != null&quot;</span>&gt;</span></span><span class="language-xml">            and publish = #</span><span class="hljs-template-variable">&#123;publish&#125;</span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sort != null&quot;</span>&gt;</span></span><span class="language-xml">            and sort = #</span><span class="hljs-template-variable">&#123;sort&#125;</span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span></code></pre></div><h2 id="set"><a href="#set" class="headerlink" title="&lt; set &gt;:"></a>&lt; set &gt;:</h2><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateBookByCondition&quot;</span>&gt;</span></span><span class="language-xml">    UPDATE t_books</span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- where子句中满足条件的if，会自动忽略后缀（如：,） --&gt;</span></span><span class="language-xml">            name = #</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml"> ,</span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span></span><span class="language-xml">            author = #</span><span class="hljs-template-variable">&#123;author&#125;</span><span class="language-xml"> ,</span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;publish != null&quot;</span>&gt;</span></span><span class="language-xml">            publish = #</span><span class="hljs-template-variable">&#123;publish&#125;</span><span class="language-xml"> ,</span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sort != null&quot;</span>&gt;</span></span><span class="language-xml">            sort = #</span><span class="hljs-template-variable">&#123;sort&#125;</span><span class="language-xml"> ,</span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span></span><span class="language-xml">    WHERE id = #</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></span></code></pre></div><h2 id="trim"><a href="#trim" class="headerlink" title="&lt; trim &gt;:"></a>&lt; trim &gt;:</h2><p>&lt; trim prefix&#x3D;”” suffix&#x3D;”” prefixOverrides&#x3D;”” suffixOverrides&#x3D;”” &gt;代替&lt; where &gt; 、&lt; set &gt;</p><p>prefix:表示该字段的前缀； suffix：表示要去除多余的前缀； suffixOverrides：表示要去除多余的后缀；</p><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectBookByCondition&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.qf.mybatis.day2.dynamic.Book&quot;</span>&gt;</span></span><span class="language-xml">SELECT id,name,author,publish,sort</span><span class="language-xml">    FROM t_books</span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;WHERE&quot;</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">&quot;AND|OR&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!-- 增加WHERE前缀，自动忽略前缀 --&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;id != null&quot;</span>&gt;</span></span><span class="language-xml">            and id = #</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span></span><span class="language-xml">            and name = #</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span></span><span class="language-xml">            and author = #</span><span class="hljs-template-variable">&#123;author&#125;</span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;publish != null&quot;</span>&gt;</span></span><span class="language-xml">            and publish = #</span><span class="hljs-template-variable">&#123;publish&#125;</span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sort != null&quot;</span>&gt;</span></span><span class="language-xml">            and sort = #</span><span class="hljs-template-variable">&#123;sort&#125;</span><span class="language-xml"></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateBookByCondition&quot;</span>&gt;</span></span><span class="language-xml">UPDATE t_books</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;SET&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!-- 增加SET前缀，自动忽略后缀 --&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span></span><span class="language-xml">name = #</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml"> ,</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span></span><span class="language-xml">author = #</span><span class="hljs-template-variable">&#123;author&#125;</span><span class="language-xml"> ,</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;publish != null&quot;</span>&gt;</span></span><span class="language-xml">publish = #</span><span class="hljs-template-variable">&#123;publish&#125;</span><span class="language-xml"> ,</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sort != null&quot;</span>&gt;</span></span><span class="language-xml">sort = #</span><span class="hljs-template-variable">&#123;sort&#125;</span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span></span><span class="language-xml">WHERE id = #</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></span></code></pre></div><h2 id="foreach"><a href="#foreach" class="headerlink" title="&lt; foreach &gt;:"></a>&lt; foreach &gt;:</h2><div class="code-wrapper"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">delete</span> id=&quot;deleteBookByIds&quot;&gt;<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> t_books<span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IN</span>&lt;<span class="hljs-keyword">foreach</span> collection=&quot;list&quot; <span class="hljs-keyword">open</span>=&quot;(&quot; separator=&quot;,&quot; <span class="hljs-keyword">close</span>=&quot;)&quot;  item=&quot;id&quot; <span class="hljs-keyword">index</span>=&quot;i&quot;&gt;#&#123;id&#125;&lt;/<span class="hljs-keyword">foreach</span>&gt;&lt;/<span class="hljs-keyword">delete</span>&gt;</code></pre></div><table><thead><tr><th>参数</th><th>描述</th><th>取值</th></tr></thead><tbody><tr><td>collection</td><td>容器类型</td><td>list、array、map</td></tr><tr><td>open</td><td>起始符</td><td>(</td></tr><tr><td>close</td><td>结束符</td><td>)</td></tr><tr><td>separator</td><td>分隔符</td><td>,</td></tr><tr><td>index</td><td>下标号</td><td>从0开始，依次递增</td></tr><tr><td>item</td><td>当前项</td><td>任意名称（循环中通过 #{任意名称} 表达式访问）</td></tr></tbody></table><h1 id="缓存（Cache）"><a href="#缓存（Cache）" class="headerlink" title="缓存（Cache）:"></a>缓存（Cache）:</h1><p>内存中的一块存储空间，服务于某个应用程序，旨在将频繁读取的数据临时保存在内存中，便于二次快速访问。</p><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存:"></a>一级缓存:</h2><p>SqlSession级别的缓存，同一个SqlSession的发起多次同构查询，会将数据保存在一级缓存中。</p><ul><li>注意：无需任何配置，默认开启一级缓存。</li></ul><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存:"></a>二级缓存:</h2><p>SqlSessionFactory级别的缓存，同一个SqlSessionFactory构建的SqlSession发起的多次同构查询，会将数据保存在二级缓存中。</p><ul><li>注意：在sqlSession.commit()或者sqlSession.close()之后生效。</li><li>二级缓存：没有默认开启，需要手动开启，其存储的范围是Mapper NameSpace。即，其范围是Mapper映射器的某个命名空间</li></ul><h2 id="开启全局缓存"><a href="#开启全局缓存" class="headerlink" title="开启全局缓存:"></a>开启全局缓存:</h2><p>&lt; settings &gt;是MyBatis中极为重要的调整设置，他们会改变MyBatis的运行行为，其他详细配置可参考官方文档。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">...</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 注意书写位置 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!-- mybaits-config.xml中开启全局缓存（默认开启） --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div><h1 id="八股文："><a href="#八股文：" class="headerlink" title="八股文："></a>八股文：</h1><h2 id="和-的区别是什么？："><a href="#和-的区别是什么？：" class="headerlink" title="**#{}和${}**的区别是什么？："></a>**#{}<strong>和</strong>${}**的区别是什么？：</h2><p>#{}是预编译处理，${}是字符串替换。使用#{}可以有效的防止SQL注入，提高系统安全性。</p><h2 id="模糊查询like语句该怎么写-："><a href="#模糊查询like语句该怎么写-：" class="headerlink" title="模糊查询like语句该怎么写**?**："></a>模糊查询<strong>like</strong>语句该怎么写**?**：</h2><p>1.让传递的参数为模糊处理过的：</p><p><img src="/../images/image-20240121205328569.png" alt="image-20240121205328569"></p><p>2.在mapper查询的时候使用函数：</p><div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.qf.mybatis.part1.different.UserDao&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUsersByKeyword&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span></span><span class="language-xml">        SELECT * FROM t_users </span><span class="language-xml">  WHERE name LIKE concat(&#x27;%&#x27;,#</span><span class="hljs-template-variable">&#123;keyword&#125;</span><span class="language-xml">,&#x27;%&#x27;) <span class="hljs-comment">&lt;!-- 拼接&#x27;%&#x27; --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span></code></pre></div><h2 id="分页插件："><a href="#分页插件：" class="headerlink" title="分页插件："></a>分页插件：</h2><p>分页插件针对ResultSet结果集执行的内存分页，而非物理分 页。分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截 待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p><h2 id="延迟加载："><a href="#延迟加载：" class="headerlink" title="延迟加载："></a>延迟加载：</h2><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加 载lazyLoadingEnabled&#x3D;true|false。</p><p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如    调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接   着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p><p><strong>延迟加载</strong>：在真正使用数据的时候才发起查询，不用的时候不查询关联的数据，延迟加载又叫按需查询（懒加载）</p><p><strong>立即加载</strong>：不管用不用，只要一调用方法，马上发起查询。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo flouid总结</title>
    <link href="/2024/01/16/hexo%20flouid%E6%80%BB%E7%BB%93%EF%BC%9A/"/>
    <url>/2024/01/16/hexo%20flouid%E6%80%BB%E7%BB%93%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705318631263-a44e3cf7-bf2f-481e-bd67-b509b234a07d.png?x-oss-process=image/resize,w_706,limit_0#averageHue=%233e3753&from=url&id=OXEIR&originHeight=622&originWidth=706&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></h1><h1 id="常见操作："><a href="#常见操作：" class="headerlink" title="常见操作："></a>常见操作：</h1><div class="code-wrapper"><pre><code class="hljs python">语雀导出markdown然后在发布的时候！可以先不写标题！导出为markdown后在篇头就可以写标题了，不然无法写标题。</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 清除缓存文件</span>hexo clean<span class="hljs-comment">#  生成静态文件 </span> hexo g <span class="hljs-comment"># 部署网站</span>hexo d</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">---title: 文章标题categories: [分类名称]tags: [标签<span class="hljs-number">1</span>, 标签<span class="hljs-number">2</span>]---</code></pre></div><h1 id="基础教程："><a href="#基础教程：" class="headerlink" title="基础教程："></a>基础教程：</h1><p><a href="https://blog.csdn.net/weixin_51545953/article/details/128499341">【个人博客】Hexo个人博客搭建与配置详细教程 + Fluid主题 + Gitee发布_fluid文章页设置-CSDN博客</a><br>ps:想修改某些配置可以在_config.yml配置文件中根据想修改部位特征的关键字查询。</p><h1 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h1><h3 id="1-使用Valine评论无法正常评论："><a href="#1-使用Valine评论无法正常评论：" class="headerlink" title="1.使用Valine评论无法正常评论："></a>1.使用Valine评论无法正常评论：</h3><p>原因：<br>1.修改Valine配置的时候没有注意appid和后面的值要有空格。<br>2.要在LeanCloud的数据储存中创建Comment类</p> <meta name="referrer" content="no-referrer"><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1705325322444-95551c58-54e5-4f30-b743-8d13d62fba77.png#averageHue=%23c5c5c5&clientId=u4f2c0d6f-91a8-4&from=paste&height=442&id=u82d94f4a&originHeight=553&originWidth=971&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=77012&status=done&style=none&taskId=ub10de5ff-5e77-48e5-a801-adfcf2cf6e9&title=&width=776.8" alt="image.png"><br><a href="https://console.leancloud.cn/apps/NkSNF5NG3Uup8tDgwIfBlJ9d-gzGzoHsz/">LeanCloud</a></p><h3 id="2-上传的md文档使用了外部图片链接导致博客页面加载不出来报403错误（特别是语雀导为md文档时照片报403）："><a href="#2-上传的md文档使用了外部图片链接导致博客页面加载不出来报403错误（特别是语雀导为md文档时照片报403）：" class="headerlink" title="2.上传的md文档使用了外部图片链接导致博客页面加载不出来报403错误（特别是语雀导为md文档时照片报403）："></a>2.上传的md文档使用了外部图片链接导致博客页面加载不出来报403错误（特别是语雀导为md文档时照片报403）：</h3><p>原因：是语雀设置防盗链策略，不允许图片被其他域名引用。<br>解决方法：<br>方法一.在不能显示的md文档前添加</p><div class="code-wrapper"><pre><code class="hljs python">&lt;meta name=<span class="hljs-string">&quot;referrer&quot;</span> content=<span class="hljs-string">&quot;no-referrer&quot;</span>&gt;</code></pre></div><p>方法二：在全局CSS或者主题的某个样式表中（如layout&#x2F;_partials&#x2F;head.ejs）设置默认的referrer策略，也就是在layout&#x2F;_partials&#x2F;head.ejs中的head标签添加如下代码：</p><div class="code-wrapper"><pre><code class="hljs python">&lt;meta name=<span class="hljs-string">&quot;referrer&quot;</span> content=<span class="hljs-string">&quot;no-referrer&quot;</span>&gt;</code></pre></div><p>上面2种方法都需要执行hexo g命令启动后才能显示！直接是无法显示的！</p><h3 id="3-代码高亮使用了highlightjs库，就不用开启行号的功能了，不然md文档中的代码无法正常换行，显示在一行。"><a href="#3-代码高亮使用了highlightjs库，就不用开启行号的功能了，不然md文档中的代码无法正常换行，显示在一行。" class="headerlink" title="3.代码高亮使用了highlightjs库，就不用开启行号的功能了，不然md文档中的代码无法正常换行，显示在一行。"></a>3.代码高亮使用了highlightjs库，就不用开启行号的功能了，不然md文档中的代码无法正常换行，显示在一行。</h3><h3 id="4-在md中设置的文档标题无法在博客中显示的，需要在文章头部添加如下信息："><a href="#4-在md中设置的文档标题无法在博客中显示的，需要在文章头部添加如下信息：" class="headerlink" title="4.在md中设置的文档标题无法在博客中显示的，需要在文章头部添加如下信息："></a>4.在md中设置的文档标题无法在博客中显示的，需要在文章头部添加如下信息：</h3><div class="code-wrapper"><pre><code class="hljs python">---title: 文章标题categories: [分类名称]tags: [标签<span class="hljs-number">1</span>, 标签<span class="hljs-number">2</span>]---</code></pre></div><h3 id="5-每次上传文章后，githubpage绑定的域名消失："><a href="#5-每次上传文章后，githubpage绑定的域名消失：" class="headerlink" title="5.每次上传文章后，githubpage绑定的域名消失："></a>5.每次上传文章后，githubpage绑定的域名消失：</h3><p>在 <code>hexo</code> 生成的博客的 <code>source</code> 目录下新建一个 <code>CNAME</code> 文件，然后在这个文件中填入你的域名</p><p><img src="/../images/70.png" alt="这里写图片描述"></p><h3 id="6-上传的长文章无法显示："><a href="#6-上传的长文章无法显示：" class="headerlink" title="6.上传的长文章无法显示："></a>6.上传的长文章无法显示：</h3><p>个人原因是上传的markdown文档中有一个表格！该表格hexo自带的markdown渲染器无法渲染导致该表格后的内容都无法显示！</p><h1 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h1> <meta name="referrer" content="no-referrer"><p><img src="https://cdn.nlark.com/yuque/0/2024/gif/28066124/1705318498223-08e05c5d-94d0-462b-a6af-740ded57795b.gif#averageHue=%2301356b&clientId=ufca4afba-4b97-4&from=paste&id=FOjx3&originHeight=280&originWidth=476&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ua55ddca9-4504-4386-bffd-3229798bd17&title="></p><h3 id="1-为了更好的管理博客可以安装：npm-install-–save-hexo-admin；"><a href="#1-为了更好的管理博客可以安装：npm-install-–save-hexo-admin；" class="headerlink" title="1.为了更好的管理博客可以安装：npm install –save hexo-admin；"></a>1.为了更好的管理博客可以安装：npm install –save hexo-admin；</h3><h3 id="2-添加网站运行时间："><a href="#2-添加网站运行时间：" class="headerlink" title="2.添加网站运行时间："></a>2.添加网站运行时间：</h3><p>页脚添加网站运行时间，只需要在主题配置中的 footer: content 添加：</p><div class="code-wrapper"><pre><code class="hljs python">footer:  content: <span class="hljs-string">&#x27;</span><span class="hljs-string">    &lt;div&gt;</span><span class="hljs-string">      &lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;</span><span class="hljs-string">      &lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;</span><span class="hljs-string">      &lt;script src=&quot;/js/duration.js&quot;&gt;&lt;/script&gt;</span><span class="hljs-string">    &lt;/div&gt;</span><span class="hljs-string">  &#x27;</span></code></pre></div><p>之后在主题目录下创建 source&#x2F;js&#x2F;duration.js，内容如下：</p><div class="code-wrapper"><pre><code class="hljs python">var now = new Date();function createtime() &#123;    var grt= new Date(<span class="hljs-string">&quot;03/03/2021 12:00:00&quot;</span>);//在此处修改你的建站时间    now.setTime(now.getTime()+<span class="hljs-number">250</span>);    days = (now - grt ) / <span class="hljs-number">1000</span> / <span class="hljs-number">60</span> / <span class="hljs-number">60</span> / <span class="hljs-number">24</span>; dnum = Math.floor(days);    hours = (now - grt ) / <span class="hljs-number">1000</span> / <span class="hljs-number">60</span> / <span class="hljs-number">60</span> - (<span class="hljs-number">24</span> * dnum); hnum = Math.floor(hours);    <span class="hljs-keyword">if</span>(String(hnum).length ==<span class="hljs-number">1</span> )&#123;hnum = <span class="hljs-string">&quot;0&quot;</span> + hnum;&#125; minutes = (now - grt ) / <span class="hljs-number">1000</span> /<span class="hljs-number">60</span> - (<span class="hljs-number">24</span> * <span class="hljs-number">60</span> * dnum) - (<span class="hljs-number">60</span> * hnum);    mnum = Math.floor(minutes); <span class="hljs-keyword">if</span>(String(mnum).length ==<span class="hljs-number">1</span> )&#123;mnum = <span class="hljs-string">&quot;0&quot;</span> + mnum;&#125;    seconds = (now - grt ) / <span class="hljs-number">1000</span> - (<span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * dnum) - (<span class="hljs-number">60</span> * <span class="hljs-number">60</span> * hnum) - (<span class="hljs-number">60</span> * mnum);    snum = Math.<span class="hljs-built_in">round</span>(seconds); <span class="hljs-keyword">if</span>(String(snum).length ==<span class="hljs-number">1</span> )&#123;snum = <span class="hljs-string">&quot;0&quot;</span> + snum;&#125;    document.getElementById(<span class="hljs-string">&quot;timeDate&quot;</span>).innerHTML = <span class="hljs-string">&quot;本站已安全运行 &quot;</span>+dnum+<span class="hljs-string">&quot; 天 &quot;</span>;    document.getElementById(<span class="hljs-string">&quot;times&quot;</span>).innerHTML = hnum + <span class="hljs-string">&quot; 小时 &quot;</span> + mnum + <span class="hljs-string">&quot; 分 &quot;</span> + snum + <span class="hljs-string">&quot; 秒&quot;</span>;&#125;setInterval(<span class="hljs-string">&quot;createtime()&quot;</span>,<span class="hljs-number">250</span>);</code></pre></div><h3 id="3-添加一言："><a href="#3-添加一言：" class="headerlink" title="3.添加一言："></a>3.添加一言：</h3><p>修改_config.yml的slogan配置为如下：</p><div class="code-wrapper"><pre><code class="hljs python">slogan:  enable: true  <span class="hljs-comment"># 为空则按 hexo config.subtitle 显示</span>  <span class="hljs-comment"># If empty, text based on `subtitle` in hexo config</span>  text: <span class="hljs-string">&quot;太阳初升之时！你会回想起曾经的自己吗？&quot;</span>  <span class="hljs-comment"># 通过 API 接口作为首页副标题的内容，必须返回的是 JSON 格式，如果请求失败则按 text 字段显示，该功能必须先开启 typing 打字机功能</span>  <span class="hljs-comment"># Subtitle of the homepage through the API, must be returned a JSON. If the request fails, it will be displayed in `text` value. This feature must first enable the typing animation</span>  api:    enable: true    <span class="hljs-comment"># 请求地址</span>    <span class="hljs-comment"># Request url</span>    url: <span class="hljs-string">&quot;https://v1.hitokoto.cn/&quot;</span>    <span class="hljs-comment"># 请求方法</span>    <span class="hljs-comment"># Request method</span>    <span class="hljs-comment"># Available: GET | POST | PUT</span>    method: <span class="hljs-string">&quot;GET&quot;</span>    <span class="hljs-comment"># 请求头</span>    <span class="hljs-comment"># Request headers</span>    headers: &#123;&#125;    <span class="hljs-comment"># 从请求结果获取字符串的取值字段，最终必须是一个字符串，例如返回结果为 &#123;&quot;data&quot;: &#123;&quot;author&quot;: &quot;fluid&quot;, &quot;content&quot;: &quot;An elegant theme&quot;&#125;&#125;, 则取值字段为 [&#x27;data&#x27;, &#x27;content&#x27;]；如果返回是列表则自动选择第一项</span>    <span class="hljs-comment"># The value field of the string obtained from the response. For example, the response content is &#123;&quot;data&quot;: &#123;&quot;author&quot;: &quot;fluid&quot;, &quot;content&quot;: &quot;An elegant theme&quot;&#125;&#125;, the expected `keys: [&#x27;data&#x27;,&#x27;content&#x27;]`; if the return is a list, the first item is automatically selected</span>    keys: [<span class="hljs-string">&#x27;hitokoto&#x27;</span>]</code></pre></div><h3 id="4-视频背景：目前是静态托管，以后再说"><a href="#4-视频背景：目前是静态托管，以后再说" class="headerlink" title="4.视频背景：目前是静态托管，以后再说:"></a>4.视频背景：目前是静态托管，以后再说:</h3><p><a href="https://www.zywvvd.com/notes/hexo/theme/fluid/fluid-video-bg-fixed/fluid-video-bg-fixed/">教程</a></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#---------------------------# 首页# Home Page#---------------------------index:  # 首页 Banner 头图，可以是相对路径或绝对路径，以下相同  # Path of Banner image, can be a relative path or an absolute path, the same on other pages  banner_img: /img/default.png   # 首页 Banner 使用随机视频  # true 开启  false 关闭  banner_video: true</span></code></pre></div><h3 id="5-添加背景黑色线条："><a href="#5-添加背景黑色线条：" class="headerlink" title="5.添加背景黑色线条："></a>5.添加背景黑色线条：</h3><div class="code-wrapper"><pre><code class="hljs python">!function()&#123;function o(w,v,i)&#123;<span class="hljs-keyword">return</span> w.getAttribute(v)||i&#125;function j(i)&#123;<span class="hljs-keyword">return</span> document.getElementsByTagName(i)&#125;function l()&#123;var i=j(<span class="hljs-string">&quot;script&quot;</span>),w=i.length,v=i[w-<span class="hljs-number">1</span>];<span class="hljs-keyword">return</span>&#123;l:w,z:o(v,<span class="hljs-string">&quot;zIndex&quot;</span>,-<span class="hljs-number">1</span>),o:o(v,<span class="hljs-string">&quot;opacity&quot;</span>,<span class="hljs-number">0.5</span>),c:o(v,<span class="hljs-string">&quot;color&quot;</span>,<span class="hljs-string">&quot;0,0,0&quot;</span>),n:o(v,<span class="hljs-string">&quot;count&quot;</span>,<span class="hljs-number">99</span>)&#125;&#125;function k()&#123;r=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,n=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight&#125;function b()&#123;e.clearRect(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,r,n);var w=[f].concat(t);var x,v,A,B,z,y;t.forEach(function(i)&#123;i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;r||i.x&lt;<span class="hljs-number">0</span>?-<span class="hljs-number">1</span>:<span class="hljs-number">1</span>,i.ya*=i.y&gt;n||i.y&lt;<span class="hljs-number">0</span>?-<span class="hljs-number">1</span>:<span class="hljs-number">1</span>,e.fillRect(i.x-<span class="hljs-number">0.5</span>,i.y-<span class="hljs-number">0.5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(v=<span class="hljs-number">0</span>;v&lt;w.length;v++)&#123;x=w[v];<span class="hljs-keyword">if</span>(i!==x&amp;&amp;null!==x.x&amp;&amp;null!==x.y)&#123;B=i.x-x.x,z=i.y-x.y,y=B*B+z*z;y&lt;x.<span class="hljs-built_in">max</span>&amp;&amp;(x===f&amp;&amp;y&gt;=x.<span class="hljs-built_in">max</span>/<span class="hljs-number">2</span>&amp;&amp;(i.x-=<span class="hljs-number">0.03</span>*B,i.y-=<span class="hljs-number">0.03</span>*z),A=(x.<span class="hljs-built_in">max</span>-y)/x.<span class="hljs-built_in">max</span>,e.beginPath(),e.lineWidth=A/<span class="hljs-number">2</span>,e.strokeStyle=<span class="hljs-string">&quot;rgba(&quot;</span>+s.c+<span class="hljs-string">&quot;,&quot;</span>+(A+<span class="hljs-number">0.2</span>)+<span class="hljs-string">&quot;)&quot;</span>,e.moveTo(i.x,i.y),e.lineTo(x.x,x.y),e.stroke())&#125;&#125;w.splice(w.indexOf(i),<span class="hljs-number">1</span>)&#125;),m(b)&#125;var u=document.createElement(<span class="hljs-string">&quot;canvas&quot;</span>),s=l(),c=<span class="hljs-string">&quot;c_n&quot;</span>+s.l,e=u.getContext(<span class="hljs-string">&quot;2d&quot;</span>),r,n,m=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(i)&#123;window.setTimeout(i,<span class="hljs-number">1000</span>/<span class="hljs-number">45</span>)&#125;,a=Math.random,f=&#123;x:null,y:null,<span class="hljs-built_in">max</span>:<span class="hljs-number">20000</span>&#125;;u.<span class="hljs-built_in">id</span>=c;u.style.cssText=<span class="hljs-string">&quot;position:fixed;top:0;left:0;z-index:&quot;</span>+s.z+<span class="hljs-string">&quot;;opacity:&quot;</span>+s.o;j(<span class="hljs-string">&quot;body&quot;</span>)[<span class="hljs-number">0</span>].appendChild(u);k(),window.onresize=k;window.onmousemove=function(i)&#123;i=i||window.event,f.x=i.clientX,f.y=i.clientY&#125;,window.onmouseout=function()&#123;f.x=null,f.y=null&#125;;<span class="hljs-keyword">for</span>(var t=[],p=<span class="hljs-number">0</span>;s.n&gt;p;p++)&#123;var h=a()*r,g=a()*n,q=<span class="hljs-number">2</span>*a()-<span class="hljs-number">1</span>,d=<span class="hljs-number">2</span>*a()-<span class="hljs-number">1</span>;t.push(&#123;x:h,y:g,xa:q,ya:d,<span class="hljs-built_in">max</span>:<span class="hljs-number">6000</span>&#125;)&#125;setTimeout(function()&#123;b()&#125;,<span class="hljs-number">100</span>)&#125;();</code></pre></div><p>将上面的代码复制，并在此目录下 themes&#x2F;fluid&#x2F;source&#x2F;js&#x2F;DynamicLine.js 创建文件，将代码全部粘贴进去。<br>然后在主题配置 _config.yml 中找到 custom_js 或者 custom_css，修改如下：</p><div class="code-wrapper"><pre><code class="hljs python">custom_js:  - /js/DynamicLine.js</code></pre></div><h3 id="6-Note美化："><a href="#6-Note美化：" class="headerlink" title="6.Note美化："></a>6.Note美化：</h3><h3 id="7-固定背景："><a href="#7-固定背景：" class="headerlink" title="7.固定背景："></a>7.固定背景：</h3><p><a href="https://asteri5m.icu/archives/0c8538e7-5b5f-4897-8e8b-0cff84320473">魔改教程</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
