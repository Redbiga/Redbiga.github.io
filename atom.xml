<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>山麋一笑</title>
  
  
  <link href="http://www.bojiboqi.fun/atom.xml" rel="self"/>
  
  <link href="http://www.bojiboqi.fun/"/>
  <updated>2024-02-28T13:06:58.838Z</updated>
  <id>http://www.bojiboqi.fun/</id>
  
  <author>
    <name>山麋一笑</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>知识点拾遗：</title>
    <link href="http://www.bojiboqi.fun/2024/02/28/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97%EF%BC%9A/"/>
    <id>http://www.bojiboqi.fun/2024/02/28/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97%EF%BC%9A/</id>
    <published>2024-02-28T13:02:28.586Z</published>
    <updated>2024-02-28T13:06:58.838Z</updated>
    
    <content type="html"><![CDATA[<p><a name="w1c60"></a></p><h2 id="什么是服务器？">什么是服务器？</h2><p>服务器是指一种计算机硬件或软件，它为其他计算机或设备提供数据或服务。Web服务器是一种特殊的服务器，它主要用于接收客户端请求并返回网页内容。Web服务器可以处理HTTP请求并返回HTML、CSS、JavaScript等文件，以便在浏览器中显示网页。<br />简单来说，Web服务器主要负责处理向浏览器发送HTML以供浏览<a href="https://zhuanlan.zhihu.com/p/351999922">1</a><em><strong>服务器不仅可以是硬件，也可以是软件。服务器软件运行在计算机硬件上，它能够接收客户端请求并提供相应的服务。</strong></em><br />服务器可以运行多种操作系统，包括Windows Server、Linux和Unix等。选择哪种操作系统取决于服务器的用途和管理员的喜好。不同的操作系统有不同的特点和优势，例如Linux和Unix通常被认为更稳定且更安全，而Windows Server则提供了更好的图形用户界面。机房是一个专门用于存放服务器和其他计算机设备的房间。它通常配备了空调、电源、防火和安全措施，以确保服务器能够在安全、稳定的环境中运行。<br />服务器通常会被安装在机房内的机架上，并通过网络连接到其他设备。这样，管理员就可以在一个集中的位置管理和维护所有服务器。<br><a name="Z58oN"></a></p><h2 id="浏览器上面搜索框和下面的搜索框有什么区别？">浏览器上面搜索框和下面的搜索框有什么区别？</h2><p><a href="https://www.zhihu.com/question/20341979">浏览器上面的搜索框又叫地址栏或Omnibox，它可以输入网址或者搜索关键词，也可以设置不同的搜索引擎和快捷键</a><a href="https://www.zhihu.com/question/20341979">1</a><a href="https://sspai.com/post/44922">2</a>。<a href="https://zhuanlan.zhihu.com/p/363343360">浏览器下面的搜索框一般是指网页中嵌入的搜索框，它只能输入搜索关键词，并且使用固定的搜索引擎</a><a href="https://zhuanlan.zhihu.com/p/363343360">3</a><br><a name="w1yHa"></a></p><h4 id="input-class-itxt-type-password-placeholder-请输入密码-autocomplete-off-tabindex-1-name-password-id-password-这里的placeholder和autocomplete-tabindex是什么？"><input class="itxt" type="password" placeholder="请输入密码" autocomplete="off" tabindex="1" name="password" id="password" />这里的placeholder和autocomplete,tabindex是什么？</h4><p>In the <strong>input</strong> element you provided:</p><ul><li>The <strong>placeholder</strong> attribute specifies a short hint that describes the expected value of the input field. The hint is displayed in the input field before the user enters a value. In this case, the placeholder text is <strong>“请输入密码”</strong>, which means “Please enter password” in English.</li><li>The <strong>autocomplete</strong> attribute specifies whether or not an input field should have autocomplete enabled. When autocomplete is enabled, the browser will automatically fill in values that the user has previously entered in similar fields. In this case, <strong>autocomplete=“off”</strong> means that autocomplete is disabled for this input field.</li><li>The <strong>tabindex</strong> attribute specifies the tab order of an element when using the “Tab” key to navigate through a form. Elements with a higher <strong>tabindex</strong> value will be visited later than elements with a lower <strong>tabindex</strong> value. In this case, <strong>tabindex=“1”</strong> means that this input field will be the first element to receive focus when navigating through the form using the “Tab” key.<br><a name="O0BJ5"></a></li></ul><h4 id="…-…-static-css-style-css这段代码的…-是什么意思？">…/…/static/css/style.css这段代码的…/是什么意思？</h4><p>In the file path <strong>‘…/…/static/css/style.css’</strong> that you provided, the <strong>‘…/’</strong> is a relative path notation that means “go up one directory level”.<br />In this case, the <strong>‘…/…/’</strong> at the beginning of the file path means to go up two directory levels from the current location of the HTML file. From there, it navigates down into the <strong>‘static/css/’</strong> directories to locate the <strong>‘style.css’</strong> file.<br />For example, if your HTML file is located at <strong>‘/myproject/pages/home/index.html’</strong>, then <strong>‘…/…/static/css/style.css’</strong> would resolve to <strong>‘/myproject/static/css/style.css’</strong>.<br><a name="EYu2J"></a></p><h4 id="IDEA实现多行不间断选择：">IDEA实现多行不间断选择：</h4><p>按住alt然后鼠标上下移动选择。<br><a name="PHf1j"></a></p><h4 id="spring-boot-starter-web里面的spring-boot-starter是什么">spring-boot-starter-web里面的spring-boot-starter是什么</h4><p>spring-boot-starter-web里面的spring-boot-starter是一个起步依赖，它可以帮助我们引入Web开发所需要的相关jar包，包括嵌入的Servlet容器和SpringMVC的依赖。它也为SpringMVC提供了大量的自动配置，可以适用于大多数Web开发场景。spring-boot-starter-web是官方提供的starter，后面跟的单词就是场景，比如说后面跟web,就是导入web场景的所有依赖。<br><a name="gfabt"></a></p><h4 id="命令行参数的java和javac的区别">命令行参数的java和javac的区别</h4><p>java和javac是Java开发工具包（JDK）中的两个命令行工具，它们分别用于运行Java程序和编译Java源代码。<br />javac命令用于将Java源代码编译为Java字节码文件（.class文件）。编译后的字节码文件可以在Java虚拟机（JVM）上运行，以执行Java程序。要使用javac命令编译Java源代码，您需要在命令行中指定Java源代码文件的路径，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac Main.java</span><br></pre></td></tr></table></figure><p>该命令会将当前目录下的Main.java文件编译为Main.class文件。<br />java命令用于运行Java程序。它将编译后的Java字节码文件加载到JVM中，并执行程序的入口点（通常是main方法）。要使用java命令运行Java程序，您需要在命令行中指定要运行的Java类的名称，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Main</span><br></pre></td></tr></table></figure><p>该命令会在JVM中加载Main.class文件，并执行其中的main方法。<br />需要注意的是，javac和java命令行参数的语法略有不同。javac命令行参数通常包括要编译的Java源代码文件的路径，以及一些编译选项。而java命令行参数通常包括要运行的Java类的名称，以及一些运行时参数。例如，要向java命令传递命令行参数，可以在类名后面加上参数，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Main arg1 arg2</span><br></pre></td></tr></table></figure><p>该命令会在JVM中加载Main.class文件，并执行其中的main方法，同时将arg1和arg2作为命令行参数传递给程序。</p><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;w1c60&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是服务器？&quot;&gt;什么是服务器？&lt;/h2&gt;
&lt;p&gt;服务器是指一种计算机硬件或软件，它为其他计算机或设备提供数据或服务。Web服务器是一种特殊的服务器，它主要用于接收客户端请求并返回网页内容。Web服务器可以处</summary>
      
    
    
    
    <category term="web" scheme="http://www.bojiboqi.fun/categories/web/"/>
    
    
    <category term="web" scheme="http://www.bojiboqi.fun/tags/web/"/>
    
    <category term="零散知识点" scheme="http://www.bojiboqi.fun/tags/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>知识点</title>
    <link href="http://www.bojiboqi.fun/2024/02/28/%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A%EF%BC%88BUG%EF%BC%89/"/>
    <id>http://www.bojiboqi.fun/2024/02/28/%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A%EF%BC%88BUG%EF%BC%89/</id>
    <published>2024-02-28T13:02:28.583Z</published>
    <updated>2024-02-28T10:44:05.259Z</updated>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h4 id="找不到mybatis文件：java-io-IOException-Could-not-find-resource-mybatis-config-xml">找不到mybatis文件：java.io.IOException: Could not find resource mybatis.config.xml</h4><p>bug:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688470269608-4fd3e82c-3631-4e0b-8beb-476c4d5ecdac.png#averageHue=%23080302&amp;clientId=u485c1c2b-dc00-4&amp;from=paste&amp;height=144&amp;id=u3d173d10&amp;originHeight=180&amp;originWidth=824&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=28618&amp;status=done&amp;style=none&amp;taskId=uaf61014d-875b-4936-b7c1-15aa27842ac&amp;title=&amp;width=659.2" alt="image.png"><br>原因：mybatis中的<mapper>映射不正确外加生成sqlssesion的文件引用不正确<br>修改后：这里的mybatis-config.xm;和com在同一个目录下的，EmpMapper.xml使用相对路径表示为：com/example/demo/mapper/EmpMapper<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688469950619-71023303-ad70-4420-b551-9f37823c8a45.png#averageHue=%231f5043&amp;clientId=u485c1c2b-dc00-4&amp;from=paste&amp;height=214&amp;id=uaf338d14&amp;originHeight=268&amp;originWidth=1191&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=57097&amp;status=done&amp;style=none&amp;taskId=u9ac5034a-e989-49c8-a528-373d7d2ca32&amp;title=&amp;width=952.8" alt="image.png"><br>修改文件引用：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688470214376-cfb36d91-a17c-4da4-98e9-fbd48850bf9e.png#averageHue=%23141624&amp;clientId=u485c1c2b-dc00-4&amp;from=paste&amp;height=160&amp;id=u03f0c4f0&amp;originHeight=200&amp;originWidth=939&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=47710&amp;status=done&amp;style=none&amp;taskId=u723765e0-d52d-4b36-97d7-098d7693021&amp;title=&amp;width=751.2" alt="image.png"></p><h4 id="复制代码出现NBSP乱码解决：">复制代码出现NBSP乱码解决：</h4><p>现象：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688525778810-d3623e70-93ba-442d-ac3d-927546917921.png#averageHue=%23141618&amp;clientId=uac13984f-90f3-4&amp;from=paste&amp;height=282&amp;id=u8819c1e9&amp;originHeight=352&amp;originWidth=515&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=47152&amp;status=done&amp;style=none&amp;taskId=u3db9185b-8b9b-4a40-ac2b-c41dd916243&amp;title=&amp;width=412" alt="image.png"><br>分析：NBSP（Non-Breaking SPace）是一个不换行的空格字符，它的 Unicode 编码是 U+00A0。有时候，当我们从其他地方复制文本到 IDEA 中，可能会出现 NBSP 字符<br>解决方法：<br>按下ctrl+shift+r打开全局替换：在全局替换中找到有问题的地方，可能直接输入\u00A0查找无法查找，这个时候可以找到有问题的内容（也就是刚刚复制过来的），选择NBSP复制后（复制后粘贴在第一个搜索框中，这个时候显示的是空格）在第二个搜索框中输入空格。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688525869991-7e4727b9-4297-412c-9bd3-fc66dcce6ae8.png#averageHue=%23628d64&amp;clientId=uac13984f-90f3-4&amp;from=paste&amp;height=711&amp;id=u9d096788&amp;originHeight=889&amp;originWidth=704&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=103409&amp;status=done&amp;style=none&amp;taskId=u33a200ee-a893-457e-b8cd-4c945c924fd&amp;title=&amp;width=563.2" alt="image.png"></p><h4 id="org-springframework-beans-factory-xml-XmlBeanDefinitionStoreException-Line-6-in-XML-document-from-class-path-resource-spring-datasource-xml-is-invalid-nested-exception-is-org-xml-sax-SAXParseException-lineNumber-6-columnNumber-62-cvc-complex-type-2-4-c-通配符的匹配很全面-但无法找到元素-‘context-property-placeholder’-的声明。">org.springframework.beans.factory.xml.XmlBeanDefinitionStoreException: Line 6 in XML document from class path resource [spring-datasource.xml] is invalid; nested exception is org.xml.sax.SAXParseException; lineNumber: 6; columnNumber: 62; cvc-complex-type.2.4.c: 通配符的匹配很全面, 但无法找到元素 ‘context:property-placeholder’ 的声明。</h4><p>原因：Spring配置文件中的xsi:schemaLocation不全，上面是差context标签的<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688547837996-e5cb89c8-82d1-4a26-9861-9ee5261fa7ec.png#averageHue=%23131317&amp;clientId=ua2de3bac-fb89-4&amp;from=paste&amp;height=119&amp;id=u5b2faab4&amp;originHeight=149&amp;originWidth=1170&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=36135&amp;status=done&amp;style=none&amp;taskId=ud3fe35d5-0254-47d1-adb9-919a77e9882&amp;title=&amp;width=936" alt="image.png"><br>解决方法：添加<a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a><br><a href="http://www.springframework.org/schema/context/spring-context.xsd">http://www.springframework.org/schema/context/spring-context.xsd</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688547915036-3729279c-19a4-4b3a-9bf8-787bdd66c6fe.png#averageHue=%23102128&amp;clientId=ua2de3bac-fb89-4&amp;from=paste&amp;height=218&amp;id=ubd390c4e&amp;originHeight=273&amp;originWidth=1088&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=51474&amp;status=done&amp;style=none&amp;taskId=ue9a6a315-d7c6-442a-9ab7-52019860091&amp;title=&amp;width=870.4" alt="image.png"></p><h4 id="编译失败-内部java编译器错误：打开设置对照下面图片">编译失败:内部java编译器错误：打开设置对照下面图片</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688988544489-1206a90e-2389-4eba-ac69-e911b209fc40.png#averageHue=%23090808&amp;clientId=ud1bacd7a-acda-4&amp;from=paste&amp;height=364&amp;id=u68d27fb0&amp;originHeight=455&amp;originWidth=1192&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=46683&amp;status=done&amp;style=none&amp;taskId=uee17bef8-9089-45af-9356-97ccc8ea041&amp;title=&amp;width=953.6" alt="image.png"></p><h4 id="ctrl点击类可以进入类内部">ctrl点击类可以进入类内部</h4><p><a href="https://blog.csdn.net/BingTaiLi/article/details/109735778">解决Maven ‘parent.relativePath‘ of POM_BingTaiLi的博客-CSDN博客</a><br><parent>标签中加上<relativePath />是用来指定父级pom文件的相对路径为空的，也就是说，不会在本地文件系统中查找父级pom文件，而是直接从本地仓库或远程仓库中查找。这样可以避免一些不必要的错误或警告，</p><h4 id="class-lombok-javac-apt-LombokProcessor-in-unnamed-module-0x7be1ce6a-cannot-access-class-com-sun-tools-javac-processing-JavacProcessingEnvironment-in-module-jdk-compiler-because-module-jdk-compiler-does-not-export-com-sun-tools-javac-processing-to-unnamed-module-0x7be1ce6a">class lombok.javac.apt.LombokProcessor (in unnamed module @0x7be1ce6a) cannot access class com.sun.tools.javac.processing.JavacProcessingEnvironment (in module jdk.compiler) because module jdk.compiler does not export com.sun.tools.javac.processing to unnamed module @0x7be1ce6a</h4><p>原因分析：lombok的版本太低了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="IDEA鼠标光标变成了白色粗条，无法正常换行">IDEA鼠标光标变成了白色粗条，无法正常换行</h4><p>原因分析：按住了insert进入覆盖模式了。再次按insert就可以变成原本的模式。</p>]]></content>
    
    
      
      
    <summary type="html"> &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h4 id=&quot;找不到mybatis文件：java-io-IOException-Could-not-find-resource-mybatis-config-xml&quot;&gt;找不到mybati</summary>
      
    
    
    
    
    <category term="bug" scheme="http://www.bojiboqi.fun/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>杂记</title>
    <link href="http://www.bojiboqi.fun/2024/02/28/%E6%9D%82%E8%AE%B0%EF%BC%9A/"/>
    <id>http://www.bojiboqi.fun/2024/02/28/%E6%9D%82%E8%AE%B0%EF%BC%9A/</id>
    <published>2024-02-28T13:02:28.579Z</published>
    <updated>2024-02-28T10:44:05.276Z</updated>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h4 id="云服务器的实例id可以修改吗？">云服务器的实例id可以修改吗？</h4><p><a href="https://help.aliyun.com/zh/ecs/user-guide/modify-the-properties-of-an-instance">实例 ID 是由系统自动生成的，无法修改。但是您可以修改实例的名称、主机名和实例描述等实例属性以提高云资源的管理效率和可读性，同时也可以提高云资源的安全性和自动化运维的支持程度。</a></p><h4 id="什么是分布式存储？">什么是分布式存储？</h4><p>分布式存储就像我们的拉货的货车（传统的集中储存），改用一节一节连接起来的火车拉货，当不能满足存储需求的时候，我们只需要添加一节一节的车厢就能满足需求了（易扩展性）。</p><h4 id="什么是流量穿透？">什么是流量穿透？</h4><p>就是中国移动，电信等国企提供的接入互联网服务时，对中小运营企业收费高，但是对非运营企业收费低。故存在套利空间（中小运营商通过利用非运营企业空余的带宽资源从而节约成本）</p><h4 id="密匙对是什么">密匙对是什么?</h4><p><strong>一、概念</strong><br>1、<strong>密钥对</strong>：在非对称加密技术中，有两种密钥，分为公钥和私钥。<br>公钥是密钥对所有者持有，<strong>公布给他人的</strong>；私钥也是密钥对所有者持有，<strong>不可公布</strong>。<br>2、<strong>密钥</strong>：指公钥或私钥。<br>3、<strong>公钥</strong>：公钥用来给数据加密，用公钥加密的数据只能使用私钥解密。<br>4、<strong>私钥</strong>：如上，用来解密公钥加密的数据。<br>总结：<strong>公钥和私钥是通过一种算法得到的一个密钥对(即一个公钥和一个私钥)，将其中的一个向外界公开，称为公钥；另一个自己保留，称为私钥。通过这种算法得到的密钥对能保证在世界范围内是唯一的。</strong><br>公钥和私钥是成对的，它们互相解密（密钥指公钥或私钥，密钥对指公钥加私钥）。<br>公钥和私钥都可以加密和解密。<br>私钥数字签名，公钥验证。</p><h4 id="通过宝塔面板出现数据库连接错误的解决方法（注意搜索不到问题的答案的时候要冷静下来思考搜索的输入，不要盲目点点搜索引擎）">通过宝塔面板出现数据库连接错误的解决方法（注意搜索不到问题的答案的时候要冷静下来思考搜索的输入，不要盲目点点搜索引擎）</h4><p><a href="https://www.bt.cn/bbs/thread-40225-1-1.html">MySQL 报 1045 错误解决方法 - Linux面板 - 宝塔面板论坛</a><br>1.通过宝塔面板查看数据库日志看看是什么原因造成的<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693650814661-d2c4920e-7035-4377-acda-109ddbdf28ce.png#averageHue=%238e8c8a&amp;clientId=u4ccb6c37-25e4-4&amp;from=paste&amp;height=546&amp;id=ud487d339&amp;originHeight=682&amp;originWidth=1020&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=134848&amp;status=done&amp;style=none&amp;taskId=ud724d708-9279-4f0e-81eb-ce79cab50a8&amp;title=&amp;width=816" alt="image.png"><br>2.浏览器搜索原因（可以添加宝塔面板字样）</p><h4 id="wordpress登录忘记了密码且无法通过邮箱找回">wordpress登录忘记了密码且无法通过邮箱找回</h4><p><a href="https://blog.csdn.net/qq_41990268/article/details/118875760">WordPress忘记密码且邮箱无法发送找回密码链接时的解决办法_wordpress忘记密码无法发送邮件_虎鲸不是鱼的博客-CSDN博客</a><br>方法1：邮箱找回：不过前提是服务器可以发送重置密码的邮件；<br>方法2：修改wordpress储存用户的数据库的密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p这里写刚查看到的root密码;</span><br><span class="line">show databases;</span><br><span class="line"> use wordpress;</span><br><span class="line">show tables;</span><br><span class="line">select * from wp_users;</span><br><span class="line">update wp_users set user_pass=md5(&quot;123456&quot;) where user_login=&#x27;admin&#x27;;</span><br><span class="line">##123456是你的Wordpress新密码，admin是管理员账号,wordpress采用的是</span><br><span class="line">md5加密，而user_pass列的内容是md5加密后的字符串</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法3：使用重置文件(也就是自己写的脚本）<br>将下面的代码另存为 reset_pw.php ，<em><strong>注意根据里面的注释修改 2-15行的相关信息</strong></em>（如果你不知道数据库的信息，可以查看你网站根目录下的 wp-config.php），然后通过FTP将 reset_pw.php 上传到网站根目录，在浏览器中访问这个文件，就会提示修改成功！<strong>使用完以后，记得删除 reset_pw.php ，以免存在安全隐患！！</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/*你的数据库服务器地址，一般保持默认*/</span><br><span class="line">$servername = &quot;localhost:3306&quot;;</span><br><span class="line">/*数据库用户名*/</span><br><span class="line">$phpMyadminUser = &quot;root&quot;;</span><br><span class="line">/*数据库密码*/</span><br><span class="line">$phpMyadminKey = &quot;yiduqiang&quot;;</span><br><span class="line">/*数据库名称*/</span><br><span class="line">$phpMyadminName = &quot;test&quot;;</span><br><span class="line">/*wordpress数据表格前缀*/</span><br><span class="line">$QZ = &quot;wp_&quot;;</span><br><span class="line">/*你要设置的wordpress新密码*/</span><br><span class="line">$NewKey = &quot;yiduqiang&quot;;</span><br><span class="line">/*你要设置新密码的用户名*/</span><br><span class="line">$wordpress_User = &quot;yiduqiang&quot;;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</span><br><span class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;wordpress密码找回工具&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">if(!mysql_connect($servername,$phpMyadminUser,$phpMyadminKey))</span><br><span class="line">&#123;</span><br><span class="line">    echo &quot;对不起，数据库链接出错。</span><br><span class="line">&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    echo &quot;数据库链接成功。</span><br><span class="line">&quot;;</span><br><span class="line">    mysql_select_db($phpMyadminName,mysql_connect($servername,$phpMyadminUser,$phpMyadminKey));</span><br><span class="line">    if (!mysql_query(&quot;update &quot;.$QZ.&quot;users set user_pass=&#x27;&quot;.md5($NewKey).&quot;&#x27; where user_login=&#x27;&quot;.$wordpress_User.&quot;&#x27;&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;对不起，修改密码失败。&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;修改密码成功。&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="知识点：">知识点：</h4><p>1.浏览器输入<a href="http://xn--ip-im8ckc280ctnmtkc921cdp0bv8m/var/www/html">http://ip地址解析通常的是/var/www/html</a> 或 /var/www文件下的index<br>2.nginx是反向代理，其中可以设置http服务,它和http服务占据的端口都是80,其中通过wordpress建立网站的时候要安装nginx，不然<a href="http://xn--ipwordpress-538rp16romu962acm1ghk2a">http://ip无法转到wordpress界面</a><br>3.mysql中的用户和密码放在mysql数据库中的user表中的<br>4.可以通过在mysql的配置文件中添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure><p>实现免密登录<br>5.更改mysql密码的步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.停止 MySQL 服务：</span><br><span class="line">sudo systemctl stop mysqld；</span><br><span class="line">2.启动 MySQL 服务，并跳过权限验证：</span><br><span class="line">sudo mysqld_safe --skip-grant-tables &amp;</span><br><span class="line">3.连接到 MySQL 服务器：</span><br><span class="line">mysql -u root</span><br><span class="line">4.在 MySQL 提示符下，切换到 mysql 数据库：</span><br><span class="line">use mysql;</span><br><span class="line">5.更新 root 用户的密码：</span><br><span class="line">update user set authentication_string=password(&#x27;新密码&#x27;) where user=&#x27;root&#x27;;</span><br><span class="line">6.刷新权限：</span><br><span class="line">flush privileges;</span><br><span class="line">7.退出 MySQL 提示符：</span><br><span class="line">exit;</span><br><span class="line">8.停止 MySQL 服务：</span><br><span class="line">sudo systemctl stop mysqld</span><br><span class="line">9.启动 MySQL 服务：</span><br><span class="line">sudo systemctl start mysqld</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>8.centos查看占用端口的进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lsof -i :80##查看占用80端口的进程</span><br></pre></td></tr></table></figure><p>通常一个端口只能被一个进程占用，但是有时候会出现多个进程占据一个端口的情况：<br>1.多个进程占据不同的ip，然后占据同样一个端口<br>2.不同用户下的进程占据同一个端口<br>9.grant all privileges on wordpress.* to ‘wpadmin’@‘localhost’ identified(识别) by ‘Edualiyun@123’;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">这是一个授予 MySQL 数据库用户权限的 SQL 语句。该语句将授予名为 &#x27;wpadmin&#x27; 的用户在名为 &#x27;wordpress&#x27; 的数据库上的所有权限，并使用密码 &#x27;Edualiyun@123&#x27; 进行身份验证。</span><br><span class="line"></span><br><span class="line">解释该语句的各个部分：</span><br><span class="line"></span><br><span class="line">GRANT ALL PRIVILEGES: 授予所有权限。</span><br><span class="line">ON wordpress.*: 应用权限到名为 &#x27;wordpress&#x27; 的数据库中的所有表。</span><br><span class="line">TO &#x27;wpadmin&#x27;@&#x27;localhost&#x27;: 授予用户 &#x27;wpadmin&#x27; 权限，并限制该用户只能从本地主机（localhost）连接。</span><br><span class="line">IDENTIFIED BY &#x27;Edualiyun@123&#x27;: 设置用户的密码为 &#x27;Edualiyun@123&#x27;。</span><br></pre></td></tr></table></figure><p>10.chown -R apache.apache /var/www/html/wordpress</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chown -R apache.apache /var/www/html/wordpress 是一个 Linux 命令，用于更改 /var/www/html/wordpress 目录及其下所有文件和子目录的所有者和所属组。</span><br><span class="line"></span><br><span class="line">解释该命令的各个部分：</span><br><span class="line"></span><br><span class="line">chown: 表示更改文件或目录的所有者和所属组。</span><br><span class="line">-R: 表示递归地修改目录及其下的所有文件和子目录。</span><br><span class="line">apache.apache: 表示将所有者设置为 apache 用户，所属组设置为 apache 组。</span><br><span class="line">/var/www/html/wordpress: 是要修改所有者和所属组的目标目录路径。</span><br></pre></td></tr></table></figure><p>11.更改用户的密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;username&#x27;@&#x27;host&#x27; IDENTIFIED BY &#x27;new_password&#x27;;</span><br><span class="line">● username&#x27;：要更改密码的用户名。</span><br><span class="line">● &#x27;host&#x27;：用户的主机名。如果要更改所有主机上的密码，可以使用 &#x27;%&#x27; 代替。</span><br><span class="line">● &#x27;new_password&#x27;：要设置的新密码。</span><br><span class="line">DENTIFIED BY 是用于指定用户的新密码的子句。当使用 ALTER USER 命令更</span><br><span class="line">改用户密码时，您可以使用 IDENTIFIED BY 子句来指定新密码。</span><br></pre></td></tr></table></figure><h4 id="如何让每次创建maven项目直接使用直接甚至的maven而不是每次去修改？">如何让每次创建maven项目直接使用直接甚至的maven而不是每次去修改？</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693670856318-9adb6278-35e9-4092-82c7-88bb3c3cc211.png#averageHue=%233c795f&amp;clientId=u8360c880-6e71-4&amp;from=paste&amp;height=690&amp;id=u019a597e&amp;originHeight=863&amp;originWidth=1329&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=177783&amp;status=done&amp;style=none&amp;taskId=uc3d99e9c-a9d7-44b0-b174-28232a0e0d1&amp;title=&amp;width=1063.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693670901031-7f8b4645-ebb4-49e3-bff9-28be4ba7f223.png#averageHue=%23070606&amp;clientId=u8360c880-6e71-4&amp;from=paste&amp;height=634&amp;id=u436f769d&amp;originHeight=793&amp;originWidth=1261&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=103388&amp;status=done&amp;style=none&amp;taskId=ub568af7d-ceca-4446-8760-4c124457c22&amp;title=&amp;width=1008.8" alt="image.png"></p><h4 id="docker-load-i-abc-tar">docker load -i abc.tar</h4><p>docker load 命令用于从一个镜像存储文件（如 .tar 文件）加载镜像到 Docker 引擎。在您提供的命令中：<br>Copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i abc.tar</span><br></pre></td></tr></table></figure><p>这个命令的作用是从名为 abc.tar 的镜像存储文件加载镜像到 Docker 引擎中。<br>-i 参数用于从标准输入（stdin）加载镜像</p><h4 id="docker-tag-guignginx-v1-0-leifengyang-guignginx-v1-0">docker tag guignginx:v1.0 leifengyang/guignginx:v1.0</h4><p>docker tag 命令用于为现有的镜像创建一个新的标签。在您提供的命令中：<br>Copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag guignginx:v1.0 leifengyang/guignginx:v1.0</span><br></pre></td></tr></table></figure><p>这个命令的作用是为已存在的 guignginx:v1.0 镜像创建一个新的标签 leifengyang/guignginx:v1.0。<br>通过执行该命令，Docker 将为镜像 guignginx:v1.0 创建一个新的标签 leifengyang/guignginx:v1.0。这个操作不会创建新的镜像副本，只是为现有镜像添加了一个新的标签。这样，您可以通过两个不同的标签来引用同一个镜像。</p><h4 id="查看redis的版本">查看redis的版本</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --version</span><br></pre></td></tr></table></figure><p>redis的命令是redis-server而不是一般的redis</p><h4 id="yum-install-centos-release-scl-scl-utils-build">yum install centos-release-scl scl-utils-build</h4><p>yum install -y devtoolset-8-toolchain<br>scl enable devtoolset-8 bash<br>这些命令用于在 CentOS 系统上安装和启用 Devtoolset-8 工具链。Devtoolset 是用于在 CentOS/RHEL 系统上使用新版本编译工具的软件集合。<br>以下是对每个命令的解释：</p><ol><li><strong>yum install centos-release-scl scl-utils-build</strong>：<br>这个命令用于安装 CentOS SCL（Software Collections）存储库和 scl-utils-build 工具包。SCL 存储库提供了一组额外的软件包，包括 Devtoolset。</li><li><strong>yum install -y devtoolset-8-toolchain</strong>：<br>这个命令用于安装 Devtoolset-8 工具链。Devtoolset-8 包含了一系列编译工具，如 GCC、G++、调试器等。通过安装这个工具链，你可以在 CentOS 系统上使用更新的编译器和工具。</li><li><strong>scl enable devtoolset-8 bash</strong>：<br>这个命令启用 Devtoolset-8 工具链，使其成为当前会话中的默认编译工具。通过执行这个命令，你将在当前终端会话中使用 Devtoolset-8 提供的编译器和工具。</li></ol><p>请注意，这些命令需要以 root 或具有管理员权限的用户来执行。在执行这些命令之前，确保你的系统已连接到互联网，并且已正确配置了软件包管理器（yum）以从正确的软件源中获取软件包。</p><h4 id="tar-zxvf-redis-6-2-1-tar-gz解读选项">tar -zxvf redis-6.2.1.tar.gz解读选项</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-6.2.1.tar.gz 是一个解压缩 tar 压缩文件的命令，其中</span><br><span class="line">包含了一些选项。下面是对每个选项的解释：</span><br><span class="line"></span><br><span class="line">-z：表示使用 gzip 压缩算法解压缩。tar 命令通常用于创建和提取 tar </span><br><span class="line">归档文件，但是压缩的归档文件通常会使用 gzip 进行压缩。这个选项告诉</span><br><span class="line">tar 命令在解压缩时使用 gzip 解压缩算法。</span><br><span class="line"></span><br><span class="line">-x：表示提取（解压缩）归档文件。这个选项告诉 tar 命令执行解压缩操作，</span><br><span class="line">将归档文件中的内容提取到文件系统中。</span><br><span class="line"></span><br><span class="line">-v：表示详细模式（verbose mode）。这个选项告诉 tar 命令在执行操作时</span><br><span class="line">显示详细的输出，以便用户可以看到正在进行的操作和提取的文件列表。</span><br><span class="line"></span><br><span class="line">-f：表示指定归档文件。这个选项后面需要指定要操作的归档文件的名称。</span><br><span class="line">在这个命令中，redis-6.2.1.tar.gz 是要解压缩的归档文件的名称。</span><br></pre></td></tr></table></figure><h4 id="make-distclean">make distclean</h4><p>用于清理并还原由 GNU Make 构建过程生成的文件和目录。它通常用于清理构建环境，以便重新开始构建过程或将项目还原到初始状态。</p><h4 id="vi命令打开的文件搜索">vi命令打开的文件搜索</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">在 Vi 编辑器中，你可以使用 / 命令来搜索打开的文件中的特定内容。以下是搜索的基本步骤：</span><br><span class="line"></span><br><span class="line">打开 Vi 编辑器：</span><br><span class="line">在终端中输入 vi 文件名，其中 文件名 是你要编辑的文件的名称。</span><br><span class="line"></span><br><span class="line">进入搜索模式：</span><br><span class="line">按下 / 键进入搜索模式。此时，你将在 Vi 编辑器的底部看到一个斜线 / 作为提示符。</span><br><span class="line"></span><br><span class="line">输入搜索内容：</span><br><span class="line">在斜线 / 后面输入你要搜索的内容，并按下回车键。Vi 将会定位到第一个匹配到的内容。</span><br><span class="line"></span><br><span class="line">查看搜索结果：</span><br><span class="line">Vi 将会高亮显示匹配到的搜索结果。按下 n 键可以跳转到下一个匹配项，按下 N 键可以跳转到上一个匹配项。</span><br><span class="line"></span><br><span class="line">退出搜索模式：</span><br><span class="line">如果你想退出搜索模式并返回正常编辑模式，按下 Esc 键。</span><br></pre></td></tr></table></figure><h4 id="阿里云非root用户无法远程登录：">阿里云非root用户无法远程登录：</h4><p><a href="https://blog.csdn.net/weixin_42041419/article/details/104774027">阿里云 root ssh远程登录 及 普通非root用户 ssh远程登录 Ubuntu1604_ecs除了root用户_哒哒哒哒哒撞的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html"> &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h4 id=&quot;云服务器的实例id可以修改吗？&quot;&gt;云服务器的实例id可以修改吗？&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://help.aliyun.com/zh/ecs/user-</summary>
      
    
    
    
    <category term="杂项" scheme="http://www.bojiboqi.fun/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="零散知识点" scheme="http://www.bojiboqi.fun/tags/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>语雀导出md文档快速部署到hexo上：</title>
    <link href="http://www.bojiboqi.fun/2024/02/28/%E8%AF%AD%E9%9B%80%E5%AF%BC%E5%87%BAmd%E6%96%87%E6%A1%A3%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2%E5%88%B0hexo%E4%B8%8A%EF%BC%9A/"/>
    <id>http://www.bojiboqi.fun/2024/02/28/%E8%AF%AD%E9%9B%80%E5%AF%BC%E5%87%BAmd%E6%96%87%E6%A1%A3%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2%E5%88%B0hexo%E4%B8%8A%EF%BC%9A/</id>
    <published>2024-02-28T13:02:28.574Z</published>
    <updated>2024-02-28T13:07:47.241Z</updated>
    
    <content type="html"><![CDATA[<p><a name="P23j7"></a></p><h2 id="br"><br /></h2><blockquote><p>处理语雀导出md文档为hexo需求的md格式：</p></blockquote><p>以前我是用语雀来写文档的！现在也是，只不过语雀导出md文档直接部署到hexo上有如下问题：</p><ul><li>导出的图片加了防盗链，部署到github上是无法访问的！</li><li>导出的文章没有分类和标签</li><li>为了好看，文章的封面设置又麻烦</li></ul><p>我抽空就写了一个python脚本!脚本的流程为：语雀导出的md到指定的文件夹中-&gt;脚本处理指定图片文件夹的内容-&gt;脚本读取并处理md文档-&gt;脚本把处理好的md文档剪切到_post文件夹中！</p><blockquote><p>py源码如下，注意更换相关文件夹的路径：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move_images</span>(<span class="params">source_folder, target_folder</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;开始处理图片文件夹：<span class="subst">&#123;source_folder&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    images = os.listdir(source_folder)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(images) == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;图片文件夹 <span class="subst">&#123;source_folder&#125;</span> 中没有图片文件。&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> image_name <span class="keyword">in</span> images:</span><br><span class="line">        image_path = os.path.join(source_folder, image_name)</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(image_path):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;正在处理图片：\033[31m<span class="subst">&#123;image_name&#125;</span>\033[0m&quot;</span>)</span><br><span class="line">            target_path = os.path.join(target_folder, image_name)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> os.path.exists(target_path):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;目标文件夹中已存在同名图片文件：<span class="subst">&#123;target_path&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;跳过当前图片。&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            shutil.move(image_path, target_path)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;已处理并移动图片：<span class="subst">&#123;target_path&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">            update_index_file(target_folder, image_name)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;图片文件夹 <span class="subst">&#123;source_folder&#125;</span> 处理完成。&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_index_file</span>(<span class="params">folder, image_name</span>):</span><br><span class="line">    index_file_path = os.path.join(folder, <span class="string">&quot;index.md&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(index_file_path):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;未找到 <span class="subst">&#123;index_file_path&#125;</span> 文件。&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(index_file_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        lines = file.readlines()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find the line number containing &#123;% gallery %&#125;</span></span><br><span class="line">    gallery_line_index = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(lines):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;&#123;% gallery %&#125;&#x27;</span> <span class="keyword">in</span> line:</span><br><span class="line">            gallery_line_index = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> gallery_line_index == -<span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;未找到 &#123;% gallery %&#125; 行，请确保在 index.md 中存在该行。&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Insert the new content after &#123;% gallery %&#125;, ensuring a newline</span></span><br><span class="line">    new_content = <span class="string">f&quot;![](<span class="subst">&#123;image_name&#125;</span>)\n&quot;</span></span><br><span class="line">    lines.insert(gallery_line_index + <span class="number">1</span>, new_content)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(index_file_path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.writelines(lines)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;已更新 <span class="subst">&#123;index_file_path&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_markdown_file</span>(<span class="params">file_path, wakawaka_images_folder</span>):</span><br><span class="line">    file_name = os.path.basename(file_path)</span><br><span class="line">    title = os.path.splitext(file_name)[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;正在处理Markdown文档：\033[31m<span class="subst">&#123;file_name&#125;</span>\033[0m&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;当前文章的categories是？&quot;</span>)</span><br><span class="line">    categories = <span class="built_in">input</span>().encode(sys.stdin.encoding).decode(sys.stdin.encoding).replace(<span class="string">&quot;，&quot;</span>, <span class="string">&quot;,&quot;</span>).split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    categories = [category.strip() <span class="keyword">for</span> category <span class="keyword">in</span> categories]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;当前文章的tags是？&quot;</span>)</span><br><span class="line">    tags = <span class="built_in">input</span>().encode(sys.stdin.encoding).decode(sys.stdin.encoding).replace(<span class="string">&quot;，&quot;</span>, <span class="string">&quot;,&quot;</span>).split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    tags = [tag.strip() <span class="keyword">for</span> tag <span class="keyword">in</span> tags]</span><br><span class="line"></span><br><span class="line">    cover_image = get_random_image(wakawaka_images_folder)</span><br><span class="line">    info = <span class="string">f&quot;---\n&quot;</span></span><br><span class="line">    info += <span class="string">f&quot;title: [<span class="subst">&#123;title&#125;</span>]\n&quot;</span></span><br><span class="line">    info += <span class="string">f&quot;categories: <span class="subst">&#123;categories&#125;</span>\n&quot;</span></span><br><span class="line">    info += <span class="string">f&quot;tags: <span class="subst">&#123;tags&#125;</span>\n&quot;</span></span><br><span class="line">    info += <span class="string">f&quot;background: url(/img/wakawaka/<span class="subst">&#123;cover_image&#125;</span>)\n&quot;</span></span><br><span class="line">    info += <span class="string">f&quot;cover:  /img/wakawaka/<span class="subst">&#123;cover_image&#125;</span>\n&quot;</span></span><br><span class="line">    info += <span class="string">f&quot;---\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r+&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        content = file.read()</span><br><span class="line">        file.seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        file.write(info + <span class="string">&quot;\n&quot;</span> + content)</span><br><span class="line"></span><br><span class="line">    html_code = <span class="string">&#x27;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;\n&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(<span class="string">&quot;\n&quot;</span> + html_code)</span><br><span class="line"></span><br><span class="line">    new_file_path = os.path.join(<span class="string">r&quot;D:\博客\hexo-blog\source\_posts&quot;</span>, file_name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(new_file_path):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;目标文件夹中已存在同名文档：<span class="subst">&#123;new_file_path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;是否覆盖原始文档？(Y/N)&quot;</span>)</span><br><span class="line">        choice = <span class="built_in">input</span>().strip().lower()</span><br><span class="line">        <span class="keyword">if</span> choice != <span class="string">&quot;y&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;跳过当前文档。&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    shutil.move(file_path, new_file_path)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;已处理并移动文件：<span class="subst">&#123;new_file_path&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_random_image</span>(<span class="params">folder</span>):</span><br><span class="line">    images = os.listdir(folder)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(images) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> random.choice(images)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    drafts_folder = <span class="string">r&quot;D:\博客\hexo-blog\source\_drafts&quot;</span></span><br><span class="line">    posts_folder = <span class="string">r&quot;D:\博客\hexo-blog\source\_posts&quot;</span></span><br><span class="line">    wakawaka_images_folder = <span class="string">r&quot;D:\博客\img\wakawaka&quot;</span></span><br><span class="line">    nsfw_images_folder = <span class="string">r&quot;D:\博客\img\NSFW&quot;</span></span><br><span class="line">    wakawaka_target_folder = <span class="string">r&quot;D:\博客\hexo-blog\source\img\wakawaka&quot;</span></span><br><span class="line">    nsfw_target_folder = <span class="string">r&quot;D:\博客\hexo-blog\source\img\NSFW&quot;</span></span><br><span class="line"></span><br><span class="line">    move_images(wakawaka_images_folder, wakawaka_target_folder)</span><br><span class="line">    move_images(nsfw_images_folder, nsfw_target_folder)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        files = os.listdir(drafts_folder)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(files) == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;已处理完所有markdown文档。&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> file_name <span class="keyword">in</span> files:</span><br><span class="line">            file_path = os.path.join(drafts_folder, file_name)</span><br><span class="line">            <span class="keyword">if</span> os.path.isfile(file_path) <span class="keyword">and</span> file_name.lower().endswith(<span class="string">&quot;.md&quot;</span>):</span><br><span class="line">                process_markdown_file(file_path, wakawaka_target_folder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(os.listdir(posts_folder)) == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;已处理完所有markdown文档。&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;请切换到命令行窗口以继续处理剩余的markdown文档。&quot;</span>)</span><br><span class="line">        <span class="built_in">input</span>(<span class="string">&quot;按回车键继续...&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><blockquote><p>指定部署脚本：</p></blockquote><p>文章过多后hexo clean,hexo g,hexo d命令执行会特别费时，我也写了一个py脚本来自动执行这3个命令，并在执行完成后自动关闭命令框：</p><blockquote><p>py源码如下，注意更换相关文件夹的路径：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">execute_hexo_commands</span>():</span><br><span class="line">    <span class="comment"># 进入特定的目录</span></span><br><span class="line">    directory = <span class="string">r&#x27;D:\博客\hexo-blog&#x27;</span></span><br><span class="line">    cmd = <span class="string">f&#x27;cd /d <span class="subst">&#123;directory&#125;</span> &amp;&amp; echo hexo clean &amp;&amp; hexo clean &amp;&amp; echo hexo g &amp;&amp; hexo g &amp;&amp; echo hexo d &amp;&amp; hexo d  &amp;&amp; exit&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打开cmd并执行命令</span></span><br><span class="line">    subprocess.call([<span class="string">&#x27;start&#x27;</span>, <span class="string">&#x27;cmd&#x27;</span>, <span class="string">&#x27;/k&#x27;</span>, cmd], shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">execute_hexo_commands()</span><br></pre></td></tr></table></figure><p>上面的缺点也很明显！就是我们语雀导出的md和图片都要存放在指定的文件夹中！</p><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;P23j7&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;br&quot;&gt;&lt;br /&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;处理语雀导出md文档为hexo需求的md格式：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以前我是用语雀来写文档的！现在也是，只不过语雀导出md</summary>
      
    
    
    
    <category term="hexo" scheme="http://www.bojiboqi.fun/categories/hexo/"/>
    
    
    <category term="hexo" scheme="http://www.bojiboqi.fun/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>c#课程作业</title>
    <link href="http://www.bojiboqi.fun/2024/02/28/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%EF%BC%9A/"/>
    <id>http://www.bojiboqi.fun/2024/02/28/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%EF%BC%9A/</id>
    <published>2024-02-28T13:02:28.571Z</published>
    <updated>2024-02-28T10:44:05.229Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1>QQ项目：</h1><h4 id="C-imageList如何上传key对应的图片">C#imageList如何上传key对应的图片</h4><p>string key = “myImageKey”; // 替换为您要上传的键 Image image = imageList1.Images[key]; // 获取与键关联的图像</p><h4 id="C-实现接口的语法">C#实现接口的语法</h4><p>在 C# 中，实现接口的语法如下：</p><p>// 定义接口<br>public interface IMyInterface {<br>void MyMethod(); // 接口方法<br>}</p><p>// 实现接口<br>public class MyClass : <strong>IMyInterface</strong> {<br>public void MyMethod() {<br>// 实现接口方法的代码<br>}<br>}<br>以上代码中，我们首先定义了一个名为 IMyInterface 的接口，其中包含一个无返回值、无参数的方法 MyMethod()。</p><p>接下来，我们定义了一个名为 MyClass 的类，并使用冒号 : 后面跟随接口名称的方式来实现 IMyInterface 接口。这意味着 MyClass 类必须实现 IMyInterface 接口中定义的所有方法。</p><p>在 MyClass 类中，我们重写了 MyMethod() 方法并提供了具体的实现代码。现在，MyClass 类就可以被视为 IMyInterface 接口的实现类，可以使用 IMyInterface 类型来引用 MyClass 的实例并调用 MyMethod() 方法。</p><p>需要注意的是，接口中定义的方法必须在实现类中被重写为公共访问级别（public）的方法。此外，如果实现类没有实现接口中的所有方法，那么它必须被标记为抽象类（abstract class）或虚拟类（virtual class）。</p><p>另外，<strong>C# 中的类可以实现多个接口，只需要在类名后面使用逗号分隔多个接口名称即可。例如：</strong></p><p>**public class MyClass : IMyInterface1, IMyInterface2 **{<br>// 实现 IMyInterface1 和 IMyInterface2 接口中定义的方法<br>}</p><h4 id="item1-Tag，ListView中的item-Tag是什么？">item1.Tag，ListView中的item.Tag是什么？</h4><p>ListView 控件中的 Item 对象具有一个名为 Tag 的属性，它允许您将任意对象与该 Item 相关联。可以使用 Tag 属性存储与 Item 相关的其他数据，例如数据库记录的 ID 或其他自定义对象。<br>在 ListView 控件中，每个 Item 表示一行数据。例如，如果您正在显示一个包含员工信息的表格，那么每一行可能代表一个员工。您可以使用 Item.Tag 属性将每个 Item 与相应的员工对象关联起来，以方便在处理表格数据时进行引用和处理。<br>以下是一个示例，演示如何在 ListView 中使用 Item.Tag 属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个包含员工信息的对象 </span><br><span class="line">Employee employee = new Employee() </span><br><span class="line">&#123;     ID = 1,     Name = &quot;John Doe&quot;,     Department = &quot;Sales&quot; &#125;; </span><br><span class="line">// 创建一个新的 ListView Item，并将其与员工对象关联</span><br><span class="line">ListViewItem item = new ListViewItem(new string[] </span><br><span class="line">&#123;      employee.ID.ToString(),      employee.Name,      employee.Department  &#125;); </span><br><span class="line">item.Tag = employee; </span><br><span class="line">// 将新的 Item 添加到 ListView 中 </span><br><span class="line">listView1.Items.Add(item); </span><br><span class="line">// 处理选中的 Item 中的 Tag 属性 </span><br><span class="line">private void listView1_SelectedIndexChanged(object sender, EventArgs e) </span><br><span class="line">&#123;     </span><br><span class="line">if (listView1.SelectedItems.Count &gt; 0)</span><br><span class="line">&#123;         Employee selectedEmployee = (Employee)listView1.SelectedItems[0].Tag;     </span><br><span class="line">// 处理 selectedEmployee 对象     </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在上面的示例中，我们创建了一个 Employee 对象，然后创建了一个新的 ListViewItem 对象，并将其与 Employee 对象相关联。我们将 Employee 对象存储在 Item.Tag 属性中，以便在需要时可以轻松地访问该对象。<br>在 listView1_SelectedIndexChanged 事件处理程序中，我们检查是否选择了一个 Item，并从选定的 Item 的 Tag 属性中检索与之相关联的 Employee 对象。然后，您可以使用 selectedEmployee 对象来进行进一步的处理。<br>总之，Item.Tag 属性为 ListView 控件中的 Item 对象提供了一种方便的方法，可以将任意对象与每个 Item 相关联。</p><h4 id="C-比较器">C#比较器</h4><p>在 C# 中，可以使用比较器（comparer）来比较两个对象的相对大小或相等性。比较器通常用于对集合中的元素进行排序或搜索操作。<br>C# 中有两种类型的比较器：比较器类和委托比较器。<br>比较器类<br><strong>比较器类是实现了 IComparer 接口的类</strong>，<strong>它定义了一个 Compare 方法</strong>，用于比较两个对象的相对大小。Compare 方法返回一个整数值，表示第一个对象与第二个对象之间的关系。如果第一个对象小于第二个对象，则返回一个负数；如果第一个对象大于第二个对象，则返回一个正数；如果两个对象相等，则返回零。<br>以下是一个比较器类的示例，用于比较两个 Person 对象的年龄：<br>public class PersonAgeComparer : IComparer<Person> {     public int Compare(Person x, Person y) {         return x.Age - y.Age;     } }<br>在上面的示例中，我们定义了一个名为 PersonAgeComparer 的比较器类，它实现了 IComparer<Person> 接口，并重写了 Compare 方法。该方法比较两个 Person 对象的年龄，并返回一个整数值，表示它们之间的关系。<br>委托比较器<br>委托比较器是一个函数，它接受两个参数并返回一个整数值，表示这两个参数之间的关系。委托比较器通常使用匿名方法或 lambda 表达式来定义。<br>以下是一个使用委托比较器的示例，用于比较两个 Person 对象的姓名：<br>List<Person> people = new List<Person>(); // 添加 Person 对象到 people 列表中 people.Sort(delegate (Person x, Person y) {     return string.Compare(<a href="http://x.Name">x.Name</a>, <a href="http://y.Name">y.Name</a>); });<br>在上面的示例中，我们使用了 List<Person> 类的 Sort 方法来对 people 列表中的元素进行排序。我们传递了一个委托比较器作为参数，该比较器使用 string.Compare 方法比较两个 Person 对象的姓名，并返回一个整数值，表示它们之间的关系。<br>除了使用匿名方法，还可以使用 lambda 表达式来定义委托比较器。例如：<br>people.Sort((x, y) =&gt; string.Compare(<a href="http://x.Name">x.Name</a>, <a href="http://y.Name">y.Name</a>));<br>在上面的示例中，我们使用了一个 lambda 表达式来定义委托比较器。该表达式接受两个参数 x 和 y，并比较它们的姓名。它返回一个整数值，表示它们之间的关系。<br>总之，比较器是 C# 中一种重要的概念，用于比较两个对象的相对大小或相等性。您可以使用比较器类或委托比较器来定义比较器，并将其用于对集合中的元素进行排序或搜索操作。</p><h4 id="C-如何把动图作为某个控件的背景图片">C#如何把动图作为某个控件的背景图片</h4><p>你可以使用 PictureBox 控件来显示动态图像，并把它作为某个控件的背景图片。貌似其他控件设置动图为背景图片无法展示动图效果，picbox也是一样的，动图设置为背景图片也是不行的</p><h4 id="C-如何修改Form">C#如何修改Form</h4><p>在 C# 中，可以使用 Form 类来创建和修改窗体（Form）。以下是修改窗体的一些常见操作：</p><ol><li>修改窗体标题：可以使用 Text 属性来设置窗体标题。例如：</li></ol><p>this.Text = “My Form Title”;</p><ol><li>修改窗体大小和位置：可以使用 Size 和 Location 属性来设置窗体大小和位置。例如：</li></ol><p>this.Size = new Size(800, 600); this.Location = new Point(100, 100);</p><ol><li>修改窗体背景颜色：可以使用 BackColor 属性来设置窗体的背景颜色。例如：</li></ol><p>this.BackColor = Color.LightBlue;</p><ol><li>添加控件到窗体中：可以使用 Controls 属性来添加控件到窗体中。例如，假设你要添加一个按钮控件到窗体中：</li></ol><p>Button myButton = new Button(); myButton.Text = “Click Me”; myButton.Location = new Point(10, 10); this.Controls.Add(myButton);</p><ol><li>修改窗体样式和行为：可以使用 FormBorderStyle 和 WindowState 属性来设置窗体的样式和行为。例如，如果你想要设置窗体为无边框窗体并最大化显示：</li></ol><p>this.FormBorderStyle = FormBorderStyle.None; this.WindowState = FormWindowState.Maximized;<br>以上仅是一些常见的窗体修改操作，你可以根据需要使用 Form 类的其他属性和方法来进行更多的窗体修改操作。</p><h4 id="C-背景图片颜色的transparent">C#背景图片颜色的transparent</h4><p>当设置控件的 BackColor 属性为 Color.Transparent 时，<strong>控件的透明背景颜色将会显示父容器的背景图片或颜色</strong>，或者<strong>如果父容器也是透明背景色，则会显示其祖先容器的背景色，一直到有非透明背景色的容器为止。</strong></p><h4 id="C-窗体如何隐藏边框">C#窗体如何隐藏边框</h4><p>在 C# 中，可以通过设置窗体的 FormBorderStyle 属性来隐藏窗体的边框。具体来说，可以将 FormBorderStyle 属性设置为 None 来隐藏窗体的边框。<br>注意：当窗体的边框被隐藏时，窗体将无法通过拖动边框来改变大小和位置。因此，你需要通过其他方式来控制窗体的大小和位置，例如在代码中设置窗体的 Size 和 Location 属性。</p><h4 id="c-点击图片关闭窗口实现">c#点击图片关闭窗口实现</h4><p>private void pictureBox1_Click(object sender, EventArgs e) {     this.Close(); }</p><h4 id="C-点击图片最小化">C#点击图片最小化</h4><p>private void pictureBox1_Click(object sender, EventArgs e) {     this.WindowState = FormWindowState.Minimized; }<br>我们将窗体的 WindowState 属性设置为 FormWindowState.Minimized，以实现最小化窗口的操作。</p><h4 id="panel如何表现为一条线">panel如何表现为一条线</h4><p>如果您想让 Panel 控件在界面上表现为一条线，可以按照以下步骤进行设置：</p><ol><li>在窗体上添加一个 Panel 控件，并设置其 Dock 属性为 Top 或 Bottom。这将使 Panel 控件沿着窗体的顶部或底部固定，占据整个窗体的宽度。</li><li>设置 Panel 控件的高度为您想要的线条粗细。例如，如果您想要一条高度为 2 像素的线条，可以将 Panel 控件的高度设置为 2 像素。</li><li>将 Panel 控件的背景色设置为您想要的线条颜色。例如，如果您想要一条黑色的线条，可以将 Panel 控件的背景色设置为黑色。</li><li>确保将 Panel 控件的边框样式（BorderStyle）设置为 None，以避免显示不必要的边框。</li></ol><p>如果您想要更细的线条，可以将 Panel 控件的高度设置为 1 像素，并在其上方或下方添加一个与窗体背景色相同的 Panel 控件，以使线条看起来更细。</p><h4 id="文本框如何让输入的密码显示为圆点">文本框如何让输入的密码显示为圆点</h4><p>您可以通过将文本框控件的 UseSystemPasswordChar 属性设置为 true，来让输入的密码显示为圆点。<br>以下是一个示例代码：<br>textBox1.UseSystemPasswordChar = true;<br>在这个示例代码中，我们将 textBox1 控件的 UseSystemPasswordChar 属性设置为 true，这样输入的密码就会显示为圆点。</p><h4 id="C-为什么启动后的文本框里面的默认值是蓝色">C#为什么启动后的文本框里面的默认值是蓝色</h4><p>您可以通过将文本框控件的 Select 方法应用于其他控件来解决文本框控件默认值显示为蓝色的问题。这将取消文本框控件的选中状态，从而避免默认背景颜色的出现。<br>以下是一个示例代码：<br>private void Form1_Load(object sender, EventArgs e) {     // 在窗体加载时将焦点设置到另一个控件上     button1.Focus();     // 使用 Select 方法取消文本框的选中状态     textBox1.Select(0, 0); }</p><h4 id="MouseEnter事件">MouseEnter事件</h4><p>MouseEnter 事件是 C# 中的一个事件，用于在鼠标进入控件时触发。当鼠标指针进入控件的可见区域时，MouseEnter 事件会被触发一次。</p><h4 id="MouseLeave">MouseLeave</h4><p>MouseLeave 事件是 C# 中的一个事件，用于在鼠标离开控件时触发。当鼠标指针离开控件的可见区域时，MouseLeave 事件会被触发一次。</p><h4 id="MouseHover">MouseHover</h4><p>MouseHover 事件是 C# 中的一个事件，用于在鼠标在控件上悬停时触发。当鼠标指针在控件的可见区域内停留一段时间时，MouseHover 事件会被触发一次。</p><h4 id="MousrMove">MousrMove</h4><p>MouseMove 事件是 C# 中的一个事件，用于在鼠标在控件内移动时触发。当鼠标指针在控件的可见区域内移动时，MouseMove 事件会被触发多次。</p><h4 id="如何把文本框的信息储存在JSON文件当中？">如何把文本框的信息储存在JSON文件当中？</h4><p>要将文本框的信息储存在 JSON 文件中，可以使用 .NET 中的 Newtonsoft.Json 库来实现。该库提供了一组 API，用于将对象序列化为 JSON 格式的字符串，并将 JSON 格式的字符串反序列化为对象。<br>以下是一个示例代码，演示如何将文本框的信息储存在 JSON 文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">using Newtonsoft.Json; using System.IO; </span><br><span class="line">// 定义一个类，用于储存文本框的信息 </span><br><span class="line">public class TextBoxInfo</span><br><span class="line">&#123;     public string Text &#123; get; set; &#125; &#125; </span><br><span class="line">// 在保存按钮的 Click 事件中执行以下代码</span><br><span class="line">private void btnSave_Click(object sender, EventArgs e)</span><br><span class="line">&#123;    </span><br><span class="line">// 创建一个 TextBoxInfo 对象，储存文本框的信息 </span><br><span class="line">TextBoxInfo textBoxInfo = new TextBoxInfo &#123; Text = textBox1.Text </span><br><span class="line">&#125;;    </span><br><span class="line">// 将 TextBoxInfo 对象序列化为 JSON 格式的字符串     </span><br><span class="line">string jsonString = JsonConvert.SerializeObject(textBoxInfo);    </span><br><span class="line">// 将 JSON 格式的字符串写入文件中     </span><br><span class="line">string filePath = &quot;textBoxInfo.json&quot;;    </span><br><span class="line">File.WriteAllText(filePath, jsonString); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在上述代码中，定义了一个 TextBoxInfo 类，用于储存文本框的信息。在保存按钮的 Click 事件中，创建了一个 TextBoxInfo 对象，储存了文本框的信息。然后，使用 JsonConvert.SerializeObject 方法将 TextBoxInfo 对象序列化为 JSON 格式的字符串，并使用 File.WriteAllText 方法将 JSON 格式的字符串写入文件中。<br>要从 JSON 文件中读取文本框的信息，可以执行以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 在窗口加载时执行以下代码 </span><br><span class="line">private void Form1_Load(object sender, EventArgs e) </span><br><span class="line">&#123;    </span><br><span class="line">// 从文件中读取 JSON 格式的字符串 </span><br><span class="line">string filePath = &quot;textBoxInfo.json&quot;;  </span><br><span class="line">string jsonString = File.ReadAllText(filePath);   </span><br><span class="line">// 将 JSON 格式的字符串反序列化为 TextBoxInfo 对象   </span><br><span class="line">TextBoxInfo textBoxInfo = JsonConvert.DeserializeObject&lt;TextBoxInfo&gt;(jsonString);  </span><br><span class="line">// 将 TextBoxInfo 对象中的信息显示在文本框中     </span><br><span class="line">textBox1.Text = textBoxInfo.Text; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在上述代码中，使用 File.ReadAllText 方法从文件中读取 JSON 格式的字符串。然后，使用 JsonConvert.DeserializeObject 方法将 JSON 格式的字符串反序列化为 TextBoxInfo 对象，并将 TextBoxInfo 对象中的信息显示在文本框中。</p><h4 id="timer控件">timer控件</h4><p>Timer 控件是 C# 中的一个计时器控件，**用于在指定的时间间隔内周期性地触发事件。**Timer 控件可以用于实现各种计时功能，例如定期更新界面、执行后台任务等。设置Enable启动timer控件，然后间断着执行timer控件中的代码</p><h4 id="C-当中的sln文件是什么？">C#当中的sln文件是什么？</h4><p>在 C# 中，.<strong>sln 文件是一个解决方案文件，用于组织和管理一个或多个项目。.sln 文件是 Visual Studio 的一部分，它包含了该解决方案中的所有项目、引用以及其他相关文件。</strong><br>每个 C# 项目都包含一个 .csproj 文件，它定义了项目的结构和内容。但是，当您需要同时管理多个项目时，.sln 文件就变得非常有用。.sln 文件实际上是一个 XML 文件，其中包含有关解决方案的信息，例如项目列表、构建配置等。<br>在 Visual Studio 中，您可以使用“新建项目”向导来创建新的项目。创建项目时，Visual Studio 会自动生成一个 .sln 文件。您可以在“解决方案资源管理器”中查看 .sln 文件，它位于解决方案的顶级目录中。<br>使用 .sln 文件的好处是可以方便地管理多个项目。如果您需要添加、删除或重命名项目，只需编辑 .sln 文件即可。.sln 文件还可以包含预定义的构建配置，例如“Debug”和“Release”，这样您就可以轻松地在不同的环境中构建应用程序。<br>总之，.sln 文件是 Visual Studio 中用于管理多个项目的解决方案文件。它包含有关解决方案的信息，例如项目列表、构建配置等。使用 .sln 文件可以方便地组织和管理项目，从而提高开发效率。</p><h4 id="C-如何实现点击一个label跳转到一个网页">C#如何实现点击一个label跳转到一个网页</h4><p>您可以使用C#中的Label控件的Click事件来实现这个功能。在Click事件处理程序中，您可以使用System.Diagnostics命名空间中的Process对象来打开网页。<br>以下是一个简单的示例代码：<br>private void label1_Click(object sender, EventArgs e) {     System.Diagnostics.Process.Start(“<a href="https://www.example.com/">https://www.example.com/</a>”); }</p><h1>酷我音乐盒：</h1><p>1.C#下如果想打开一个项目并窗口化编辑选择项目中的.sln文件</p><h4 id="C-如何设置窗口可以自动调整大小">C#如何设置窗口可以自动调整大小</h4><p>在 C# 中，您可以通过设置窗体的 AutoSize、AutoSizeMode 和 MinimumSize 属性来实现窗口自动调整大小的功能。</p><ol><li>AutoSize 属性：此属性指示窗体是否根据其内容自动调整大小。将其设置为 true 可以启用自动调整大小功能。默认情况下，AutoSize 属性为 false。</li><li>AutoSizeMode 属性：此属性指定窗体自动调整大小的方式。可以将其设置为以下值之一：<ul><li>GrowOnly：窗体仅在其内容增加时才会增加大小。</li><li>None：窗体不会自动调整大小。</li><li>GrowAndShrink：窗体可以根据其内容增加或减小大小。</li></ul></li><li>MinimumSize 属性：此属性指定窗体的最小大小。如果窗体的大小小于此值，则窗体将自动调整大小以适应其内容。</li></ol><h4 id="C-Substring">C#Substring</h4><p>Substring 方法用于从字符串中提取部分子字符串。该方法有多个重载形式，可以根据需要提取子字符串。<br>以下是 Substring 方法的几种常见用法：</p><ol><li>Substring(int startIndex)：从指定的开始位置 startIndex 提取子字符串。子字符串包括 startIndex 和之后的所有字符。</li></ol><p>string str = “Hello world”; string subStr = str.Substring(6); // subStr = “world”</p><ol><li>Substring(int startIndex, int length)：从指定的开始位置 startIndex 提取长度为 length 的子字符串。</li></ol><p>string str = “Hello world”; string subStr = str.Substring(0, 5); // subStr = “Hello”</p><ol><li>Substring(int startIndex, int endIndex - startIndex)：从指定的开始位置 startIndex 提取到指定的结束位置 endIndex（不包括 endIndex）的子字符串。</li></ol><p>string str = “Hello world”; string subStr = str.Substring(6, 5); // subStr = “world”<br>需要注意的是，如果 startIndex 或 endIndex 超出了字符串的范围，则会引发 ArgumentOutOfRangeException 异常。<br>另外，Substring 方法返回的是一个新的字符串对象，原始字符串不会受到影响。如果需要修改原始字符串，可以使用 StringBuilder 类。<br>string str = “Hello world”; string subStr = str.Substring(6); // subStr = “world” StringBuilder sb = new StringBuilder(str); sb.Remove(0, 6); // 移除 &quot;Hello &quot; string modifiedStr = sb.ToString(); // modifiedStr = “world”</p><h4 id="axWindowsMediaPlayer-Ctlcontrols-currentPositionString">axWindowsMediaPlayer.Ctlcontrols.currentPositionString</h4><p>axWindowsMediaPlayer.Ctlcontrols.currentPositionString 是在使用 AxWindowsMediaPlayer 控件时，用于获取当前媒体播放位置的字符串表示形式的属性。<br>AxWindowsMediaPlayer 控件可以用于在 Windows 窗体应用程序中播放音频和视频文件。该控件有一个名为 Ctlcontrols 的属性，该属性返回一个 WMPLib.IWMPControls 接口的实例，可用于控制媒体的播放、暂停、停止等操作。<br>currentPositionString 属性是 WMPLib.IWMPControls 接口的一个成员，用于获取当前媒体播放位置的字符串表示形式。该属性返回一个格式为 mm:ss 的字符串，其中 mm 表示分钟数，ss 表示秒数。</p><h4 id="axWindowsMediaPlayer-currentMedia-durationString">axWindowsMediaPlayer.currentMedia.durationString</h4><p>axWindowsMediaPlayer.currentMedia.durationString 是在使用 AxWindowsMediaPlayer 控件时，用于获取当前媒体总时长的字符串表示形式的属性。<br>AxWindowsMediaPlayer 控件可以用于在 Windows 窗体应用程序中播放音频和视频文件。该控件有一个名为 currentMedia 的属性，该属性返回一个 WMPLib.IWMPMedia 接口的实例，可用于获取当前媒体的信息，如标题、作者、时长等。<br>durationString 属性是 WMPLib.IWMPMedia 接口的一个成员，用于获取当前媒体总时长的字符串表示形式。该属性返回一个格式为 hh:mm:ss 的字符串，其中 hh 表示小时数，mm 表示分钟数，ss 表示秒</p><h4 id="axWindowsMediaPlayer-URL-“song”-songName-currentSong-“-mp3”-这句-是什么">axWindowsMediaPlayer.URL = @“song” + songName[currentSong] + “.mp3”;这句@是什么</h4><h4 id="在这句代码中，-符号是C-语言中的字符串字面量前缀符号，它告诉编译器将紧随其后的字符串视为字面量，而不需要进行转义。在这个例子中，字符串字面量是-“song”-songName-currentSong-“-mp3”，它表示一个包含歌曲名称的字符串，用于指定Windows-Media-Player控件播放的音频文件。">在这句代码中，@符号是C#语言中的字符串字面量前缀符号，它告诉编译器将紧随其后的字符串视为字面量，而不需要进行转义。在这个例子中，字符串字面量是@“song” + songName[currentSong] + “.mp3”，它表示一个包含歌曲名称的字符串，用于指定Windows Media Player控件播放的音频文件。</h4><h1>ppt模仿</h1><h4 id="Graphics-g-pictureBoxCanvas-CreateGraphics-解读这个">Graphics g = pictureBoxCanvas.CreateGraphics();解读这个</h4><p>这段代码的含义是创建了一个Graphics对象g，并将其绑定到PictureBox控件pictureBoxCanvas上的绘图表面上。<br>具体来说，CreateGraphics()是PictureBox控件的一个方法，用于创建一个Graphics对象，该对象可以用于在PictureBox控件上绘制图形。在这个例子中，通过调用CreateGraphics()方法，创建了一个与pictureBoxCanvas控件关联的Graphics对象g。<br>在绘制图形时，需要使用该Graphics对象g来进行绘制操作。例如，可以使用g.DrawRectangle()方法绘制一个矩形，或使用g.DrawEllipse()方法绘制一个椭圆，等等。<br>需要注意的是，使用CreateGraphics()方法创建的Graphics对象只在当前窗体重绘时有效，即在窗体重绘后，所有绘制的图形都会被清空。如果需要将绘制的图形保留，可以在创建Graphics对象时，将其与一个Bitmap对象关联。这样，在绘制图形时，先将图形绘制到Bitmap对象上，然后再将Bitmap对象绘制到PictureBox控件上，就可以保留绘制的图形了。<br>g.DrawBezier(pen, curvePoints[0], curvePoints[1], curvePoints[2], curvePoints[3]);解读这个命令<br>这段代码的含义是使用指定的画笔pen，在PictureBox控件上绘制一条Bezier曲线，曲线的控制点分别为curvePoints[0]、curvePoints[1]、curvePoints[2]、curvePoints[3]。<br>具体来说，DrawBezier()是Graphics对象g的一个方法，用于绘制Bezier曲线。该方法需要传入以下参数：</p><ul><li>pen：一个Pen对象，用于指定绘制的画笔。</li><li>curvePoints[0]：Bezier曲线的起始点。</li><li>curvePoints[1]：Bezier曲线的第一个控制点。</li><li>curvePoints[2]：Bezier曲线的第二个控制点。</li><li>curvePoints[3]：Bezier曲线的终止点。</li></ul><p>这些参数都是必须的，否则会出现编译错误。<br>需要注意的是，Bezier曲线是一种二次或三次曲线，其形状由控制点决定。在绘制Bezier曲线时，需要指定控制点的位置，以确定曲线的形状。在这个例子中，curvePoints数组保存了四个控制点的位置，用于绘制一条Bezier曲线。<br>另外，需要确保Graphics对象g与PictureBox控件pictureBoxCanvas关联，否则无法在控件上绘制图形。可以使用pictureBoxCanvas.CreateGraphics()方法创建一个Graphics对象，并将其与PictureBox控件关联。<br>Bezier曲线是什么<br>Bezier曲线是一种数学上的曲线，由法国工程师Pierre Bézier在20世纪50年代发明。它是一种插值曲线，用于平滑地连接多个控制点。<br>Bezier曲线通常被用于计算机图形学中的图形设计和绘制，因为它们可以通过少量的控制点创建平滑的曲线。它们也被广泛用于计算机辅助设计（CAD）、计算机动画和计算机游戏中。<br>在二维空间中，Bezier曲线通常由四个点组成，分别称为起始点、终止点和两个控制点。这些点的位置决定了曲线的形状和方向。Bezier曲线可以是二次曲线或三次曲线，具体取决于控制点的数量。<br>Bezier曲线的优点是可以通过少量的控制点来创建平滑的曲线，同时它们也比其他类型的曲线更容易在计算机上计算和绘制。此外，Bezier曲线还可以通过插值来进行曲线的平滑处理，使得曲线更加自然和平滑。<br>g.Dispose();解读这个命令<br>这段代码的含义是释放Graphics对象g占用的资源，并将其销毁。<br>具体来说，Dispose()是Graphics对象g的一个方法，用于释放该对象占用的资源，包括绑定的所有GDI+对象（如画笔、画刷等）。该方法在使用完Graphics对象后，应该及时调用，以避免资源泄漏和性能问题。<br>在这个例子中，使用Dispose()方法释放了Graphics对象g所占用的所有资源。需要注意的是，释放Graphics对象后，就不能再使用它来绘制图像，否则会抛出异常。<br><a href="http://xn--3ds.NET">在.NET</a> Framework中，许多类型都实现了IDisposable接口，包括Graphics对象、文件流、网络连接等等。这些类型在使用完毕后，应该及时调用Dispose()方法来释放占用的资源，以避免程序运行过程中出现资源泄漏和性能问题。另外，可以使用using语句来自动释放实现IDisposable接口的对象，以简化代码和提高可读性。</p><h4 id="pictureBoxCanvas-Image-Save-saveFileDialog-FileName-解读这个">pictureBoxCanvas.Image.Save(saveFileDialog.FileName);解读这个</h4><p>这段代码的含义是将PictureBox控件pictureBoxCanvas上显示的图像保存到指定的文件中。<br>具体来说，pictureBoxCanvas是一个PictureBox控件，它可以用来显示图像。在这个例子中，pictureBoxCanvas上显示了一个图像，并且用户选择了一个保存文件对话框saveFileDialog，用于指定保存的文件名和文件路径。<br>Image是PictureBox控件的一个属性，用于获取或设置PictureBox控件上显示的图像。在这个例子中，使用pictureBoxCanvas.Image获取PictureBox控件上显示的图像。<br>Image对象具有Save()方法，该方法可以将图像保存到指定的文件中。在这个例子中，使用pictureBoxCanvas.Image.Save()方法将PictureBox控件上显示的图像保存到用户指定的文件中，文件名和路径由saveFileDialog.FileName属性指定。<br>需要注意的是，如果PictureBox控件上没有显示任何图像，或者PictureBox控件的Image属性为null，则会抛出NullReferenceException异常。另外，如果指定的文件已经存在，Save()方法会覆盖原来的文件，因此需要谨慎使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void comboBoxColor_SelectedIndexChanged(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">switch (comboBoxColor.SelectedIndex)</span><br><span class="line">&#123;</span><br><span class="line">case 0:</span><br><span class="line">currentColor = Color.Black;</span><br><span class="line">break;</span><br><span class="line">case 1:</span><br><span class="line">currentColor = Color.Red;</span><br><span class="line">break;</span><br><span class="line">case 2:</span><br><span class="line">currentColor = Color.Blue;</span><br><span class="line">break;</span><br><span class="line">case 3:</span><br><span class="line">currentColor = Color.Green;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个事件处理方法，用于响应ComboBox控件comboBoxColor的SelectedIndexChanged事件。当用户选择ComboBox中的某一项时，就会触发该事件，从而执行该方法。<br>具体来说，该方法的作用是根据用户选择的颜色，更新currentColor变量的值。currentColor是一个Color类型的变量，用于指定当前画笔的颜色。在该方法中，根据用户选择的颜色，将currentColor变量更新为相应的颜色值。<br>使用switch语句，根据comboBoxColor控件中选中的项的索引值，判断用户选择的颜色。如果用户选择了黑色，则将currentColor设置为Color.Black；如果用户选择了红色，则将currentColor设置为Color.Red；如果用户选择了蓝色，则将currentColor设置为Color.Blue；如果用户选择了绿色，则将currentColor设置为Color.Green。如果用户选择的是其他颜色，则不做任何操作。<br>需要注意的是，comboBoxColor控件中各项的索引值从0开始计数。因此，第一项的索引值为0，第二项的索引值为1，依此类推。<br>在完成currentColor的更新后，该方法的执行就结束了。currentColor的值会在后续的绘图操作中被使用，以指定当前画笔的颜色。ComboBox控件中各项的索引值是从0开始计数的整数，表示该项在ComboBox中的位置。例如，ComboBox中第一项的索引值为0，第二项的索引值为1，依此类推。<br>在ComboBox的数据源中，每个项都有一个关联的索引值。当用户选择ComboBox中的某一项时，就会触发SelectedIndexChanged事件，并将所选项的索引值传递给相关的事件处理方法。<br>在事件处理方法中，可以使用Switch语句或其他条件语句根据索引值来判断用户选择了哪个项，并执行相应的操作。<br>需要注意的是，在设置ComboBox中的数据源时，可以为每个项指定一个显示文本和一个值（Value）。在这种情况下，所选项的值可以通过ComboBox控件的SelectedValue属性来获取，而不是使用索引值。<br><a href="https://blog.csdn.net/qq_29406323/article/details/86488248">C# ComboBox 下拉选项框_c#中下拉框添加选项_渐进的冰山的博客-CSDN博客</a></p><h4 id="ComboBox如何添加数据源">ComboBox如何添加数据源</h4><p>可以通过以下步骤向ComboBox控件添加数据源：</p><ol><li>在设计模式下，在Visual Studio的工具箱中选择ComboBox控件，将其拖放到窗体中。</li><li>选中ComboBox控件，打开其属性窗口。</li><li>在属性窗口中，找到DataSource属性，将其设置为要作为数据源的对象。可以选择一个数据表、数组、集合等。</li><li>在属性窗口中，找到DisplayMember属性，将其设置为要在ComboBox中显示的值的属性名。例如，如果数据源是一个包含&quot;姓名&quot;和&quot;年龄&quot;两列的表格，而你想在ComboBox中显示&quot;姓名&quot;列的值，那么应该将DisplayMember属性设置为&quot;姓名&quot;。</li><li>可选的步骤：如果要在ComboBox中显示的值不是数据源中的某个属性，而是根据数据源动态生成的值，可以使用ComboBox控件的DataBindings属性来绑定一个方法或表达式，以生成所需的值。</li><li>运行程序，ComboBox控件就会显示来自数据源的值了。</li></ol><p>需要注意的是，如果数据源是一个集合或数组，ComboBox控件会自动将其元素添加为ComboBox的项。但是，如果数据源是一个数据表，则需要手动向ComboBox中添加项。可以使用ComboBox控件的Items属性，通过代码向ComboBox中添加项。例如：<br>comboBox1.Items.Clear(); //先清空原来的项 foreach (DataRow row in dataTable.Rows) {     comboBox1.Items.Add(row[“Name”].ToString()); //向ComboBox中添加项 }<br>在上面的示例中，dataTable是一个数据表，包含&quot;Name&quot;和&quot;Age&quot;两列。使用foreach语句遍历表中的每一行，将&quot;Name&quot;列的值添加到ComboBox控件中。</p><h4 id="C-如何将一个数组添加为ComBox控件的下拉选项">C#如何将一个数组添加为ComBox控件的下拉选项</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public partial class Form1 : Form</span><br><span class="line">&#123;</span><br><span class="line">    public Form1()</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">        //数据源为一个string数组</span><br><span class="line">        string [] colors =</span><br><span class="line">            new[]&#123; &quot;Black&quot;, &quot;Red&quot;, &quot;Blue&quot;, </span><br><span class="line">                   &quot;Green&quot; &#125;;</span><br><span class="line"> </span><br><span class="line">         // 初始化cmb,注意这里的comboBoxColor是已经存在于Form中的</span><br><span class="line">        </span><br><span class="line">         comboBoxColor.DataSource = colors;</span><br><span class="line">//下面这部不能少</span><br><span class="line">         comboBoxColor.DropDownStyle = ComboBoxStyle.DropDownList;</span><br><span class="line"> //</span><br><span class="line">         // 添加cmb到Form中</span><br><span class="line">         this.Controls.Add(comboBoxColor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pictureBox1-Invalidate解读这个方法">pictureBox1.Invalidate解读这个方法</h4><p>Invalidate() 方法是 Control 类的一个成员，它用于使控件的整个区域无效，从而要求窗体系统重新绘制该控件。在 PictureBox 控件中，Invalidate() 方法可以用于更新控件的绘图表面，以便显示新的绘制内容。<br>当 Invalidate() 方法被调用时，它会引发 Paint 事件，从而通知窗体系统重新绘制控件。在 PictureBox 控件中，Paint 事件通常用于在控件上绘制图形或图像。如果控件的 Paint 事件处理程序中修改了控件的绘图表面，那么需要调用 Invalidate() 方法来通知窗体系统重新绘制控件，以便更新显示内容。<br>在上面的示例中，当鼠标移动或松开时，控件的绘图表面需要更新，以便显示矩形轮廓。因此，在 MouseMove 和 MouseUp 事件处理程序中，我们调用了 Invalidate() 方法来刷新控件的绘图表面。然后，在 Paint 事件处理程序中，我们根据当前的绘制状态绘制矩形轮廓。这样，每当控件的绘图表面需要更新时，都会引发 Paint 事件，从而调用 Paint 事件处理程序来重新绘制控件。</p><h4 id="C-如何清除picbox上面的绘画">C#如何清除picbox上面的绘画</h4><p>您可以使用 PictureBox 的 Invalidate 方法来清除其上的绘图。Invalidate 方法将触发 PictureBox 的 Paint 事件，从而使 PictureBox 重新绘制其内容。<br>以下是一个简单的示例代码，演示如何使用 Invalidate 方法清除 PictureBox 上的绘图：<br>// 清除 PictureBox 上的绘画 pictureBox1.Invalidate();<br>如果您想要清除 PictureBox 上的所有绘图，您可以在 Paint 事件中使用 Graphics 对象的 Clear 方法来实现。以下是一个示例代码：<br>private void pictureBox1_Paint(object sender, PaintEventArgs e) {     // 清除 PictureBox 上的绘画     e.Graphics.Clear(Color.White); }<br>在这个示例中，我们将 PictureBox 的 Paint 事件与一个名为 pictureBox1_Paint 的方法关联。在该方法中，我们使用 Graphics 对象的 Clear 方法来清除 PictureBox 上的所有绘图。当 PictureBox 的 Invalidate 方法被调用时，Paint 事件将被触发，从而导致 pictureBox1_Paint 方法被调用，清除 PictureBox 上的所有绘图。</p><h1>图片处理：</h1><h4 id="灰白化原理：">灰白化原理：</h4><p>图片灰白化处理是一种常见的图像处理方法，它将彩色图像转换为灰度图像，使图像失去颜色信息，只保留亮度信息。其原理是利用 RGB 颜色模型中的亮度公式，将每个像素点的 RGB 值转化为相同的灰度值，从而使图像呈现出黑白灰度的效果。<br>RGB 颜色模型中的亮度公式如下：<br>L = 0.299R + 0.587G + 0.114B<br>其中，L 表示亮度值，R、G、B 分别表示红、绿、蓝三个颜色通道的值。在灰白化处理中，将每个像素点的 R、G、B 值分别代入上述公式，得到一个灰度值，然后将这个灰度值赋给该像素点的 R、G、B 三个通道，即可实现灰白化处理。<br>例如，对于一个 RGB 值为 (100, 150, 200) 的像素点，根据亮度公式计算得到的灰度值为：<br>L = 0.299 × 100 + 0.587 × 150 + 0.114 × 200 ≈ 147<br>然后将这个灰度值赋给该像素点的 R、G、B 三个通道，即可得到灰度值为 147 的灰白化像素点。<br>灰白化处理可以去除图像中的颜色信息，突出图像的亮度信息，适用于一些只需分析亮度信息的图像处理任务，如图像边缘检测、图像识别等。灰白化处理也是一些图像处理算法的前置处理步骤，如二值化、图像增强等。</p><h4 id="C-浮雕化原理">C#浮雕化原理</h4><p>浮雕化是一种图像处理技术，基本原理是将图片中像素的点与相邻点的RGB值进行相减，然后加上128，得到中间值灰色。因为相邻点基本上都是RGB比较相似的，所以相似的点的处理结果基本上临近128，而不相近颜色的值则偏离128较远，所以可以得到一个类似于浮雕的图像。</p><h4 id="马赛克化原理：">马赛克化原理：</h4><p>图片处理马赛克化原理<br>马赛克化是一种图像处理技术，基本原理是将图片中的像素点分块，然后用同一颜色代替这个块中的所有像素点，从而达到模糊化的效果。马赛克化的实现原理是把图像上某个像素点一定范围邻域内的所有点用邻域内左上像素点的颜色代替，这样可以模糊细节，但是可以保留大体的轮廓</p><h1>girl</h1><h4 id="为什么程序刚运行的时候effect的默认值是None">为什么程序刚运行的时候effect的默认值是None</h4><p>在 C# 中，枚举类型的默认值是第一个成员的值，因此在该程序中，Effect 枚举类型的默认值是 None。</p><h4 id="负数取余">负数取余</h4><p>对于两个整数 a 和 b，可以使用 % 运算符对它们进行取模运算，即 a % b。当 a 和 b 都是正整数时，取模运算的结果是 a 除以 b 的余数。<br>如果 a 或 b 中存在负数，那么取模运算的结果会和不同的编程语言和算法实现有关。在 C# 中，取模运算的结果与 a 的符号相同，即：</p><ul><li>当 a 和 b 都是正整数时，结果为 a 对 b 取余的结果。</li><li>当 a 是负整数时，结果为 a 对 b 取余的结果减去 b 的绝对值。</li><li>当 b 是负整数时，结果为 a 对 b 取余的结果加上 b 的绝对值。</li><li>当 a 和 b 都是负整数时，结果为 a 对 b 取余的结果减去 b 的绝对值。</li></ul><p>下面是一些示例：<br>int a = 7, b = 3; int result1 = a % b;   // 结果为 1 a = -7; b = 3; int result2 = a % b;   // 结果为 -1 a = 7; b = -3; int result3 = a % b;   // 结果为 1 a = -7; b = -3; int result4 = a % b;   // 结果为 -1<br>需要注意的是，当 b 的绝对值大于 a 的绝对值时，取模运算的结果为 a 的值。例如：<br>int a = 7, b = 10; int result = a % b;   // 结果为 7<br>这是因为在这种情况下，a 对 b 取余的结果等于 a 本身，并且 a 的符号与 b 的符号相同。</p><h4 id="C-如何实现读取一个目录的所有文件">C#如何实现读取一个目录的所有文件</h4><p>可以使用 Directory 类和 File 类实现读取一个目录的所有文件。具体实现步骤如下：</p><ol><li>导入 <a href="http://System.IO">System.IO</a> 命名空间，以便使用 Directory 类和 File 类。using <a href="http://System.IO">System.IO</a>;</li><li>使用 Directory.GetFiles() 方法获取指定目录中的所有文件路径。string[] fileNames = Directory.GetFiles(@“C:\example\directory”); 其中，@“C:\example\directory” 为指定的目录路径。该方法返回一个字符串数组，包含指定目录中的所有文件路径。</li><li>遍历文件路径数组，使用 File.ReadAllText() 方法逐个读取文件内容。foreach (string fileName in fileNames) {     string content = File.ReadAllText(fileName);     Console.WriteLine(content); } 其中，fileName 为每个文件的路径。该方法返回一个字符串，包含指定文件的所有文本内容。</li></ol><p>完整代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.IO;</span><br><span class="line"></span><br><span class="line">namespace FileExample</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            string[] fileNames = Directory.GetFiles(@&quot;C:\example\directory&quot;);</span><br><span class="line"></span><br><span class="line">            foreach (string fileName in fileNames)</span><br><span class="line">            &#123;</span><br><span class="line">                string content = File.ReadAllText(fileName);</span><br><span class="line">                Console.WriteLine(content);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码将遍历指定目录中的所有文件，并输出每个文件的文本内容到控制台。你可以根据实际需要修改代码，例如修改文件读取方式、输出方式等。</p><h4 id="什么时候会触发picbox中的paint事件">什么时候会触发picbox中的paint事件</h4><p>PictureBox 控件的 Paint 事件在以下情况下会被触发：</p><ol><li>当控件被显示或重绘时（例如，当窗体被最小化或最大化，或者当其他控件被移动时）。</li><li>当控件的 Invalidate() 方法或 Refresh() 方法被调用时，这些方法会强制控件进行重新绘制操作。</li><li>当控件的 BackgroundImage 属性被设置为一个有效的图像时，系统会自动进行绘制操作，从而触发 Paint 事件。</li><li>当控件的 Image 属性被设置为一个有效的图像时，系统也会自动进行绘制操作，从而触发 Paint 事件。</li></ol><p>需要注意的是，当控件的 Image 或 BackgroundImage 属性被设置时，如果图片的尺寸超出了控件的大小，那么图片可能会被裁剪或缩放以适应控件的大小。在这种情况下，绘制的效果可能与预期不同。<br>因此，为了确保绘制效果正确，建议在绘制之前先检查控件的尺寸和图片的尺寸，并根据需要进行缩放或裁剪操作。</p><h1>PPM文件转化</h1><h4 id="PPM是什么文件">PPM是什么文件</h4><p>PM（Portable Pixmap）是一种简单的、可移植的图像文件格式，它是Unix系统中常用的一种图像格式。PPM文件由一系列的ASCII码或二进制代码表示的像素构成，它们按照从左到右、从上到下的顺序排列，每个像素用RGB三元组表示，即红、绿、蓝三个颜色分量。PPM文件可以表示灰度图像、彩色图像和真彩色图像。<br>PPM文件的格式比较简单，每个像素采用纯文本或二进制方式表示，因此容易读取和处理。但是，由于每个像素都用RGB三元组表示，所以PPM文件的文件大小比较大，不适合存储大型图像。此外，PPM文件也不支持压缩，因此文件大小随着图像分辨率的增加而呈线性增长。<br>PPM文件通常用于图像处理、计算机视觉和计算机图形学等领域中，例如在算法测试中，可以将算法处理前后的图像保存为PPM文件，方便比较和分析。</p><h2 id="羊了个羊">羊了个羊</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h1&gt;QQ项目：&lt;/h1&gt;
&lt;h4 id=&quot;C-imageList如何上传key对应的图片&quot;&gt;C#imageList如何上传key对应的图片&lt;/h4&gt;
&lt;p&gt;string key = “m</summary>
      
    
    
    
    <category term="课程作业" scheme="http://www.bojiboqi.fun/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="课程作业" scheme="http://www.bojiboqi.fun/tags/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
    <category term="C#" scheme="http://www.bojiboqi.fun/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>免费下载网易云付费音乐</title>
    <link href="http://www.bojiboqi.fun/2024/02/28/%E4%B8%8B%E8%BD%BD%E7%BD%91%E6%98%93%E4%BA%91%E4%BB%98%E8%B4%B9%E9%9F%B3%E4%B9%90/"/>
    <id>http://www.bojiboqi.fun/2024/02/28/%E4%B8%8B%E8%BD%BD%E7%BD%91%E6%98%93%E4%BA%91%E4%BB%98%E8%B4%B9%E9%9F%B3%E4%B9%90/</id>
    <published>2024-02-28T13:02:28.568Z</published>
    <updated>2024-02-28T10:44:05.215Z</updated>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id="只适用PC：">只适用PC：</h2><h2 id="1-搜索要下载的付费音乐打开开发者模式：">1.搜索要下载的付费音乐打开开发者模式：</h2><h4 id="打开开发者模式：">打开开发者模式：</h4><p>按F12或者鼠标右键选择检查：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1708692555387-c1748ef6-c7bf-421a-bab5-c3d3d3a1d2f2.png#averageHue=%23d8bd9b&amp;clientId=u4ebd3624-36cf-4&amp;from=paste&amp;height=510&amp;id=u75200f3d&amp;originHeight=637&amp;originWidth=1561&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=195670&amp;status=done&amp;style=none&amp;taskId=u94f765c6-2a22-4437-9062-085a675a424&amp;title=&amp;width=1248.8" alt="image.png"><br>刚开始进入开发者模式是这个界面！我们需要的不是这个界面，按照如下的步骤进入下个界面：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1708692645419-e1000f56-536e-4377-a0e9-60637e0fdb08.png#averageHue=%23d7c5a2&amp;clientId=u4ebd3624-36cf-4&amp;from=paste&amp;height=507&amp;id=uc4550e92&amp;originHeight=634&amp;originWidth=1708&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=177283&amp;status=done&amp;style=none&amp;taskId=u92330f53-e65a-4aba-bd11-de564939d38&amp;title=&amp;width=1366.4" alt="image.png"><br>点击播放刷新页面或者按住ctrl+r，然后页面变成下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1708692785653-f4853c1a-9836-44ac-bf8f-eb8fbde6189a.png#averageHue=%23d9dcc4&amp;clientId=u4ebd3624-36cf-4&amp;from=paste&amp;height=586&amp;id=u0c1eb7de&amp;originHeight=733&amp;originWidth=1716&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=262338&amp;status=done&amp;style=none&amp;taskId=u91b9bb7c-5a80-4fdc-89cf-b5e5bffc7b0&amp;title=&amp;width=1372.8" alt="image.png"><br>如果走到这步上图的右侧没有下面没有请求，就是没有点击播放！<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1708692884296-f2c155b2-5013-4ca4-a130-a4921276a6b5.png#averageHue=%23d8dbc3&amp;clientId=u4ebd3624-36cf-4&amp;from=paste&amp;height=553&amp;id=u8e9444a7&amp;originHeight=691&amp;originWidth=1618&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=235327&amp;status=done&amp;style=none&amp;taskId=ue0eba2ba-a203-4f2c-ab3b-836563101ef&amp;title=&amp;width=1294.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1708692930533-f93a36a8-2f52-4f85-a2fd-8d6c5ac74274.png#averageHue=%23dac298&amp;clientId=u4ebd3624-36cf-4&amp;from=paste&amp;height=608&amp;id=ufa76291c&amp;originHeight=760&amp;originWidth=1552&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=243818&amp;status=done&amp;style=none&amp;taskId=ue8a73002-e414-4c7e-a001-e372c46597e&amp;title=&amp;width=1241.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1708692986619-5018024f-1c4a-4250-9707-c8e25623817a.png#averageHue=%23000000&amp;clientId=u4ebd3624-36cf-4&amp;from=paste&amp;height=365&amp;id=ub81e2a9f&amp;originHeight=456&amp;originWidth=705&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=21754&amp;status=done&amp;style=none&amp;taskId=u81efb9b2-9ca0-44e9-a7ec-eaeb0b43592&amp;title=&amp;width=564" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html"> &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h2 id=&quot;只适用PC：&quot;&gt;只适用PC：&lt;/h2&gt;
&lt;h2 id=&quot;1-搜索要下载的付费音乐打开开发者模式：&quot;&gt;1.搜索要下载的付费音乐打开开发者模式：&lt;/h2&gt;
&lt;h4 id=&quot;打开</summary>
      
    
    
    
    <category term="杂项" scheme="http://www.bojiboqi.fun/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="白嫖技能" scheme="http://www.bojiboqi.fun/tags/%E7%99%BD%E5%AB%96%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>搜索的技巧：</title>
    <link href="http://www.bojiboqi.fun/2024/02/28/%E6%90%9C%E7%B4%A2%E7%9A%84%E6%8A%80%E5%B7%A7%EF%BC%9A/"/>
    <id>http://www.bojiboqi.fun/2024/02/28/%E6%90%9C%E7%B4%A2%E7%9A%84%E6%8A%80%E5%B7%A7%EF%BC%9A/</id>
    <published>2024-02-28T13:02:28.565Z</published>
    <updated>2024-02-28T13:03:18.865Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=tiN6T1LewmQ">视频</a><br /><a href="https://cloud.tencent.com/developer/article/2240162">Google 和 Baidu 的 16 个高级搜索技巧，干货满满！建议收藏学习！-腾讯云开发者社区-腾讯云</a><br><a name="bC8gV"></a></p><h2 id="搜索引擎技巧（重要）：">搜索引擎技巧（重要）：</h2><p><a name="lSIKt"></a></p><h4 id="1-精确搜索：双引号">1.精确搜索：双引号</h4><p>精确搜索，就是在你要搜索的词上，加上双引号，那个 Google 搜索引擎，就会完全的匹配你所要的词<br><a name="i6EWS"></a></p><h4 id="2-站内搜索：site">2.站内搜索：site</h4><p>这是一个比较常用的搜索方法，site 搜索，就是在站内进行搜索.<br />语法是：site:stackoverflow.com ，其中 site:后面加上你要搜索的网站地址。<br />一般程序猿解决问题，用 site:stackoverflow.com，大部分解决不了的问题，都会有答案了。<br><a name="P3Kfz"></a></p><h4 id="intitle-搜索范围限定在网页标题（也就是intitle后面的内容是标题的一部分）"><strong>intitle - 搜索范围限定在网页标题（也就是intitle后面的内容是标题的一部分）</strong></h4><p>搜索范围限定在包含 keyword 的网页标题中，这也是最普通的搜索。<br />intitle: 和后面的关键词之间不要有空格。<br><a name="FScqD"></a></p><h4 id="allintitle-限定标题多个关键字：">allintitle 限定标题多个关键字：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allintitle:李子柒 微念</span><br><span class="line">上面的意思是搜索结果的标题中要出现李子柒和微念两个关键词</span><br></pre></td></tr></table></figure><p><a name="JlbUp"></a></p><h4 id="inurl-搜索范围限定在-url-链接中"><strong>inurl 搜索范围限定在 url 链接中</strong></h4><p><strong>搜索范围限定在 url 链接中</strong>.<br />网页 url 中的某些信息，常常有某种有价值的含义。您如果对搜索结果的 url 做某种限定，可以获得良好的效果。<br />例如：前端教程 inurl:video<br><a name="OPtJU"></a></p><h4 id="imagesize-限定图片大小">imagesize:限定图片大小</h4><p><a name="mWH2R"></a></p><h4 id="filetype-限定文档：">filetype:限定文档：</h4><p><a name="KCa72"></a></p><h2 id="导航网站（比较重要）：">导航网站（比较重要）：</h2><p>直接谷歌搜某某行业导航网站或某某岗位/行业必逛网站。<br><a name="IUT5e"></a></p><h2 id="寻找相似的网站：">寻找相似的网站：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1702707274512-a461297e-ad20-4d75-b773-a705963eaa7b.png#averageHue=%23363636&amp;clientId=u3b86627d-2b3e-4&amp;from=paste&amp;height=337&amp;id=ubb915741&amp;originHeight=421&amp;originWidth=900&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=273502&amp;status=done&amp;style=none&amp;taskId=u71acd269-4266-436e-b322-392a28d79c5&amp;title=&amp;width=720" alt="image.png"><br><a name="gSalh"></a></p><h2 id="论文搜索：">论文搜索：</h2><p>谷歌学术和SCI-HUB，高校图书馆<br><a name="aUDz6"></a></p><h2 id="电子书（重要）：">电子书（重要）：</h2><p><a href="https://www.thinkdoc.vip/">欢乐图书馆|收录最优质的电子书网站的导航网站 | 最好的zlibrary电子书网址导航网站</a><br><a name="gl901"></a></p><h2 id="百度网盘搜索引擎：">百度网盘搜索引擎：</h2><p><a href="https://www.dalipan.com/#/main/search?restype=1">大力盘 - 网盘搜索引擎</a><br /><a href="https://www.xuesousou.net/">学搜搜(酷搜kolsou) - 百度网盘搜索引擎,百度云资源搜索,网盘资源下载</a><br /><a href="https://pansou.cc/">盘搜搜 - 百度网盘资源搜索神器</a><br /><a href="https://www.yunpangou.com/2155351113250243?p=4">Attention Required! | Cloudflare</a><br />个人感觉网盘搜索用处较少，有点鸡肋。<br><a name="u1E1D"></a></p><h2 id="素材搜索：">素材搜索：</h2><p><a href="https://www.pexels.com/zh-cn/">pexels</a><br /><a href="https://pixabay.com/">pixabay</a><br /><a href="https://www.videvo.net/">videvo</a><br /><a href="https://mixkit.co/">mixkit</a><br><a name="UeSIW"></a></p><h2 id="以图搜片：">以图搜片：</h2><p><a href="https://www.youtube.com/watch?v=tERFkMjRGaE">视频教学</a><br /><a href="https://xslist.org/tw">xslist</a>（根据图片寻找女优信息）<br /><a href="https://tineye.com/">老牌搜图</a><br /><a href="https://trace.moe/">搜索动漫</a><br />search by image浏览器插件<br><a name="zHlhJ"></a></p><h2 id="galgame资源：">galgame资源：</h2><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=tiN6T1LewmQ&quot;&gt;视频&lt;/a&gt;&lt;br /&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/2240162&quot;&gt;Google 和 </summary>
      
    
    
    
    <category term="工具技巧" scheme="http://www.bojiboqi.fun/categories/%E5%B7%A5%E5%85%B7%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="工具技巧" scheme="http://www.bojiboqi.fun/tags/%E5%B7%A5%E5%85%B7%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>设计模式总结</title>
    <link href="http://www.bojiboqi.fun/2024/02/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A/"/>
    <id>http://www.bojiboqi.fun/2024/02/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A/</id>
    <published>2024-02-28T13:02:28.562Z</published>
    <updated>2024-02-28T10:44:05.206Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><a href="https://blog.csdn.net/No_Game_No_Life_/article/details/107629644#:~:text=%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95UML%E7%B1%BB%E5%9B%BE%E6%B3%9B%E5%8C%96%20%28generalize%29%E4%B8%8E%E5%AE%9E%E7%8E%B0%20%28realize%29%E8%81%9A%E5%90%88%20%28aggregation%29%E4%B8%8E%E7%BB%84%E5%90%88,%28composition%29%E5%85%B3%E8%81%94%20%28association%29%E4%B8%8E%E4%BE%9D%E8%B5%96%20%28dependency%2923%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8FUML%E7%B1%BB%E5%9B%BE%E4%BB%8E%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B%E5%BC%80%E5%A7%8B%EF%BC%8C%E8%AF%B7%E7%9C%8B%E4%BB%A5%E4%B8%8B%E8%BF%99%E4%B8%AA%E7%B1%BB%E5%9B%BE%EF%BC%8C%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E5%85%B3%E6%B3%A8%E7%9A%84%EF%BC%9A%E6%B3%9B%E5%8C%96%20%28generalize%29%E4%B8%8E%E5%AE%9E%E7%8E%B0%20%28realize%29%E6%B3%9B%E5%8C%96%EF%BC%9ASUV%E6%89%A9%E5%B1%95%E5%92%8C%E7%BB%A7%E6%89%BF%E5%B0%8F%E6%B1%BD%E8%BD%A6%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%9B%E5%AE%9E%E7%8E%B0%EF%BC%9A%E5%B0%8F%E6%B1%BD%E8%BD%A6%E5%AE%9E%E7%8E%B0%E8%BD%A6%E8%BF%99%E4%B8%AA%E6%A6%82%E5%BF%B5%E3%80%82">Java设计之道——通过UML理解23种设计模式_下面的javaiouml类图体现了哪种设计模式思想-CSDN博客</a>（有图最好的）</p><h1><a href="https://juejin.cn/post/6975032627128614949#heading-1">13.工厂方法设计模式 - 掘金</a></h1><p><a href="https://blog.csdn.net/weixin_53202763/article/details/118579427">基于Java的XML操作（XML使用、解析、生成）_javaxml islabel-CSDN博客</a></p><h2 id="XML操作：">XML操作：</h2><p><a href="https://blog.csdn.net/weixin_53202763/article/details/118579427">基于Java的XML操作（XML使用、解析、生成）_javaxml islabel-CSDN博客</a><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1697863973548-aa627bbf-3fd5-4fb1-94b9-bd3a93d8e82c.jpeg" alt=""></p><h3 id="DOM4j解析XML：">DOM4j解析XML：</h3><p><a href="https://blog.csdn.net/qq_51447436/article/details/124754572">【精选】Dom4j解析XML（详解）_dom4j解析xml文件_散一世繁华，颠半世琉璃的博客-CSDN博客</a><br>1.导入依赖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.dom4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.准备的XML:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">books</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>鬼谷子<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">info</span>&gt;</span>教你如何识人，谋略，管理。。。<span class="tag">&lt;/<span class="name">info</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>白雪公主<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">info</span>&gt;</span>白雪公主与七个小矮人的故事<span class="tag">&lt;/<span class="name">info</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">books</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package <span class="variable constant_">XML</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">dom4j</span>.<span class="property">Document</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">dom4j</span>.<span class="property">DocumentException</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">dom4j</span>.<span class="property">Element</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">dom4j</span>.<span class="property">io</span>.<span class="property">SAXReader</span>;</span><br><span class="line"><span class="keyword">import</span> java.<span class="property">io</span>.<span class="property">FileInputStream</span>;</span><br><span class="line"><span class="keyword">import</span> java.<span class="property">io</span>.<span class="property">IOException</span>;</span><br><span class="line"><span class="keyword">import</span> java.<span class="property">util</span>.<span class="property">List</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> <span class="variable">redA</span></span></span><br><span class="line"><span class="comment"> * @时间: 2023年10月21日 12:46</span></span><br><span class="line"><span class="comment"> * DOM4J解析XML</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="title class_">String</span>[] args) throws <span class="title class_">IOException</span>,  <span class="title class_">DocumentException</span> &#123;</span><br><span class="line">        <span class="comment">//1、获取输入流</span></span><br><span class="line">        <span class="title class_">FileInputStream</span> fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test/src/test/java/XML/demo.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//2、创建xml读取对象</span></span><br><span class="line">        <span class="title class_">SAXReader</span> sr = <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="comment">//3、读取并获得文档</span></span><br><span class="line">        <span class="title class_">Document</span> doc = sr.<span class="title function_">read</span>(fis);</span><br><span class="line">        <span class="comment">//4、通过文档获取根元素</span></span><br><span class="line">        <span class="title class_">Element</span> root = ((org.<span class="property">dom4j</span>.<span class="property">Document</span>) doc).<span class="title function_">getRootElement</span>();</span><br><span class="line">        <span class="comment">//5、开始解析元素</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(root.<span class="title function_">getName</span>());</span><br><span class="line">        <span class="comment">//常见操作</span></span><br><span class="line">        <span class="comment">/*Element book = root.element(&quot;book&quot;);</span></span><br><span class="line"><span class="comment">        Element name = book.element(&quot;name&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(name.getText());*/</span></span><br><span class="line">        <span class="title class_">List</span>&lt;<span class="title class_">Element</span>&gt; list = root.<span class="title function_">elements</span>();</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; list.<span class="title function_">size</span>(); i++) &#123;</span><br><span class="line">            <span class="title class_">Element</span> element = list.<span class="title function_">get</span>(i);</span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(element.<span class="title function_">attributeValue</span>(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(element.<span class="title function_">elementText</span>(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(element.<span class="title function_">elementText</span>(<span class="string">&quot;info&quot;</span>));</span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.<span class="title function_">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="dom4j结合XPath解析XML">dom4j结合XPath解析XML</h3><p>1.导入依赖：<br>上面的dom4j依赖还需要额外的依赖：在pom.xml导入Xpath对应的依赖即可，具体如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jaxen<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxen<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package <span class="variable constant_">XML</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.<span class="property">dom4j</span>.<span class="property">Document</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">dom4j</span>.<span class="property">DocumentException</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">dom4j</span>.<span class="property">Node</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">dom4j</span>.<span class="property">io</span>.<span class="property">SAXReader</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.<span class="property">io</span>.<span class="property">FileInputStream</span>;</span><br><span class="line"><span class="keyword">import</span> java.<span class="property">io</span>.<span class="property">IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> <span class="variable">redA</span></span></span><br><span class="line"><span class="comment"> * @时间: 2023年10月21日 13:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="title class_">String</span>[] args) throws  <span class="title class_">DocumentException</span>, <span class="title class_">IOException</span> &#123;</span><br><span class="line">        <span class="comment">//1、获取输入流</span></span><br><span class="line">        <span class="title class_">FileInputStream</span> fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test/src/test/java/XML/demo.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//2、创建xml读取对象</span></span><br><span class="line">        <span class="title class_">SAXReader</span> sr = <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="comment">//3、读取并获得文档</span></span><br><span class="line">        <span class="title class_">Document</span> doc = sr.<span class="title function_">read</span>(fis);</span><br><span class="line">        <span class="title class_">Node</span> node = doc.<span class="title function_">selectSingleNode</span>(<span class="string">&quot;//book[@id=&#x27;1&#x27;]//name&quot;</span>);</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(node.<span class="title function_">getName</span>()+<span class="string">&quot;:&quot;</span>+node.<span class="title function_">getText</span>());</span><br><span class="line">        fis.<span class="title function_">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="DEMO4J生成XML文件">DEMO4J生成XML文件:</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> <span class="title class_">SaveGrandpa</span> &#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="title class_">String</span>[] args) throws <span class="title class_">IOException</span> &#123;</span><br><span class="line">        <span class="comment">//1、通过文档助手，创建一个文档对象</span></span><br><span class="line">        <span class="title class_">Document</span> <span class="variable language_">document</span> = <span class="title class_">DocumentHelper</span>.<span class="title function_">createDocument</span>();</span><br><span class="line">        <span class="comment">//2、给文档添加第一个节点（根节点）</span></span><br><span class="line">        <span class="title class_">Element</span> books = <span class="variable language_">document</span>.<span class="title function_">addElement</span>(<span class="string">&quot;books&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="title class_">Element</span> book = books.<span class="title function_">addElement</span>(<span class="string">&quot;book&quot;</span>);<span class="comment">//添加books节点下的节点book</span></span><br><span class="line">            <span class="title class_">Element</span> name = book.<span class="title function_">addElement</span>(<span class="string">&quot;name&quot;</span>);<span class="comment">//添加book节点下的节点name</span></span><br><span class="line">            name.<span class="title function_">setText</span>(<span class="string">&quot;葫芦娃救爷爷第（&quot;</span>+i+<span class="string">&quot;）集&quot;</span>);</span><br><span class="line">            <span class="title class_">Element</span> info = book.<span class="title function_">addElement</span>(<span class="string">&quot;info&quot;</span>);<span class="comment">//添加book节点下的节点info</span></span><br><span class="line">            info.<span class="title function_">setText</span>(<span class="string">&quot;爷爷第&quot;</span>+i+<span class="string">&quot;次被抓走后，葫芦兄弟们，开始了他们第&quot;</span>+i+<span class="string">&quot;次的行动计划&quot;</span>);</span><br><span class="line">            book.<span class="title function_">addAttribute</span>(<span class="string">&quot;id&quot;</span>,<span class="number">100</span>+i+<span class="string">&quot;&quot;</span>);<span class="comment">//给定book一个id属性，还有其对应的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4、创建一个文件输出流</span></span><br><span class="line">        <span class="title class_">FileOutputStream</span> fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test/src/test/java/XML/book.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//5、将输出流转换为XML输出流</span></span><br><span class="line">        <span class="title class_">XMLWriter</span> xw = <span class="keyword">new</span> <span class="title class_">XMLWriter</span>(fos);</span><br><span class="line">        <span class="comment">//6、写出文档</span></span><br><span class="line">        xw.<span class="title function_">write</span>(<span class="variable language_">document</span>);</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        xw.<span class="title function_">close</span>();</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="XML解析之DOM解析">XML解析之DOM解析</h3><p><a href="https://blog.csdn.net/a1353206432/article/details/80583302">XML解析之DOM解析详解_dom xml-CSDN博客</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> <span class="title class_">DOMDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="title class_">String</span>[] args) throws <span class="title class_">ParserConfigurationException</span>, <span class="title class_">SAXException</span>, <span class="title class_">IOException</span>, <span class="title class_">IOException</span>, <span class="title class_">SAXException</span> &#123;</span><br><span class="line">        <span class="comment">//建立DocumentBuilderFactor，用于获得DocumentBuilder对象：</span></span><br><span class="line">        <span class="title class_">DocumentBuilderFactory</span> factory = <span class="title class_">DocumentBuilderFactory</span>.<span class="title function_">newInstance</span>();</span><br><span class="line">        <span class="comment">//2.建立DocumentBuidler：</span></span><br><span class="line">        <span class="title class_">DocumentBuilder</span> builder = factory.<span class="title function_">newDocumentBuilder</span>();</span><br><span class="line">        <span class="comment">//3.建立Document对象，获取树的入口：</span></span><br><span class="line">        <span class="title class_">Document</span> doc = builder.<span class="title function_">parse</span>(<span class="string">&quot;test/src/test/java/XML/demo.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//4.建立NodeList：</span></span><br><span class="line">        <span class="title class_">NodeList</span> node = doc.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">        <span class="comment">//5.进行xml信息获取</span></span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;node.<span class="title function_">getLength</span>();i++)&#123;</span><br><span class="line">            <span class="title class_">Element</span> e = (<span class="title class_">Element</span>)node.<span class="title function_">item</span>(i);</span><br><span class="line">            <span class="comment">// e.getElementsByTagName(&quot;name&quot;)返回name标签下所有名为name的标签集合；.item(0)获取</span></span><br><span class="line"><span class="comment">//            索引为0的标签集合；.getFirstChild()获取该标签下的第一个子节点（和前端的DOM树一个概念，文本信息也是节点）</span></span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;书名：&quot;</span>+</span><br><span class="line">                    e.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;name&quot;</span>).<span class="title function_">item</span>(<span class="number">0</span>).<span class="title function_">getFirstChild</span>().<span class="title function_">getNodeValue</span>());</span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;信息：&quot;</span>+</span><br><span class="line">                    e.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;info&quot;</span>).<span class="title function_">item</span>(<span class="number">0</span>).<span class="title function_">getFirstChild</span>().<span class="title function_">getNodeValue</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697866671687-9e4c0662-f7ab-4b9f-9dc7-e93ec193e3d7.png#averageHue=%23adb9a3&amp;clientId=u8e7046c2-c39f-4&amp;from=paste&amp;height=150&amp;id=u4520cb1f&amp;originHeight=188&amp;originWidth=454&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=36584&amp;status=done&amp;style=none&amp;taskId=u19d0c24d-f0fa-4b58-be1f-a74d420b0e6&amp;title=&amp;width=363.2" alt="image.png"></p><h2 id="反射：">反射：</h2><p><a href="https://blog.csdn.net/qq_44715943/article/details/120587716">Java反射（超详细！）_一个快乐的野指针~的博客-CSDN博客</a>（最好）<br><a href="https://blog.csdn.net/HO1_K/article/details/81210947">深入理解Java反射机制原理、使用方法_反射获取 hashmap 成员_涝山道士的博客-CSDN博客</a><br><a href="https://www.cnblogs.com/mikechenshare/p/15796381.html">Java反射详解：入门+使用+原理+应用场景 - mikechen的互联网架构 - 博客园</a>（原理）<br><a href="https://blog.csdn.net/peng_zhanxuan/article/details/104028236">一篇图文彻底弄懂Class文件是如何被加载进JVM的_classloader加载class之后,class内容放在那里-CSDN博客</a>(类加载原理）<br><a href="https://frank909.blog.csdn.net/article/details/54973413?spm=1001.2101.3001.6650.11&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-11-54973413-blog-104028236.235%5Ev38%5Epc_relevant_default_base&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-11-54973413-blog-104028236.235%5Ev38%5Epc_relevant_default_base&amp;utm_relevant_index=17">一看你就懂，超详细java中的ClassLoader详解-CSDN博客</a>（详细较难）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">JVM</span>加载<span class="keyword">class</span>要经历加载连接和初始化阶段。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1697940589429-088280d5-a2cc-4b32-81f0-93cd5b35cec2.jpeg" alt=""></p><h2 id="设计模式七大准则：">设计模式七大准则：</h2><p><a href="https://juejin.cn/post/6844904065806106632#heading-29">万字总结之设计模式七大原则 - 掘金</a><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1697936886662-ef323251-e37d-422c-b580-235f030a00bf.jpeg" alt=""></p><h2 id="工厂设计模式：">工厂设计模式：</h2><p>简单工厂模式：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700697406061-8636a8ba-7342-4643-9005-2f897a1bfac6.png#averageHue=%23f8f7f6&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;id=u1fb7a595&amp;originHeight=289&amp;originWidth=584&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufc53946e-54cb-4024-9dbf-b422147fdf2&amp;title=" alt=""><br>工厂方法模式：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700697454837-e517f62c-1e75-4467-a454-6bb033ddf680.png#averageHue=%23f7f6f3&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;id=u3f4ab352&amp;originHeight=351&amp;originWidth=836&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ude09a469-8938-4008-afb5-fe790f8c2e6&amp;title=" alt=""><br>抽象工厂：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700697477558-74711338-f414-4540-ad39-fceee78a2145.png#averageHue=%23f8f7f5&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;id=u2254c91a&amp;originHeight=575&amp;originWidth=859&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u69b08de9-ad59-4c37-ac79-90ce36f4e33&amp;title=" alt=""><br><a href="https://juejin.cn/post/7290157103673573430">设计模式学习笔记（三）简单工厂、工厂方法和抽象工厂之间的区别 - 掘金</a>（较难）<br><a href="https://juejin.cn/post/6966429276438528037#heading-10">1.简单工厂设计模式 - 掘金</a><br><a href="https://juejin.cn/post/6975032627128614949#heading-1">13.工厂方法设计模式 - 掘金</a><br><a href="https://blog.csdn.net/qq_42804736/article/details/115168313">java工厂模式：简单工厂、工厂方法、抽象工厂（通俗易懂）_Mitsuha三葉的博客-CSDN博客</a><br>简单工厂是一个工厂方法承担多个产品制造方法。工厂方法是每个产品有一个公共的工厂类，各个工厂类抽象了一个接口，供上层模块使用。抽象工厂有多个工厂（抽象工厂+多个具体工厂），多个产品接口/抽象类，对产品子类进行分组，根据继承抽象工厂中的方法多态创建同组的不同具体产品对象。适用于多个类型的多个产品。抽象工厂：比如有多个产品，这多个产品中每种产品有多种特性，我们把其中的一些特性抽取出来为多个接口，让这些产品实现这些接口；然后把部分特性放在工厂类中，工厂类在制造这些产品的时候给这些产品附加一些特性，然后把各个工厂类抽象为一个抽象工厂类供上层模块使用。</p><h2 id="适配器模式：">适配器模式：</h2><p><a href="https://zhuanlan.zhihu.com/p/369272002">秒懂设计模式之适配器模式（Adapter Pattern）</a><br><a href="https://hyper18.github.io/2022/01/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/">设计模式之结构型模式的设计与实现（一）</a><br>分为对象适配器模式和类适配器模式。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697950230938-1654fb7f-2d58-485f-9ccb-21a2c5019685.png#averageHue=%23fafafa&amp;clientId=ucf7aa35b-d6e3-4&amp;from=paste&amp;height=403&amp;id=ued1d1656&amp;originHeight=504&amp;originWidth=886&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=65828&amp;status=done&amp;style=none&amp;taskId=u553f38d0-c706-4715-bf5a-7c368d7327c&amp;title=&amp;width=708.8" alt="image.png"></p><h2 id="桥接模式：">桥接模式：</h2><h2 id=""><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700643857216-22c6ede3-a69c-4582-b7b4-dc420db3c313.png#averageHue=%23f5f1f1&amp;clientId=u94ee9845-25a0-4&amp;from=paste&amp;id=u2d9da7d3&amp;originHeight=260&amp;originWidth=532&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uece6c55d-7a24-4109-b361-4ec7dd1992c&amp;title=" alt=""></h2><p><a href="https://blog.csdn.net/bueke/article/details/115640512">桥接模式实例与解析 实例一：模拟毛笔_桥接模式 毛笔-CSDN博客</a><br><a href="https://cloud.tencent.com/developer/article/2183989">详解设计模式：桥接模式-腾讯云开发者社区-腾讯云</a></p><h2 id="外观模式：">外观模式：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700645512075-be1a2562-87cb-4e82-b6fb-0e8b0f872401.png#averageHue=%23f9f8f0&amp;clientId=u94ee9845-25a0-4&amp;from=paste&amp;id=u6215c5c2&amp;originHeight=294&amp;originWidth=544&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u472e0d03-bda0-4737-8761-51c9e87c2db&amp;title=" alt=""><br>（简单来说就是将多个类的功能集中到一个外观类中，让这个外观类去调用各个类的方法）<br><a href="https://blog.csdn.net/shulianghan/article/details/105339213">【设计模式】外观模式 ( 概念 | 适用场景 | 优缺点 | 代码示例 )_外观模式的优缺点-CSDN博客</a><br><a href="https://blog.csdn.net/qq_44302255/article/details/119026220">外观模式 ------模拟电脑主机调用其他硬件和软件_模拟连接计算机硬件_寻常w的博客-CSDN博客</a><br><a href="https://blog.csdn.net/Altitude_/article/details/103870191">外观模式_使用外观模式,描述cpu、memory、disk、电脑几个对象-CSDN博客</a></p><h2 id="代理模式：">代理模式：</h2><p>静态代理：需要实现接口的原因是为了可以用接口来代替代理类。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700664251988-75270825-7b75-4837-9b78-4146146ce972.png#averageHue=%23f5f4ea&amp;clientId=u94ee9845-25a0-4&amp;from=paste&amp;id=u01f30944&amp;originHeight=335&amp;originWidth=482&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u93e65a83-3817-4b39-8d92-cec01b034e8&amp;title=" alt=""><br>动态代理：不需要实现接口但是因为利用了反射机制；AOP编程使用的就是动态代理<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700664285010-f34cffcf-b65b-46cc-8455-7112589d1a40.png#averageHue=%23f1f0e2&amp;clientId=u94ee9845-25a0-4&amp;from=paste&amp;id=uc7c14baf&amp;originHeight=262&amp;originWidth=457&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u24a8a8fd-3770-4776-b05c-4504b9e919e&amp;title=" alt=""><br><a href="https://it-blog-cn.com/blogs/design_mode/proxy.html#%E4%BA%8C%E3%80%81%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86">设计模式——代理模式 | 程序员进阶</a><br><a href="https://blog.csdn.net/will130/article/details/50707527">代理模式（二）：代理模式应用实例（收费商务信息查询系统）-CSDN博客</a><br><a href="https://juejin.cn/post/7218559384450924604#heading-5">Java代理模式：如何优雅地控制对象访问？ - 掘金</a></p><h2 id="命令模式：">命令模式：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700724055355-ef8d51e9-1fab-4334-9b71-42d85ef56cbd.png#averageHue=%23fcfcfc&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;height=210&amp;id=uae146fd5&amp;originHeight=263&amp;originWidth=684&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=18687&amp;status=done&amp;style=none&amp;taskId=u139dd4da-ec93-44c7-b429-62a364db76d&amp;title=&amp;width=547.2" alt="image.png"><br><a href="https://www.cnblogs.com/xuwendong/p/9814421.html#_label2">深入理解设计模式（十）：命令模式 - 一指流砂~ - 博客园</a><br><a href="https://blog.csdn.net/qq_45703570/article/details/123814016">【精选】命令模式模拟房间开关_房间中的开关就是命令模式的一个实现_水木 清华的博客-CSDN博客</a></p><h2 id="迭代器模式：">迭代器模式：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700666053595-7efa2537-a417-4c87-98f6-7f4be9a255e6.png#averageHue=%23f4f3e5&amp;clientId=u94ee9845-25a0-4&amp;from=paste&amp;id=u95811787&amp;originHeight=200&amp;originWidth=821&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u635b5f51-1766-4fae-a0d3-40d732a25d6&amp;title=" alt=""><br><a href="https://blog.csdn.net/sheng0113/article/details/122712947">【精选】Java迭代器详解，看这一篇就够了-CSDN博客</a><br><a href="https://blog.csdn.net/shulianghan/article/details/119777612">【设计模式】迭代器模式 ( 简介 | 适用场景 | 优缺点 | 代码示例 )_迭代器模式优缺点-CSDN博客</a><br><a href="https://cloud.tencent.com/developer/article/2342495">设计模式学习笔记（十六）迭代器模式及其在Java 容器中的应用-腾讯云开发者社区-腾讯云</a></p><h2 id="观察者模式：">观察者模式：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700667035824-c8744e25-b87c-4475-ae49-cda5965d90f6.png#averageHue=%23f2f1ed&amp;clientId=u94ee9845-25a0-4&amp;from=paste&amp;id=udb284363&amp;originHeight=306&amp;originWidth=479&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3794665b-2aa4-4b05-b30b-8318b1a6cb4&amp;title=" alt=""><br><a href="https://www.cnblogs.com/xuwendong/p/9814417.html">深入理解设计模式（八）：观察者模式 - 一指流砂~ - 博客园</a><br><a href="https://juejin.cn/post/7203310104010162237">设计模式之《观察者模式》 - 掘金</a><br><a href="https://www.cnblogs.com/binyao/p/4898144.html">观察者模式－猫叫了,老鼠跑了,主人醒了… - Binyao - 博客园</a></p><h2 id="策略模式：">策略模式：</h2><p><a href="https://www.cnblogs.com/ysocean/p/15635852.html#_label4">Java设计模式之（十四）——策略模式 - YSOcean - 博客园</a><br><a href="https://blog.csdn.net/yuanmayuzhou/article/details/131430435?spm=1001.2101.3001.6650.15&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-15-131430435-blog-90601469.235%5Ev38%5Epc_relevant_default_base&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-15-131430435-blog-90601469.235%5Ev38%5Epc_relevant_default_base&amp;utm_relevant_index=20">【设计模式】用Java实现策略模式_java策略模式实现_卷帘的博客-CSDN博客</a><br><a href="https://www.cnblogs.com/wangyongwen/p/11255563.html">Java的设计模式（5）-- 策略模式 - 扁豆一号 - 博客园</a></p><h2 id="访问者模式：">访问者模式：</h2><p><a href="https://www.jianshu.com/p/1f1049d0a0f4">访问者模式一篇就够了</a><br>访问者模式是一种将数据操作和数据结构分离的设计模式。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698587841234-71706cf7-5ba2-4433-9cca-a7f0b4a65494.png#averageHue=%23474b49&amp;clientId=u72c71db7-a8bd-4&amp;from=paste&amp;height=472&amp;id=u89dc5bda&amp;originHeight=590&amp;originWidth=900&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=170983&amp;status=done&amp;style=none&amp;taskId=u7d9cfec2-6d57-4594-993b-e6e81078010&amp;title=&amp;width=720" alt="image.png"></p><h2 id="复习：">复习：</h2><h3 id="建造者模式：">建造者模式：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700630270327-4bbf82a4-2e03-44e8-aa17-bd7d19d4be9e.png#averageHue=%23fcfcfc&amp;clientId=u94ee9845-25a0-4&amp;from=paste&amp;height=193&amp;id=ufc6e7925&amp;originHeight=241&amp;originWidth=613&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=31108&amp;status=done&amp;style=none&amp;taskId=u487d60f2-39ab-4f4e-9448-52d1a1f43b4&amp;title=&amp;width=490.4" alt="image.png"><br>建造者模式在创建产品的时候使用的是Director中的创造产品方法，而该方法的参数是Builder接口的具体实现类，而这个具体实现类的作用是产生一个具体的产品（该产品的属性赋值了的）；这样做就可以把产品的生成和赋值分离开来。比如当一个产品融合到一个模块中了，如果该产品是用new生成在赋值的，那么我们想修改该产品的属性就需要修改这个模块；如果我们使用了构造者模式，我们就把该产品赋值分离了该模块也就是是把赋值的功能交给了Builder具体实现类，我们只需要修改这个具体实现类而不用修改原模块了。<br><a href="https://blog.csdn.net/qq_43652327/article/details/115856402">23种设计模式全解析（JAVA实现）_23种设计模式 java实现、-CSDN博客</a></p><h3 id="原型模式：">原型模式：</h3><p><a href="https://it-blog-cn.com/blogs/design_mode/prototype.html#%E4%BA%8C%E3%80%81%E7%B1%BB%E5%9B%BE">设计模式——原型模式 | 程序员进阶</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700631075062-27757752-d23e-4d1d-ba50-93bbba153667.png#averageHue=%23fefcfa&amp;clientId=u94ee9845-25a0-4&amp;from=paste&amp;height=94&amp;id=u43dee661&amp;originHeight=117&amp;originWidth=811&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=19556&amp;status=done&amp;style=none&amp;taskId=u95340d35-0c0f-4df4-a491-ca502a0f6b5&amp;title=&amp;width=648.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700630981440-697e4124-aaaa-4e92-b7fd-3481177500fc.png#averageHue=%23f5f5ea&amp;clientId=u94ee9845-25a0-4&amp;from=paste&amp;id=u432a964e&amp;originHeight=206&amp;originWidth=415&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u42667948-7c60-4a9b-9cc6-c76fbd74400&amp;title=" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yintong.principle.singleresponsibility;</span><br><span class="line"><span class="comment">//写一个手机的克隆类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="comment">// 这里的Cloneable是一个空接口，起着标记的作用</span></span><br><span class="line"><span class="comment">//名称</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">//号码</span></span><br><span class="line"><span class="keyword">private</span> Long number;</span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcretePrototype</span><span class="params">(String name, Long number)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.number = number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;ConcretePrototype [name=&quot;</span> + name + <span class="string">&quot;, number=&quot;</span> + number + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 克隆用到的主要部分，重写的clone方法是object中的方法，Object</span></span><br><span class="line">    <span class="comment">// 中的clone方法用于创建并返回当前对象的副本。如果当前对象的类实现了Cloneable接口，</span></span><br><span class="line">    <span class="comment">// 则返回新的对象，否则抛出CloneNotSupportedException异常。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line"><span class="type">ConcretePrototype</span> <span class="variable">ConcretePrototype</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ConcretePrototype = (ConcretePrototype) <span class="built_in">super</span>.clone();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ConcretePrototype;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line"><span class="comment">//创建一个对象</span></span><br><span class="line"><span class="type">ConcretePrototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(<span class="string">&quot;华为&quot;</span>, <span class="keyword">new</span> <span class="title class_">Long</span>(<span class="number">1568889932</span>));</span><br><span class="line"><span class="comment">//通过原型模式完成对象的创建  克隆</span></span><br><span class="line"><span class="type">ConcretePrototype</span> <span class="variable">p2</span> <span class="operator">=</span> (ConcretePrototype)prototype.clone();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里的p2和 prototype创建对象的地址不一样</span></span><br></pre></td></tr></table></figure><h3 id="单例模式：">单例模式：</h3><p>通过构造方法私有化，在类中实例该对象，从而达到单例的效果。</p><h3 id="组合模式：">组合模式：</h3><p>主要表现的是类的层次结构<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700644275717-97906ff7-9846-4e93-8c1a-e1595e768205.png#averageHue=%23fefdfb&amp;clientId=u94ee9845-25a0-4&amp;from=paste&amp;height=82&amp;id=u20fb80ad&amp;originHeight=103&amp;originWidth=1423&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=21853&amp;status=done&amp;style=none&amp;taskId=u74b954aa-6664-49d2-b737-bca4f370332&amp;title=&amp;width=1138.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700644282629-e626acda-0a8d-4749-b4b5-cdc0020df8ec.png#averageHue=%23f7f5e2&amp;clientId=u94ee9845-25a0-4&amp;from=paste&amp;id=u28275542&amp;originHeight=370&amp;originWidth=1040&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1517a201-b125-4bbf-a0cf-42949b1dd0a&amp;title=" alt=""></p><h3 id="装饰者模式：">装饰者模式：</h3><p><a href="https://blog.csdn.net/No_Game_No_Life_/article/details/85777928">Java设计模式——装饰模式_装饰模式代码-CSDN博客</a><br>动态地给一个对象添加一些额外的职责的同时不修改原对象；这里的原对象是ConcreteComponent的实例，在不修改原对象添加额外的操作说白了就是新创建一个类，这个类属性为原对象，把这个类的实例当作原对象的实例，通过往该类中添加额外的操作来实现。这里之所以抽出一个接口是为了让类依赖于接口而不是具体的类。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700644479601-17954813-9f04-478d-88c8-f53aa6188058.png#averageHue=%23f4f1ec&amp;clientId=u94ee9845-25a0-4&amp;from=paste&amp;id=ub241c7e9&amp;originHeight=326&amp;originWidth=629&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue45997b2-9927-4b34-ad0f-561b3e06ec3&amp;title=" alt=""></p><p>Component:对象的接口类，定义装饰对象和被装饰对象的共同接口；<br>ConcreteComponent:被装饰对象的类定义；<br>Decorator:装饰对象的抽象类，持有一个具体的被修饰对象，并实现接口类继承的公共接口；<br>ConcreteDecorator:具体的装饰器，负责往被装饰对象添加额外的功能；</p><h3 id="享元模式：">享元模式：</h3><p><a href="https://it-blog-cn.com/blogs/design_mode/flyweight.html#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">设计模式——享元模式 | 程序员进阶</a></p><h3 id="职责链模式：">职责链模式：</h3><p>就是客户端将请求request包装为一个request该request发给一个抽象的handler类，该handler有多个实现类；<br>这种模式深刻体现了依赖倒置原则。</p><h3 id="访问者模式：-2">访问者模式：</h3><p>将数据结构的操作和数据结构分离开来。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700665871732-75c0dc46-cbf9-4fa5-beb2-f90889708341.png#averageHue=%23ededed&amp;clientId=u94ee9845-25a0-4&amp;from=paste&amp;id=u64abde58&amp;originHeight=413&amp;originWidth=560&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ubd72810e-3d94-4898-95d0-07a56fff11c&amp;title=" alt=""></p><h3 id="中介模式：">中介模式：</h3><p>当一个类依赖一个类是，不直接使用依赖而是通过中介来实现这种依赖关系。迪米特法则当传递过来的参数是数组的时候，该类中对该数组参数的处理可能会new一个该参数的类，这个时候就破坏了迪米特法则；利用中介模式可以很好的维护迪米特法则。</p><h3 id="备忘录模式：">备忘录模式：</h3><p>在不破坏一个对象封装性的前提下，获取该对象内部状态。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700667536762-faa27152-74cd-4dbd-bbf0-684dbea671a9.png#averageHue=%23f5f4df&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;id=ub9a423cd&amp;originHeight=465&amp;originWidth=787&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1593eead-e344-4d86-ab33-43642c750d0&amp;title=" alt=""></p><h3 id="状态模式：">状态模式：</h3><p><strong>当对象的状态改变时，同时改变其行为。也就是行为由其状态决定。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700667692599-12166ee9-ce23-466e-b2f0-9f9dce5477b2.png#averageHue=%23f3f2f0&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;id=ud8564ead&amp;originHeight=178&amp;originWidth=565&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue45ccb5d-d8a8-4585-b7e2-c2b258424ce&amp;title=" alt=""></p><h3 id="策略模式：-2">策略模式：</h3><p>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700667742848-e1d3c5a5-1519-4f06-8668-25fb848e1b86.png#averageHue=%23f3ddb0&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;id=u525c08b7&amp;originHeight=166&amp;originWidth=587&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf8642269-9d65-49b3-a7ad-935ba0a4dab&amp;title=" alt=""></p><h3 id="模板模型：">模板模型：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700667785713-b6abf372-a615-40bd-810f-0efb71a7abff.png#averageHue=%23f7f6ea&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;id=u166614fb&amp;originHeight=205&amp;originWidth=478&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc1cc0514-74c8-48e9-8c99-96ca63a4f1e&amp;title=" alt=""></p><h2 id="习题：">习题：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700700546719-46ba9e6a-def3-4b46-8da8-1fb663b94486.png#averageHue=%23fefefe&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;height=349&amp;id=u4b4d0897&amp;originHeight=436&amp;originWidth=787&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=50689&amp;status=done&amp;style=none&amp;taskId=u48aeff43-ae67-400f-81f1-6dee8246b03&amp;title=&amp;width=629.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700702555642-2fc0ff08-e896-496e-81a4-deeb27aae9f9.png#averageHue=%23fdfcfb&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;height=358&amp;id=u95106190&amp;originHeight=447&amp;originWidth=1079&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=109650&amp;status=done&amp;style=none&amp;taskId=u045c5d8a-41da-4c40-bda9-0349f0bca79&amp;title=&amp;width=863.2" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">合成复用实际上更倾向于<span class="string">&quot;黑箱&quot;</span>复用，而不是<span class="string">&quot;白箱&quot;</span>复用。在合成复用中，包含对象的容器对象并不需要了</span><br><span class="line">解或暴露被包含对象的实现细节，因此称为<span class="string">&quot;黑箱&quot;</span>复用。这种方式降低了对象之间的耦合度，并且使得容</span><br><span class="line">器对象可以独立于被包含对象进行变化。</span><br><span class="line"></span><br><span class="line">另外，合成复用是可以在运行时动态实现的，通过组合对象，可以在运行时灵活地改变对象之间的关系。</span><br><span class="line">这使得合成复用比继承复用更加灵活和可扩展。因此，选项B的说法是错误的。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700705175603-e347f492-cdcb-4d2f-8d39-2be451a99610.png#averageHue=%23fefefe&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;height=308&amp;id=u796366bd&amp;originHeight=385&amp;originWidth=1114&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=19941&amp;status=done&amp;style=none&amp;taskId=ue649576a-cbc7-4bfe-9576-2514815b6d9&amp;title=&amp;width=891.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700705229399-8222eeda-e8db-4e1b-b106-b984e8df6973.png#averageHue=%23f7f7f6&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;height=538&amp;id=u8b79214f&amp;originHeight=672&amp;originWidth=1114&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=162923&amp;status=done&amp;style=none&amp;taskId=u5f783264-a802-44fb-ba5b-e24fb5b1ebf&amp;title=&amp;width=891.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700705570296-3e97e4b7-37de-4550-a026-dfeb41107bf5.png#averageHue=%23fefdfd&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;height=274&amp;id=ub059b76c&amp;originHeight=342&amp;originWidth=1070&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=21448&amp;status=done&amp;style=none&amp;taskId=uf29fdab3-a95a-4d87-8ad8-3c754ab7727&amp;title=&amp;width=856" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">桥接模式将对象的抽象部分与它的实现部分分离，以使得它们都可以独立地变化。在桥接模式中，</span><br><span class="line">一个对象被划分成两个部分，即抽象部分和实现部分，然后两者通过桥进行关联。</span><br><span class="line">这样，抽象部分和实现部分可以分别独立地变化，而不会影响到它们之间的耦合关系。 </span><br><span class="line">状态模式则是一种行为型模式，用于模拟对象的各种状态，并且方便在不同状态之间进行转换。</span><br><span class="line">状态模式包含状态接口、具体状态以及上下文三个部分。其中，状态接口定义了各个具体状态的共同行为，</span><br><span class="line">具体状态则实现了这些行为，而上下文则包含了状态接口，并且通过引用具体状态来实现状态的切换。</span><br><span class="line">因此，桥接模式和状态模式的作用和实现方式是不同的。桥接模式主要用于对象的抽象和实现的分离，</span><br><span class="line">而状态模式主要用于模拟对象的不同状态和状态之间的切换。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700705765398-6eeeb26a-826c-4872-bae3-e89727c85631.png#averageHue=%23fefefd&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;height=302&amp;id=u84e8af58&amp;originHeight=377&amp;originWidth=766&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=37020&amp;status=done&amp;style=none&amp;taskId=uadc62e4e-3cbf-4a63-b48e-5ceaa950b19&amp;title=&amp;width=612.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700705959590-c5e35bef-c6bc-4b75-9192-4b67e49f8caf.png#averageHue=%23fefdfd&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;height=194&amp;id=u907da4bd&amp;originHeight=243&amp;originWidth=548&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=12804&amp;status=done&amp;style=none&amp;taskId=u309240ad-7912-4467-b26c-99f323456a5&amp;title=&amp;width=438.4" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">封装不仅仅包括数据，还包括一些方法</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700706074307-d0d19e0e-0a68-424c-beb9-677d6f157781.png#averageHue=%23fdfdfd&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;height=208&amp;id=u71109ad4&amp;originHeight=260&amp;originWidth=502&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=12657&amp;status=done&amp;style=none&amp;taskId=u0698ef60-bc90-4ccc-b4c8-8475d7887c3&amp;title=&amp;width=401.6" alt="image.png"><br>简单工厂模式的类图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700697406061-8636a8ba-7342-4643-9005-2f897a1bfac6.png#averageHue=%23f8f7f6&amp;from=url&amp;id=vW0gT&amp;originHeight=289&amp;originWidth=584&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>可以看到如果新增一个具体产品的话，就需要修改Factory中的构造方法，明显不符合开闭原则。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700706283790-70c49687-2ce9-49cd-b390-f02c5d2b6a93.png#averageHue=%23fdfdfc&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;height=193&amp;id=u577e6c38&amp;originHeight=241&amp;originWidth=461&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=12506&amp;status=done&amp;style=none&amp;taskId=u65a8e59e-37e0-4425-b6d8-325753c624f&amp;title=&amp;width=368.8" alt="image.png">（这个题应该有点争议）<br>原型模式clone的对象不一样，但是类型一样。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700706553905-28c708c7-5a6f-470c-9fe4-659ee5314f92.png#averageHue=%23fdfdfc&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;height=215&amp;id=u5b7b3681&amp;originHeight=269&amp;originWidth=625&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=14356&amp;status=done&amp;style=none&amp;taskId=u1af2d06f-cf74-4a7a-ac48-b2d583164e9&amp;title=&amp;width=500" alt="image.png"><br>这个说的应该是桥接模式，抽象工厂针对的是多个产品等级结构。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700706608794-6d3f696c-e0e2-44e2-b624-06dceef08a87.png#averageHue=%23f8f7f5&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;id=u11821bd5&amp;originHeight=575&amp;originWidth=859&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u81538e04-0d95-4c68-8511-59e8cb9ceca&amp;title=" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700706639063-ac936d77-5a84-4056-8ecc-abb1a67a37ee.png#averageHue=%23fdfdfd&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;height=200&amp;id=ue686e415&amp;originHeight=250&amp;originWidth=647&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=14283&amp;status=done&amp;style=none&amp;taskId=ue5221bbc-2eca-4250-8470-8de04ef9d90&amp;title=&amp;width=517.6" alt="image.png"><br>饿汉式是随着类加载的时候创建实例，懒汉式是需要使用的时候加载实例，其存在线程安全问题。<br>单例模型的作用就是保证一个类仅有一个实例，并提供一个访问他的全局访问点。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700706716676-6ab8a3ef-5861-4ce4-91f6-245fd1b27351.png#averageHue=%23fdfdfc&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;height=193&amp;id=u637d648b&amp;originHeight=241&amp;originWidth=767&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=15665&amp;status=done&amp;style=none&amp;taskId=u5e56101d-81d2-48ef-b7fd-856c9ec0435&amp;title=&amp;width=613.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700706849042-6c007611-1c2b-4f52-90da-a9c94fffc78c.png#averageHue=%23fdfdfd&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;height=205&amp;id=u9640da3d&amp;originHeight=256&amp;originWidth=782&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=19105&amp;status=done&amp;style=none&amp;taskId=u78b2a3d3-bee2-403e-aaf9-be4b91f2aa6&amp;title=&amp;width=625.6" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正确。如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。这是因为Cloneable接口的clone()方法会创建一个与原始对象相同的对象，并返回该对象。然后，通过调用equals()方法比较两个对象是否相等。在这种情况下，x.clone().equals(x)应该返回<span class="literal">true</span>，表示两个对象相等。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700706972111-6c8fdd16-03a9-418e-a82b-f88896cfe570.png#averageHue=%23fbfbfa&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;height=597&amp;id=u058c683a&amp;originHeight=746&amp;originWidth=773&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=92700&amp;status=done&amp;style=none&amp;taskId=u6bb57ea5-cdf7-4d8d-961f-c308eae3c5c&amp;title=&amp;width=618.4" alt="image.png"><br>建造者模式是将对象的创建和赋值给分离开的模式，这里汽车的反向盘等是可以用其他来替换的；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组合模式是一种用于组合对象以形成树形结构的模式。它允许动态地添加和删除对象，同时保持了对象的层次结构。组合模式使用分层的结构来表示整体和部分的关系，部分可以是另一个整体。组合模式适用于需要对对象进行遍历和访问的情况。  建造者模式是一种用于将对象的不同部分组合成一个完整对象的模式。它将对象的构造过程分离出来，以便可以单独管理和改变这个过程。建造者模式适用于当需要创建复杂对象时，这些对象的构建过程很复杂，很难通过简单的赋值来实现。  总之，组合模式是用于组合对象以形成树形结构的模式，而建造者模式是用于将对象的不同部分组合成一个完整对象的模式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1700707528174-3bda3c28-db60-4c2a-906a-a15947beb8c4.jpeg#averageHue=%23f3f3f3&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;id=u20d69d63&amp;originHeight=353&amp;originWidth=578&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u50d3bb9d-4cc9-40da-9119-a6f68faafa0&amp;title=" alt=""><br>上面的题如果选中组合模式，那么发动机和方向盘都需要实现统一的接口，这在现实世界中是不现实的。<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700708049412-e9aa5ac2-79a7-4e95-baf9-7deef9497438.png#averageHue=%23fefdfb&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;height=276&amp;id=u136816e8&amp;originHeight=345&amp;originWidth=979&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=41507&amp;status=done&amp;style=none&amp;taskId=ubc532f6a-64e2-4297-850e-4e31ec32579&amp;title=&amp;width=783.2" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在原型模式中，每个具体原型类都需要实现一个克隆方法（Clone Method），该方法用于创建并返回当前对象的副本。因此，对于每个类都需要配置一个克隆方法，以便实现原型对象的复制。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700711119870-5a3ce7c3-1de7-45ef-86e2-37f3c23956d2.png#averageHue=%23fdfcfc&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;height=320&amp;id=u87a8c6a6&amp;originHeight=400&amp;originWidth=874&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=29265&amp;status=done&amp;style=none&amp;taskId=u22a581eb-63bb-4eb6-a436-3adcdbb388e&amp;title=&amp;width=699.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700711144922-260b7cb3-d4ec-49d9-b7f6-24bdb127bea9.png#averageHue=%23fdfcfa&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;height=93&amp;id=u0d504d5d&amp;originHeight=116&amp;originWidth=1312&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=37184&amp;status=done&amp;style=none&amp;taskId=u4a000895-c1ba-424b-a761-4f8f9808ed7&amp;title=&amp;width=1049.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700712968147-f962f318-8936-40cb-8ff5-dc293d8562cf.png#averageHue=%23fdfdfc&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;height=288&amp;id=uef8844d5&amp;originHeight=360&amp;originWidth=1089&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=25596&amp;status=done&amp;style=none&amp;taskId=u97971418-71f0-466f-a172-a3a047a8fb1&amp;title=&amp;width=871.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700713803230-7141e0d6-6324-4181-94f8-2e54d2a28308.png#averageHue=%23fefdfd&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;height=380&amp;id=u0572a858&amp;originHeight=475&amp;originWidth=1118&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=44761&amp;status=done&amp;style=none&amp;taskId=udf9de837-6905-418e-96f4-ef5f2e32ca9&amp;title=&amp;width=894.4" alt="image.png"><br>职责链模式是将处理请求传递给下一个处理者。如果上面使用的是职责链模式，那么系统会在判断教师是否满足科研奖后自动继续判断是否教师满足成绩优秀奖；这明显是不符合题目需求的：判断是否符合某个奖项而不是判断能拿哪些奖项。因此这里该使用访问者模式，将某种具体的奖项当成一种数据结构，而判断是否满足当成访问者（数据的操作）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模板方法模式（Template Method Pattern）是一种行为型模式，它定义了一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义算法的某些特定步骤。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700723525624-0ab100c2-2171-49af-ade9-5f22667a30d0.png#averageHue=%23f8f8f7&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;height=229&amp;id=ub8f36951&amp;originHeight=286&amp;originWidth=666&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=21412&amp;status=done&amp;style=none&amp;taskId=u3f86c948-cb95-4f48-86ff-0b6d789c296&amp;title=&amp;width=532.8" alt="image.png"><br>A</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">职责链模式是一种行为型设计模式，用于解决一组对象对同一消息做出响应的问题。职责链模式通过创建一个对象链，使得多个对象都有机会处理请求，从而避免了传统的多分支处理请求的模式。其中，每个对象都有机会处理请求，而客户端只需知道最终处理请求的对象，而不需要了解链上的其他对象。 </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 职责链模式示例代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 职责接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">handleRequest</span><span class="params">(<span class="type">int</span> request)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体职责类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteHandler1</span> <span class="keyword">implements</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handleRequest</span><span class="params">(<span class="type">int</span> request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request &gt;= <span class="number">10</span> &amp;&amp; request &lt;= <span class="number">15</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nextHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nextHandler.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Handler nextHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteHandler2</span> <span class="keyword">implements</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handleRequest</span><span class="params">(<span class="type">int</span> request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request &gt;= <span class="number">5</span> &amp;&amp; request &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nextHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nextHandler.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Handler nextHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">handler1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteHandler1</span>();</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">handler2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteHandler2</span>();</span><br><span class="line">        handler1.setNext(handler2);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> handler1.handleRequest(<span class="number">7</span>);</span><br><span class="line">        System.out.println(result);  <span class="comment">// 输出 true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700723581069-98dd4ecd-3509-450f-879f-23b935828141.png#averageHue=%23faf8f6&amp;clientId=uddc4e6af-e41a-4&amp;from=paste&amp;height=183&amp;id=ud7a18ef8&amp;originHeight=229&amp;originWidth=742&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=31915&amp;status=done&amp;style=none&amp;taskId=ue7ac542e-d83f-4d75-8218-709107a1920&amp;title=&amp;width=593.6" alt="image.png"><br>A</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">产品等级是同一产品族之间的划分，主要是由产品构造类决定的</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/No_Game_No_Life_/article/details/107629644#:~:text=%E6%96%87%</summary>
      
    
    
    
    <category term="课程作业" scheme="http://www.bojiboqi.fun/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="设计模式" scheme="http://www.bojiboqi.fun/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis尚硅谷课件</title>
    <link href="http://www.bojiboqi.fun/2024/02/28/%E5%B0%9A%E7%A1%85%E8%B0%B7_Redis6%E8%AF%BE%E4%BB%B6/"/>
    <id>http://www.bojiboqi.fun/2024/02/28/%E5%B0%9A%E7%A1%85%E8%B0%B7_Redis6%E8%AF%BE%E4%BB%B6/</id>
    <published>2024-02-28T13:02:28.558Z</published>
    <updated>2024-02-28T10:44:05.344Z</updated>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id="框架高级课程系列之Redis6">框架高级课程系列之Redis6</h2><p>尚硅谷JavaEE教研组</p><ol><li><strong>NoSQL数据库简介</strong><ol><li><strong>技术发展</strong></li></ol></li></ol><p>技术的分类<br>1、解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN<br>2、解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis<br>3、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</p><pre><code>  1. **Web1.0时代**</code></pre><p>Web1.0的时代，数据访问量很有限(数据量只是部署到一个服务器中，可是一个服务器的访问量是有上限的），用一夫当关的高性能的单点服务器可以解决大部分问题。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730024175-de0e4e42-179e-4e3b-895e-17700759e95e.png#averageHue=%23f5f5f4&amp;id=bVpXM&amp;originHeight=206&amp;originWidth=625&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **Web2.0时代**</code></pre><p>随着Web2.0的时代的到来，用户访问量大幅度提升，同时产生了大量的用户数据。加上后来的智能移动设备的普及，所有的互联网平台都面临了巨大的性能挑战。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730024434-0ade84eb-da30-4a92-ace5-09cea2dc1024.png#averageHue=%23fbfbf9&amp;id=QgJNI&amp;originHeight=249&amp;originWidth=549&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **解决CPU及内存压力**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730024678-7d3c02dc-2b5c-41d2-b8c9-b877787a94cb.jpeg#averageHue=%23fdfdfb&amp;id=RMHWz&amp;originHeight=412&amp;originWidth=612&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **解决IO压力**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730024920-7b0502f1-7db6-46a2-b691-dde5d51cfec8.jpeg#averageHue=%23ecdac9&amp;id=iztPi&amp;originHeight=395&amp;originWidth=534&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>NoSQL数据库</strong><ol><li><strong>NoSQL数据库概述</strong></li></ol></li></ol><p>NoSQL(NoSQL = <strong>Not Only SQL</strong> )，意即“不仅仅是SQL”，泛指<strong>非关系型的数据库</strong>。<br>NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。</p><ul><li><p>不遵循SQL标准。</p></li><li><p>不支持ACID。</p></li><li><p>远超于SQL的性能。<br>1. **NoSQL适用场景 **</p></li><li><p>对数据高并发的读写</p></li><li><p>海量数据的读写</p></li><li><p>对数据高可扩展性的<br>1. <strong>NoSQL不适用场景</strong></p></li><li><p>需要事务支持</p></li><li><p>基于sql的结构化查询存储，处理复杂的关系,需要即席查询。</p></li><li><p><strong>（用不着sql的和用了sql也不行的情况，请考虑用NoSql）</strong><br>1. <strong>Memcache</strong><br>| <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730025094-1199db9b-a0b2-4ad7-86d8-c2d6f03e7b47.jpeg#averageHue=%237a7771&amp;id=kcfXq&amp;originHeight=81&amp;originWidth=78&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""> |</p></li><li><p>很早出现的NoSql数据库</p></li><li><p>数据都在内存中，一般不持久化</p></li><li><p>支持简单的key-value模式，支持类型单一</p></li><li><p>一般是作为缓存数据库辅助持久化的数据库<br>|<br>| — | — |</p><pre><code>1. **Redis**</code></pre></li></ul><p>| <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730025274-325bc689-39ae-48c4-b6bc-3994276b632d.jpeg#averageHue=%23583b39&amp;id=Kyfuz&amp;originHeight=58&amp;originWidth=157&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""> |</p><ul><li><p>几乎覆盖了Memcached的绝大部分功能</p></li><li><p>数据都在内存中，支持持久化，主要用作备份恢复</p></li><li><p>除了支持简单的key-value模式，还支持多种数据结构的存储，比如 list、set、hash、zset等。</p></li><li><p>一般是作为缓存数据库辅助持久化的数据库<br>|<br>| — | — |</p><pre><code>1. **MongoDB**</code></pre></li></ul><p>| <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730025458-d1ba96a0-c4b1-4d64-8c1b-19dfaca31068.jpeg#averageHue=%23353638&amp;id=xvUtK&amp;originHeight=60&amp;originWidth=172&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>  |</p><ul><li><p>高性能、开源、模式自由(schema  free)的<strong>文档型数据库</strong></p></li><li><p>数据都在内存中， 如果内存不足，把不常用的数据保存到硬盘</p></li><li><p>虽然是key-value模式，但是对value（尤其是<strong>json</strong>）提供了丰富的查询功能</p></li><li><p>支持二进制数据及大型对象</p></li><li><p>可以根据数据的特点<strong>替代RDBMS</strong> ，成为独立的数据库。或者配合RDBMS，存储特定的数据。<br>|<br>| — | — |</p><ol><li><strong>行式存储数据库（大数据时代）</strong><ol><li><strong>行式数据库</strong></li></ol></li></ol></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730025714-33f52a5c-1350-4b6a-b103-4390136ce59a.jpeg#averageHue=%23fefefc&amp;id=aR4FU&amp;originHeight=294&amp;originWidth=614&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **列式数据库**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730025979-8afc701f-d64a-4b50-b1af-29add5d7ef85.jpeg#averageHue=%23fefefc&amp;id=To3RC&amp;originHeight=297&amp;originWidth=615&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>     1. **Hbase**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730026188-acabbd4f-c8b9-487d-a7c7-4c56f3e7ec94.jpeg#averageHue=%23e0bbb8&amp;id=p0QYN&amp;originHeight=68&amp;originWidth=197&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>HBase是<strong>Hadoop</strong>项目中的数据库。它用于需要对大量的数据进行随机、实时的读写操作的场景中。<br>HBase的目标就是处理数据量<strong>非常庞大</strong>的表，可以用<strong>普通的计算机</strong>处理超过<strong>10亿行数据</strong>，还可处理有数百万<strong>列</strong>元素的数据表。</p><pre><code>     1. **Cassandra[kəˈsændrə]**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730026415-e41587d3-9c91-4657-a9da-ae4d12dc7b51.jpeg#averageHue=%2396be5e&amp;id=ZYRSN&amp;originHeight=79&amp;originWidth=316&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>Apache Cassandra是一款免费的开源NoSQL数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的<strong>海量数据集(数据量通常达到PB级别)</strong>。在众多显著特性当中，Cassandra最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程。</p><p>| 计算机存储单位 计算机存储单位一般用B，KB，MB，GB，TB，EB，ZB，YB，BB来表示，它们之间的关系是：<br>位 bit (比特)(Binary Digits)：存放一位二进制数，即 0 或 1，最小的存储单位。<br>字节 byte：8个二进制位为一个字节(B)，最常用的单位。<br>1KB (Kilobyte 千字节)=1024B，<br>1MB (Megabyte 兆字节 简称“兆”)=1024KB，<br>1GB (Gigabyte 吉字节 又称“千兆”)=1024MB，<br>1TB (Trillionbyte 万亿字节 太字节)=1024GB，其中1024=2^10 ( 2 的10次方)，<br>1PB（Petabyte 千万亿字节 拍字节）=1024TB，<br>1EB（Exabyte 百亿亿字节 艾字节）=1024PB，<br>1ZB (Zettabyte 十万亿亿字节 泽字节)= 1024 EB,<br>1YB (Jottabyte 一亿亿亿字节 尧字节)= 1024 ZB,<br>1BB (Brontobyte 一千亿亿亿字节)= 1024 YB.</p><table><thead><tr><th>注：“兆”为百万级数量单位。</th></tr></thead></table><ol><li><strong>图关系型数据库</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730026617-54037f85-76e9-436a-a371-2025ee7eb66e.jpeg#averageHue=%23256d7e&amp;id=lVgOG&amp;originHeight=45&amp;originWidth=184&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>主要应用：社会关系，公共交通网络，地图及网络拓谱(n*(n-1)/2)<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730026840-d4e86748-4ccc-492d-bb02-a042f37e3178.jpeg#averageHue=%23fcfcfc&amp;id=Qe1bj&amp;originHeight=374&amp;originWidth=614&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>DB-Engines 数据库排名</strong></li></ol><p><a href="http://db-engines.com/en/ranking"><strong>http://db-engines.com/en/ranking</strong></a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730027053-000a8467-9e14-4d82-9d9b-67acd902b0bf.png#averageHue=%23f4f1f1&amp;id=KR0mx&amp;originHeight=529&amp;originWidth=1030&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>Redis概述安装</strong></li></ol><ul><li>Redis是一个开源的key-value存储系统。</li><li>和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。</li><li>这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</li><li>在此基础上，Redis支持各种不同方式的排序。</li><li>与memcached一样，为了保证效率，数据都是缓存在内存中。</li><li>区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</li><li>并且在此基础上实现了master-slave(主从)同步。<ol><li><strong>应用场景</strong><ol><li><strong>配合关系型数据库做高速缓存</strong></li></ol></li></ol></li><li>高频次，热门访问的数据，降低数据库IO</li><li>分布式架构，做session共享</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730027296-d0ed1746-398d-4ad6-a069-95a13289b15e.jpeg#averageHue=%23fefefe&amp;id=ytubD&amp;originHeight=288&amp;originWidth=612&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **多样的数据结构存储持久化数据**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730027552-e85a412b-f826-4aeb-90f4-3d3938f57f33.jpeg#averageHue=%23f6e1b3&amp;id=BvZuL&amp;originHeight=259&amp;originWidth=589&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>Redis安装</strong><br>| Redis官方网站 | Redis中文官方网站 |<br>| — | — |<br>| <a href="http://redis.io"><strong>http://redis.io</strong></a> | <a href="http://redis.cn/">http://redis.cn/</a> |</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730027790-fc5e341b-4503-46d1-be3d-25f94aa9768d.png#averageHue=%23d8d7d7&amp;id=ZUvxl&amp;originHeight=520&amp;originWidth=904&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730028065-2e2e9d14-3fa4-4681-b917-8fb752aaec0a.png#averageHue=%23e7e6e5&amp;id=cNR9K&amp;originHeight=602&amp;originWidth=868&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **安装版本**</code></pre><ul><li>6.2.1 for Linux（redis-6.2.1.tar.gz）</li><li>不用考虑在windows环境下对Redis的支持</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730028304-e77217ee-2e83-47d8-b3d7-113d77246779.jpeg#averageHue=%23e3e1dc&amp;id=AXZed&amp;originHeight=62&amp;originWidth=618&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **安装步骤**     1. **准备工作：下载安装最新版的gcc编译器**</code></pre><p>安装C 语言的编译环境<br><strong>yum install centos-release-scl scl-utils-build</strong><br><strong>yum install -y devtoolset-8-toolchain</strong><br><strong>scl enable devtoolset-8 bash</strong><br>**测试 gcc版本 **<br><strong>gcc --version</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730028505-f0f903ef-6226-47d3-b2ca-0e33aaf8c6e4.png#averageHue=%23110d09&amp;id=l2q01&amp;originHeight=95&amp;originWidth=724&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>     1. **下载redis-6.2.1.tar.gz放/opt目录**     2. **解压命令：tar -zxvf redis-6.2.1.tar.gz**     3. **解压完成后进入目录：cd redis-6.2.1**     4. **在redis-6.2.1目录下再次执行make命令（只是编译好）**     5. **如果没有准备好C语言编译环境，make 会报错—Jemalloc/jemalloc.h：没有那个文件**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730028763-7c216a0e-fd7c-439c-b8f4-3e83a3176204.jpeg#averageHue=%230b0908&amp;id=qjmPY&amp;originHeight=235&amp;originWidth=610&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>     1. **解决方案：运行make distclean**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730029022-e087da3f-8cfa-43c0-b7ab-f21c02ebb5f6.jpeg#averageHue=%23080706&amp;id=K3tab&amp;originHeight=165&amp;originWidth=613&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>     1. **在redis-6.2.1目录下再次执行make命令（只是编译好）**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730029271-b5265504-b824-449e-b6d9-9ce0cac16298.jpeg#averageHue=%230d0a06&amp;id=ZqZ35&amp;originHeight=234&amp;originWidth=311&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>     1. **跳过make test 继续执行: make install**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730029545-606e6f99-0021-4103-a63b-19121e66c882.jpeg#averageHue=%23584f46&amp;id=KtAlt&amp;originHeight=204&amp;originWidth=382&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **安装目录：/**usr/local/bin</code></pre><p>查看默认安装目录：<br>redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何<br>redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲<br>redis-check-dump：修复有问题的dump.rdb文件<br>redis-sentinel：Redis集群使用<br>redis-server：Redis服务器启动命令<br>redis-cli：客户端，操作入口</p><pre><code>  1. **前台启动（不推荐）**</code></pre><p>前台启动，命令行窗口不能关闭，否则服务器停止<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730029828-3bb4bd46-5323-4e46-b477-60de7a51a16f.jpeg#averageHue=%23443f39&amp;id=pNpen&amp;originHeight=441&amp;originWidth=619&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **后台启动（推荐）**     1. **备份redis.conf**</code></pre><p>拷贝一份redis.conf到其他目录<br>cp  /opt/redis-3.2.5/redis.conf  /myredis</p><pre><code>     1. **后台启动设置daemonize no改成yes**</code></pre><p>修改redis.conf(128行)文件将里面的daemonize no 改成 yes，让服务在后台启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Redis daemonize介绍</span><br><span class="line"></span><br><span class="line">1、daemonize介绍</span><br><span class="line"></span><br><span class="line">A、redis.conf配置文件中daemonize守护线程，默认是NO。</span><br><span class="line">B、daemonize是用来指定redis是否要用守护线程的方式启动。</span><br><span class="line">2、daemonize 设置yes或者no区别</span><br><span class="line"></span><br><span class="line">daemonize:yes:redis采用的是单进程多线程的模式。当redis.conf中选项</span><br><span class="line">daemonize设置成yes时，代表开启守护进程模式。在该模式下，</span><br><span class="line">redis会在后台运行，并将进程pid号写入至redis.conf选项pidfile</span><br><span class="line">设置的文件中，此时redis将一直运行，除非手动kill该进程。（有时候手动</span><br><span class="line">杀死了redis进程但是用ps -ef | grep redis 发现又以新的pid重启了，那</span><br><span class="line">可能是有父进程自动生成了redis进程。这个时候可以使用</span><br><span class="line">service redis-server stop命令关闭redis进程同时让父进程无法重启redis</span><br><span class="line">进程）。service redis-server stop命令会保存内存中的数据到磁盘上，</span><br><span class="line">然后关闭。解决无法关闭redis的方法2:</span><br><span class="line"></span><br><span class="line">daemonize:no: 当daemonize选项设置成no时，当前界面将进入redis</span><br><span class="line">的命令行界面，exit强制退出或者关闭连接工具(putty,xshell等)都</span><br><span class="line">会导致redis进程退出。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis中的daemonize配置为yes时，表示开启守护进程模式，redis会在后台运行，</span><br><span class="line">并将进程pid号写入至redis.conf选项pidfile设置的文件中，此时redis将一直运</span><br><span class="line">行，除非手动kill该进程</span><br><span class="line">如果你想要杀死redis进程，你可以先用ps -ef | grep redis-server命令</span><br><span class="line">找到redis的进程号，然后用sudo kill &lt;pid&gt;命令强制终止该进程</span><br><span class="line">如果你发现redis进程被重启了，可能是因为有其他的父进程在监控它，</span><br><span class="line">你可以用ps -o ppid= &lt;pid&gt;命令查看是否有父进程存在，</span><br><span class="line">如果有，你也需要杀死父进程</span><br></pre></td></tr></table></figure><pre><code>     1. **Redis启动**</code></pre><p>redis-server/myredis/redis.conf<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730030045-794a9dd4-34b6-457a-9354-349986f54973.jpeg#averageHue=%23504a41&amp;id=evehi&amp;originHeight=70&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>     1. **用客户端访问：redis-cli**</code></pre><ol><li></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730030271-7201ddb3-8d85-46f3-a8c9-cc0a74976dbd.jpeg#averageHue=%23395a32&amp;id=C6OLI&amp;originHeight=41&amp;originWidth=218&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>     1. **多个端口可以：redis-cli -p6379**</code></pre><p><a href="https://www.cnblogs.com/kongzhongqijing/p/6867960.html">redis cli命令 - milkty - 博客园</a></p><pre><code>     2. **测试验证： ping**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730030475-37d148f6-3826-4a8e-b952-d09b8b6404ea.jpeg#averageHue=%23635a4d&amp;id=RecC7&amp;originHeight=38&amp;originWidth=193&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>     1. **Redis关闭**</code></pre><p>单实例关闭：redis-cli shutdown<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730030719-2395f73a-ba68-46e1-b311-07705f9fc5c5.jpeg#averageHue=%234f473f&amp;id=xhvma&amp;originHeight=68&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>也可以进入终端后再关闭<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730030957-49053f95-1d0d-40b6-ac2f-b1c8c7941dff.jpeg#averageHue=%23676054&amp;id=QlgGg&amp;originHeight=41&amp;originWidth=231&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>多实例关闭，指定端口关闭：redis-cli -p 6379 shutdown<br>也可以找到redis的进程号然后用kill -9 pid杀掉也可以。</p><pre><code>  1. **Redis介绍相关知识**</code></pre><p>| 端口6379从何而来<br>Alessia  Merz<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730031186-7ab5b215-6ce9-4ce7-abb8-d9cce1f5422e.jpeg#averageHue=%237c7362&amp;id=aDfhF&amp;originHeight=72&amp;originWidth=136&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""> | 默认16个数据库，类似数组下标从0开始，初始默认使用0号库<br>使用命令 select   <dbid>来切换数据库。如: select 8<br>统一密码管理，所有库同样密码。<br>dbsize查看当前数据库的key的数量<br>flushdb清空当前库<br>flushall通杀全部库 |<br>| — | — |</p><p>Redis是单线程+多路IO复用技术<br>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）<br>串行   vs   多线程+锁（memcached） vs   单线程+多路IO复用(Redis)<br>（与Memcache三点不同: 支持多数据类型，支持持久化，单线程+多路IO复用）<br><img src="https://cdn.nlark.com/yuque/0/2023/gif/28066124/1693730031481-b7e58f7f-b4d9-4945-9a5d-ed8c0b68742a.gif#averageHue=%23f8f6f6&amp;id=MKIQH&amp;originHeight=119&amp;originWidth=400&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693795465201-5ba384c5-5020-4e21-8c5b-8f44ace04a47.png#averageHue=%23fefdfa&amp;clientId=uab116c27-7b29-4&amp;from=paste&amp;height=306&amp;id=uef5e8a80&amp;originHeight=383&amp;originWidth=686&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=54293&amp;status=done&amp;style=none&amp;taskId=u816f3de5-a661-48c5-95b1-d89f347cf1f&amp;title=&amp;width=548.8" alt="image.png"></p><ol><li><strong>常用五大数据类型</strong></li></ol><p>哪里去获得redis常见数据类型操作命令<a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p><ol><li><strong>Redis键(key)</strong></li></ol><p>keys *查看当前库所有key    (匹配：keys *1)<br>exists key判断某个key是否存在（返回为1就存在，返回为0就不存在）<br>type key 查看你的key是什么类型（使用set 10 10 设置的值key仍旧是string)<br>del key       删除指定的key数据<br>unlink key   根据value选择非阻塞删除(异步删除，并不是在执行命令的时候就删除了数据）<br>仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。<br>expire key 10   10秒钟：为给定的key设置过期时间（过期的 key 会被自动删除，不再可用。）<br>ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期，返回的正数表示还有多少s过期。</p><p>select命令切换数据库<br>dbsize查看当前数据库的key的数量<br>flushdb清空当前库<br>flushall通杀全部库</p><ol><li><strong>Redis字符串(String)</strong><ol><li><strong>简介</strong></li></ol></li></ol><p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。<br>String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。<br>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</p><pre><code>  1. **常用命令**</code></pre><p>set   <key><value>添加键值对<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730031776-944ce1d5-008e-44e0-8684-91a112c09a7a.png#averageHue=%230d0b0a&amp;id=JGNaN&amp;originHeight=35&amp;originWidth=972&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>*NX：当数据库中key不存在时，可以将key-value添加数据库<br>*XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥<br>*EX：key的超时秒数<br>*PX：key的超时毫秒数，与EX互斥</p><p>get   <key>查询对应键值<br>append  <key><value>将给定的<value> 追加到原值的末尾（返回值是追加后的value字符串的长度）<br>strlen  <key>获得值的长度<br>setnx  <key><value>只有在 key 不存在时    设置 key 的值（如果key存在时，无法覆盖原来的key)</p><p>incr  <key><br>将 key 中储存的数字值增1<br>只能对数字值操作，如果为空，新增值为1<br>decr  <key><br>将 key 中储存的数字值减1<br>只能对数字值操作，如果为空，新增值为-1<br>incr和decr的返回值都是加1减1的结果。<br>incrby / decrby  <key>&lt;步长&gt;将 key 中储存的数字值增减。自定义步长。（返回值也是增加或者减少后的值）</p><p>| 原子性<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730032028-b7a90996-a232-4807-a889-8e0c4f807ed2.jpeg#averageHue=%23f4f3f2&amp;id=aBiOH&amp;originHeight=138&amp;originWidth=244&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>所谓<strong>原子</strong>操作是指不会被线程调度机制打断的操作；<br>这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。<br>（1）在单线程中， 能够在单条指令中完成的操作都可以认为是&quot;原子操作&quot;，因为中断只能发生于指令之间。<br>（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。<br>Redis单命令的原子性主要得益于Redis的单线程。<br><strong>案例：</strong><br>java中的i++是否是原子操作？不是<strong>不是</strong></p><table><thead><tr><th>i=0;两个线程分别对i进行++100次,值是多少？不确定（2 -200）** 2~200**</th></tr></thead></table><p>mset  <key1><value1><key2><value2>  …<br>同时设置一个或多个 key-value对<br>mget  <key1><key2><key3> …<br>同时获取一个或多个 value<br>msetnx <key1><value1><key2><value2>  …<br>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。<br><strong>原子性，有一个失败则都失败（添加key和value失败）</strong></p><p>getrange  <key>&lt;起始位置&gt;&lt;结束位置&gt;<br>获得值的范围，类似java中的substring，<strong>前包，后包（其中的value的第一个值的索引是0）</strong><br>setrange  <key>&lt;起始位置&gt;<value><br>用 <value>  覆写<key>所储存的字符串值，从&lt;起始位置&gt;开始(<strong>索引从0开始</strong>)。</p><p><strong>setex  <key>&lt;过期时间&gt;<value></strong><br>设置键值的同时，设置过期时间，单位秒。<br>getset <key><value><br>以新换旧，设置了新值同时获得旧值。（就是该命令返回值是旧key的值，同时在返回的时候覆盖key的value下次访问key的时候，value就是更改后的值了）</p><pre><code>  1. **数据结构**</code></pre><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730032225-8d06e5d3-1805-4a7e-b541-a20f72392afa.png#averageHue=%23fdf8f4&amp;id=zgqOF&amp;originHeight=121&amp;originWidth=666&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p><ol><li><strong>Redis列表(List)</strong><ol><li><strong>简介</strong></li></ol></li></ol><p>单键多值<br>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。<br>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730032474-62d4cc76-7c20-41cb-9f95-fda5515498c1.jpeg#averageHue=%23fefefc&amp;id=ykK7q&amp;originHeight=92&amp;originWidth=614&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **常用命令**</code></pre><p>lpush/rpush  <key><value1><value2><value3> … 从左边/右边插入一个或多个值。（这里的从左右插入数据，是后面的数据在前面的数据的左边或者右边）<br>lpop/rpop  <key>从左边/右边吐出一个值。值在键在，值光键亡。</p><p>rpoplpush  <key1><key2>从<key1>列表右边吐出一个值，插到<key2>列表左边。</p><p>lrange <key><start><stop><br>按照索引下标获得元素(从左到右)<br>lrange mylist 0 -1   0左边第一个，-1右边第一个，（0-1表示获取所有）<br>lindex <key><index>按照索引下标获得元素(从左到右)<br>llen <key>获得列表长度</p><p>linsert <key>  before <value><newvalue>在<value>的后面插入<newvalue>插入值<br>lrem <key><n><value>从左边删除n个value(从左到右)<br>lset<key><index><value>将列表key下标为index的值替换成value</p><pre><code>  1. **数据结构**</code></pre><p>List的数据结构为快速链表quickList。<br>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。<br>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。<br>当数据量比较多的时候才会改成quicklist。<br>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730032728-a57a2672-9ab9-4127-ac84-260498627670.png#averageHue=%23f1f6fa&amp;id=gpMLd&amp;originHeight=78&amp;originWidth=748&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><ol><li><strong>Redis集合(Set)</strong><ol><li><strong>简介</strong></li></ol></li></ol><p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以<strong>自动排重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。<br>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的<strong>复杂度都是O(1)</strong>。<br>一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变</p><pre><code>  1. **常用命令**</code></pre><p>sadd <key><value1><value2> …<br>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略（返回值是添加成功的个数）<br>smembers <key>取出该集合的所有值。<br>sismember <key><value>判断集合<key>是否为含有该<value>值，有1，没有0<br>scard<key>返回该集合的元素个数。<br>srem <key><value1><value2> … 删除集合中的某个元素。（返回值是成功删除的个数）<br>spop <key><strong>随机从该集合中吐出一个值。（这里的吐出一个值表示从set集合删除一个数）</strong><br>srandmember <key><n>随机从该集合中取出n个值。不会从集合中删除 。<br>smove <source><destination>value把集合中一个值从一个集合移动到另一个集合<br>sinter <key1><key2>返回两个集合的交集元素。（但是并不会删除元素）<br>sunion <key1><key2>返回两个集合的并集元素。（也是一样不会删除颜色）<br>sdiff <key1><key2>返回两个集合的<strong>差集</strong>元素(key1中的，不包含key2中的)会改变k1中的集合。（k1的集合是查缉的元素）<br>sinter  sunion   sdiff 其实就是集合的运算而已。</p><pre><code>  1. **数据结构**</code></pre><p>Set数据结构是dict字典，字典是用哈希表实现的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ict 字典是指 Python 语言中的一种数据类型，它是一种可变的、无序的、可存储任意类型对象的容器。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">这里所说的所有的 value 都指向同一个内部值，是指 Redis 的 set 结构中，</span><br><span class="line">每个元素的 value 都是一个特殊的常量，叫做 REDIS_SHARED_INTEGERS ，</span><br><span class="line">它是一个包含 0 到 9999 的整数数组，用于节省内存空间。</span><br><span class="line">https://redis.io/commands/set/https://www.runoob.com/redis/strings-set.html</span><br><span class="line"></span><br><span class="line">也就是说，Redis 的 set 结构中，每个元素的 key 是实际存储的字符串值，</span><br><span class="line">而每个元素的 value 都是 REDIS_SHARED_INTEGERS[0] ，这个值在内存中</span><br><span class="line">只有一份，所有的 set 元素都共享它。</span><br><span class="line">https://redis.io/commands/set/https://www.runoob.com/redis/strings-set.html</span><br><span class="line"></span><br><span class="line">这样做的好处是，Redis 可以用 hash 结构来实现 set 的功能，</span><br><span class="line">而不需要额外分配内存空间来存储每个元素的 value </span><br></pre></td></tr></table></figure><ol><li><strong>Redis哈希(Hash)</strong><ol><li><strong>简介</strong></li></ol></li></ol><p>Redis hash 是一个键值对集合。<br>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。<br>类似Java里面的Map&lt;String,Object&gt;<br>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储<br>主要有以下2种存储方式：</p><p>| <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730032990-9e5593f0-4887-4ab7-ac65-8df3fd71ea0e.jpeg#averageHue=%23fcfdf9&amp;id=K6svc&amp;originHeight=161&amp;originWidth=271&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>每次修改用户的某个属性需要，先反序列化改好后再序列化回去。开销较大。 | <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730033258-17c5c182-f458-4034-92ce-18cd2b9d6faa.jpeg#averageHue=%23ececec&amp;id=VzaaA&amp;originHeight=156&amp;originWidth=277&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>用户ID数据冗余 |<br>| — | — |</p><p>| <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730033537-c99a4769-d614-44a1-81d9-f4bc881c84ce.jpeg#averageHue=%23f8f9f5&amp;id=TC7nl&amp;originHeight=151&amp;originWidth=320&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><table><thead><tr><th><strong>通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题</strong></th></tr></thead></table><pre><code>  1. **常用命令**</code></pre><p>hset <key><field><value>:给<key>集合中的  <field>键赋值<value></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> hset user:10 id 1</span><br><span class="line">给hash中添加一个key为user，fild为id，value为1的对象.如果存储的值为中文的</span><br><span class="line">话取出会有问题的</span><br></pre></td></tr></table></figure><p>hget <key1><field>:从<key1>集合<field>取出 value  eg: hget user:10 name<br>hmset <key1><field1><value1><field2><value2>… ：批量设置hash的值 eg:<br>hmset user:11 id 2 name lishi age 40<br>hexists<key1><field>查看哈希表 key 中，给定域 field 是否存在，存在返回1，不存在返回0。 eg: hexists user:10 id<br>判断user为10中是否存在id的field。<br>hkeys <key>列出该hash集合的所有field<br>hvals <key>列出该hash集合的所有value<br>hincrby <key><field><increment>：为哈希表 key 中的域 field 的值加上增量，返回值是fileld增加后的值。<br>hsetnx <key><field><value>将哈希表 key 中的域 中添加为 value的field ，当且仅当域 field 不存在时才能添加成功 .</p><pre><code>  1. **数据结构**</code></pre><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p><ol><li>**Redis有序集合Zset(sorted set) **<ol><li><strong>简介</strong></li></ol></li></ol><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。<br>不同之处是有序集合的每个成员都关联了一个<strong>评分（score）</strong>,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。<br>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。<br>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p><pre><code>  1. **常用命令**</code></pre><p>zadd  <key><score1><value1><score2><value2>…<br>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。<br>**zrange <key><start><stop>  [WITHSCORES]   **<br>返回有序集 key 中，下标在<start><stop>之间的元素<br>带WITHSCORES，可以让分数一起和值返回到结果集。<br>zrangebyscore key minmax [withscores] [limit offset count]<br>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。<br>zrevrangebyscore key maxmin [withscores] [limit offset count]<br>同上，改为从大到小排列。<br>zincrby <key><increment><value>      为元素的score加上增量<br>zrem  <key><value>删除该集合下，指定值的元素<br>zcount <key><min><max>统计该集合，分数区间内的元素个数<br>zrank <key><value>返回该值在集合中的排名，从0开始。<br>案例：如何利用zset实现一个文章访问量的排行榜？<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730033775-1fc94010-b543-452e-87d5-6894662bf634.jpeg#averageHue=%23060605&amp;id=Oe0tL&amp;originHeight=172&amp;originWidth=451&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693831031687-92c85b21-af19-4cff-b7ed-8558e780aaf7.png#averageHue=%23323a7b&amp;clientId=u937b6ec7-0521-4&amp;from=paste&amp;height=709&amp;id=u3d405017&amp;originHeight=886&amp;originWidth=1549&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=1497218&amp;status=done&amp;style=none&amp;taskId=u997b05f6-e2cc-4eb9-b1cf-74049528801&amp;title=&amp;width=1239.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693831423299-38eeba85-6ba5-49e0-a377-c4291397ccce.png#averageHue=%23383069&amp;clientId=u937b6ec7-0521-4&amp;from=paste&amp;height=464&amp;id=u0219068c&amp;originHeight=580&amp;originWidth=1175&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=700443&amp;status=done&amp;style=none&amp;taskId=u7e67e8ec-1c7d-4a5d-8da9-990740ef1b9&amp;title=&amp;width=940" alt="image.png"></p><pre><code>  1. **数据结构**</code></pre><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。<br>zset底层使用了两个数据结构<br>（1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。<br>（2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</p><pre><code>  1. **跳跃表（跳表）**</code></pre><p>1、简介<br>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。<br>2、实例<br>对比有序链表和跳跃表，从链表中查询出51</p><ol><li>有序链表</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730034017-e622ecb5-18ab-4430-aaed-bacc99ffdf92.png#averageHue=%23d5d5d4&amp;id=kTuYG&amp;originHeight=53&amp;originWidth=737&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p><ol><li>跳跃表</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730034386-79f4163c-95b0-4766-9ffa-fe70a3da037a.png#averageHue=%23e2e1e1&amp;id=OvSb1&amp;originHeight=228&amp;originWidth=778&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>从第2层开始，1节点比51节点小，向后比较。<br>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层<br>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下<br>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p><p>从此可以看出跳跃表比有序链表效率要高<br><a href="https://zhuanlan.zhihu.com/p/260075092">跳跃表详解</a></p><ol><li><strong>Redis配置文件介绍</strong></li></ol><p>自定义目录：/myredis/redis.conf</p><ol><li>**###Units单位### **</li></ol><p>配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit<br>大小写不敏感<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730034656-ba811a1d-4d97-402f-8c91-3c2edfcbc1a0.jpeg#averageHue=%23433e20&amp;id=HtasJ&amp;originHeight=297&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>###INCLUDES包含###</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730035011-c2232a6e-ac70-47b4-9c82-0dde4f477c8d.jpeg#averageHue=%23121106&amp;id=VgJME&amp;originHeight=250&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>类似jsp中的include，多实例的情况可以把公用的配置文件提取出来</p><ol><li><strong>###网络相关配置 ###</strong><ol><li><strong>bind</strong></li></ol></li></ol><p>默认情况bind=127.0.0.1只能接受本机的访问请求<br>不写的情况下，无限制接受任何ip地址的访问<br>生产环境肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要将其注释掉<br>如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730035267-6c663b0c-3c59-45f4-90ab-3ce0f7fee46d.jpeg#averageHue=%23121105&amp;id=HCbik&amp;originHeight=324&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>保存配置，停止服务，重启启动查看进程，不再是本机访问了。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730035537-13ecade4-af50-4ba3-bffc-6db989132305.jpeg#averageHue=%230e0b0a&amp;id=bF83z&amp;originHeight=115&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **protected-mode**</code></pre><p>将本机访问保护模式设置no<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730035811-d33ade2e-e632-42e6-983a-0cda31729d0b.jpeg#averageHue=%23141408&amp;id=iWb21&amp;originHeight=282&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **Port**</code></pre><p>端口号，默认 6379<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730036042-accb83bb-44e4-4823-914f-5ce7a9d5b7d0.jpeg#averageHue=%2319190c&amp;id=AFndT&amp;originHeight=49&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **tcp-backlog**</code></pre><p>设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。<br>在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。<br>注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值（128），所以需要确认增大/proc/sys/net/core/somaxconn和/proc/sys/net/ipv4/tcp_max_syn_backlog（128）两个值来达到想要的效果<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730036258-460d724a-fdc6-44f4-ae8e-bf1cb61d6206.jpeg#averageHue=%23181709&amp;id=mzQHJ&amp;originHeight=123&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **timeout**</code></pre><p>一个空闲的客户端维持多少秒会关闭，0表示关闭该功能。即永不关闭。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730036579-56d82572-9069-4270-a220-c1ae349220e7.jpeg#averageHue=%233f3918&amp;id=uJCD5&amp;originHeight=172&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **tcp-keepalive**</code></pre><p>对访问客户端的一种心跳检测，每个n秒检测一次。<br>单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730036855-e756b5c6-337a-46c7-9e45-437a9e839122.jpeg#averageHue=%233b3616&amp;id=oa00J&amp;originHeight=238&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>###GENERAL通用###</strong><ol><li><strong>daemonize</strong></li></ol></li></ol><p>是否为后台进程，设置为yes<br>守护进程，后台启动<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730037109-0c0be9df-1f8a-415e-b6cf-a29983811cec.jpeg#averageHue=%231b1b0d&amp;id=vJVEz&amp;originHeight=47&amp;originWidth=607&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **pidfile**</code></pre><p>存放pid文件的位置，每个实例会产生一个不同的pid文件<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730037384-bb32e365-75ec-4f41-b5c5-95960eabde47.jpeg#averageHue=%23171709&amp;id=FE36Z&amp;originHeight=151&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **loglevel **</code></pre><p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为<strong>notice</strong><br>四个级别根据使用阶段来选择，生产环境选择notice 或者warning<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730037735-a056dc8c-7e81-4f07-898b-7821baff9e59.jpeg#averageHue=%2319190a&amp;id=ABUFP&amp;originHeight=112&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **logfile **</code></pre><p>日志文件名称<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730037986-95002380-8b6a-4856-915c-e7439c59cbd2.jpeg#averageHue=%230d0e04&amp;id=ZZEqN&amp;originHeight=66&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **databases 16 **</code></pre><p>设定库的数量 默认16，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730038238-3a52dc70-2dc6-46cd-aff3-15695bf3bb31.jpeg#averageHue=%231b1a0e&amp;id=NAV13&amp;originHeight=60&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>###SECURITY安全###</strong><ol><li><strong>设置密码</strong></li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730038485-b721f0bf-38ca-4a40-9eaf-56f55f1e7ad1.jpeg#averageHue=%23161507&amp;id=YZ4fD&amp;originHeight=206&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>访问密码的查看、设置和取消<br>在命令中设置密码，只是临时的。重启redis服务器，密码就还原了。<br>永久设置，需要再配置文件中进行设置。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730038741-02fe699c-751b-4a4e-938f-7d1d4b4daf9e.jpeg#averageHue=%23f8f3f3&amp;id=G7UGU&amp;originHeight=356&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>#### LIMITS限制 ###</strong><ol><li><strong>maxclients</strong></li></ol></li></ol><ul><li>设置redis同时可以与多少个客户端进行连接。</li><li>默认情况下为10000个客户端。</li><li>如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730039000-f90e6ed1-eba5-4226-b9b5-50017f44ffda.jpeg#averageHue=%23111107&amp;id=oWW5t&amp;originHeight=151&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **maxmemory **</code></pre><ul><li>建议<strong>必须设置</strong>，否则，将内存占满，造成服务器宕机</li><li>设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。</li><li>如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。</li><li>但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730039266-f1e3c844-46e9-49db-9ba6-c739649153f3.jpeg#averageHue=%23070802&amp;id=jGg2L&amp;originHeight=350&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **maxmemory-policy**</code></pre><ul><li>volatile-lru：使用LRU算法移除key，只对设置了过期时间的键；（最近最少使用）</li><li>allkeys-lru：在所有集合key中，使用LRU算法移除key</li><li>volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键</li><li>allkeys-random：在所有集合key中，移除随机的key</li><li>volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key</li><li>noeviction：不进行移除。针对写操作，只是返回错误信息</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730039585-06e1a32b-282f-424b-91e0-51c8e44825d2.jpeg#averageHue=%23181707&amp;id=BQlIS&amp;originHeight=348&amp;originWidth=616&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **maxmemory-samples**</code></pre><ul><li>设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个。</li><li>一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730039834-216147c3-2b02-488c-8c31-e35b22d07085.jpeg#averageHue=%23131206&amp;id=tHMcu&amp;originHeight=153&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>Redis的发布和订阅</strong><ol><li><strong>什么是发布和订阅</strong></li></ol></li></ol><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。<br>Redis 客户端可以订阅任意数量的频道。</p><ol><li><strong>Redis的发布和订阅</strong></li></ol><p>1、客户端可以订阅频道如下图<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730040062-c5a4d2ce-fa30-4c07-ad84-6ce4421511db.png#averageHue=%23e7ebd9&amp;id=jba6O&amp;originHeight=214&amp;originWidth=516&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>2、当给这个频道发布消息后，消息就会发送给订阅的客户端<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730040377-91b7001c-de87-47f5-9971-e1b500f6feaf.png#averageHue=%23eaeae9&amp;id=CEjqK&amp;originHeight=303&amp;originWidth=471&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>发布订阅命令行实现</strong></li><li>打开一个客户端订阅channel1</li></ol><p>SUBSCRIBE channel1<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730040629-5d1e893c-fb8a-4320-8280-7284fb8dedac.png#averageHue=%230c0a09&amp;id=wW3l8&amp;originHeight=154&amp;originWidth=541&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>2、打开另一个客户端，给channel1发布消息hello<br>publish channel1 hello<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730040869-9547417c-700c-4bef-9c9d-c650dab1b686.png#averageHue=%23110f0d&amp;id=bv7O0&amp;originHeight=50&amp;originWidth=495&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>返回的1是订阅者数量<br>3、打开第一个客户端可以看到发送的消息<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730041137-08dbd908-930c-46bc-892d-c3975a44515b.png#averageHue=%230a0807&amp;id=Opd93&amp;originHeight=227&amp;originWidth=552&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>注：发布的消息没有持久化，如果在订阅的客户端收不到hello，只能收到订阅后发布的消息</p><ol><li><strong>Redis新数据类型</strong><ol><li><strong>Bitmaps</strong><ol><li><strong>简介</strong></li></ol></li></ol></li></ol><p>现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730041380-1e9c0ca4-5e84-47b2-9984-4647f3a6b1a1.png#averageHue=%23e9e9e9&amp;id=uehK8&amp;originHeight=115&amp;originWidth=628&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>合理地使用操作位能够有效地提高内存使用率和开发效率。<br>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p><ol><li>Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</li><li>Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730041676-b07a50a5-97e1-453e-9c45-420743a1144d.png#averageHue=%23cdcccc&amp;id=DojKK&amp;originHeight=81&amp;originWidth=822&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **命令**</code></pre><p>1、setbit<br>（1）格式<br>setbit<key><offset><value>设置Bitmaps中某个偏移量的值（0或1）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730041887-6e6d1411-b201-4d9c-8da2-5e2e7512b457.png#averageHue=%23110f0d&amp;id=za5A6&amp;originHeight=37&amp;originWidth=519&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>*offset:偏移量从0开始<br>（2）实例<br>每个独立用户是否访问过网站存放在Bitmaps中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的id。<br>设置键的第offset个位的值（从0算起） ， 假设现在有20个用户，userid=1， 6， 11， 15， 19的用户对网站进行了访问， 那么当前Bitmaps初始化结果如图<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730042156-2c62c32d-62a3-45f7-854d-3bf1cf1e489f.png#averageHue=%23ececec&amp;id=KepT0&amp;originHeight=135&amp;originWidth=646&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>unique:users:20201106代表2020-11-06这天的独立访问用户的Bitmaps<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730042383-9e87289b-c3fe-4884-bc89-37897d0108fe.png#averageHue=%23100e0c&amp;id=k5Jkg&amp;originHeight=251&amp;originWidth=652&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>注：<br>很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。<br>在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。<br>2、getbit<br>（1）格式<br>getbit<key><offset>获取Bitmaps中某个偏移量的值<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730042647-7b0094f9-0323-4d9a-a8be-ca2552194b79.png#averageHue=%23100e0c&amp;id=ogPG6&amp;originHeight=35&amp;originWidth=444&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>获取键的第offset位的值（从0开始算）<br>（2）实例<br>获取id=8的用户是否在2020-11-06这天访问过， 返回0说明没有访问过：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730042882-62c46e10-5689-4e65-856e-a6b2ac7468be.png#averageHue=%23100e0c&amp;id=lo73f&amp;originHeight=154&amp;originWidth=633&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>注：因为100根本不存在，所以也是返回0<br>3、bitcount<br>统计<strong>字符串</strong>被设置为1的bit数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。<br>（1）格式<br>bitcount<key>[start end] 统计字符串从start字节到end字节比特值为1的数量<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730043084-62a931d2-c5e0-4b31-b14a-cfe895317f1e.png#averageHue=%2315120f&amp;id=nw0n4&amp;originHeight=29&amp;originWidth=526&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>（2）实例<br>计算2022-11-06这天的独立访问用户数量<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730043338-e4615ff4-d54b-4821-b778-1a9bd1824324.png#averageHue=%230c0a07&amp;id=rcLg5&amp;originHeight=62&amp;originWidth=657&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>start和end代表起始和结束字节数， 下面操作计算用户id在第1个字节到第3个字节之间的独立访问用户数， 对应的用户id是11， 15， 19。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730043539-b573ced4-e2ab-463b-831e-c17c49ba60a6.png#averageHue=%23100d0c&amp;id=VstjJ&amp;originHeight=51&amp;originWidth=662&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>举例： K1 【01000001 01000000  00000000 00100001】，对应【0，1，2，3】<br>bitcount K1 1 2  ： 统计下标1、2字节组中bit=1的个数，即01000000  00000000<br>–》bitcount K1 1 2 　　--》1<br>bitcount K1 1 3  ： 统计下标1、2字节组中bit=1的个数，即01000000  00000000 00100001<br>–》bitcount K1 1 3　　--》3<br>bitcount K1 0 -2  ： 统计下标0到下标倒数第2，字节组中bit=1的个数，即01000001  01000000   00000000<br>–》bitcount K1 0 -2　　--》3<br>注意：redis的setbit设置或清除的是bit位置，而bitcount计算的是byte位置。<br>4、bitop<br>(1)格式<br>bitop  and(or/not/xor) <destkey> [key…]<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730043743-ba80e6ed-b5da-4394-9bcf-19467d02a666.png#averageHue=%2313100e&amp;id=j9TK6&amp;originHeight=29&amp;originWidth=691&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。<br>(2)实例<br>2020-11-04 日访问网站的userid=1,2,5,9。<br>setbit unique:users:20201104 1 1<br>setbit unique:users:20201104 2 1<br>setbit unique:users:20201104 5 1<br>setbit unique:users:20201104 9 1<br>2020-11-03 日访问网站的userid=0,1,4,9。<br>setbit unique:users:20201103 0 1<br>setbit unique:users:20201103 1 1<br>setbit unique:users:20201103 4 1<br>setbit unique:users:20201103 9 1<br>计算出两天都访问过网站的用户数量<br>bitop and unique:users:and:20201104_03<br>unique:users:20201103unique:users:20201104<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730043980-be07c887-3214-4b9d-87c3-d4df59d7233c.png#averageHue=%230a0907&amp;id=seAnr&amp;originHeight=129&amp;originWidth=1181&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>bitop and操作返回值是位串中为1的个数。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730044227-82e0367b-be06-4164-88df-f1f6713b6fc5.png#averageHue=%23f0efef&amp;id=fiQAN&amp;originHeight=394&amp;originWidth=617&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>计算出任意一天都访问过网站的用户数量（例如月活跃就是类似这种） ， 可以使用or求并集<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730044526-f201de03-2143-4c20-9153-9d6aa4f54b63.png#averageHue=%230a0807&amp;id=pl4Ku&amp;originHeight=126&amp;originWidth=1183&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **Bitmaps与set对比**</code></pre><p>假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表</p><table><thead><tr><th>set和Bitmaps存储一天活跃用户对比</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据</td><td></td><td></td><td></td></tr><tr><td>类型</td><td>每个用户id占用空间</td><td>需要存储的用户量</td><td>全部内存量</td></tr><tr><td>集合</td><td></td><td></td><td></td></tr><tr><td>类型</td><td>64位</td><td>50000000</td><td>64位*50000000 = 400MB</td></tr><tr><td>Bitmaps</td><td>1位</td><td>100000000</td><td>1位*100000000 = 12.5MB</td></tr></tbody></table><p>很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的</p><table><thead><tr><th>set和Bitmaps存储独立用户空间对比</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据类型</td><td>一天</td><td>一个月</td><td>一年</td></tr><tr><td>集合类型</td><td>400MB</td><td>12GB</td><td>144GB</td></tr><tr><td>Bitmaps</td><td>12.5MB</td><td>375MB</td><td>4.5GB</td></tr></tbody></table><p>但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0。</p><table><thead><tr><th>set和Bitmaps存储一天活跃用户对比（独立用户比较少）</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据类型</td><td>每个userid占用空间</td><td>需要存储的用户量</td><td>全部内存量</td></tr><tr><td>集合类型</td><td>64位</td><td>100000</td><td>64位*100000 = 800KB</td></tr><tr><td>Bitmaps</td><td>1位</td><td>100000000</td><td>1位*100000000 = 12.5MB</td></tr></tbody></table><ol><li><strong>HyperLogLog</strong><ol><li><strong>简介</strong></li></ol></li></ol><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。<br>但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。<br>解决基数问题有很多种方案：<br>（1）数据存储在MySQL表中，使用distinct count计算不重复个数<br>（2）使用Redis提供的hash、set、bitmaps等数据结构来处理<br>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。<br>能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog<br>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。<br>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。<br>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。<br>什么是基数?<br>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p><pre><code>  1. **命令**</code></pre><p>1、pfadd<br>（1）格式<br>pfadd <key>&lt; element&gt; [element …]   添加指定元素到 HyperLogLog 中<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730044807-6a71eed0-0b1f-44a4-839b-e33e56882e07.png#averageHue=%23100d0c&amp;id=Yw5RO&amp;originHeight=31&amp;originWidth=620&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>（2）实例<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730045083-57372cbe-5fc9-467d-b162-15c621ebaf03.png#averageHue=%23100d0c&amp;id=RDA2W&amp;originHeight=177&amp;originWidth=447&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>将所有元素添加到指定HyperLogLog数据结构中。如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0。<br>2、pfcount<br>（1）格式<br>pfcount<key> [key …] 计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730045284-0ea0a0a4-29f5-4d7a-a2d1-e1d0ff413a83.png#averageHue=%23100e0c&amp;id=ymRaK&amp;originHeight=32&amp;originWidth=482&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>（2）实例<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730045569-ff64944a-93ae-4f3e-b189-25091586aa3a.png#averageHue=%230f0d0b&amp;id=tIUfy&amp;originHeight=375&amp;originWidth=473&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>3、pfmerge<br>（1）格式<br>pfmerge<destkey><sourcekey> [sourcekey …]  将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730045959-ae3fb38f-f426-41e2-9abd-33317a976419.png#averageHue=%23151210&amp;id=bQZBn&amp;originHeight=27&amp;originWidth=744&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>（2）实例<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730046204-9eef0e6b-7a15-410d-83bd-65d4a7d7e358.png#averageHue=%230d0b09&amp;id=KDaCu&amp;originHeight=182&amp;originWidth=495&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>Geospatial</strong><ol><li><strong>简介</strong></li></ol></li></ol><p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p><pre><code>  1. **命令**</code></pre><p>1、geoadd<br>（1）格式<br>geoadd<key>&lt; longitude&gt;<latitude><member> [longitude latitude member…]   添加地理位置（经度，纬度，名称）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730046502-25494722-7483-4493-8757-95fb5196cbc5.png#averageHue=%230b0806&amp;id=aAHRQ&amp;originHeight=30&amp;originWidth=754&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>（2）实例<br>geoadd china:city 121.47 31.23 shanghai<br>geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730046771-cd8f0b9f-c7ec-4cf4-b994-023b74e0753d.png#averageHue=%23070503&amp;id=mzQwF&amp;originHeight=96&amp;originWidth=898&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。<br>有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。<br>当坐标位置超出指定范围时，该命令将会返回一个错误。<br>已经添加的数据，是无法再次往里面添加的。<br>2、geopos<br>（1）格式<br>geopos  <key><member> [member…]  获得指定地区的坐标值<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730047046-9212fba5-b8c3-4ec3-8dd7-ff0823d9c79c.png#averageHue=%230d0a07&amp;id=ujxFG&amp;originHeight=27&amp;originWidth=464&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>（2）实例<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730047304-a8479a43-fdca-4b12-92a1-683084423427.png#averageHue=%23120e0a&amp;id=N5gjj&amp;originHeight=61&amp;originWidth=423&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>3、geodist<br>（1）格式<br>geodist<key><member1><member2>  [m|km|ft|mi ]  获取两个位置之间的直线距离<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730047526-463fa02f-03df-488e-93ed-16c6ff5a7bdb.png#averageHue=%230c0906&amp;id=LaFSb&amp;originHeight=28&amp;originWidth=564&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>（2）实例<br>获取两个位置之间的直线距离<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730047763-e55e7def-edf0-4318-8b5d-4bfb091fa53d.png#averageHue=%23090704&amp;id=OwVHS&amp;originHeight=50&amp;originWidth=557&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>单位：<br>m 表示单位为米[默认值]。<br>km 表示单位为千米。<br>mi 表示单位为英里。<br>ft 表示单位为英尺。<br>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位<br>4、georadius<br>（1）格式<br>georadius<key>&lt; longitude&gt;<latitude>radius  m|km|ft|mi   以给定的经纬度为中心，找出某一半径内的元素<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730048028-db65bfe1-ddcd-4996-a673-88e25f0bfb7d.png#averageHue=%230d0a07&amp;id=giAcC&amp;originHeight=26&amp;originWidth=671&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>经度 纬度 距离 单位<br>（2）实例<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730048304-448a2baf-96e7-44ec-a154-990d2526f401.png#averageHue=%23090604&amp;id=iFc6n&amp;originHeight=60&amp;originWidth=519&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>Redis_Jedis_测试</strong><ol><li><strong>Jedis所需要的jar包</strong><br>| &lt;<strong>dependency</strong>&gt;<br>&lt;<strong>groupId</strong>&gt;redis.clients&lt;/<strong>groupId</strong>&gt;<br>&lt;<strong>artifactId</strong>&gt;jedis&lt;/<strong>artifactId</strong>&gt;<br>&lt;<strong>version</strong>&gt;3.2.0&lt;/<strong>version</strong>&gt;<br>&lt;/<strong>dependency</strong>&gt; |<br>| — |</li></ol></li></ol><p>什么是Jedis?<br>Jedis是redis的java客户端，集成了Redis的命令操作，提供连接池操作。</p><ol><li><strong>连接Redis注意事项</strong></li></ol><p>禁用Linux的防火墙：Linux(CentOS7)里执行命令<br>**systemctl stop/disable firewalld.service   **<br>redis.conf中注释掉bind 127.0.0.1 ,然后 protected-mode no<br>1.查看redis进程的命令： ps -ef | grep redis。<br>2.关于prptected-mode no的解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">protected-mode no 是一个用于关闭 Redis 的保护模式的配置选项。</span><br><span class="line">保护模式是 Redis 3.2 版本后引入的一种安全机制，</span><br><span class="line">它的目的是防止 Redis 实例被外部网络访问和利用。https://www.jianshu.com/p/ddd19ec819dchttps://blog.csdn.net/zzhongcy/article/details/123653851</span><br><span class="line"></span><br><span class="line">当保护模式开启时，如果 Redis 实例没有指定绑定地址（bind）</span><br><span class="line">或者没有设置访问密码（requirepass），那么它只接受来自本地回环地址</span><br><span class="line">（127.0.0.1 或者 ::1）和 Unix 域套接字的连接请求。这样可以避免 </span><br><span class="line">Redis 实例被暴露在公网上，造成数据泄露或者被恶意攻击。https://www.jianshu.com/p/ddd19ec819dchttps://blog.csdn.net/zzhongcy/article/details/123653851</span><br><span class="line"></span><br><span class="line">如果你想让 Redis 实例能够接受来自外部网络的连接请求</span><br><span class="line">，你可以采用以下几种方法之一：</span><br><span class="line"></span><br><span class="line">•  关闭保护模式，将 protected-mode no 设置为 no ，然后重启服务器。</span><br><span class="line">但是这样做需要确保 Redis 实例不会被公网访问，否则会有安全风险。https://www.jianshu.com/p/ddd19ec819dchttps://blog.csdn.net/zzhongcy/article/details/123653851</span><br><span class="line"></span><br><span class="line">•  开启保护模式，但是指定绑定地址（bind），让 Redis 实例只监听特定</span><br><span class="line">的网络接口。例如，如果你想让 Redis 实例只监听 192.168.1.100 这个地址，你可以在配置文件中设置 bind 192.168.1.100 ，然后重启服务器。https://www.jianshu.com/p/ddd19ec819dchttps://blog.csdn.net/zzhongcy/article/details/123653851</span><br><span class="line"></span><br><span class="line">•  开启保护模式，但是设置访问密码（requirepass），让 Redis 实例要</span><br><span class="line">求客户端提供密码才能连接。例如，如果你想让 Redis 实例的密码为 mypass </span><br><span class="line">，你可以在配置文件中设置 requirepass mypass ，然后重启服务器。</span><br><span class="line">https://www.jianshu.com/p/ddd19ec819dchttps://blog.csdn.net/zzhongcy/article/details/123653851</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">命令ps -ef中，选项-ef是两个单独的选项-e和-f的组合。</span><br><span class="line"></span><br><span class="line">-e选项：它表示显示所有进程，而不仅仅是当前用户的进程。它会列出所有</span><br><span class="line">正在运行的进程，包括系统进程和其他用户的进程。</span><br><span class="line"></span><br><span class="line">-f选项：它表示以全格式显示进程信息。它会显示更详细的信息，如进</span><br><span class="line">程的PID（进程ID）、PPID（父进程ID）、CPU使用情况、内存使用情况等。</span><br></pre></td></tr></table></figure><ol><li><p><strong>Jedis常用操作</strong></p><ol><li><strong>创建动态的工程</strong></li><li><strong>创建测试程序</strong><br>| package com.atguigu.jedis;<br>import redis.clients.jedis.Jedis;<br>public class Demo01 {<br>public static void main(String[] args) {<br>Jedis jedis = new Jedis(“192.168.137.3”,6379);//注意这里连接的是redis-server<br>而不是redis-sentinel<br>String pong = jedis.ping();<br>System.out.println(“连接成功：”+pong);<br>jedis.close();<br>}<br>} |<br>| — |</li></ol></li><li><p><strong>测试相关数据类型</strong></p><ol><li><p><strong>Jedis-API:    Key</strong><br>| jedis.<strong>set</strong>(“k1”, “v1”);<br>jedis.set(“k2”, “v2”);<br>jedis.set(“k3”, “v3”);<br>Set<String> keys = jedis.<strong>keys</strong>(“*”);<br>System.out.println(keys.size());<br>for (String key : keys) {<br>System.out.println(key);<br>}<br>System.out.println(jedis.<strong>exists</strong>(“k1”));<br>System.out.println(jedis.<strong>ttl</strong>(“k1”));<br>System.out.println(jedis.<strong>get</strong>(“k1”)); |<br>| — |</p></li><li><p><strong>Jedis-API:    String</strong><br>| jedis.<strong>mset</strong>(“str1”,“v1”,“str2”,“v2”,“str3”,“v3”);<br>System.<em>out</em>.println(jedis.<strong>mget</strong>(“str1”,“str2”,“str3”)); |<br>| — |</p></li><li><p><strong>Jedis-API:    List</strong><br>| List<String> list = jedis.<strong>lrange</strong>(“mylist”,0,-1);<br>for (String element : list) {<br>System.out.println(element);<br>} |<br>| — |</p></li><li><p><strong>Jedis-API:    set</strong><br>| jedis.sadd(“orders”, “order01”);<br>jedis.sadd(“orders”, “order02”);<br>jedis.sadd(“orders”, “order03”);<br>jedis.sadd(“orders”, “order04”);<br>Set<String> smembers = jedis.<strong>smembers</strong>(“orders”);<br>for (String order : smembers) {<br>System.out.println(order);<br>}<br>jedis.<strong>srem</strong>(“orders”, “order02”); |<br>| — |</p></li><li><p><strong>Jedis-API:    hash</strong><br>| jedis.<strong>hset</strong>(“hash1”,“userName”,“lisi”);<br>System.out.println(jedis.<strong>hget</strong>(“hash1”,“userName”));<br>Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();<br>map.put(“telphone”,“13810169999”);<br>map.put(“address”,“atguigu”);<br>map.put(“<a href="mailto:email%22,%22abc@163.com">email&quot;,&quot;abc@163.com</a>”);<br>jedis.<strong>hmset</strong>(“hash2”,map);<br>List<String> result = jedis.<strong>hmget</strong>(“hash2”, “telphone”,“email”);<br>for (String element : result) {<br>System.out.println(element);<br>} |<br>| — |</p></li><li><p><strong>Jedis-API:    zset</strong><br>| jedis.<strong>zadd</strong>(“zset01”, 100d, “z3”);<br>jedis.zadd(“zset01”, 90d, “l4”);<br>jedis.zadd(“zset01”, 80d, “w5”);<br>jedis.zadd(“zset01”, 70d, “z6”);</p></li></ol></li></ol><p>Set<String> zrange = jedis.<strong>zrange</strong>(“zset01”, 0, -1);<br>for (String e : zrange) {<br>System.out.println(e);</p><table><thead><tr><th>}</th></tr></thead></table><ol><li><strong>Redis_Jedis_实例</strong><ol><li><strong>完成一个手机验证码功能</strong></li></ol></li></ol><p>要求：<br>1、输入手机号，点击发送后随机生成6位数字码，2分钟有效<br>2、输入验证码，点击验证，返回成功或失败<br>3、每个手机号每天只能输入3次<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730048567-6aa26936-21dc-4110-8bba-d0bea1ab89f0.jpeg#averageHue=%23eae8e0&amp;id=sLE5A&amp;originHeight=165&amp;originWidth=516&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>Redis与Spring Boot整合</strong></li></ol><p>Spring Boot整合Redis非常简单，只需要按如下步骤整合即可</p><ol><li><p><strong>整合步骤</strong></p></li><li><p>在pom.xml文件中引入redis相关依赖<br>| <em><!-- redis --></em>&lt;<strong>dependency</strong>&gt;<br>&lt;<strong>groupId</strong>&gt;org.springframework.boot&lt;/<strong>groupId</strong>&gt;<br>&lt;<strong>artifactId</strong>&gt;spring-boot-starter-data-redis&lt;/<strong>artifactId</strong>&gt;<br>&lt;/<strong>dependency</strong>&gt;<br><em><!-- spring2.X集成redis所需common-pool2--></em>&lt;<strong>dependency</strong>&gt;<br>&lt;<strong>groupId</strong>&gt;org.apache.commons&lt;/<strong>groupId</strong>&gt;<br>&lt;<strong>artifactId</strong>&gt;commons-pool2&lt;/<strong>artifactId</strong>&gt;<br>&lt;<strong>version</strong>&gt;2.6.0&lt;/<strong>version</strong>&gt;<br>&lt;/<strong>dependency</strong>&gt; |<br>| — |</p></li><li><p>application.properties配置redis配置<br>| #Redis服务器地址<br>spring.data.redis.host=8.130.50.249<br>#Redis服务器连接端口<br>spring.data.redis.port=**6379<br>**#Redis数据库索引（默认为0）<br>spring.data.redis.database= **0<br>**#连接超时时间（毫秒）<br>spring.data.redis.timeout=1800000<br>#连接池最大连接数（使用负值表示没有限制）<br>spring.data.redis.jedis.pool.max-active=**20<br>**#最大阻塞等待时间(负数表示没限制)<br>spring.data.redis.jedis.pool.max-wait=-1<br>#连接池中的最大空闲连接<br>spring.data.redis.jedis.pool.max-idle=**5<br>**#连接池中的最小空闲连接<br>spring.data.redis.jedis.pool.min-idle=<strong>0</strong> |<br>| — |</p></li><li><p>添加redis配置类<br>| @EnableCaching<br>@Configuration<br>**public class **RedisConfig **extends **CachingConfigurerSupport {</p><p>@Bean<br>**public **RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) {<br>RedisTemplate&lt;String, Object&gt; template = **new **RedisTemplate&lt;&gt;();<br>RedisSerializer<String> redisSerializer = <strong>new <strong>StringRedisSerializer();<br>Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <strong>new <strong>Jackson2JsonRedisSerializer(Object.<strong>class</strong>);<br>ObjectMapper om = <strong>new <strong>ObjectMapper();<br>om.setVisibility(PropertyAccessor.</strong><em>ALL</em></strong>, JsonAutoDetect.Visibility.</strong><em>ANY</em></strong>);<br>om.enableDefaultTyping(ObjectMapper.DefaultTyping.</strong><em>NON_FINAL</em></strong>);<br>jackson2JsonRedisSerializer.setObjectMapper(om);<br>template.setConnectionFactory(factory);_//key序列化方式<br><em>template.setKeySerializer(redisSerializer);</em>//value序列化<br><em>template.setValueSerializer(jackson2JsonRedisSerializer);</em>//value hashmap序列化<br>_template.setHashValueSerializer(jackson2JsonRedisSerializer);<br>**return **template;<br>}</p><p>@Bean<br>**public **CacheManager cacheManager(RedisConnectionFactory factory) {<br>RedisSerializer<String> redisSerializer = <strong>new <strong>StringRedisSerializer();<br>Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <strong>new <strong>Jackson2JsonRedisSerializer(Object.<strong>class</strong>);_//解决查询缓存转换异常的问题<br>_ObjectMapper om = <strong>new <strong>ObjectMapper();<br>om.setVisibility(PropertyAccessor.</strong><em>ALL</em></strong>, JsonAutoDetect.Visibility.</strong><em>ANY</em></strong>);<br>om.enableDefaultTyping(ObjectMapper.DefaultTyping.</strong><em>NON_FINAL</em></strong>);<br>jackson2JsonRedisSerializer.setObjectMapper(om);_// 配置序列化（解决乱码的问题）,过期时间600秒<br>_RedisCacheConfiguration config = RedisCacheConfiguration.<em>defaultCacheConfig</em>()<br>.entryTtl(Duration.<em>ofSeconds</em>(600))<br>.serializeKeysWith(RedisSerializationContext.SerializationPair.<em>fromSerializer</em>(redisSerializer))<br>.serializeValuesWith(RedisSerializationContext.SerializationPair.<em>fromSerializer</em>(jackson2JsonRedisSerializer))<br>.disableCachingNullValues();<br>RedisCacheManager cacheManager = RedisCacheManager.<em>builder</em>(factory)<br>.cacheDefaults(config)<br>.build();<br>**return **cacheManager;<br>}<br>} |<br>| — |<br>|  |<br>|  |</p></li></ol><p>4、测试一下<br>RedisTestController中添加测试方法</p><p>| @RestController<br>@RequestMapping(<strong>“/redisTest”</strong>)<br><strong>public class <strong>RedisTestController {<br>@Autowired<br><strong>private <strong>RedisTemplate <strong>redisTemplate</strong>;<br>@GetMapping<br><strong>public <strong>String testRedis() {<br>_//设置值到redis<br>_<strong>redisTemplate</strong>.opsForValue().set(</strong>“name”</strong>,</strong>“lucy”</strong>);<br>_//从redis获取值<br>_String name = (String)<strong>redisTemplate</strong>.opsForValue().get(</strong>“name”</strong>);<br>**return **name;<br>}</p><table><thead><tr><th>}</th></tr></thead></table><ol><li><strong>Redis_事务_锁机制_秒杀</strong><ol><li><strong>Redis的事务定义</strong></li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730048825-54893261-bf10-4de3-a66c-f7b8b69c7a63.jpeg#averageHue=%23e0dfdb&amp;id=jmvjN&amp;originHeight=66&amp;originWidth=625&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>Redis事务的主要作用就是串联多个命令防止别的命令插队。</p><ol><li><strong>Multi、Exec、discard</strong></li></ol><p>从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。<br>组队的过程中可以通过discard来放弃组队。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730049147-dc3307d8-1793-4200-9f46-8d71c8175710.png#averageHue=%23fdfbfb&amp;id=ITVQ2&amp;originHeight=309&amp;originWidth=693&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br><strong>案例：</strong></p><p>| <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730049420-5fee2564-1c4f-4b27-9f0d-5081fa588321.jpeg#averageHue=%23615c55&amp;id=u9oHB&amp;originHeight=117&amp;originWidth=159&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><table><thead><tr><th>组队成功，提交成功</th></tr></thead><tbody><tr><td><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730049688-69b9a09e-c48f-48d0-95d8-2f3368017f39.jpeg#averageHue=%23060605&amp;id=PqyhT&amp;originHeight=122&amp;originWidth=389&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></td></tr><tr><td>组队阶段报错，提交失败</td></tr><tr><td><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730049917-4a5ea3be-4561-417e-8316-cd2266f3a8b2.jpeg#averageHue=%23080707&amp;id=BLVOz&amp;originHeight=152&amp;originWidth=330&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></td></tr><tr><td>组队成功，提交有成功有失败情况</td></tr></tbody></table><ol><li><strong>事务的错误处理</strong></li></ol><p>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730050175-662baba3-e42b-4d7e-97a5-fbaf395b7141.jpeg#averageHue=%23f6f5f5&amp;id=tNetC&amp;originHeight=270&amp;originWidth=617&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730050447-d9680bf2-fda6-4551-b0eb-ba707f216ac3.jpeg#averageHue=%23ebebe3&amp;id=JAArc&amp;originHeight=269&amp;originWidth=614&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>为什么要做成事务</strong></li></ol><p>想想一个场景：有很多人有你的账户,同时去参加双十一抢购</p><ol><li><strong>事务冲突的问题</strong><ol><li><strong>例子</strong></li></ol></li></ol><p>一个请求想给金额减8000<br>一个请求想给金额减5000<br>一个请求想给金额减1000<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730050721-2562fa91-e6be-4801-bec9-b54b906cddf4.jpeg#averageHue=%23fac47d&amp;id=oYHnE&amp;originHeight=215&amp;originWidth=616&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **悲观锁**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730050986-995b2faa-d872-406f-9ba7-cdca0f1a0d29.jpeg#averageHue=%23f1c084&amp;id=w0mhj&amp;originHeight=169&amp;originWidth=613&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br><strong>悲观锁(Pessimistic Lock)</strong>, 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。<strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。</p><pre><code>  1. **乐观锁**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730051248-472694bb-fce1-419f-b8b8-ee0b46349fac.jpeg#averageHue=%23f9e5d3&amp;id=pMR6f&amp;originHeight=195&amp;originWidth=613&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>**乐观锁(Optimistic Lock), **顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis就是利用这种check-and-set机制实现事务的。</p><pre><code>  1. **WATCH key [key ...]**</code></pre><p>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务<strong>执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730051584-c6030859-5595-4dd5-af27-cd9f93ef166e.jpeg#averageHue=%23f5edec&amp;id=jXO1L&amp;originHeight=180&amp;originWidth=314&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **unwatch**</code></pre><p>取消 WATCH 命令对所有 key 的监视。<br>如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了。<br><a href="http://doc.redisfans.com/transaction/exec.html">http://doc.redisfans.com/transaction/exec.html</a></p><ol><li><strong>Redis事务三特性</strong></li></ol><ul><li>单独的隔离操作<ul><li>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li></ul></li><li>没有隔离级别的概念<ul><li>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</li></ul></li><li>不保证原子性<ul><li>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li></ul></li></ul><ol><li><strong>Redis_事务_秒杀案例</strong><ol><li><strong>解决计数器和人员记录的事务操作</strong></li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730051888-55bb4789-36fb-4865-ac03-920446cb6b8d.jpeg#averageHue=%23fdfefd&amp;id=cx1Bh&amp;originHeight=189&amp;originWidth=614&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>Redis事务–秒杀并发模拟</strong></li></ol><p>使用工具ab模拟测试<br>CentOS6 默认安装<br>CentOS7需要手动安装</p><pre><code>  1. **联网：yum install httpd-tools**  2. **无网络**</code></pre><p>（1） 进入cd  /run/media/root/CentOS 7 x86_64/Packages（路径跟centos6不同）<br>（2） 顺序安装<br>apr-1.4.8-3.el7.x86_64.rpm<br>apr-util-1.5.2-6.el7.x86_64.rpm<br>httpd-tools-2.4.6-67.el7.centos.x86_64.rpm</p><pre><code>  1. **测试及结果**     1. **通过ab测试**</code></pre><p>vim postfile 模拟表单提交参数,以&amp;符号结尾;存放当前目录。<br>内容：prodid=0101&amp;<br>ab -n 2000 -c 200 -k -p ~/postfile -T application/x-www-form-urlencoded <a href="http://192.168.2.115:8081/Seckill/doseckill">http://192.168.2.115:8081/Seckill/doseckill</a></p><pre><code>     1. **超卖**</code></pre><p>| <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730052159-72c632b8-c258-476c-ab16-ba02e679e609.jpeg#averageHue=%23efefe9&amp;id=e0BcE&amp;originHeight=320&amp;originWidth=117&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""> | <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730052444-7f1821af-9326-4c5b-8ff9-3a55c795e243.jpeg#averageHue=%230e0908&amp;id=RzNKd&amp;originHeight=138&amp;originWidth=360&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>  |<br>| — | — |</p><ol><li><strong>超卖问题</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730052742-4e563233-bb89-48ce-9b0d-a6d4836dd0f9.jpeg#averageHue=%23f8e5db&amp;id=VNTTo&amp;originHeight=348&amp;originWidth=547&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>利用乐观锁淘汰用户，解决超卖问题。</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730053044-acd5fa54-be05-4269-b369-47acf2f2a3e9.jpeg#averageHue=%23f6ddd3&amp;id=wpIeY&amp;originHeight=289&amp;originWidth=613&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>| //增加乐观锁<br>jedis.watch(qtkey);</p><p><a href="//3.xn--fcr37t4sc0rk">//3.判断库存</a><br>String qtkeystr = jedis.get(qtkey);<br>if(qtkeystr==null || “”.equals(qtkeystr.trim())) {<br>System.out.println(“未初始化库存”);<br>jedis.close();<br>return false ;<br>}</p><p>int qt = Integer.parseInt(qtkeystr);<br>if(qt&lt;=0) {<br>System.err.println(“已经秒光”);<br>jedis.close();<br>return false;<br>}</p><p>//增加事务<br>Transaction <strong>multi</strong> = jedis.multi();</p><p><a href="//4.xn--z8q55u3pai4f">//4.减少库存</a><br><a href="//jedis.decr">//jedis.decr</a>(qtkey);<br><strong>multi</strong>.decr(qtkey);</p><p><a href="//5.xn--gmqv8g">//5.加人</a><br><a href="//jedis.sadd">//jedis.sadd</a>(usrkey, uid);<br><strong>multi</strong>.sadd(usrkey, uid);</p><p>//执行事务<br>List<Object> list = <strong>multi</strong>.exec();</p><p>//判断事务提交是否失败<br>if(list==null || list.size()==0) {<br>System.out.println(“秒杀失败”);<br>jedis.close();<br>return false;<br>}<br>System.err.print<strong>ln(&quot;秒杀成</strong>功&quot;);<br>jedis.close(); | <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730053362-ccd953c7-236d-448b-8ad2-5a5b050b2997.jpeg#averageHue=%23080606&amp;id=Rhbmv&amp;originHeight=311&amp;originWidth=331&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730053594-7a639b97-8a83-49f7-9005-c3a535b71ec4.jpeg#averageHue=%23e6e4dd&amp;id=jeZiO&amp;originHeight=319&amp;originWidth=127&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""> |<br>| — | — |</p><ol><li><strong>继续增加并发测试</strong><ol><li><strong>连接有限制</strong></li></ol></li></ol><p>ab -n 2000 -c 200 -k -p postfile -T ‘application/x-www-form-urlencoded’ <a href="http://192.168.140.1:8080/seckill/doseckill">http://192.168.140.1:8080/seckill/doseckill</a><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730053896-5957fed5-aab7-4802-bbbb-f886c8d8c83e.jpeg#averageHue=%230f0c0c&amp;id=oPqVJ&amp;originHeight=83&amp;originWidth=626&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>增加-r参数，-r   Don’t exit on socket receive errors.<br>**ab -n 2000 -c 100 -r -p postfile -T ‘application/x-www-form-urlencoded’ **<a href="http://192.168.140.1:8080/seckill/doseckill"><strong>http://192.168.140.1:8080/seckill/doseckill</strong></a></p><pre><code>  1. **已经秒光，可是还有库存**</code></pre><p>ab -n 2000 -c 100 -p postfile -T ‘application/x-www-form-urlencoded’ <a href="http://192.168.137.1:8080/seckill/doseckill">http://192.168.137.1:8080/seckill/doseckill</a><br>已经秒光，可是还有库存。原因，就是乐观锁导致很多请求都失败。先点的没秒到，后点的可能秒到了。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730054113-9d5a6de0-5d17-45bd-97b9-874049d61baf.jpeg#averageHue=%23797269&amp;id=d14LS&amp;originHeight=108&amp;originWidth=302&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **连接超时，通过连接池解决**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730054288-27c5b05f-a94c-4b63-a525-e6d16c0375a3.jpeg#averageHue=%2393bbe1&amp;id=VLdEy&amp;originHeight=86&amp;originWidth=619&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **连接池**</code></pre><p>节省每次连接redis服务带来的消耗，把连接好的实例反复利用。<br>通过参数管理连接的行为<br>代码见项目中</p><ul><li>链接池参数<ul><li>MaxTotal：控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；如果赋值为-1，则表示不限制；如果pool已经分配了MaxTotal个jedis实例，则此时pool的状态为exhausted。</li><li>maxIdle：控制一个pool最多有多少个状态为idle(空闲)的jedis实例；</li><li>MaxWaitMillis：表示当borrow一个jedis实例时，最大的等待毫秒数，如果超过等待时间，则直接抛JedisConnectionException；</li><li>testOnBorrow：获得一个jedis实例的时候是否检查连接可用性（ping()）；如果为true，则得到的jedis实例均是可用的；</li></ul><ol><li><strong>解决库存遗留问题</strong><ol><li><strong>LUA脚本</strong></li></ol></li></ol></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730054477-cae19266-6238-4723-8a4c-c28305a736d8.jpeg#averageHue=%23e8e9e7&amp;id=D7HPy&amp;originHeight=129&amp;originWidth=138&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>Lua 是一个小巧的<a href="http://baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80">脚本语言</a>，Lua脚本可以很容易的被C/C++ 代码调用，也可以反过来调用C/C++的函数，Lua并没有提供强大的库，一个完整的Lua解释器不过200k，所以Lua不适合作为开发独立应用程序的语言，而是作为嵌入式脚本语言。<br>很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。<br>这其中包括魔兽争霸地图、魔兽世界、博德之门、愤怒的小鸟等众多游戏插件或外挂。<br><a href="https://www.w3cschool.cn/lua/">https://www.w3cschool.cn/lua/</a></p><pre><code>  1. **LUA脚本在Redis中的优势**</code></pre><p>将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连接redis的次数。提升性能。<br>LUA脚本是类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作。<br>但是注意redis的lua脚本功能，只有在Redis 2.6以上的版本才可以使用。<br>利用lua脚本淘汰用户，解决超卖问题。<br>redis 2.6版本以后，通过lua脚本解决<strong>争抢问题</strong>，实际上是<strong>redis 利用其单线程的特性，用任务队列的方式解决多任务并发问题</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730054720-4b5108cf-836f-454d-8d3a-5e6610f33167.jpeg#averageHue=%23fae0be&amp;id=Iy2sW&amp;originHeight=225&amp;originWidth=600&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>Redis_事务_秒杀案例_代码</strong><ol><li><strong>项目结构</strong></li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730054907-f204ef93-9675-4e13-97f0-f9c305933a1f.png#averageHue=%23faf7f2&amp;id=clsqt&amp;originHeight=209&amp;originWidth=215&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **第一版：简单版 **</code></pre><p>老师点10次，正常秒杀<br>同学一起点试一试，秒杀也是正常的。这是因为还达不到并发的效果。<br>使用工具ab模拟并发测试，会出现超卖情况。查看库存会出现负数。</p><pre><code>  1. **第二版：加事务-乐观锁(解决超卖),但出现遗留库存和连接超时**  2. **第三版：连接池解决超时问题 **  3. **第四版：解决库存依赖问题，LUA脚本**</code></pre><p>| local userid=KEYS[1];<br>local prodid=KEYS[2];<br>local qtkey=“sk:”…prodid…“:qt”;<br>local usersKey=“sk:”…prodid.&quot;:usr’;<br>local userExists=redis.call(“sismember”,usersKey,userid);<br>if tonumber(userExists)==1 then<br>return 2;<br>end<br>local num= redis.call(“get” ,qtkey);<br>if tonumber(num)&lt;=0 then<br>return 0;<br>else<br>redis.call(“decr”,qtkey);<br>redis.call(“sadd”,usersKey,userid);<br>end</p><table><thead><tr><th>return 1;</th></tr></thead></table><ol><li><strong>Redis持久化之RDB</strong><ol><li><strong>总体介绍</strong></li></ol></li></ol><p>官网介绍：<a href="http://www.redis.io">http://www.redis.io</a><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730055181-21b42629-abdb-408d-8139-72b3db4826e7.jpeg#averageHue=%23dddcd8&amp;id=LuJfp&amp;originHeight=240&amp;originWidth=612&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>Redis 提供了2个不同形式的持久化方式。</p><ul><li>RDB（Redis DataBase）</li><li>AOF（Append Of File）<ol><li><strong>RDB（Redis DataBase）</strong><ol><li><strong>官网介绍</strong></li></ol></li></ol></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730055430-a04d534c-6813-404e-afa9-ad374a47ae7f.jpeg#averageHue=%23e1dfdc&amp;id=L2nnI&amp;originHeight=389&amp;originWidth=606&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **是什么**</code></pre><p>在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里</p><pre><code>  1. **备份是如何执行的**</code></pre><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。<strong>RDB的缺点是最后一次持久化后的数据可能丢失</strong>。</p><pre><code>  1. **Fork**</code></pre><ul><li><p>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p></li><li><p>在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“<strong>写时复制技术</strong>”</p></li><li><p><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p><pre><code>1. **RDB持久化流程**</code></pre></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730055601-d03945eb-508f-499e-acde-dd485a30138d.png#averageHue=%23eeeded&amp;id=mZlnw&amp;originHeight=330&amp;originWidth=475&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **dump.rdb文件**</code></pre><p>在redis.conf中配置文件名称，默认为dump.rdb<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730055806-a8519103-df9a-4e33-98b1-320aca70fbcd.png#averageHue=%23160606&amp;id=F2yMJ&amp;originHeight=84&amp;originWidth=473&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **配置位置**</code></pre><p>rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下<br>dir “/myredis/”<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730056042-a0f2e26f-c64f-4e30-b801-e772b0abaf58.png#averageHue=%230b0808&amp;id=LxeNT&amp;originHeight=200&amp;originWidth=719&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **如何触发RDB快照；保持策略**     1. **配置文件中默认的快照配置**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730056324-6811ad3a-8f85-4229-9f2b-a4345a12125f.png#averageHue=%23160808&amp;id=ikta5&amp;originHeight=220&amp;originWidth=699&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>     1. **命令save VS bgsave**</code></pre><p>save ：save时只管保存，其它不管，全部阻塞。手动保存。不建议。<br><strong>bgsave：Redis会在后台异步进行快照操作， 快照同时还可以响应客户端请求。</strong><br>可以通过lastsave 命令获取最后一次成功执行快照的时间</p><pre><code>     1. **flushall命令**</code></pre><p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</p><pre><code>     1. **###SNAPSHOTTING快照###**     2. **Save**</code></pre><p>格式：save 秒钟 写操作次数<br>RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，<br><strong>默认是1分钟内改了1万次，或5分钟内改了10次，或15分钟内改了1次。</strong><br>禁用<br>不设置save指令，或者给save传入空字符串</p><pre><code>     1. **stop-writes-on-bgsave-error**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730056566-b7477281-0ae2-4042-ae1d-7fb4ad566669.png#averageHue=%23130a0a&amp;id=uEi7h&amp;originHeight=134&amp;originWidth=725&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes.</p><pre><code>     1. **rdbcompression 压缩文件**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730056786-cf02a974-a051-438d-b27e-6c6acbc7b15e.png#averageHue=%23120c0c&amp;id=AnH3A&amp;originHeight=129&amp;originWidth=724&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。<br>如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes.</p><pre><code>     1. **rdbchecksum 检查完整性**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730057060-2dd5e796-841a-4e7a-8f95-8fbf34cc5eda.png#averageHue=%230e0707&amp;id=vfML2&amp;originHeight=105&amp;originWidth=724&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>在存储快照后，还可以让redis使用CRC64算法来进行数据校验，<br>但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能<br>推荐yes.</p><pre><code>     1. **rdb的备份**</code></pre><p>先通过config get dir  查询rdb文件的目录<br>将*.rdb的文件拷贝到别的地方<br>rdb的恢复</p><pre><code>  - 关闭Redis  - 先把备份的文件拷贝到工作目录下 cp dump2.rdb dump.rdb  - 启动Redis, 备份数据会直接加载  1. **优势**</code></pre><ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高更适合使用</li><li>节省磁盘空间</li><li>恢复速度快</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730057328-1a1bd3cf-aa53-4fa3-99a7-8766afb7f633.jpeg#averageHue=%23a6d477&amp;id=bdgqK&amp;originHeight=202&amp;originWidth=479&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **劣势**</code></pre><ul><li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li><li>虽然Redis在fork时使用了<strong>写时拷贝技术</strong>,但是如果数据庞大时还是比较消耗性能。</li><li>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。<br>1. <strong>如何停止</strong></li></ul><p>动态停止RDB：redis-cli config set save “”#save后给空值，表示禁用保存策略</p><pre><code>  1. **小总结**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730057646-f8b197f6-79c1-4fc4-acc6-f7bec75f94eb.jpeg#averageHue=%23f9f9f9&amp;id=Dm0u6&amp;originHeight=403&amp;originWidth=613&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>Redis持久化之AOF</strong><ol><li><strong>AOF（Append Only File）</strong><ol><li><strong>是什么</strong></li></ol></li></ol></li></ol><p>以<strong>日志</strong>的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(<strong>读操作不记录</strong>)， <strong>只许追加文件但不可以改写文件</strong>，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p><pre><code>  1. **AOF持久化流程**</code></pre><p>（1）客户端的请求写命令会被append追加到AOF缓冲区内；<br>（2）AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；<br>（3）AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；<br>（4）Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的；<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730057886-6d5c494b-e7a7-4115-9575-2e78ef90c48d.png#averageHue=%23edecec&amp;id=DNPfE&amp;originHeight=383&amp;originWidth=233&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **AOF默认不开启**</code></pre><p>可以在redis.conf中配置文件名称，默认为 appendonly.aof<br>AOF文件的保存路径，同RDB的路径一致。</p><pre><code>  1. **AOF和RDB同时开启，redis听谁的？**</code></pre><p>AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）</p><pre><code>  1. **AOF启动/修复/恢复**</code></pre><ul><li>AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</li><li>正常恢复</li><li>修改默认的appendonly no，改为yes</li><li>将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir)</li><li>恢复：重启redis然后重新加载</li><li>异常恢复</li><li>修改默认的appendonly no，改为yes</li><li>如遇到<strong>AOF文件损坏</strong>，通过/usr/local/bin/<strong>redis-check-aof–fix appendonly.aof</strong>进行恢复</li><li>备份被写坏的AOF文件</li><li>恢复：重启redis，然后重新加载<br>1. <strong>AOF同步频率设置</strong></li></ul><p>appendfsync always<br>始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好<br>appendfsync everysec<br>每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。<br>appendfsync no<br>redis不主动进行同步，把同步时机交给操作系统。</p><pre><code>  1. **Rewrite压缩**</code></pre><p>1是什么：<br>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof<br>2重写原理，如何实现重写<br>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。<br>no-appendfsync-on-rewrite：<br>如果 no-appendfsync-on-rewrite=yes ,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）<br>如果 no-appendfsync-on-rewrite=no,  还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）<br>触发机制，何时重写<br>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发<br>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。<br>auto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）<br>auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。<br>例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB<br>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,<br>如果Redis的AOF当前大小&gt;= base_size +base_size*100% (默认)且当前大小&gt;=64mb(默认)的情况下，Redis会对AOF进行重写。<br>3、重写流程<br>（1）bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。<br>（2）主进程fork出子进程执行重写操作，保证主进程不会阻塞。<br>（3）子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。<br>（4）1).子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。2).主进程把aof_rewrite_buf中的数据写入到新的AOF文件。<br>（5）使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730058156-e7a60505-1151-4537-8a78-0ea8a294fccd.png#averageHue=%23f6f6f6&amp;id=DnxVL&amp;originHeight=638&amp;originWidth=701&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **优势**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730058439-66ee9250-8f65-48b6-bc41-58850a528e74.jpeg#averageHue=%23cad496&amp;id=f4Efc&amp;originHeight=106&amp;originWidth=536&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ul><li>备份机制更稳健，丢失数据概率更低。</li><li>可读的日志文本，通过操作AOF稳健，可以处理误操作。<br>1. <strong>劣势</strong></li><li>比起RDB占用更多的磁盘空间。</li><li>恢复备份速度要慢。</li><li>每次读写都同步的话，有一定的性能压力。</li><li>存在个别Bug，造成恢复不能。<br>1. **  小总结**</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730058786-ed4e3683-45aa-4285-8764-3d48c440bd73.jpeg#averageHue=%23faf9f8&amp;id=yjMkA&amp;originHeight=326&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>总结(Which one)</strong><ol><li><strong>用哪个好</strong></li></ol></li></ol><p>官方推荐两个都启用。<br>如果对数据不敏感，可以选单独用RDB。<br>不建议单独用 AOF，因为可能会出现Bug。<br>如果只是做纯内存缓存，可以都不用。</p><pre><code>  1. **官网建议**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730059011-3a34fc84-6548-4124-8b48-303d3df871d0.jpeg#averageHue=%23faf9f9&amp;id=MvDwj&amp;originHeight=341&amp;originWidth=610&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ul><li>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</li><li>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.</li><li>Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大</li><li>只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</li><li>同时开启两种持久化方式</li><li>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据, 因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</li><li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？</li><li>建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)， 快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</li><li>性能建议<br>| 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。</li></ul><p>如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。<br>代价,一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。<br>只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。</p><table><thead><tr><th>默认超过原大小100%大小时重写可以改到适当的数值。</th></tr></thead></table><ol><li><strong>Redis_主从复制</strong><ol><li><strong>是什么</strong></li></ol></li></ol><p>主机数据更新后根据配置和策略， 自动同步到备机的master/slaver机制，<strong>Master以写为主，Slave以读为主</strong></p><ol><li><strong>能干嘛</strong></li></ol><ul><li>读写分离，性能扩展</li><li>容灾快速恢复</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730059288-8136969e-2728-44c0-92f1-403eaab1bc16.jpeg#averageHue=%23fefcf2&amp;id=KK85J&amp;originHeight=206&amp;originWidth=324&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>怎么玩：主从复制</strong></li></ol><p>拷贝多个redis.conf文件include(写绝对路径)<br>开启daemonize yes<br>Pid文件名字pidfile<br>指定端口port<br>Log文件名字<br>dump.rdb名字dbfilename<br>Appendonly 关掉或者换名字</p><pre><code>  1. **新建redis6379.conf，填写以下内容**</code></pre><p>include /myredis/redis.conf<br>pidfile /var/run/redis_6379.pid<br>port 6379<br>dbfilename dump6379.rdb<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730059500-a043faca-b0c8-4ca1-bea2-ca501c4ee043.jpeg#averageHue=%23686259&amp;id=b4oWf&amp;originHeight=70&amp;originWidth=265&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **新建redis6380.conf，填写以下内容**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730059753-1adb8e30-94f0-436c-85a5-5267413c6a65.jpeg#averageHue=%23696359&amp;id=Q5Svi&amp;originHeight=76&amp;originWidth=273&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **新建redis6381.conf，填写以下内容**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730060016-2ceaeb23-5896-4990-848e-f5bfdfae8f67.jpeg#averageHue=%23827b73&amp;id=wdYqu&amp;originHeight=79&amp;originWidth=270&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>slave-priority 10<br>设置从机的优先级，值越小，优先级越高，用于选举主机时使用。默认100</p><pre><code>  1. **启动三台redis服务器**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730060260-b04a3052-e6b0-487b-aec1-3a3290ccc001.jpeg#averageHue=%239a9589&amp;id=yy6Ru&amp;originHeight=68&amp;originWidth=428&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **查看系统进程，看看三台服务器是否启动**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730060610-89904f51-3b40-46ca-848b-6a81c80c9cda.jpeg#averageHue=%235e5951&amp;id=U3EWV&amp;originHeight=100&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **查看三台主机运行情况**</code></pre><p>info replication<br>打印主从复制的相关信息</p><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730060901-a0b333aa-8379-4a88-a487-9ec66fbc18bd.jpeg#averageHue=%235a5853&amp;id=dElMA&amp;originHeight=180&amp;originWidth=612&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **配从(库)不配主(库) **</code></pre><p>slaveof  <ip><port><br>成为某个实例的从服务器<br>1、在6380和6381上执行: slaveof 127.0.0.1 6379<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730061199-cc3e0dca-3cc4-4183-bec2-31ac0c33d1d7.jpeg#averageHue=%231f1d1d&amp;id=yKo9V&amp;originHeight=191&amp;originWidth=611&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>2、在主机上写，在从机上可以读取数据<br>在从机上写数据报错<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730061424-10f974eb-e268-4ed3-970a-58624217171e.jpeg#averageHue=%23625b51&amp;id=NxioL&amp;originHeight=38&amp;originWidth=513&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>3、主机挂掉，重启就行，一切如初<br>4、从机重启需重设：slaveof 127.0.0.1 6379<br>可以将配置增加到文件中。永久生效。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730061676-2e200633-8bbd-4339-8cfa-12e606c17002.jpeg#averageHue=%230b0a09&amp;id=SapCx&amp;originHeight=248&amp;originWidth=538&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>常用3招</strong><ol><li><strong>一主二仆</strong></li></ol></li></ol><p>切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的k1,k2,k3是否也可以复制？<br>从机是否可以写？set可否？<br>主机shutdown后情况如何？从机是上位还是原地待命？<br>主机又回来了后，主机新增记录，从机还能否顺利复制？<br>其中一台从机down后情况如何？依照原有它能跟上大部队吗？</p><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730061938-227d99d9-6b81-481e-863e-528691c14421.jpeg#averageHue=%23fbfbf8&amp;id=xOZvU&amp;originHeight=109&amp;originWidth=284&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **薪火相传**</code></pre><p>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。<br>用 slaveof  <ip><port><br>中途变更转向:会清除之前的数据，重新建立拷贝最新的<br>风险是一旦某个slave宕机，后面的slave都没法备份<br>主机挂了，从机还是从机，无法写数据了<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730062220-2562dda9-6423-4298-81e7-2579ef008c95.jpeg#averageHue=%23fafaf7&amp;id=I2xJV&amp;originHeight=89&amp;originWidth=407&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730062487-6c6e8c25-d0b8-446f-bcdc-36fab2a44a0e.jpeg#averageHue=%23191616&amp;id=R9Lra&amp;originHeight=153&amp;originWidth=625&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **反客为主**</code></pre><p>当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。<br>用 slaveof  no one  将从机变为主机。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730062734-bb999b61-30d6-4f9b-8428-f7718dd62b06.jpeg#averageHue=%237c766e&amp;id=DfAOO&amp;originHeight=145&amp;originWidth=616&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>复制原理</strong></li></ol><ul><li>Slave启动成功连接到master后会发送一个sync命令</li><li>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步</li><li>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li><li>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</li><li>但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730062965-da099463-4551-4b5f-948b-90d3dd45f71c.jpeg#averageHue=%23fbfbf9&amp;id=iFoVd&amp;originHeight=157&amp;originWidth=397&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>哨兵模式(sentinel)</strong><ol><li><strong>是什么</strong></li></ol></li></ol><p><strong>反客为主的自动版</strong>，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730063255-4b1a1df6-440e-404a-9038-9dcd704a13f8.jpeg#averageHue=%23fdfdfa&amp;id=yTMO9&amp;originHeight=200&amp;originWidth=305&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **怎么玩(使用步骤)**     1. **调整为一主二仆模式，6379带着6380、6381**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730063529-6128db26-5298-4980-bb0b-aa20b60715d1.jpeg#averageHue=%231e1c1b&amp;id=O9Zhq&amp;originHeight=192&amp;originWidth=615&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>     1. **自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错**     2. **配置哨兵,填写内容**</code></pre><p>sentinel monitor mymaster 127.0.0.1 6379 1<br>其中mymaster为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量。</p><pre><code>     1. **启动哨兵**</code></pre><p>/usr/local/bin<br>redis做压测可以用自带的redis-benchmark工具<br>执行redis-sentinel  /myredis/sentinel.conf<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730063836-22f7cd8d-4279-494b-8bdb-60758c46aa30.jpeg#averageHue=%230a0605&amp;id=K9J6x&amp;originHeight=517&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>     1. **当主机挂掉，从机选举中产生新的主机**</code></pre><p>(大概10秒左右可以看到哨兵窗口日志，切换了新的主机)<br>哪个从机会被选举为主机呢？根据优先级别：slave-priority<br>原主机重启后会变为从机。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730064132-98b85c71-677b-42f0-8e44-79623a2d24c9.jpeg#averageHue=%235a564f&amp;id=pV7en&amp;originHeight=496&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>     1. **复制延时**</code></pre><p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p><pre><code>  1. **故障恢复**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730064417-c797bdf6-42f1-4a57-9584-25f699de26fe.jpeg#averageHue=%23ececec&amp;id=LHDIf&amp;originHeight=301&amp;originWidth=553&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>优先级在redis.conf中默认：slave-priority 100，值越小优先级越高<br>偏移量是指获得原主机数据最全的<br>每个redis实例启动后都会随机生成一个40位的runid</p><pre><code>  1. **主从复制**</code></pre><p>| **private static **JedisSentinelPool <em>jedisSentinelPool</em>=<strong>null</strong>;<br>**public static  **Jedis getJedisFromSentinel(){<strong>if</strong>(<em>jedisSentinelPool</em>==<strong>null</strong>){<br>Set<String> sentinelSet=<strong>new <strong>HashSet&lt;&gt;();<br>sentinelSet.add(</strong>“192.168.11.103:26379”</strong>);</p><pre><code>        JedisPoolConfig jedisPoolConfig =**new **JedisPoolConfig();        jedisPoolConfig.setMaxTotal(10); _//最大可用连接数_jedisPoolConfig.setMaxIdle(5); _//最大闲置连接数_jedisPoolConfig.setMinIdle(5); _//最小闲置连接数_jedisPoolConfig.setBlockWhenExhausted(**true**); _//连接耗尽是否等待_jedisPoolConfig.setMaxWaitMillis(2000); _//等待时间_jedisPoolConfig.setTestOnBorrow(**true**); _//取连接的时候进行一下测试 ping pong</code></pre><p>jedisSentinelPool_=<strong>new <strong>JedisSentinelPool(</strong>“mymaster”</strong>,sentinelSet,jedisPoolConfig);**return **<em>jedisSentinelPool</em>.getResource();<br>}<strong>else</strong>{**return **<em>jedisSentinelPool</em>.getResource();<br>}</p><table><thead><tr><th>}</th></tr></thead></table><ol><li><strong>Redis集群</strong><ol><li><strong>问题</strong></li></ol></li></ol><p>容量不够，redis如何进行扩容？<br>并发写操作， redis如何分摊？<br>另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。<br>之前通过代理主机来解决，但是redis3.0中提供了解决方案。就是无中心化集群配置。</p><ol><li><strong>什么是集群</strong></li></ol><p>Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。<br>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p><ol><li><strong>删除持久化数据</strong></li></ol><p>将rdb,aof文件都删除掉。</p><ol><li><strong>制作6个实例，6379,6380,6381,6389,6390,6391</strong><ol><li><strong>配置基本信息</strong></li></ol></li></ol><p>开启daemonize yes<br>Pid文件名字<br>指定端口<br>Log文件名字<br>Dump.rdb名字<br>Appendonly 关掉或者换名字</p><pre><code>  1. **redis cluster配置修改**</code></pre><p>cluster-enabled yes    打开集群模式<br>cluster-config-file nodes-6379.conf  设定节点配置文件名<br>cluster-node-timeout 15000   设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。</p><p>| include /home/bigdata/redis.conf<br>port 6379<br>pidfile “/var/run/redis_6379.pid”<br>dbfilename “dump6379.rdb”<br>dir “/home/bigdata/redis_cluster”<br>logfile “/home/bigdata/redis_cluster/redis_err_6379.log”<br>cluster-enabled yes<br>cluster-config-file nodes-6379.conf</p><table><thead><tr><th>cluster-node-timeout 15000</th></tr></thead></table><pre><code>  1. **修改好redis6379.conf文件，拷贝多个redis.conf文件**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730064711-25ff6879-8c94-4ff2-912e-19dc08501733.jpeg#averageHue=%2352524a&amp;id=uCbvU&amp;originHeight=122&amp;originWidth=146&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **使用查找替换修改另外5个文件**</code></pre><p>例如：:%s/6379/6380</p><pre><code>  1. **启动6个redis服务**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730065009-ba59696d-4822-48c4-93e0-816f06495ae3.jpeg#averageHue=%2358534d&amp;id=aum7N&amp;originHeight=390&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>将六个节点合成一个集群</strong></li></ol><p>组合之前，请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730065368-75e6de27-eeb8-4e87-a5ab-aad76a30ab41.jpeg#averageHue=%239a9488&amp;id=LnPSN&amp;originHeight=325&amp;originWidth=551&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ul><li>合体：</li></ul><p>cd  /opt/redis-6.2.1/src</p><table><thead><tr><th>redis-cli --cluster create --cluster-replicas 1 192.168.11.101:6379 192.168.11.101:6380 192.168.11.101:6381 192.168.11.101:6389 192.168.11.101:6390 192.168.11.101:6391</th></tr></thead></table><p>此处不要用127.0.0.1， 请用真实IP地址<br>–replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730065713-2362c661-8190-45e5-af40-b67d53a1a702.jpeg#averageHue=%23090505&amp;id=BB1yK&amp;originHeight=229&amp;originWidth=613&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730066034-314aefd9-6dbd-44ce-aaaa-235bdb11969b.jpeg#averageHue=%23656059&amp;id=upEEw&amp;originHeight=400&amp;originWidth=453&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ul><li>普通方式登录</li></ul><p>可能直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，应该以集群方式登录。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730066308-ffcffe03-91f5-486f-a8d4-ab6fd5acd1e3.jpeg#averageHue=%2390887c&amp;id=cKQ0P&amp;originHeight=96&amp;originWidth=352&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>-c 采用集群策略连接，设置数据会自动切换到相应的写主机</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730066592-57524d74-ea9c-4c77-a0be-922f9b6fa646.jpeg#averageHue=%23110908&amp;id=HUIXr&amp;originHeight=136&amp;originWidth=545&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>通过 cluster nodes 命令查看集群信息</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730067892-bcf1e26e-d09d-49e7-ab1d-30c7e1bcd569.jpeg#averageHue=%23373734&amp;id=ZEIAM&amp;originHeight=70&amp;originWidth=619&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>redis cluster 如何分配这六个节点?</strong></li></ol><p>一个集群至少要有三个主节点。<br>选项 --cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。<br>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。</p><ol><li><strong>什么是slots</strong></li></ol><p><strong>[OK] All nodes agree about slots configuration.</strong><br><strong>&gt;&gt;&gt; Check for open slots…</strong><br><strong>&gt;&gt;&gt; Check slots coverage…</strong><br><strong>[OK] All 16384 slots covered.</strong><br>一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个，<br>集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。<br>集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点， 其中：<br>节点 A 负责处理 0 号至 5460 号插槽。<br>节点 B 负责处理 5461 号至 10922 号插槽。<br>节点 C 负责处理 10923 号至 16383 号插槽。</p><ol><li><strong>在集群中录入值</strong></li></ol><p>在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。<br>redis-cli客户端提供了 –c 参数实现自动重定向。<br>如 redis-cli  -c –p 6379 登入后，再录入、查询键值对可以自动重定向。<br>不在一个slot下的键值，是不能使用mget,mset等多键操作。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730068169-f49380f0-681e-41d7-8b82-32c7a26bc5f6.jpeg#averageHue=%235d5850&amp;id=ovTRs&amp;originHeight=38&amp;originWidth=477&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730068454-8358ba48-2f36-4d66-8cb6-1c760ec33013.jpeg#averageHue=%23635d54&amp;id=tiyJ9&amp;originHeight=51&amp;originWidth=477&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>查询集群中的值</strong></li></ol><p>CLUSTER GETKEYSINSLOT <slot><count> 返回 count 个 slot 槽中的键。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730068715-d5089a9d-586c-4755-85ab-2f07e10e337e.jpeg#averageHue=%230b0a09&amp;id=trh58&amp;originHeight=159&amp;originWidth=458&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>故障恢复</strong></li></ol><p>如果主节点下线？从节点能否自动升为主节点？注意：<strong>15秒超时</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730069111-379b6de7-4859-4afe-b479-807245c3400a.jpeg#averageHue=%233e3e3b&amp;id=nO7l1&amp;originHeight=69&amp;originWidth=612&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>主节点恢复后，主从关系会如何？主节点回来变成从机。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730069586-dc99921d-5a48-491a-bb57-67c66f78919f.jpeg#averageHue=%233c3c39&amp;id=E6CJd&amp;originHeight=69&amp;originWidth=611&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?<br>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉<br>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。<br>redis.conf中的参数  cluster-require-full-coverage</p><ol><li><strong>集群的Jedis开发</strong></li></ol><p>即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。<br>无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。</p><p>| public class JedisClusterTest {<br>public static void main(String[] args) { <br>Set<HostAndPort>set =new HashSet<HostAndPort>();<br>set.add(new HostAndPort(“192.168.31.211”,6379));<br>JedisCluster jedisCluster=new JedisCluster(set);<br>jedisCluster.set(“k1”, “v1”);<br>System.<em>out.println(jedisCluster.get(“k1”));</em><br>}</p><table><thead><tr><th>}</th></tr></thead></table><ol><li><strong>Redis 集群提供了以下好处</strong></li></ol><p>实现扩容<br>分摊压力<br>无中心配置相对简单</p><ol><li><strong>Redis 集群的不足</strong></li></ol><p>多键操作是不被支持的<br>多键的Redis事务是不被支持的。lua脚本不被支持<br>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</p><ol><li><strong>Redis应用问题解决</strong><ol><li><strong>缓存穿透</strong><ol><li><strong>问题描述</strong></li></ol></li></ol></li></ol><p>key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730069953-275cddcd-e44c-40e5-9b9f-d46ded46ad78.png#averageHue=%23faf4f3&amp;id=TrOEm&amp;originHeight=329&amp;originWidth=677&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **解决方案**</code></pre><p>一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。<br>解决方案：</p><ol><li>**对空值缓存：**如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟</li><li><strong>设置可访问的名单（白名单）：</strong></li></ol><p>使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</p><ol><li><strong>采用布隆过滤器</strong>：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。</li></ol><p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)<br>将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。</p><ol><li>**进行实时监控：**当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务<ol><li><strong>缓存击穿</strong><ol><li><strong>问题描述</strong></li></ol></li></ol></li></ol><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730070215-e34d05fd-bf8e-40e6-af86-88ae9eb44e95.png#averageHue=%23faf6f5&amp;id=xAfbW&amp;originHeight=343&amp;originWidth=723&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **解决方案**</code></pre><p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。<br>解决问题：<br>**（1）预先设置热门数据：**在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长<br>**（2）实时调整：**现场监控哪些数据热门，实时调整key的过期时长<br><strong>（3）使用锁：</strong></p><ol><li>就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。</li><li>先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key</li><li>当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；</li><li>当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730070470-f8183b79-bf14-4a22-9fbc-3cc4835cb2af.png#averageHue=%23fbfbfb&amp;id=VBlaP&amp;originHeight=411&amp;originWidth=448&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>缓存雪崩</strong><ol><li><strong>问题描述</strong></li></ol></li></ol><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。<br>缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key<br>正常访问<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730070765-88efeeb3-4ea4-4960-ae38-84aa60eb556d.png#averageHue=%23faf8f7&amp;id=LHa9y&amp;originHeight=484&amp;originWidth=826&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>缓存失效瞬间<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730071077-28e3b97a-2cdc-4f8a-a415-8e0ec739bfbe.png#averageHue=%23faf8f7&amp;id=qyRBl&amp;originHeight=473&amp;originWidth=826&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **解决方案**</code></pre><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕！<br>解决方案：</p><ol><li>**构建多级缓存架构：**nginx缓存 + redis缓存 +其他缓存（ehcache等）</li><li><strong>使用锁或队列：</strong></li></ol><p>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况</p><ol><li><strong>设置过期标志更新缓存：</strong></li></ol><p>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</p><ol><li><strong>将缓存失效时间分散开：</strong></li></ol><p>比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><ol><li><strong>分布式锁</strong><ol><li><strong>问题描述</strong></li></ol></li></ol><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！<br>分布式锁主流的实现方案：</p><ol><li><p>基于数据库实现分布式锁</p></li><li><p>基于缓存（Redis等）</p></li><li><p>基于Zookeeper<br>每一种分布式锁解决方案都有各自的优缺点：</p></li><li><p>性能：redis最高</p></li><li><p>可靠性：zookeeper最高<br>这里，我们就基于redis实现分布式锁。</p><ol><li><strong>解决方案：使用redis实现分布式锁</strong></li></ol></li></ol><p>redis:命令</p><h1>set sku:1:info “OK” NX PX 10000</h1><p>EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。<br>PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。<br>NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。<br>XX ：只在键已经存在时，才对键进行设置操作。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730071356-417caa2a-c06b-40b6-a1a1-57e0999e745e.png#averageHue=%23f7ebda&amp;id=QibzD&amp;originHeight=413&amp;originWidth=516&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><p>多个客户端同时获取锁（setnx）</p></li><li><p>获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</p></li><li><p>其他客户端等待重试</p><ol><li><strong>编写代码</strong></li></ol></li></ol><p>Redis: set num 0</p><p>| @GetMapping(<strong>“testLock”</strong>)<strong>public void <strong>testLock(){<br>_//1获取锁，setne<br>_Boolean lock = <strong>redisTemplate</strong>.opsForValue().setIfAbsent(</strong>“lock”</strong>, <strong>“111”</strong>);<br>_//2获取锁成功、查询num的值<br>_<strong>if</strong>(lock){<br>Object value = <strong>redisTemplate</strong>.opsForValue().get(<strong>“num”</strong>);<br>_//2.1判断num为空return<br>_<strong>if</strong>(StringUtils.<em>isEmpty</em>(value)){<br><strong>return</strong>;<br>}<br>_//2.2有值就转成成int<br>_<strong>int <strong>num = Integer.<em>parseInt</em>(value+</strong>“”</strong>);<br>_//2.3把redis的num加1<br>_<strong>redisTemplate</strong>.opsForValue().set(<strong>“num”</strong>, ++num);<br>_//2.4释放锁，del<br>_<strong>redisTemplate</strong>.delete(<strong>“lock”</strong>);</p><pre><code>&#125;**else**&#123;    _//3获取锁失败、每隔0.1秒再获取    _**try **&#123;        Thread._sleep_(100);        testLock();    &#125; **catch **(InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><table><thead><tr><th>}</th></tr></thead></table><p>重启，服务集群，通过网关压力测试：<br>ab -n 1000 -c 100 <a href="http://192.168.140.1:8080/test/testLock">http://192.168.140.1:8080/test/testLock</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730071601-fe3ab0bd-e460-4b8b-849a-182bb9e26043.png#averageHue=%23080604&amp;id=gLlai&amp;originHeight=339&amp;originWidth=675&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>查看redis中num的值：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730071805-569a0a60-558e-439f-bb0f-003547344d5b.png#averageHue=%23070503&amp;id=cqeJ7&amp;originHeight=79&amp;originWidth=254&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>基本实现。<br>问题：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放<br>解决：设置过期时间，自动释放锁。</p><pre><code>  1. **优化之设置锁的过期时间**</code></pre><p>设置过期时间有两种方式：</p><ol><li>首先想到通过expire设置过期时间（缺乏原子性：如果在setnx和expire之间出现异常，锁也无法释放）</li><li>在set时指定过期时间（推荐）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730072097-a77ddcab-ed0e-4a5b-b5f2-4c8880d8f329.png#averageHue=%23e5ba99&amp;id=Rzw5k&amp;originHeight=469&amp;originWidth=535&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>设置过期时间：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730072368-07cc7a51-aa40-4613-9e55-361b8f4a67f5.png#averageHue=%23f9f9f9&amp;id=dn0YL&amp;originHeight=366&amp;originWidth=938&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>压力测试肯定也没有问题。自行测试<br>问题：可能会释放其他服务器的锁。</li></ol><p>场景：如果业务逻辑的执行时间是7s。执行流程如下</p><ol><li>index1业务逻辑没执行完，3秒后锁被自动释放。</li><li>index2获取到锁，执行业务逻辑，3秒后锁被自动释放。</li><li>index3获取到锁，执行业务逻辑</li><li>index1业务逻辑执行完成，开始调用del释放锁，这时释放的是index3的锁，导致index3的业务只执行1s就被别人释放。</li></ol><p>最终等于没锁的情况。</p><p>解决：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁</p><pre><code>  1. **优化之UUID防误删**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730072580-28c79e0f-3450-45e9-82d6-fa412efc8ee4.png#averageHue=%23eac79d&amp;id=OZwju&amp;originHeight=477&amp;originWidth=535&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730072856-6390182a-5813-4629-a70c-f663a2a33437.png#averageHue=%23fcf5f3&amp;id=Z1TwL&amp;originHeight=464&amp;originWidth=682&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>问题：删除操作缺乏原子性。<br>场景：</p><ol><li>index1执行删除时，查询到的lock值确实和uuid相等</li></ol><p>uuid=v1<br>set(lock,uuid)；<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730073160-2aaca9d4-f781-484d-ba52-a8ff40078ed7.png#averageHue=%23d6c0a0&amp;id=ufXoz&amp;originHeight=28&amp;originWidth=590&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li>index1执行删除前，lock刚好过期时间已到，被redis自动释放</li></ol><p>在redis中没有了lock，没有了锁。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730073432-cd41f3c8-78eb-4eb5-a00b-364c584de07b.png#averageHue=%23d5cca5&amp;id=z7cRe&amp;originHeight=24&amp;originWidth=379&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li>index2获取了lock</li></ol><p>index2线程获取到了cpu的资源，开始执行方法<br>uuid=v2<br>set(lock,uuid)；</p><ol><li>index1执行删除，此时会把index2的lock删除</li></ol><p>index1 因为已经在方法中了，所以不需要重新上锁。index1有执行的权限。index1已经比较完成了，这个时候，开始执行<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730073672-4a90d87b-fc4d-4c89-bcfb-94163aed807f.png#averageHue=%23d5cca5&amp;id=v1xgD&amp;originHeight=24&amp;originWidth=379&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>删除的index2的锁！</p><pre><code>  1. **优化之LUA脚本保证删除的原子性**</code></pre><p>| @GetMapping(<strong>“testLockLua”</strong>)**public void **testLockLua() {_    //1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中<br>_String uuid = UUID.<em>randomUUID</em>().toString();<br>_//2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！<br>_String skuId = <strong>“25”</strong>; _// 访问skuId 为25号的商品 100008348542<br>_String locKey = **“lock:” **+ skuId; _// 锁住的是每个商品的数据</p><pre><code>// 3 获取锁_Boolean lock = **redisTemplate**.opsForValue().setIfAbsent(locKey, uuid, 3, TimeUnit.**_SECONDS_**);_// 第一种： lock 与过期时间中间不写任何的代码。// redisTemplate.expire(&quot;lock&quot;,10, TimeUnit.SECONDS);//设置过期时间// 如果true_**if **(lock) &#123;    _// 执行的业务逻辑开始    // 获取缓存中的num 数据    _Object value = **redisTemplate**.opsForValue().get(**&quot;num&quot;**);    _// 如果是空直接返回    _**if **(StringUtils._isEmpty_(value)) &#123;        **return**;    &#125;    _// 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！    _**int **num = Integer._parseInt_(value + **&quot;&quot;**);    _// 使num 每次+1 放入缓存    _**redisTemplate**.opsForValue().set(**&quot;num&quot;**, String._valueOf_(++num));    _/*使用lua脚本来锁*/    // 定义lua 脚本    _String script = **&quot;if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end&quot;**;    _// 使用redis执行lua执行    _DefaultRedisScript&lt;Long&gt; redisScript = **new **DefaultRedisScript&lt;&gt;();    redisScript.setScriptText(script);    _// 设置一下返回值类型 为Long    // 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型，    // 那么返回字符串与0 会有发生错误。    _redisScript.setResultType(Long.**class**);    _// 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。    _**redisTemplate**.execute(redisScript, Arrays._asList_(locKey), uuid);&#125; **else **&#123;    _// 其他线程等待    _**try **&#123;        _// 睡眠        _Thread._sleep_(1000);        _// 睡醒了之后，调用方法。        _testLockLua();    &#125; **catch **(InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><table><thead><tr><th>}</th></tr></thead></table><p>Lua 脚本详解：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730073899-6d3141e9-8519-4cdb-8541-2dd6e8bdc18d.png#averageHue=%23fdfcfb&amp;id=ETVfk&amp;originHeight=480&amp;originWidth=1028&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>项目中正确使用：</p><p>|</p><ol><li>定义key，key应该是为每个sku定义的，也就是每个sku有一把锁。</li></ol><p>String locKey =<strong>“lock:”</strong>+skuId; <em>// 锁住的是每个商品的数据</em></p><table><thead><tr><th>Boolean lock = <strong>redisTemplate</strong>.opsForValue().setIfAbsent(locKey, uuid,3,TimeUnit.<strong><em>SECONDS</em></strong>);</th></tr></thead><tbody><tr><td><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730074191-2c9f99ec-d32f-48b3-b315-1ff9b4ca3aaf.png#averageHue=%23fcf8f6&amp;id=zrxML&amp;originHeight=403&amp;originWidth=1234&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></td></tr></tbody></table><pre><code>  1. **总结**</code></pre><p>1、加锁</p><p>| _// 1. 从redis中获取锁,set k1 v1 px 20000 nx_String uuid = UUID.<em>randomUUID</em>().toString();<br>Boolean lock = <strong>this</strong>.<strong>redisTemplate</strong>.opsForValue()<br>.setIfAbsent(<strong>“lock”</strong>, uuid, 2, TimeUnit.<strong><em>SECONDS</em></strong>); |<br>| — |</p><ol><li><p>使用lua释放锁<br>| <em>// 2. 释放锁 del_String script = <strong>“if redis.call(‘get’, KEYS[1]) == ARGV[1] then return redis.call(‘del’, KEYS[1]) else return 0 end”</strong>;</em>// 设置lua脚本返回的数据类型_DefaultRedisScript<Long> redisScript = <strong>new <strong>DefaultRedisScript&lt;&gt;();_// 设置lua脚本返回类型为Long_redisScript.setResultType(Long.<strong>class</strong>);<br>redisScript.setScriptText(script);<strong>redisTemplate</strong>.execute(redisScript, Arrays.<em>asList</em>(</strong>“lock”</strong>),uuid); |<br>| — |</p></li><li><p>重试<br>| Thread.<em>sleep</em>(500);<br>testLock(); |<br>| — |</p></li></ol><p>为了确保分布式锁可用，我们至少要确保锁的实现同时<strong>满足以下四个条件</strong>：</p><ul><li>互斥性。在任意时刻，只有一个客户端能持有锁。</li><li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li><li>加锁和解锁必须具有原子性。</li></ul><ol><li><strong>Redis6.0新功能</strong><ol><li><strong>ACL</strong><ol><li><strong>简介</strong></li></ol></li></ol></li></ol><p>Redis ACL是Access Control List（访问控制列表）的缩写，该功能允许根据可以执行的命令和可以访问的键来限制某些连接。<br>在Redis 5版本之前，Redis 安全规则只有密码控制 还有通过rename 来调整高危命令比如 flushdb ， KEYS* ， shutdown 等。Redis 6 则提供ACL的功能对用户进行更细粒度的权限控制 ：<br>（1）接入权限:用户名和密码<br>（2）可以执行的命令<br>（3）可以操作的 KEY<br>参考官网：<a href="https://redis.io/topics/acl">https://redis.io/topics/acl</a></p><pre><code>  1. **命令**</code></pre><p>1、使用acl list命令展现用户权限列表<br>（1）数据说明<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730074431-05b634e8-61c0-434c-a443-98aa75f7c092.png#averageHue=%23b0adab&amp;id=FB9YM&amp;originHeight=179&amp;originWidth=554&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>2、使用acl cat命令<br>（1）查看添加权限指令类别<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730074718-a4d67980-3dbd-460a-b8bc-5cf765f8f8b4.png#averageHue=%230a0705&amp;id=WeuV7&amp;originHeight=353&amp;originWidth=201&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>（2）加参数类型名可以查看类型下具体命令<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730074979-70b85580-5a5c-4cdd-b862-5e4e55a68541.png#averageHue=%23070503&amp;id=ixrMP&amp;originHeight=336&amp;originWidth=257&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>3、使用acl whoami命令查看当前用户<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730075281-c2b829f3-ef21-4de1-b410-f92965d4e1b1.png#averageHue=%230f0b08&amp;id=TpN1o&amp;originHeight=34&amp;originWidth=212&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>4、使用aclsetuser命令创建和编辑用户ACL<br>（1）ACL规则<br>下面是有效ACL规则的列表。某些规则只是用于激活或删除标志，或对用户ACL执行给定更改的单个单词。其他规则是字符前缀，它们与命令或类别名称、键模式等连接在一起。</p><table><thead><tr><th>ACL规则</th><th></th><th></th></tr></thead><tbody><tr><td>类型</td><td>参数</td><td>说明</td></tr><tr><td>启动和禁用用户</td><td><strong>on</strong></td><td>激活某用户账号</td></tr><tr><td></td><td><strong>off</strong></td><td>禁用某用户账号。注意，已验证的连接仍然可以工作。如果默认用户被标记为off，则新连接将在未进行身份验证的情况下启动，并要求用户使用AUTH选项发送AUTH或HELLO，以便以某种方式进行身份验证。</td></tr><tr><td>权限的添加删除</td><td><strong>+<command></strong></td><td>将指令添加到用户可以调用的指令列表中</td></tr><tr><td></td><td><strong>-<command></strong></td><td>从用户可执行指令列表移除指令</td></tr><tr><td></td><td><strong>+@<category></strong></td><td>添加该类别中用户要调用的所有指令，有效类别为@admin、@set、@sortedset…等，通过调用ACL CAT命令查看完整列表。特殊类别@all表示所有命令，包括当前存在于服务器中的命令，以及将来将通过模块加载的命令。</td></tr><tr><td></td><td>-@<actegory></td><td>从用户可调用指令中移除类别</td></tr><tr><td></td><td><strong>allcommands</strong></td><td>+@all的别名</td></tr><tr><td></td><td><strong>nocommand</strong></td><td>-@all的别名</td></tr><tr><td>可操作键的添加或删除</td><td><strong>~<pattern></strong></td><td>添加可作为用户可操作的键的模式。例如~*允许所有的键</td></tr></tbody></table><p>（2）通过命令创建新用户默认权限<br>acl setuser user1<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730075555-fb2539f0-9a30-41cf-a945-db4f7b570a59.png#averageHue=%230c0906&amp;id=hG7rS&amp;originHeight=82&amp;originWidth=295&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>在上面的示例中，我根本没有指定任何规则。如果用户不存在，这将使用just created的默认属性来创建用户。如果用户已经存在，则上面的命令将不执行任何操作。<br>（3）设置有用户名、密码、ACL权限、并启用的用户<br>acl setuser user2 on &gt;password ~cached:* +get<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730075866-dd1a0cfb-2d9d-4c28-9b53-ed1a51a031b1.png#averageHue=%23090604&amp;id=R4oZ1&amp;originHeight=127&amp;originWidth=669&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>(4)切换用户，验证权限<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730076093-e51c4181-36eb-4d57-9f5a-f0eafdd9b50d.png#averageHue=%23070503&amp;id=yITh8&amp;originHeight=242&amp;originWidth=673&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>IO多线程</strong><ol><li><strong>简介</strong></li></ol></li></ol><p>Redis6终于支撑多线程了，告别单线程了吗？<br>IO多线程其实指<strong>客户端交互部分</strong>的<strong>网络IO</strong>交互处理模块<strong>多线程</strong>，而非<strong>执行命令多线程</strong>。Redis6执行命令依然是单线程。</p><pre><code>  1. **原理架构**</code></pre><p>Redis 6 加入多线程,但跟 Memcached 这种从 IO处理到数据访问多线程的实现模式有些差异。Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题。整体的设计大体如下:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730076372-2cc09b37-398c-4e0c-87c5-b4aca4d719ba.png#averageHue=%2397a72b&amp;id=zmIJm&amp;originHeight=411&amp;originWidth=656&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>另外，多线程IO默认也是不开启的，需要再配置文件中配置<br>io-threads-do-reads  yes<br>io-threads 4</p><ol><li><strong>工具支持 Cluster</strong></li></ol><p>之前老版Redis想要搭集群需要单独安装ruby环境，Redis 5 将 redis-trib.rb 的功能集成到 redis-cli 。另外官方 redis-benchmark 工具开始支持 cluster 模式了，通过多线程的方式对多个分片进行压测。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730076655-3a897056-f7ac-4c50-bd1b-ce082189a699.png#averageHue=%230d0a07&amp;id=Phaot&amp;originHeight=290&amp;originWidth=673&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>Redis新功能持续关注</strong></li></ol><p>Redis6新功能还有：<br>1、RESP3新的 Redis 通信协议：优化服务端与客户端之间通信<br>2、Client side caching客户端缓存：基于 RESP3 协议实现的客户端缓存功能。为了进一步提升缓存的性能，将客户端经常访问的数据cache到客户端。减少TCP网络交互。<br>3、Proxy集群代理模式：Proxy 功能，让 Cluster 拥有像单实例一样的接入方式，降低大家使用cluster的门槛。不过需要注意的是代理不改变 Cluster 的功能限制，不支持的命令还是不会支持，比如跨 slot 的多Key操作。<br>4、Modules API<br>Redis 6中模块API开发进展非常大，因为Redis Labs为了开发复杂的功能，从一开始就用上Redis模块。Redis可以变成一个框架，利用Modules来构建不同系统，而不需要从头开始写然后还要BSD许可。Redis一开始就是一个向编写各种系统开放的平台。</p>]]></content>
    
    
      
      
    <summary type="html"> &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h2 id=&quot;框架高级课程系列之Redis6&quot;&gt;框架高级课程系列之Redis6&lt;/h2&gt;
&lt;p&gt;尚硅谷JavaEE教研组&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;NoSQL数据库简介&lt;</summary>
      
    
    
    
    <category term="中间件" scheme="http://www.bojiboqi.fun/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="redis" scheme="http://www.bojiboqi.fun/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>软件体系实验结构一：</title>
    <link href="http://www.bojiboqi.fun/2024/02/28/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%84%E4%B8%80%EF%BC%9A/"/>
    <id>http://www.bojiboqi.fun/2024/02/28/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%84%E4%B8%80%EF%BC%9A/</id>
    <published>2024-02-28T13:02:28.554Z</published>
    <updated>2024-02-28T13:07:53.200Z</updated>
    
    <content type="html"><![CDATA[<p><a name="cVg2T"></a></p><h1>一、     实验内容</h1><p>噪声监测系统通常由声级计（声音传感器）、采集单元和传输单元、PC计算机等部分组成。采集单元从传感器采集声音信息并转换为数字，然后通过传输单元上传到PC端（暂定采用串口通讯方式），PC端通过技术分析后将数据上传至数据库服务器，并在PC端以合适方式展示噪声信息。<br />（1）    采集单元由单片机构成，负责数据采集，并通过串口通讯方式上传给PC端；<br />（2）    PC端软件需要使用RS232 SDK来与采集单元通讯（将来可能更换为其它通讯方式）。<br />（3）    操作员即可以实时查看当前采集到的噪声信息，也可以分析数据库服务器中保存的任意时段噪声数据并打印输出分析报告。<br />任务：<br />（1）    利用“4+1”视图建模方法对以上描述的“噪声监测系统”进行软件体系结构设计。<br />（2）    请说明当PC端与采集单元的通讯方式发生变化，你设计的体系结构如何应对？<br><a name="oXBJ2"></a></p><h1>二.实验步骤：</h1><p><a name="B4eYI"></a></p><h3 id="UML图形工具：">UML图形工具：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698159226042-a739b842-f60f-4298-82db-642960693b27.png#averageHue=%23a9b8cf&amp;clientId=u801801c7-a9c6-4&amp;from=paste&amp;height=37&amp;id=u0da0c52a&amp;originHeight=46&amp;originWidth=118&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=4001&amp;status=done&amp;style=none&amp;taskId=ue0c9bcfd-3f49-4bf5-8a93-6a3d9ef0124&amp;title=&amp;width=94.4" alt="image.png"><br><a name="nYIXY"></a></p><h3 id="设计考虑：">设计考虑：</h3><ul><li>可维护性：软件应该易于维护和修改。</li><li>可重用性：软件应该易于重用。</li><li>可扩展性：软件应该易于扩展。</li><li>可移植性：软件应该易于移植到不同的平台。</li><li>可靠性：软件应该具有高可靠性，即在面对各种异常情况时，仍能保持正常运行。</li><li>性能：软件应该具有良好的性能，即能够在合理的时间内完成所需的任务。</li><li>安全性：软件应该具有良好的安全性，即能够保护用户数据和系统安全。</li></ul><p>在该系统中当PC端与采集单元的通讯方式发生变化时，只修改传输单元构件就可以了。<br><a name="JXaXc"></a></p><h3 id="场景视图：">场景视图：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698153699112-7fa93cdc-222a-4d16-874d-5e78cd61d2a3.png#averageHue=%23fbfafa&amp;clientId=u801801c7-a9c6-4&amp;from=paste&amp;height=402&amp;id=ua6eec258&amp;originHeight=502&amp;originWidth=1087&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=47190&amp;status=done&amp;style=none&amp;taskId=u7855be2e-7411-42d6-91d1-7220a19b188&amp;title=&amp;width=869.6" alt="image.png"><br><a name="N0iLV"></a></p><h3 id="逻辑视图：">逻辑视图：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698152866585-0dfa1d1a-ae1a-4d27-b982-26c93d615da4.png#averageHue=%23fbfbfb&amp;clientId=u801801c7-a9c6-4&amp;from=paste&amp;height=557&amp;id=ue708415f&amp;originHeight=696&amp;originWidth=836&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=60052&amp;status=done&amp;style=none&amp;taskId=u328a519f-dea8-4bcb-95b1-898928bfb89&amp;title=&amp;width=668.8" alt="image.png"><br><a name="lW6YR"></a></p><h3 id="开发视图：">开发视图：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698155637140-036debb3-55ce-43d1-b09c-5638bc865989.png#averageHue=%23fbfafa&amp;clientId=u801801c7-a9c6-4&amp;from=paste&amp;height=369&amp;id=u566380b8&amp;originHeight=461&amp;originWidth=982&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=30739&amp;status=done&amp;style=none&amp;taskId=u0c7f7c31-b7e0-4240-8cb1-ad5cb429857&amp;title=&amp;width=785.6" alt="image.png"><br><a name="EAFWw"></a></p><h3 id="过程视图：">过程视图：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698157462151-a983e627-1103-40d7-934b-774a9610190e.png#averageHue=%23fbfbfb&amp;clientId=u801801c7-a9c6-4&amp;from=paste&amp;height=531&amp;id=ub5b52c72&amp;originHeight=664&amp;originWidth=945&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=32263&amp;status=done&amp;style=none&amp;taskId=u5670c9a1-a54e-437c-91f8-88b97f71786&amp;title=&amp;width=756" alt="image.png"><br><a name="lZqbb"></a></p><h3 id="物理视图：">物理视图：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698158529311-9b819f7c-d9c4-4b22-9876-26fa35905f40.png#averageHue=%23fcfcfc&amp;clientId=u801801c7-a9c6-4&amp;from=paste&amp;height=478&amp;id=ueec8c875&amp;originHeight=597&amp;originWidth=1180&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=25775&amp;status=done&amp;style=none&amp;taskId=ub53983ef-ec4a-4da0-9a8e-86748cce8e0&amp;title=&amp;width=944" alt="image.png"><br><a name="DlaEY"></a></p><h1>总结：</h1><p>逻辑视图和开发视图描述系统的静态结构，而进程视图和物理视图描述系统的动态结构。<br />对于不同的软件系统来说，侧重的角度也有所不同。例如，对于管理信息系统来说，比较侧重于从逻辑视图和开发视图来描述系统，而对于实时控制系统来说，则比较注重于从进程视图和物理视图来描述系统。<br />“4+1”视图模型已经成功使用在几个大型项目中，无论是否在术语4中有一些本地定制和调整。它的确能使不同利益相关者找到他们想了解的软件架构信息。系统工程师使用物理视图，再到过程视图。最终用户、客户、数据专家使用逻辑视图。项目经理、软件配置人员使用开发视图。</p><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;cVg2T&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;一、     实验内容&lt;/h1&gt;
&lt;p&gt;噪声监测系统通常由声级计（声音传感器）、采集单元和传输单元、PC计算机等部分组成。采集单元从传感器采集声音信息并转换为数字，然后通过传输单元上传到PC端（暂定采用串口通讯方式）</summary>
      
    
    
    
    <category term="软件体系结构" scheme="http://www.bojiboqi.fun/categories/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="软件体系结构" scheme="http://www.bojiboqi.fun/tags/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    <category term="课程作业" scheme="http://www.bojiboqi.fun/tags/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>软件体系结构实验四：</title>
    <link href="http://www.bojiboqi.fun/2024/02/28/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9A/"/>
    <id>http://www.bojiboqi.fun/2024/02/28/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9A/</id>
    <published>2024-02-28T13:02:28.551Z</published>
    <updated>2024-02-28T13:02:57.816Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><a name="WECuS"></a></p><h2 id="一、-实验内容">一、 实验内容</h2><p>任务1：Web Service服务器端程序开发<br />开发个人所得税计算程序，并发布为Web服务。<br />Idea参考：<a href="https://blog.csdn.net/C1041067258/article/details/86543099">idea搭建WebService HelloWorld程序_helloworld wsdl-CSDN博客</a><br />任务2：Web Servic客户端程序开发<br />网站<a href="http://www.webxml.com.cn/">http://www.webxml.com.cn/</a>提供了诸如天气预报、航班时刻表、中英文翻译等许多公共web service功能，请利用这些web service功能开发一小型应用软件（比如：XXX天气预报系统、XXX航班查询系统等），软件名称自定。<br><a name="XaiLE"></a></p><h2 id="任务1：">任务1：</h2><p><a name="tDfTY"></a></p><h3 id="源代码地址：">源代码地址：</h3><p><a href="https://github.com/Redbiga/SA4.git">https://github.com/Redbiga/SA4.git</a><br><a name="iPWp0"></a></p><h3 id="源代码结构：">源代码结构：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698500885228-956579fd-588f-43a3-b330-92ce62b2f88d.png#averageHue=%23414a52&amp;clientId=ue18db17b-c587-4&amp;from=paste&amp;height=370&amp;id=u36f606c9&amp;originHeight=463&amp;originWidth=928&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=266515&amp;status=done&amp;style=none&amp;taskId=u4f3023b8-b940-419b-80d0-9ca87880647&amp;title=&amp;width=742.4" alt="image.png"><br><a name="uUjeV"></a></p><h3 id="运行截图：">运行截图：</h3><p>web配置启动成功：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698501049454-7f1324c6-c0cc-4294-b162-4f8c842d7c58.png#averageHue=%23fefdfd&amp;clientId=ue18db17b-c587-4&amp;from=paste&amp;height=364&amp;id=uadfe4268&amp;originHeight=455&amp;originWidth=669&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=21136&amp;status=done&amp;style=none&amp;taskId=u4a08b796-d0da-47b2-8ea5-badb0bcfa93&amp;title=&amp;width=535.2" alt="image.png"><br />成功发布服务截图：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698501069837-2a3bec51-36d6-4503-93c5-30f57f401b31.png#averageHue=%23f8f7f6&amp;clientId=ue18db17b-c587-4&amp;from=paste&amp;height=367&amp;id=ue14fbe12&amp;originHeight=459&amp;originWidth=697&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=40531&amp;status=done&amp;style=none&amp;taskId=u1165bf43-2945-47e4-a5fa-06bf6ad5d60&amp;title=&amp;width=557.6" alt="image.png"><br />使用服务截图：<br />输入不合法：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698501470365-57e3455f-adcf-481d-bba9-f6407354709f.png#averageHue=%23242427&amp;clientId=ue18db17b-c587-4&amp;from=paste&amp;height=262&amp;id=u983455a5&amp;originHeight=327&amp;originWidth=1054&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=171258&amp;status=done&amp;style=none&amp;taskId=ude2ff205-c575-4278-9602-99fe1a71ae1&amp;title=&amp;width=843.2" alt="image.png"><br />输入合法：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698502063675-f92161ab-a9c7-4596-bb67-9572dba2a0bd.png#averageHue=%23242325&amp;clientId=ue18db17b-c587-4&amp;from=paste&amp;height=219&amp;id=uc60d96e8&amp;originHeight=274&amp;originWidth=691&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=70952&amp;status=done&amp;style=none&amp;taskId=u46fef8c5-a301-4196-9adc-b82db4789f0&amp;title=&amp;width=552.8" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698502085421-43b9f5f1-fe0e-4377-ae54-4c256412d8ea.png#averageHue=%23252426&amp;clientId=ue18db17b-c587-4&amp;from=paste&amp;height=171&amp;id=u1d5041bc&amp;originHeight=214&amp;originWidth=617&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=51011&amp;status=done&amp;style=none&amp;taskId=u4c803333-1cb0-46f4-aa76-1dd966584e1&amp;title=&amp;width=493.6" alt="image.png"><br><a name="cKtMz"></a></p><h2 id="任务2：Web-Service客户端天气查询客户端">任务2：Web Service客户端天气查询客户端</h2><p><a name="M8mMV"></a></p><h4 id="源代码地址：-2">源代码地址：</h4><p><a href="https://github.com/Redbiga/SA4Weather-inquiry.git">https://github.com/Redbiga/SA4Weather-inquiry.git</a><br><a name="SVlYY"></a></p><h3 id="功能需求：">功能需求：</h3><p>查询天气<br><a name="plxAN"></a></p><h3 id="服务介绍：">服务介绍：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698503030903-56b2d015-24c3-44a1-9504-b8ad1fd6eb7a.png#averageHue=%23f9f8f6&amp;clientId=ue18db17b-c587-4&amp;from=paste&amp;height=668&amp;id=u01d76181&amp;originHeight=835&amp;originWidth=1029&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=237053&amp;status=done&amp;style=none&amp;taskId=u61b7b747-a335-423c-86e2-5e7a8abbe48&amp;title=&amp;width=823.2" alt="image.png"><br><a name="wdB80"></a></p><h4 id="源程序代码结构：">源程序代码结构：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698503175453-56d8e332-533e-4886-be81-f36fc0f9912a.png#averageHue=%2348545b&amp;clientId=ue18db17b-c587-4&amp;from=paste&amp;height=379&amp;id=ubc0ef041&amp;originHeight=474&amp;originWidth=880&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=256041&amp;status=done&amp;style=none&amp;taskId=u1c12743e-2544-4cdc-8bfe-b223599d06c&amp;title=&amp;width=704" alt="image.png"><br><a name="ghCbk"></a></p><h4 id="运行截图：-2">运行截图：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698503376791-b7a26bd4-face-4793-b956-59f6e10a2561.png#averageHue=%23f7f6f5&amp;clientId=ue18db17b-c587-4&amp;from=paste&amp;height=641&amp;id=u83035804&amp;originHeight=801&amp;originWidth=1031&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=112962&amp;status=done&amp;style=none&amp;taskId=u1722f247-b24d-422c-9bc3-23d7f446dca&amp;title=&amp;width=824.8" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698503386868-52979d14-6f28-4091-8cb7-08160f2eb280.png#averageHue=%23ebeae9&amp;clientId=ue18db17b-c587-4&amp;from=paste&amp;height=607&amp;id=u022c6f12&amp;originHeight=759&amp;originWidth=927&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=135928&amp;status=done&amp;style=none&amp;taskId=u0496e468-2457-40e3-99c5-1e2d6befbe6&amp;title=&amp;width=741.6" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698503407460-b6e433ca-62ad-4cf6-8d18-fa87a997ffeb.png#averageHue=%23f6f5f4&amp;clientId=ue18db17b-c587-4&amp;from=paste&amp;height=595&amp;id=u09973d0d&amp;originHeight=744&amp;originWidth=1017&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=86708&amp;status=done&amp;style=none&amp;taskId=u11116a06-7287-4352-add0-f865de0e500&amp;title=&amp;width=813.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698503429291-45190d30-2d80-43de-880c-2e65c3b19041.png#averageHue=%23f8f7f7&amp;clientId=ue18db17b-c587-4&amp;from=paste&amp;height=615&amp;id=u4178433e&amp;originHeight=769&amp;originWidth=994&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=64801&amp;status=done&amp;style=none&amp;taskId=ua18e17d6-2cca-4c2d-87b1-fd4f5bbd10e&amp;title=&amp;width=795.2" alt="image.png"></p><p><a name="GuTg9"></a></p><h2 id="遇到的问题：">遇到的问题：</h2><p>1.<a href="https://segmentfault.com/q/1010000042900375">Maven 错误：模块的 Maven 项目配置不可用</a><br />解决方法：右键单击 pom.xml，然后单击“添加为 Maven 项目”。<br><a name="vVPP5"></a></p><h2 id="总结：">总结：</h2><p><a href="https://zhuanlan.zhihu.com/p/126507013">Web Service是一种可以接收从Internet或者Intranet上的其它系统中传递过来的请求，轻量级的独立的通讯技术</a><a href="https://zhuanlan.zhihu.com/p/126507013">。它是通过SOAP在Web上提供的软件服务，使用WSDL文件进行说明，并通过UDDI进行注册</a><a href="https://zhuanlan.zhihu.com/p/126507013">。WebService是一种跨编程语言和跨操作系统平台的远程调用技术</a><a href="https://zhuanlan.zhihu.com/p/126507013">1</a><a href="https://zhuanlan.zhihu.com/p/126507013">。WebService三要素是SOAP、WSDL、UDDI</a>。<br /><a href="https://zhuanlan.zhihu.com/p/126507013">SOAP是WebService通过HTTP协议发送请求和接收结果时，发送的请求内容和结果内容都采用XML格式封装，并增加了一些特定的HTTP消息头，以说明HTTP消息的内容格式，这些特定的HTTP消息头和XML内容格式就是SOAP协议</a><a href="https://zhuanlan.zhihu.com/p/126507013">。SOAP提供了标准的RPC (远程调用技术)方法来调用Web Service</a>。<br /><a href="https://zhuanlan.zhihu.com/p/126507013">WSDL是WebService客户端要调用一个WebService服务，首先要有知道这个服务的地址在哪，以及这个服务里有什么方法可以调用，所以，WebService务器端首先要通过一个WSDL文件来说明自己家里有啥服务可以对外调用，服务是什么（服务中有哪些方法，方法接受的参数是什么，返回值是什么），服务的网络地址用哪个url地址表示，服务通过什么方式来调用。WSDL ( Web Services Description Language)就是这样一个基于XML的语言，用于描述Web Service及其函数、参数和返回值</a>。<br /><a href="https://zhuanlan.zhihu.com/p/126507013">UDDI是一个跨产业、跨平台的开放性架构，可以帮助 Web 服务提供商在互联网上发布 Web 服务的信息。UDDI 是一种目录服务，企业可以通过 UDDI 来注册和搜索 Web 服务。简单来说，UDDI 就是一个目录，只不过在这个目录中存放的是一些关于 Web 服务的信息而已</a>。</p><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;p&gt;&lt;a name=&quot;WECuS&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、-实验内容&quot;&gt;一、 实验内容&lt;/h2&gt;
&lt;p&gt;任务1：Web Service服务器端程序开发&lt;br /&gt;		开发个</summary>
      
    
    
    
    <category term="软件体系结构" scheme="http://www.bojiboqi.fun/categories/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="软件体系结构" scheme="http://www.bojiboqi.fun/tags/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    <category term="学校课程" scheme="http://www.bojiboqi.fun/tags/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>软件体系结构实验三：</title>
    <link href="http://www.bojiboqi.fun/2024/02/28/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A/"/>
    <id>http://www.bojiboqi.fun/2024/02/28/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A/</id>
    <published>2024-02-28T13:02:28.547Z</published>
    <updated>2024-02-28T13:08:00.053Z</updated>
    
    <content type="html"><![CDATA[<p><a name="jcQk2"></a></p><h2 id="一、-实验内容">一、 实验内容</h2><p>个人通讯录系统的设计目标是能够轻松地管理个人的联系人信息，包括添加、修改和删除操作。联系人信息包括姓名、住址、电话。整个系统的功能图如下图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698393517486-f9c653d0-3e66-4310-b2b0-1db18abb2e74.png#averageHue=%23f1f1f1&amp;clientId=u537b546b-41d6-4&amp;from=paste&amp;height=229&amp;id=u7cf32b4e&amp;originHeight=286&amp;originWidth=469&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=20685&amp;status=done&amp;style=none&amp;taskId=u25459ff4-e299-49d1-9bc7-f913de031eb&amp;title=&amp;width=375.2" alt="image.png"><br />任务1：采用二层C/S结构实现“个人通讯录系统”；<br />任务2：采用三层C/S结构实现“个人通讯录系统”；<br />任务3：采用B/S结构实现“个人通讯录系统”。<br><a name="VDLp6"></a></p><h2 id="二：实验结果：">二：实验结果：</h2><p><a name="J9m5x"></a></p><h3 id="实验源代码：">实验源代码：</h3><p><a href="https://github.com/Redbiga/SA3.git">https://github.com/Redbiga/SA3.git</a><br />开发环境是：JDK:1.8，tomcat:9.0.65<br><a name="IjbgP"></a></p><h3 id="数据库结构：">数据库结构：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698395792024-cc50c10e-0515-4055-bbbf-e8adf6bc3693.png#averageHue=%232d2f33&amp;clientId=uef4eb324-706d-4&amp;from=paste&amp;height=194&amp;id=uad8b6b4c&amp;originHeight=243&amp;originWidth=1044&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=86604&amp;status=done&amp;style=none&amp;taskId=u2ce16b00-4d93-40ac-9984-3c5f8b2fc8a&amp;title=&amp;width=835.2" alt="image.png"><br><a name="hhhRD"></a></p><h3 id="两层CS体系结构：">两层CS体系结构：</h3><p><a name="Rnab0"></a></p><h4 id="逻辑结构：">逻辑结构：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698394568833-1263846d-20c4-494e-9131-17846d10dd43.png#averageHue=%23ebcba0&amp;clientId=ua3da19bb-144d-4&amp;from=paste&amp;height=79&amp;id=u7bd416f0&amp;originHeight=99&amp;originWidth=681&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=16154&amp;status=done&amp;style=none&amp;taskId=ucbba3221-ee1a-4a15-a7f6-6691a4715ec&amp;title=&amp;width=544.8" alt="image.png"><br><a name="bEoik"></a></p><h4 id="源程序代码结构：">源程序代码结构：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698395687317-b8376a9f-5212-4081-b3a1-3b2de8231884.png#averageHue=%2339455c&amp;clientId=uef4eb324-706d-4&amp;from=paste&amp;height=204&amp;id=u12029e66&amp;originHeight=255&amp;originWidth=869&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=135580&amp;status=done&amp;style=none&amp;taskId=u9f1e979b-c5fc-4c06-98c9-6d4dcbb683d&amp;title=&amp;width=695.2" alt="image.png"><br><a name="QL1Ti"></a></p><h4 id="运行界面截图：">运行界面截图：</h4><p>查询：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698395872221-73d5649f-b1e5-4803-a72d-c12cb6691834.png#averageHue=%23f6f6f6&amp;clientId=uef4eb324-706d-4&amp;from=paste&amp;height=358&amp;id=u23b91da1&amp;originHeight=447&amp;originWidth=1216&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=26954&amp;status=done&amp;style=none&amp;taskId=udfa04e85-a36b-4696-865b-ab911626494&amp;title=&amp;width=972.8" alt="image.png"><br><a name="kHnak"></a></p><h3 id="三层体系结构：">三层体系结构：</h3><p><a name="Md89E"></a></p><h4 id="逻辑结构：-2">逻辑结构：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698396423699-15d9f800-804b-4fdf-8042-4724c8d7f64b.png#averageHue=%23ead5b1&amp;clientId=uef4eb324-706d-4&amp;from=paste&amp;height=114&amp;id=u0327e6df&amp;originHeight=143&amp;originWidth=822&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=23537&amp;status=done&amp;style=none&amp;taskId=u4f58f4b4-f848-4052-96e2-6fc8323ec91&amp;title=&amp;width=657.6" alt="image.png"><br><a name="n1IHp"></a></p><h4 id="源程序代码结构：-2">源程序代码结构：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698396611575-ad53412e-fa9a-4ecc-9723-a3dc400bf9f3.png#averageHue=%233a4865&amp;clientId=uef4eb324-706d-4&amp;from=paste&amp;height=130&amp;id=u1e77be3c&amp;originHeight=162&amp;originWidth=759&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=71431&amp;status=done&amp;style=none&amp;taskId=u6b0a5785-41ba-4b68-ab68-72c278b9a4e&amp;title=&amp;width=607.2" alt="image.png"><br><a name="g14nQ"></a></p><h4 id="运行界面截图：运行结果同两层体系结构，只不过业务逻辑层放在服务层处理了。">运行界面截图：运行结果同两层体系结构，只不过业务逻辑层放在服务层处理了。</h4><p><a name="Vngfz"></a></p><h3 id="BS结构：">BS结构：</h3><p><a name="JWnrg"></a></p><h4 id="逻辑架构：">逻辑架构：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698396961933-0f10f519-0bb2-460e-b39e-6350a2366c34.png#averageHue=%23f8f8f7&amp;clientId=uef4eb324-706d-4&amp;from=paste&amp;height=315&amp;id=uaf2c5d5b&amp;originHeight=394&amp;originWidth=896&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=77311&amp;status=done&amp;style=none&amp;taskId=u2ad79267-6702-4de2-b4ca-07e5b5c48eb&amp;title=&amp;width=716.8" alt="image.png"><br><a name="i7owF"></a></p><h4 id="源代码程序结构：">源代码程序结构：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698397073870-0b79da1a-d207-4e59-ac44-d3b3c43105fb.png#averageHue=%233a3f46&amp;clientId=uef4eb324-706d-4&amp;from=paste&amp;height=326&amp;id=u65b19eae&amp;originHeight=407&amp;originWidth=1046&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=196033&amp;status=done&amp;style=none&amp;taskId=u6c63aab0-a3e6-4d9d-ac4c-eed0ccf38b6&amp;title=&amp;width=836.8" alt="image.png"><br><a name="T12vU"></a></p><h3 id="方案比较：">方案比较：</h3><p>三层C/S结构相对于二层C/S结构更加灵活，可以更好地实现应用功能的独立性，提高系统和软件的可维护性和可扩展性； 二层C/S结构相对于三层C/S结构来说，缺点在于其数据处理能力较弱；B/S架构相对于C/S架构来说，具有以下优点：①跨平台性好；②客户端零维护；③易于维护4. B/S架构相对于C/S架构来说，缺点在于其个性化能力低，响应速度较慢。<br><a name="x3Iw7"></a></p><h3 id="总结：">总结：</h3><p>C/S结构是一种常见的软件体系结构，它将整个系统分为客户端和服务器端。二层C/S结构是指只有一个服务器，且以局域网为中心的结构。三层C/S结构是指分为两类服务器（数据库服务器和应用服务器）和用户的结构。三层C/S结构相对于二层C/S结构更加灵活，可以更好地实现应用功能的独立性，提高系统和软件的可维护性和可扩展性； 三层C/S结构的优点包括：①允许合理地划分三层结构的功能，使之在逻辑上保持相对独立性，能提高系统和软件的可维护性和可扩展性；②允许更灵活有效地选用相应的平台和硬件系统，使之在处理负荷能力上与处理特性上分别适应于结构清晰的三层；③应用的各层可以并行开发，可以选择各自最适合的开发语言；④利用功能层有效地隔离开表示层与数据层，未授权的用户难以绕过功能层而利用数据库工具或黑客手段去非法地访问数据层1. 二层C/S结构相对于三层C/S结构来说，缺点在于其数据处理能力较弱，安全性难以控制。<br />B/S架构是指浏览器-服务器架构。B/S架构相对于C/S架构来说，具有以下优点：①跨平台性好；②客户端零维护；③易于维护4. B/S架构相对于C/S架构来说，缺点在于其个性化能力低，响应速度较慢。<br />总体而言，二层C/S架构、三层C/S架构、B/S架构各有优缺点。选择何种架构需要根据实际情况进行权衡。</p><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;jcQk2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、-实验内容&quot;&gt;一、 实验内容&lt;/h2&gt;
&lt;p&gt;个人通讯录系统的设计目标是能够轻松地管理个人的联系人信息，包括添加、修改和删除操作。联系人信息包括姓名、住址、电话。整个系统的功能图如下图所示：&lt;br /&gt;&lt;</summary>
      
    
    
    
    <category term="软件体系结构" scheme="http://www.bojiboqi.fun/categories/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="软件体系结构" scheme="http://www.bojiboqi.fun/tags/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    <category term="学校课程" scheme="http://www.bojiboqi.fun/tags/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>软件体系结构实验二：</title>
    <link href="http://www.bojiboqi.fun/2024/02/28/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A/"/>
    <id>http://www.bojiboqi.fun/2024/02/28/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A/</id>
    <published>2024-02-28T13:02:28.543Z</published>
    <updated>2024-02-28T13:08:12.196Z</updated>
    
    <content type="html"><![CDATA[<p><a name="t8pNN"></a></p><h1>一：实验内容：</h1><p>任务1：仔细阅读文献<a href="https://blog.csdn.net/weixin_43853097/article/details/110943379?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-110943379-blog-82871259.t5_download_50w&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-110943379-blog-82871259.t5_download_50w&amp;utm_relevant_index=1">“主程序-子程序、面向对象、事件系统和管道-过滤软件体系结构实现KWIC”</a><br />任务2：实现文献中的所有程序并调试通过。<br />任务3：参考和整合以上参考文献，开发“经典软件体系结构教学软件”，用于向用户展示主程序-子程序、面向对象、事件系统和管道-过滤器等软件体系结构风格的基本原理。软件功能及界面可自由设计，但应包括如下内容：<br />（1） 用户可选择四种方法之一对指定的输入文件进行处理，结果可显示在界面上；<br />（2） 能够分别显示各种“体系结构风格”的原理图或文字说明、源程序代码结构、关键函数的程序代码等；<br><a name="nAChu"></a></p><h1>二.软件开发：</h1><p><a name="s5y0m"></a></p><h2 id="环境：">环境：</h2><p>1.JDK8，maven，IDEA<br />2.springboot+thymeleaf<br />3.源代码地址：<a href="https://gitee.com/fanshanshui/architecture-experiment.git">晓晨/ Sa-experiment2</a><br><a name="SfWoV"></a></p><h2 id="源代码结构：">源代码结构：</h2><p>总体上采用MVC的结构开发<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698234665556-84cbfcec-e244-4337-b7d3-d017dbb8fa5f.png#averageHue=%23536268&amp;clientId=u877b6732-74b4-4&amp;from=paste&amp;height=429&amp;id=ubb371b37&amp;originHeight=536&amp;originWidth=747&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=197557&amp;status=done&amp;style=none&amp;taskId=uc0ca482f-3a9a-47e8-874f-9c3704d4417&amp;title=&amp;width=597.6" alt="image.png"><br><a name="sSocg"></a></p><h2 id="运行截图：">运行截图：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698234725788-c45e761c-74fb-40b3-a776-58a10a9a960d.png#averageHue=%23f8f7f6&amp;clientId=u877b6732-74b4-4&amp;from=paste&amp;height=460&amp;id=u03d42cbc&amp;originHeight=575&amp;originWidth=895&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=66407&amp;status=done&amp;style=none&amp;taskId=uec95920a-a594-417c-81a8-de7371b3142&amp;title=&amp;width=716" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698234765228-25385136-a354-4f30-8362-bf9803d163b6.png#averageHue=%23f9f9f9&amp;clientId=u877b6732-74b4-4&amp;from=paste&amp;height=691&amp;id=u7455a5cd&amp;originHeight=864&amp;originWidth=1062&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=137092&amp;status=done&amp;style=none&amp;taskId=u8b241396-23af-4f0e-81d8-d9a2bb84831&amp;title=&amp;width=849.6" alt="image.png"><br />查看代码功能：<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698234879261-3c23de92-5852-4e21-8ab7-99759e33561f.png#averageHue=%23f9f8f6&amp;clientId=u877b6732-74b4-4&amp;from=paste&amp;height=567&amp;id=u35382cfd&amp;originHeight=709&amp;originWidth=834&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=57216&amp;status=done&amp;style=none&amp;taskId=ucf1ce82a-1ba7-4e1c-a51f-b64c8759f79&amp;title=&amp;width=667.2" alt="image.png"><br />测试其他体系结构：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698234930262-3ee8b732-4f15-4ad9-bd02-66942c85530a.png#averageHue=%23f8f7f7&amp;clientId=u877b6732-74b4-4&amp;from=paste&amp;height=680&amp;id=u796df42e&amp;originHeight=850&amp;originWidth=995&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=123152&amp;status=done&amp;style=none&amp;taskId=ub30051ab-dee9-4c81-9c51-fcf8ba3e6bf&amp;title=&amp;width=796" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698234937075-62502cb5-5cb3-40ba-8f95-922195995ade.png#averageHue=%23f8f8f8&amp;clientId=u877b6732-74b4-4&amp;from=paste&amp;height=690&amp;id=u991882cc&amp;originHeight=862&amp;originWidth=986&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=124221&amp;status=done&amp;style=none&amp;taskId=u96a57ed2-bacd-4dbc-ba27-504b792f2c7&amp;title=&amp;width=788.8" alt="image.png"><br><a name="fTx76"></a></p><h1>遇到的问题：</h1><p>1.IDEA文件相对路径写对了但是却找不到的问题：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698235681601-a66b317a-554e-4f0f-a750-7551025d20c3.png#averageHue=%2335445c&amp;clientId=u877b6732-74b4-4&amp;from=paste&amp;height=458&amp;id=ue394ae0a&amp;originHeight=573&amp;originWidth=1656&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=400404&amp;status=done&amp;style=none&amp;taskId=ub7150a54-bd54-45df-8eeb-f161a7a2059&amp;title=&amp;width=1324.8" alt="image.png"><br />原因是：…/表示上级目录是Linucx下的表示方法<br />解决方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">root</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);<span class="comment">//获取当前程序运行的目录，</span></span><br><span class="line"><span class="comment">// 它通常是启动 Java 程序的命令行或应用程序所在的目录。</span></span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(root+File.separator+<span class="string">&quot;test.txt&quot;</span>);<span class="comment">//File.separator</span></span><br><span class="line"><span class="comment">//是产生文件分割符号，Linucx和window的文件分割符是不一样的。</span></span><br></pre></td></tr></table></figure><p>2.添加了devtools依赖并不能实现真正意义上的修改代码不用重新加载就可以看到变化，还需要设置IDEA自动编译<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698236724532-84392022-ec93-4264-8026-d0e9b9a0011b.png#averageHue=%23303337&amp;clientId=u877b6732-74b4-4&amp;from=paste&amp;height=613&amp;id=uc3c35123&amp;originHeight=766&amp;originWidth=716&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=67616&amp;status=done&amp;style=none&amp;taskId=ud5c01a0c-9053-4345-9514-c3b4be91c29&amp;title=&amp;width=572.8" alt="image.png"><br><a name="KIkgM"></a></p><h1>总结：</h1><p>主程序-子程序风格是一种结构化的软件体系结构，它从功能的角度设计系统，通过逐步分解和细化，形成整个系统的体系结构。主程序是系统的入口和控制中心，它调用各种子程序来完成具体的任务。子程序是一些独立的功能模块，它们可以被主程序或其他子程序重复调用。主程序-子程序风格的特点有：<br />•  简单：它遵循自顶向下、逐步求精的设计原则，易于理解和实现。<br />•  模块化：它将系统划分为若干相对独立的模块，提高了代码的重用性和可维护性。<br />•  局限性：它不能很好地处理数据和行为的耦合问题，也不适合处理并发和分布式的情况。<br />面向对象风格是一种封装的软件体系结构，它从数据的角度设计系统，通过抽象和多态，形成整个系统的体系结构。对象是系统的基本单位，它包含了数据和作用在数据上的操作。对象之间通过接口进行消息传递和协作。面向对象风格的特点有：<br />•  灵活：它可以通过继承和组合来实现代码的复用和扩展，也可以通过多态来实现动态绑定和行为变化。<br />•  隐蔽性：它可以通过封装来隐藏对象的内部细节，只暴露必要的接口给外界，提高了系统的安全性和稳定性。<br />•  复杂性：它需要考虑对象之间的关系和协作，以及对象生命周期和状态管理等问题，增加了系统的设计难度和开发成本。<br /> 事件系统风格是一种异步的软件体系结构，它从交互的角度设计系统，通过事件驱动和回调函数，形成整个系统的体系结构。事件是系统中发生的各种情况或变化，它们可以由用户、设备或其他源产生。事件处理器是响应事件并执行相应操作的模块，它们可以注册到事件源或事件分发器上。事件系统风格的特点有：<br />•  响应性：它可以实现非阻塞式的通信和处理，提高了系统的并发性能和用户体验。<br />•  解耦性：它可以将事件源和事件处理器分离开来，降低了系统各部分之间的依赖性。<br />•  不确定性：它需要处理事件之间的时序、优先级、冲突等问题，也需要考虑事件丢失、重复、延迟等问题，增加了系统的复杂性和不可预测性。<br /> 管道-过滤器风格是一种流式的软件体系结构，它从数据流的角度设计系统，通过连续处理和数据转换，形成整个系统的体系结构。过滤器是对输入数据流进行某种变换或增量计算，并产生输出数据流的模块。管道是将一个过滤器的输出传递到另一个过滤器输入的连接件。管道-过滤器风格的特点有：<br />•  可重用性：它可以将系统任务分解为若干个过滤器，每个过滤器都是一个独立的实体，可以在不同的系统中重用。<br />•  可组合性：它可以将不同的过滤器通过管道连接起来，形成不同的功能和行为。<br />•  可并行性：它可以将每个过滤器作为一个单独的任务执行，实现系统的并行处理和分布式计算。<br />•  局限性：它要求过滤器之间的数据格式和传输方式相匹配，也要求过滤器之间没有共享数据和状态信息，否则会影响系统的正确性和效率。</p><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;t8pNN&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;一：实验内容：&lt;/h1&gt;
&lt;p&gt;任务1：仔细阅读文献&lt;a href=&quot;https://blog.csdn.net/weixin_43853097/article/details/110943379?spm=1001.</summary>
      
    
    
    
    <category term="软件体系结构" scheme="http://www.bojiboqi.fun/categories/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="软件体系结构" scheme="http://www.bojiboqi.fun/tags/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    <category term="学校课程" scheme="http://www.bojiboqi.fun/tags/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>软件体系结构学习总结</title>
    <link href="http://www.bojiboqi.fun/2024/02/28/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9A/"/>
    <id>http://www.bojiboqi.fun/2024/02/28/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9A/</id>
    <published>2024-02-28T13:02:28.539Z</published>
    <updated>2024-02-28T10:44:05.255Z</updated>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id=""></h2><p><a href="https://www.bilibili.com/video/BV1GE411G7hu/?spm_id_from=333.337.search-card.all.click&amp;vd_source=add54d0fcd49c96c6c124259f9775bc3">软件体系结构-6.REST架构_哔哩哔哩_bilibili</a></p><h2 id="基础信息：">基础信息：</h2><h4 id="1-设计模式和软件体系结构的区别：">1.设计模式和软件体系结构的区别：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697952543929-85e364d1-96c1-4e53-aadc-d168d1cb529d.png#averageHue=%23d1cfcd&amp;clientId=u436bf433-d833-4&amp;from=paste&amp;height=434&amp;id=ub6b3d71c&amp;originHeight=543&amp;originWidth=901&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=112953&amp;status=done&amp;style=none&amp;taskId=ub3648dd4-9e7a-41b3-8290-23089514668&amp;title=&amp;width=720.8" alt="image.png"></p><h4 id="2-mvn-spring-boot-run可以让spring项目跑起来">2. mvn spring-boot:run可以让spring项目跑起来</h4><h4 id="3-CBD：基于构建构件的软件开发">3.CBD：基于构建构件的软件开发</h4><h4 id="构建开发例子：">构建开发例子：</h4><p>springboot项目导入了模板引擎依赖和springsecurity依赖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">Controller</span><span class="comment">//注意这里是contreller注解，而不是@RestController；后者是基于RESFUL风格的请求;</span></span><br><span class="line"><span class="comment">//后者返回的是一个单纯的字符串，而前者返回的是一个视图的名称</span></span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">SimpleController</span> &#123;</span><br><span class="line">  <span class="comment">// $&#123;&#125;获取配置文件中的信息</span></span><br><span class="line">    @<span class="title class_">Value</span>(<span class="string">&quot;$&#123;spring.application.name&#125;&quot;</span>)</span><br><span class="line">    <span class="title class_">String</span> springApplicationName;</span><br><span class="line">    @<span class="title class_">GetMapping</span>(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">  <span class="comment">// Modle返回的视图模型</span></span><br><span class="line">    public <span class="title class_">String</span> <span class="title function_">homePage</span>(<span class="params">Model model</span>)&#123;</span><br><span class="line">      <span class="comment">// 下面的方法给视图新增了一个appName属性。该属性可以在模板引擎中用</span></span><br><span class="line">        model.<span class="title function_">addAttribute</span>(<span class="string">&quot;appName&quot;</span>,springApplicationName);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--模板引擎，这里不用添加命令空间，因为导入了模板引擎依赖  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Home Page<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Welcome to <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;appName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.<span class="property">application</span>.<span class="property">name</span> = <span class="title class_">My</span> <span class="title class_">First</span> <span class="title class_">Web</span> <span class="title class_">App</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697958874431-5f65d8e9-d9fa-4f39-897c-c98ebc81d206.png#averageHue=%23d4ae3a&amp;clientId=u49304794-0dc7-4&amp;from=paste&amp;height=368&amp;id=u03174004&amp;originHeight=460&amp;originWidth=831&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=87486&amp;status=done&amp;style=none&amp;taskId=u81e05ce7-5b63-4b42-8245-9cb89ec10a1&amp;title=&amp;width=664.8" alt="image.png"></p><h4 id="反转控制和依赖注入：">反转控制和依赖注入：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697959176912-7c3ecccb-59b0-44bb-9876-b2a271fed6c4.png#averageHue=%23a4c642&amp;clientId=u49304794-0dc7-4&amp;from=paste&amp;height=441&amp;id=u1f00475d&amp;originHeight=551&amp;originWidth=1004&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=218078&amp;status=done&amp;style=none&amp;taskId=u34bb1a40-bd43-4360-a397-3e1561bc2e3&amp;title=&amp;width=803.2" alt="image.png"><br>控制反转IOC：<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697959249397-b0d3843c-ac38-4ad6-ae3a-9e8eac17fe2c.png#averageHue=%23d7d7d7&amp;clientId=u49304794-0dc7-4&amp;from=paste&amp;height=36&amp;id=u242c06f0&amp;originHeight=45&amp;originWidth=830&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=32476&amp;status=done&amp;style=none&amp;taskId=u61f1eea8-2cc2-42f2-8686-1187999bf31&amp;title=&amp;width=664" alt="image.png"><br>上面提供服务的是Controller组件，请求者是Web Server.<br>控制反转的概念：<br>（一个组件并不创造它所依赖的组件，而是由其他控件去创建。）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697962355523-f43aabca-6ce7-45ff-8e79-21852c347fbd.png#averageHue=%23faf8f8&amp;clientId=u49304794-0dc7-4&amp;from=paste&amp;height=113&amp;id=u1a37f638&amp;originHeight=141&amp;originWidth=923&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=52692&amp;status=done&amp;style=none&amp;taskId=u0fffc078-f22f-4039-9100-4ff37fa97c0&amp;title=&amp;width=738.4" alt="image.png"><br>特别符合依赖倒置原则也就是构建不依赖具体的实现类，而是依赖于一个接口。<br>（反转控件就是由一个容器独立的定义一组构建以及他们之间的依赖关系，用这种方式实现把构建在运行时组合在一起，在构建生命周期的特殊时间段调用它）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697962509900-505d7c86-5448-4683-879c-3a3f7994e575.png#averageHue=%23f8f8f8&amp;clientId=u49304794-0dc7-4&amp;from=paste&amp;height=202&amp;id=ue0a6ecf9&amp;originHeight=252&amp;originWidth=927&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=106721&amp;status=done&amp;style=none&amp;taskId=u47c93f95-c9d8-4cd6-babc-327a36d6a94&amp;title=&amp;width=741.6" alt="image.png"><br>实现反转控制可以通过依赖注入或者Service Locator来实现。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697964675412-9233193c-a8d0-41c2-ba41-6100f29b08ee.png#averageHue=%23fbfbfb&amp;clientId=u49304794-0dc7-4&amp;from=paste&amp;height=438&amp;id=ub4c0e8d5&amp;originHeight=547&amp;originWidth=841&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=125340&amp;status=done&amp;style=none&amp;taskId=u802f681a-8638-4006-8555-529c4778ce4&amp;title=&amp;width=672.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697964722352-c8065877-eed8-4419-bc48-71774720551b.png#averageHue=%23fbfbfb&amp;clientId=u49304794-0dc7-4&amp;from=paste&amp;height=350&amp;id=u6ca29748&amp;originHeight=438&amp;originWidth=959&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=124357&amp;status=done&amp;style=none&amp;taskId=u60bafe33-4ee8-4dfc-99ef-ed550a28531&amp;title=&amp;width=767.2" alt="image.png"><br>总结：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1697967593331-4ee01bf7-25b8-4c5d-95b8-3b0658cc4bdb.jpeg" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697967875519-07dcfc7a-9b5b-4223-816a-ecd5dce11a9b.png#averageHue=%2326262a&amp;clientId=u49304794-0dc7-4&amp;from=paste&amp;height=230&amp;id=u09c07e8e&amp;originHeight=288&amp;originWidth=953&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=167460&amp;status=done&amp;style=none&amp;taskId=u3515a796-eb0b-45e1-ba75-3b164b9e834&amp;title=&amp;width=762.4" alt="image.png"></p><h4 id="注解的理解：">注解的理解：</h4><p><a href="https://blog.csdn.net/KingBoyWorld/article/details/105337011">Java注解入门到精通，这一篇就够了_java注解精通联系-CSDN博客</a><br><a href="https://blog.csdn.net/ajianyingxiaoqinghan/article/details/81436118">Java 注解 —— 注解的理解、注解的使用与自定义注解_java注解-CSDN博客</a></p><h4 id="总结：">总结：</h4><p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html">Redirecting…</a><br><a href="https://www.jikexueyuan.com/">极客企业版</a></p><h2 id="分层架构：">分层架构：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697973508115-cb275da9-03a8-4178-bcb1-32a2920c9cc6.png#averageHue=%23fdfefc&amp;clientId=u49304794-0dc7-4&amp;from=paste&amp;height=421&amp;id=u2d27c062&amp;originHeight=526&amp;originWidth=781&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=207763&amp;status=done&amp;style=none&amp;taskId=ued4347ea-06c2-4e1a-99b2-7926e9652e9&amp;title=&amp;width=624.8" alt="image.png"><br>三层体系结构：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697973933531-4ea84acd-132b-4e2b-bdb6-1442e1620c33.png#averageHue=%23fbf7f0&amp;clientId=u49304794-0dc7-4&amp;from=paste&amp;height=444&amp;id=u81034b75&amp;originHeight=555&amp;originWidth=973&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=221766&amp;status=done&amp;style=none&amp;taskId=ue52c2db9-cb3d-4219-8d26-c34eba9d4f6&amp;title=&amp;width=778.4" alt="image.png"></p><h2 id="客户机服务器模式：">客户机服务器模式：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697974158750-b0b7ea35-5b3a-4a34-a775-cd9ab1e3c1bd.png#averageHue=%23fdfdfd&amp;clientId=u49304794-0dc7-4&amp;from=paste&amp;height=390&amp;id=uac2b1a47&amp;originHeight=487&amp;originWidth=909&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=82654&amp;status=done&amp;style=none&amp;taskId=ua5f862fe-ae1c-4c1d-a30b-5219e810e2f&amp;title=&amp;width=727.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697974366196-726befe9-168b-4995-a569-3c21363ad1f4.png#averageHue=%23fcfcfc&amp;clientId=u49304794-0dc7-4&amp;from=paste&amp;height=329&amp;id=u0dbea32e&amp;originHeight=411&amp;originWidth=863&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=51671&amp;status=done&amp;style=none&amp;taskId=ua724f0f5-fa25-4347-942e-a5324120138&amp;title=&amp;width=690.4" alt="image.png"><br>Fat Client:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697974452946-db7295a0-8deb-4c5f-a77f-2ab7fcb4fa07.png#averageHue=%23fcfcfc&amp;clientId=u49304794-0dc7-4&amp;from=paste&amp;height=351&amp;id=u35073d37&amp;originHeight=439&amp;originWidth=1007&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=108230&amp;status=done&amp;style=none&amp;taskId=u670a087e-f30b-4bb7-a229-aafc8663a1b&amp;title=&amp;width=805.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697974542905-fef86043-1239-4e5f-9721-9405370b20ad.png#averageHue=%23fcfcfc&amp;clientId=u49304794-0dc7-4&amp;from=paste&amp;height=420&amp;id=u9c8f4a52&amp;originHeight=525&amp;originWidth=972&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=135046&amp;status=done&amp;style=none&amp;taskId=u1328a997-45b4-4022-96c5-b56143a5123&amp;title=&amp;width=777.6" alt="image.png"></p><h3 id="基于servlet的BS架构：">基于servlet的BS架构：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697975183209-7e6a41ed-9c7e-4b67-bb6b-023db6784fc5.png#averageHue=%23eff0f0&amp;clientId=u49304794-0dc7-4&amp;from=paste&amp;height=408&amp;id=ub0d5a1e5&amp;originHeight=510&amp;originWidth=686&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=103076&amp;status=done&amp;style=none&amp;taskId=u3028007d-93d5-471c-83d1-067d9e45a66&amp;title=&amp;width=548.8" alt="image.png"><br><a href="https://luoyong.blog.csdn.net/article/details/130204152?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-130204152-blog-117879799.235%5Ev38%5Epc_relevant_default_base&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-130204152-blog-117879799.235%5Ev38%5Epc_relevant_default_base&amp;utm_relevant_index=10">Spring Boot进阶(85)：配置Jetty容器|超级详细，建议收藏_springboot jetty-CSDN博客</a><br>spring-boot更好jetty服务器后用:mvn jetty:run启动项目</p><h2 id="模型-视图-控制器：">模型-视图-控制器：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697980670345-d96f8921-b7ce-4b44-95b5-2c29114df75b.png#averageHue=%23fafafa&amp;clientId=u734475b1-ed84-4&amp;from=paste&amp;height=457&amp;id=u79f55de2&amp;originHeight=571&amp;originWidth=1035&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=141435&amp;status=done&amp;style=none&amp;taskId=u3208e6e3-add9-4387-b860-26b785f0a18&amp;title=&amp;width=828" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697980856511-b50514ae-9ec9-4e3a-9285-cb302966d3dc.png#averageHue=%23fcfcfc&amp;clientId=u734475b1-ed84-4&amp;from=paste&amp;height=429&amp;id=u04355d5c&amp;originHeight=536&amp;originWidth=1002&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=157239&amp;status=done&amp;style=none&amp;taskId=uc1bfdfeb-3284-402b-bd46-480a7d8a741&amp;title=&amp;width=801.6" alt="image.png"></p><h4 id="MVC的概念：">MVC的概念：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697981940499-78ee883c-8ec2-4b2b-97bd-007675fec64b.png#averageHue=%23538726&amp;clientId=u734475b1-ed84-4&amp;from=paste&amp;height=431&amp;id=ud7b1c8eb&amp;originHeight=539&amp;originWidth=1183&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=547298&amp;status=done&amp;style=none&amp;taskId=ub12a801e-6314-4c03-9f15-fb22bc1cc8d&amp;title=&amp;width=946.4" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697981983781-177588ca-d219-4d9a-9e6e-6c50dc5a602d.png#averageHue=%23748b48&amp;clientId=u734475b1-ed84-4&amp;from=paste&amp;height=690&amp;id=u32e6154b&amp;originHeight=862&amp;originWidth=1660&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=584160&amp;status=done&amp;style=none&amp;taskId=u49393f6b-4afc-4b6a-8fff-74755213873&amp;title=&amp;width=1328" alt="image.png"><br>上面的UI可以是模板引擎。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697982612706-9566502b-b48f-49db-ba12-9a5a36403132.png#averageHue=%23558929&amp;clientId=u734475b1-ed84-4&amp;from=paste&amp;height=586&amp;id=u050527c4&amp;originHeight=733&amp;originWidth=1380&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=596424&amp;status=done&amp;style=none&amp;taskId=ua45351e1-9d2c-4761-876c-62daade6ff6&amp;title=&amp;width=1104" alt="image.png"><br>接受用户请求之后，业务不用在serve当中实现了，而是交给另外一个组件来实现这个组件就是Modle,Modle实现相关业务逻辑。Model可能是一个算法模型，或者是和数据库交互进行存储持久化操作等等。Modle执行业务逻辑得到的结果交还给Controller，Controller再交给UI进行渲染作为Respanse返回给用户。把原理单独的servlet拆分为3部分了，Modle,View,Controller.<br>Controller接收用户请求并解释用户请求交给Model来执行业务逻辑，得到的结果返回给控制器然后返回交给视图View，View将渲染后的结果当中响应返回给Client.<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697983201831-484f057c-d250-4e9e-8d00-c6454cf63fa4.png#averageHue=%23f7f7f7&amp;clientId=u734475b1-ed84-4&amp;from=paste&amp;height=631&amp;id=u7e4b5878&amp;originHeight=789&amp;originWidth=1622&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=303571&amp;status=done&amp;style=none&amp;taskId=u9d8909fc-32a0-45c6-8843-fc4968e2987&amp;title=&amp;width=1297.6" alt="image.png"><br>例子：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697983343193-7ec9e50f-98d6-4886-b4b9-b57035c2c3dd.png#averageHue=%23fcfcfb&amp;clientId=u734475b1-ed84-4&amp;from=paste&amp;height=523&amp;id=ue8a4c8c6&amp;originHeight=654&amp;originWidth=1415&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=220986&amp;status=done&amp;style=none&amp;taskId=u43ecdbe4-fe1d-4ec0-8609-fb2f3702cd9&amp;title=&amp;width=1132" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697983602965-c1f208d8-db72-449f-be08-62c1b7fdf27b.png#averageHue=%237da57d&amp;clientId=u734475b1-ed84-4&amp;from=paste&amp;height=627&amp;id=u84082edb&amp;originHeight=784&amp;originWidth=1570&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=601592&amp;status=done&amp;style=none&amp;taskId=u25f3a8b0-f183-4e80-9fa6-8a1befc4eff&amp;title=&amp;width=1256" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697983605805-4fb74fb5-2445-4c7e-abe0-9c2a6c369bbb.png#averageHue=%23d1beb5&amp;clientId=u734475b1-ed84-4&amp;from=paste&amp;height=570&amp;id=u2fb12b65&amp;originHeight=712&amp;originWidth=1028&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=333821&amp;status=done&amp;style=none&amp;taskId=u09d4329e-8705-4a0d-944e-ddc2cf90048&amp;title=&amp;width=822.4" alt="image.png"></p><h4 id="springmvc">springmvc:</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697983634413-63b5dc74-a2fb-4804-872e-41d341db6bc4.png#averageHue=%23b8b7b6&amp;clientId=u734475b1-ed84-4&amp;from=paste&amp;height=666&amp;id=u2d4450ef&amp;originHeight=832&amp;originWidth=929&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=241546&amp;status=done&amp;style=none&amp;taskId=u3b82dfbb-1ee7-4dc3-a670-952604976e5&amp;title=&amp;width=743.2" alt="image.png"><br>Dispatcher:调度，分配。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697983778149-4e727f97-46e4-4caa-8f24-80e10009ad0a.png#averageHue=%23d6b141&amp;clientId=u734475b1-ed84-4&amp;from=paste&amp;height=601&amp;id=u9c72f8cb&amp;originHeight=751&amp;originWidth=1287&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=237892&amp;status=done&amp;style=none&amp;taskId=u31972873-b6ba-47c0-8676-a2347803559&amp;title=&amp;width=1029.6" alt="image.png"><br>这里的Controller并不是把MVC中的M和C结合到一起了。Controller会调用相关Model中的方法。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697985852986-0cbd7b5f-f042-4da0-90df-de709286b8ea.png#averageHue=%23fcfbf5&amp;clientId=u734475b1-ed84-4&amp;from=paste&amp;height=94&amp;id=ub28a5c58&amp;originHeight=118&amp;originWidth=667&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=56394&amp;status=done&amp;style=none&amp;taskId=u3d176cd4-db9c-43a7-bf9b-e4360f8149f&amp;title=&amp;width=533.6" alt="image.png"></p><h4 id="测试Controller：-WebMvcTest">测试Controller：@WebMvcTest();</h4><p>测试类上添加@WebMvcTest注解，该注解的属性值就是要测试的类，如果该要测试的类需要注入Modle的时候，也技术依赖Modle类，测试中；在测试类中要注入@Autowired  MockMvc组件模拟发送请求并断言。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1697987314551-24ce1813-9e6f-49c6-84ed-4405b8d8cc68.png#averageHue=%23fdfcfc&amp;clientId=u734475b1-ed84-4&amp;from=paste&amp;height=353&amp;id=ub8dd2186&amp;originHeight=441&amp;originWidth=875&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=167030&amp;status=done&amp;style=none&amp;taskId=uc25d757c-d39f-402f-af03-35c6b41deeb&amp;title=&amp;width=700" alt="image.png"><br>单纯只添加了这个注解，如果测试的类也就是控制类的时候，如果</p><h2 id="REST：">REST：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698018173231-339b7dad-fb14-4ac6-ba18-5bf0bc0e07c1.png#averageHue=%23f5f5f5&amp;clientId=u7a79556a-f9a9-4&amp;from=paste&amp;height=643&amp;id=ue9bcef9d&amp;originHeight=804&amp;originWidth=1586&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=190959&amp;status=done&amp;style=none&amp;taskId=u0b31f6a5-e1c3-4dca-8a8d-8366cb17f1a&amp;title=&amp;width=1268.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698018182905-4315e3e5-cf40-435d-9614-cd18536bc4fc.png#averageHue=%23fbfbfb&amp;clientId=u7a79556a-f9a9-4&amp;from=paste&amp;height=703&amp;id=ud3b73cb4&amp;originHeight=879&amp;originWidth=1441&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=200517&amp;status=done&amp;style=none&amp;taskId=u322e17ce-b0ac-47fd-a899-4ff580304df&amp;title=&amp;width=1152.8" alt="image.png"></p><h4 id="统一资源接口：">统一资源接口：</h4><p>所有的东西在REST下都称作资源。<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698018318571-c8a69469-e7bb-4925-b2bd-41451795ee07.png#averageHue=%23fafafa&amp;clientId=u7a79556a-f9a9-4&amp;from=paste&amp;height=642&amp;id=uc3b17c5f&amp;originHeight=802&amp;originWidth=1546&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=179046&amp;status=done&amp;style=none&amp;taskId=u09197a86-00d4-4b0d-84fc-e846b77a29c&amp;title=&amp;width=1236.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698018370097-7d09f383-c6d2-4114-8c77-bbbfb5f3137b.png#averageHue=%23f4f4f4&amp;clientId=u7a79556a-f9a9-4&amp;from=paste&amp;height=661&amp;id=u85b8d103&amp;originHeight=826&amp;originWidth=1559&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=285214&amp;status=done&amp;style=none&amp;taskId=u566186af-caf8-481f-9ffa-079d15201cb&amp;title=&amp;width=1247.2" alt="image.png"><br>上面的URL中分号；代表同级关系，/代表层级关系。？后面是查询字符串，代表资源的过滤要满足的条件。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698018426982-e92f0428-7587-4440-83b6-9a28bfca1e94.png#averageHue=%23fafafa&amp;clientId=u7a79556a-f9a9-4&amp;from=paste&amp;height=701&amp;id=u1fd8c291&amp;originHeight=876&amp;originWidth=1285&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=240921&amp;status=done&amp;style=none&amp;taskId=u77b42584-054a-40bb-9703-7fd022bf46a&amp;title=&amp;width=1028" alt="image.png"><br><a href="https://www.runoob.com/w3cnote/http-vs-https.html#SnippetTab">HTTP 与 HTTPS 的区别 | 菜鸟教程</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698018749614-f1ad5f33-d8df-4a20-bb59-f08e278293ed.png#averageHue=%23f3f3f3&amp;clientId=u7a79556a-f9a9-4&amp;from=paste&amp;height=690&amp;id=u551cfc02&amp;originHeight=862&amp;originWidth=1558&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=440719&amp;status=done&amp;style=none&amp;taskId=u5686980b-0e42-4a01-afb8-de9d2b5dfd2&amp;title=&amp;width=1246.4" alt="image.png"><br><strong>HEAD方法</strong>跟GET方法相同，只不过服务器响应时不会返回消息体，只返回资源响应的头部信息。 一个HEAD请求的响应中，HTTP头中包含的元信息应该和一个GET请求的响应消息相同。 这种方法能够用来获取请求中隐含的元信息（元信息是描述数据或信息资源的数据），而不用传输实体自己。 也常常用来测试超连接的有效性、可用性和最近的修改。这里的资源指的是URL定义的一个资源。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698021648064-1edc6bdf-7b70-42f0-ad22-4df6a730056b.png#averageHue=%23fefefe&amp;clientId=u7a79556a-f9a9-4&amp;from=paste&amp;height=375&amp;id=ud2231a34&amp;originHeight=469&amp;originWidth=905&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=166772&amp;status=done&amp;style=none&amp;taskId=u11e811fa-59a9-4a81-87cc-2df8ebf3c7f&amp;title=&amp;width=724" alt="image.png"><br>get请求的安全是不管请求多少次都不会改变服务器的状态的，幂等是多次HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用，幂等性——是系统的接口对外一种承诺（而不是实现），承诺只要调用接口成功，外部多次调用对系统的影响是一致的。<br>一个幂等的操作典型如：把编号为5的记录的A字段设置为0，这种操作不管执行多少次都是幂等的。<br>一个非幂等的操作典型如：把编号为5的记录的A字段增加1，这种操作显然就不是幂等的。这里get幂等的意思是多次get都是获取同一资源，对服务器上的资源没有副作用。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698021917232-26551e4d-dad1-4131-bfb7-5fa28c7c19e3.png#averageHue=%23f0f0f1&amp;clientId=u7a79556a-f9a9-4&amp;from=paste&amp;height=420&amp;id=u17d42d5c&amp;originHeight=525&amp;originWidth=917&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=255984&amp;status=done&amp;style=none&amp;taskId=u2613032b-7f8f-424a-811e-a4d464f0ff7&amp;title=&amp;width=733.6" alt="image.png"><br><a href="https://www.cnblogs.com/gyjjyg/p/9855511.html">理解http的幂等性 - yjge - 博客园</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698022556197-4340d667-960c-4645-8c46-6e8ebbd42ea4.png#averageHue=%23fefefe&amp;clientId=u7a79556a-f9a9-4&amp;from=paste&amp;height=395&amp;id=u5ed7dcfc&amp;originHeight=494&amp;originWidth=918&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=223098&amp;status=done&amp;style=none&amp;taskId=u5595e437-a491-452a-ad65-9cc7f7ece2e&amp;title=&amp;width=734.4" alt="image.png"><br>post url请求中url标识对该请求的处理并创建资源，这样多次post请求可能会生成多个资源实例，其多次请求对服务器产生了不一样的效果：生成了多个url资源；但是put请求中的url就是该表该要修改的资源，多次相同的put请求都是对同一个url产生效果。<br>就跟上面一样：put请求是用客户端的实例号创建资源，后面的相同的put请求就是在相同的url上进行修改。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698022903545-c27559e9-7c54-4d55-b44e-c9b3c0883578.png#averageHue=%23fefefe&amp;clientId=u7a79556a-f9a9-4&amp;from=paste&amp;height=370&amp;id=u99a0e18a&amp;originHeight=462&amp;originWidth=933&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=112371&amp;status=done&amp;style=none&amp;taskId=ucbd76200-a6e2-4186-b940-ffbca521d43&amp;title=&amp;width=746.4" alt="Snipaste_2023-10-23_09-01-35.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698022953990-4a500979-4c0a-46e1-8a16-f3c90fc5e97f.png#averageHue=%23fdfdfd&amp;clientId=u7a79556a-f9a9-4&amp;from=paste&amp;height=345&amp;id=u326862c6&amp;originHeight=431&amp;originWidth=924&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=120867&amp;status=done&amp;style=none&amp;taskId=u4fa409e3-98b5-478b-8054-5477af6bbff&amp;title=&amp;width=739.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698022966939-14786148-b3fc-41a1-9e48-4428e02aebd5.png#averageHue=%23fdfdfd&amp;clientId=u7a79556a-f9a9-4&amp;from=paste&amp;height=402&amp;id=u653f6e17&amp;originHeight=502&amp;originWidth=925&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=201160&amp;status=done&amp;style=none&amp;taskId=u27aafe9e-33dd-47aa-b150-0c3d7eaffc1&amp;title=&amp;width=740" alt="image.png"><br>总结：url代表的是服务器一个资源的标识符，一个资源可以有多个标识符；但是一个url只能指向一个资源。<br>url中的?后面跟的是参数，分号代表同级下的资源，/斜杠代表层级结构。<br>REST中的get,HEAD是安全且幂等的。安全是服务器中的资源在该请求下不会发送变化，幂等是同样的请求，多次都是针对同一个url，且对系统资源的影响是一样的就是幂等性。<br>get HEAD是安全幂等的，是他们的请求既不会对服务器的资源产生变化，且多次请求都是对同一个资源进行获取，对服务器是无影响的。<br>POST是不安全且不幂等的，因为post请求是创建资源或更新资源，都会资源发送变化（就算改变后的数据和改变前的数据是一样的，但是该数据的确是改变了的）。POST URL请求中的URL是服务端的请求对象，这里的URL并非操作资源的标识符，指定了URL请求对象可能在多次POST会产生不同的情况，也就是2次同样的POST请求可能操作的资源不是同一个，这样对服务器的影响是不一样的。<br>PUT请求是不安全但是幂等的。幂等的原因是PUT URL中的URL指向是具体的资源，多个相同的PUT请求都是对同一个URL进行操作。</p><h4 id="REST的资源表征和状态转移：">REST的资源表征和状态转移：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698024138765-a08f53d2-1d4d-4078-b3bb-d46ff864290a.png#averageHue=%23ebebec&amp;clientId=u7a79556a-f9a9-4&amp;from=paste&amp;height=364&amp;id=u38b91ad1&amp;originHeight=455&amp;originWidth=935&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=224048&amp;status=done&amp;style=none&amp;taskId=ua800327e-5e8f-424d-850b-6d62d56d97e&amp;title=&amp;width=748" alt="image.png"><br>比如数据库中的一条记录就是一个资源，它可以表示为JSON格式作为响应体响应出去，也可以作为相应的变量传递给模板引擎，后面的情况就是资源的表现层。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698024392473-63574539-8dd3-4370-90a1-4e6397fd0d75.png#averageHue=%23ececec&amp;clientId=u7a79556a-f9a9-4&amp;from=paste&amp;height=392&amp;id=u00e65c6c&amp;originHeight=490&amp;originWidth=934&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=260848&amp;status=done&amp;style=none&amp;taskId=uf2dc333f-7838-4807-a0c6-10a0c372a37&amp;title=&amp;width=747.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698024655852-8a81f475-5bb2-488a-ac11-3e1708468043.png#averageHue=%23e2ead4&amp;clientId=u7a79556a-f9a9-4&amp;from=paste&amp;height=422&amp;id=ua0629266&amp;originHeight=528&amp;originWidth=953&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=307248&amp;status=done&amp;style=none&amp;taskId=uc577fbaa-cd1d-4bd5-8f7f-d7935bd763a&amp;title=&amp;width=762.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698025253620-155add42-33d3-4f39-b25f-3af31ecd593a.png#averageHue=%23e4ebd4&amp;clientId=u7a79556a-f9a9-4&amp;from=paste&amp;height=425&amp;id=u09477531&amp;originHeight=531&amp;originWidth=959&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=262800&amp;status=done&amp;style=none&amp;taskId=u9aaf740f-dbd4-4977-9b2b-91176b65ba0&amp;title=&amp;width=767.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698025441670-1091c508-141c-44b0-81a2-511b0a8cf354.png#averageHue=%23edf3df&amp;clientId=u7a79556a-f9a9-4&amp;from=paste&amp;height=370&amp;id=u7e5de6de&amp;originHeight=463&amp;originWidth=811&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=185770&amp;status=done&amp;style=none&amp;taskId=u4d5feeb0-087a-4b34-b97a-2c6c9972881&amp;title=&amp;width=648.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698025484225-2bb4cdb6-c6f0-40d0-82af-4e77b9c8478b.png#averageHue=%23f9f9f9&amp;clientId=u7a79556a-f9a9-4&amp;from=paste&amp;height=437&amp;id=ufd1cfd04&amp;originHeight=546&amp;originWidth=959&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=210098&amp;status=done&amp;style=none&amp;taskId=u2e9977c9-c9d4-4a3c-bf77-dee29caf0e4&amp;title=&amp;width=767.2" alt="image.png"><br>状态转移：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698029345277-cb2572ac-40a6-449e-868b-d340be4df942.png#averageHue=%23dddddd&amp;clientId=u7a79556a-f9a9-4&amp;from=paste&amp;height=67&amp;id=u8d8adc8a&amp;originHeight=84&amp;originWidth=882&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=56155&amp;status=done&amp;style=none&amp;taskId=ud8d1ee41-f064-49d0-8405-ed32398f96e&amp;title=&amp;width=705.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698029600852-6c15950c-e7a7-44ea-91cd-41b33cfec5d7.png#averageHue=%23dedede&amp;clientId=u7a79556a-f9a9-4&amp;from=paste&amp;height=155&amp;id=u7afdaf44&amp;originHeight=194&amp;originWidth=907&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=126164&amp;status=done&amp;style=none&amp;taskId=uccdbc11d-133a-4d85-9a80-0e04377c94c&amp;title=&amp;width=725.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698029663890-cb454a53-79f9-4e74-87d2-6b557084c222.png#averageHue=%23696e6b&amp;clientId=u7a79556a-f9a9-4&amp;from=paste&amp;height=356&amp;id=u35f35560&amp;originHeight=445&amp;originWidth=923&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=293791&amp;status=done&amp;style=none&amp;taskId=u61276bf1-815c-48e2-8c95-d892af822dc&amp;title=&amp;width=738.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698029884723-d64aa6c3-3a91-44ca-8d0c-1359229aec97.png#averageHue=%235a5e5a&amp;clientId=u7a79556a-f9a9-4&amp;from=paste&amp;height=365&amp;id=ubae1f7e8&amp;originHeight=456&amp;originWidth=930&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=281904&amp;status=done&amp;style=none&amp;taskId=u22686dba-887b-475e-ad72-684687a94d7&amp;title=&amp;width=744" alt="image.png"><br>上面的点击进入下一个页面并成功进入到下一个页面了，就是客户端实现了状态转移。<br><a href="https://www.cnblogs.com/mzq123/p/11747845.html">SpringBoot HATEOAS用法简介 - smileNicky - 博客园</a><br><a href="https://zhuanlan.zhihu.com/p/626962131">Spring ResponseEntity 详解：从原理到实践</a></p><h2 id="可扩展架构：">可扩展架构：</h2><p>传统的CS架构只有一个服务器，当请求数量特别多的时候，服务器压力特别大。</p><h4 id="压力测试：">压力测试：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698039097227-3b04994d-8e30-4949-983b-992a0dfff95f.png#averageHue=%23fefaf8&amp;clientId=uaffa3aa4-bdea-4&amp;from=paste&amp;height=166&amp;id=u9d10e904&amp;originHeight=208&amp;originWidth=531&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=35960&amp;status=done&amp;style=none&amp;taskId=ubae9359e-e173-4c10-b922-85f54502cb1&amp;title=&amp;width=424.8" alt="image.png"><br><a href="https://xiuxiuing.gitee.io/blog/2018/09/18/gatlingintellij/">使用IntelliJ开发Gatling - 咻咻ing</a></p><h4 id="垂直扩展：">垂直扩展：</h4><p>更新硬件或者更好服务器提到性能。<br><a href="https://blog.csdn.net/qq_40298902/article/details/106543208">https://blog.csdn.net/qq_40298902/article/details/106543208</a></p><h4 id="SpringCaching-Redis">SpringCaching Redis:</h4><p><a href="https://blog.csdn.net/qq_44421399/article/details/109825479">@Repository 与 @Mapper的区别-CSDN博客</a><br><a href="https://blog.csdn.net/qq_31635851/article/details/120886426">【精选】【Spring Boot】Spring Boot + H2 Database 示例_springboot h2 database创建表-CSDN博客</a><br><a href="https://blog.csdn.net/qq_59363371/article/details/133758281">haproxy负载均衡_sorry#的博客-CSDN博客</a></p><h4 id="SpringsessionJDBC">SpringsessionJDBC:</h4><p><a href="https://www.bing.com/ck/a?!&amp;&amp;p=7e43384f8ea7ba95JmltdHM9MTY5ODAxOTIwMCZpZ3VpZD0wZjZlN2RlZC04YjRmLTZiYWQtMWQ2YS02ZTk4OGFhNTZhY2UmaW5zaWQ9NTQ1MA&amp;ptn=3&amp;hsh=3&amp;fclid=0f6e7ded-8b4f-6bad-1d6a-6e988aa56ace&amp;psq=session%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e6%b6%88%e5%a4%b1&amp;u=a1aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hwZWFjaGVuZy9hcnRpY2xlL2RldGFpbHMvMTIwNTM2NzMyIzp-OnRleHQ9JUU2JTg4JTkxJUU0JUJCJUFDJUU5JTgzJUJEJUU3JTlGJUE1JUU5JTgxJTkzU2Vzc2lvbiVFNiU5OCVBRiVFNSU4RiVBRiVFNCVCQiVBNSVFNiU4QyU4MSVFNCVCOSU4NSVFNSU4QyU5NiVFNSU5QyVBOCVFNiU5QyU4RCVFNSU4QSVBMSVFNSU5OSVBOCVFNCVCOCVBRCVFNCVCRiU5RCVFNSVBRCU5OCVFNyU5QSU4NCVFRiVCQyU4QyVFOCU4MCU4QyVFNCVCOCU5NCVFOSVCQiU5OCVFOCVBRSVBNCVFNiU5NyVCNiVFOSU5NyVCNCVFNiU5OCVBRjMwJUU1JTg4JTg2JUU5JTkyJTlGJUVGJUJDJThDJUU4JUJGJTk5JUU0JUI4JUFBJUU2JTk4JUFGJUU1JThGJUFGJUU0JUJCJUE1JUU1JTlDJUE4Y29uZiUyRndlYi54bWwlRTYlOTYlODclRTQlQkIlQjYlRTUlQTQlQjklRTQlQjglOEIlRTUlOEYlQUYlRTQlQkIlQTUlRTQlQkYlQUUlRTYlOTQlQjklRTclOUElODQlRUYlQkMlOEMlRTUlQjklQjYlRTQlQjglOTRTZXNzaW9uJUU1JThGJUFBJUU2JTlDJTg5JUU1JTlDJUE4JUU2JTlDJThEJUU1JThBJUExJUU1JTk5JUE4JUU1JTg1JUIzJUU5JTk3JUFEJUU3JTlBJTg0JUU2JTk3JUI2JUU1JTgwJTk5JUVGJUJDJThDJUU2JTg4JTk2JUU4JTgwJTg1JUU0JUJEJUJGJUU3JTk0JUE4LGludmFsaWRhdGUlMjAlMjglMjklRTclOUElODQlRTYlOTclQjYlRTUlODAlOTklRTYlODklOEQlRTQlQkMlOUElRTYlQjYlODglRTUlQTQlQjElRTMlODAlODI&amp;ntb=1">session存活时间</a><br><a href="https://www.yuque.com/gezigezi-lc6ye/wn4u60/clx59t?view=doc_embed">可扩展架构-续</a></p><h2 id="管道过滤器结构：">管道过滤器结构：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698111542403-22360f2c-232b-42d3-8fac-f860b57c14c7.png#averageHue=%23fbfbfb&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=617&amp;id=u26034929&amp;originHeight=771&amp;originWidth=1471&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=118980&amp;status=done&amp;style=none&amp;taskId=u13a5b9c5-d7a7-4649-8a56-789876c3783&amp;title=&amp;width=1176.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698111599403-d514dbe9-2433-4604-a71f-79e7d6f265be.png#averageHue=%23fcfcfc&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=632&amp;id=ub71c2934&amp;originHeight=790&amp;originWidth=1640&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=122713&amp;status=done&amp;style=none&amp;taskId=u38b5e005-0f8c-485a-93bb-ee1c0561607&amp;title=&amp;width=1312" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698111709762-163c62ca-c2f3-4b7d-a715-d7eff18660d4.png#averageHue=%23f4f4f4&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=660&amp;id=ucbc10473&amp;originHeight=825&amp;originWidth=1432&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=249265&amp;status=done&amp;style=none&amp;taskId=u760c50f2-448d-4508-91b8-7826ac2a1d2&amp;title=&amp;width=1145.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698111862134-65d5aaee-6f8b-4d12-b57e-8a2515ca37e6.png#averageHue=%23f2f2f2&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=604&amp;id=u9e3dc042&amp;originHeight=755&amp;originWidth=1538&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=276134&amp;status=done&amp;style=none&amp;taskId=ua111ee66-0010-4435-8f99-074c72f343f&amp;title=&amp;width=1230.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698111898662-bf4ad5b0-f2db-453c-a504-55d1350f4a5d.png#averageHue=%23f2f2f2&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=587&amp;id=u6df19330&amp;originHeight=734&amp;originWidth=1500&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=212100&amp;status=done&amp;style=none&amp;taskId=u095a9fa8-14aa-4513-b95e-6bf73c9d60c&amp;title=&amp;width=1200" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698111913217-88ad40bf-6ef2-41ee-a9d4-f41d6de57856.png#averageHue=%23f1f1f1&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=664&amp;id=uef8ec7fb&amp;originHeight=830&amp;originWidth=1535&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=369640&amp;status=done&amp;style=none&amp;taskId=ubd7eeecf-a399-4d96-8f05-2c16c83c49f&amp;title=&amp;width=1228" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698111942558-7374244f-2edd-4c26-a84b-cdb9b763a806.png#averageHue=%23fcfcfc&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=684&amp;id=uff3dc625&amp;originHeight=855&amp;originWidth=1372&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=138388&amp;status=done&amp;style=none&amp;taskId=u73a4f72e-d678-4d26-8001-fdd84ed4d52&amp;title=&amp;width=1097.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698111969254-bdbb8a65-d08e-45f9-8ccb-0e9d735a4af6.png#averageHue=%23f8f8f8&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=668&amp;id=u1e7f0dbd&amp;originHeight=835&amp;originWidth=1415&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=145919&amp;status=done&amp;style=none&amp;taskId=u1b582beb-b2fa-44de-833b-e9eb7e7d140&amp;title=&amp;width=1132" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698111992119-90a67c3a-fab1-4216-bf1e-3041861a2c3a.png#averageHue=%23f8f8f8&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=584&amp;id=u1ce4f4b0&amp;originHeight=730&amp;originWidth=1363&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=144944&amp;status=done&amp;style=none&amp;taskId=ub2ec7e0a-ba09-4a49-9033-c60fb47e649&amp;title=&amp;width=1090.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698112033911-9ef16fc5-fe4c-4aa9-871e-546121a15be3.png#averageHue=%23f9f9f9&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=354&amp;id=u14244ff8&amp;originHeight=442&amp;originWidth=1267&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=117291&amp;status=done&amp;style=none&amp;taskId=u831772ce-9d25-410b-ae0b-abce3fbc722&amp;title=&amp;width=1013.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698112061008-acbfeeec-2178-428b-a83e-87d2a70a5622.png#averageHue=%23f4f4f4&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=562&amp;id=ua0e54674&amp;originHeight=702&amp;originWidth=1482&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=128325&amp;status=done&amp;style=none&amp;taskId=udcdd1e7d-751c-4549-bd3d-24ca8118d93&amp;title=&amp;width=1185.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698112071807-8d2413c9-081b-415f-8fe8-10ec81511198.png#averageHue=%23f5f5f5&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=675&amp;id=u436c350c&amp;originHeight=844&amp;originWidth=1579&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=307989&amp;status=done&amp;style=none&amp;taskId=u4107cb5f-e93c-40fb-a10c-f99d34497b7&amp;title=&amp;width=1263.2" alt="image.png"><br>JavaIO流大都情况下是这个模式。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698112139507-7bf55aa6-f750-4d9d-bf98-182db10724b6.png#averageHue=%23fbfbfb&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=641&amp;id=udc005eed&amp;originHeight=801&amp;originWidth=1477&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=126842&amp;status=done&amp;style=none&amp;taskId=uc6721cd9-d260-4c7a-9aff-70a0d5e57f8&amp;title=&amp;width=1181.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698112183822-b9803781-3f96-4874-99a2-00d477340a17.png#averageHue=%23f9f9f9&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=688&amp;id=ua93d279f&amp;originHeight=860&amp;originWidth=1538&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=328048&amp;status=done&amp;style=none&amp;taskId=u2cdb4414-79b1-4020-b1f1-293b2cd8590&amp;title=&amp;width=1230.4" alt="image.png"><br>pipe实现了在父子进程之间的通信。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698112272369-0d972c5b-a118-48fa-bc43-5c5f8ded5432.png#averageHue=%23f6f5f4&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=595&amp;id=u2cb49bc3&amp;originHeight=744&amp;originWidth=1508&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=291818&amp;status=done&amp;style=none&amp;taskId=u685ebbc7-0090-4166-acca-54a5db02dce&amp;title=&amp;width=1206.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698112324985-d782706f-b86e-4d0f-b147-b946c84f1724.png#averageHue=%23fbfbfb&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=723&amp;id=u2c8cd9ac&amp;originHeight=904&amp;originWidth=1696&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=273726&amp;status=done&amp;style=none&amp;taskId=u1977a55e-a72d-43b4-beb0-54d93eed91a&amp;title=&amp;width=1356.8" alt="image.png"><br>通过中间形式实现不同语言的互通。</p><h4 id="SpringBatch-进行大批批处理的框架">SpringBatch:进行大批批处理的框架</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698112403869-68343d01-179a-4c4d-b723-446adeb6eecf.png#averageHue=%23f2f3f2&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=649&amp;id=u10efbd8a&amp;originHeight=811&amp;originWidth=1552&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=383369&amp;status=done&amp;style=none&amp;taskId=uff5f7288-8d10-4626-a6b5-517ac0ad993&amp;title=&amp;width=1241.6" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698112513669-29e4a06b-8474-479e-86a8-60a3c7f577e9.png#averageHue=%23f7f2ec&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=697&amp;id=u9d790273&amp;originHeight=871&amp;originWidth=1351&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=215942&amp;status=done&amp;style=none&amp;taskId=uf0117dbc-6f41-4633-a92f-e9fc1305c51&amp;title=&amp;width=1080.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698112576440-1f5df12f-22c8-4ff1-b45f-855c0942b579.png#averageHue=%23fbf9f4&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=666&amp;id=u3cdba329&amp;originHeight=832&amp;originWidth=1461&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=216267&amp;status=done&amp;style=none&amp;taskId=u6ee3173f-f6fc-49a1-9c2e-29e35b662c7&amp;title=&amp;width=1168.8" alt="image.png"><br><a href="https://spring.io/projects/spring-batch">Spring Batch</a><br><a href="https://spring.io/batch">Batch</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698112942602-b70256f0-0497-48b2-b7b1-ef3870248b63.png#averageHue=%23fdfcfb&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=457&amp;id=ub4cd4964&amp;originHeight=571&amp;originWidth=1012&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=271856&amp;status=done&amp;style=none&amp;taskId=u3aa8a0c9-3005-4ddc-b462-732ffeb4671&amp;title=&amp;width=809.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698113063287-b81b2d51-5d8e-4b70-9cef-1dc982a29de5.png#averageHue=%23f5f5f5&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=735&amp;id=uf43e818c&amp;originHeight=919&amp;originWidth=1587&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=495311&amp;status=done&amp;style=none&amp;taskId=u10688858-52e3-460f-ad59-bc61f007e73&amp;title=&amp;width=1269.6" alt="image.png"></p><h2 id="事件驱动架构：image-png">事件驱动架构：<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698114239770-0b4a0ce9-ef27-409c-a0da-a7dbf0bff81e.png#averageHue=%23f8f8f8&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=702&amp;id=u9a9ae9ba&amp;originHeight=877&amp;originWidth=1666&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=229772&amp;status=done&amp;style=none&amp;taskId=u1dc28dfa-597f-4ace-adc4-a0fc6c92bd8&amp;title=&amp;width=1332.8" alt="image.png"></h2><h2 id="image-png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698114298557-a1738aca-1885-4cb5-8947-d755c3ece8ef.png#averageHue=%23f6f6f6&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=688&amp;id=u0c056f53&amp;originHeight=860&amp;originWidth=1613&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=223383&amp;status=done&amp;style=none&amp;taskId=u924d4caa-d359-4077-8861-b3a29471d43&amp;title=&amp;width=1290.4" alt="image.png"></h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698114326988-288ae8a2-19bb-4cf7-a6a5-ba41f8fe0c7d.png#averageHue=%23c7b97a&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=654&amp;id=u3008e674&amp;originHeight=817&amp;originWidth=1584&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=675407&amp;status=done&amp;style=none&amp;taskId=u2dc75531-8d30-4a26-8476-4d98726a47c&amp;title=&amp;width=1267.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698114359262-4a00707e-d66e-42de-8f5e-de266a57ac28.png#averageHue=%23f5ede0&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=673&amp;id=u75b6c92a&amp;originHeight=841&amp;originWidth=1560&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=378016&amp;status=done&amp;style=none&amp;taskId=u4b556cb9-ac30-4cae-882e-84a283f5d31&amp;title=&amp;width=1248" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698114383154-e9c0f3be-0e91-4f78-888b-bcb9be5ef34b.png#averageHue=%23f6f6f6&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=596&amp;id=u68b51cb4&amp;originHeight=745&amp;originWidth=1266&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=195742&amp;status=done&amp;style=none&amp;taskId=u2e310a33-a86a-4e9d-b06d-1e150f11f0c&amp;title=&amp;width=1012.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698114450537-b3cea071-8dd6-4321-86d7-2965cb03ef92.png#averageHue=%23f8f6f5&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=621&amp;id=u84ac8ce9&amp;originHeight=776&amp;originWidth=1240&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=206724&amp;status=done&amp;style=none&amp;taskId=u6b08dae9-3153-4f59-923d-76c830b822d&amp;title=&amp;width=992" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698114487691-4d4a70fa-4c19-4902-9dd7-f636c6d810b2.png#averageHue=%23faf9f2&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=527&amp;id=ud450b2b6&amp;originHeight=659&amp;originWidth=1079&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=145617&amp;status=done&amp;style=none&amp;taskId=ubb0b4a96-9305-406e-b6fb-89c695367ec&amp;title=&amp;width=863.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698114591938-7ab69a43-818b-43b6-bfa4-cf1f72b4d751.png#averageHue=%23f2f1f1&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=559&amp;id=u5eabfa53&amp;originHeight=699&amp;originWidth=1369&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=372538&amp;status=done&amp;style=none&amp;taskId=u9ca84bef-931c-4f7e-bc21-e9b54ba4c86&amp;title=&amp;width=1095.2" alt="image.png"><br><a href="https://www.cnblogs.com/caicz/p/15127904.html">Spring Event奇技淫巧 - 菜菜聊架构 - 博客园</a><br><a href="https://www.baeldung.com/spring-events">Just a moment…</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698114671024-60dd429c-d10a-4fe0-951d-e831298290cc.png#averageHue=%23f8f8f8&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=675&amp;id=uac1bc5f6&amp;originHeight=844&amp;originWidth=1651&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=389818&amp;status=done&amp;style=none&amp;taskId=ufeb54eb1-2118-4851-8c88-628a51e5149&amp;title=&amp;width=1320.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698114973444-e757d85c-dd8a-4e16-ae0d-3ff05d1cb699.png#averageHue=%23f0efee&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=638&amp;id=u88d49958&amp;originHeight=798&amp;originWidth=1432&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=469066&amp;status=done&amp;style=none&amp;taskId=uf4504bad-6c2e-4370-b7ec-9b6d9be78bc&amp;title=&amp;width=1145.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698115003732-2d073421-e7a8-42a1-a4b4-9fd221522200.png#averageHue=%23f69762&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=721&amp;id=u9c509b26&amp;originHeight=901&amp;originWidth=1604&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=318400&amp;status=done&amp;style=none&amp;taskId=u852be7c0-d509-40ce-98c8-4805d9e9495&amp;title=&amp;width=1283.2" alt="image.png"></p><h2 id="响应式架构：">响应式架构：</h2><p>响应式架构比springmvc吞吐率高，执行效率也高。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698117409784-af643b8c-1ddb-4885-83f0-574e1ddb38f8.png#averageHue=%23f6f6f6&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=650&amp;id=u28804216&amp;originHeight=813&amp;originWidth=1669&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=291827&amp;status=done&amp;style=none&amp;taskId=u3f06b05d-0842-401b-961f-eb71e0ecbc6&amp;title=&amp;width=1335.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698117654697-2bf6b061-debf-4347-bd8e-c72c18d5b803.png#averageHue=%23f9f9f8&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=686&amp;id=u5080ed24&amp;originHeight=857&amp;originWidth=1666&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=260988&amp;status=done&amp;style=none&amp;taskId=ufbc3cdfa-0fe1-43ef-ba64-fcaecba8b43&amp;title=&amp;width=1332.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698119268912-af228d7d-6c19-4f24-ba98-2a4f1e0b370d.png#averageHue=%23c0bf66&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=438&amp;id=ue7a0f927&amp;originHeight=548&amp;originWidth=997&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=276704&amp;status=done&amp;style=none&amp;taskId=u0ea251ec-b4ce-4c94-ad69-9f9d6de6496&amp;title=&amp;width=797.6" alt="image.png"><br>原因：REST风格的spring项目，当每个请求来的时候就会在tomcat服务器中的线程池中创建一个线程，而线程的创建和切换都会有额外的开销，但是当其中的一个用户请求创建的线程陷入到了阻塞，分配给该线程的cpu是浪费的；而响应式是将数据的请求当成一个流，当一个请求陷入了阻塞，线程就会切换到另外的地方处理其他失去而非等待。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698124843727-2f5464b9-a1eb-4c0f-9d1b-2b379ba940df.png#averageHue=%23f9f9f3&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=642&amp;id=uf37fb6f1&amp;originHeight=802&amp;originWidth=1354&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=289669&amp;status=done&amp;style=none&amp;taskId=u17766a7a-65fd-4d9d-98f9-5ca682d9162&amp;title=&amp;width=1083.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698124854963-e17d3edc-983b-496e-85df-f874c7be8b0e.png#averageHue=%23f6f6f5&amp;clientId=u4d1c17cb-e6d8-4&amp;from=paste&amp;height=641&amp;id=u60c86613&amp;originHeight=801&amp;originWidth=1498&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=284635&amp;status=done&amp;style=none&amp;taskId=u67450b8a-4f13-4505-aa23-633aeac1cc4&amp;title=&amp;width=1198.4" alt="image.png"></p><h1>复习：</h1><p><a href="https://leibudao.github.io/posts/safinalexam/">软件体系结构期末复习</a><br><a href="https://acupofair.github.io/post/software_arch/">软件体系结构核心点复习</a><br><a href="https://blog.csdn.net/weixin_51970555/article/details/125272228">软件体系结构期末复习六十题_软件设计与体系结构期末考试题-CSDN博客</a><br>1.软件架构包括组件、连接件和约束三大要素。</p><ul><li>组件：可以是一组代码，也可以是独立的程序。</li><li>连接件：可以是过程调用、管道和消息等，用于表示组件间的相互关系。</li><li>约束：组件连接时的条件。</li></ul><p><a href="https://www.cnblogs.com/qixin/p/3163536.html">“4+1”视图模型 - QI XIN - 博客园</a><br><a href="https://leibudao.github.io/posts/safinalexam/">软件体系结构期末复习</a><br>主义上面2种关于4+1不同的说法，但是实质是一样的，只不过使用的标准不一样。第一个是某个论文提出的，第二个是Rational Rose中提出的，但是他们的本质是不变的。<br>1.逻辑视图是描述系统的功能需求的，也即是系统提供给用户什么服务。通常包括类图、对象图、状态图和协作图<br>2.过程视图：描述系统中的进程，该视图通常包含活动图、顺序图等。<br>3.开发视图侧重于软件模块的组织和管理。也就是组织软件模块，库，子系统，开发单元。</p><ul><li>描述系统的各部分如何被组织为模块和组件。</li><li>该视图通常包含包图和组件图。</li><li>管理系统体系结构中的层非常有用。</li></ul><p>4.物理视图：将其他元素映射到处理和通信节点。描述如何将前三个视图中所述的系统设计实现为一组现实世界的实体，该视图通常包含部署图，展示了抽象部分如何映射到最终部署的系统中。<br>5.用例视图（场景视图）：将其他视图映射到重要的用例（这些用例被称作场景）上对体系结构加以说明。场景视图就是描述现实中的一个系统运用场景的过程；</p><ul><li>从外部世界的角度描述正在建模的系统的功能。</li><li>需要使用此视图来描述系统应该执行的操作。 所有其他视图都依靠用例视图（场景）来指导，这就是将模型称为4 + 1的原因。</li><li>该视图通常包含用例图，描述和概述图。</li></ul><p>为什么事件驱动的特殊风格的架构存在数据交换的问题？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">一个问题是事件驱动架构中的数据交换需要通过事件消息进行，这可能导致数据的复制和传递过程。</span><br><span class="line">当一个事件被触发时，它必须通过事件消息进行传递到相应的处理器或订阅者。这可能涉及将数据从</span><br><span class="line">一个组件复制到另一个组件，从而引入了额外的开销和延迟。如果系统中存在大量频繁的数据交换，</span><br><span class="line">这种复制和传递过程可能会成为性能瓶颈。</span><br><span class="line">此外，事件驱动架构中的数据交换通常是异步的。当事件被触发时，发送事件消息的组件不会立即等待接收方</span><br><span class="line">的响应。这意味着在事件消息被处理之前，发送方无法得知接收方的状态或结果。这种异步性质可以增加</span><br><span class="line">系统的复杂性，特别是在处理涉及多个事件和依赖关系的复杂业务逻辑时。</span><br><span class="line">另一个可能的问题是事件驱动架构中的数据一致性。由于事件消息的异步性质，可能存在事件消息的顺序</span><br><span class="line">问题或丢失问题。如果事件消息的顺序很重要，或者某些事件消息丢失将导致数据不一致，那么</span><br><span class="line">在设计和实现事件驱动架构时需要考虑这些问题，并采取适当的措施来确保数据的一致性。</span><br></pre></td></tr></table></figure><p>黑板知识库：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">黑板知识库（Blackboard Knowledge Base）是一种软件架构中的组件，用于支持基于协同问题解决的系统。它的设计灵感来自于人类协同问题解决的模式，其中多个专家在一个黑板上共同解决复杂问题。</span><br><span class="line"></span><br><span class="line">在黑板知识库的架构中，系统的问题被表示为一个共享的黑板，也称为黑板区域（Blackboard Area）。问题的初始状态被放置在黑板上，然后系统中的多个独立的专家组件（称为知识源）并行地观察和分析问题，并尝试提供解决方案。</span><br><span class="line"></span><br><span class="line">每个知识源是一个独立的模块，具有特定的知识、推理能力或算法。它们独立地工作，观察黑板上的问题状态，并生成或修改与问题相关的信息。每当知识源做出改变时，它将其结果写回黑板，以便其他知识源可以读取并进行进一步的推理和分析。</span><br><span class="line"></span><br><span class="line">黑板知识库架构的核心思想是通过知识源之间的协同合作来解决问题。不同的知识源可以具有不同的专业领域知识、算法或推理能力，它们可以根据自己的知识和推理结果来决定何时对问题状态进行修改。这种协同合作的方式可以使系统更具灵活性和适应性，能够处理复杂的、多学科的问题。</span><br><span class="line"></span><br><span class="line">黑板知识库的架构适用于解决那些问题领域复杂、需要多种专业知识和推理方法的应用。它可以应用于领域如人工智能、专家系统、机器学习和数据挖掘等。</span><br></pre></td></tr></table></figure><p>C2风格是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C2风格的设计灵感来自于人类协同工作的模式，例如团队合作、集体智慧和群体决策。它提供了一种机制和架构，使得分布在不同位置的多个计算节点能够相互通信、协同工作和协同决策。</span><br><span class="line"></span><br><span class="line">C2风格的核心概念是<span class="string">&quot;C2&quot;</span>，即指挥与控制（Command and Control）。在这种风格下，一个或多个指挥节点（Command Node）负责协调和指导系统中的其他节点。指挥节点可以收集、分析和传达信息，协调节点之间的工作，并做出决策。</span><br><span class="line"></span><br><span class="line">其他节点被称为执行节点（Execution Node），它们根据指挥节点的指令执行任务，并将结果反馈给指挥节点。执行节点之间可以相互通信和协作，共同解决问题。指挥节点可以根据执行节点的反馈信息进行调整和决策，以实现协同工作和协同决策的目标。</span><br></pre></td></tr></table></figure><p>剪切板应该是什么体系结构？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">体系结构的角度来看，剪切板功能可以被认为是一个典型的发布-订阅（Publish-Subscribe）或观察者模式（Observer Pattern）。应用程序可以将数据发布到剪切板，并通知操作系统，表示数据可供其他应用程序订阅和使用。其他应用程序可以订阅剪切板，并在有新数据可用时接收通知，并获取数据以供其自身使用。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700013735889-9777f591-8570-43b1-b655-3dd7df475e42.png#averageHue=%23fcfcfb&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=245&amp;id=ud09a17da&amp;originHeight=306&amp;originWidth=532&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=17678&amp;status=done&amp;style=none&amp;taskId=ude90b039-6dce-4d2e-b4a2-5d801c6e947&amp;title=&amp;width=425.6" alt="image.png"><br>过程控制是属于控制流的体系结构。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700013822753-5556384c-7bac-49c4-99c1-694c0b54fb99.png#averageHue=%23fdfdfc&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=286&amp;id=u2cc55c9f&amp;originHeight=358&amp;originWidth=647&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=15991&amp;status=done&amp;style=none&amp;taskId=u60b47502-7f65-42e3-8f22-76a1eba7ea0&amp;title=&amp;width=517.6" alt="image.png"><br>D是拓扑的意思。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700014207022-ada4dbab-2d0d-4c77-9753-643e62a23ee3.png#averageHue=%23fbfaf9&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=287&amp;id=u9670232e&amp;originHeight=359&amp;originWidth=863&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=45149&amp;status=done&amp;style=none&amp;taskId=uc28ca3a5-88db-411c-ae8f-809678d2e38&amp;title=&amp;width=690.4" alt="image.png"><br>D选项，B/S体系结构是不利于事务的处理的。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700014343808-e7746300-3b75-45b8-95ef-d124c2689ca2.png#averageHue=%23fbfafa&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=254&amp;id=u3f33747c&amp;originHeight=318&amp;originWidth=555&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=21881&amp;status=done&amp;style=none&amp;taskId=ufa8e0ff3-5f32-44ba-b547-8489bcdaa36&amp;title=&amp;width=444" alt="image.png"><br>C选项的移植困难是因为不同的操作系统兼容性不一样，维护困难和升级困难是因为客户端被安装到本地电脑上了需要逐个升级和维护。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700014819232-01e99db7-10b0-437d-acb6-41a5a2ea08ed.png#averageHue=%23fcfbfa&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=268&amp;id=u00806b3f&amp;originHeight=335&amp;originWidth=432&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=23730&amp;status=done&amp;style=none&amp;taskId=u48ca5b91-8320-4b82-9f7e-14c6a834340&amp;title=&amp;width=345.6" alt="image.png">（B选项可以这样理解spring中的控制层返回的是一个页面也就是view，他们并没有完全的解耦；C选项视图要通过控制器才能访问模型数据。模型（Model）是MVC架构中的组成部分之一，它代表应用程序的数据和业务逻辑。模型负责存储和管理数据，以及定义与数据相关的操作和规则。模型封装了数据的访问方法，并提供了对数据的增加、删除、修改和查询等操作。而spring中的模型我们常常用到它的存储和管理数据功能来动态修改模板引擎的数据。可以理解为springboot中的model将MVC中的V分割为了2部分，一部分是操作数据，一部分是存储和管理数据的）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700015194915-4a8b49f1-2fc8-431b-9b22-ca7325ae8140.png#averageHue=%23fdfdfc&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=254&amp;id=ud15c552a&amp;originHeight=318&amp;originWidth=709&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=15716&amp;status=done&amp;style=none&amp;taskId=ucaa92803-851a-4148-a7e3-9e8b2fd8893&amp;title=&amp;width=567.2" alt="image.png"><br>XML：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700015304570-17ca2138-af1c-4376-9d29-c26bcf5d4336.png#averageHue=%23fefefe&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=257&amp;id=uabef6ede&amp;originHeight=321&amp;originWidth=973&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=101673&amp;status=done&amp;style=none&amp;taskId=uc7eee41e-dbf5-4904-946d-345dca19764&amp;title=&amp;width=778.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700015396526-758b3560-6614-4339-b017-cbb4791e8781.png#averageHue=%23fefefe&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=422&amp;id=u37603c34&amp;originHeight=528&amp;originWidth=1001&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=275180&amp;status=done&amp;style=none&amp;taskId=u5405bd6c-ab35-4270-a231-885be0eb2d8&amp;title=&amp;width=800.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700015464454-cae499bc-8604-49f1-b80a-27d68af12053.png#averageHue=%23fef9f7&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=147&amp;id=u3d8ba980&amp;originHeight=184&amp;originWidth=952&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=93444&amp;status=done&amp;style=none&amp;taskId=u23e6c597-6f97-456b-aa2f-f78afff83e1&amp;title=&amp;width=761.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700015523330-388680ec-666b-49c9-9888-d486fa4cef9d.png#averageHue=%23fbf8f7&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=410&amp;id=u70abc40a&amp;originHeight=512&amp;originWidth=952&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=83022&amp;status=done&amp;style=none&amp;taskId=u3cdb66ce-cb3f-4839-b9db-bd463c83374&amp;title=&amp;width=761.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700015590836-61c08192-e470-4708-a76d-7da0ce7f7347.png#averageHue=%23ebe9e6&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=267&amp;id=ue95cff94&amp;originHeight=334&amp;originWidth=952&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=145754&amp;status=done&amp;style=none&amp;taskId=ubc24f260-a3e6-4ade-92f6-d8abce311f1&amp;title=&amp;width=761.6" alt="image.png"><br>Web服务的特点：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700016557597-541c8c00-4f75-4bc1-aa46-5af96d57dd6a.png#averageHue=%23eeeeee&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=446&amp;id=u5ac201a3&amp;originHeight=557&amp;originWidth=1039&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=349198&amp;status=done&amp;style=none&amp;taskId=u8f34730a-1162-4c5d-9c02-be05c83c16b&amp;title=&amp;width=831.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700016569231-9dc384d2-e189-4274-b9be-d59b8c82898b.png#averageHue=%23edef69&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=392&amp;id=uc744be14&amp;originHeight=490&amp;originWidth=1045&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=183696&amp;status=done&amp;style=none&amp;taskId=ub2019e17-e526-49fe-9b4f-392b8845424&amp;title=&amp;width=836" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700016601995-f2541fe8-737e-4313-bb4b-6cb99c38e144.png#averageHue=%23e8e8e8&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=451&amp;id=u9bcc8ae0&amp;originHeight=564&amp;originWidth=1045&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=276521&amp;status=done&amp;style=none&amp;taskId=uf72c08dd-4525-449a-946d-4747c2b4e4b&amp;title=&amp;width=836" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700016613738-e71db09a-a1aa-4c1b-8d97-e82586d38e80.png#averageHue=%23e0e0e0&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=183&amp;id=u7b41e090&amp;originHeight=229&amp;originWidth=647&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=82334&amp;status=done&amp;style=none&amp;taskId=u7bc0f1b6-3a20-43a6-8e93-e2ee60eacff&amp;title=&amp;width=517.6" alt="image.png"><br>简单对象访问协议(SOAP)是一个基于XML, 在松散分布式环境中交换结构化信息的轻量级协议，它本身不定义任何应用<br>语言。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700016750948-92a090ff-93a6-4428-8500-ab2ca05d011d.png#averageHue=%23fcfcfc&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=281&amp;id=u8fe8ff1a&amp;originHeight=351&amp;originWidth=693&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=17451&amp;status=done&amp;style=none&amp;taskId=ue8f655b2-1f2e-470e-9cdd-99e46f94047&amp;title=&amp;width=554.4" alt="image.png"><br><a href="https://blog.csdn.net/Cookie__C/article/details/105789466">六、Web服务体系结构_wsdl定义了服务的接口、格式协议、实现三个层次的概念。每一层各包括哪些基本元素-CSDN博客</a><br>软件体系结构的描述方法有非标准图形符号，UML,ADL，，但是无法用XML来描述，其中非标准图形符号的优点是直观形象，简单易用。<br>软件体系结构的描述方法：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700019378933-2820ab59-3cfb-41dd-95d5-c3ca295e32ef.png#averageHue=%23f4f3f3&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=167&amp;id=u42c9a972&amp;originHeight=209&amp;originWidth=304&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=20384&amp;status=done&amp;style=none&amp;taskId=u691ff6a7-133a-4544-bd5b-2227376827f&amp;title=&amp;width=243.2" alt="image.png"><br>软件体系结构用UML描述的特点：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700019433514-cc1eaa2c-b6c0-4a6b-b2ed-884183f23e37.png#averageHue=%23f8f7f7&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=446&amp;id=u4329c237&amp;originHeight=558&amp;originWidth=590&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=67631&amp;status=done&amp;style=none&amp;taskId=u866b601b-e2e3-4ac7-9adf-0024913ad9c&amp;title=&amp;width=472" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700019500458-1f5299e6-371a-4574-9518-951cb68ed630.png#averageHue=%23f5f5f4&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=499&amp;id=ubc606769&amp;originHeight=624&amp;originWidth=992&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=149174&amp;status=done&amp;style=none&amp;taskId=u71f7db35-9a7d-4035-8824-05896ab6d20&amp;title=&amp;width=793.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700019508481-c9f6ab58-99b8-46af-afca-bbfd34ac7b0c.png#averageHue=%23f0efef&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=195&amp;id=u905568df&amp;originHeight=244&amp;originWidth=976&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=107268&amp;status=done&amp;style=none&amp;taskId=u339cf97c-d2e5-494a-ab53-cf396279442&amp;title=&amp;width=780.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700019520744-def141c9-0e42-4db4-a0f2-37a87c5ce571.png#averageHue=%23eeeded&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=113&amp;id=u14e2e716&amp;originHeight=141&amp;originWidth=957&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=69651&amp;status=done&amp;style=none&amp;taskId=u9a14da4b-45a4-4e5b-8c27-8bcdfafb9e3&amp;title=&amp;width=765.6" alt="image.png"><br>上面的ADL是软件体系结构的形式化描述。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700018422750-1fb0b6a3-206d-4d89-b7e2-6e15419ee93b.png#averageHue=%23fdfcfc&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=260&amp;id=u64ad5fd6&amp;originHeight=325&amp;originWidth=448&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=15508&amp;status=done&amp;style=none&amp;taskId=u4b059079-2ae6-439f-bcbe-3c93a80a83d&amp;title=&amp;width=358.4" alt="image.png"><br>服务发现是服务使用者的特性<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700018477239-ae4f4d91-fc50-40b7-b233-4e49a7090746.png#averageHue=%23fbfbfa&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=273&amp;id=u0b9388a9&amp;originHeight=341&amp;originWidth=553&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=22073&amp;status=done&amp;style=none&amp;taskId=u68f038e0-4220-4c5e-b7fd-99efcf0c069&amp;title=&amp;width=442.4" alt="image.png"><br>XML本身不显示数据的样式，但是可以和其他技术（XSLT）结合来显示样式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XML本身并不关注数据的显示样式，它主要用于表示和组织数据的结构和内容，并提供一种通用的标记语言来描述数据。XML可以用于存储、传输和交换数据，但它并不提供直接的样式描述功能。</span><br><span class="line"></span><br><span class="line">XML可以与其他技术和语言（如XSLT和CSS）结合使用，以实现数据的样式化和展示。通过使用XSLT（Extensible Stylesheet Language Transformations）和CSS（Cascading Style Sheets），可以将XML数据与样式表关联，并将其转换为特定的显示格式，例如HTML或PDF。但这种样式化的过程是通过外部的样式表和转换规则来实现的，而不是XML本身提供的功能。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700018641153-0bfab7f8-6af4-403c-85a3-1c4c65618646.png#averageHue=%23fbfaf9&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=271&amp;id=u1ffcf3da&amp;originHeight=339&amp;originWidth=919&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=33803&amp;status=done&amp;style=none&amp;taskId=uc5bfd5d2-f6df-4005-9aa6-6ba99e085f1&amp;title=&amp;width=735.2" alt="image.png"><br>可以这样理解对象层就是类图中某个具体类的名称，特征层就是类的属性和方法；特征层描述的是类的特征（属性）和相关问题域的行为（方法），关系层就是类之间的关系，比如依赖，关联什么的。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700018701480-9436917c-9cd2-4689-be64-b06be024c0d0.png#averageHue=%23f1f1f1&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=447&amp;id=u458c3098&amp;originHeight=559&amp;originWidth=950&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=139915&amp;status=done&amp;style=none&amp;taskId=u37a51187-c24b-4b58-8f0d-fb6e2b2b70b&amp;title=&amp;width=760" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700024635391-82415447-d369-4753-99da-d0a53abb50c5.png#averageHue=%23f7f4f4&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=462&amp;id=u7a7ef77b&amp;originHeight=577&amp;originWidth=1028&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=154000&amp;status=done&amp;style=none&amp;taskId=u5d152080-5d78-4e32-ae42-b19d0e895a5&amp;title=&amp;width=822.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700025546362-9f562463-1686-48b6-b6ed-6e02faf2209d.png#averageHue=%23f2f2f2&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=185&amp;id=u5919e98a&amp;originHeight=231&amp;originWidth=351&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=15631&amp;status=done&amp;style=none&amp;taskId=u4470f4d1-9c93-4558-9690-19d96e141bd&amp;title=&amp;width=280.8" alt="image.png"><br>C/S体系结构和文件共享体系结构一般处理的情况不一样，文件共享体系结构处理的是文件的上传和修改等业务操作；文件体系结构在客户端和服务端传输的是文件，而C/S体系结构传输的是响应和请求数据，文件共享体系结构中的文件数据在客户端和服务器之间进行实际的传输和共享。当用户需要访问或编辑文件时，文件被从服务器传输到客户端，用户对文件进行操作后，可能会将修改后的文件再次上传到服务器。因此，文件共享体系结构涉及大量的文件数据在客户端和服务器之间来回移动。客户/服务器结构返回给客户端的是处理后的结果数据,文件服务器结构返回给客户端的是包含客户所需数据的文件<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700025667607-e36a591e-6fa0-4dd2-a872-393d662ec006.png#averageHue=%23f4f4f4&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=178&amp;id=u3c35a967&amp;originHeight=222&amp;originWidth=347&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=12644&amp;status=done&amp;style=none&amp;taskId=u2e07a53e-67a6-45a4-b1ee-fadb2d9abfc&amp;title=&amp;width=277.6" alt="image.png"><br>C/S体系结构开发的软件在安装和部署的时候要考虑不同的操作系统，相比于B/S不那么容易安装和部署。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700026546234-a8823cf3-fae4-450e-87cc-ed7abaf8c537.png#averageHue=%23f7f0f0&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=209&amp;id=uf4553c4c&amp;originHeight=261&amp;originWidth=908&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=74949&amp;status=done&amp;style=none&amp;taskId=u3392d39f-3951-4b13-a8b2-905ae925067&amp;title=&amp;width=726.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700026580035-8364fbba-3d7a-4fa9-bdec-a66636c1cda2.png#averageHue=%23faeaea&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=94&amp;id=u5d94945d&amp;originHeight=118&amp;originWidth=793&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=33771&amp;status=done&amp;style=none&amp;taskId=u00313762-e4cc-4757-b842-73c0801ea3f&amp;title=&amp;width=634.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700026600859-424b639d-4c6c-473d-b5ce-9ae20c5f96c1.png#averageHue=%23f2eeee&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=416&amp;id=u69e9e676&amp;originHeight=520&amp;originWidth=1016&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=160885&amp;status=done&amp;style=none&amp;taskId=u068654b4-1627-4bc0-b1e1-c36140f89b2&amp;title=&amp;width=812.8" alt="Snipaste_2023-11-15_13-36-34.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700026613188-6c64cf42-8559-42f8-8b9a-f74b9d182422.png#averageHue=%23f7ecec&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=312&amp;id=ue12b48a4&amp;originHeight=390&amp;originWidth=992&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=118688&amp;status=done&amp;style=none&amp;taskId=u66540ba1-fe89-4e86-a737-3316b651b5c&amp;title=&amp;width=793.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700026623529-8172f689-4923-47a2-92d6-37d561743dda.png#averageHue=%23f5f2f2&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=204&amp;id=ucf1b91cf&amp;originHeight=255&amp;originWidth=986&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=64221&amp;status=done&amp;style=none&amp;taskId=u34880127-8a4a-458e-bfa5-7a5e04d98f8&amp;title=&amp;width=788.8" alt="Snipaste_2023-11-15_13-36-58.png"><br>中间件：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700027105757-2b6389a5-22da-4eef-a7e6-c3e22e74edbe.png#averageHue=%23fbf4f4&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=148&amp;id=u85b4259a&amp;originHeight=185&amp;originWidth=650&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=30910&amp;status=done&amp;style=none&amp;taskId=ud19db07f-020b-4afb-b1b4-59f32d14f2f&amp;title=&amp;width=520" alt="image.png"><br>中间件的定义：一种连接类软件，由一组服务构成，用来连接不同的软件构件或应用系统这些服务可以让运行在同一台或多台机器上的进程进行通信交互；在分布式计算环境中是一种处于操作系统和应用系统之间的软件层。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700027275407-6eee22c0-919e-48ef-9c04-472be1ae8b18.png#averageHue=%23e6d9d9&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=339&amp;id=u8f3099ab&amp;originHeight=424&amp;originWidth=1019&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=263724&amp;status=done&amp;style=none&amp;taskId=ub985b905-7539-430d-a7eb-0facd6d4cb0&amp;title=&amp;width=815.2" alt="image.png"><br>中间件的类型：RPC：远程过程调用，MOM：消息中间件；ORB:对象请求代理中间件；SQL;TP Monitor:事件处理监听器；<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700029667129-4909a61d-7c03-44d1-8d98-eec7731f623a.png#averageHue=%23f5f4f4&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=487&amp;id=uc06be3c7&amp;originHeight=609&amp;originWidth=1039&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=201148&amp;status=done&amp;style=none&amp;taskId=u7041192a-5406-4685-98f3-cafacdd3928&amp;title=&amp;width=831.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700029941215-63edd40f-706e-4a7c-9d8a-9dba09fe67b2.png#averageHue=%23ebdfdf&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=381&amp;id=u3944d521&amp;originHeight=476&amp;originWidth=987&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=221651&amp;status=done&amp;style=none&amp;taskId=u1c99558a-60f5-459e-a8a2-c777f2d387c&amp;title=&amp;width=789.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700029963648-ec45e416-3197-4619-87fe-0510718911be.png#averageHue=%23eedfdf&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=307&amp;id=u4dd68796&amp;originHeight=384&amp;originWidth=1000&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=180108&amp;status=done&amp;style=none&amp;taskId=ud049f40e-f5f7-40d1-98aa-8a4b266ac97&amp;title=&amp;width=800" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700029981169-5f3c75cd-9e77-4e38-9aa3-962020181315.png#averageHue=%23ede6e6&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=316&amp;id=u3f78b583&amp;originHeight=395&amp;originWidth=1013&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=208082&amp;status=done&amp;style=none&amp;taskId=u2a30b063-704a-4ff5-9f37-dfc155b78b0&amp;title=&amp;width=810.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700030044889-1cf400ee-c555-4420-bc0d-0f5c8d9fadf2.png#averageHue=%23f8f4f4&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=464&amp;id=u75864ed2&amp;originHeight=580&amp;originWidth=1018&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=132461&amp;status=done&amp;style=none&amp;taskId=ued03c55f-a66e-4664-b44a-b5aaa58781a&amp;title=&amp;width=814.4" alt="image.png"><br>MVC遵循稳定依赖原则，其中稳定依赖原则是SDP；MVC稳定依赖的部分是模型，因为模型不依赖于控制器和视图。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700030184946-5a3895aa-7755-4125-8c0e-56aa2032980c.png#averageHue=%23fbf6ef&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=502&amp;id=ue9e0738c&amp;originHeight=628&amp;originWidth=1028&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=347135&amp;status=done&amp;style=none&amp;taskId=u03dd6c37-0a06-4f56-b759-6dbd49bad28&amp;title=&amp;width=822.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700030229000-e00050ad-48c1-45fe-94a8-c67e888e8178.png#averageHue=%23f8f2f2&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=269&amp;id=ubcacf6c9&amp;originHeight=336&amp;originWidth=1010&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=88760&amp;status=done&amp;style=none&amp;taskId=ufb181a55-2b7e-4910-bbf2-25044da4e01&amp;title=&amp;width=808" alt="image.png"><br>MVC的被动模式：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700031177103-1fb3ff4f-c22a-4e95-879d-284af56fc470.png#averageHue=%23fffefe&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=225&amp;id=uddc7095a&amp;originHeight=281&amp;originWidth=1004&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=68905&amp;status=done&amp;style=none&amp;taskId=u53d17c56-e708-4e53-812b-096b365cc4d&amp;title=&amp;width=803.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700031289673-0eeae289-78cb-49ea-bad1-17d06f5dc825.png#averageHue=%23fbfaf9&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=250&amp;id=ue932c60d&amp;originHeight=312&amp;originWidth=527&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=22090&amp;status=done&amp;style=none&amp;taskId=ufbd8466a-cd0b-4ba6-b26a-c242b996d8c&amp;title=&amp;width=421.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700031601457-f0b8d4e0-4182-42b1-b838-4fa3924588dc.png#averageHue=%23f7f7f8&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=225&amp;id=u722420aa&amp;originHeight=281&amp;originWidth=426&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=13607&amp;status=done&amp;style=none&amp;taskId=ud672f52b-7b1c-49b5-8c24-d226f72f2f9&amp;title=&amp;width=340.8" alt="image.png"><br>SOA的优点：</p><ul><li>（1）灵活性，根据需求变化，重新编排服务。</li><li>（2）对IT资产的复用。</li><li>（3）使企业的信息化建设真正以业务为核心。业务人员根据需求编排服务，而不必考虑技术细节。</li></ul><p>WSDL是SOA中Web服务的描述，WSDL文档也描述了Web服务的接口。<br>软件体系结构是什么？<br>软件体系结构来源于建筑学的体系结构，覆盖软件开发的全周期，主要聚焦于系统的总体结构以及需求和实现之间的对应；注重组件的可重用性和软件的健壮性，可维护性；软件体系结构=构件+连接件+拓扑结构+约束+质量，其中构件，连接件，约束是软件体系结构的三大要素；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">软件重用是指在软件开发过程中，利用已有的软件组件、模块、库、框架或设计模式等，以提高开发效率、</span><br><span class="line">降低成本，并改善软件质量和可维护性的实践。它的核心思想是通过重复使用已有的可靠和经过验证的</span><br><span class="line">软件资产，避免从头开始编写代码，从而加快开发速度、减少开发风险并提高软件的质量。</span><br><span class="line">软件重用的几个关键是：组件和模块重用；第三方库和框架重用；设计模式和架构重用；经验和知识重用</span><br></pre></td></tr></table></figure><p>批处理和管道过滤器的比较：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700033163645-b49f2b97-eb43-464a-a8a0-a81f6160925c.png#averageHue=%23dfdfdf&amp;clientId=u742374d8-b650-4&amp;from=paste&amp;height=185&amp;id=u917a4381&amp;originHeight=231&amp;originWidth=813&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=31047&amp;status=done&amp;style=none&amp;taskId=u17fc0d0f-bef5-4f1c-9362-469f2d33545&amp;title=&amp;width=650.4" alt="image.png"><br>批处理是将多个任务按照一定的顺序排好自动执行的，而管道过滤器是逐步执行的，数据流经过一个过滤器后处理信息后传递该后一个过滤器；管道可以在Linux系统中实现父子进程的通信，而批处理不可以。管道过滤器可能会发生死锁，其也支持死锁检测；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)合理地划分三层结构的功能，可以使系统的逻辑结构更加清晰，提高软件的可维护性和可扩充性。</span><br><span class="line">(<span class="number">2</span>)在实现三层C/S架构时，可以更有效地选择运行平台和硬件环境，从而使每一层都具有清晰的逻辑结构、</span><br><span class="line">良好的负荷处理能力和较好的开放性。</span><br><span class="line">(<span class="number">3</span>)在C/S架构中，可以分别选择合适的编程语言并行开发。</span><br><span class="line">(<span class="number">4</span>)系统具有较高的安全性。</span><br></pre></td></tr></table></figure><p>软件体系结构的描述方法有：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700036061364-b032b32f-3101-4764-86f0-e0e1bad62749.png#averageHue=%23fefefd&amp;clientId=u4491d297-fb93-4&amp;from=paste&amp;height=157&amp;id=u0cea7455&amp;originHeight=196&amp;originWidth=892&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=29669&amp;status=done&amp;style=none&amp;taskId=uc1fedf09-194b-45b6-8fe7-6a1c1a3f141&amp;title=&amp;width=713.6" alt="image.png"><br>1.非标准图形符号描述：特点是：语义丰富，但是不精确，直观形象，简单易用<br>2.UML：侧重于面向对象分析，语义丰富，且精确；可以根据UML图生成代码；<br>3.模块接口语言：MIL，语义比较丰富，精确，但是实现级别，层次较低；<br>4.体系结构描述语言ADL：在软件体系结构抽象级上提供了精确的定义，提供了强有力的分析能力，抽象和实现细节无观性，为体系结构元素定义了一系列的符号。语言准确无二义性；<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700035760288-d3931967-707e-4391-a3da-bbd39186fb17.png#averageHue=%23fefefd&amp;clientId=u4491d297-fb93-4&amp;from=paste&amp;height=253&amp;id=u1d1e0cd3&amp;originHeight=316&amp;originWidth=521&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=17428&amp;status=done&amp;style=none&amp;taskId=u9034af6e-d732-4771-ade3-abd0b4fe6cf&amp;title=&amp;width=416.8" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开发关注的是组件的组合方式，也就是开发环境中的静态组织结构，其属于开发期的质量属性</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700035849072-9b414d07-f0ea-4fd5-b067-c7db0ee6bebe.png#averageHue=%23fefefd&amp;clientId=u4491d297-fb93-4&amp;from=paste&amp;height=282&amp;id=u83f7a197&amp;originHeight=353&amp;originWidth=844&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=24266&amp;status=done&amp;style=none&amp;taskId=uc59fe91c-05cd-4bcd-9dd2-1df63bf657d&amp;title=&amp;width=675.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700035943599-d53fac9d-7e08-46fe-a374-84f9be04d2f5.png#averageHue=%23fefdfb&amp;clientId=u4491d297-fb93-4&amp;from=paste&amp;height=275&amp;id=uc5f7915b&amp;originHeight=344&amp;originWidth=772&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=29588&amp;status=done&amp;style=none&amp;taskId=uffeaf5ad-e862-4f95-956d-e87fe238a2c&amp;title=&amp;width=617.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700035990296-98c3de37-d2bf-4330-89cd-6365eaaf0cfa.png#averageHue=%23fefefe&amp;clientId=u4491d297-fb93-4&amp;from=paste&amp;height=298&amp;id=u4b8dda1e&amp;originHeight=373&amp;originWidth=1061&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=33542&amp;status=done&amp;style=none&amp;taskId=u5773f8e3-2516-4647-b0a8-29702d6a41a&amp;title=&amp;width=848.8" alt="image.png"><br>开发视图通常使用构件图来描述。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700036246949-17dcd291-ca2f-4bfe-8862-51691720f97a.png#averageHue=%23fefdfc&amp;clientId=u4491d297-fb93-4&amp;from=paste&amp;height=402&amp;id=uc40a9604&amp;originHeight=503&amp;originWidth=1057&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=75270&amp;status=done&amp;style=none&amp;taskId=u32efd650-ba7d-4108-a8d4-738b9ab8db3&amp;title=&amp;width=845.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700036608106-975c8478-50ee-49bb-bf89-5f3396eb1891.png#averageHue=%23fefefd&amp;clientId=u4491d297-fb93-4&amp;from=paste&amp;height=277&amp;id=u57695e5b&amp;originHeight=346&amp;originWidth=563&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=16721&amp;status=done&amp;style=none&amp;taskId=u7f33cb08-eef3-48c4-9e4c-53747541daf&amp;title=&amp;width=450.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700036692900-b8ceea18-44a3-43b9-aeab-441a7d49d842.png#averageHue=%23fefdfc&amp;clientId=u4491d297-fb93-4&amp;from=paste&amp;height=324&amp;id=u04485349&amp;originHeight=405&amp;originWidth=939&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=47173&amp;status=done&amp;style=none&amp;taskId=u6a9c7a19-342b-4c4a-a5e1-4441b04b2ae&amp;title=&amp;width=751.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700037033333-e65dcaac-aec7-4eb1-8e7d-1ab036d0e287.png#averageHue=%23fbfaf9&amp;clientId=u4491d297-fb93-4&amp;from=paste&amp;height=383&amp;id=ueabf9161&amp;originHeight=479&amp;originWidth=1078&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=54822&amp;status=done&amp;style=none&amp;taskId=u836db62c-674c-44eb-9078-d37b4fb9f0d&amp;title=&amp;width=862.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700037146888-d9ff8dad-3996-43d8-92fa-a457c516f294.png#averageHue=%23fefefd&amp;clientId=u4491d297-fb93-4&amp;from=paste&amp;height=282&amp;id=u6cd65ff3&amp;originHeight=352&amp;originWidth=633&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=25248&amp;status=done&amp;style=none&amp;taskId=u1d1eae15-ca2b-408a-a26c-3ac0369aff7&amp;title=&amp;width=506.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700038601588-2e538f43-d810-49bc-b2af-206d9761b65e.png#averageHue=%23fefdfb&amp;clientId=u4491d297-fb93-4&amp;from=paste&amp;height=267&amp;id=uee7f9664&amp;originHeight=334&amp;originWidth=646&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=34389&amp;status=done&amp;style=none&amp;taskId=ud1f2c037-3fa2-406a-936c-6214dcc1411&amp;title=&amp;width=516.8" alt="image.png"><br>Web服务所提供的接口、对Web服务的请求、Web服务的应答数据都是通过XML来描述的。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700039090428-5914aba4-d8a0-4e41-9a7b-f9b6e2e30390.png#averageHue=%23fefefd&amp;clientId=u4491d297-fb93-4&amp;from=paste&amp;height=366&amp;id=u701b67e0&amp;originHeight=458&amp;originWidth=712&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=27243&amp;status=done&amp;style=none&amp;taskId=u85c5a2be-4fdd-473f-a88c-91a7883d175&amp;title=&amp;width=569.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700039273910-da1c79c2-3660-4ade-aba0-c507c8ebb1a9.png#averageHue=%23fefefe&amp;clientId=u4491d297-fb93-4&amp;from=paste&amp;height=258&amp;id=u14a6851c&amp;originHeight=323&amp;originWidth=718&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=42652&amp;status=done&amp;style=none&amp;taskId=u5b85a85d-053b-4c5e-ac0a-9bd28e3b0e9&amp;title=&amp;width=574.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700039741906-c499e826-cfe9-4af2-ac4d-b6084ccdacd5.png#averageHue=%23fefefd&amp;clientId=u4491d297-fb93-4&amp;from=paste&amp;height=292&amp;id=u13076abf&amp;originHeight=365&amp;originWidth=1094&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=25722&amp;status=done&amp;style=none&amp;taskId=u79fb2cfe-99b8-4119-85ca-648ff33c275&amp;title=&amp;width=875.2" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html"> &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1GE411G7hu/?spm_id_from=333.337.s</summary>
      
    
    
    
    <category term="课程作业" scheme="http://www.bojiboqi.fun/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="软件体系结构" scheme="http://www.bojiboqi.fun/tags/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>软件工程课堂学习记录</title>
    <link href="http://www.bojiboqi.fun/2024/02/28/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    <id>http://www.bojiboqi.fun/2024/02/28/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</id>
    <published>2024-02-28T13:02:28.536Z</published>
    <updated>2024-02-28T10:44:05.251Z</updated>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h1>软件及软件工程：</h1><p>计算机软件指计算机系统中的<strong>程序</strong>、<strong>数据</strong>及<strong>其相关文档</strong><br>程序：按照特定顺序组织的计算机数据和指令的集合。<br>数据：使程序能正常执行的数据结构<br>文档：为了便于理解程序所需的与开发、维护和使用有关的资料<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686713495060-cdf27133-f9ba-4928-a83a-c41381428958.png#averageHue=%23d6c9c5&amp;clientId=u3a2eaed4-c828-4&amp;from=paste&amp;height=369&amp;id=ue4e721cd&amp;originHeight=461&amp;originWidth=709&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=113642&amp;status=done&amp;style=none&amp;taskId=ue5df6370-8fe5-4bd1-acfc-f101f3f2ba2&amp;title=&amp;width=567.2" alt="image.png"></p><h4 id="生命周期模型">生命周期模型</h4><p>软件生命周期模型是指在软件开发过程中，按照一定的时间顺序和阶段性的划分，将软件开发过程分为不同的阶段，并规定各个阶段的任务和交付成果。这些阶段通常包括需求分析、设计、编码、测试、部署和维护等<br>软件生命周期(Software Life Cycle,SLC)是软件的产生直到报废或停止使用的生命周期。软件生命周期内有<strong>问题定义、可行性分析、总体描述、系统设计、编码、调试和测试、验收与运行、维护升级</strong>等阶段。那么如何将上述软件开发过程方法化呢？这就是过程模型。过程模型（Process Models） 意图解决软件过程中的混乱，将软件开发过程中的沟通、计划、建模、构建和部署等活动（activities）有效地组织了起来。<strong>他们之间的线性（linear）、迭代（iterative）、演进（evolutionary）和平行（parallel）关系会产生不同的模型</strong>。常见的过程模型包括：瀑布模型、原型模型、增量模型、<br><a href="https://www.cnblogs.com/qiaoli0726/p/14167524.html">软件开发常见模型（瀑布模型、V模型、W模型、敏捷开发模型） - qiaoli - 博客园</a></p><h4 id="软件过程模型：">软件过程模型：</h4><p>也称软件开发模型  或 软件生存周期模型<br>是软件生存周期中一系列有序的软件开发活动的流程，是软件开发全部活动的结构框架。<br>对一个软件的开发无论其大小，都需要选择一个合适的软件过程模型，主要根据软件的类型、规模，开发方法、开发环境等多种因素来确定。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686445217940-edf1f49e-9a0e-4ff0-b457-846d4303aebf.png#averageHue=%23e6d9cc&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=382&amp;id=u363915b6&amp;originHeight=478&amp;originWidth=752&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=122099&amp;status=done&amp;style=none&amp;taskId=u2bc8e8c0-3ba8-4681-a28f-0449ab564b8&amp;title=&amp;width=601.6" alt="image.png"><br>瀑布模型<br>原型模型</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686448315316-db100647-b56f-4ba6-b3e7-8b35a74ee240.png#averageHue=%23ebe8e8&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=418&amp;id=u4db035f4&amp;originHeight=522&amp;originWidth=853&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=174134&amp;status=done&amp;style=none&amp;taskId=u5e50f2b3-ac26-41bb-b285-d8c040890f0&amp;title=&amp;width=682.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686448668857-2c852d99-3d1b-47da-8fdd-f4374c4517b9.png#averageHue=%23fefefd&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=281&amp;id=u1945f7c5&amp;originHeight=351&amp;originWidth=1116&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=28513&amp;status=done&amp;style=none&amp;taskId=u5f592378-a0f4-4c9f-9148-eeaf90b0f64&amp;title=&amp;width=892.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686448749409-73183c2e-79be-468a-97e2-746d9df97348.png#averageHue=%23fefefe&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=289&amp;id=u659a6c6e&amp;originHeight=361&amp;originWidth=1151&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=23067&amp;status=done&amp;style=none&amp;taskId=u595d0ef7-66de-4957-b279-f9e6b544211&amp;title=&amp;width=920.8" alt="image.png"><br>结构化程序设计（Structured Programming）是一种软件开发方法，旨在通过清晰、简洁、易于理解的编码方式来提高软件的可读性、可维护性和可靠性。结构化程序设计通常采用顺序、选择和循环等基本控制结构，避免使用goto语句等不可控制的跳转语句，以便更好地理解和控制程序的执行流程。<br>结构化程序设计的主要特点包括：</p><ol><li>模块化：将程序分解成多个相互独立的模块，每个模块具有清晰的输入和输出，便于维护和修改。</li><li>顺序结构：按照顺序执行程序的不同部分，避免使用不可控制的跳转语句。</li><li>选择结构：根据条件选择不同的执行路径，例如if-else语句、switch语句等。</li><li>循环结构：根据条件重复执行某些操作，例如while循环、for循环等。</li></ol><p>结构化程序设计的优点是程序结构清晰，易于理解和维护，能够提高程序的可读性、可维护性和可靠性。同时，结构化程序设计还可以提高软件开发的效率和质量，减少开发成本和时间。<br>是“<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/9957246?fromModule=lemma_inlink">面向过程</a>”方法的改进， 结构上将<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/224122?fromModule=lemma_inlink">软件系统</a>划分为若干功能模块， 各模块按要求单独编程， 再由各模块连接， 组合构成相应的软件系统。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686449426922-26349020-c7ea-4b3c-a38f-0c8bb7a92cb1.png#averageHue=%23fefefe&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=257&amp;id=u42c70125&amp;originHeight=321&amp;originWidth=1126&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=22224&amp;status=done&amp;style=none&amp;taskId=u7df85039-2ce0-4f61-9c71-db9e49a096b&amp;title=&amp;width=900.8" alt="image.png"></p><h1><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686449470800-adb9d6e5-af86-4cb5-8717-8391bd5cf58c.png#averageHue=%23fefefd&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=327&amp;id=ub136348b&amp;originHeight=409&amp;originWidth=1098&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=30274&amp;status=done&amp;style=none&amp;taskId=uca03df77-002c-487b-b0f2-5e3c14f9057&amp;title=&amp;width=878.4" alt="image.png"></h1><p>潜在可交付的产品增量是什么<br>在敏捷开发中，潜在可交付的产品增量（Potentially Shippable Product Increment，PSPI）指的是在当前迭代周期结束时，团队完成的一个可用、可测试、可部署、可交付的软件产品版本。它是在迭代周期内完成的所有工作成果的集合，包括新功能、增强功能和修复问题等。PSPI是一个完整的、可用的、可交付的软件产品版本，可以交付给客户或者用于生产环境。<br>潜在可交付的产品增量是敏捷开发中的一个重要概念，它强调了团队在每个迭代周期内需要完成一个可用、可测试、可部署、可交付的软件产品版本。通过这种方式，团队可以更快地响应客户需求和市场变化，提高开发效率和质量，并不断改进和优化软件产品。<br>值得注意的是，潜在可交付的产品增量并不一定需要在迭代周期结束时立即交付给客户或者用于生产环境。它可以在迭代周期结束后进行进一步的测试、评估和优化，直至达到满足交付要求的标准后再进行交付。这有助于确保软件产品的质量和可用性，并避免潜在的风险和问题。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686540999105-c1bab5c6-495b-40ce-b947-3be57b0e84cd.png#averageHue=%23faf9f9&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=150&amp;id=ub06ee257&amp;originHeight=188&amp;originWidth=1012&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=17286&amp;status=done&amp;style=none&amp;taskId=u6965dea2-70dc-43e4-9998-b539b6db3ad&amp;title=&amp;width=809.6" alt="image.png"></p><h1>敏捷过程：</h1><h1><a href="https://zhuanlan.zhihu.com/p/37815239">实施敏捷开发，看这一篇就够了</a></h1><p><a href="https://www.cnblogs.com/jiftle/p/14005715.html#:~:text=%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%B3%95%E9%80%82%E5%90%88%E5%AF%B9,%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%9C%BA%E6%99%AF%E3%80%82">《敏捷开发培训考试》考试题目及答案 - jiftle - 博客园</a><br><strong>迭代计划会议：</strong><a href="https://zhuanlan.zhihu.com/p/405527208#:~:text=%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E8%AE%A1%E5%88%92%E4%BC%9A%E8%AE%AE%EF%BC%9F%20Sprint%E8%AE%A1%E5%88%92%E4%BC%9A%E8%AE%AE%E6%98%AF%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E7%9A%84%E4%BC%9A%E8%AE%AE%E4%B9%8B%E4%B8%80%EF%BC%8C%E5%9C%A8%E6%AF%8F%E4%B8%AA%E8%BF%AD%E4%BB%A3%E5%91%A8%E6%9C%9F%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D%E5%8F%AC%E5%BC%80%E3%80%82,%E7%9B%AE%E7%9A%84%E6%98%AF%E4%B8%BA%E4%BA%86%E5%88%B6%E5%AE%9A%E5%BD%93%E5%89%8D%E8%BF%AD%E4%BB%A3%E5%91%A8%E6%9C%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%9B%AE%E6%A0%87%E4%BB%A5%E5%8F%8A%E9%9C%80%E8%A6%81%E5%AE%8C%E6%88%90%E7%9A%84%E5%B7%A5%E4%BD%9C%E3%80%82%20%E4%B8%BE%E5%8A%9E%20Sprint%E8%AE%A1%E5%88%92%E4%BC%9A%E8%AE%AE%EF%BC%8C%E6%98%AF%E4%B8%BA%E4%BA%86%E8%AE%A9%E5%9B%A2%E9%98%9F%E8%8E%B7%E5%BE%97%E8%B6%B3%E5%A4%9F%E7%9A%84%E4%BF%A1%E6%81%AF%EF%BC%8C%E8%83%BD%E5%A4%9F%E5%9C%A8%E5%87%A0%E4%B8%AA%E6%98%9F%E6%9C%9F%E5%86%85%E4%B8%8D%E5%8F%97%E5%B9%B2%E6%89%B0%E5%9C%B0%E5%B7%A5%E4%BD%9C%E3%80%82">Scrum敏捷管理之”迭代计划会“</a><br><strong>迭代回顾：</strong> 迭代回顾会议是Scrum五个仪式之一，是在迭代评审会议之后对本次迭代的优点与改进点进行复盘的一个活动，其最主要的目的是提升团队的整体能力，持续改进，形成一个自学习的团队。. 通过回顾会议可以使团队每个迭代都能比上个迭代做得更好。. 在很多敏捷团队中，最容易忽略该活动，很多团队没有意识到该活动的重要性。. 为什么呢？. 最主要的原因是开了会议，没有实际效果，大家认为没用，所以也就不开了。. 实践中，在开迭代回顾会议时常犯的错误有：. 把回顾会议开成了吐槽大会，大家只提意见，不提改进措施；.<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686539298682-a4a874fc-4060-4500-a572-17ba29730846.png#averageHue=%23f7f5f4&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=157&amp;id=ue8a1fd34&amp;originHeight=196&amp;originWidth=508&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=14680&amp;status=done&amp;style=none&amp;taskId=u7f8e5852-4d54-4199-8a76-82a06c39c53&amp;title=&amp;width=406.4" alt="image.png"><br>一般来说，迭代回顾会议可以持续1到2小时，以确保充分的讨论和反馈，但也不会过于耗费时间和资源。在会议开始前，团队成员应该准备好相关的数据和材料，如迭代进度报告、测试报告、客户反馈等，以便在会议中进行讨论和分析。<br><strong>燃尽图：</strong><a href="https://zhuanlan.zhihu.com/p/258744550#:~:text=%E4%BB%80%E4%B9%88%E6%98%AF%E7%87%83%E5%B0%BD%E5%9B%BE.%20%E7%87%83%E5%B0%BD%E5%9B%BE%EF%BC%88burn%20down%20chart%EF%BC%89%E6%98%AF%E5%9C%A8%E9%A1%B9%E7%9B%AE%E5%AE%8C%E6%88%90%E4%B9%8B%E5%89%8D%EF%BC%8C%E5%AF%B9%E9%9C%80%E8%A6%81%E5%AE%8C%E6%88%90%E7%9A%84%E5%B7%A5%E4%BD%9C%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%B8%80%E7%A7%8D%E5%8F%AF%E8%A7%86%E5%8C%96%E8%A1%A8%E7%A4%BA%E3%80%82.%20%E7%90%86%E6%83%B3%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E8%AF%A5%E5%9B%BE%E8%A1%A8%E6%98%AF%E4%B8%80%E4%B8%AA%E5%90%91%E4%B8%8B%E7%9A%84%E6%9B%B2%E7%BA%BF%EF%BC%8C%E9%9A%8F%E7%9D%80%E9%A1%B9%E7%9B%AE%E4%BB%BB%E5%8A%A1%E7%9A%84%E9%80%90%E6%B8%90%E5%AE%8C%E6%88%90%E2%80%9C%E7%83%A7%E5%B0%BD%E2%80%9D%E8%87%B3%E9%9B%B6%E3%80%82.,%E7%87%83%E5%B0%BD%E5%9B%BE%E5%B8%B8%E5%B8%B8%E7%94%A8%E4%BA%8E%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E4%BD%9C%E4%B8%BA%E9%A1%B9%E7%9B%AE%E8%BF%9B%E5%B1%95%E7%9A%84%E4%B8%80%E4%B8%AA%E6%8C%87%E7%A4%BA%E5%99%A8%E3%80%82.%20%E5%A6%82%E4%BD%95%E8%A7%A3%E8%AF%BB%E7%87%83%E5%B0%BD%E5%9B%BE.%20%E7%87%83%E5%B0%BD%E5%9B%BE%E6%98%AF%E4%B8%80%E4%B8%AA%E5%9D%90%E6%A0%87%E5%9B%BE%E3%80%82.%20%E5%91%88%E7%8E%B0%E7%9A%84%E6%98%AF%E9%9A%8F%E7%9D%80%E6%97%B6%E9%97%B4%E6%8E%A8%E7%A7%BB%E8%80%8C%E5%89%A9%E4%BD%99%E7%9A%84%E5%B7%A5%E4%BD%9C%E9%87%8F%E3%80%82.%20%E7%87%83%E5%B0%BD%E5%9B%BE%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%9A.%20%E6%A8%AA%E5%9D%90%E6%A0%87%EF%BC%9Asprint%E7%9A%84%E5%B7%A5%E6%9C%9F%EF%BC%88%E4%BB%A5%E5%A4%A9%E8%AE%A1%E7%AE%97%EF%BC%89%E3%80%82.">教你如何用燃尽图做项目管理</a><br><strong>DOD和DOR是什么：</strong><a href="https://blog.csdn.net/LigaAI/article/details/126042526">敏捷开发中的 DoD 和 DoR 是什么？_dod 敏捷_LigaAI的博客-CSDN博客</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686540489194-4617848d-4a61-4dbb-956a-e68a0bb9ccb5.png#averageHue=%23f9f7f6&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=143&amp;id=ube36f8a0&amp;originHeight=179&amp;originWidth=344&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=8620&amp;status=done&amp;style=none&amp;taskId=u8d2a894c-4599-45d0-b096-7eaad560759&amp;title=&amp;width=275.2" alt="image.png">投产文档是软件工程中的一种文档，也称为发布文档、上线文档或部署文档。它是在软件开发过程中最后一个阶段的重要产物，通常是由项目经理、开发团队和运维团队联合编写的。投产文档记录了软件系统的部署、测试、验证和上线等过程中的各种信息和细节，以确保系统能够在生产环境中稳定运行。而DOD是是需求准出的标准表示的是需求，而投产文档是整个步骤完成后要完成的<br>**PSPI:**在敏捷开发中，潜在可交付的产品增量（Potentially Shippable Product Increment，PSPI）指的是在当前迭代周期结束时，团队完成的一个可用、可测试、可部署、可交付的软件产品版本。它是在迭代周期内完成的所有工作成果的集合，包括新功能、增强功能和修复问题等。PSPI是一个完整的、可用的、可交付的软件产品版本，可以交付给客户或者用于生产环境。<br><strong>敏捷开发</strong>法是一种以团队为核心的、迭代式、自下而上的开发方法，与自顶向下的传统开发方法有所不同。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686538236683-abf20531-e1bf-406b-a155-dd7d6fcdab90.png#averageHue=%23fefefe&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=202&amp;id=u7a42e314&amp;originHeight=253&amp;originWidth=1102&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=18249&amp;status=done&amp;style=none&amp;taskId=u1c489adb-b463-4f1d-880b-1295a977b87&amp;title=&amp;width=881.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686539631766-3c21a2e4-fd79-4439-bda7-a88955418a84.png#averageHue=%23f7f5f4&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=153&amp;id=u5f3a55bf&amp;originHeight=191&amp;originWidth=563&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=15390&amp;status=done&amp;style=none&amp;taskId=u3490744d-ba26-4be7-a362-b3d7dcbca84&amp;title=&amp;width=450.4" alt="image.png"><br>目前存在两种形式的燃尽图，Sprint燃尽图用于显示迭代中的剩余工作量，而产品燃尽图则用于说明整个项目的剩余工作量。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686541330291-059fc930-9d8f-44b3-86f2-f1186d62d224.png#averageHue=%23f8f7f6&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=155&amp;id=u7266ee75&amp;originHeight=194&amp;originWidth=386&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=10104&amp;status=done&amp;style=none&amp;taskId=ue85dd581-5822-4f88-bce9-baf3c05d801&amp;title=&amp;width=308.8" alt="image.png">用户故事（User Story）是敏捷开发中的一种需求描述方式，它描述了用户或利益相关者在使用软件系统时所需要完成的具体任务、目标或需求。用户故事通常由简短的、自然语言的语句组成，用于概括一个或多个特定的用户场景。通常，用户故事通过格式化的语句来描述，例如：<br>&quot;As a [角色], I want to [行动], so that [目标]&quot;在敏捷开发中，用户故事通常由客户或利益相关者提出，并与开发团队共同制定和明确。客户和利益相关者通常是最了解系统使用场景和需求的人，他们可以通过用户故事的方式清晰地描述和传达自己的需求和期望，帮助开发团队更好地理解和满足用户需求。<br>客户和利益相关者通常会参与到敏捷开发的迭代过程中，与开发团队一起讨论和优化用户故事，以确保开发团队理解和满足用户需求。这种协作和沟通方式可以帮助团队更好地把握用户需求和期望，以便更好地设计和开发软件产品。<br>除了客户和利益相关者，开发团队中的其他成员，如产品经理、业务分析师、开发人员等，也可以参与制定用户故事。他们可以提出自己的想法和建议，帮助团队更好地理解和实现用户需求，从而提高软件产品的质量和用户体验。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686541486304-55296cf7-a376-48c8-9527-a2aa62414d12.png#averageHue=%23f8f6f5&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=163&amp;id=u6b064a32&amp;originHeight=204&amp;originWidth=393&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=11371&amp;status=done&amp;style=none&amp;taskId=u4bdb4d40-a0f6-431a-a314-e4636caf9c9&amp;title=&amp;width=314.4" alt="image.png"><br>D选项：有估算的。Product Backlog中的需求应该根据其复杂度、工作量和资源等因素进行估算，并根据其估算结果进行排序和开发。因此，有估算的特点是Product Backlog应该具备的。<br>Product Backlog（产品待办列表）是敏捷开发中的一种需求管理工具，它是一个优先级排序的需求列表，其中包含了所有的产品需求、特性和用户故事等，以及与之相关的任务、缺陷和技术债务等。<br>Product Backlog由产品负责人（Product Owner）维护，并根据需求的优先级和价值进行排序和管理。产品负责人通常会与客户和利益相关者紧密合作，收集和明确需求，并根据需求的重要性和价值，将其添加到Product Backlog中。<br>Product Backlog中的每个需求通常都包含以下信息：</p><ol><li>描述：对需求进行简要描述，例如需求的名称、特性等。</li><li>价值：对需求的重要性和价值进行评估，并根据其价值进行排序。</li><li>优先级：对需求的优先级进行评估，并根据其优先级进行排序。</li><li>状态：对需求的状态进行跟踪，例如已完成、正在进行中、待办等。</li><li>验收标准：对需求的验收标准进行定义，以便在需求完成后进行验收。</li></ol><p>Product Backlog是敏捷开发中的一个重要工具，它可以帮助团队更好地管理和追踪需求，以便更好地满足客户需求和市场变化。团队通常会定期审查和优化Product Backlog，以保持其与产品需求的一致性和实时性。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686541853956-47638bcf-1b9a-4d3f-8152-7bf890be476b.png#averageHue=%23f9f8f7&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=101&amp;id=u0fd8d089&amp;originHeight=126&amp;originWidth=411&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=6019&amp;status=done&amp;style=none&amp;taskId=uae3e5f04-2348-4f5a-8c02-56cc38d7b71&amp;title=&amp;width=328.8" alt="image.png"><br>敏捷开发团队通常由5至9人组成。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686541957388-d50be0f9-56b5-4380-aec0-a11786a9d319.png#averageHue=%23f9f8f7&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=94&amp;id=u46a9d4d5&amp;originHeight=117&amp;originWidth=774&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=8630&amp;status=done&amp;style=none&amp;taskId=u44243042-581d-4c09-ba1a-a10f0e9b948&amp;title=&amp;width=619.2" alt="image.png"><br>错误。虽然敏捷开发可以提高团队的灵活性和响应变化的能力，但是对于极高的关键性、可靠性、安全性要求的项目，敏捷开发不一定是最适合的开发方法。这类项目通常需要更多的计划、设计、测试和验证工作，以确保系统的稳定性、可靠性和安全性，而这些工作在敏捷开发中可能会被忽略或减少。<br>相反，传统的瀑布模型（Waterfall Model）可能更适合这类项目。瀑布模型强调计划、设计、测试和验证等阶段的顺序性和严格性，可以确保系统的稳定性、可靠性和安全性，并在项目初期进行详细的规划和设计，以避免后期的问题和风险。<br>当然，对于某些具有极高可变性的项目，例如创新型项目，敏捷开发可能是更为适合的方法。在这种情况下，敏捷开发可以帮助团队更快地响应变化和市场需求，从而提高创新和竞争力。</p><h1>软件需求</h1><p>软件需求指用户对目标系统在功能、性能等方面的期望;主要有:功能需求、性能需求、可靠性需求、可用性需求、出错处理需求、接口需求等</p><h4 id="软件需求3层次：">软件需求3层次：</h4><p>软件需求的三个层次:<br><strong>业务需求</strong>：业务需求(business requirement)反映了组织机构或客户对系统、产品高层次的目标要求<br>业务需求从总体上描述了为什么要开发系统（why），组织希望达到什么目标。<br>一般使用前景和范围（vision and scope）文档来记录业务需求，称作项目轮廓图或市场需求文档。<br>这些最高级别的需求数量很少（2－5条）<br>**用户需求：**用户需求(user requirement)描述了用户使用产品必须要完成的任务。<br>用例、场景描述和事件―响应表都是表达用户需求的有效途径。<br>在问题定义的基础上进行用户访谈、调查，对用户使用的场景进行整理，从而建立用户角度的需求。<br>描述了用户能使用系统来做些什么（what）。<br>**功能需求：**系统分析员描述 开发人员在产品中实现的软件功能，用户利用这些功能来完成任务，满足业务需求。<br>功能需求是需求的主体，它描述的是开发人员如何设计具体的解决方案来实现这些用户需求（how），其数量往往比用户需求高一个数量级。 <br>这些需求记录在软件需求规格说明SRS（Software Requirments Specification）中。</p><h4 id="软件需求的分类">软件需求的分类</h4><p>**功能需求：**描述系统预期提供的功能或服务<br>系统应提供的服务<br>系统如何对输入做出反应<br>系统在特定条件下的行为<br>系统不应该做什么<br><strong>非功能需求</strong>：不直接与系统具体功能相关的需求。<br>产品需求：产品行为的需求，包括性能需求、可靠性需求和可用性需求等。<br>机构需求：客户和开发者所在机构中的政策和规定要求，如过程标准、实现要求、交付需求。<br>外部需求：所有的系统外部因素要求，如互操作需求</p><h4 id="需求工程：">需求工程：</h4><p>应用已证实有效的技术、方法进行需求分析，确定客户需求，帮助分析人员理解问题并定义目标系统的所有外部特征的一门学科。<br>它通过合适的工具和记号系统地描述待开发系统及其行为特征和相关约束，形成需求文档，并对用户不断变化的需求演进给予支持。</p><h4 id="需求分析的基本活动：">需求分析的基本活动：</h4><p>起始—询问一系列问题，以确立：<br>对问题的基本理解<br>谁需要解决方案<br>所期望解决方案的性质<br>导出—从所有利益相关者（ stakeholders）处获取需求（需求获取）<br>精化—创建一个分析模型，定义问题的信息域、功能域和行为域 （需求建模）<br>协商—通过协商过程来调解客户提出的过高的目标要求和相互冲突的需求<br><strong>规格说明</strong>—需求分析师的工作产品，为以下一种或几种:写好的文档、图形化的模型、形式化的数学模型、一组用户场景（用例）、原型<br>两种需求文档<br>需求定义：客户要求的完整列表<br>通常由客户和需求分析师一起编写，是开发人员对系统功能的一个合同，主要给客户阅读<br>需求规格说明：要构建系统的规格化说明<br>由需求分析师编写，并由其他软件开发人员使用<br><strong>确认（需求验证）—通过评审机制，寻找</strong>：<br>内容或解释上的差错<br>可能需要进一步澄清的地方<br>丢失的信息<br>不一致 (开发大型系统时的主要问题)<br>冲突或不现实的需求<br><strong>需求管理</strong><br>在项目执行过程中标识、控制和跟踪需求以及变更需求<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686457764762-77116d6e-3b9d-426f-8be4-35c3189f499c.png#averageHue=%23e6e5e4&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=418&amp;id=u56f7035b&amp;originHeight=522&amp;originWidth=907&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=174007&amp;status=done&amp;style=none&amp;taskId=u552e462a-dadf-4f43-9089-f13f8fabfc2&amp;title=&amp;width=725.6" alt="image.png"></p><h4 id="获取需求的技术：">获取需求的技术：</h4><p>**面谈：**面对面交流是理解业务功能和规则的最有效方法<br>该方法比较耗时和资源<br>项目组成员与单个用户或用户组举行会议<br>面谈步骤：<br>阅读背景资料<br>确定面谈目标<br>决定面谈对象<br>和面谈对象沟通。<br>整理面谈报告.<br>非正式面谈和正式面谈<br>**调查技术：**向客户组织的相关人员发放调查表<br>关键：确定调查内容<br>非正式会谈<br>制定调查表<br>组织调查<br>使用场合：<br>系统相关者较多<br>地理上分布广<br>**观察实际业务过程：**观察并记录业务流程<br>同用户进行交谈。<br>观察：有效收集信息的另一种方法<br>方式：直接在用户工作的地方观察他们的日常活动并记录下观察到的业务操作过程<br>观察方法<br>对办公室进行快速浏览<br>安排一定的时间观察用户的工作过程<br>同用户一道亲身实践体会工作过程<br>使用工作流图来进行记录<br>工作流 – 处理商业事务或客户请求的一系列步骤<br>工作流图：流程图、数据流图、活动图<br>**原型法：**软件原型是一种软件系统的局部实现技术，可以帮助软件开发人员、用户和客户更好地理解软件需求。<br>使用原型的主要目的：<br>明确并完善需求<br>探索设计选择方案<br>发展为最终的产品原型<br>**基于场景的需求捕获方法：**也称为情景实例的分析方法<br>基于对应用环境的某一特定情景的描述来阐述用户的需求<br>从场景的结构化描述中抽取活动图、场景、角色、数据关系图等，从而形成需求模型。<br>**竞争性需求分析法：**1) N (Need 需求)<br>   你的创意解决了用户的什么需求?  <br>2) A (Approach 做法)<br>你有什么招数, 特别是独特的招数, 来解决用户的痛苦。 <br>3) B (Benefit  好处)<br>   那你这个产品用户带来什么好处呢?<br>4) C (Competitors 竞争)<br>与竞争对手相比你有什么优势?<br>5) D (Delivery)<br>你怎么让目标用户都知道你的产品? 并且让产品的用户量快速提高?</p><h4 id="需求建模方法：">需求建模方法：</h4><p><strong>结构化分析</strong><br>考虑数据和处理的分析建模方法<br>数据作为独立实体转换<br>数据对象定义了对象的属性和关系<br>处理表明数据对象在系统内流动时的数据转换<br><strong>面向对象分析</strong><br>定义类和类之间的协作方式</p><h4 id="结构化分析方法-技术：">结构化分析方法-技术：</h4><p><a href="https://www.zhihu.com/tardis/zm/art/389748904?source_id=1003">如何掌握结构化的分析方法？</a></p><h4 id="数据流图：">数据流图：</h4><p><a href="https://blog.csdn.net/qq_50977450/article/details/121802790">软件工程：数据流图，数据字典的画法，以及如何转化为软件结构图_数据字典怎么画_Brother汤的博客-CSDN博客</a><br><a href="https://blog.csdn.net/Erin_jwx/article/details/121685204">【软件工程】根据数据流图导出程序结构_数据流图转换为软件结构图_AC它真的很香的博客-CSDN博客</a><br><a href="https://blog.csdn.net/shulianghan/article/details/109271777">【软件工程】数据流图 ( 数据流图简介 | 数据流图概念 | 数据流 | 加工 | 数据存储 | 外部实体 | 数据流图分层 | 顶层数据流图 | 中层数据流图 | 底层数据流图 )_韩曙亮的博客-CSDN博客</a><br><strong>数据字典：<strong>数字字典是指一个用来存储和管理数据元素定义和描述信息的集合，它包括了系统中使用到的所有数据元素、数据结构、数据类型、数据格式、数据值域等信息。数字字典通常用于帮助软件开发人员在系统分析、设计和开发中更好地理解和管理数据元素。其基本功能是数据定义。<br>找到变换中心是数据流图导出结构图的关键，一般将数据流划分为交换流和事务流。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686549571777-b09c11ba-4ea8-49d4-96f1-487fab4fff0c.png#averageHue=%23fefefe&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=265&amp;id=ud93c7aa1&amp;originHeight=331&amp;originWidth=837&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=17762&amp;status=done&amp;style=none&amp;taskId=u1f677d85-a4f9-4a0b-a7bb-b099cba043c&amp;title=&amp;width=669.6" alt="image.png"><br>结构化分析常用工具：数据流图（DFD），数据字典（DD），判定表，判定树。<br>详细设计阶段常用的工具：程序流程图，N-S图，PAD图，HIP0图。 而需求分析主要是完成总体设计，是结构化分析，需求分析建模是采用结构化分析建模。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686551978053-c8a2111d-f355-45c3-981d-34eed55b29e1.png#averageHue=%23fefefe&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=308&amp;id=u8f734e0a&amp;originHeight=385&amp;originWidth=822&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=17756&amp;status=done&amp;style=none&amp;taskId=u8b97d9cd-3a87-44a1-81a9-b3f7022c08a&amp;title=&amp;width=657.6" alt="image.png"><br>是的，数据流图和数据字典通常被视为系统的逻辑模型的两个主要组成部分。<br>数据流图（Data Flow Diagram，简称DFD）是一种图形化工具，用于描述系统中数据的流动和处理过程。它通过图形符号表示系统中的各种处理过程、数据存储、数据流动和外部实体，形成一个数据流图，用于描述系统的功能和行为。数据流图通常用于识别和定义系统的功能需求、系统流程和数据流动的过程。<br>数据字典（Data Dictionary）是系统中使用的各种数据和信息的集合，包括数据类型、数据格式、数据来源和数据用途等。它用于描述系统中各种数据和信息的定义和用途，从而为系统的设计、开发和测试提供指导和依据。数据字典通常包括数据元素的名称、描述、数据类型、数据长度、数据格式、取值范围等信息。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686552334790-097be0fe-2d23-4e89-950f-d1c771b33c9f.png#averageHue=%23fefefd&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=266&amp;id=ubf99bc76&amp;originHeight=333&amp;originWidth=820&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=19044&amp;status=done&amp;style=none&amp;taskId=u39b31468-86b6-4368-9b34-ddf4e2ce0f4&amp;title=&amp;width=656" alt="image.png"><br>如果在数据流图中出现控制流，将会导致数据流图的复杂度增加，难以理解和维护。此外，过多的控制流可能也会使数据流图变得冗长和混乱，影响对系统的理解和描述。<br>因此，数据流图不允许出现控制流，它应该专注于描述系统中的数据流动和处理过程，从而更好地识别和定义系统的功能需求和功能间的关系。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686552393227-e8ef41d3-01d6-4cab-a63f-d895f101518a.png#averageHue=%23fefefe&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=286&amp;id=u5c97a8f0&amp;originHeight=357&amp;originWidth=1138&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=26325&amp;status=done&amp;style=none&amp;taskId=u826f6d27-19e2-459b-ac50-5223aa40687&amp;title=&amp;width=910.4" alt="image.png"><br>需求规格说明书不包括软件的可行性研究的依据</strong>需求分析</strong>：系统必须做什么？定义时期最后一个阶段，产生软件需求规格说明书。可行性研究是在其上一个步骤<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686552681986-c594759e-7b46-4ddc-90c4-d9cc1c51ed6f.png#averageHue=%23fefefd&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=249&amp;id=u01abc19a&amp;originHeight=311&amp;originWidth=1101&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=25436&amp;status=done&amp;style=none&amp;taskId=ucbe8b250-5486-47f8-bb37-8ff7b3b683b&amp;title=&amp;width=880.8" alt="image.png"><br>软件需求分析阶段的主要工作包括四个方面：<strong>需求获取、需求分析、编写需求规格说明书和需求评审</strong><a href="https://www.bing.com/ck/a?!&amp;&amp;p=2221036aeb1ef788JmltdHM9MTY4NjQ0MTYwMCZpZ3VpZD0wZDhmZWU2OS01NWY5LTZhMzUtMTYyMi1mY2IwNTRiYzZiZWYmaW5zaWQ9NTQ4MA&amp;ptn=3&amp;hsh=3&amp;fclid=0d8fee69-55f9-6a35-1622-fcb054bc6bef&amp;u=a1aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3F1ZXN0aW9uVGVybWluYWwvNDg3NzEyMTY1MTM0NGMyYmIxNGE0ZWY2YjVjMmVhMjg_dG9Db21tZW50SWQ9OTcwMQ&amp;ntb=1">1</a><a href="https://www.bing.com/ck/a?!&amp;&amp;p=eb950947559c9644JmltdHM9MTY4NjQ0MTYwMCZpZ3VpZD0wZDhmZWU2OS01NWY5LTZhMzUtMTYyMi1mY2IwNTRiYzZiZWYmaW5zaWQ9NTQ4MQ&amp;ptn=3&amp;hsh=3&amp;fclid=0d8fee69-55f9-6a35-1622-fcb054bc6bef&amp;u=a1aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTgyODIzL2FydGljbGUvZGV0YWlscy8xMTEzODcxMDY&amp;ntb=1">2</a><a href="https://www.bing.com/ck/a?!&amp;&amp;p=1f44ead18f68f380JmltdHM9MTY4NjQ0MTYwMCZpZ3VpZD0wZDhmZWU2OS01NWY5LTZhMzUtMTYyMi1mY2IwNTRiYzZiZWYmaW5zaWQ9NTQ4Mg&amp;ptn=3&amp;hsh=3&amp;fclid=0d8fee69-55f9-6a35-1622-fcb054bc6bef&amp;u=a1aHR0cHM6Ly93d3cueWluZ3Bvcy5jb20vc2hlbmdodW9iYWlrZS9LbDhXRG45M1laQjFkYXkuaHRtbA&amp;ntb=1">3</a><a href="https://www.bing.com/ck/a?!&amp;&amp;p=ffeb755af5395b61JmltdHM9MTY4NjQ0MTYwMCZpZ3VpZD0wZDhmZWU2OS01NWY5LTZhMzUtMTYyMi1mY2IwNTRiYzZiZWYmaW5zaWQ9NTQ4Mw&amp;ptn=3&amp;hsh=3&amp;fclid=0d8fee69-55f9-6a35-1622-fcb054bc6bef&amp;u=a1aHR0cHM6Ly9lYXN5bGVhcm4uYmFpZHUuY29tL2VkdS1wYWdlL3RpYW5nb25nL3F1ZXN0aW9uZGV0YWlsP2lkPTE3MzAwMDI4OTQ3MzAxNzE1NTI&amp;ntb=1">4</a><a href="https://www.bing.com/ck/a?!&amp;&amp;p=cb6ca98731c722a8JmltdHM9MTY4NjQ0MTYwMCZpZ3VpZD0wZDhmZWU2OS01NWY5LTZhMzUtMTYyMi1mY2IwNTRiYzZiZWYmaW5zaWQ9NTQ4NA&amp;ptn=3&amp;hsh=3&amp;fclid=0d8fee69-55f9-6a35-1622-fcb054bc6bef&amp;u=a1aHR0cHM6Ly96aGlkYW8uYmFpZHUuY29tL3F1ZXN0aW9uLzI4NDI0OTM5OC5odG1s&amp;ntb=1">5</a>。需求获取是通过与用户接触初步确定系统的功能；需求分析的任务是确定系统必须完成哪些工作，提出完整、准确、清晰、具体的要求；在需求分析阶段结束之前，系统分析员应该编写需求规格说明书；需求评审是根据需求规格说明书来严格审查和验证需求分析的结果<a href="https://www.bing.com/ck/a?!&amp;&amp;p=8a0b79d9bf07db70JmltdHM9MTY4NjQ0MTYwMCZpZ3VpZD0wZDhmZWU2OS01NWY5LTZhMzUtMTYyMi1mY2IwNTRiYzZiZWYmaW5zaWQ9NTQ4NQ&amp;ptn=3&amp;hsh=3&amp;fclid=0d8fee69-55f9-6a35-1622-fcb054bc6bef&amp;u=a1aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3F1ZXN0aW9uVGVybWluYWwvNDg3NzEyMTY1MTM0NGMyYmIxNGE0ZWY2YjVjMmVhMjg_dG9Db21tZW50SWQ9OTcwMQ&amp;ntb=1">1</a>。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686552864351-d5b01c1b-e496-48d4-b9bc-8f7298761c09.png#averageHue=%23fefefd&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=328&amp;id=uc63bd510&amp;originHeight=410&amp;originWidth=1106&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=32259&amp;status=done&amp;style=none&amp;taskId=u6458aabe-8189-42bd-8d76-5b80fc185b9&amp;title=&amp;width=884.8" alt="image.png"><br><strong>数据字典中什么是加工条目：</strong>，加工条目（Processing Entry）是指描述系统中某个数据项的加工过程或转换过程的数据元素。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686563702757-e3ace121-f3eb-4d47-b0ad-b11bf0e5fa1b.png#averageHue=%23fefdfd&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=244&amp;id=u54659413&amp;originHeight=305&amp;originWidth=1091&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=26072&amp;status=done&amp;style=none&amp;taskId=ufb7f1eb4-c95b-4952-a686-2618a7cadbb&amp;title=&amp;width=872.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686563900613-d0c11afc-001a-454c-8215-59087b3c074e.png#averageHue=%23fdfdfc&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=228&amp;id=uaab46eac&amp;originHeight=285&amp;originWidth=960&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=27346&amp;status=done&amp;style=none&amp;taskId=u485d6e82-8bc5-4e4c-a20c-068b0990cba&amp;title=&amp;width=768" alt="image.png"><br><a href="https://blog.csdn.net/I_r_o_n_M_a_n/article/details/121309525">软件工程 – 数据流图的画法_CodeJiao的博客-CSDN博客</a></p><h4 id="数据流转化为软件体系结构：">数据流转化为软件体系结构：</h4><p><a href="https://blog.csdn.net/lipeijie163/article/details/109703886">软件工程——软件结构图设计（变换分析设计、事务分析设计、混合流设计）_Rucooo的博客-CSDN博客</a></p><h4 id="模块独立：">模块独立：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686618575144-06ecac9e-fa31-4a9a-bfef-076db713306e.png#averageHue=%23fefefe&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=302&amp;id=ub0e4d45d&amp;originHeight=378&amp;originWidth=1102&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=19658&amp;status=done&amp;style=none&amp;taskId=u459cd818-8eae-48c5-be4b-6bb77f59de2&amp;title=&amp;width=881.6" alt="image.png"><br><a href="https://www.cnblogs.com/1002-/p/14643746.html#:~:text=%E7%AD%94%EF%BC%9A%20%E8%BD%AF%E4%BB%B6%E7%BB%93%E6%9E%84%E5%9B%BE%E7%9A%84%E5%BD%A2%E6%80%81%E7%89%B9%E5%BE%81%EF%BC%9A%20%E2%91%A0%E6%B7%B1%E5%BA%A6%EF%BC%9A%E7%BB%93%E6%9E%84%E5%9B%BE%E6%8E%A7%E5%88%B6%E7%9A%84%E5%B1%82%E6%AC%A1%EF%BC%8C%E5%8D%B3%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B1%82%E6%95%B0%E3%80%82,%E2%91%A1%E5%AE%BD%E5%BA%A6%EF%BC%9A%E4%B8%80%E5%B1%82%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E6%A8%A1%E5%9D%97%E4%B8%AA%E6%95%B0%E3%80%82%20%E2%91%A2%E6%89%87%E5%87%BA%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E7%9B%B4%E6%8E%A5%E4%B8%8B%E5%B1%9E%E6%A8%A1%E5%9D%97%E7%9A%84%E4%B8%AA%E6%95%B0%E3%80%82%20%E2%91%A3%E6%89%87%E5%85%A5%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E7%9B%B4%E6%8E%A5%E4%B8%8A%E5%B1%9E%E6%A8%A1%E5%9D%97%E7%9A%84%E4%B8%AA%E6%95%B0%E3%80%82">地信1902李孟雪 第八章思考题 - lmxshelly - 博客园</a><br><a href="https://blog.csdn.net/pikalavender/article/details/102601298">模块独立性_pikalavender的博客-CSDN博客</a></p><h4 id="设计规格说明书：">设计规格说明书：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686618933569-ab00e323-20be-417a-b653-0b95148c179d.png#averageHue=%23fefefe&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=282&amp;id=u4ae3e287&amp;originHeight=352&amp;originWidth=1090&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=18849&amp;status=done&amp;style=none&amp;taskId=u6813e5a7-ccfc-47f4-a077-69b7b515e56&amp;title=&amp;width=872" alt="image.png"><br><a href="https://blog.csdn.net/weiwenhuaming_/article/details/112559628">软件需求规格说明书，概要设计说明书，详细设计说明书（文档）_各自软件系统的需求规格说明书、概要设计以及详细设计。_caiqingheng的博客-CSDN博客</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686619137666-7116228a-4311-427a-86c6-7c71587c83fb.png#averageHue=%23fefefe&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=279&amp;id=u4e80bb11&amp;originHeight=349&amp;originWidth=1075&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=22125&amp;status=done&amp;style=none&amp;taskId=u50b6d64d-de59-4119-8758-638b8fba61e&amp;title=&amp;width=860" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686619211230-3421b178-5e75-453d-9f32-14f21e0088b7.png#averageHue=%23fefefe&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=273&amp;id=ub3fe2739&amp;originHeight=341&amp;originWidth=1108&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=21478&amp;status=done&amp;style=none&amp;taskId=u143e98b3-2a03-44d4-90cb-1de00b0120a&amp;title=&amp;width=886.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686619234158-b1d55f0a-6f1a-4543-80f6-9e1810727f4e.png#averageHue=%23fefefe&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=262&amp;id=u7a7243b9&amp;originHeight=328&amp;originWidth=1088&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=23507&amp;status=done&amp;style=none&amp;taskId=u63b1dd45-1d44-4932-b44d-2007c35a0b0&amp;title=&amp;width=870.4" alt="image.png"><br><a href="https://blog.csdn.net/jerry11112/article/details/79180171">【软件工程】 软件设计阶段_光哥_帅的博客-CSDN博客</a>软件设计阶段分为总体设计和详细设计，总体设计是结构设计：（确定软件系统的整体结构和组成方式，包括模块划分、模块之间的关系和接口等。)和模块过程设计（模块的具体实现）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686633566619-abeef38f-c8f1-4c82-866d-ccb591261967.png#averageHue=%23fefefe&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=248&amp;id=uc1becde7&amp;originHeight=310&amp;originWidth=759&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=17369&amp;status=done&amp;style=none&amp;taskId=u61721e2c-3f30-499c-8bc4-942b66db3b1&amp;title=&amp;width=607.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686633773954-1cb65e21-5215-4541-8b8f-9c008a91c68e.png#averageHue=%23fefefd&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=259&amp;id=ua7eeab71&amp;originHeight=324&amp;originWidth=999&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=23277&amp;status=done&amp;style=none&amp;taskId=u95ef2090-eb95-4a58-a944-b3055b0470b&amp;title=&amp;width=799.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686633960092-403a6d6b-2021-4417-a3a9-d0a13dc6ab9c.png#averageHue=%23fefefd&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=268&amp;id=ucc9ca45e&amp;originHeight=335&amp;originWidth=1094&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=23912&amp;status=done&amp;style=none&amp;taskId=ua6785c19-0f0e-4e78-bb72-0944fe8c76e&amp;title=&amp;width=875.2" alt="image.png"><br><a href="https://blog.51cto.com/u_15060513/3490901">结构化设计_51CTO博客_结构化设计的目标是</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686634089945-f7d3ef38-db3c-46a1-b037-20ef03e8c0bb.png#averageHue=%23fefefe&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=256&amp;id=uaa46df2c&amp;originHeight=320&amp;originWidth=699&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=17194&amp;status=done&amp;style=none&amp;taskId=uee881a98-3a80-4ddb-bb74-8f729df3a1d&amp;title=&amp;width=559.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686634386242-d71b8c2d-8381-49dc-9b33-d7b0021ea9b7.png#averageHue=%23fefefe&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=267&amp;id=u502437e2&amp;originHeight=334&amp;originWidth=741&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=15609&amp;status=done&amp;style=none&amp;taskId=ue9499935-5e6b-4656-88dd-ec71fbcfa76&amp;title=&amp;width=592.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686634515392-9b731269-7cb2-43f8-bab1-9b47f8968e74.png#averageHue=%23fefefe&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=283&amp;id=uef6ce70e&amp;originHeight=354&amp;originWidth=798&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=17546&amp;status=done&amp;style=none&amp;taskId=u5960706e-5542-4d26-abd1-013f0ab9a01&amp;title=&amp;width=638.4" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686473616949-cb4bf435-faa5-4b31-8bf0-211f0e084dda.png#averageHue=%23eae8e8&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=609&amp;id=ue313cdf9&amp;originHeight=761&amp;originWidth=1305&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=194651&amp;status=done&amp;style=none&amp;taskId=uc37a4559-8fde-4918-a3ac-b20a9444b9c&amp;title=&amp;width=1044" alt="image.png">Beta测试是一种软件测试方式，旨在通过让最终用户或特定用户群体使用软件产品的测试版本，以帮助开发人员收集用户反馈和识别潜在问题。Beta测试通常是软件开发周期中的最后一个测试阶段，在正式发布之前进行。<br>Beta测试通常包括以下几个步骤：</p><ol><li>选定测试用户：在Beta测试阶段，开发团队会选定一些最终用户或特定用户群体来测试软件产品的测试版本，以获得真实的用户反馈和使用情况。</li><li>发布测试版本：开发团队会将软件产品的测试版本发布给测试用户，让他们使用并提供反馈和建议。</li><li>收集用户反馈：测试用户使用测试版本后，会向开发团队提供反馈和建议，包括软件的使用体验、功能问题、性能问题等。</li><li>分析和修复问题：开发团队会分析用户反馈和测试结果，识别潜在问题并进行修复和改进。</li><li>发布正式版本：经过多次Beta测试和问题修复后，开发团队会发布正式版本的软件产品。</li></ol><p>Beta测试可以帮助开发人员在软件发布之前获得真实的用户反馈和使用情况，从而识别和修复潜在问题，提高软件的质量和用户体验。同时，Beta测试也可以建立用户与开发团队之间的沟通渠道，促进开发团队和用户之间的合作和沟通。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686474058809-31514159-14a6-4e2a-abb8-097533b525fa.png#averageHue=%23e9e7e7&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=610&amp;id=uf3429016&amp;originHeight=763&amp;originWidth=1372&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=194117&amp;status=done&amp;style=none&amp;taskId=ufcf7d794-0327-4c73-889a-454c7a56232&amp;title=&amp;width=1097.6" alt="image.png"><br><strong>条件覆盖</strong>：判定中每个条件的所有可能结果至少出现一次，但未必能覆盖全部分支<br><strong>判定条件覆盖</strong>：判定/条件覆盖是使判定中每个条件的所有可能结果至少出现一次，并且每个判定本身的所有可能结果也至少出现一次；<br><a href="https://www.cnblogs.com/jerry19880126/articles/2623433.html">条件覆盖，路径覆盖，语句覆盖，分支覆盖 - Jerry19880126 - 博客园</a></p><h4 id="软件设计阶段：">软件设计阶段：</h4><p><a href="https://blog.csdn.net/jerry11112/article/details/79180171">【软件工程】 软件设计阶段_光哥_帅的博客-CSDN博客</a><br>软件设计阶段输出的主要是设计规格说明书</p><h4 id="程序的正确性：是程序能够满足规格说明书和用户目标的程度">程序的正确性：是程序能够满足规格说明书和用户目标的程度</h4><h4 id="等价类的划分：等价类划分法-案例剖析-设计测试用例-等价类划分法举例-chde2Wang的博客-CSDN博客">等价类的划分：<a href="https://blog.csdn.net/weixin_38383877/article/details/124909626#:~:text=%E6%9C%89%E6%95%88%E7%AD%89%E4%BB%B7%E7%B1%BB%EF%BC%9A%20%E5%8F%AA%E5%AE%8C%E5%85%A8%E6%BB%A1%E8%B6%B3%E4%BA%A7%E5%93%81%E8%A7%84%E5%88%99%E8%AF%B4%E6%98%8E%E7%9A%84%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%8D%B3%E6%9C%89%E6%95%88%E7%9A%84%E3%80%81%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E9%9B%86%E5%90%88%E3%80%82%20%E5%88%A9%E7%94%A8%E6%9C%89%E6%95%88%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%8F%AF%E4%BB%A5%E6%A3%80%E9%AA%8C%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%90%A6%E6%BB%A1%E8%B6%B3%E8%A7%84%E5%88%99%E8%AF%B4%E6%98%8E%E6%89%80%E8%A7%84%E5%AE%9A%E7%9A%84%E5%8A%9F%E8%83%BD%E6%80%A7%E8%A6%81%E6%B1%82%E3%80%82,%E6%97%A0%E6%95%88%E7%AD%89%E4%BB%B7%E7%B1%BB%EF%BC%9A%20%E4%B8%8D%E6%BB%A1%E8%B6%B3%E7%A8%8B%E5%BA%8F%E8%BE%93%E5%85%A5%E8%A6%81%E6%B1%82%E6%88%96%E8%80%85%E6%97%A0%E6%95%88%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9E%84%E6%88%90%E7%9A%84%E9%9B%86%E5%90%88%E3%80%82%20%E5%88%A9%E7%94%A8%E6%97%A0%E6%95%88%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%8F%AF%E4%BB%A5%E6%A3%80%E6%B5%8B%E7%A8%8B%E5%BA%8F%E5%AF%B9%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E8%83%BD%E5%8A%9B%E3%80%82">等价类划分法-案例剖析-设计测试用例_等价类划分法举例_chde2Wang的博客-CSDN博客</a></h4><h4 id="代码审查：代码审查-Code-Review-代码审核-夕刃的博客-CSDN博客">代码审查：<a href="https://blog.csdn.net/czyying123/article/details/115585466">代码审查(Code Review)_代码审核_夕刃的博客-CSDN博客</a></h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686710551367-b9495301-ae5e-4796-9a74-61644dba51e0.png#averageHue=%23fefdfb&amp;clientId=u3a2eaed4-c828-4&amp;from=paste&amp;height=226&amp;id=ua819d004&amp;originHeight=282&amp;originWidth=629&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=23295&amp;status=done&amp;style=none&amp;taskId=u4f0328e3-62da-4b25-9b5e-958e7468d66&amp;title=&amp;width=503.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686634734519-7308ebf3-fbf6-499e-8b01-789589b63a49.png#averageHue=%23fefefe&amp;clientId=udbefbbe5-2d1f-4&amp;from=paste&amp;height=271&amp;id=u8bab60e9&amp;originHeight=339&amp;originWidth=821&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=16719&amp;status=done&amp;style=none&amp;taskId=ua6b63e6b-45f5-44b7-a2c3-446e319915b&amp;title=&amp;width=656.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686635158558-a5442631-0890-41b4-b631-4bcb0b8d5678.png#averageHue=%23fefefe&amp;clientId=u385899d5-e87f-4&amp;from=paste&amp;height=280&amp;id=ub4825c3f&amp;originHeight=350&amp;originWidth=846&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=20345&amp;status=done&amp;style=none&amp;taskId=u675040ea-7f29-45bd-aaf9-b0a998f4b8c&amp;title=&amp;width=676.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686739851791-a0c70b1e-4121-448c-95b2-655e2c808a2b.png#clientId=u3a2eaed4-c828-4&amp;from=paste&amp;height=164&amp;id=u1fa264d8&amp;originHeight=205&amp;originWidth=406&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=9769&amp;status=done&amp;style=none&amp;taskId=u1cbfba7d-d89d-4357-b079-9fbc9d3ebbf&amp;title=&amp;width=324.8" alt="image.png"></p><h4 id="功能点方法（FPA）：">功能点方法（FPA）：</h4><pre><code>  （Function Point Analysis） 功能点分析法，简称FPA，与代码行分析法是近年来最流行的两种基础软件规模估算和度量方法。是从用户角度出发度量软件规模的一种方法。它从用户的角度出发，将**系统分为数据功能和事物功能两大类（这是要依靠**信息域值），分别根据具体的规则来计算功能点，最后结合系统的特征因子来调整功能点数， 从而得到最终的系统规模。</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686635441241-e78c5f84-6c8b-4242-a920-f75d2a0c2f50.png#averageHue=%23fefefd&amp;clientId=u385899d5-e87f-4&amp;from=paste&amp;height=258&amp;id=u49f04be9&amp;originHeight=323&amp;originWidth=543&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=19561&amp;status=done&amp;style=none&amp;taskId=ue17c0ccd-2dbf-49d8-b287-abf654e4f36&amp;title=&amp;width=434.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686710447316-018fcbd4-074e-45dc-b6fc-8903aad3a658.png#averageHue=%23fefdfc&amp;clientId=u3a2eaed4-c828-4&amp;from=paste&amp;height=256&amp;id=u710982f9&amp;originHeight=320&amp;originWidth=615&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=22870&amp;status=done&amp;style=none&amp;taskId=ueeb0fa0e-7664-405e-a2d5-14f3b898407&amp;title=&amp;width=492" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686710658820-567a7a7b-094f-40f3-b58f-4b05a5f00821.png#averageHue=%23fefefd&amp;clientId=u3a2eaed4-c828-4&amp;from=paste&amp;height=242&amp;id=u1293cf65&amp;originHeight=303&amp;originWidth=817&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=18872&amp;status=done&amp;style=none&amp;taskId=u9c6bd04c-4e94-4dc6-95d0-4b2ae6bed7f&amp;title=&amp;width=653.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686710730505-71b977f3-4348-41a0-a27e-e843149aecf8.png#averageHue=%23fefefd&amp;clientId=u3a2eaed4-c828-4&amp;from=paste&amp;height=247&amp;id=u5b24152b&amp;originHeight=309&amp;originWidth=772&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=15844&amp;status=done&amp;style=none&amp;taskId=u466be684-b76e-4c20-9fec-7bce1df3763&amp;title=&amp;width=617.6" alt="image.png"><br>A. 计算机辅助静态分析是软件测试方法中的静态测试方法之一。静态测试是在代码执行之前对软件进行检查，以发现潜在的缺陷和错误。计算机辅助静态分析是使用计算机工具对软件代码进行分析，以检测潜在的缺陷和错误。这种方法可以自动化地执行许多常见的静态测试任务，例如语法检查、类型检查、代码风格检查等。因此，它可以提高软件开发的效率和质量。其他静态测试方法包括代码审查、故障模拟和需求分析等。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686710826326-20c09ba3-98a4-4cbd-ba5c-7ee756caedce.png#averageHue=%23fefefd&amp;clientId=u3a2eaed4-c828-4&amp;from=paste&amp;height=266&amp;id=u95edfa8c&amp;originHeight=333&amp;originWidth=843&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=18690&amp;status=done&amp;style=none&amp;taskId=ud0077091-89db-4ed8-9bc5-c6c4041723a&amp;title=&amp;width=674.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686710833984-b514a7f8-0002-4c76-9788-e9e5730e4a70.png#averageHue=%23ededee&amp;clientId=u3a2eaed4-c828-4&amp;from=paste&amp;height=230&amp;id=u6a8790b4&amp;originHeight=288&amp;originWidth=1092&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=148165&amp;status=done&amp;style=none&amp;taskId=u19594ae1-dc21-461e-96c1-bbab693dc03&amp;title=&amp;width=873.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686728511727-84fa4f31-25a6-4fd8-9612-2f6a0dbb393b.png#averageHue=%23f5f5f5&amp;clientId=u3a2eaed4-c828-4&amp;from=paste&amp;height=80&amp;id=u52228a7a&amp;originHeight=100&amp;originWidth=725&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=9883&amp;status=done&amp;style=none&amp;taskId=u229ba343-dfb3-44b0-a723-9e184c6032e&amp;title=&amp;width=580" alt="image.png">详细设计阶段可以利用判定树和判定表。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686728690735-7b389dc3-fc77-4b89-b3bb-e548a1e17f18.png#averageHue=%23efefef&amp;clientId=u3a2eaed4-c828-4&amp;from=paste&amp;height=87&amp;id=ucc78fef8&amp;originHeight=109&amp;originWidth=716&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=16752&amp;status=done&amp;style=none&amp;taskId=uf94b5fb1-9523-4ffc-8903-6084dd41b36&amp;title=&amp;width=572.8" alt="image.png"><br>软件重用是指在开发新软件时，利用已有的可重复使用的软件组件、模块或库，以便更快地、更经济地开发出高质量的软件。它可以降低软件开发成本、缩短开发周期、提高软件的可靠性、可维护性和可重用性。<br>具体来说，通过软件重用可以实现以下优点：</p><ol><li>提高软件开发效率：软件重用可以避免重复开发已有的功能，减少了开发时间和成本。</li><li>提高软件质量：经过多次测试和验证的可重用组件，具有高质量和稳定性，能够提高新软件的可靠性和稳定性。</li><li>提高软件可维护性：可重用的软件组件通常具有良好的文档和接口规范，易于维护和更新。</li><li>提高软件可重用性：重用软件组件可以使开发人员积累更多的经验和技能，并促进软件组件的共享和发展。</li></ol><p>因此，软件重用是降低软件成本和提高软件质量的合理方法之一<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686729006361-c491cd54-8545-4a30-87ae-de83dbffdd47.png#averageHue=%23f5f5f5&amp;clientId=u3a2eaed4-c828-4&amp;from=paste&amp;height=74&amp;id=u316440cc&amp;originHeight=92&amp;originWidth=801&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=10582&amp;status=done&amp;style=none&amp;taskId=u45f97c6d-217d-4457-ba92-eacf5efb12e&amp;title=&amp;width=640.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686729162422-2bddcd9d-3453-408e-9756-53d209e0c96a.png#averageHue=%23ededed&amp;clientId=u3a2eaed4-c828-4&amp;from=paste&amp;height=60&amp;id=u22604e80&amp;originHeight=75&amp;originWidth=813&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=13763&amp;status=done&amp;style=none&amp;taskId=ucfa16dcd-76d6-43ad-a1c9-3b539f9f576&amp;title=&amp;width=650.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1686729420936-5d622115-b97d-4eb5-a911-efa5e71fcd8e.png#averageHue=%23ececec&amp;clientId=u3a2eaed4-c828-4&amp;from=paste&amp;height=50&amp;id=u649ce2b3&amp;originHeight=63&amp;originWidth=820&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=14046&amp;status=done&amp;style=none&amp;taskId=u259ee7d7-bfae-4fe7-b033-1632597f256&amp;title=&amp;width=656" alt="image.png"><br>对的，盒图的特点是取<br>消了传统流程图中的流程线，而是使用缩进和嵌套的方式来表示程序的结构和控制流程。这种表达方式强迫程序员以结构化方式思考和解决问题，避免了不必要的跳转和分支，使程序更易于理解和维护。、</p><h4 id="McCall的质量模型">McCall的质量模型</h4><p><a href="https://blog.csdn.net/gz153016/article/details/50483417">McCall的软件质量模型_gz153016的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html"> &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h1&gt;软件及软件工程：&lt;/h1&gt;
&lt;p&gt;计算机软件指计算机系统中的&lt;strong&gt;程序&lt;/strong&gt;、&lt;strong&gt;数据&lt;/strong&gt;及&lt;strong&gt;其相关文档&lt;/stron</summary>
      
    
    
    
    <category term="课程作业" scheme="http://www.bojiboqi.fun/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="软件工程" scheme="http://www.bojiboqi.fun/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>软件测试</title>
    <link href="http://www.bojiboqi.fun/2024/02/28/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    <id>http://www.bojiboqi.fun/2024/02/28/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</id>
    <published>2024-02-28T13:02:28.533Z</published>
    <updated>2024-02-28T10:44:05.273Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1>1.Junit单元测试教程:</h1><h2 id="基础测试：">基础测试：</h2><p>官方文档：<a href="https://junit.org/junit5/docs/current/user-guide/index.html#migrating-from-junit4">JUnit 5 User Guide</a><br>教学链接：<a href="https://blog.csdn.net/weixin_44170221/article/details/106463482">超级详细的Junit单元测试教程_何学长在奔跑的博客-CSDN博客</a><br>注意：<br>1.Junit4中的断言是Assert.assertEquals这种样式的（也就是教学链接里面的样子）<br>但是Junit5中的断言是直接使用assertEquals。<br>2.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method.invoke(junitClass.newInstance()); invoke是调用反射类的方法</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/wyx1990/p/12732902.html">Eclipse搭建selenium环境 - 景月 - 博客园</a><br>超时测试：&quot;@Test (timeout=&quot;规定的时间）</p><h2 id="参数测试：">参数测试：</h2><p><a href="https://blog.csdn.net/w605283073/article/details/80051229">JUnit4 参数化测试（ Parameterized tests）_junit参数化测试_明明如月学长的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h1&gt;1.Junit单元测试教程:&lt;/h1&gt;
&lt;h2 id=&quot;基础测试：&quot;&gt;基础测试：&lt;/h2&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://junit.org/junit5/doc</summary>
      
    
    
    
    <category term="课程作业" scheme="http://www.bojiboqi.fun/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="软件测试" scheme="http://www.bojiboqi.fun/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端bug</title>
    <link href="http://www.bojiboqi.fun/2024/02/28/%E5%89%8D%E7%AB%AF%E8%99%AB%E5%B7%A2%EF%BC%9A/"/>
    <id>http://www.bojiboqi.fun/2024/02/28/%E5%89%8D%E7%AB%AF%E8%99%AB%E5%B7%A2%EF%BC%9A/</id>
    <published>2024-02-28T13:02:28.530Z</published>
    <updated>2024-02-28T10:44:05.316Z</updated>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h4 id="Uncaught-TypeError-Vue-is-not-a-constructor">Uncaught TypeError: Vue is not a constructor</h4><p>错误描述：<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688607718270-92d49fc2-be09-47e1-be5b-d859947b381e.png#averageHue=%23ca9e64&amp;clientId=u3fbcc324-fcac-4&amp;from=paste&amp;height=610&amp;id=uc2ecf945&amp;originHeight=762&amp;originWidth=788&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=25150&amp;status=done&amp;style=none&amp;taskId=uec197f31-8ed4-4f45-9cd4-3c059ba9b74&amp;title=&amp;width=630.4" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Hello World!&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;!--通过CDN引入全局的vue.js文件--&gt;</span><br><span class="line">&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;&#123;&#123;mess&#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        Hello, Vue!</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        //创建Vue的实例并且绑定</span><br><span class="line">        var app = new Vue ( &#123;</span><br><span class="line">            el:&quot;#app&quot;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                mes:&quot;hello world!!&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      </span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>原因：通过CDN导入的vue3，应该导入vue2<br>修改：将</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--通过CDN引入全局的vue.js文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>改成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="启动vue项目管理显示断开连接：">启动vue项目管理显示断开连接：</h4><p>输入vue ui启动项目管理遇到的问题：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688713252188-4bec1391-94c0-4841-bca0-b7f8af05a9a4.png#averageHue=%232d2d2c&amp;clientId=u8b3834fa-4e23-4&amp;from=paste&amp;id=uf7c369f1&amp;originHeight=427&amp;originWidth=732&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=36947&amp;status=done&amp;style=none&amp;taskId=u01ba1473-7c1c-46b9-aa4e-e0f94f6560b&amp;title=" alt="image.png"><br>解决方法：添加系统环境变量：C:\Windows\System32；</p><h4 id="删除vue项目的一个自定义组件后报-error-Component-name-“elinput”-should-always-be-multi-word-vue-multi-word-component-namesimage-png">删除vue项目的一个自定义组件后报:error  Component name “elinput” should always be multi-word  vue/multi-word-component-names<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688782766237-782a2b10-9b07-4e14-8488-62f33a283ffd.png#averageHue=%23161617&amp;clientId=u5cbc3a4f-bffa-4&amp;from=paste&amp;height=285&amp;id=u4aeece03&amp;originHeight=356&amp;originWidth=1286&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=36451&amp;status=done&amp;style=none&amp;taskId=u19fc7b30-183f-4f96-be81-e5e974108cc&amp;title=&amp;width=1028.8" alt="image.png"></h4><p>原因：可能是你没有完全卸载eslint，它可能还存在于全局安装的包中。你可以使用npm list -g命令查看全局安装的包，如果看到eslint，就可以使用npm uninstall -g eslint --save命令卸载它。</p><h4 id="Duplicate-entry-‘1’-for-key-‘t-emp-PRIMARY’">Duplicate entry ‘1’ for key ‘t_emp.PRIMARY’</h4><p>Duplicate：重复；原因：插入sql的主键重复了</p><h4 id="Uncaught-runtime-errors-ERROR-vue-WEBPACK-IMPORTED-MODULE-0-default-is-undefined">Uncaught runtime errors:ERROR:vue__WEBPACK_IMPORTED_MODULE_0__.default is undefined</h4><p>错误描述：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688967384172-2dc1b1e9-349a-4014-80e1-e9e546981567.png#averageHue=%23332123&amp;clientId=ue1e7ae7b-b956-4&amp;from=paste&amp;height=366&amp;id=u9f359619&amp;originHeight=457&amp;originWidth=838&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=48331&amp;status=done&amp;style=none&amp;taskId=u8df096df-24a2-4ec8-83c2-9f62c2077ce&amp;title=&amp;width=670.4" alt="Snipaste_2023-07-10_13-36-22.png"><br>原因：<br>我的项目使用的是 vue 3.3.4 版本，但是你的 main.js 文件中使用的是 vue 2 的语法。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688967460719-06ddfd72-8351-481a-bab4-7174989c78ed.png#averageHue=%23251c10&amp;clientId=ue1e7ae7b-b956-4&amp;from=paste&amp;height=122&amp;id=u0f48bdbc&amp;originHeight=153&amp;originWidth=550&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=14095&amp;status=done&amp;style=none&amp;taskId=ucb48d7ee-32a5-422d-95d1-f443209333d&amp;title=&amp;width=440" alt="image.png"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">Vue.config.productionTip = false </span><br><span class="line">Vue.use(Vuex)</span><br><span class="line">let store = new Vuex.Store(&#123; </span><br><span class="line">state:&#123;</span><br><span class="line">count: 100 </span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">new Vue(&#123; </span><br><span class="line">store,</span><br><span class="line">render: h =&gt; h(App), </span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure><p>修改方法：<br>方法1：main.js中使用vue3的语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line"></span><br><span class="line">let store = new Vuex.Store(&#123; </span><br><span class="line">state:&#123;</span><br><span class="line">count: 100 </span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const app = createApp(App)</span><br><span class="line">app.use(store)</span><br><span class="line">app.mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure><p>方法2：重新创建一个项目，创建项目的时候注意选择vue2版本的。</p><h4 id=""></h4>]]></content>
    
    
      
      
    <summary type="html"> &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h4 id=&quot;Uncaught-TypeError-Vue-is-not-a-constructor&quot;&gt;Uncaught TypeError: Vue is not a construc</summary>
      
    
    
    
    <category term="杂项" scheme="http://www.bojiboqi.fun/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="bug" scheme="http://www.bojiboqi.fun/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础课后期末复习</title>
    <link href="http://www.bojiboqi.fun/2024/02/28/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%9A/"/>
    <id>http://www.bojiboqi.fun/2024/02/28/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%EF%BC%9A/</id>
    <published>2024-02-28T13:02:28.527Z</published>
    <updated>2024-02-28T10:44:05.173Z</updated>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id=""></h2><h2 id="第一章：">第一章：</h2><p>1.冯诺依曼研究的计算机不是第一台存储结构的计算机。<br>2。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687074892884-661239a4-90e7-4bc5-848b-af0a00634894.png#averageHue=%23f3f3f3&amp;clientId=u7a700a2e-d781-4&amp;from=paste&amp;height=169&amp;id=u29502497&amp;originHeight=211&amp;originWidth=641&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=12072&amp;status=done&amp;style=none&amp;taskId=ue3e21772-7861-4217-b942-97cec331463&amp;title=&amp;width=512.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687075672801-d1fb4af4-4fe2-43be-99fa-10a509ea73e5.png#averageHue=%23f5dad0&amp;clientId=u7a700a2e-d781-4&amp;from=paste&amp;height=198&amp;id=uec2c0ed3&amp;originHeight=247&amp;originWidth=1134&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=152121&amp;status=done&amp;style=none&amp;taskId=u790c7516-e2c1-4e4b-aa18-cd199d291a3&amp;title=&amp;width=907.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687076054310-4fb49b11-55db-4dea-ac4f-d09fe8e7f6b6.png#averageHue=%23f8ece8&amp;clientId=u7a700a2e-d781-4&amp;from=paste&amp;height=428&amp;id=u03fb9077&amp;originHeight=535&amp;originWidth=1326&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=343670&amp;status=done&amp;style=none&amp;taskId=u0e20936d-b84b-4241-adc7-ad7d5203f6e&amp;title=&amp;width=1060.8" alt="image.png"><br>1.浮点数的阶码用移码表示是因为移码在比较大小的时候可以改变符号位带来的影响。<br>1.<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687079581752-9dff08b2-1ac6-4215-ab94-8934d57bea63.png#averageHue=%23faf5f4&amp;clientId=u7a700a2e-d781-4&amp;from=paste&amp;height=246&amp;id=u68ac9d12&amp;originHeight=308&amp;originWidth=583&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=28810&amp;status=done&amp;style=none&amp;taskId=u24f86a24-e45b-42fb-874f-76ddf7e5903&amp;title=&amp;width=466.4" alt="image.png">变形补码如果2个符号位相同则没有溢出，不同就溢出了。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687084965957-1f6f0d41-56ad-42ec-9daa-2f28bba2c40f.png#averageHue=%23d5d5d5&amp;clientId=ud1688b1c-f083-4&amp;from=paste&amp;height=60&amp;id=ucf7b6d65&amp;originHeight=75&amp;originWidth=982&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=35798&amp;status=done&amp;style=none&amp;taskId=u872aa925-825e-46f0-8039-8b64f21db7f&amp;title=&amp;width=785.6" alt="image.png"><br>0/0的结果为非数。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687085905199-f7015f9b-d86a-4c41-894c-9e54b5aaef81.png#averageHue=%23f6f5f3&amp;clientId=ud1688b1c-f083-4&amp;from=paste&amp;height=282&amp;id=u903d3657&amp;originHeight=352&amp;originWidth=773&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=45445&amp;status=done&amp;style=none&amp;taskId=u10970eca-8b67-43b0-8360-660f9327c74&amp;title=&amp;width=618.4" alt="image.png"><br>浮点数float型的数据类型的有效位数最高为7位。<br>字长是数据通路的宽度（寄存器的宽度，ALU运算的宽度，传输路径上的宽度），IA-32架构字长是32位。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687090831737-aac5d7b4-1405-4e8e-a10e-092c93350f68.png#averageHue=%23f9f8f7&amp;clientId=ud1688b1c-f083-4&amp;from=paste&amp;height=379&amp;id=ud83a47b3&amp;originHeight=474&amp;originWidth=1110&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=65104&amp;status=done&amp;style=none&amp;taskId=u014d3b58-acc3-4f55-9860-2166a72077f&amp;title=&amp;width=888" alt="image.png"><br>对于A选项，是先将f的真值用32位的int表示，其真值位1234.5其小数部分会被截断损失。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687090914398-c2f2e37d-125f-478c-944c-c1cafe94bcbd.png#averageHue=%23faf9f8&amp;clientId=ud1688b1c-f083-4&amp;from=paste&amp;height=283&amp;id=ueb567853&amp;originHeight=354&amp;originWidth=1085&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=42150&amp;status=done&amp;style=none&amp;taskId=u76597a50-f032-4a53-9976-3ef67a03ed5&amp;title=&amp;width=868" alt="image.png"><br>（不同的指令其长度不一样）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687093510841-aed589bc-61e7-42ba-bfbf-061556ab67df.png#averageHue=%23f7d7a3&amp;clientId=ud1688b1c-f083-4&amp;from=paste&amp;height=155&amp;id=u8d734d1f&amp;originHeight=194&amp;originWidth=594&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=79642&amp;status=done&amp;style=none&amp;taskId=u11f9d2f6-ae3a-4f74-96bc-b8140160777&amp;title=&amp;width=475.2" alt="image.png">（若是带符号整数其乘积的结果大于最大的int范围就会反转为负数，得到的高n为全为0或者1则没有溢出，否则溢出）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687094666759-99ee8c53-8d95-486f-bcc2-35fa6bf49805.png#averageHue=%23f8dcb0&amp;clientId=ud1688b1c-f083-4&amp;from=paste&amp;height=131&amp;id=uad12239a&amp;originHeight=164&amp;originWidth=894&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=143626&amp;status=done&amp;style=none&amp;taskId=ub2cdd32a-efe6-4b2f-844b-8f64832ca44&amp;title=&amp;width=715.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687094732935-8a0a5b8d-39f4-479f-82c5-22ec42ca734c.png#averageHue=%23cfcecb&amp;clientId=ud1688b1c-f083-4&amp;from=paste&amp;height=62&amp;id=u798fbfe7&amp;originHeight=78&amp;originWidth=949&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=56232&amp;status=done&amp;style=none&amp;taskId=ua24b490d-9264-4d5f-ad98-9cea0250f25&amp;title=&amp;width=759.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687102280483-b2de2c1d-88a7-4e21-ad65-011abf9c36a1.png#averageHue=%23f9f8f7&amp;clientId=uc67fcce9-c2c2-4&amp;from=paste&amp;height=455&amp;id=u5f4e9dd2&amp;originHeight=569&amp;originWidth=1108&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=81464&amp;status=done&amp;style=none&amp;taskId=u0be441a1-e72b-4268-8ae0-c3a4b8cfa92&amp;title=&amp;width=886.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687102424723-5aab7545-b083-491f-9f15-9f21f2e7fb92.png#averageHue=%23fafaf9&amp;clientId=uc67fcce9-c2c2-4&amp;from=paste&amp;height=377&amp;id=u7ec98900&amp;originHeight=471&amp;originWidth=1054&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=41626&amp;status=done&amp;style=none&amp;taskId=u19444912-60d5-483a-b7a8-78fe638e41f&amp;title=&amp;width=843.2" alt="image.png">（为什么是25为因为在进行尾数相加的时候会保留符号位，附加位，粘位，当移动25位的时候尾数的符号位+附加位+粘位可能是：010，011都是小于100的情况，都是要舍入的，如果是24位或者是23位都会可能发生进位的情况。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687102703442-1bb6cb00-59a6-4eed-bf85-68afa7221ebe.png#averageHue=%23fbf7f6&amp;clientId=uc67fcce9-c2c2-4&amp;from=paste&amp;height=656&amp;id=u0cd6254f&amp;originHeight=820&amp;originWidth=1064&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=95515&amp;status=done&amp;style=none&amp;taskId=uf5f308dd-fc16-439e-88b4-58b59aa029d&amp;title=&amp;width=851.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687136125858-5bcda0df-6619-413c-a4b6-2461cd24f4de.png#averageHue=%23f8f7f6&amp;clientId=uc67fcce9-c2c2-4&amp;from=paste&amp;height=237&amp;id=u2889776e&amp;originHeight=296&amp;originWidth=787&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=27779&amp;status=done&amp;style=none&amp;taskId=u33ded9a3-d8ce-4f53-893a-bdd321d55c0&amp;title=&amp;width=629.6" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687137049082-b374bd94-9c29-42cc-ab49-413cd389ffe9.png#averageHue=%23fbfaf9&amp;clientId=uc67fcce9-c2c2-4&amp;from=paste&amp;height=325&amp;id=uf5a786d5&amp;originHeight=406&amp;originWidth=920&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=52635&amp;status=done&amp;style=none&amp;taskId=u1bb98632-83ed-499c-b4ee-cbee1495a9a&amp;title=&amp;width=736" alt="image.png">汇编指令是机器指令的助记符号，需要转变位机器指令才能执行。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687137139094-d6b39db8-6d72-404e-a25c-e2589aaaf766.png#averageHue=%23fbfbfa&amp;clientId=uc67fcce9-c2c2-4&amp;from=paste&amp;height=319&amp;id=ua5b02a04&amp;originHeight=399&amp;originWidth=839&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=26721&amp;status=done&amp;style=none&amp;taskId=u4dc38799-d7d3-495a-93ca-2b7fed3c705&amp;title=&amp;width=671.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687137168047-74ba7503-2a45-4801-b731-f633bfb914d1.png#averageHue=%23fbfaf9&amp;clientId=uc67fcce9-c2c2-4&amp;from=paste&amp;height=323&amp;id=uc6fc5904&amp;originHeight=404&amp;originWidth=825&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=49914&amp;status=done&amp;style=none&amp;taskId=ub770d9e1-4884-444a-8d43-d2a2e03fff0&amp;title=&amp;width=660" alt="image.png">指令中的寄存器可能是ax<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687137214095-63f1839f-e11e-4d98-9fd8-f9026effaadb.png#averageHue=%23faf9f8&amp;clientId=uc67fcce9-c2c2-4&amp;from=paste&amp;height=310&amp;id=u78859393&amp;originHeight=388&amp;originWidth=850&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=48714&amp;status=done&amp;style=none&amp;taskId=u84a5f577-e9f1-4852-a9ca-e6bb1402c0c&amp;title=&amp;width=680" alt="image.png">只有EAX,EBX,ECX,ED可以这样，其余通用寄存器保留当中8位寄存器使用。<br>布斯乘法：<br><a href="https://blog.csdn.net/skl4869/article/details/120829532">布斯（booth）乘法详解和例子_booth乘法_某六十九岁合法萝莉的博客-CSDN博客</a><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687151012238-6991f46b-e509-4ace-81a7-88c9ec18591b.png#averageHue=%23fdfaf9&amp;clientId=uc67fcce9-c2c2-4&amp;from=paste&amp;height=342&amp;id=u0259658b&amp;originHeight=428&amp;originWidth=1190&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=36209&amp;status=done&amp;style=none&amp;taskId=u29a96197-7269-4927-bba5-4895586f701&amp;title=&amp;width=952" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687151033074-c5ea92dd-b74d-497c-b97a-aa83dc8226c7.png#averageHue=%23faf9f9&amp;clientId=uc67fcce9-c2c2-4&amp;from=paste&amp;height=381&amp;id=u85e86c6f&amp;originHeight=476&amp;originWidth=1098&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=50347&amp;status=done&amp;style=none&amp;taskId=u26cf64c4-b096-4e2f-9683-9b3cd271692&amp;title=&amp;width=878.4" alt="image.png">（有减法运算时求CF一定将其减数转化为补码在运算）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687151075994-772ff53c-c8b2-475f-be30-c2675b0a6b4d.png#averageHue=%23faf9f8&amp;clientId=uc67fcce9-c2c2-4&amp;from=paste&amp;height=353&amp;id=u97348b65&amp;originHeight=441&amp;originWidth=1081&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=54865&amp;status=done&amp;style=none&amp;taskId=u486d58e9-532b-49a4-b647-9a371e760bc&amp;title=&amp;width=864.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687156162258-a99a2085-5a5b-45fb-a227-507b18acce66.png#averageHue=%23fbfafa&amp;clientId=ue180da2c-b857-4&amp;from=paste&amp;height=361&amp;id=u55668b0c&amp;originHeight=451&amp;originWidth=1075&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=39982&amp;status=done&amp;style=none&amp;taskId=u328ff7d3-9491-46c8-9b30-6546bfb72ae&amp;title=&amp;width=860" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687156182794-a97cc52b-69f3-4521-b03e-20f8d9b190b6.png#averageHue=%23fbfaf9&amp;clientId=ue180da2c-b857-4&amp;from=paste&amp;height=354&amp;id=uafb997b2&amp;originHeight=443&amp;originWidth=1083&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=43606&amp;status=done&amp;style=none&amp;taskId=uc1b3ebc2-9675-451e-8e03-8a097c7875e&amp;title=&amp;width=866.4" alt="image.png"><br>（这里要注意A选项，为了体系else关键字，汇编语句中一定包含无条件跳转指令）<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687159267242-94e41de6-9d00-448f-b733-34b51e9d5a94.png#averageHue=%23fdf9f9&amp;clientId=ue180da2c-b857-4&amp;from=paste&amp;height=354&amp;id=u1ff9efef&amp;originHeight=443&amp;originWidth=1059&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=40585&amp;status=done&amp;style=none&amp;taskId=u3625dce8-8662-4348-966b-a9ed678245d&amp;title=&amp;width=847.2" alt="image.png"><br>（这里要求送的是首地址）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687168489104-82da4674-e4b1-44aa-a2cc-bef1d654ec28.png#averageHue=%23fcf7f6&amp;clientId=ufa541de4-9c4f-4&amp;from=paste&amp;height=301&amp;id=u46e05049&amp;originHeight=376&amp;originWidth=1035&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=38802&amp;status=done&amp;style=none&amp;taskId=u9e810193-76d2-4da2-a071-eeacfcc6e64&amp;title=&amp;width=828" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687168534461-7a8050b7-4953-43a7-8c4b-d6c8eab454e8.png#averageHue=%23f9f9f8&amp;clientId=ufa541de4-9c4f-4&amp;from=paste&amp;height=314&amp;id=u9a67ab8e&amp;originHeight=392&amp;originWidth=1022&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=42163&amp;status=done&amp;style=none&amp;taskId=uef27aff5-3b24-4bc0-861f-0005e38be17&amp;title=&amp;width=817.6" alt="image.png"><br>（还需要指明是动态链接还是静态链接）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687183700317-ea29635d-0826-44da-909f-acdbf2f916f2.png#averageHue=%23fcfbfb&amp;clientId=uc7f32047-918b-4&amp;from=paste&amp;height=633&amp;id=u23375bcd&amp;originHeight=791&amp;originWidth=833&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=49214&amp;status=done&amp;style=none&amp;taskId=uf2b4d17d-c98c-45c0-9c59-890fed64d40&amp;title=&amp;width=666.4" alt="image.png"><br>（ m1中的main()函数和m2中定义的静态变量main是不一样的符号）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687183811809-15300667-de81-44e7-b7fc-d729273262db.png#averageHue=%23fdfdfd&amp;clientId=uc7f32047-918b-4&amp;from=paste&amp;height=675&amp;id=ua924dccf&amp;originHeight=844&amp;originWidth=1179&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=48633&amp;status=done&amp;style=none&amp;taskId=u0a312d08-214e-4659-a199-0b34bbc3f6e&amp;title=&amp;width=943.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1687183875756-3747f935-476b-41e9-9ed6-c907ac6a61b6.png#averageHue=%23f3f2f0&amp;clientId=uc7f32047-918b-4&amp;from=paste&amp;height=124&amp;id=u76cfee2a&amp;originHeight=155&amp;originWidth=1022&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=26522&amp;status=done&amp;style=none&amp;taskId=ubae7a322-ba04-41da-94cc-1e1d2469615&amp;title=&amp;width=817.6" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html"> &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;/h2&gt;
&lt;h2 id=&quot;第一章：&quot;&gt;第一章：&lt;/h2&gt;
&lt;p&gt;1.冯诺依曼研究的计算机不是第一台存储结构的计算机。&lt;br&gt;
2。&lt;br&gt;
&lt;img src=&quot;htt</summary>
      
    
    
    
    <category term="课程作业" scheme="http://www.bojiboqi.fun/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="计算机基础" scheme="http://www.bojiboqi.fun/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>springSecurity</title>
    <link href="http://www.bojiboqi.fun/2024/02/28/%E6%B1%9F%E5%8D%97%E4%B8%80%E7%82%B9%E9%9B%A8springSecurity_/"/>
    <id>http://www.bojiboqi.fun/2024/02/28/%E6%B1%9F%E5%8D%97%E4%B8%80%E7%82%B9%E9%9B%A8springSecurity_/</id>
    <published>2024-02-28T13:02:28.523Z</published>
    <updated>2024-02-28T10:44:05.349Z</updated>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id=""></h2><h2 id="springsecurity自动配置解析：">springsecurity自动配置解析：</h2><p>SecurityFilterAutoConfiguration：<br><a href="https://www.cnblogs.com/chengxuxiaoyuan/p/17300575.html">spring security自动配置的源码简单分析 - 程序晓猿 - 博客园</a>（详细但是也挺难的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;SecurityProperties.class&#125;)</span>注解，Spring Boot会自动将这些属性加载到应用程序的上下文中，使得我们可以通过<span class="meta">@Autowired</span>注解或其他方式方便地访问和使用这些属性。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表示SecurityFilterAutoConfiguration的自动配置必须要在</span><br></pre></td></tr></table></figure><h3 id="请求到达spring-security的处理过程：">请求到达spring security的处理过程：</h3><p>一个请求到达spring security后首先会被DelegatingFilterProxy这个过滤器拦截到，这是一个代理过滤器，它会使用内部的代理目标delegate 也就是从容器中获取名称是springSecurityFilterChain的过滤器（而这个过滤器是由由WebSecurity 构建的FilterChainProxy这个类型的过滤器来处理请求,）总结下请求的处理路径就是：<br>1.DelegatingFilterProxy -----&gt;2.FilterChainProxy<br>详细看下FilterChainProxy这个过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterChainProxy</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这个属性很重要,过滤器链的集合,从这个属性的类型可以知道spring security支持多个过滤器链</span></span><br><span class="line"><span class="comment">    一个链条对象SecurityFilterChain中会包含多个过滤器,</span></span><br><span class="line"><span class="comment">    当然一般情况我们的应用中只需要配置一个链条对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;SecurityFilterChain&gt; filterChains;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//下面的方法用于拦截并处理HTTP请求。首先检查是否已经应用了过滤器，如果没有则将一个标记属</span></span><br><span class="line">    <span class="comment">// 性设置到请求中，然后执行内部的过滤器处理方法。最后，清除SecurityContextHolder中的上下</span></span><br><span class="line">    <span class="comment">// 文，并移除标记属性。如果已经应用了过滤器，则直接执行内部处理方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">clearContext</span> <span class="operator">=</span> request.getAttribute(FILTER_APPLIED) == <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (clearContext) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">request.setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">doFilterInternal(request, response, chain);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">SecurityContextHolder.clearContext();</span><br><span class="line">request.removeAttribute(FILTER_APPLIED);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//请求进来后会执行到这里来执行真正的过滤逻辑</span></span><br><span class="line">doFilterInternal(request, response, chain);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">FirewalledRequest</span> <span class="variable">fwRequest</span> <span class="operator">=</span> firewall</span><br><span class="line">.getFirewalledRequest((HttpServletRequest) request);</span><br><span class="line"><span class="type">HttpServletResponse</span> <span class="variable">fwResponse</span> <span class="operator">=</span> firewall</span><br><span class="line">.getFirewalledResponse((HttpServletResponse) response);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 首先通过这个getFilters方法来从过滤器链的集合filterChains中匹配到一个过滤器链</span></span><br><span class="line"><span class="comment">           对象SecurityFilterChain，返回这个链条里边的所有过滤器</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">List&lt;Filter&gt; filters = getFilters(fwRequest);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (filters == <span class="literal">null</span> || filters.size() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(UrlUtils.buildRequestUrl(fwRequest)</span><br><span class="line">+ (filters == <span class="literal">null</span> ? <span class="string">&quot; has no matching filters&quot;</span></span><br><span class="line">: <span class="string">&quot; has an empty filter list&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fwRequest.reset();</span><br><span class="line"></span><br><span class="line">chain.doFilter(fwRequest, fwResponse);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 根据filters构造虚拟过滤器链对象VirtualFilterChain来遍历执行filters中的每个过滤器</span></span><br><span class="line">         <span class="comment">// VirtualFilterChain是当前类中的内部类，遍历的原理就是这个类</span></span><br><span class="line"><span class="type">VirtualFilterChain</span> <span class="variable">vfc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VirtualFilterChain</span>(fwRequest, chain, filters);</span><br><span class="line">vfc.doFilter(fwRequest, fwResponse);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个方法用来根据request对象从filterChains中匹配出一个SecurityFilterChain对象并返回</span></span><br><span class="line">    <span class="comment">// 此链条中的所有过滤器</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Filter&gt; <span class="title function_">getFilters</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line"><span class="comment">//从这个方法可以看出SecurityFilterChain中一定存在两个方法 matches，getFilters</span></span><br><span class="line">        <span class="keyword">for</span> (SecurityFilterChain chain : filterChains) &#123;</span><br><span class="line"><span class="keyword">if</span> (chain.matches(request)) &#123;</span><br><span class="line"><span class="keyword">return</span> chain.getFilters();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部类用来依次执行上边getFilters方法获取到的filters中的所有过滤器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">VirtualFilterChain</span> <span class="keyword">implements</span> <span class="title class_">FilterChain</span> &#123;</span><br><span class="line"><span class="comment">/* 这个变量记录了原始的FilterChain对象,也就是FilterChainProxy这个过滤器的doFilter方法中的参            数FilterChain,通过这个FilterChain可以把请求从FilterChainProxy转给其他的过滤器(请求已经被         spring security处理完了接着去执行其他的过滤器)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这里需要普及一下Filter的相关知识,当我们的应用中配置多个过滤器(不仅是spirng security的过滤器)         时,是通过FilterChain实现从filter1转给filter2的</span></span><br><span class="line"><span class="comment">下面是Filter接口的源码</span></span><br><span class="line"><span class="comment">        public interface Filter &#123;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">           //这个方法参数chain就是用来实现把请求从filter1转给filter2的</span></span><br><span class="line"><span class="comment">            public void doFilter(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="comment">                FilterChain chain) throws IOException, ServletException;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        一般我们实现Filter接口时都要实现此方法,并通过chain.doFilter方法实现把请求交给下一个过滤器。</span></span><br><span class="line"><span class="comment">        public  MyFilter implements Filter&#123;</span></span><br><span class="line"><span class="comment">        @Override</span></span><br><span class="line"><span class="comment">        public void doFilter(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="comment">            FilterChain chain) throws IOException, ServletException&#123;</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">              ...一些过滤的逻辑</span></span><br><span class="line"><span class="comment">              //最后把请求交给下一个顾虑器时都会执行</span></span><br><span class="line"><span class="comment">              chain.doFilter(request, response);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> FilterChain originalChain;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Filter&gt; additionalFilters;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FirewalledRequest firewalledRequest;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> size;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">currentPosition</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">VirtualFilterChain</span><span class="params">(FirewalledRequest firewalledRequest,</span></span><br><span class="line"><span class="params">FilterChain chain, List&lt;Filter&gt; additionalFilters)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.originalChain = chain;</span><br><span class="line"><span class="built_in">this</span>.additionalFilters = additionalFilters;</span><br><span class="line"><span class="built_in">this</span>.size = additionalFilters.size();</span><br><span class="line"><span class="built_in">this</span>.firewalledRequest = firewalledRequest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">            <span class="comment">//这个方法通过currentPosition来控制递归调用additionalFilters中的所有过滤器</span></span><br><span class="line"><span class="keyword">if</span> (currentPosition == size) &#123;</span><br><span class="line">                <span class="comment">//这里表示执行到了最后一个过滤器</span></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(UrlUtils.buildRequestUrl(firewalledRequest)</span><br><span class="line">+ <span class="string">&quot; reached end of additional filter chain; proceeding with original chain&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deactivate path stripping as we exit the security filter chain</span></span><br><span class="line"><span class="built_in">this</span>.firewalledRequest.reset();</span><br><span class="line"><span class="comment">// spring security已经处理完了，把请求转给其他的过滤器</span></span><br><span class="line">originalChain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">currentPosition++;</span><br><span class="line"><span class="comment">// 取出additionalFilters中currentPosition位置的过滤器</span></span><br><span class="line"><span class="type">Filter</span> <span class="variable">nextFilter</span> <span class="operator">=</span> additionalFilters.get(currentPosition - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(UrlUtils.buildRequestUrl(firewalledRequest)</span><br><span class="line">+ <span class="string">&quot; at position &quot;</span> + currentPosition + <span class="string">&quot; of &quot;</span> + size</span><br><span class="line">+ <span class="string">&quot; in additional filter chain; firing Filter: &#x27;&quot;</span></span><br><span class="line">+ nextFilter.getClass().getSimpleName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为VirtualFilterChain实现了FilterChain接口，所以这里</span></span><br><span class="line">                <span class="comment">//利用this把请求又转给了自己,相当于递归,通过currentPosition的递增会</span></span><br><span class="line">                 <span class="comment">//遍历执行完additionalFilters中的全部过滤器。</span></span><br><span class="line">nextFilter.doFilter(request, response, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以真正处理请求的其实是FilterChainProxy中维护的 SecurityFilterChain ,再更新下上边说的请求处理路径<br>1.DelegatingFilterProxy -----&gt;2.FilterChainProxy ----&gt;3.SecurityFilterChain<br>总结：<br>先是在SecurityFilterAutoConfiguration中给容器中加入了一个DelegatingFilterProxyRegistrationBean ,这个bean最后会给应用中注册一个DelegatingFilterProxy,这个代理过滤器会从容器中找出名称为springSecurityFilterChain的过滤器来执行它；<br>而这个springSecurityFilterChain是在WebSecurityConfiguration（这个类可以靠SecurityAutoConfiguration导入到容器中的）<br>）中由springSecurityFilterChain这个方法加到spring容器中的,在这个方法中会调用构建器WebSecurity.build方法创建出一个FilterChainProxy过滤器放到spring容器中;<br>当执行到WebSecurity.performBuild方法,会先调用SecurityFilterChain的构建器HttpSecurity的build方法构建出DefaultSecurityFilterChain对象,该对象内部会持有多个过滤器,然后把该对象作为参数创建出FilterChainProxy 对象返回。<br>可以看到这个过程中WebSecurity 是一个很关键的角色，它创建了DefaultSecurityFilterChain和FilterChainProxy</p><ul><li>[ ] SecurityFilterAutoConfiguration-&gt;DelegatingFilterProxyRegistrationBean-&gt;DelegatingFilterProxy-&gt;FilterChainProxy-&gt;DefaultSecurityFilterChain;这里其中的FilterChainProxy-&gt;DefaultSecurityFilterChain是在websecurity中创建的。</li></ul><p>webSecurity这个构建器用来创建Filter,，其中它具体构造过滤链还是落在WebSecurityConfigurerAdapter上的configure方法。<br>WebSecurity是一个接口，它定义了Spring Security框架提供的安全功能的抽象接口。WebSecurityConfigurer是一个抽象类，用于配置Web应用程序的安全性。WebSecurityConfigurerAdapter是WebSecurityConfigurer的子类，它通过实现WebSecurityConfigurer中的抽象方法来配置Web应用程序的安全性。它还提供了默认实现来简化配置过程。因此，WebSecurityConfigurerAdapter是WebSecurityConfigurer的适配器类，用于方便地配置Web应用程序的安全性。<br>个人总结：我们一般配置安全信息配置类一般是要重写WebSecurityConfigurerAdapter，为什么要重写这个？因为spring从SecurityFilterAutoConfiguration自动加载过滤链的时候需要提取加载WebSecurityAutoConfiguration到容器中，而WebSecurityAutoConfiguration会加载WebSecurityConfiguration到容器中，其中真正过滤器链的创建还是要落在WebSecurityConfigurerAdapter上的configure方法上，当我们没有配置安全信息类时就启动时就加载WebSecurityConfigurerAdapter的其他默认配置类到容器中，比如：DefaultConfigurerAdapter。<br><a href="https://juejin.cn/post/7046236598832201758#heading-14">🍃【Spring专题】「技术原理」Spring Security的核心功能和加载运行流程的原理分析 - 掘金</a>（这个简单些）<br><a href="https://blog.csdn.net/m0_37989980/article/details/107519382">Spring Security——认证、授权的工作原理_spring security 授权原理-CSDN博客</a><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1700456347886-7de54b1e-0d9e-4152-ad92-47bd9ef539fb.jpeg#averageHue=%23fafafa&amp;clientId=uf783de77-98a1-4&amp;from=paste&amp;id=BlS8q&amp;originHeight=1488&amp;originWidth=1080&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3002f874-d427-448f-aeaa-de701abfb8e&amp;title=" alt=""><br>个人简单总结：就是安全的过滤链配置是通过重写WebSecurityConfigurerAdapter中的configure实现的，而这个过滤链接包括认证和授权：而下面的认证授权过滤链几乎都集中到WebSecurityConfigurerAdapter中了。<br>认证：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700459594842-c9c3cb42-5ff5-4ea1-92a6-638ed3a7fc2c.png#averageHue=%23fefefe&amp;clientId=uf783de77-98a1-4&amp;from=paste&amp;id=u4bc7aa3f&amp;originHeight=519&amp;originWidth=1011&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf0086c3a-d91d-4588-9269-6dc0a248b09&amp;title=" alt=""><br>授权：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700459619119-d8bcb9b2-56ec-45fd-bf0d-710ba773b507.png#averageHue=%23fefefe&amp;clientId=uf783de77-98a1-4&amp;from=paste&amp;id=u795db273&amp;originHeight=424&amp;originWidth=843&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue765f258-cee3-4292-96b9-2692eb9f292&amp;title=" alt=""></p><h2 id="获取ip地址：">获取ip地址：</h2><h2 id="SpringSecurity配置过滤器的时候对-and的理解：">SpringSecurity配置过滤器的时候对.and的理解：</h2><p><a href="https://cloud.tencent.com/developer/article/1651669">Spring Security 配置中的 and 到底该怎么理解？-腾讯云开发者社区-腾讯云</a><br>springsecurity有15个过滤器，and结束的地方是每个过滤器相关配置结束的地方。</p><h2 id="其他：">其他：</h2><p>1.我们往容器中注入了UserDetailsService后，我们配置文件中配置的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  security:</span><br><span class="line">    user:</span><br><span class="line">      name: admin</span><br><span class="line">      password: <span class="number">888888</span></span><br></pre></td></tr></table></figure><p>就会失效。这是因为在这种情况下，Spring Security将使用注入的UserDetailsService返回的UserDetails对象来进行身份验证，而不再使用配置文件中的用户名和密码。<br>2.当我们希望系统想从指定的数据源获取<br>3.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UserDetails是一个接口，表示用户的身份信息。它包含了用户的基本信息，如用户名、密码、角色等。</span><br><span class="line">WebAuthenticationDetails是一个类，表示Web应用程序中的身份验证细节。它包含了用户进行身份验证时的相关信息，如用户的IP地址、浏览器的 Referer 等</span><br><span class="line">UserDetails是UserDetailsService获取的。</span><br></pre></td></tr></table></figure><p>4.<a href="https://stackoverflow.com/questions/64526372/when-should-i-override-the-configureauthenticationmanagerbuilder-auth-from-spr">When should I override the configure(AuthenticationManagerBuilder auth) from Spring Security in a Spring Boot app?</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">注入 UserDetailsService 实例和重写 configure(AuthenticationManagerBuilder auth) 方法之间的</span><br><span class="line">区别在于配置的灵活性和控制权。</span><br><span class="line"></span><br><span class="line">注入 UserDetailsService 实例：</span><br><span class="line"></span><br><span class="line">通过将 UserDetailsService 实例注入到容器中，Spring Security 将自动使用该实例进行身份验证。</span><br><span class="line">这种方式适用于简单的身份验证需求，例如基于数据库的验证，只需要提供用户详细信息的查询逻辑。</span><br><span class="line">你无法直接在代码中对身份验证流程进行更详细的配置，因为验证过程是由 Spring Security 自动处理的。</span><br><span class="line">重写 configure(AuthenticationManagerBuilder auth) 方法：</span><br><span class="line"></span><br><span class="line">通过重写 configure(AuthenticationManagerBuilder auth) 方法，你可以更精确地配置身份验证过程。</span><br><span class="line">你可以定义多个身份验证提供者，并为每个提供者指定不同的验证逻辑、密码编码器等。</span><br><span class="line">可以使用多种身份验证方式，如数据库、LDAP、OAuth 等。</span><br><span class="line">可以自定义用户详细信息的加载方式和逻辑。</span><br><span class="line">可以添加其他的身份验证配置，如记住我功能、会话管理、多因素身份验证等。</span><br><span class="line">你可以在代码中直接控制身份验证的细节，并根据需要进行自定义和扩展。</span><br></pre></td></tr></table></figure><h2 id="springsecurity中的-ThreadLocal如何理解：">springsecurity中的 ThreadLocal如何理解：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在Spring Security中，ThreadLocal主要用于存储当前用户的信息。当用户进行认证并获得访问权限后，</span><br><span class="line">Spring Security会将用户信息存储到ThreadLocal中，以便在请求的处理过程中可以获取到当前用户的信息</span><br><span class="line">。  具体来说，Spring Security提供了SecurityContextHolder类来管理用户信息的存储和获取。</span><br><span class="line">SecurityContextHolder类中有一个getContext()方法返回一个SecurityContext对象，该对象中有一个</span><br><span class="line">getAuthentication()方法返回一个Authentication对象，该对象中存储了用户的信息。 </span><br><span class="line">在每个请求的处理过程中，Spring Security会将Authentication对象存储到ThreadLocal中，</span><br><span class="line">以便在需要访问用户信息的地方可以通过SecurityContextHolder.getContext().getAuthentication()</span><br><span class="line">来获取到用户的信息。  需要注意的是，ThreadLocal的使用可以保证每个请求都有独立的用户信息</span><br><span class="line">存储空间，避免了多个线程间共享用户信息导致的安全问题。但是，ThreadLocal的使用也会带来一定</span><br><span class="line">的性能开销，因为每个线程都需要存储和获取自己的ThreadLocal对象。因此，在使用ThreadLocal</span><br><span class="line">存储用户信息时，需要注意权衡安全和性能的关系。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html"> &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;/h2&gt;
&lt;h2 id=&quot;springsecurity自动配置解析：&quot;&gt;springsecurity自动配置解析：&lt;/h2&gt;
&lt;p&gt;SecurityFilterAut</summary>
      
    
    
    
    <category term="springSecurity" scheme="http://www.bojiboqi.fun/categories/springSecurity/"/>
    
    
    <category term="springSecurity" scheme="http://www.bojiboqi.fun/tags/springSecurity/"/>
    
  </entry>
  
  <entry>
    <title>springboot2江南一点雨博客总结</title>
    <link href="http://www.bojiboqi.fun/2024/02/28/%E6%B1%9F%E5%8D%97%E4%B8%80%E7%82%B9%E9%9B%A8springboot%E6%95%B4%E7%90%86%EF%BC%9A/"/>
    <id>http://www.bojiboqi.fun/2024/02/28/%E6%B1%9F%E5%8D%97%E4%B8%80%E7%82%B9%E9%9B%A8springboot%E6%95%B4%E7%90%86%EF%BC%9A/</id>
    <published>2024-02-28T13:02:28.520Z</published>
    <updated>2024-02-28T10:44:05.312Z</updated>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id=""></h2><h1>Springboot:</h1><h2 id="入门：">入门：</h2><h3 id="ComponentScan注解：">@ComponentScan注解：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.javaboy&quot;, useDefaultFilters = true,</span></span><br><span class="line"><span class="meta">excludeFilters = &#123;@ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Controller.class)&#125;)</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/huangjhai/article/details/104600328">@ComponentScan注解用于定义扫描的路径，从中找出标识了需要装配的类自动装配到Spring的Bean容器中。basePackages属性用于指定扫描路径，可以是单个路径，也可以是扫描的路径数组。如果不指定该属性，则默认扫描该注解所在类的同级目录及其子目录下所有的类。useDefaultFilters属性默认为true，表示开启默认过滤器，即只有标注了@Component、@Repository、@Service、@Controller等注解的类才会被装配到Spring的Bean容器中。如果不想使用默认过滤器，可以将该属性设置为false。如果需要排除某些类，则可以使用excludeFilters属性，该属性接收一个数组参数，数组中每个元素都是一个过滤器。在这里，您使用了一个排除过滤器，即排除所有标注了@Controller注解的类。</a></p><h3 id="DispatcherServlet">DispatcherServlet:</h3><p><a href="https://www.baeldung.com/spring-controllers#Overview">Just a moment…</a><br>springmvc流程图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698890087546-b6de719c-e18f-4797-9ead-a98872acf9ed.png#averageHue=%23fcf9f8&amp;clientId=uc63d89a5-684b-4&amp;from=paste&amp;height=439&amp;id=ud49b9475&amp;originHeight=549&amp;originWidth=982&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=68285&amp;status=done&amp;style=none&amp;taskId=ue9f3a3a4-2fca-42ea-8913-177b8ae22d6&amp;title=&amp;width=785.6" alt="image.png"><br>**_Front Controller _**主要职责包括：</p><ul><li>拦截传入请求</li><li>将请求的有效负载（请求的有效载荷就是请求中的数据部分，也就是请求体部分）转换为数据的内部结构</li><li>将数据发送到_模型_进行进一步处理</li><li>从模型中获取处理后的数据_，_并将该数据推进到_视图_进行渲染</li></ul><p><em>DispatcherServlet</em> 在架构中扮演着 <em>Front Controller</em> 的角色。该图既适用于典型的 MVC 控制器，也适用于 RESTful 控制器，但有一些细微的差异（如下所述）。<br>在传统方法中，<em>MVC</em> 应用程序不是面向服务的;因此，有一个 V_iew 解析器_，它根据从 <em>Controller</em> 接收的数据呈现最终视图。<br><em>RESTful</em> 应用程序被设计为面向服务并返回原始数据（通常为 JSON/XML）。由于这些应用程序不执行任何视图渲染，因此没有_视图解析器，并且通常期望控制器_通过 HTTP 响应直接发送数据。</p><h3 id="ServletContext：">ServletContext：</h3><p>1.一个web应用只有一个ServletContext。<br>2，在web应用部署成功后，servlet容器为应用创建了ServletContext实例，当服务器关闭时，其才被释放。在web中，<strong>一个用户可以有多个request；一个用户有一个session，而ServletContext，是所有的用户共用一个</strong>。所以，<em>ServletContext的存在，就是为了存放必须的、重要的、所有用户需要共享的、线程又是安全的一些资源信息，这样不仅节省了空间，还提高了效率</em>。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698891268381-033152f0-2985-471a-9d81-bef534b0e081.png#averageHue=%23fbf9f8&amp;clientId=uc63d89a5-684b-4&amp;from=paste&amp;height=562&amp;id=u20e7ea4b&amp;originHeight=703&amp;originWidth=1186&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=53892&amp;status=done&amp;style=none&amp;taskId=u6a8bec85-9013-4249-a54f-67002fef631&amp;title=&amp;width=948.8" alt="image.png"></p><h3 id="消息转换器：">消息转换器：</h3><p><a href="https://cloud.tencent.com/developer/article/1666635">https://cloud.tencent.com/developer/article/1666635</a><br><a href="https://www.baeldung.com/spring-httpmessageconverter-rest">Just a moment…</a><br>1.@RestController 注解即可将返回的数据结构转换成 Json 格式;@ResponseBody 注解是将返回的数据结构转换为 Json 格式。<br>2.要自定义JSON转换可以在相关配置类中重写configureMessageConverters方法。</p><h2 id="基础配置：">基础配置：</h2><p><strong>application.properties配置文件的位置和顺序：</strong></p><ol><li>当前项目根目录下的 config 目录下</li><li>当前项目的根目录下</li><li>resources 目录下的 config 目录下</li><li>resources 目录下</li></ol><p>按如上顺序，四个配置文件的优先级依次降低。如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698904143503-fb8b531c-fac5-4f21-bd37-7709b2815ad7.png#averageHue=%23fcfaf9&amp;clientId=uc63d89a5-684b-4&amp;from=paste&amp;id=uc570651b&amp;originHeight=402&amp;originWidth=285&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=12916&amp;status=done&amp;style=none&amp;taskId=u707a1795-6eeb-402b-b86d-ff31eb75e48&amp;title=" alt="image.png"><br><a href="https://blog.csdn.net/sanduo112/article/details/129061118">SpringBoot 启动配置文件加载和参数配置修改问题_springboot 动态修改properties-CSDN博客</a></p><h3 id="通过配置文件实现属性注入：">通过配置文件实现属性注入：</h3><p><a href="https://blog.csdn.net/qq_42937522/article/details/106230679">修改SpringBoot默认的启动图案_springboot项目启动动画-CSDN博客</a></p><h4 id="properties版本：">properties版本：</h4><p>法1：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698904456651-70570623-1d03-452d-b10c-51e07f2fdcdd.png#averageHue=%23f7f6f6&amp;clientId=uc63d89a5-684b-4&amp;from=paste&amp;height=195&amp;id=u5acadc95&amp;originHeight=244&amp;originWidth=1079&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=48642&amp;status=done&amp;style=none&amp;taskId=ud6a3335b-be02-4fde-982e-2acc317af40&amp;title=&amp;width=863.2" alt="image.png"><br>法2：自定义属性配置文件<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698904509965-5d092091-2cba-4726-8f33-3e1cb0dc058c.png#averageHue=%23f7f6f5&amp;clientId=uc63d89a5-684b-4&amp;from=paste&amp;height=295&amp;id=uc034b30f&amp;originHeight=369&amp;originWidth=648&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=31205&amp;status=done&amp;style=none&amp;taskId=uca732f19-c64d-497a-af94-bec3c517878&amp;title=&amp;width=518.4" alt="image.png"><br>法3：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698904570866-42066c9d-da27-4c3f-a23d-ceff0cea9c78.png#averageHue=%23f6f5f4&amp;clientId=uc63d89a5-684b-4&amp;from=paste&amp;height=251&amp;id=uda6ed2bf&amp;originHeight=314&amp;originWidth=1096&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=36820&amp;status=done&amp;style=none&amp;taskId=u982f2f91-bfe1-487b-b49f-eb43e84434d&amp;title=&amp;width=876.8" alt="image.png"><br>yaml文件的数组注入：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698904672864-5748916a-b284-40ad-83a2-780fddb87c3b.png#averageHue=%23f8f7f7&amp;clientId=uc63d89a5-684b-4&amp;from=paste&amp;height=205&amp;id=u65a5874b&amp;originHeight=256&amp;originWidth=1128&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=24788&amp;status=done&amp;style=none&amp;taskId=uec0a16e1-b425-4fc1-801b-bc37b59bb15&amp;title=&amp;width=902.4" alt="image.png"><br><a href="https://www.ruanyifeng.com/blog/2016/07/yaml.html">YAML 语言教程 - 阮一峰的网络日志</a><br>YAML文件是有序的。这意味着在YAML文件中，键值对的顺序是被保留的，并且在读取配置文件时会按照它们的出现顺序进行处理。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698909888570-fe6ca9f5-a789-41d5-b841-e0cfc0a80fff.png#averageHue=%233e4c5b&amp;clientId=uc63d89a5-684b-4&amp;from=paste&amp;height=387&amp;id=u84e7a604&amp;originHeight=484&amp;originWidth=1201&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=277512&amp;status=done&amp;style=none&amp;taskId=u33e0fd3a-ecbc-4873-b82d-b9e0d75d9c1&amp;title=&amp;width=960.8" alt="image.png"></p><h3 id="配置文件多环境区分：">配置文件多环境区分：</h3><p><a href="https://www.cnblogs.com/Chenjiabing/p/13968781.html">嗯，挺全乎儿的，Spring Boot 多环境配置都在这里了，你喜欢哪种？ - 爱撒谎的男孩 - 博客园</a><br>1.创建不同环境的配置文件：<br>既然每个环境的配置都不相同，索性将不同环境的配置放在不同的配置文件中，因此需要创建三个不同的配置文件，分别是<strong>application-dev.properties</strong>、<strong>application-test.properties</strong>、<strong>application-prod.properties</strong>。<br><strong>「注意」</strong>：配置文件的名称一定要是<strong>application-name.properties</strong>或者<strong>application-name.yml</strong>格式。这个<strong>name</strong>可以自定义，主要用于区分。<br>此时整个项目中就有四个配置文件，加上<strong>application.properties</strong>。<br>2.指定运行的环境<br>虽然你创建了各个环境的配置文件，但是Spring Boot 仍然不知道你要运行哪个环境，有以下两种方式指定：<br>配置文件中指定：<br>在application.properties或者application.yml文件中指定，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指定运行环境为测试环境</span><br><span class="line">spring.profiles.active=test</span><br></pre></td></tr></table></figure><p>如果没有指定运行的环境，<strong>Spring Boot</strong> 默认会加载<strong>application.properties</strong>文件，而这个的文件又告诉<strong>Spring Boot</strong> 去找<strong>test</strong>环境的配置文件。<br>运行 jar 的时候指定：<br><strong>Spring Boot</strong> 内置的环境切换能够在运行<strong>Jar</strong>包的时候指定环境，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxx.jar --spring.profiles.active=test</span><br></pre></td></tr></table></figure><p>以上命令指定了运行的环境是<strong>test</strong>。</p><h3 id="springboot关于tomcat的配置：">springboot关于tomcat的配置：</h3><p><a href="https://www.cnblogs.com/jvstarblog/p/12717900.html">SpringBoot - 内置的Tomcat服务器配置详解（附：启用HTTPS服务） - 11014p - 博客园</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server.port：配置 Web 容器的端口号（默认为 <span class="number">8080</span>）</span><br><span class="line">server.error.path：配置当前项目出错时跳转去的页面。</span><br><span class="line">server.servlet.session.timeout：配置 session 失效时间。30m 表示 <span class="number">30</span> 分钟，如果不写单位则默认单位是秒。（注意：由于 Tomcat 中配置 session 过期时间是以分钟为单位，如果我们这里设置是秒的话，那么会自动转换为一个不超过所配置秒数的最大分钟数。比如配置了 <span class="number">119</span> 秒，那么实际 session 过期时间是 <span class="number">1</span> 分钟）</span><br><span class="line">server.servlet.context-path：配置项目名称（默认为 /），如果配置了项目名称，那么在访问路径中要加上配置的路径</span><br><span class="line">server.tomcat.uri-encoding：配置 Tomcat 请求编码</span><br><span class="line">server.tomcat.max-threads：配置 Tomcat 的最大线程数</span><br><span class="line">server.tomcat.basedir：配置 Tomcat 运行日志和临时文件的目录。若不配置，则默认使用系统的临时目录。</span><br></pre></td></tr></table></figure><p>其中tomcat的配置选项还有https的配置选项。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698909158697-f4c6a29d-0f6b-4784-9009-5a2237a7efb6.png#averageHue=%232b2c31&amp;clientId=uc63d89a5-684b-4&amp;from=paste&amp;height=104&amp;id=uf19d6248&amp;originHeight=130&amp;originWidth=574&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=42016&amp;status=done&amp;style=none&amp;taskId=ucf1289cd-e685-465d-aa5c-1734cfc66dc&amp;title=&amp;width=459.2" alt="image.png"></p><h3 id="自定义一个start">自定义一个start:</h3><h2 id="整合视图：">整合视图：</h2><h2 id="整合web开发：">整合web开发：</h2><h3 id="静态资源配置：">静态资源配置：</h3><p>/** 表示可以匹配任意层级的路径；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.sang.javassm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMVCConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/**&quot;</span>).addResourceLocations(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Spring Boot 中，默认情况下，一共有5个位置可以放静态资源，五个路径分别是如下5个：</p><ol><li>classpath:/META-INF/resources/</li><li>classpath:/resources/</li><li>classpath:/static/</li><li>classpath:/public/</li><li>/</li></ol><p>第5个 / 其实就是表示 webapp 目录中的静态资源；如果同一个文件分别出现在五个目录下，那么优先级也是按照上面列出的顺序。</p><h3 id="ControllerAdvice-注解">@ControllerAdvice 注解</h3><p>以实现三个方面的功能：</p><ol><li>全局异常处理</li><li>全局数据绑定</li><li>全局数据预处理</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="comment">//@ExceptionHandler 注解用来指明异常的处理类型</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">customException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        mv.addObject(<span class="string">&quot;message&quot;</span>, e.getMessage());</span><br><span class="line">        mv.setViewName(<span class="string">&quot;myerror&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局数据绑定功能可以用来做一些初始化的数据操作，我们可以将一些公共的数据定义在添加了 @ControllerAdvice 注解的类中，这样，在每一个 Controller 的接口中，就都能够访问导致这些数据。<br>全局数据预处理：</p><p>Model,ModelMap,ModelAndView的区别：<br><a href="https://www.baeldung.com/spring-mvc-model-model-map-model-view">Model, ModelMap, and ModelAndView in Spring MVC | Baeldung</a><br><a href="https://blog.csdn.net/ITBigGod/article/details/79685610">Model、ModelMap和ModelAndView的使用详解-CSDN博客</a>（完整）<br>Model是一个接口,ModelMap类，ModelAndView是容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Model is an <span class="keyword">interface</span> <span class="title class_">that</span> defines a holder <span class="keyword">for</span> model attributes and is primarily designed <span class="keyword">for</span> adding attributes to the model. It can supply attributes used <span class="keyword">for</span> rendering views. To provide a view with usable data, we simply add <span class="built_in">this</span> data to its Model object. Additionally, maps with attributes can be merged with Model instances.</span><br><span class="line"></span><br><span class="line">ModelMap is a <span class="keyword">class</span> <span class="title class_">that</span> is also used to pass values to render a view. The advantage of ModelMap is it gives us the ability to pass a collection of values and treat these values as <span class="keyword">if</span> they were within a Map.</span><br><span class="line"></span><br><span class="line">ModelAndView is a container <span class="keyword">for</span> both a ModelMap and a view object. It allows a controller to <span class="keyword">return</span> both as a single value.</span><br></pre></td></tr></table></figure><h3 id="ModelAttribute：">@ModelAttribute：</h3><p><a href="https://blog.csdn.net/wxgxgp/article/details/81304570">【Spring】@ModelAttribute三种使用场景_@modelattribute @valid-CSDN博客</a><br><strong>1.用在Controller的方法上：</strong><br>每次执行方法时都会先执行@ModelAttribute注解的方法（此时该注解修饰的方法是用来准备数据的)，并将结果添加到<a href="https://so.csdn.net/so/search?q=model&amp;spm=1001.2101.3001.7020">model</a>中。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698928290546-b45a1883-fd5e-4c04-989e-1c64fa3b57aa.png#averageHue=%232c2e33&amp;clientId=ucec36595-9ede-4&amp;from=paste&amp;height=350&amp;id=u2932cf82&amp;originHeight=437&amp;originWidth=1059&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=219047&amp;status=done&amp;style=none&amp;taskId=u20da7afb-e587-4342-86dc-6fec0214a04&amp;title=&amp;width=847.2" alt="image.png"><br>@ModelAttribute(“top”)中的top是该Model的名字；<br>控制台结果：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698928330942-01750c78-3802-4167-bbdc-0c84b652fd99.png#averageHue=%236083a6&amp;clientId=ucec36595-9ede-4&amp;from=paste&amp;height=42&amp;id=u8e11ba24&amp;originHeight=52&amp;originWidth=336&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=9108&amp;status=done&amp;style=none&amp;taskId=u20581994-2e5a-46b6-a74f-4aa15f8b42d&amp;title=&amp;width=268.8" alt="image.png"><br>2**.用在方法的参数上：**可以直接从指定的模型中中取值.标注在方法参数上的@ModelAttribute说明了该方法参数的值将由model中取得。如果model中找不到，那么该参数会先被实例化，然后被添加到model中。在model中存在以后，请求中所有名称匹配的参数都会填充到该参数中。<br>3.**用在ControllerAdvice的方法中：**每个Controller中的方法执行前都会先执行 @ModelAttribute注解标注的方法，并将返回值添加到model<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698929265928-829ccb7a-716b-48d4-9df4-6dee12417bc3.png#averageHue=%232b2f37&amp;clientId=ucec36595-9ede-4&amp;from=paste&amp;height=313&amp;id=u3611b62b&amp;originHeight=391&amp;originWidth=964&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=190086&amp;status=done&amp;style=none&amp;taskId=u4b8a4672-d6b4-4075-ad49-271013eca25&amp;title=&amp;width=771.2" alt="image.png"><a href="https://zhuanlan.zhihu.com/p/115902823">SpringBoot2教程29整合SpringMVC之@InitBinder处理请求参数的绑定(一)</a></p><h3 id="自定义异常处理：">自定义异常处理：</h3><p>springboot错误处理原理：</p><ul><li><ol><li>SpringBoot 会<strong>自适应处理错误</strong>，<strong>响应页面</strong>或<strong>JSON数据</strong></li></ol></li><li>2.** SpringMVC的错误处理机制<strong>依然保留，<strong>MVC处理不了</strong>，才会</strong>交给boot进行处理**</li><li><img src="https://cdn.nlark.com/yuque/0/2023/svg/1613913/1681723795095-828d2034-1e6c-4d98-8e47-573dd6b5463b.svg#from=url&amp;id=ORNes&amp;originHeight=842&amp;originWidth=1047&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></li></ul><h4 id="静态异常页面：">静态异常页面：</h4><h4 id="动态异常页面：">动态异常页面：</h4><p><strong>动态页面模板，不需要开发者自己去定义控制器，直接定义异常页面即可 ，Spring Boot 中自带的异常处理器会自动查找到异常页面。</strong><br>如果动态页面和静态页面同时定义了异常处理页面，例如 classpath:/static/error/404.html 和 classpath:/templates/error/404.html 同时存在时，默认使用动态页面。</p><h4 id="自定义异常视图：">自定义异常视图：</h4><p><a href="https://www.baeldung.com/global-error-handler-in-a-spring-rest-api">Custom Error Message Handling for REST API | Baeldung</a></p><h3 id="解决跨域问题：">解决跨域问题：</h3><p><a href="https://blog.csdn.net/weixin_42318691/article/details/121187785">【精选】跨域请求被拒绝时，会进入后端接口执行吗？ 对跨域有个全面的认知_跨域请求被拦截后怎么判断请求到达后端_Yionr的博客-CSDN博客</a>（较长，有点废话）<br>1.所谓同源是指协议、域名以及端口要相同。</p><ul><li>浏览器的跨域请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。</li><li>所谓跨域是指浏览器当前访问的界面和请求的界面不是同一个源</li><li><strong>如果服务器没有配置CORS，则简单跨域请求可以成功执行，但是返回的内容会被浏览器拦截！</strong></li><li>当我们使用阿里OSS存储访问图片的时候，大都情况下是访问图片的请求是跨域请求；但是阿里云后端解决了跨域问题，所以访问前端可以直接访问图片，而不用处理跨域问题。</li><li><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698983164618-07adea71-2756-4788-b027-561c6b95dbae.png#averageHue=%23fdfdfc&amp;clientId=ucec36595-9ede-4&amp;from=paste&amp;height=613&amp;id=u7a47e668&amp;originHeight=766&amp;originWidth=1153&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=195846&amp;status=done&amp;style=none&amp;taskId=u2079ddce-adf2-4073-b4ed-c8d2cfcc09a&amp;title=&amp;width=922.4" alt="image.png"></li></ul><p>解决跨域问题：<br><a href="https://blog.csdn.net/qq_39390545/article/details/106615075">Springboot处理CORS跨域请求的三种方法_springmvc 中的请求转发 重定向 导致 cors-CSDN博客</a><br>法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>可以通过<span class="meta">@CrossOrigin</span>注解配置某一个方法（contrller类）接受某一个域的请求，</span><br><span class="line"><span class="meta">@CrossOrigin(value = &quot;http://localhost:8081&quot;)</span></span><br><span class="line"> <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;表示hello方法将解释来自http:<span class="comment">//localhost:8081的请求。也就是说该方法可以接受不属于自己域的值</span></span><br><span class="line">如果该注解修饰的是一个controller类，那么表示该控制器的所有方法将可以接受不属于自己域的请求。</span><br></pre></td></tr></table></figure><p>法2：全局配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>).allowedOrigins(<span class="string">&quot;http://localhost:8081&quot;</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .maxAge(<span class="number">30</span> * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.registry.addMapping(&quot;/**&quot;)表示将控制器所有的方法都映射到跨源处理当中，也就是说控制器的所有</span></span><br><span class="line"><span class="comment">// 方法都可以处理来自不同域的请求;</span></span><br><span class="line"><span class="comment">// 2.allowedOrigins表示该控制器允许处理的其他域；</span></span><br><span class="line"><span class="comment">// 3.allowedMethods(&quot;*&quot;)是允许处理所有的请求方法，也就是get,put等等</span></span><br><span class="line"><span class="comment">//4. 可以这样思考：一个请求包括请求地址，请求方式，请求头；所以在addCorsMappings方法中要分别</span></span><br><span class="line"><span class="comment">// 对他们进行处理。</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1699068846815-6ca54bd8-343f-4c8c-9b31-b6a9bd1703c8.png#averageHue=%23b9b9b9&amp;clientId=u8707d90f-a194-4&amp;from=paste&amp;height=134&amp;id=u507bd7a1&amp;originHeight=168&amp;originWidth=1210&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=175723&amp;status=done&amp;style=none&amp;taskId=ud0cb1ccb-c3b0-47cc-af37-4d2d7f740da&amp;title=&amp;width=968" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这里的.maxAge(<span class="number">30</span> * <span class="number">1000</span>)方法的含义是设置预检请求的响应可以被客户端缓存的时间，单位是毫秒。</span><br><span class="line">这样，如果客户端在这个时间内再次发送相同的预检请求，就不需要再次询问服务器，而是直接使用缓存</span><br><span class="line">的响应。这可以提高性能和效率。</span><br><span class="line">预检请求是一种特殊的OPTIONS请求，用于在跨域请求之前检查服务器是否允许该请求。预检请求会携带一些</span><br><span class="line">特定的头信息，如Origin, Access-Control-Request-Method, Access-Control-Request-Headers等，</span><br><span class="line">以告知服务器客户端的请求信息。服务器会根据这些信息返回一个响应，包含一些CORS相关的头信息</span><br><span class="line">，如Access-Control-Allow-Origin, Access-Control-Allow-Methods</span><br><span class="line">, Access-Control-Allow-Headers等，以告知客户端是否允许该请求。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="自定义系统启动定时任务：">自定义系统启动定时任务：</h3><p>1.往spring容器中注入实现CommandLineRunner接口的bean.并重写run方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//oredr代表的启动顺序，数字越小启动越早</span></span><br><span class="line"><span class="meta">@Order(98)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCommandLineRunner2</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyCommandLineRunner2&gt;&gt;&gt;&quot;</span>+Arrays.toString(args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>首先通过 @Compoent 注解将 MyCommandLineRunner1 注册为Spring容器中的一个 Bean。</li><li>添加 @Order注解，表示这个启动任务的执行优先级，因为在一个项目中，启动任务可能有多个，所以需要有一个排序。@Order 注解中，数字越小，优先级越大，默认情况下，优先级的值为 Integer.MAX_VALUE，表示优先级最低。</li><li>在 run 方法中，写启动任务的核心逻辑，当项目启动时，run方法会被自动执行。</li><li>run 方法的参数，来自于项目的启动参数，即项目入口类中，main方法的参数会被传到这里。</li></ol><p>其中启动项目参数的设置：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1699027215737-3f76fcf5-a990-41c1-b55a-2a8d0f4a2d89.png#averageHue=%232d3034&amp;clientId=ucec36595-9ede-4&amp;from=paste&amp;height=557&amp;id=uf6b3bb45&amp;originHeight=696&amp;originWidth=1307&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=80941&amp;status=done&amp;style=none&amp;taskId=u6cf348ff-05b0-47a9-a498-5d0f3937027&amp;title=&amp;width=1045.6" alt="image.png"><br>另一种方式，则是将项目打包，在命令行中启动项目，然后启动时在命令行传入参数，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar devtools-<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT.jar 三国演义 西游记</span><br></pre></td></tr></table></figure><p>2.实现ApplicationRunner<br>ApplicationRunner 可以接收更多类型的参数（ApplicationRunner 除了可以接收 CommandLineRunner 的参数之外，还可以接收 key/value形式的参数）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(98)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplicationRunner1</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs();</span><br><span class="line">        System.out.println(<span class="string">&quot;MyApplicationRunner1&gt;&gt;&gt;&quot;</span>+nonOptionArgs);</span><br><span class="line">        Set&lt;String&gt; optionNames = args.getOptionNames();</span><br><span class="line">        <span class="keyword">for</span> (String key : optionNames) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyApplicationRunner1&gt;&gt;&gt;&quot;</span>+key + <span class="string">&quot;:&quot;</span> + args.getOptionValues(key));</span><br><span class="line">        &#125;</span><br><span class="line">        String[] sourceArgs = args.getSourceArgs();</span><br><span class="line">        System.out.println(<span class="string">&quot;MyApplicationRunner1&gt;&gt;&gt;&quot;</span>+Arrays.toString(sourceArgs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当项目启动时，这里的 run 方法就会被自动执行，关于 run 方法的参数 ApplicationArguments ，我说如下几点：</p><ol><li>args.getNonOptionArgs();可以用来获取命令行中的无key参数（和CommandLineRunner一样）。</li><li>args.getOptionNames();可以用来获取所有key/value形式的参数的key。</li><li>args.getOptionValues(key));可以根据key获取key/value 形式的参数的value。</li><li>args.getSourceArgs(); 则表示获取命令行中的所有参数。</li></ol><p>ApplicationRunner 定义完成后，传启动参数也是两种方式，参数类型也有两种，第一种和 CommandLineRunner 一致，第二种则是 –-key=value 的形式<br>或者使用 如下启动命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar devtools-<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT.jar 三国演义 西游记 --age=<span class="number">99</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1699027440578-37ca5b8f-1ec7-40b9-84d0-b0021ed1e8ba.png#averageHue=%232e3035&amp;clientId=ucec36595-9ede-4&amp;from=paste&amp;height=250&amp;id=u2ea68ea4&amp;originHeight=312&amp;originWidth=1311&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=38886&amp;status=done&amp;style=none&amp;taskId=u40cd6dc6-c2e9-4c32-bbbe-9566398f4ce&amp;title=&amp;width=1048.8" alt="image.png"></p><h3 id="整合Swagger2">整合Swagger2:</h3><h3 id="返回JSON数据：">返回JSON数据：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1699029558493-55ad3d7c-e0ec-47a0-87a5-1fbe6b65e887.png#averageHue=%23c1c1c1&amp;clientId=ucec36595-9ede-4&amp;from=paste&amp;height=246&amp;id=u79c1b3f4&amp;originHeight=307&amp;originWidth=939&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=126216&amp;status=done&amp;style=none&amp;taskId=u92e2689f-b9d8-42d3-84dc-c763c912b08&amp;title=&amp;width=751.2" alt="image.png"><br>@JsonIgnore<br>@JsonFormat</p><h3 id="文件上传：">文件上传：</h3><h4 id="当个文件上传：">当个文件上传：</h4><p>上传后实际文件的路径：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1699065995881-ba07577d-1fb2-4e73-b883-e2b075b6ab8c.png#averageHue=%232e3f60&amp;clientId=u8707d90f-a194-4&amp;from=paste&amp;height=50&amp;id=u80220495&amp;originHeight=62&amp;originWidth=1021&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=49946&amp;status=done&amp;style=none&amp;taskId=ub3f72b4d-fed8-4cfd-bc01-b115cdcdd27&amp;title=&amp;width=816.8" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1699066123309-ccaad666-22dd-4be9-b683-ec039a5a7265.png#averageHue=%23f9f7f5&amp;clientId=u8707d90f-a194-4&amp;from=paste&amp;height=230&amp;id=ua3cef9b1&amp;originHeight=287&amp;originWidth=1030&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=63131&amp;status=done&amp;style=none&amp;taskId=uc7c22aba-2fff-4de9-9665-b30d3d88c69&amp;title=&amp;width=824" alt="image.png"><br>上面的文件夹是服务器每次重启后都会新建一个。之前我做过一个项目是将上传头像的功能，上传的头像放在静态资源的路径下，但是每次上传成功后头像要系统重启后才能访问！会产生这种情况的原因是：静态资源在web访问启动后会被打包在target目录的class目录下。更新的头像更新了原静态文件夹的内容，但是这是没有更新class目录下的图片，只能重启重新打包在 class文件下。因为前端访问的静态资源是打包后class路径下的静态资源，而非服务器我们创建用来存放头像的静态资源。我们可以通过把头像放在上面tomcat生成的文件夹，从而实现文件的实时更新。<br>理解tomcat启动创建的文件夹：<br>上面的文件夹是web服务启动时，在temp目录下创建的。<br><a href="https://www.cnblogs.com/gavincoder/p/13794913.html">SpringBoot设置tomcat临时文件目录必要性 - 马非白即黑 - 博客园</a><br><a href="https://juejin.cn/s/tomcat%20temp%E7%9B%AE%E5%BD%95%E4%BD%9C%E7%94%A8">tomcat temp目录作用-掘金</a><br>文件上传form表单中的entype=&quot;multipart/form-data&quot;的理解：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1699066512036-4b29ca6a-e35f-4662-bd38-211e7586d6da.png#averageHue=%23b6b7b6&amp;clientId=u8707d90f-a194-4&amp;from=paste&amp;height=57&amp;id=u303dd822&amp;originHeight=71&amp;originWidth=947&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=96749&amp;status=done&amp;style=none&amp;taskId=uda3fa412-7da8-4637-be35-de238de8bc9&amp;title=&amp;width=757.6" alt="image.png"><br>multipart是多部分的意思。<br><a href="https://zhuanlan.zhihu.com/p/195726295">entype=&quot;multipart/form-data&quot;是一种指定表单数据的编码方式，它可以让表单同时发送文本和二进制数据，比如文件、图片等。这种编码方式将表单数据分成多个部分，每个部分都有自己的头信息和内容，这样服务器就可以根据头信息来解析不同类型的数据</a><a href="https://zhuanlan.zhihu.com/p/195726295">1</a>。</p><h3 id="配置类和XML：">配置类和XML：</h3><h3 id="拦截器：">拦截器：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1699086129180-f794aa5f-d1fa-42bf-8715-bceea0e76fbe.png#averageHue=%23b6b6b6&amp;clientId=u8707d90f-a194-4&amp;from=paste&amp;height=154&amp;id=u96750bc5&amp;originHeight=192&amp;originWidth=1260&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=258261&amp;status=done&amp;style=none&amp;taskId=ub347e9f5-f197-4655-8c6c-f66adc954e4&amp;title=&amp;width=1008" alt="image.png"></p><h3 id="整合Servlet，Filter-Listener">整合Servlet，Filter,Listener:</h3><h3 id="路径映射：">路径映射：</h3><h3 id="配置AOP：">配置AOP：</h3><h2 id="数据持久化：">数据持久化：</h2><h3 id="JdbcTemplate：">JdbcTemplate：</h3><h3 id="mybatis">mybatis:</h3><p><a href="https://blog.csdn.net/weixin_43944305/article/details/116178864">【精选】使用tk-mapper(通用mapper)自动生成mybatis的mapper/实体/接口_mybatis tkmapper生成接口-CSDN博客</a></p><h3 id="JPA">JPA:</h3><p><a href="https://blog.csdn.net/weixin_48321825/article/details/121953316">nativeQuery = true是什么意思？_@query(nativequery = true_有翅膀的猫的博客-CSDN博客</a><br><a href="https://www.baeldung.com/spring-data-jpa-modifying-annotation">Just a moment…</a></p><h2 id="整合NoSql">整合NoSql:</h2><h2 id="REST：">REST：</h2><p>1.REST风格服务端不储存session,相关的信息要么要么通过客户端的token保存，要么保存在特点的redis中。</p><h3 id="WebSocket">WebSocket:</h3><p><a href="https://juejin.cn/post/6926419575349182477#heading-0">SpringBoot + Vue 实现基于 WebSocket 的聊天室 - 掘金</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1699162382400-919c2099-2242-4b29-9019-41cc2d6e49e7.png#averageHue=%23b9b9b9&amp;clientId=ucddaab6e-692b-4&amp;from=paste&amp;height=363&amp;id=uf6182c7b&amp;originHeight=454&amp;originWidth=1289&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=481655&amp;status=done&amp;style=none&amp;taskId=uca19d7bf-4492-460f-82e7-f71e309e769&amp;title=&amp;width=1031.2" alt="image.png"><br>STOMP 是一种简单的可互操作协议，设计用于通过中介服务器在客户端之间传递异步消息。它为这些客户端和服务器之间传递的消息定义了基于文本的有线格式。<a href="https://stomp.github.io/stomp-specification-1.1.html">STOMP官方文档</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Spring Boot提供了WebSocket的支持，可以使用<span class="meta">@ServerEndpoint</span>注解来标注一个类，</span><br><span class="line">表示该类是一个WebSocket服务器端的处理器。在使用<span class="meta">@ServerEndpoint</span>注解时，</span><br><span class="line">我们还需要为该处理器配置一个ServerEndpointExporter实例，以便能够将其发布到服务器中。</span><br><span class="line"></span><br><span class="line">ServerEndpointExporter是一个Spring Bean，可以通过在配置类中添加<span class="meta">@Bean</span>注解来创建它的实例。</span><br><span class="line">在创建ServerEndpointExporter实例时，我们需要注入ServerEndpointExporter所需的其他Bean</span><br><span class="line">，例如ServerEndpointConfig和MessageConverter等。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html"> &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;/h2&gt;
&lt;h1&gt;Springboot:&lt;/h1&gt;
&lt;h2 id=&quot;入门：&quot;&gt;入门：&lt;/h2&gt;
&lt;h3 id=&quot;ComponentScan注解：&quot;&gt;@Componen</summary>
      
    
    
    
    <category term="springboot2" scheme="http://www.bojiboqi.fun/categories/springboot2/"/>
    
    
    <category term="springboot2" scheme="http://www.bojiboqi.fun/tags/springboot2/"/>
    
  </entry>
  
</feed>
