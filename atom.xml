<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>山麋一笑</title>
  
  
  <link href="http://www.bojiboqi.fun/atom.xml" rel="self"/>
  
  <link href="http://www.bojiboqi.fun/"/>
  <updated>2024-09-25T00:10:39.911Z</updated>
  <id>http://www.bojiboqi.fun/</id>
  
  <author>
    <name>山麋一笑</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IDEA断点</title>
    <link href="http://www.bojiboqi.fun/2024/09/24/IDEA%E6%96%AD%E7%82%B9/"/>
    <id>http://www.bojiboqi.fun/2024/09/24/IDEA%E6%96%AD%E7%82%B9/</id>
    <published>2024-09-24T15:33:01.197Z</published>
    <updated>2024-09-25T00:10:39.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JbAi7">前言</h2>[IDEA 断点调试 debug 会用吗？#69_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1ur4y1P7SV/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=add54d0fcd49c96c6c124259f9775bc3)<h2 id="aWdnn">断点的分类</h2>> 行断点：><ul><li>在某一行产生的断点，代码运行到该行停止</li></ul><blockquote><p>详细断点：</p></blockquote><p>1.按住shfit+鼠标左键产生</p><p>2.<img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1717428840793-c1c27aff-0724-4330-8877-81ebfdd38aa8.png" alt=""></p><p>3.详细断点输出的值</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1717428905027-ea473335-9395-40a2-ba10-5768e606d50e.png" alt=""></p><blockquote><p>方法断点</p></blockquote><ul><li>在方法上打的断点</li><li><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1717428992798-ecd66bd7-a958-404c-b744-478975baee6e.png" alt=""></li><li>会在方法的开始的第一行停止。</li><li>在接口中的方法打方法断点： 在运行的时候会停止在该接口的具体类实现中。</li><li><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1717429633113-9cda131a-b926-48bb-a9c1-7e2be7b4e00c.png" alt="">最后程序停留在其接口实现类中。</li></ul><blockquote><p>异常断点</p></blockquote><ul><li>在一个启动程序中设置了异常代码，最后会停留在抛出异常的那一行代码处。</li><li></li></ul><blockquote><p>属性断点</p></blockquote><p>追踪一个类或者对象属性变化的过程。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1717472651536-50e24cb6-0cef-499d-b667-29318ead8579.png" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1717472620189-5ffd48ad-ac7c-4a2b-a9c4-421f1f9b7232.png" alt=""></p><h2 id="F2lpR">断点的使用:</h2><h4 id="hWIez">断点条件</h4>+ 给断点设置条件，只有当条件满足的时候，程序才再这里停下来；常用于循环，和多线程调试中<p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1717480147386-ca091c27-6c4c-4535-a69e-febe07aaa503.png" alt=""></p><h4 id="f2xNv">参看调试过程中变量的值</h4>![](https://cdn.nlark.com/yuque/0/2024/png/28066124/1717480251020-89cd3eda-c6f9-440b-9c57-cd38a6939099.png)<p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1717480409649-5d7a160f-a27c-4afb-9399-2e9e69191c1e.png" alt=""></p><h4 id="xt7Q4">动态修改变量的值</h4>+ 这调试的时候，我们可以修改断点前面变量的值；从而让断点后面代码有使用到这个变量的时候用我们给这个变量设置的值。+ 当我们这调用接口，可能那个接口这本地是ip受限，这服务器上不是ip受限的。这个时候我们就可以在本地调试的时候将储存接口返回值的变量设置为服务器请求该接口返回的值。<blockquote><p>改变值方法1：</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1718360907570-c98c3891-51b4-4064-b509-41168bf093ec.png" alt=""></p><blockquote><p>方法2</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1718360939918-8cbaa28e-a815-47ce-b468-d4a5a463049f.png" alt=""></p><p>光标停留这name处，按住alt键。</p><h4 id="Wr34Q">多线程的调试</h4>[滑动验证页面](https://segmentfault.com/a/1190000042431321#item-6)<ul><li>多线程调试主要利用断点挂起线程来实现的。<img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1717486772838-0db96dc2-ea94-4bd1-b5bb-81bc97d80d99.png" alt=""></li><li>也可以在条件中设置为某某线程断点</li></ul><h4 id="KTOmz">流处理</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1717516384347-d045e833-8c05-4db7-8aac-ecab43fa806d.png" alt=""></p><ul><li>像上面的这里流链式编程可以使用追踪流发现数据的变化</li><li><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1717516428214-50d4f3c2-36cd-409c-9f44-eb943a93ba3b.png" alt=""></li><li><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1717516473678-65bc1ca0-faa0-419e-8c76-2334f6cb7529.png" alt=""></li></ul><h2 id="a1XvQ">远程Debug</h2>+ 配置本地的run debug<blockquote><p>进入编辑配置</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1717517424660-8a8fdcea-850d-4ed3-b36e-bc96755ffe5c.png" alt=""></p><blockquote><p>选择远程jvm调试</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1717517516816-28c280db-0f5d-4c2c-90fa-504f934abe83.png" alt=""></p><blockquote><p>配置远程debug</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1717517694187-0509e00a-999e-4382-a334-4164d51d087b.png" alt=""></p><blockquote><p>远程服务器以远程debug的形式启动</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xdebug -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=<span class="number">5005</span> -jar remoteDebug-<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT.jar </span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:<span class="number">5005</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1717518081713-085a0d00-0e3d-414f-b30d-7182a0db5b5c.png" alt=""></p><blockquote><p>上面报找不到主清单:<br>解决方法<br>由于我使用的是Centos的虚拟机，默认情况下我们配置了Nat外界是无法访问虚拟机的。我们需要设置端口转发和关闭必要的防火墙</p></blockquote><p><a href="https://www.cnblogs.com/linyijia/p/16190493.html">NAT模式主机访问虚拟机Linux上启动的spring boot项目 - 一佳一 - 博客园</a></p><blockquote><p>本地打断点并调试</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1718119764459-a6b13727-c9fc-4f8a-bef8-55b101976759.png" alt=""></p><p>出现这种情况就表示已经连接到了远程服务器了。</p><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JbAi7&quot;&gt;前言&lt;/h2&gt;
[IDEA 断点调试 debug 会用吗？#69_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1ur4y1P7SV/?spm_id_from=333.1007.top_right_b</summary>
      
    
    
    
    <category term="java" scheme="http://www.bojiboqi.fun/categories/java/"/>
    
    
    <category term="断点" scheme="http://www.bojiboqi.fun/tags/%E6%96%AD%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>SQL-递归查询（with recursive）</title>
    <link href="http://www.bojiboqi.fun/2024/09/24/26-%E8%BF%9B%E9%98%B6SQL-%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2%EF%BC%88with%20recursive%EF%BC%89/"/>
    <id>http://www.bojiboqi.fun/2024/09/24/26-%E8%BF%9B%E9%98%B6SQL-%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2%EF%BC%88with%20recursive%EF%BC%89/</id>
    <published>2024-09-24T15:31:35.465Z</published>
    <updated>2024-09-24T16:02:24.896Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL with Recursive是一种基于递归思想的MySQL查询方式，可以实现对数据的递归查询和处理，返回符合条件的数据，在MySQL 8.0版本中，该功能被正式引入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WITH RECURSIVE cte_name (column_list) AS (</span><br><span class="line">    SELECT initial_query_result</span><br><span class="line">    UNION [ALL]</span><br><span class="line">    SELECT recursive_query</span><br><span class="line">    FROM cte_name</span><br><span class="line">    WHERE condition</span><br><span class="line">)</span><br><span class="line">SELECT * FROM cte_name;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 创建表</span><br><span class="line">DROP TABLE IF EXISTS `sys_region`;</span><br><span class="line">CREATE TABLE sys_region  (</span><br><span class="line">  id int NOT NULL AUTO_INCREMENT COMMENT &#x27;地区主键编号&#x27;,</span><br><span class="line">  name varchar(50) COMMENT &#x27;地区名称&#x27;,</span><br><span class="line">  short_name varchar(50) COMMENT &#x27;简称&#x27;,</span><br><span class="line">  code varchar(50) COMMENT &#x27;行政地区编号&#x27;,</span><br><span class="line">  parent_code varchar(50) COMMENT &#x27;父id&#x27;,</span><br><span class="line">  level int(2)  COMMENT &#x27;1级：省、直辖市、自治区\r\n2级：地级市\r\n3级：市辖区、县（旗）、县级市、自治县（自治旗）、特区、林区\r\n4级：镇、乡、民族乡、县辖区、街道\r\n5级：村、居委会&#x27;,</span><br><span class="line">  flag int(1) COMMENT &#x27;0:正常 1废弃&#x27;,</span><br><span class="line">  PRIMARY KEY (id) USING BTREE</span><br><span class="line">) ENGINE = InnoDB AUTO_INCREMENT = 182 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = &#x27;地区表&#x27; ROW_FORMAT = Dynamic;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line">-- 插入数据</span><br><span class="line">INSERT INTO sys_region </span><br><span class="line">VALUES </span><br><span class="line">(1, &quot;山东省&quot;, &quot;鲁&quot;, &quot;370000000000&quot;, NULL, 1, 0),</span><br><span class="line">(2, &quot;济南市&quot;, &quot;济南&quot;, &quot;370100000000&quot;, &quot;370000000000&quot;, 2, 0),</span><br><span class="line">(3, &quot;市辖区&quot;, &quot;市辖区&quot;, &quot;370101000000&quot;, &quot;370100000000&quot;, 3, 0),</span><br><span class="line">(4, &quot;历下区&quot;, &quot;历下区&quot;, &quot;370102000000&quot;, &quot;370100000000&quot;, 3, 0),</span><br><span class="line">(5, &quot;市中区&quot;, &quot;市中区&quot;, &quot;370103000000&quot;, &quot;370100000000&quot;, 3, 0),</span><br><span class="line">(6, &quot;槐荫区&quot;, &quot;槐荫区&quot;, &quot;370104000000&quot;, &quot;370100000000&quot;, 3, 0),</span><br><span class="line">(7, &quot;天桥区&quot;, &quot;天桥区&quot;, &quot;370105000000&quot;, &quot;370100000000&quot;, 3, 0),</span><br><span class="line">(8, &quot;历城区&quot;, &quot;历城区&quot;, &quot;370112000000&quot;, &quot;370100000000&quot;, 3, 0),</span><br><span class="line">(9, &quot;长清区&quot;, &quot;长清区&quot;, &quot;370113000000&quot;, &quot;370100000000&quot;, 3, 0),</span><br><span class="line">(10, &quot;章丘区&quot;, &quot;章丘区&quot;, &quot;370114000000&quot;, &quot;370100000000&quot;, 3, 0),</span><br><span class="line">(11, &quot;济阳区&quot;, &quot;济阳区&quot;, &quot;370115000000&quot;, &quot;370100000000&quot;, 3, 0),</span><br><span class="line">(12, &quot;莱芜区&quot;, &quot;莱芜区&quot;, &quot;370116000000&quot;, &quot;370100000000&quot;, 3, 0),</span><br><span class="line">(13, &quot;钢城区&quot;, &quot;钢城区&quot;, &quot;370117000000&quot;, &quot;370100000000&quot;, 3, 0),</span><br><span class="line">(14, &quot;平阴县&quot;, &quot;平阴县&quot;, &quot;370124000000&quot;, &quot;370100000000&quot;, 3, 0),</span><br><span class="line">(15, &quot;商河县&quot;, &quot;商河县&quot;, &quot;370126000000&quot;, &quot;370100000000&quot;, 3, 0),</span><br><span class="line">(16, &quot;济南高新技术产业开发区&quot;, &quot;高新区&quot;, &quot;370171000000&quot;, &quot;370100000000&quot;, 3, 0),</span><br><span class="line">(17, &quot;解放路街道&quot;, &quot;解放路街道&quot;, &quot;370102001000&quot;, &quot;370102000000&quot;, 4, 0),</span><br><span class="line">(18, &quot;千佛山街道&quot;, &quot;千佛山街道&quot;, &quot;370102002000&quot;, &quot;370102000000&quot;, 4, 0),</span><br><span class="line">(19, &quot;趵突泉街道&quot;, &quot;趵突泉街道&quot;, &quot;370102003000&quot;, &quot;370102000000&quot;, 4, 0),</span><br><span class="line">(20, &quot;泉城路街道&quot;, &quot;泉城路街道&quot;, &quot;370102004000&quot;, &quot;370102000000&quot;, 4, 0),</span><br><span class="line">(21, &quot;大明湖街道&quot;, &quot;大明湖街道&quot;, &quot;370102005000&quot;, &quot;370102000000&quot;, 4, 0),</span><br><span class="line">(22, &quot;东关街道&quot;, &quot;东关街道&quot;, &quot;370102006000&quot;, &quot;370102000000&quot;, 4, 0),</span><br><span class="line">(23, &quot;文东街道&quot;, &quot;文东街道&quot;, &quot;370102007000&quot;, &quot;370102000000&quot;, 4, 0),</span><br><span class="line">(24, &quot;建新街道&quot;, &quot;建新街道&quot;, &quot;370102008000&quot;, &quot;370102000000&quot;, 4, 0),</span><br><span class="line">(25, &quot;甸柳街道&quot;, &quot;甸柳街道&quot;, &quot;370102009000&quot;, &quot;370102000000&quot;, 4, 0),</span><br><span class="line">(26, &quot;燕山街道&quot;, &quot;燕山街道&quot;, &quot;370102010000&quot;, &quot;370102000000&quot;, 4, 0),</span><br><span class="line">(27, &quot;姚家街道&quot;, &quot;姚家街道&quot;, &quot;370102011000&quot;, &quot;370102000000&quot;, 4, 0),</span><br><span class="line">(28, &quot;龙洞街道&quot;, &quot;龙洞街道&quot;, &quot;370102012000&quot;, &quot;370102000000&quot;, 4, 0),</span><br><span class="line">(29, &quot;智远街道&quot;, &quot;智远街道&quot;, &quot;370102013000&quot;, &quot;370102000000&quot;, 4, 0),</span><br><span class="line">(30, &quot;大观园街道&quot;, &quot;大观园街道&quot;, &quot;370103002000&quot;, &quot;370103000000&quot;, 4, 0),</span><br><span class="line">(31, &quot;杆石桥街道&quot;, &quot;杆石桥街道&quot;, &quot;370103003000&quot;, &quot;370103000000&quot;, 4, 0),</span><br><span class="line">(32, &quot;四里村街道&quot;, &quot;四里村街道&quot;, &quot;370103004000&quot;, &quot;370103000000&quot;, 4, 0),</span><br><span class="line">(33, &quot;魏家庄街道&quot;, &quot;魏家庄街道&quot;, &quot;370103006000&quot;, &quot;370103000000&quot;, 4, 0),</span><br><span class="line">(34, &quot;二七街道&quot;, &quot;二七街道&quot;, &quot;370103008000&quot;, &quot;370103000000&quot;, 4, 0),</span><br><span class="line">(35, &quot;七里山街道&quot;, &quot;七里山街道&quot;, &quot;370103009000&quot;, &quot;370103000000&quot;, 4, 0),</span><br><span class="line">(36, &quot;六里山街道&quot;, &quot;六里山街道&quot;, &quot;370103010000&quot;, &quot;370103000000&quot;, 4, 0),</span><br><span class="line">(37, &quot;舜玉路街道&quot;, &quot;舜玉路街道&quot;, &quot;370103012000&quot;, &quot;370103000000&quot;, 4, 0),</span><br><span class="line">(38, &quot;泺源街道&quot;, &quot;泺源街道&quot;, &quot;370103014000&quot;, &quot;370103000000&quot;, 4, 0),</span><br><span class="line">(39, &quot;王官庄街道&quot;, &quot;王官庄街道&quot;, &quot;370103015000&quot;, &quot;370103000000&quot;, 4, 0),</span><br><span class="line">(40, &quot;舜耕街道&quot;, &quot;舜耕街道&quot;, &quot;370103016000&quot;, &quot;370103000000&quot;, 4, 0),</span><br><span class="line">(41, &quot;白马山街道&quot;, &quot;白马山街道&quot;, &quot;370103017000&quot;, &quot;370103000000&quot;, 4, 0),</span><br><span class="line">(42, &quot;七贤街道&quot;, &quot;七贤街道&quot;, &quot;370103018000&quot;, &quot;370103000000&quot;, 4, 0),</span><br><span class="line">(43, &quot;十六里河街道&quot;, &quot;十六里河街道&quot;, &quot;370103019000&quot;, &quot;370103000000&quot;, 4, 0),</span><br><span class="line">(44, &quot;兴隆街道&quot;, &quot;兴隆街道&quot;, &quot;370103020000&quot;, &quot;370103000000&quot;, 4, 0),</span><br><span class="line">(45, &quot;党家街道&quot;, &quot;党家街道&quot;, &quot;370103021000&quot;, &quot;370103000000&quot;, 4, 0),</span><br><span class="line">(46, &quot;陡沟街道&quot;, &quot;陡沟街道&quot;, &quot;370103022000&quot;, &quot;370103000000&quot;, 4, 0),</span><br><span class="line">(47, &quot;振兴街街道&quot;, &quot;振兴街街道&quot;, &quot;370104001000&quot;, &quot;370104000000&quot;, 4, 0),</span><br><span class="line">(48, &quot;中大槐树街道&quot;, &quot;中大槐树街道&quot;, &quot;370104002000&quot;, &quot;370104000000&quot;, 4, 0),</span><br><span class="line">(49, &quot;道德街街道&quot;, &quot;道德街街道&quot;, &quot;370104003000&quot;, &quot;370104000000&quot;, 4, 0),</span><br><span class="line">(50, &quot;西市场街道&quot;, &quot;西市场街道&quot;, &quot;370104004000&quot;, &quot;370104000000&quot;, 4, 0),</span><br><span class="line">(51, &quot;五里沟街道&quot;, &quot;五里沟街道&quot;, &quot;370104005000&quot;, &quot;370104000000&quot;, 4, 0),</span><br><span class="line">(52, &quot;营市街街道&quot;, &quot;营市街街道&quot;, &quot;370104006000&quot;, &quot;370104000000&quot;, 4, 0),</span><br><span class="line">(53, &quot;青年公园街道&quot;, &quot;青年公园街道&quot;, &quot;370104007000&quot;, &quot;370104000000&quot;, 4, 0),</span><br><span class="line">(54, &quot;南辛庄街道&quot;, &quot;南辛庄街道&quot;, &quot;370104008000&quot;, &quot;370104000000&quot;, 4, 0),</span><br><span class="line">(55, &quot;段店北路街道&quot;, &quot;段店北路街道&quot;, &quot;370104009000&quot;, &quot;370104000000&quot;, 4, 0),</span><br><span class="line">(56, &quot;张庄路街道&quot;, &quot;张庄路街道&quot;, &quot;370104010000&quot;, &quot;370104000000&quot;, 4, 0),</span><br><span class="line">(57, &quot;匡山街道&quot;, &quot;匡山街道&quot;, &quot;370104011000&quot;, &quot;370104000000&quot;, 4, 0),</span><br><span class="line">(58, &quot;美里湖街道&quot;, &quot;美里湖街道&quot;, &quot;370104012000&quot;, &quot;370104000000&quot;, 4, 0),</span><br><span class="line">(59, &quot;腊山街道&quot;, &quot;腊山街道&quot;, &quot;370104013000&quot;, &quot;370104000000&quot;, 4, 0),</span><br><span class="line">(60, &quot;兴福街道&quot;, &quot;兴福街道&quot;, &quot;370104014000&quot;, &quot;370104000000&quot;, 4, 0),</span><br><span class="line">(61, &quot;玉清湖街道&quot;, &quot;玉清湖街道&quot;, &quot;370104015000&quot;, &quot;370104000000&quot;, 4, 0),</span><br><span class="line">(62, &quot;吴家堡街道&quot;, &quot;吴家堡街道&quot;, &quot;370104016000&quot;, &quot;370104000000&quot;, 4, 0),</span><br><span class="line">(63, &quot;无影山街道&quot;, &quot;无影山街道&quot;, &quot;370105001000&quot;, &quot;370105000000&quot;, 4, 0),</span><br><span class="line">(64, &quot;天桥东街街道&quot;, &quot;天桥东街街道&quot;, &quot;370105003000&quot;, &quot;370105000000&quot;, 4, 0),</span><br><span class="line">(65, &quot;北村街道&quot;, &quot;北村街道&quot;, &quot;370105004000&quot;, &quot;370105000000&quot;, 4, 0),</span><br><span class="line">(66, &quot;南村街道&quot;, &quot;南村街道&quot;, &quot;370105005000&quot;, &quot;370105000000&quot;, 4, 0),</span><br><span class="line">(67, &quot;堤口路街道&quot;, &quot;堤口路街道&quot;, &quot;370105006000&quot;, &quot;370105000000&quot;, 4, 0),</span><br><span class="line">(68, &quot;北坦街道&quot;, &quot;北坦街道&quot;, &quot;370105007000&quot;, &quot;370105000000&quot;, 4, 0),</span><br><span class="line">(69, &quot;制锦市街道&quot;, &quot;制锦市街道&quot;, &quot;370105009000&quot;, &quot;370105000000&quot;, 4, 0),</span><br><span class="line">(70, &quot;宝华街道&quot;, &quot;宝华街道&quot;, &quot;370105010000&quot;, &quot;370105000000&quot;, 4, 0),</span><br><span class="line">(71, &quot;官扎营街道&quot;, &quot;官扎营街道&quot;, &quot;370105011000&quot;, &quot;370105000000&quot;, 4, 0),</span><br><span class="line">(72, &quot;纬北路街道&quot;, &quot;纬北路街道&quot;, &quot;370105012000&quot;, &quot;370105000000&quot;, 4, 0),</span><br><span class="line">(73, &quot;药山街道&quot;, &quot;药山街道&quot;, &quot;370105013000&quot;, &quot;370105000000&quot;, 4, 0),</span><br><span class="line">(74, &quot;北园街道&quot;, &quot;北园街道&quot;, &quot;370105014000&quot;, &quot;370105000000&quot;, 4, 0),</span><br><span class="line">(75, &quot;泺口街道&quot;, &quot;泺口街道&quot;, &quot;370105015000&quot;, &quot;370105000000&quot;, 4, 0),</span><br><span class="line">(76, &quot;桑梓店街道&quot;, &quot;桑梓店街道&quot;, &quot;370105016000&quot;, &quot;370105000000&quot;, 4, 0),</span><br><span class="line">(77, &quot;大桥街道&quot;, &quot;大桥街道&quot;, &quot;370105017000&quot;, &quot;370105000000&quot;, 4, 0),</span><br><span class="line">(78, &quot;山大路街道&quot;, &quot;山大路街道&quot;, &quot;370112001000&quot;, &quot;370112000000&quot;, 4, 0),</span><br><span class="line">(79, &quot;洪家楼街道&quot;, &quot;洪家楼街道&quot;, &quot;370112002000&quot;, &quot;370112000000&quot;, 4, 0),</span><br><span class="line">(80, &quot;东风街道&quot;, &quot;东风街道&quot;, &quot;370112003000&quot;, &quot;370112000000&quot;, 4, 0),</span><br><span class="line">(81, &quot;全福街道&quot;, &quot;全福街道&quot;, &quot;370112004000&quot;, &quot;370112000000&quot;, 4, 0),</span><br><span class="line">(82, &quot;华山街道&quot;, &quot;华山街道&quot;, &quot;370112007000&quot;, &quot;370112000000&quot;, 4, 0),</span><br><span class="line">(83, &quot;荷花路街道&quot;, &quot;荷花路街道&quot;, &quot;370112008000&quot;, &quot;370112000000&quot;, 4, 0),</span><br><span class="line">(84, &quot;王舍人街道&quot;, &quot;王舍人街道&quot;, &quot;370112009000&quot;, &quot;370112000000&quot;, 4, 0),</span><br><span class="line">(85, &quot;鲍山街道&quot;, &quot;鲍山街道&quot;, &quot;370112010000&quot;, &quot;370112000000&quot;, 4, 0),</span><br><span class="line">(86, &quot;郭店街道&quot;, &quot;郭店街道&quot;, &quot;370112011000&quot;, &quot;370112000000&quot;, 4, 0),</span><br><span class="line">(87, &quot;唐冶街道&quot;, &quot;唐冶街道&quot;, &quot;370112012000&quot;, &quot;370112000000&quot;, 4, 0),</span><br><span class="line">(88, &quot;港沟街道&quot;, &quot;港沟街道&quot;, &quot;370112013000&quot;, &quot;370112000000&quot;, 4, 0),</span><br><span class="line">(89, &quot;董家街道&quot;, &quot;董家街道&quot;, &quot;370112016000&quot;, &quot;370112000000&quot;, 4, 0),</span><br><span class="line">(90, &quot;彩石街道&quot;, &quot;彩石街道&quot;, &quot;370112017000&quot;, &quot;370112000000&quot;, 4, 0),</span><br><span class="line">(91, &quot;仲宫街道&quot;, &quot;仲宫街道&quot;, &quot;370112018000&quot;, &quot;370112000000&quot;, 4, 0),</span><br><span class="line">(92, &quot;柳埠街道&quot;, &quot;柳埠街道&quot;, &quot;370112019000&quot;, &quot;370112000000&quot;, 4, 0),</span><br><span class="line">(93, &quot;唐王街道&quot;, &quot;唐王街道&quot;, &quot;370112020000&quot;, &quot;370112000000&quot;, 4, 0),</span><br><span class="line">(94, &quot;西营街道&quot;, &quot;西营街道&quot;, &quot;370112021000&quot;, &quot;370112000000&quot;, 4, 0),</span><br><span class="line">(95, &quot;文昌街道&quot;, &quot;文昌街道&quot;, &quot;370113001000&quot;, &quot;370113000000&quot;, 4, 0),</span><br><span class="line">(96, &quot;崮云湖街道&quot;, &quot;崮云湖街道&quot;, &quot;370113002000&quot;, &quot;370113000000&quot;, 4, 0),</span><br><span class="line">(97, &quot;平安街道&quot;, &quot;平安街道&quot;, &quot;370113003000&quot;, &quot;370113000000&quot;, 4, 0),</span><br><span class="line">(98, &quot;五峰山街道&quot;, &quot;五峰山街道&quot;, &quot;370113004000&quot;, &quot;370113000000&quot;, 4, 0),</span><br><span class="line">(99, &quot;归德街道&quot;, &quot;归德街道&quot;, &quot;370113005000&quot;, &quot;370113000000&quot;, 4, 0),</span><br><span class="line">(100, &quot;张夏街道&quot;, &quot;张夏街道&quot;, &quot;370113006000&quot;, &quot;370113000000&quot;, 4, 0),</span><br><span class="line">(101, &quot;万德街道&quot;, &quot;万德街道&quot;, &quot;370113007000&quot;, &quot;370113000000&quot;, 4, 0),</span><br><span class="line">(102, &quot;孝里镇&quot;, &quot;孝里镇&quot;, &quot;370113102000&quot;, &quot;370113000000&quot;, 4, 0),</span><br><span class="line">(103, &quot;马山镇&quot;, &quot;马山镇&quot;, &quot;370113107000&quot;, &quot;370113000000&quot;, 4, 0),</span><br><span class="line">(104, &quot;双泉镇&quot;, &quot;双泉镇&quot;, &quot;370113108000&quot;, &quot;370113000000&quot;, 4, 0),</span><br><span class="line">(105, &quot;明水街道&quot;, &quot;明水街道&quot;, &quot;370114001000&quot;, &quot;370114000000&quot;, 4, 0),</span><br><span class="line">(106, &quot;双山街道&quot;, &quot;双山街道&quot;, &quot;370114002000&quot;, &quot;370114000000&quot;, 4, 0),</span><br><span class="line">(107, &quot;枣园街道&quot;, &quot;枣园街道&quot;, &quot;370114003000&quot;, &quot;370114000000&quot;, 4, 0),</span><br><span class="line">(108, &quot;龙山街道&quot;, &quot;龙山街道&quot;, &quot;370114004000&quot;, &quot;370114000000&quot;, 4, 0),</span><br><span class="line">(109, &quot;埠村街道&quot;, &quot;埠村街道&quot;, &quot;370114005000&quot;, &quot;370114000000&quot;, 4, 0),</span><br><span class="line">(110, &quot;圣井街道&quot;, &quot;圣井街道&quot;, &quot;370114006000&quot;, &quot;370114000000&quot;, 4, 0),</span><br><span class="line">(111, &quot;普集街道&quot;, &quot;普集街道&quot;, &quot;370114007000&quot;, &quot;370114000000&quot;, 4, 0),</span><br><span class="line">(112, &quot;绣惠街道&quot;, &quot;绣惠街道&quot;, &quot;370114008000&quot;, &quot;370114000000&quot;, 4, 0),</span><br><span class="line">(113, &quot;相公庄街道&quot;, &quot;相公庄街道&quot;, &quot;370114009000&quot;, &quot;370114000000&quot;, 4, 0),</span><br><span class="line">(114, &quot;文祖街道&quot;, &quot;文祖街道&quot;, &quot;370114010000&quot;, &quot;370114000000&quot;, 4, 0),</span><br><span class="line">(115, &quot;官庄街道&quot;, &quot;官庄街道&quot;, &quot;370114011000&quot;, &quot;370114000000&quot;, 4, 0),</span><br><span class="line">(116, &quot;高官寨街道&quot;, &quot;高官寨街道&quot;, &quot;370114012000&quot;, &quot;370114000000&quot;, 4, 0),</span><br><span class="line">(117, &quot;白云湖街道&quot;, &quot;白云湖街道&quot;, &quot;370114013000&quot;, &quot;370114000000&quot;, 4, 0),</span><br><span class="line">(118, &quot;宁家埠街道&quot;, &quot;宁家埠街道&quot;, &quot;370114014000&quot;, &quot;370114000000&quot;, 4, 0),</span><br><span class="line">(119, &quot;曹范街道&quot;, &quot;曹范街道&quot;, &quot;370114015000&quot;, &quot;370114000000&quot;, 4, 0),</span><br><span class="line">(120, &quot;***镇&quot;, &quot;***镇&quot;, &quot;370114100000&quot;, &quot;370114000000&quot;, 4, 0),</span><br><span class="line">(121, &quot;垛庄镇&quot;, &quot;垛庄镇&quot;, &quot;370114101000&quot;, &quot;370114000000&quot;, 4, 0),</span><br><span class="line">(122, &quot;黄河镇&quot;, &quot;黄河镇&quot;, &quot;370114102000&quot;, &quot;370114000000&quot;, 4, 0),</span><br><span class="line">(123, &quot;济阳街道&quot;, &quot;济阳街道&quot;, &quot;370115001000&quot;, &quot;370115000000&quot;, 4, 0),</span><br><span class="line">(124, &quot;济北街道&quot;, &quot;济北街道&quot;, &quot;370115002000&quot;, &quot;370115000000&quot;, 4, 0),</span><br><span class="line">(125, &quot;崔寨街道&quot;, &quot;崔寨街道&quot;, &quot;370115003000&quot;, &quot;370115000000&quot;, 4, 0),</span><br><span class="line">(126, &quot;孙耿街道&quot;, &quot;孙耿街道&quot;, &quot;370115004000&quot;, &quot;370115000000&quot;, 4, 0),</span><br><span class="line">(127, &quot;回河街道&quot;, &quot;回河街道&quot;, &quot;370115005000&quot;, &quot;370115000000&quot;, 4, 0),</span><br><span class="line">(128, &quot;太平街道&quot;, &quot;太平街道&quot;, &quot;370115006000&quot;, &quot;370115000000&quot;, 4, 0),</span><br><span class="line">(129, &quot;垛石镇&quot;, &quot;垛石镇&quot;, &quot;370115101000&quot;, &quot;370115000000&quot;, 4, 0),</span><br><span class="line">(130, &quot;曲堤镇&quot;, &quot;曲堤镇&quot;, &quot;370115103000&quot;, &quot;370115000000&quot;, 4, 0),</span><br><span class="line">(131, &quot;仁风镇&quot;, &quot;仁风镇&quot;, &quot;370115104000&quot;, &quot;370115000000&quot;, 4, 0),</span><br><span class="line">(132, &quot;新市镇&quot;, &quot;新市镇&quot;, &quot;370115110000&quot;, &quot;370115000000&quot;, 4, 0),</span><br><span class="line">(133, &quot;凤城街道&quot;, &quot;凤城街道&quot;, &quot;370116001000&quot;, &quot;370116000000&quot;, 4, 0),</span><br><span class="line">(134, &quot;张家洼街道&quot;, &quot;张家洼街道&quot;, &quot;370116002000&quot;, &quot;370116000000&quot;, 4, 0),</span><br><span class="line">(135, &quot;高庄街道&quot;, &quot;高庄街道&quot;, &quot;370116003000&quot;, &quot;370116000000&quot;, 4, 0),</span><br><span class="line">(136, &quot;鹏泉街道&quot;, &quot;鹏泉街道&quot;, &quot;370116004000&quot;, &quot;370116000000&quot;, 4, 0),</span><br><span class="line">(137, &quot;口镇&quot;, &quot;口镇&quot;, &quot;370116100000&quot;, &quot;370116000000&quot;, 4, 0),</span><br><span class="line">(138, &quot;羊里镇&quot;, &quot;羊里镇&quot;, &quot;370116101000&quot;, &quot;370116000000&quot;, 4, 0),</span><br><span class="line">(139, &quot;方下镇&quot;, &quot;方下镇&quot;, &quot;370116102000&quot;, &quot;370116000000&quot;, 4, 0),</span><br><span class="line">(140, &quot;牛泉镇&quot;, &quot;牛泉镇&quot;, &quot;370116103000&quot;, &quot;370116000000&quot;, 4, 0),</span><br><span class="line">(141, &quot;苗山镇&quot;, &quot;苗山镇&quot;, &quot;370116104000&quot;, &quot;370116000000&quot;, 4, 0),</span><br><span class="line">(142, &quot;雪野镇&quot;, &quot;雪野镇&quot;, &quot;370116105000&quot;, &quot;370116000000&quot;, 4, 0),</span><br><span class="line">(143, &quot;大王庄镇&quot;, &quot;大王庄镇&quot;, &quot;370116106000&quot;, &quot;370116000000&quot;, 4, 0),</span><br><span class="line">(144, &quot;寨里镇&quot;, &quot;寨里镇&quot;, &quot;370116107000&quot;, &quot;370116000000&quot;, 4, 0),</span><br><span class="line">(145, &quot;杨庄镇&quot;, &quot;杨庄镇&quot;, &quot;370116108000&quot;, &quot;370116000000&quot;, 4, 0),</span><br><span class="line">(146, &quot;茶业口镇&quot;, &quot;茶业口镇&quot;, &quot;370116109000&quot;, &quot;370116000000&quot;, 4, 0),</span><br><span class="line">(147, &quot;和庄镇&quot;, &quot;和庄镇&quot;, &quot;370116110000&quot;, &quot;370116000000&quot;, 4, 0),</span><br><span class="line">(148, &quot;艾山街道&quot;, &quot;艾山街道&quot;, &quot;370117001000&quot;, &quot;370117000000&quot;, 4, 0),</span><br><span class="line">(149, &quot;里辛街道&quot;, &quot;里辛街道&quot;, &quot;370117002000&quot;, &quot;370117000000&quot;, 4, 0),</span><br><span class="line">(150, &quot;汶源街道&quot;, &quot;汶源街道&quot;, &quot;370117003000&quot;, &quot;370117000000&quot;, 4, 0),</span><br><span class="line">(151, &quot;颜庄镇&quot;, &quot;颜庄镇&quot;, &quot;370117100000&quot;, &quot;370117000000&quot;, 4, 0),</span><br><span class="line">(152, &quot;辛庄镇&quot;, &quot;辛庄镇&quot;, &quot;370117103000&quot;, &quot;370117000000&quot;, 4, 0),</span><br><span class="line">(153, &quot;棋山国家森林公园&quot;, &quot;棋山国家森林公园&quot;, &quot;370117400000&quot;, &quot;370117000000&quot;, 4, 0),</span><br><span class="line">(154, &quot;高新技术开发区&quot;, &quot;高新技术开发区&quot;, &quot;370117401000&quot;, &quot;370117000000&quot;, 4, 0),</span><br><span class="line">(155, &quot;榆山街道&quot;, &quot;榆山街道&quot;, &quot;370124001000&quot;, &quot;370124000000&quot;, 4, 0),</span><br><span class="line">(156, &quot;锦水街道&quot;, &quot;锦水街道&quot;, &quot;370124002000&quot;, &quot;370124000000&quot;, 4, 0),</span><br><span class="line">(157, &quot;东阿镇&quot;, &quot;东阿镇&quot;, &quot;370124102000&quot;, &quot;370124000000&quot;, 4, 0),</span><br><span class="line">(158, &quot;孝直镇&quot;, &quot;孝直镇&quot;, &quot;370124103000&quot;, &quot;370124000000&quot;, 4, 0),</span><br><span class="line">(159, &quot;孔村镇&quot;, &quot;孔村镇&quot;, &quot;370124104000&quot;, &quot;370124000000&quot;, 4, 0),</span><br><span class="line">(160, &quot;洪范池镇&quot;, &quot;洪范池镇&quot;, &quot;370124105000&quot;, &quot;370124000000&quot;, 4, 0),</span><br><span class="line">(161, &quot;玫瑰镇&quot;, &quot;玫瑰镇&quot;, &quot;370124106000&quot;, &quot;370124000000&quot;, 4, 0),</span><br><span class="line">(162, &quot;安城镇&quot;, &quot;安城镇&quot;, &quot;370124107000&quot;, &quot;370124000000&quot;, 4, 0),</span><br><span class="line">(163, &quot;许商街道&quot;, &quot;许商街道&quot;, &quot;370126001000&quot;, &quot;370126000000&quot;, 4, 0),</span><br><span class="line">(164, &quot;殷巷镇&quot;, &quot;殷巷镇&quot;, &quot;370126101000&quot;, &quot;370126000000&quot;, 4, 0),</span><br><span class="line">(165, &quot;怀仁镇&quot;, &quot;怀仁镇&quot;, &quot;370126102000&quot;, &quot;370126000000&quot;, 4, 0),</span><br><span class="line">(166, &quot;龙桑寺镇&quot;, &quot;龙桑寺镇&quot;, &quot;370126104000&quot;, &quot;370126000000&quot;, 4, 0),</span><br><span class="line">(167, &quot;郑路镇&quot;, &quot;郑路镇&quot;, &quot;370126105000&quot;, &quot;370126000000&quot;, 4, 0),</span><br><span class="line">(168, &quot;贾庄镇&quot;, &quot;贾庄镇&quot;, &quot;370126106000&quot;, &quot;370126000000&quot;, 4, 0),</span><br><span class="line">(169, &quot;玉皇庙镇&quot;, &quot;玉皇庙镇&quot;, &quot;370126107000&quot;, &quot;370126000000&quot;, 4, 0),</span><br><span class="line">(170, &quot;白桥镇&quot;, &quot;白桥镇&quot;, &quot;370126108000&quot;, &quot;370126000000&quot;, 4, 0),</span><br><span class="line">(171, &quot;孙集镇&quot;, &quot;孙集镇&quot;, &quot;370126109000&quot;, &quot;370126000000&quot;, 4, 0),</span><br><span class="line">(172, &quot;韩庙镇&quot;, &quot;韩庙镇&quot;, &quot;370126110000&quot;, &quot;370126000000&quot;, 4, 0),</span><br><span class="line">(173, &quot;沙河镇&quot;, &quot;沙河镇&quot;, &quot;370126111000&quot;, &quot;370126000000&quot;, 4, 0),</span><br><span class="line">(174, &quot;张坊镇&quot;, &quot;张坊镇&quot;, &quot;370126112000&quot;, &quot;370126000000&quot;, 4, 0),</span><br><span class="line">(175, &quot;舜华路街道&quot;, &quot;舜华路街道&quot;, &quot;370171001000&quot;, &quot;370171000000&quot;, 4, 0),</span><br><span class="line">(176, &quot;孙村街道&quot;, &quot;孙村街道&quot;, &quot;370171002000&quot;, &quot;370171000000&quot;, 4, 0),</span><br><span class="line">(177, &quot;巨野河街道&quot;, &quot;巨野河街道&quot;, &quot;370171003000&quot;, &quot;370171000000&quot;, 4, 0),</span><br><span class="line">(178, &quot;遥墙街道&quot;, &quot;遥墙街道&quot;, &quot;370171004000&quot;, &quot;370171000000&quot;, 4, 0),</span><br><span class="line">(179, &quot;临港街道&quot;, &quot;临港街道&quot;, &quot;370171005000&quot;, &quot;370171000000&quot;, 4, 0),</span><br><span class="line">(180, &quot;创新谷街道办事处&quot;, &quot;创新谷街道办事处&quot;, &quot;370171400000&quot;, &quot;370171000000&quot;, 4, 0),</span><br><span class="line">(181, &quot;章锦街道&quot;, &quot;章锦街道&quot;, &quot;370171401000&quot;, &quot;370171000000&quot;, 4, 0);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 查询子节点  含自己</span><br><span class="line">WITH RECURSIVE recursion (id, name, short_name, code, parent_code, level, flag) AS (</span><br><span class="line">    SELECT T1.id, T1.name, T1.short_name, T1.code, T1.parent_code, T1.level, T1.flag  </span><br><span class="line">    FROM sys_region T1</span><br><span class="line">    WHERE T1.code=&#x27;370000000000&#x27;</span><br><span class="line">    UNION ALL</span><br><span class="line">    SELECT T2.id, T2.name, T2.short_name, T2.code, T2.parent_code, T2.level, T2.flag</span><br><span class="line">    FROM sys_region T2, recursion T3</span><br><span class="line">    WHERE T2.parent_code=T3.code</span><br><span class="line">)</span><br><span class="line">SELECT T.id, T.name, T.short_name, T.code, T.parent_code, T.level, T.flag FROM recursion T;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 查询子节点 不含自己</span><br><span class="line">WITH RECURSIVE recursion (id, name, short_name, code, parent_code, level, flag) AS(</span><br><span class="line">        SELECT T1.id, T1.name, T1.short_name, T1.code, T1.parent_code, T1.level, T1.flag  </span><br><span class="line">        FROM sys_region T1</span><br><span class="line">        WHERE T1.code=&#x27;370000000000&#x27;</span><br><span class="line">        UNION ALL</span><br><span class="line">        SELECT T2.id, T2.name, T2.short_name, T2.code, T2.parent_code, T2.level, T2.flag</span><br><span class="line">        FROM sys_region T2, recursion T3</span><br><span class="line">        WHERE T2.parent_code=T3.code</span><br><span class="line">)</span><br><span class="line">SELECT T.id, T.name, T.short_name, T.code, T.parent_code, T.level, T.flag FROM recursion T</span><br><span class="line">WHERE T.code!=&#x27;370000000000&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 查询父节点  含自己</span><br><span class="line">WITH RECURSIVE recursion (id, name, short_name, code, parent_code, level, flag) AS (</span><br><span class="line">        SELECT T1.id, T1.name, T1.short_name, T1.code, T1.parent_code, T1.level, T1.flag  </span><br><span class="line">        FROM sys_region T1</span><br><span class="line">        WHERE T1.code=&#x27;370171401000&#x27;</span><br><span class="line">        UNION ALL</span><br><span class="line">        SELECT T2.id, T2.name, T2.short_name, T2.code, T2.parent_code, T2.level, T2.flag</span><br><span class="line">        FROM sys_region T2, recursion T3</span><br><span class="line">        WHERE T2.code=T3.parent_code</span><br><span class="line">)</span><br><span class="line">SELECT T.id, T.name, T.short_name, T.code, T.parent_code, T.level, T.flag FROM recursion T;</span><br></pre></td></tr></table></figure><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL with Recursive是一种基于递归思想的MySQL查询方式，可以实现对数据的递归查询和处理，返回符合条件的数据，在MySQL 8.0版本中，该功能被正式引入。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;</summary>
      
    
    
    
    <category term="数据库" scheme="http://www.bojiboqi.fun/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="mysql" scheme="http://www.bojiboqi.fun/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>表去重</title>
    <link href="http://www.bojiboqi.fun/2024/09/24/%E8%A1%A8%E5%8E%BB%E9%87%8D/"/>
    <id>http://www.bojiboqi.fun/2024/09/24/%E8%A1%A8%E5%8E%BB%E9%87%8D/</id>
    <published>2024-09-24T15:30:25.240Z</published>
    <updated>2024-09-24T15:40:33.805Z</updated>
    
    <content type="html"><![CDATA[<p>测试表：</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1718957009776-b1a027e5-2f3d-4397-a183-09cb43b9666c.png" alt=""></p><h4 id="nmyZ0">使用Distinct:</h4>+ 去除某列相同的数据，或者某几列都相同的数据。+ <font style="color:rgb(0, 0, 0);">根据单个字段去重，能精确去重；</font>+ <font style="color:rgb(0, 0, 0);">作用在多个字段时，只有当这几个字段的完全相同时，才能去重；</font>+ <font style="color:rgb(0, 0, 0);">关键字distinct只能放在SQL语句中的第一个，才会起作用</font><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 去除id,class,score都重复才去除</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> class, id,score </span><br><span class="line"><span class="keyword">FROM</span> drc_student;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1718957060926-be61e3bc-2584-4d1b-a883-f5cc192daae5.png" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> class <span class="keyword">FROM</span> drc_student;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> class列去重</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1718957116723-036e6316-b7c9-4535-9996-2e4cf443bff7.png" alt=""></p><h4 id="T3X2k">2.使用groupby</h4>![](https://cdn.nlark.com/yuque/0/2024/png/28066124/1718957696441-91a52702-edca-48ad-a3e3-3316f7460dcd.png)<ul><li>使用groupby()会直接对括号里面的列去重</li><li>使用groupby的时候，<font style="color:rgb(51, 51, 51);">select指定的字段要么就要包含在Group By语句的后面，作为分组的依据；要么就要被包含在聚合函数中。也就是这里的select后面查询的列只能出现在group中，其他列作为聚合函数中的参数</font></li></ul><h4 id="l6Ml6"><font style="color:rgb(51, 51, 51);">3.使用窗口函数：</font></h4>+ 窗口函数主要是用来根据某个字段去重，但是还有查询其他列<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> column1, column2, ..., </span><br><span class="line">           <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> column_to_deduplicate <span class="keyword">ORDER</span> <span class="keyword">BY</span> some_column) <span class="keyword">AS</span> row_num</span><br><span class="line">    <span class="keyword">FROM</span> table_name</span><br><span class="line">) subquery</span><br><span class="line"><span class="keyword">WHERE</span> row_num <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>窗口函数：</p><p>:::info<br>ROW_NUMBER() OVER (PARTITION BY column_to_deduplicate ORDER BY some_column) AS row_num</p><p>:::</p><p>这里的PARTITION BY后面跟的是窗口， some_column表示窗口后的数据根据哪列排序</p><ul><li>窗口函数可以说是，先分组，后把同一组的数据中的其他列按照规则排序，最后生成多余的列</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 窗口函数 :根据班级分组，班级内按照分数排序</span></span><br><span class="line"><span class="keyword">SELECT</span> id, class, score, </span><br><span class="line">           <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> class <span class="keyword">ORDER</span> <span class="keyword">BY</span> score) <span class="keyword">AS</span> row_num</span><br><span class="line">    <span class="keyword">FROM</span> drc_student;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1718958521010-af4ff387-0fff-406e-bc94-ca17c3c559cf.png" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询同班中不同的分数</span></span><br><span class="line"><span class="keyword">SELECT</span> id ,class,score </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="comment">-- 窗口函数 :根据班级分组，班级内按照分数排序</span></span><br><span class="line"><span class="keyword">SELECT</span> id, class, score, </span><br><span class="line">           <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> class <span class="keyword">ORDER</span> <span class="keyword">BY</span> score) <span class="keyword">AS</span> row_num</span><br><span class="line">    <span class="keyword">FROM</span> drc_student</span><br><span class="line">)subqury</span><br><span class="line"><span class="keyword">WHERE</span> row_num <span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1718958679440-873271f1-d0dd-4b76-9ce0-b23db8933570.png" alt=""></p><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;测试表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2024/png/28066124/1718957009776-b1a027e5-2f3d-4397-a183-09cb43b9666c.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="数据库" scheme="http://www.bojiboqi.fun/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="mysql" scheme="http://www.bojiboqi.fun/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>缓存</title>
    <link href="http://www.bojiboqi.fun/2024/09/24/%E7%BC%93%E5%AD%98/"/>
    <id>http://www.bojiboqi.fun/2024/09/24/%E7%BC%93%E5%AD%98/</id>
    <published>2024-09-24T15:29:24.614Z</published>
    <updated>2024-09-24T15:39:58.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hBK1Y">[https://www.youtube.com/watch?v=HiBDZgTNpXY](https://www.youtube.com/watch?v=HiBDZgTNpXY)</h2><h2 id="Cfa5w">服务端缓存</h2><h3 id="R6ZVl">CDN</h3>**CDN** 全称是 Content Delivery Network/Content Distribution Network，翻译过的意思是 **内容分发网络** 。<p>我们可以将内容分发网络拆开来看：</p><ul><li>内容：指的是静态资源比如图片、视频、文档、JS、CSS、HTML。</li><li>分发网络：指的是将这些静态资源分发到位于多个不同的地理位置机房中的服务器上，这样，就可以实现静态资源的就近访问比如北京的用户直接访问北京机房的数据。</li></ul><p>所以，简单来说，<strong>CDN 就是将静态资源分发到多个不同的地方以实现就近访问，进而加快静态资源的访问速度，减轻服务器以及带宽的负担。</strong></p><ul><li><font style="color:rgb(44, 62, 80);">全站加速（不同云服务商叫法不同，腾讯云叫 ECDN、阿里云叫 DCDN）既可以加速静态资源又可以加速动态资源，内容分发网络（CDN）主要针对的是 </font><strong><font style="color:rgb(44, 62, 80);">静态资源</font></strong><font style="color:rgb(44, 62, 80);"> 。</font></li></ul><h4 id="pAZCX"><font style="color:rgb(44, 62, 80);">CDN 工作原理是什么？</font></h4><h6 id="ZzeqJ">静态资源是如何被缓存到 CDN 节点中的？</h6>你可以通过 **预热** 的方式将源站的资源同步到 CDN 的节点中。这样的话，用户首次请求资源可以直接从 CDN 节点中取，无需回源。这样可以降低源站压力，提升用户体验。<p>如果不预热的话，你访问的资源可能不在 CDN 节点中，这个时候 CDN 节点将请求源站获取资源，这个过程是大家经常说的 <strong>回源</strong>。</p><ul><li>回源：当 CDN 节点上没有用户请求的资源或该资源的缓存已经过期时，CDN 节点需要从原始服务器获取最新的资源内容，这个过程就是回源。当用户请求发生回源的话，会导致该请求的响应速度比未使用 CDN 还慢，因为相比于未使用 CDN 还多了一层 CDN 的调用流程。</li><li>预热：预热是指在 CDN 上提前将内容缓存到 CDN 节点上。这样当用户在请求这些资源时，能够快速地从最近的 CDN 节点获取到而不需要回源，进而减少了对源站的访问压力，提高了访问速度。</li></ul><h6 id="uf9yy">如何找到最合适的 CDN 节点？</h6>GSLB （Global Server Load Balance，全局负载均衡）是 CDN 的大脑，负责多个 CDN 节点之间相互协作，最常用的是基于 DNS 的 GSLB。<p>CDN 会通过 GSLB 找到最合适的 CDN 节点，更具体点来说是下面这样的：</p><ol><li>浏览器向 DNS 服务器发送域名请求；</li><li>DNS 服务器向根据 CNAME( Canonical Name ) 别名记录向 GSLB 发送请求；</li><li>GSLB 返回性能最好（通常距离请求地址最近）的 CDN 节点（边缘服务器，真正缓存内容的地方）的地址给浏览器；</li><li>浏览器直接访问指定的 CDN 节点。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712813319642-af89acaa-8bad-441d-8b53-20b241f77b6e.png" alt=""></p><p>CDN 原理示意图</p><p>为了方便理解，上图其实做了一点简化。GSLB 内部可以看作是 CDN 专用 DNS 服务器和负载均衡系统组合。CDN 专用 DNS 服务器会返回负载均衡系统 IP 地址给浏览器，浏览器使用 IP 地址请求负载均衡系统进而找到对应的 CDN 节点。</p><p><strong>GSLB 是如何选择出最合适的 CDN 节点呢？</strong> GSLB 会根据请求的 IP 地址、CDN 节点状态（比如负载情况、性能、响应时间、带宽）等指标来综合判断具体返回哪一个 CDN 节点的地址。</p><h3 id="zFmij">Redis缓存</h3>+ Redis现在常用于分布式缓存<h4 id="Ku9l4">缓存更新问题</h4>[输入密码 · 语雀](https://www.yuque.com/snailclimb/mf2z3k/sy238z)<blockquote><p>旁路缓存：</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712815663494-21cf46b5-48b6-4381-ac16-031b00c98ae3.png" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712815671719-dc87225a-51d3-4933-a9b9-80691a39e39c.png" alt=""></p><p>旁路缓存删除缓存失败的解决方案：</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712828486070-790e2114-f07b-4b49-af3b-ffb6a59a5fb9.png" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712828496566-9b20b4e9-591a-40da-8633-0e1da0cd04f0.png" alt=""></p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;mid=2247493521&amp;idx=1&amp;sn=bff84e7a819d79e4b8eb7e722e96ddfc&amp;chksm=c0e83f79f79fb66f2e7bf03a104580b404ea0a3c977846e428f13c1f12fbad46d4d778b2da14&amp;token=902535653&amp;lang=zh_CN&amp;scene=21#wechat_redirect">先更新数据库的弊端</a></li></ul><blockquote><p>读写穿透</p></blockquote><p>在上面的Cache Aside套路中，我们的应用代码需要维护两个数据存储，一个是缓存（Cache），一个是数据库（Repository）。所以，应用程序比较啰嗦。而Read/Write Through套路是把更新数据库（Repository）的操作由缓存自己代理了，所以，对于应用层来说，就简单很多了。可以理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的Cache。</p><blockquote><p>Read Through</p></blockquote><p>Read Through 套路就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。</p><blockquote><p>Write Through</p></blockquote><p>Write Through 套路和Read Through相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）</p><blockquote><p><a href="https://coolshell.cn/articles/17416.html">缓存更新的套路 | 酷 壳 - CoolShell</a>（这里介绍的比较通俗易懂）</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712815765426-d971fb1a-4f78-4051-8c8b-e7d3fda4763d.png" alt=""></p><blockquote><h4 id="E1Xq6"><font style="color:rgb(33, 33, 33);background-color:rgb(245, 245, 245);">Write Behind Caching </font><font style="color:rgb(255, 136, 97) !important;background-color:rgb(245, 245, 245);">Pattern</font></h4></blockquote><p><font style="color:rgb(66, 66, 66);">在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是让数据的I/O操作飞快，但是，其带来的问题是，数据不是强一致性的。</font></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712815836205-eedbbff8-e11f-424b-9ef9-563604aebc09.png" alt=""></p><h4 id="glt5P">缓存击穿</h4>**<font style="color:rgb(44, 62, 80);">缓存中没有但数据库中有的数据</font>**<ul><li>解决方法：</li></ul><p><font style="color:rgb(44, 62, 80);">1、设置热点数据永远不过期。</font></p><p><font style="color:rgb(44, 62, 80);">2、接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些 服务 不可用时候，进行熔断，失败快速返回机制。</font></p><p><font style="color:rgb(44, 62, 80);">3、加互斥锁</font></p><ul><li>服务熔断是故障扩散导致的服务雪崩</li><li>降级：是为了保护核心服务，关掉其他服务以腾出资源给主要服务。</li></ul><p>4.<strong><font style="color:rgb(6, 6, 7);">后台刷新</font></strong><font style="color:rgb(6, 6, 7);">：后台定义一个job (定时任务)专门主动更新缓存数据。比如，一个缓存中的数据过期时间是30分钟，那么job每隔29分钟定时刷新数据，确保缓存中的数据始终是最新的</font></p><p><font style="color:rgb(6, 6, 7);">5.</font><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713343027283-4ec62d59-b1bf-4f60-8f9e-84a2f4331132.png" alt=""></p><p><font style="color:rgb(44, 62, 80);">熔断：</font></p><h4 id="zkhd8">缓存穿透</h4>**<font style="color:rgb(44, 62, 80);">缓存和数据库中都没有的数据</font>**<ul><li><strong><font style="color:rgb(44, 62, 80);">解决办法：</font></strong></li></ul><ol><li><font style="color:rgb(44, 62, 80);">接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</font></li><li><font style="color:rgb(44, 62, 80);">缓存空对象</font></li><li><font style="color:rgb(44, 62, 80);">布隆过滤器</font></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不行</span><br><span class="line">布隆过滤器不能删除，存在误判性，布隆过滤器通常用作缓存穿透问题的第一道防线，用于过滤掉大部分的无效请求。对于布隆过滤器判断为存在的请求，仍然需要进一步验证和处理。</span><br><span class="line">可以举一个极端的例子：就是布隆过滤器使用久了，其中的bit为几乎全为<span class="number">1</span>了，某个请求大量的过来了，这个时候布隆过滤器发现其可能存在于数据库中，就放行了该请求。但是其数据库中没有该数据，就会导致让数据库宕机。</span><br></pre></td></tr></table></figure><h4 id="cu7CA">缓存雪崩</h4>**<font style="color:rgb(44, 62, 80);">数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机</font>**<font style="color:rgb(44, 62, 80);">。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</font><ul><li><font style="color:rgb(44, 62, 80);">解决方法</font></li></ul><p><font style="color:rgb(44, 62, 80);">1.过期时间随机化</font></p><p><font style="color:rgb(44, 62, 80);">2.加锁排队</font></p><p><font style="color:rgb(44, 62, 80);">3.二级缓存</font></p><h4 id="PKh7g">缓存预热</h4>启动系统的时候将数据刷到缓存中<h4 id="fX6wJ">缓存污染</h4>缓存中一些只会被访问一次或者几次的的数据，被访问完后，再也不会被访问到，但这部分数据依然留存在缓存中，消耗缓存空间。<p>缓存污染会随着数据的持续增加而逐渐显露，随着服务的不断运行，缓存中会存在大量的永远不会再次被访问的数据。缓存空间是有限的，如果缓存空间满了，再往缓存里写数据时就会有额外开销，影响Redis性能。这部分额外开销主要是指写的时候判断淘汰策略，根据淘汰策略去选择要淘汰的数据，然后进行删除操作。</p><h3 id="zJgrj">服务器本地缓存</h3>Coffine<h2 id="ky4xh">客户端缓存</h2><h4 id="m0Aqz">Nginx缓存：</h4><h4 id="Vq59H">浏览器缓存：</h4><h4 id="PhLmk">http缓存：</h4><font style="color:rgb(27, 27, 27);">HTTP 缓存会存储与请求关联的响应，并将存储的响应复用于后续请求。</font><p><font style="color:rgb(27, 27, 27);">有两种不同类型的缓存：</font><strong><font style="color:rgb(27, 27, 27);">私有缓存</font></strong><font style="color:rgb(27, 27, 27);">和</font><strong><font style="color:rgb(27, 27, 27);">共享缓存</font></strong><font style="color:rgb(27, 27, 27);">。</font></p><ul><li><font style="color:rgb(27, 27, 27);">私有缓存是绑定到特定客户端的缓存——通常是浏览器缓存。由于存储的响应不与其他客户端共享，因此私有缓存可以存储该用户的个性化响应。</font></li></ul><p><font style="color:rgb(27, 27, 27);">另一方面，如果个性化内容存储在私有缓存以外的缓存中，那么其他用户可能能够检索到这些内容——这可能会导致无意的信息泄露。</font></p><ul><li><font style="color:rgb(27, 27, 27);">共享缓存位于客户端和服务器之间，可以存储能在用户之间共享的响应。共享缓存可以进一步细分为</font><strong><font style="color:rgb(27, 27, 27);">代理缓存</font></strong><font style="color:rgb(27, 27, 27);">和</font><strong><font style="color:rgb(27, 27, 27);">托管缓存</font></strong><font style="color:rgb(27, 27, 27);">。</font><ul><li><font style="color:rgb(27, 27, 27);">代理还实现了缓存以减少网络流量。这通常不由服务开发人员管理，因此必须由恰当的 HTTP 标头等控制。然而，在过去，过时的代理缓存实现——例如没有正确理解 HTTP 缓存标准的实现——经常给开发人员带来问题。</font></li><li><font style="color:rgb(27, 27, 27);">托管缓存由服务开发人员明确部署，以降低源服务器负载并有效地交付内容。示例包括反向代理、CDN 和 service worker 与缓存 API 的组合。</font></li></ul></li></ul><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;hBK1Y&quot;&gt;[https://www.youtube.com/watch?v=HiBDZgTNpXY](https://www.youtube.com/watch?v=HiBDZgTNpXY)&lt;/h2&gt;
&lt;h2 id=&quot;Cfa5w&quot;&gt;服务端缓存&lt;/h2&gt;
&lt;h3</summary>
      
    
    
    
    <category term="缓存" scheme="http://www.bojiboqi.fun/categories/%E7%BC%93%E5%AD%98/"/>
    
    
    <category term="缓存" scheme="http://www.bojiboqi.fun/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>使用MP进行curd错误记录</title>
    <link href="http://www.bojiboqi.fun/2024/09/24/%E4%BD%BF%E7%94%A8MP%E8%BF%9B%E8%A1%8Ccurd%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/"/>
    <id>http://www.bojiboqi.fun/2024/09/24/%E4%BD%BF%E7%94%A8MP%E8%BF%9B%E8%A1%8Ccurd%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/</id>
    <published>2024-09-24T15:24:55.134Z</published>
    <updated>2024-09-24T16:17:08.918Z</updated>
    
    <content type="html"><![CDATA[<h4 id="DswAX">字段是数据库的保留字错误</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@TableName(value = <span class="string">&quot;t_ods_cdszpt_sjtb_kb_policy_index_d&quot;</span>)</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class TODSCdsZptSjtbKbPolicyIndexD &#123;</span><br><span class="line">    @TableField(<span class="string">&quot;order&quot;</span>)</span><br><span class="line">    private String order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面的order是mysql的保留关键字，之间按照上面使用在进行crud会报错的，应该修改:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@TableField(<span class="string">&quot;`order`&quot;</span>)</span><br><span class="line">private String order;</span><br></pre></td></tr></table></figure><ul><li>上面是mysql的使用，但是pg数据库却不一样</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@TableField(<span class="string">&quot;\&quot;table\&quot;&quot;</span>)</span><br><span class="line"> private String table;</span><br></pre></td></tr></table></figure><h4 id="d6NGn">pg:operator does not exist: character varying</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;蓉政通======开始删除蓉政通用户数据,删除时间: &#123;&#125;&quot;</span>, LocalDateTime.now()</span><br><span class="line">         .format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));</span><br><span class="line"></span><br><span class="line">odsCityApiScimUserRtService.remove(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;OdsCityApiScimUserRt&gt;()</span><br><span class="line">                                   .ne(OdsCityApiScimUserRt::getId, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// ne(OdsCityApiScimUserRt::getId, &quot;0&quot;));修改为这个就可以了</span></span><br></pre></td></tr></table></figure><p>错误：这里的OdsCityApiScimUserRt::getId获取的是一个String类型。.ne(OdsCityApiScimUserRt::getId, 0));这个条件语句转换为sql是:where id = 0;这里就有问题的，在mysql中后面的0后自动转换为字符串，但是pg更加严格。</p><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;DswAX&quot;&gt;字段是数据库的保留字错误&lt;/h4&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    <category term="中间件" scheme="http://www.bojiboqi.fun/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="mybatis" scheme="http://www.bojiboqi.fun/tags/mybatis/"/>
    
    <category term="bug" scheme="http://www.bojiboqi.fun/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>打包的jar上传到服务器找不到主清单解决方法</title>
    <link href="http://www.bojiboqi.fun/2024/09/24/%E6%89%93%E5%8C%85%E7%9A%84jar%E4%B8%8A%E4%BC%A0%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%BE%E4%B8%8D%E5%88%B0%E4%B8%BB%E6%B8%85%E5%8D%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://www.bojiboqi.fun/2024/09/24/%E6%89%93%E5%8C%85%E7%9A%84jar%E4%B8%8A%E4%BC%A0%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%BE%E4%B8%8D%E5%88%B0%E4%B8%BB%E6%B8%85%E5%8D%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2024-09-24T15:23:08.521Z</published>
    <updated>2024-09-24T15:38:56.536Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hLgCo">解决方法1：</h2><h4 id="YiGH5">在maven中添加如下配置，让每次打包后的jar包包含其他依赖：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;repositories&gt;</span><br><span class="line">       &lt;repository&gt;</span><br><span class="line">           &lt;id&gt;spring-releases&lt;/id&gt;</span><br><span class="line">           &lt;url&gt;https:<span class="comment">//repo.spring.io/libs-release&lt;/url&gt;</span></span><br><span class="line">       &lt;/repository&gt;</span><br><span class="line">   &lt;/repositories&gt;</span><br><span class="line">   &lt;pluginRepositories&gt;</span><br><span class="line">       &lt;pluginRepository&gt;</span><br><span class="line">           &lt;id&gt;spring-releases&lt;/id&gt;</span><br><span class="line">           &lt;url&gt;https:<span class="comment">//repo.spring.io/libs-release&lt;/url&gt;</span></span><br><span class="line">       &lt;/pluginRepository&gt;</span><br><span class="line">   &lt;/pluginRepositories&gt;</span><br><span class="line"></span><br><span class="line">   &lt;build&gt;</span><br><span class="line">       &lt;plugins&gt;</span><br><span class="line">           &lt;plugin&gt;</span><br><span class="line">               &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;<span class="number">3.8</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">               &lt;configuration&gt;</span><br><span class="line">                   &lt;source&gt;<span class="number">1.8</span>&lt;/source&gt;</span><br><span class="line">                   &lt;target&gt;<span class="number">1.8</span>&lt;/target&gt;</span><br><span class="line">                   &lt;encoding&gt;UTF-<span class="number">8</span>&lt;/encoding&gt;</span><br><span class="line">               &lt;/configuration&gt;</span><br><span class="line">           &lt;/plugin&gt;</span><br><span class="line">               &lt;plugin&gt;</span><br><span class="line">                   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                   &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                   &lt;version&gt;<span class="number">2.6</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">                   &lt;configuration&gt;</span><br><span class="line">                       &lt;mainClass&gt;com.example.remotedebug.RemoteDebugApplication&lt;/mainClass&gt;</span><br><span class="line">                       &lt;layout&gt;JAR&lt;/layout&gt;</span><br><span class="line">                   &lt;/configuration&gt;</span><br><span class="line">                   &lt;executions&gt;</span><br><span class="line">                       &lt;execution&gt;</span><br><span class="line">                           &lt;goals&gt;</span><br><span class="line">                               &lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class="line">                           &lt;/goals&gt;</span><br><span class="line">                       &lt;/execution&gt;</span><br><span class="line">                   &lt;/executions&gt;</span><br><span class="line">               &lt;/plugin&gt;</span><br><span class="line">       &lt;/plugins&gt;</span><br><span class="line">   &lt;/build&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="G4t60">解决方法2：</h4>先把相关依赖的包上传到服务器<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span>build<span class="operator">&gt;</span></span><br><span class="line">      <span class="operator">&lt;</span>finalName<span class="operator">&gt;</span>DebugDemo<span class="operator">&lt;</span><span class="operator">/</span>finalName<span class="operator">&gt;</span></span><br><span class="line">      <span class="operator">&lt;</span>plugins<span class="operator">&gt;</span></span><br><span class="line">          <span class="operator">&lt;</span>plugin<span class="operator">&gt;</span></span><br><span class="line">              <span class="operator">&lt;</span>groupId<span class="operator">&gt;</span>org.apache.maven.plugins<span class="operator">&lt;</span><span class="operator">/</span>groupId<span class="operator">&gt;</span></span><br><span class="line">              <span class="operator">&lt;</span>artifactId<span class="operator">&gt;</span>maven<span class="operator">-</span>jar<span class="operator">-</span>plugin<span class="operator">&lt;</span><span class="operator">/</span>artifactId<span class="operator">&gt;</span></span><br><span class="line">              <span class="operator">&lt;</span>version<span class="operator">&gt;</span><span class="number">3.2</span><span class="number">.2</span><span class="operator">&lt;</span><span class="operator">/</span>version<span class="operator">&gt;</span></span><br><span class="line">              <span class="operator">&lt;</span>configuration<span class="operator">&gt;</span></span><br><span class="line">                  <span class="operator">&lt;</span>archive<span class="operator">&gt;</span></span><br><span class="line">                      <span class="operator">&lt;</span>manifestEntries<span class="operator">&gt;</span></span><br><span class="line">                          <span class="operator">&lt;</span>Build<span class="operator">-</span><span class="type">Time</span><span class="operator">&gt;</span>$&#123;maven.build.timestamp&#125;<span class="operator">&lt;</span><span class="operator">/</span>Build<span class="operator">-</span><span class="type">Time</span><span class="operator">&gt;</span></span><br><span class="line">                      <span class="operator">&lt;</span><span class="operator">/</span>manifestEntries<span class="operator">&gt;</span></span><br><span class="line">                      <span class="operator">&lt;</span>manifest<span class="operator">&gt;</span></span><br><span class="line">                          <span class="operator">&lt;</span>addClasspath<span class="operator">&gt;</span><span class="literal">true</span><span class="operator">&lt;</span><span class="operator">/</span>addClasspath<span class="operator">&gt;</span></span><br><span class="line">                          <span class="operator">&lt;</span>classpathPrefix<span class="operator">&gt;</span>lib<span class="operator">/</span><span class="operator">&lt;</span><span class="operator">/</span>classpathPrefix<span class="operator">&gt;</span></span><br><span class="line">                          <span class="operator">&lt;</span>mainClass<span class="operator">&gt;</span>com.<span class="operator">&lt;</span><span class="operator">/</span>mainClass<span class="operator">&gt;</span></span><br><span class="line">                      <span class="operator">&lt;</span><span class="operator">/</span>manifest<span class="operator">&gt;</span></span><br><span class="line">                  <span class="operator">&lt;</span><span class="operator">/</span>archive<span class="operator">&gt;</span></span><br><span class="line">              <span class="operator">&lt;</span><span class="operator">/</span>configuration<span class="operator">&gt;</span></span><br><span class="line">          <span class="operator">&lt;</span><span class="operator">/</span>plugin<span class="operator">&gt;</span></span><br><span class="line">      <span class="operator">&lt;</span><span class="operator">/</span>plugins<span class="operator">&gt;</span></span><br><span class="line">  <span class="operator">&lt;</span><span class="operator">/</span>build<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;hLgCo&quot;&gt;解决方法1：&lt;/h2&gt;
&lt;h4 id=&quot;YiGH5&quot;&gt;在maven中添加如下配置，让每次打包后的jar包包含其他依赖：&lt;/h4&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;</summary>
      
    
    
    
    <category term="项目" scheme="http://www.bojiboqi.fun/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="bug" scheme="http://www.bojiboqi.fun/tags/bug/"/>
    
    <category term="项目" scheme="http://www.bojiboqi.fun/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机连接Docker中的mysql报10060错</title>
    <link href="http://www.bojiboqi.fun/2024/09/24/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%9E%E6%8E%A5Docker%E4%B8%AD%E7%9A%84mysql%E6%8A%A510060%E9%94%99/"/>
    <id>http://www.bojiboqi.fun/2024/09/24/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%9E%E6%8E%A5Docker%E4%B8%AD%E7%9A%84mysql%E6%8A%A510060%E9%94%99/</id>
    <published>2024-09-24T15:22:28.837Z</published>
    <updated>2024-09-24T15:40:19.537Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/zhangxiaoxia/p/13043508.html#:~:text=%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%97%B6%E5%80%99%E6%98%BE%E7%A4%BACan%27t%20connect%20to%20MySQL%20server%20%2810060%29%20%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA%20%E5%8F%AF%E4%BB%A5%E4%BB%8E%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AA%E6%96%B9%E9%9D%A2%E5%85%A5%E6%89%8B%EF%BC%8C%E6%89%BE%E5%87%BA%E9%94%99%E8%AF%AF%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A,%E6%A3%80%E6%9F%A5%E4%B8%8B%E6%98%AF%E4%B8%8D%E6%98%AF%E8%83%BDping%E9%80%9A%202.mysql%E8%B4%A6%E6%88%B7%E8%AE%BE%E7%BD%AE%20mysql%E8%B4%A6%E6%88%B7%E6%98%AF%E5%90%A6%E4%B8%8D%E5%85%81%E8%AE%B8%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%20--%20mysql%20-u%20root%20-p">MySQL错误：Can’t connect to MySQL server (10060) 解决方案 - Felix-Zhang - 博客园</a></p><h4 id="xvsw9">错误</h4>![](https://cdn.nlark.com/yuque/0/2024/png/28066124/1718245117145-3c5a91df-d262-422f-8873-5a6632d00e6f.png)<h4 id="qhNMU">检测虚拟机中的ip能否ping通</h4><h4 id="PHgk6">检测Docker中的mysql是否允许用户远程访问</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--  mysql -u root -p</span><br><span class="line"></span><br><span class="line">--  show databases;</span><br><span class="line"></span><br><span class="line">--  use mysql;</span><br><span class="line"> </span><br><span class="line">--  select host,user from user</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span>WITH GRANT OPTION;     <span class="comment">//任何远程主机都可以访问数据库  </span></span><br><span class="line"> </span><br><span class="line">-- FLUSH PRIVILEGES;    <span class="comment">//需要输入次命令使修改生效  </span></span><br><span class="line"> </span><br><span class="line">-- EXIT    <span class="comment">//退出 </span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- use mysql;  </span><br><span class="line"> </span><br><span class="line">-- update user <span class="type">set</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&#x27;%&#x27;</span> <span class="type">where</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>;  </span><br><span class="line"> </span><br><span class="line">-- select host, user from user; </span><br></pre></td></tr></table></figure><p>发现我的不是这个问题</p><h4 id="fCYkm">检测虚拟机中的防火墙是否关闭端口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root<span class="meta">@iZ2zee2l6djknfZ</span> ~]# firewall-cmd --list-ports</span><br><span class="line"><span class="number">20</span>/tcp <span class="number">21</span>/tcp <span class="number">22</span>/tcp <span class="number">80</span>/tcp <span class="number">8888</span>/tcp <span class="number">39000</span>-<span class="number">40000</span>/tcp <span class="number">8001</span>/tcp <span class="number">8001</span>/udp</span><br><span class="line">[root<span class="meta">@iZ2zee2l6djknfZ</span> ~]# firewall-cmd --zone=<span class="keyword">public</span> --add-port=<span class="number">3306</span>/tcp --permanent</span><br><span class="line">success</span><br><span class="line">[root<span class="meta">@iZ2zee2l6djknfZ</span> ~]# firewall-cmd --reload</span><br><span class="line">success</span><br><span class="line">[root<span class="meta">@iZ2zee2l6djknfZ</span> ~]# firewall-cmd --list-port</span><br><span class="line"><span class="number">20</span>/tcp <span class="number">21</span>/tcp <span class="number">22</span>/tcp <span class="number">80</span>/tcp <span class="number">8888</span>/tcp <span class="number">39000</span>-<span class="number">40000</span>/tcp <span class="number">8001</span>/tcp <span class="number">8001</span>/udp <span class="number">3306</span>/tcp</span><br></pre></td></tr></table></figure><p>发现不是这个</p><h4 id="ZHJ25">检测虚拟机中的NAT设计的端口转发是否添加对应的虚拟机端口映射</h4>> 这里如果是云服务器就检查对应安全组是否打开><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1718245135424-fd6785ba-fb6a-4c5b-8006-4a85247d2a8f.png" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1718245232346-e4129877-ad38-4bfa-a308-418eeb504f74.png" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1718245256223-e2dcecd5-dc93-47c2-b09b-cf5c7289c193.png" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1718245288612-173e486f-03f6-4b74-9279-5c8f99287da6.png" alt=""></p><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhangxiaoxia/p/13043508.html#:~:text=%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%9</summary>
      
    
    
    
    <category term="bug" scheme="http://www.bojiboqi.fun/categories/bug/"/>
    
    
    <category term="mysql" scheme="http://www.bojiboqi.fun/tags/mysql/"/>
    
    <category term="docker" scheme="http://www.bojiboqi.fun/tags/docker/"/>
    
    <category term="byg" scheme="http://www.bojiboqi.fun/tags/byg/"/>
    
  </entry>
  
  <entry>
    <title>线程异常和spring异常扩散机制</title>
    <link href="http://www.bojiboqi.fun/2024/09/24/%E7%BA%BF%E7%A8%8B%E5%BC%82%E5%B8%B8%E5%92%8Cspring%E5%BC%82%E5%B8%B8%E6%89%A9%E6%95%A3%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.bojiboqi.fun/2024/09/24/%E7%BA%BF%E7%A8%8B%E5%BC%82%E5%B8%B8%E5%92%8Cspring%E5%BC%82%E5%B8%B8%E6%89%A9%E6%95%A3%E6%9C%BA%E5%88%B6/</id>
    <published>2024-09-24T15:21:50.470Z</published>
    <updated>2024-09-24T15:39:49.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tgU04">java中的异常</h2>[Java中的异常总结详解（异常类型、声明异常、抛出异常、捕获异常）_声明异常的关键字是 ,抛出异常的关键字是 ,捕捉异常的关键字是-CSDN博客](https://blog.csdn.net/m0_46316970/article/details/119898445)<ul><li><font style="color:rgb(77, 77, 77);">在程序运行过程中，如果 JVM 检测出一个不可能执行的操作，就会出现运行时错误（runtime error)。</font></li><li><font style="color:rgb(77, 77, 77);"> 异常就是程序在运行过程中出现的一些错误，我们通过面向对象的思想，把这些错误也用类来描述，那么一旦产生一个错误，即就是创建了某一个错误的对象，这个对象就是我们所说的异常对象。</font></li><li><font style="color:rgb(0, 0, 0);background-color:rgb(248, 248, 64);">RuntimeException 的任何子类都无需在 throws 子句中进行声明</font><font style="color:rgba(0, 0, 0, 0.75);">，指的就是这些问题</font><font style="color:rgb(0, 0, 0);background-color:rgb(248, 248, 64);">不需要提前被预防</font><font style="color:rgba(0, 0, 0, 0.75);">（本质上也可以的，只不过没必要），</font><font style="color:rgb(0, 0, 0);background-color:rgb(248, 248, 64);">因为只有在真正运行的时候才能发现是否发生问题，一旦在运行期间发生了问题，则一般不会修正，程序直接终端。</font></li><li><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1718941298420-523726c8-5e9b-4133-889a-1af9fcf9fd67.png" alt=""></li><li>系统錯误（system error) 是由 Java 虚拟机抛出的，用 Error 类表示。Error 类描述的是内部系统错误。这样的错误很少发生，Error不能被抛出和try</li><li>异常实际上是方法退出的另外一种方式。</li><li><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1718948502639-10179a41-0d9a-4eb2-9f18-8a7d68a5c97a.png" alt=""></li><li><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1718949417789-b598b248-d6f2-4e81-b2bd-fb28261e6ee7.png" alt=""></li><li><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1718949646340-1d00a753-1db1-4175-b872-9e15def0673e.png" alt=""></li><li><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1718949654559-8efe3787-031e-4a9a-82b6-e35c8ee33261.png" alt=""></li><li>异常会在方法调用栈中传递的，某个线程发生了异常，且并没有进行try，那么只是这个线程会挂掉，整个服务或者说main线程不会挂掉的。</li></ul><h4 id="oz2Dl">checked和unchecked</h4>+ <font style="color:rgba(0, 0, 0, 0.5);">必须捕获的异常，包括 Exception 及其子类，但不包括 RuntimeException 及其子类，这种类型的异常称为Checked Exception。这种异常在我们写代码的时候IDEA就会提醒我们要么try或者throws</font>+ <font style="color:rgba(0, 0, 0, 0.5);">不需要捕获的异常，包括 Error 及其子类， RuntimeException 及其子类。</font><h4 id="FNI0m">自定义异常</h4>[自定义异常类 - deng-hui - 博客园](https://www.cnblogs.com/denghui-study/p/14327442.html)<h4 id="RGMhb">异常栈</h4>[一篇文章让你读懂Java异常栈信息-CSDN博客](https://blog.csdn.net/tianjindong0804/article/details/105117779)<ul><li>lombook中的<font style="color:#9e880d;background-color:#ffffff;">@SneakyThrows注解可以减少声明异常</font></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@SneakyThrows</span></span><br><span class="line">    public void throwCheckedException() &#123;</span><br><span class="line">        throw <span class="keyword">new</span> Exception(&quot;Checked exception thrown&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@SneakyThrows</span></span><br><span class="line">    public void throwUncheckedException() &#123;</span><br><span class="line">        throw <span class="keyword">new</span> RuntimeException(&quot;Unchecked exception thrown&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> void main(String[] args) &#123;</span><br><span class="line">        Example example <span class="operator">=</span> <span class="keyword">new</span> Example();</span><br><span class="line">        example.throwCheckedException();</span><br><span class="line">        example.throwUncheckedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="sAWVQ"><font style="color:rgba(0, 0, 0, 0.5);">Spring中的异常处理机制</font></h4>+ spring在对于控制层每个路径下的请求，如果某个请求抛出了异常并不会影响整个spring项目的关闭，这是因为在<font style="color:#000000;background-color:#ffffff;">RequestMappingHandlerAdapter对控制层中代码抛出的异常做出了try</font><h4 id="tnwGx">受检异常的思考</h4>[滑动验证页面](https://segmentfault.com/a/1190000044581225)（很值得看一下，了解其他语言为啥没有checked异常）<h4 id="DfHjz"><font style="color:#9e880d;background-color:#ffffff;">@SneakyThrows</font></h4><font style="color:#DF2A3F;">Lombok 的 @SneakyThrows 注解允许您在不使用 throws 声明的情况下抛出选中的异常</font>。当您需要从限制性很强的接口（如 Runnable）中的方法引发异常时，这会派上用场。假设我们从 Runnable 中抛出一个异常;它只会传递给线程的未经处理的异常处理程序。<ul><li>对于受检异常，该注解可以不用throws抛出异常，这样就算某个方法改动throws的异常发生了变化，该方法中调用链的其他方法不用修改其throws</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Main</span>().f2();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*   try &#123;</span></span><br><span class="line"><span class="comment">            throwSneakyIOExceptionUsingLombok();</span></span><br><span class="line"><span class="comment">        &#125;catch (Exception e)&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(e.getMessage());</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="comment">//        new Main().f2();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> <span class="string">&quot;test.txt&quot;</span>;</span><br><span class="line">        f1(filename);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">f1</span><span class="params">(String filename)</span>  &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(filename));</span><br><span class="line">        <span class="keyword">return</span> scanner.next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">throwSneakyIOExceptionUsingLombok</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;lombok sneaky&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.上面的方法f1不添加SneakyThrows注解就需要在f1方法后面添加throws FileNotFoundException;同时调用f1方法的f2和main也要添加；添加了SneakyThrows注解后，如果后面f1方法改了后，其抛出的异常发生了变化就可以，如果没有使用SneakyThrows注解就要修改f2和main方法的throws，使用了该注解就可以不用这样了。</p><ul><li>当发生了是非检查异常的时候，使用了该注解和没有使用感觉区别不大：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.SneakyThrows;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">       <span class="comment">/* try &#123;</span></span><br><span class="line"><span class="comment">            new Main().f2();</span></span><br><span class="line"><span class="comment">        &#125;catch (Exception e)&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(e.getMessage());</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            throwSneakyIOExceptionUsingLombok();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        new Main().f2();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> <span class="string">&quot;test.txt&quot;</span>;</span><br><span class="line">        f1(filename);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">f1</span><span class="params">(String filename)</span>  &#123;</span><br><span class="line">     <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(filename));</span><br><span class="line">     <span class="keyword">return</span> scanner.next();</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">throwSneakyIOExceptionUsingLombok</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;lombok sneaky&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;tgU04&quot;&gt;java中的异常&lt;/h2&gt;
[Java中的异常总结详解（异常类型、声明异常、抛出异常、捕获异常）_声明异常的关键字是 ,抛出异常的关键字是 ,捕捉异常的关键字是-CSDN博客](https://blog.csdn.net/m0_46316970/ar</summary>
      
    
    
    
    <category term="java" scheme="http://www.bojiboqi.fun/categories/java/"/>
    
    
    <category term="异常" scheme="http://www.bojiboqi.fun/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Java常见集合源码分析</title>
    <link href="http://www.bojiboqi.fun/2024/09/24/Java%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://www.bojiboqi.fun/2024/09/24/Java%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2024-09-24T15:20:31.380Z</published>
    <updated>2024-09-25T00:08:36.728Z</updated>
    
    <content type="html"><![CDATA[<h2 id="aech1">ArrayList</h2><h3 id="GFV9x">概述</h3><blockquote><p>实现接口图</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714131148479-73505ed1-e13f-4c72-8ecc-e761533cf7f7.png" alt=""></p><ul><li>RandomAccess ：这是一个标志接口，表明实现这个接口的 List 集合是支持 快速随机访问 的。</li><li>ArrayList是可以动态增长和缩减的索引序列，它是基于数组实现的List类。</li><li>ArrayList也可以储存null值</li></ul><h3 id="InDEy">源码分析</h3><h4 id="fu7aG">属性</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714132763265-20c8dbe3-a331-4ad3-b986-6abdbd1a042d.png" alt=""></p><h4 id="KE7Ln">构造方法</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714132940533-7c43d07a-8490-46b2-9a45-28c0748903f8.png" alt=""></p><h4 id="ouNk2">核心方法</h4<blockquote></blockquote><blockquote><p>add方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">// 形参:</span></span><br><span class="line"><span class="comment">// e -要添加到此列表的元素</span></span><br><span class="line"><span class="comment">// 返回值:</span></span><br><span class="line"><span class="comment">// True(由 Collection.add）</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>查看ensureCapacityInternal方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">       ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>查看ensureExplicitCapacity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 从上面的代码可以看出，以无参构建ArrayList的时候，刚开始数组的大小是为0的，在第一次添加元素的时候会创建一个长度为10的数组，并将该元素赋值到数组的第一个位置</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">      modCount++; <span class="comment">//修改的次数可以忽略</span></span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">          grow(minCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>查看grow方法：上面我们传递的minCapacity是插入数据后的大小，当minCapacity - elementData.length &gt; 0也就是当前的ArrayList的大小不足了，下面的grow肯定就是扩容的关键代码</p><blockquote><p>扩容代码关键点</p></blockquote><ul><li>ArrayList有2个关键的属性：elementData数组，int的size;size是ArrayList储存数据的数量。</li><li>当我们以无参构造ArrayList的时候分配给elementData长度为0，第 1 次添加元素，会创建一个长度为10的数组，并将该元素赋值到数组的第一个位置</li><li>扩容的时间发生在插入数据后元素的大小大于当前ArrayList的大小的时候</li><li>先扩容到旧容量的1.5倍看是否够用</li><li>够用以该容量生成新的数组，数据拷贝到新数组里面，然后让elementData指向新数组</li><li>扩容1.5倍倍后如果不够用，就扩大到插入元素后的大小；扩容1.5倍倍够用的话（或者在不够用的情况下，扩大到插入后的情况）就看看这个容量是否超过了规定的最大容量，如果是就调用 hugeCapacity方法，该方法中会判断插入元素数组的大小是否超过int的最大值，如果是抛出异常，不是就判断插入元素后的大小是否超出了ArrayList规定的最大值，如果不是就让它为规定的最大数，否则为int的最大值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加容量以确保它至少可以容纳最小容量参数指定的元素数量。</span></span><br><span class="line"><span class="comment">// 形参: minCapacity -所需的最小容量</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;<span class="comment">//因为有保留了8个字符</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 要分配的数组的最大大小。有些虚拟机在数组中保留一些头字。尝试分配更大的数组可能会导致OutOfMemoryError:请求的数组大小超过虚拟机限制</span></span><br><span class="line"><span class="comment">// private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br></pre></td></tr></table></figure><blockquote><p>remove</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除此列表中指定位置的元素。将所有后续元素向左移动(从它们的索引中减去1)。</span></span><br><span class="line"><span class="comment">// 形参:</span></span><br><span class="line"><span class="comment">// 指数 -要删除的元素的索引</span></span><br><span class="line"><span class="comment">// 返回值:</span></span><br><span class="line"><span class="comment">// 从列表中删除的元素</span></span><br><span class="line"><span class="comment">// 抛出:</span></span><br><span class="line"><span class="comment">// IndexOutOfBoundsException -如果索引超出范围(index &lt; 0 || index &gt;= size())</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><font style="color:rgb(44, 62, 80);">ArrayList</font><font style="color:rgb(44, 62, 80);"> 中可以存储任何类型的对象，包括 </font><font style="color:rgb(44, 62, 80);">null</font><font style="color:rgb(44, 62, 80);"> 值。</font></li><li><font style="color:rgb(44, 62, 80);">以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10</font></li><li><font style="color:rgb(44, 62, 80);"> size() 方法时，它会遍历列表并计算元素的个数，然后将这个计数值作为结果返回；</font></li></ul><h3 id="NV9oK"><font style="color:rgb(44, 62, 80);">线程不安全Demo分析</font></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; list.add(<span class="string">&quot;Element &quot;</span> + finalI)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;预期长度为10&quot;</span>+list.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;list:&quot;</span>+list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714138941747-6a1b628c-77ff-4bc6-b2e9-d8a79453dedb.png" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714138956956-978a941e-8cbd-4882-80f4-1b82457c04ee.png" alt=""></p><ol><li><strong><font style="color:rgb(6, 6, 7);">并发修改</font></strong><font style="color:rgb(6, 6, 7);">：由于有多个线程尝试同时修改 </font>ArrayList<font style="color:rgb(6, 6, 7);">，这会导致并发修改的问题。</font></li><li><strong><font style="color:rgb(6, 6, 7);">数组扩容</font></strong><font style="color:rgb(6, 6, 7);">：当 </font>ArrayList<font style="color:rgb(6, 6, 7);"> 达到其初始容量时，它需要进行扩容。扩容过程涉及到创建一个新的数组，并将旧数组的元素复制到新数组中。如果多个线程同时触发了扩容，可能会导致数据丢失或不一致。</font></li><li><strong><font style="color:rgb(6, 6, 7);">快速失败迭代器</font></strong><font style="color:rgb(6, 6, 7);">：</font>ArrayList<font style="color:rgb(6, 6, 7);"> 提供的迭代器是快速失败的，意味着在迭代过程中如果检测到列表被修改了（除了迭代器自身的 </font>remove<font style="color:rgb(6, 6, 7);"> 方法），迭代器会立即抛出 </font>ConcurrentModificationException<font style="color:rgb(6, 6, 7);">。</font></li><li>**<font style="color:rgb(6, 6, 7);">潜在的</font>**<strong>IndexOutOfBoundsException</strong><font style="color:rgb(6, 6, 7);">：由于 </font>ArrayList<font style="color:rgb(6, 6, 7);"> 使用数组存储数据，当多个线程同时修改数组大小时，可能会导致数组下标越界异常。</font></li></ol><p><font style="color:rgb(6, 6, 7);">解决方法</font></p><p><font style="color:rgb(6, 6, 7);">使用Collections.synchronizedList(List<T> list) 包装的 ArrayList 或者 CopyOnWriteArrayList。</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br></pre></td></tr></table></figure><h2 id="Seu3f">LinkedList</h2><h3 id="nTBBW">概述</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714139203978-90622815-fca8-40f3-97ac-73a544f3b1aa.png" alt=""></p><ul><li><font style="color:rgb(0, 0, 0);">LinkedList是一种可以在</font><font style="color:rgb(255, 0, 0);">任何位置进行高效地插入和移除操作的有序序列，它是基于双向链表实现的</font><font style="color:rgb(0, 0, 0);">。</font></li><li><font style="color:rgb(0, 0, 0);">LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。LinkedList 实现 List 接口，能对它进行队列操作。<br></font><font style="color:rgb(0, 0, 0);">LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。<br></font><font style="color:rgb(0, 0, 0);">LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。<br></font><font style="color:rgb(0, 0, 0);">LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。<br></font><font style="color:rgb(0, 0, 0);">LinkedList 是非同步的。</font></li><li><font style="color:rgb(0, 0, 0);">Deque接口：有队列的各种特性，</font></li><li><font style="color:rgb(255, 0, 0);">没有RandomAccess：那么就推荐使用iterator</font></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714139323808-2de1d2f5-133a-47f1-9021-be7cba020eee.png" alt=""></p><h3 id="G7Cb0">源码分析</h3><h4 id="Y2uzO">属性</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714139454048-80702850-ab4d-44e2-9726-f9c9fb7d9ac5.png" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714139462503-78f5d164-7b2a-49d0-91c0-4cb467192621.png" alt=""></p><h4 id="hvLSm">构造器</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714139688405-8b798c0f-d55e-467f-870f-cb22e3e37a45.png" alt=""></p><h4 id="MhNEC">迭代器</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714140274266-a9f8067c-6044-48e8-b749-442386c06a8a.png" alt=""></p><p><font style="color:rgb(44, 62, 80);">LinkedList</font><font style="color:rgb(44, 62, 80);"> 的遍历的核心就是它的迭代器的实现。</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向迭代器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ListItr</span> <span class="keyword">implements</span> <span class="title class_">ListIterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 表示上一次调用 next() 或 previous() 方法时经过的节点；</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastReturned;</span><br><span class="line">    <span class="comment">// 表示下一个要遍历的节点；</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line">    <span class="comment">// 表示下一个要遍历的节点的下标，也就是当前节点的后继节点的下标；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nextIndex;</span><br><span class="line">    <span class="comment">// 表示当前遍历期望的修改计数值，用于和 LinkedList 的 modCount 比较，判断链表是否被其他线程修改过。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    …………</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><font style="color:rgb(44, 62, 80);">下面我们对迭代器 </font><font style="color:rgb(44, 62, 80);">ListItr</font><font style="color:rgb(44, 62, 80);"> 中的核心方法进行详细介绍。</font></p><p><font style="color:rgb(44, 62, 80);">我们先来看下从头到尾方向的迭代：</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断还有没有下一个节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 判断下一个节点的下标是否小于链表的大小，如果是则表示还有下一个元素可以遍历</span></span><br><span class="line">    <span class="keyword">return</span> nextIndex &lt; size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取下一个节点</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 检查在迭代过程中链表是否被修改过</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="comment">// 判断是否还有下一个节点可以遍历，如果没有则抛出 NoSuchElementException 异常</span></span><br><span class="line">    <span class="keyword">if</span> (!hasNext())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="comment">// 将 lastReturned 指向当前节点</span></span><br><span class="line">    lastReturned = next;</span><br><span class="line">    <span class="comment">// 将 next 指向下一个节点</span></span><br><span class="line">    next = next.next;</span><br><span class="line">    nextIndex++;</span><br><span class="line">    <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><font style="color:rgb(44, 62, 80);">再来看一下从尾到头方向的迭代：</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否还有前一个节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nextIndex &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取前一个节点</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">previous</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否在迭代过程中链表被修改</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="comment">// 如果没有前一个节点，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="comment">// 将 lastReturned 和 next 指针指向上一个节点</span></span><br><span class="line">    lastReturned = next = (next == <span class="literal">null</span>) ? last : next.prev;</span><br><span class="line">    nextIndex--;</span><br><span class="line">    <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><font style="color:rgb(44, 62, 80);">如果需要删除或插入元素，也可以使用迭代器进行操作。</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">list.add(<span class="literal">null</span>);</span><br><span class="line">list.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Collection 接口的 removeIf 方法底层依然是基于迭代器</span></span><br><span class="line">list.removeIf(Objects::isNull);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String fruit : list) &#123;</span><br><span class="line">    System.out.println(fruit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><font style="color:rgb(44, 62, 80);">迭代器对应的移除元素的方法如下：</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从列表中删除上次被返回的元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否在迭代过程中链表被修改</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="comment">// 如果上次返回的节点为空，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (lastReturned == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前节点的下一个节点</span></span><br><span class="line">    Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">    <span class="comment">// 从链表中删除上次返回的节点</span></span><br><span class="line">    unlink(lastReturned);</span><br><span class="line">    <span class="comment">// 修改指针</span></span><br><span class="line">    <span class="keyword">if</span> (next == lastReturned)</span><br><span class="line">        next = lastNext;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        nextIndex--;</span><br><span class="line">    <span class="comment">// 将上次返回的节点引用置为 null，方便 GC 回收</span></span><br><span class="line">    lastReturned = <span class="literal">null</span>;</span><br><span class="line">    expectedModCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="MRz65">总结</h3><font style="color:rgb(0, 0, 0);"> 1）linkedList本质上是</font><font style="color:rgb(255, 0, 0);">一个双向链表，通过一个Node内部类实现的这种链表结构</font><font style="color:rgb(0, 0, 0);">。</font>  <font style="color:rgb(0, 0, 0);"> 2）能</font><font style="color:rgb(255, 0, 0);">存储null值</font>  <font style="color:rgb(0, 0, 0);"> 3）跟</font><font style="color:rgb(255, 0, 0);">arrayList相比较，就真正的知道了，LinkedList在删除和增加等操作上性能好，而ArrayList在查询的性能上好</font>  <font style="color:rgb(0, 0, 0);"> 4）从源码中看，</font><font style="color:rgb(255, 0, 0);">它不存在容量不足的情况</font>  <font style="color:rgb(0, 0, 0);"> 5）linkedList不光</font><font style="color:rgb(255, 0, 0);">能够向前迭代，还能像后迭代，并且在迭代的过程中，可以修改值、添加值、还能移除值</font><font style="color:rgb(0, 0, 0);">。</font>  <font style="color:rgb(0, 0, 0);"> 6）linkedList不光能</font><font style="color:rgb(255, 0, 0);">当链表，还能当队列使用，这个就是因为实现了Deque接口</font><font style="color:rgb(0, 0, 0);">。</font><h2 id="oZyfI"><font style="color:rgb(0, 0, 0);">HashMap</font></h2><h3 id="okiH8">概述</h3>+ [Java 8系列之重新认识HashMap](https://tech.meituan.com/2016/06/24/java-hashmap.html)（这个看完可以不用看下面的大部分内容）+ HashMap中的key最好使用不可变对象，否则新值重写计算的hashcode和之前的值可能不一样，从而导致查询失败。<p><a href="https://www.bilibili.com/video/BV14r4y1R7e6/?spm_id_from=333.337.search-card.all.click&amp;vd_source=add54d0fcd49c96c6c124259f9775bc3">Java面试题：聊聊HashMap扩容的流程_哔哩哔哩_bilibili</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hashCode() 和 equals() 基于 name 和 age</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span> || getClass() != obj.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 创建一个 HashMap，并将 person1 作为键</span></span><br><span class="line">        HashMap&lt;Person, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(person1, <span class="string">&quot;Developer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询时能正常获取值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Before changing age: &quot;</span> + map.get(person1)); <span class="comment">// 输出: Developer</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改 person1 的 age</span></span><br><span class="line">        person1.age = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次查询时，由于 hashCode 改变，可能无法获取值;更改值后hash值发生了变化</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After changing age: &quot;</span> + map.get(person1)); <span class="comment">// 输出: null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印 map 内容以验证</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Map content: &quot;</span> + map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714140688908-3fb7af1a-851d-46cb-bdf1-42f132b644ca.png" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714145450610-1cff8ffe-4f7b-4304-9296-f991afb37864.png" alt=""></p><ul><li><font style="color:rgb(44, 62, 80);">HashMap</font><font style="color:rgb(44, 62, 80);"> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个</font></li><li><font style="color:rgb(44, 62, 80);">JDK1.8 之前 HashMap 由 数组+链表 组成的， JDK1.8 以后变成了数组加链表加红黑树</font></li><li><font style="color:rgb(44, 62, 80);">HashMap的数据结构和存储原理</font><ul><li><font style="color:rgb(44, 62, 80);">第一步：HashMap内部有一个entry的内部类，其中有四个属性，我们要存储一个值，则需要一个key和一个value，存到map中就会先将key和value保存在这个Entry类创建的对象中。</font></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">     　　　　  <span class="keyword">final</span> K key;    <span class="comment">//就是我们说的map的key</span></span><br><span class="line">      　　　　 V value;    <span class="comment">//value值，这两个都不陌生</span></span><br><span class="line">      　　　　 Entry&lt;K,V&gt; next;<span class="comment">//指向下一个entry对象</span></span><br><span class="line">      　　　　 <span class="type">int</span> hash;<span class="comment">//通过key算过来的你hashcode值。</span></span><br></pre></td></tr></table></figure><ul><li>Entry的物理模型图：<img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714140905651-d059c3c3-707e-46a0-b4c0-87e62ec93895.png" alt=""></li><li>第二步：构造好了entry对象，然后将该对象放入数组中</li><li>大概的一个存放过程是：通过entry对象中的hash值来确定将该对象存放在数组中的哪个位置上，如果在这个位置上还有其他元素，则通过链表来存储这个元素。当然JDK1.8后会把链表变成红黑树</li><li><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714140968955-8f63f6ee-f27e-44d5-acca-2040ad635912.png" alt=""></li><li><font style="color:rgb(0, 0, 0);">通过key、value封装成一个entry对象，然后通过key的值来计算该entry的hash值，通过entry的hash值和数组的长度length来计算出entry放在数组中的哪个位置上面，每次存放都是将entry放在第一个位置，在这个过程中，就是通过hash值来确定将该对象存放在数组中的哪个位置上。</font></li><li><font style="color:rgb(0, 0, 0);">JDK1.8后的结构</font><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714141155678-07626eb7-dd36-4140-ad46-b88e511ae44c.png" alt=""></li><li><font style="color:rgb(0, 0, 0);">上图很形象的展示了HashMap的数据结构（数组+链表+红黑树），</font><font style="color:rgb(255, 0, 0);">桶中的结构可能是链表，也可能是红黑树，红黑树的引入是为了提高效率。</font></li></ul><h3 id="UWsi4">源码分析</h3><h4 id="aiSyN">属性</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714145706705-12d10b25-2d38-4e07-b470-a6d11c264bbc.png" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714145712775-4243bde6-85e4-4e35-848a-66d0177a650d.png" alt=""></p><ul><li><font style="color:rgb(0, 0, 0);">HashMap的实例有两个参数影响其性能。</font><ul><li><font style="color:rgb(0, 0, 0);">初始容量：</font><font style="color:rgb(255, 0, 0);">哈希表中桶的数量</font></li><li><font style="color:rgb(0, 0, 0);">加载因子：</font><font style="color:rgb(255, 0, 0);">哈希表在其容量自动增加之前可以达到多满的一种尺度</font></li></ul></li><li>桶<ul><li>数组中每一个位置上都放有一个桶，每个桶里就是装一个链表，链表中可以有很多个元素(entry)，这就是桶的意思。也就相当于把元素都放在桶中。</li></ul></li><li><font style="color:rgb(0, 0, 0);">当哈希表中条目数超出了当前容量*加载因子(其实就是HashMap的实际容量)时，则对该哈希表进行rehash操作，将哈希表扩充至两倍的桶数。</font></li><li><font style="color:rgb(0, 0, 0);">loadFactor加载因子</font><ul><li><font style="color:rgb(0, 0, 0);">定义：loadFactor译为装载因子。</font><font style="color:rgb(255, 0, 0);">装载因子用来衡量HashMap满的程度。loadFactor的默认值为0.75f。计算HashMap的实时装载因子的方法为：size/capacity</font><font style="color:rgb(0, 0, 0);">，而不是占用桶的数量去除以capacity,这里的</font><font style="color:rgb(255, 0, 0);">capacity是底层数组的大小，size：指的是哈希表中当前存储的键值对数量</font></li><li><font style="color:rgb(0, 0, 0);">loadFactor加载因子是</font><font style="color:rgb(255, 0, 0);">控制数组存放数据的疏密程度</font><font style="color:rgb(0, 0, 0);">，</font><font style="color:rgb(255, 0, 0);">loadFactor越趋近于1，那么数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加</font><font style="color:rgb(0, 0, 0);">，loadFactor越小，也就是趋近于0</font></li><li><font style="color:rgb(0, 0, 0);">那么数组中存放的数据也就越稀，也就是可能数组中每个位置上就放一个元素。那有人说，就把loadFactor变为1最好吗，存的数据很多，但是这样会有一个问题，就是我们</font><font style="color:rgb(255, 0, 0);">在通过key拿到我们的value时，是先通过key的hashcode值，找到对应数组中的位置，如果该位置中有很多元素，则需要通过equals来依次比较链表中的元素，拿到我们的value值，这样花费的性能就很高，</font><font style="color:rgb(0, 0, 0);">如果</font><font style="color:rgb(255, 0, 0);">能让数组上的每个位置尽量只有一个元素最好，我们就能直接得到value值了，所以有人又会说，那把loadFactor变得很小不就好了，但是如果变得太小，在数组中的位置就会太稀，也就是分散的太开</font></li></ul></li><li><font style="color:rgb(0, 0, 0);">capacity</font><ul><li><font style="color:rgb(0, 0, 0);"> capacity译为容量代表的</font><font style="color:rgb(255, 0, 0);">数组的容量，也就是数组的长度，同时也是HashMap中桶的个数。默认值是16。</font></li><li><font style="color:rgb(255, 0, 0);">   一般第一次扩容时会扩容到64，之后好像是2倍。总之，</font><strong><font style="color:rgb(255, 0, 0);">容量都是2的幂</font></strong><font style="color:rgb(255, 0, 0);">。</font></li></ul></li><li>size<ul><li><font style="color:rgb(0, 0, 0);">size就是在</font><font style="color:rgb(255, 0, 0);">该HashMap的实例中实际存储的元素的个数</font></li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714185955600-95d6787e-dbab-465c-b5ff-0aecbff9345e.png" alt=""></p><h4 id="RPxAY">构造器</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714186734206-5f5f02c3-3f6c-4b1b-b92f-31eb627087a3.png" alt=""></p><ul><li>我们一般new HashMap()都是采用的无参构造，这个时候知识给负载因子赋值为0.75了，而没有给Node数组分配大小</li></ul><h4 id="MvPFF">put方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将指定值与此映射中的指定键关联。如果映射以前包含键的映射，则替换旧值。</span></span><br><span class="line"><span class="comment">// 形参:</span></span><br><span class="line"><span class="comment">// 关键 -指定值要关联的关键字 价值 -与指定密钥关联的值</span></span><br><span class="line"><span class="comment">// 返回值:</span></span><br><span class="line"><span class="comment">// 与key关联的前一个值，如果没有key的映射，则为空。(null返回也可以表明映射先前将null与key关联。</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>putVal方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 将第一个元素赋值给e，用e来记录</span></span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值，转化为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><font style="color:rgb(0, 0, 0);">HashMap并没有直接提供putVal接口给用户调用，而是提供的put函数，而put函数就是通过putVal来插入元素的。 </font></li></ul><hr><h4 id="wGytI">扩容</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1726461642433-7e2b8890-17ae-4df8-b847-64fc44bccfb4.png" alt=""></p><ul><li>threshold是所能容纳的key-value对极限；</li><li>threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</li></ul><p><font style="color:rgb(51, 51, 51);background-color:rgb(253, 253, 253);">①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容； ②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③； ③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals； ④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤； ⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； ⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</font></p><p><font style="color:rgb(51, 51, 51);background-color:rgb(253, 253, 253);"></font></p><p>resize方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 当前table保存</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 保存table大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 保存当前阈值 </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 之前table大小大于0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 之前table大于最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 阈值为最大整形</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 容量翻倍，使用左移，效率更高</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">            oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 阈值翻倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 之前阈值大于0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// oldCap = 0并且oldThr = 0，使用缺省值（如使用HashMap()构造函数，之后再插入一个元素会调用resize函数，会进入这一步）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;         </span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新阈值为0</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">// 初始化table</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 之前的table已经初始化过</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 复制元素，重新进行hash</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 将同一桶中的元素根据(e.hash &amp; oldCap)是否为0进行分割，分成两个不同的链表，完成rehash</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resize()</span><br></pre></td></tr></table></figure><ul><li><font style="color:rgb(0, 0, 0);">进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。</font></li></ul><p><font style="color:rgb(0, 0, 0);">在resize前和resize后的元素布局如下:</font></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714195310118-28f04e29-1434-4334-b4b3-42af2ce2dce3.png" alt=""></p><h2 id="lKOmK"><font style="color:rgb(44, 62, 80);">ConcurrentHashMap </font></h2><h3 id="g4ng4">概述</h3>+ 　在ConcurrentHashMap中通过一个Node<K,V>[]数组来保存添加到map中的键值对，而在同一个数组位置是通过链表和红黑树的形式来保存的。但是这个数组只有在第一次添加元素的时候才会初始化，否则只是初始化一个ConcurrentHashMap对象的话，只是设定了一个sizeCtl变量，这个变量用来判断对象的一些状态和是否需要扩容，后面会详细解释。+ 第一次添加元素的时候，默认初期长度为16，当往map中继续添加元素的时候，通过hash值跟数组长度取与来决定放在数组的哪个位置，如果出现放在同一个位置的时候，优先以链表的形式存放，在同一个位置的个数又达到了8个以上，如果数组的长度还小于64的时候，则会扩容数组。如果数组的长度大于等于64了的话，在会将该节点的链表转换成树。+ 　通过扩容数组的方式来把这些节点给分散开。然后将这些元素复制到扩容后的新的数组中，同一个链表中的元素通过hash值的数组长度位来区分，是还是放在原来的位置还是放到扩容的长度的相同位置去 。在扩容完成之后，如果某个节点的是树，同时现在该节点的个数又小于等于6个了，则会将该树转为链表。+ 　取元素的时候，相对来说比较简单，通过计算hash来确定该元素在数组的哪个位置，然后在通过遍历链表或树来判断key和key的hash，取出value值。+ 其是作为<font style="color:rgb(44, 62, 80);">线程安全的 HashMap</font>+ <font style="color:rgb(44, 62, 80);">JDK1.8储存结构</font>![](https://cdn.nlark.com/yuque/0/2024/png/28066124/1714196599884-0630fcf6-2922-491b-b5f8-7ed2f6bfc225.png)+ ![](https://cdn.nlark.com/yuque/0/2024/png/28066124/1714196639191-71e9db80-da55-4d9b-a861-eab07bb5f9c3.png)<h3 id="m0hS3">源码分析</h3>初始化 initTable<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//　如果 sizeCtl &lt; 0 ,说明另外的线程执行CAS 成功，正在进行初始化。</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 让出 CPU 使用权</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从源码中可以发现 ConcurrentHashMap 的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 sizeCtl （sizeControl 的缩写），它的值决定着当前的初始化状态。</p><ol><li>-1 说明正在初始化，其他线程需要自旋等待</li><li>-N 说明 table 正在进行扩容，高 16 位表示扩容的标识戳，低 16 位减 1 为正在进行扩容的线程数</li><li>0 表示 table 初始化大小，如果 table 没有初始化</li><li><blockquote><p>0 表示 table 扩容的阈值，如果 table 已经初始化。</p></blockquote></li></ol><blockquote><p>put</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">// key 和 value 不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">// f = 目标位置元素</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;<span class="comment">// fh 后面存放目标位置的元素 hash 值</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 数组桶为空，初始化数组桶（自旋+CAS)</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 使用 synchronized 加锁加入节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 说明是链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 循环加入新的或者覆盖节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">// 红黑树</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>根据 key 计算出 hashcode 。</li><li>判断是否需要进行初始化。</li><li>即<font style="color:#DF2A3F;">为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入</font>，失败则自旋保证成功。</li><li>如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。</li><li>如果都不满足，则利用 synchronized 锁写入数据。</li><li>如果数量大于 TREEIFY_THRESHOLD 则要执行树化方法，在 treeifyBin 中会首先判断当前数组长度 ≥64 时才会将链表转换为红黑树。</li><li><font style="color:#DF2A3F;">put操作中CAS的使用：</font><ul><li><font style="color:#DF2A3F;">从源码上来看，我们能够发现，ConcurrentHashMap 和 HashMap 的元素插入操作流程是非常相似的。最大的几个不同点在于：</font></li></ul></li></ul><p><font style="color:#DF2A3F;">1.如果槽是空的，那么添加元素的时候，ConcurrentHashMap 是通过 CAS操作来完成的。HashMap则是直接赋值。对比图如下：</font></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1726464357937-5c2bcb6d-7267-4192-8ab5-dd4a88d51140.png" alt=""></p><p>2.<font style="color:rgba(0, 0, 0, 0.75);">如果槽不是空的，在对槽中元素（链表/红黑树）进行遍历的时候。</font><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;ConcurrentHashMap&lt;/font&gt;</code><font style="color:rgba(0, 0, 0, 0.75);"> 有通过 </font><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;synchronized&lt;/font&gt;</code><font style="color:rgba(0, 0, 0, 0.75);"> 将整个</font><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;Node&lt;/font&gt;</code><font style="color:rgba(0, 0, 0, 0.75);">节点给加锁（也就是所谓的</font><strong><font style="color:rgba(0, 0, 0, 0.75);">分段锁</font></strong><font style="color:rgba(0, 0, 0, 0.75);">）。</font><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;HashMap&lt;/font&gt;</code><font style="color:rgba(0, 0, 0, 0.75);">则没有。</font></p><blockquote><p><font style="color:rgb(44, 62, 80);">get</font></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">// key 所在的 hash 位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果指定位置元素存在，头结点hash值相同</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="comment">// key hash 值相等，key值相同，直接返回元素 value</span></span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 头结点hash值小于0，说明正在扩容或者是红黑树，find查找</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 是链表，遍历查找</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结一下 get 过程：</p><ol><li>根据 hash 值计算位置。</li><li>查找到指定位置，如果头节点就是要找的，直接返回它的 value.</li><li>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。</li><li>如果是链表，遍历查找之。</li></ol><p>总结：</p><p>总的来说 ConcurrentHashMap 在 Java8 中相对于 Java7 来说变化还是挺大的，</p><p><font style="color:#DF2A3F;">Java8 中的 </font><font style="color:#DF2A3F;">ConcurrentHashMap</font><font style="color:#DF2A3F;"> 使用的 </font><font style="color:#DF2A3F;">Synchronized</font><font style="color:#DF2A3F;"> 锁加 CAS 的机制</font></p><ul><li>ConcurrentMaps (ConcurrentHashMaps, ConcurrentSkipListMaps)上，不允许null值的出现的主要原因是他可能会在并发的情况下带来难以容忍的二义性。如果在HashMap等非并发容器中，你可以通过contains方法来判断，这个key是究竟不存在，还是本来就是null。但是在并发容器中，如果允许空值的存在的话，你就没法判断真正的情况</li></ul><h2 id="aBtXy"><font style="color:rgb(44, 62, 80);">HashSet</font></h2><h3 id="yP2Ff">概述</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714197112493-80c57e98-c1e9-4244-b56b-5a3df6479461.png" alt=""></p><ul><li>无序性：HashSet 不保证元素的顺序，它不按照元素的插入顺序或者排序顺序进行存储。因此，当你迭代 HashSet 时，元素的顺序是不确定的。</li><li>唯一性：HashSet 中不允许重复的元素。如果你尝试将一个已经存在的元素添加到 HashSet 中，添加操作将会被忽略，不会有任何效果。</li><li>允许 null 元素：HashSet 允许存储 null 元素。你可以将 null 添加到 HashSet 中，并且只能添加一个 null 元素，因为它不允许重复。</li><li>线程不安全：HashSet 是线程不安全的。如果需要在多线程环境中使用，应该使用 Collections.synchronizedSet 包装 HashSet 或者使用 ConcurrentHashMap 作为其底层实现。</li><li>不保证元素的唯一性：虽然 HashSet 不允许集合中直接出现重复的元素，但是它依赖于对象的 equals() 和 hashCode() 方法来确定对象的唯一性。如果集合中的两个对象通过 equals() 方法比较是相等的，但它们的 hashCode() 返回不同的值，HashSet 仍然会认为它们是不同的元素，并允许它们同时存在于集合中。不过，这会降低性能，因为 HashSet 需要使用 equals() 方法来比较对象。</li><li>对于HashSet而言，它是基于HashMap实现的，HashSet底层使用HashMap来保存所有元素</li><li><font style="color:rgb(51, 51, 51);">添加值得时候会先获取对象的hashCode方法，如果hashCode 方法返回的值一致，则再调用equals方法判断是否一致，如果不一致才add元素。</font></li></ul><h3 id="Tcl5S"><font style="color:rgb(51, 51, 51);">源码分析</font></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714197613695-95a0c0d4-4d17-41ba-91b5-cf941974b9c3.png" alt=""></p><blockquote><p>属性</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714197721492-8e3d5bc5-22eb-4aff-9a5b-d745d5c88c5c.png" alt=""></p><ul><li>HashSet是基于HashMap实现的，HashMap是key和value结构，Hashset中的vaule是一个虚拟值</li></ul><blockquote><p>构造器</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714197678559-52fa920f-6895-4b36-abed-3159993b8498.png" alt=""></p><blockquote><p>方法</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1714197797615-047dd9d0-767d-4c4d-833c-0c7ed5c4684b.png" alt=""></p><ul><li>add方法保证元素不重复的关键就是map中添加key保证key不重复</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br></pre></td></tr></table></figure><ul><li>这里先比较的是Node节点的hash值也就是key的hashcode，然后就是(k = p.key) == key || (key != null &amp;&amp; key.equals(k)</li><li><font style="color:rgb(0, 0, 0);">当你把对象加入</font><font style="color:rgb(0, 0, 0);">HashSet</font><font style="color:rgb(0, 0, 0);">时，</font><font style="color:rgb(0, 0, 0);">HashSet</font><font style="color:rgb(0, 0, 0);">会先计算对象的</font><font style="color:rgb(0, 0, 0);">hashcode</font><font style="color:rgb(0, 0, 0);">值来判断对象加入的位置，同时也会与其他加入的对象的</font><font style="color:rgb(0, 0, 0);">hashcode</font><font style="color:rgb(0, 0, 0);">值作比较，如果没有相符的</font><font style="color:rgb(0, 0, 0);">hashcode</font><font style="color:rgb(0, 0, 0);">，</font><font style="color:rgb(0, 0, 0);">HashSet</font><font style="color:rgb(0, 0, 0);">会假设对象没有重复出现。但是如果发现有相同</font><font style="color:rgb(0, 0, 0);">hashcode</font><font style="color:rgb(0, 0, 0);">值的对象，这时会调用</font><font style="color:rgb(0, 0, 0);">equals()</font><font style="color:rgb(0, 0, 0);">方法来检查</font><font style="color:rgb(0, 0, 0);">hashcode</font><font style="color:rgb(0, 0, 0);">相等的对象是否真的相同。如果两者相同，</font><font style="color:rgb(0, 0, 0);">HashSet</font><font style="color:rgb(0, 0, 0);">就不会让加入操作成功。</font></li></ul><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;aech1&quot;&gt;ArrayList&lt;/h2&gt;
&lt;h3 id=&quot;GFV9x&quot;&gt;概述&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;实现接口图&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2024</summary>
      
    
    
    
    <category term="java" scheme="http://www.bojiboqi.fun/categories/java/"/>
    
    
    <category term="集合" scheme="http://www.bojiboqi.fun/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 Optional</title>
    <link href="http://www.bojiboqi.fun/2024/09/24/Java%208%20Optional/"/>
    <id>http://www.bojiboqi.fun/2024/09/24/Java%208%20Optional/</id>
    <published>2024-09-24T15:18:54.969Z</published>
    <updated>2024-09-24T15:49:19.825Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/quanzhan_King/article/details/130717621">【Java8新特性】史上最全Optional实战教程，太厉害了!_java optional使用场景-CSDN博客</a></p><h4 id="cI48O">一、简介</h4>Optional 是一个对象容器，具有以下两个特点：<ul><li><p>提示用户要注意该对象有可能为null</p><ul><li>简化if else代码</li></ul><h4 id="UrASE">二、使用介绍</h4>**1. 创建：**<ul><li>Optional.empty()： 创建一个空的 Optional 实例</li><li>Optional.of(T t)：创建一个 Optional 实例，当 t为null时抛出异常</li><li>Optional.ofNullable(T t)：创建一个 Optional 实例，但当 t为null时不会抛出异常，而是返回一个空的实例</li></ul><p><strong>2. 获取：</strong></p><ul><li>get()：获取optional实例中的对象，当optional 容器为空时报错</li></ul><p><strong>3. 判断：</strong></p><ul><li>isPresent()：判断optional是否为空，如果空则返回false，否则返回true</li><li>ifPresent(Consumer c)：如果optional不为空，则将optional中的对象传给Comsumer函数</li><li>orElse(T other)：如果optional不为空，则返回optional中的对象；如果为null，则返回 other 这个默认值</li><li>orElseGet(Supplier<T> other)：如果optional不为空，则返回optional中的对象；如果为null，则使用Supplier函数生成默认值other</li><li>orElseThrow(Supplier<X> exception)：如果optional不为空，则返回optional中的对象；如果为null，则抛出Supplier函数生成的异常</li></ul><p><strong>4. 过滤：</strong></p><ul><li>filter(Predicate<T> p)：如果optional不为空，则执行断言函数p，如果p的结果为true，则返回原本的optional，否则返回空的optional</li></ul><p><strong>5. 映射：</strong></p><ul><li>map(Function&lt;T, U&gt; mapper)：如果optional不为空，则将optional中的对象 t 映射成另外一个对象 u，并将 u 存放到一个新的optional容器中。</li><li>flatMap(Function&lt; T,Optional<U>&gt; mapper)：跟上面一样，在optional不为空的情况下，将对象t映射成另外一个optional</li><li>区别：map会自动将u放到optional中，而flatMap则需要手动给u创建一个optional</li></ul><h4 id="erKl1">三、Demo应用</h4>**需求：**<p>学校想从一批学生中，选出年龄大于等于18，参加过考试并且成绩大于80的人去参加比赛。<br><strong>准备数据：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private Integer score;</span><br><span class="line">  </span><br><span class="line">    //省略 construct get set</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public List&lt;Student&gt; initData()&#123;</span><br><span class="line">    Student s1 = new Student(&quot;张三&quot;, 19, 80);</span><br><span class="line">    Student s2 = new Student(&quot;李四&quot;, 19, 50);</span><br><span class="line">    Student s3 = new Student(&quot;王五&quot;, 23, null);</span><br><span class="line">    Student s4 = new Student(&quot;赵六&quot;, 16, 90);</span><br><span class="line">    Student s5 = new Student(&quot;钱七&quot;, 18, 99);</span><br><span class="line">    Student s6 = new Student(&quot;孙八&quot;, 20, 40);</span><br><span class="line">    Student s7 = new Student(&quot;吴九&quot;, 21, 88);</span><br><span class="line"> </span><br><span class="line">    return Arrays.asList(s1, s2, s3, s4, s5, s6, s7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>java8 之前写法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void beforeJava8() &#123;</span><br><span class="line">    List&lt;Student&gt; studentList = initData();</span><br><span class="line"> </span><br><span class="line">    for (Student student : studentList) &#123;</span><br><span class="line">        if (student != null) &#123;</span><br><span class="line">            if (student.getAge() &gt;= 18) &#123;</span><br><span class="line">                Integer score = student.getScore();</span><br><span class="line">                if (score != null &amp;&amp; score &gt; 80) &#123;</span><br><span class="line">                    System.out.println(&quot;入选：&quot; + student.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>java8 写法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void useJava8() &#123;</span><br><span class="line">    List&lt;Student&gt; studentList = initData();</span><br><span class="line">    for (Student student : studentList) &#123;</span><br><span class="line">        Optional&lt;Student&gt; studentOptional = Optional.of(student);</span><br><span class="line">        Integer score = studentOptional.filter(s -&gt; s.getAge() &gt;= 18).map(Student::getScore).orElse(0);</span><br><span class="line"> </span><br><span class="line">        if (score &gt; 80) &#123;</span><br><span class="line">            System.out.println(&quot;入选：&quot; + student.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><meta name="referrer" content="no-referrer"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/quanzhan_King/article/details/130717621&quot;&gt;【Java8新特性】史上最全Optional实战教程，太厉害了!_java optional使用场景-CSDN博客&lt;/a&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="java" scheme="http://www.bojiboqi.fun/categories/java/"/>
    
    
    <category term="函数式编程" scheme="http://www.bojiboqi.fun/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>流Stream基础</title>
    <link href="http://www.bojiboqi.fun/2024/09/24/%E6%B5%81Stream%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.bojiboqi.fun/2024/09/24/%E6%B5%81Stream%E5%9F%BA%E7%A1%80/</id>
    <published>2024-09-24T15:16:17.419Z</published>
    <updated>2024-09-24T16:11:38.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LGKzq">写在前面</h2>如果说函数式接口和lambda表达式是Java中函数式编程的基石，那么stream就是在基石上的最富丽堂皇的大厦。<p>只有熟悉了stream，你才能说熟悉了Java 的函数式编程。</p><p>本文主要介绍Stream的基础概念和基本操作，让大家对Stream有一个初步的理解。</p><p>本文的示例代码可从gitee上获取：<a href="https://gitee.com/cnmemset/javafp">https://gitee.com/cnmemset/javafp</a></p><h2 id="HyDMW">stream的概念</h2>首先，看一个典型的stream例子：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void simpleStream() &#123;</span><br><span class="line">    List&lt;String&gt; words = Arrays.asList(&quot;hello&quot;, &quot;world&quot;, &quot;I&quot;, &quot;love&quot;, &quot;you&quot;);</span><br><span class="line">    int letterCount = words.stream()</span><br><span class="line">            .filter(s -&gt; s.length() &gt; 3)  // 过滤掉长度小于等于3的单词</span><br><span class="line">            .mapToInt(String::length)     // 将每个单词映射为单词长度</span><br><span class="line">            .sum();  // 计算总长度 5(hello) + 5(world) + 4(love) = 14</span><br><span class="line"> </span><br><span class="line">    // 输出为 14</span><br><span class="line">    System.out.println(letterCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述例子中，我们将字符串列表 words 作为stream的数据源，然后执行了 filter-map-reduce 的系列操作（sum方法属于 reduce 操作），后面会详细介绍map和reduce 操作。如果你有大数据的编程经验，会更容易理解map和reduce的含义。</p><p>stream的定义比较晦涩，大致可以理解为是一个支持串行或并行操作的数据元素序列。它具备以下几个特点：</p><ul><li>首先，stream不是一种数据结构，它并不存储数据。stream是某个数据源之上的数据视图。数据源可以是一个数组，或者是一个Collection类，甚至还可以是I/O channel。它通过一个计算管道（a pipeline of computational operations），对数据源的数据进行filter-map-reduce的操作。</li><li>其次，stream天生支持函数式编程。函数式编程的一个重要特点就是不会修改变量的值（没有“副作用”）。而对stream的任何操作，都不会修改数据源中的数据。例如，对一个数据源为Collection的stream进行filter操作，只会生成一个新的stream对象，而不会真的删除底层数据源中的元素。</li><li>第三，stream的许多操作都是惰性求值的（laziness-seeking）。惰性求值是指该操作只是对stream的一个描述，并不会马上执行。这类惰性的操作在stream中被称为中间操作（intermediate operations）。</li><li>第四，stream呈现的数据可以是无限的。例如Stream.generate可以生成一个无限的流。我们可以通过 limit(n) 方法来将一个无限流转换为有限流，或者通过 findFirst() 方法终止一个无限流。</li><li>最后，stream中的元素只能被消费1次。和迭代器 Iterator 相似，当需要重复访问某个元素时，需要重新生成一个新的stream。</li></ul><p>stream的操作可以分成两类，<strong>中间操作</strong>（intermediate operations）和<strong>终止操作</strong>（terminal operations）。一个stream管道（stream pipeline）是由一个数据源 + 0个或多个中间操作 + 1个终止操作组成的。</p><p><strong>中间操作：</strong><br>中间操作（intermediate operations）指的是将一个stream转换为另一个stream的操作，譬如filter和map操作。中间操作都是惰性的，它们的作用仅仅是描述了一个新的stream，不会马上被执行。</p><p><strong>终止操作：</strong><br>终止操作（terminal operations）则指的是那些会产生一个新值或副作用（side-effect）的操作，譬如count 和 forEach 操作。只有遇到终止操作时，之前定义的中间操作才会真正被执行。需要注意，当一个stream执行了一个终止操作后，它的状态会变成“已消费”，不能再被使用。</p><p>为了证实“中间操作都是惰性的”，我们设计了一个实验性的示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public static void intermediateOperations() &#123;</span><br><span class="line">    List&lt;String&gt; words = Arrays.asList(&quot;hello&quot;, &quot;world&quot;, &quot;I&quot;, &quot;love&quot;, &quot;you&quot;);</span><br><span class="line"> </span><br><span class="line">    System.out.println(&quot;start: &quot; + System.currentTimeMillis());</span><br><span class="line"> </span><br><span class="line">    Stream&lt;String&gt; interStream = words.stream()</span><br><span class="line">            .filter(s -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // do nothing</span><br><span class="line">                &#125;</span><br><span class="line">                return s.length() &gt; 3;</span><br><span class="line">            &#125;);</span><br><span class="line">    IntStream intStream = interStream.mapToInt(s -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            // do nothing</span><br><span class="line">        &#125;</span><br><span class="line">        return s.length();</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    // 因为 filter 和 map 操作都属于中间操作，并不会真正执行，</span><br><span class="line">    // 所以它们不受 Thread.sleep 的影响，耗时很短</span><br><span class="line">    System.out.println(&quot;after filter &amp;&amp; map: &quot; + System.currentTimeMillis());</span><br><span class="line"> </span><br><span class="line">    int letterCount = intStream.sum();</span><br><span class="line"> </span><br><span class="line">    // sum 属于终止操作，会执行之前定义的中间操作，</span><br><span class="line">    // Thread.sleep 被真正执行了，耗时为 5(filter) + 3(mapToInt) = 8秒</span><br><span class="line">    System.out.println(&quot;after sum: &quot; + System.currentTimeMillis());</span><br><span class="line"> </span><br><span class="line">    // 输出为 14</span><br><span class="line">    System.out.println(letterCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的输出类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start: 1633438922526</span><br><span class="line">after filter &amp;&amp; map: 1633438922588</span><br><span class="line">after sum: 1633438930620</span><br><span class="line">14</span><br></pre></td></tr></table></figure><p>可以看到，上述代码验证了“中间操作都是惰性的”：打印“start”和打印“after filter &amp;&amp; map”之间只隔了几十毫秒，而打印“after sum”则在8秒之后，证明了只有在遇到 sum 操作后，filter 和 map 中定义的函数才真正被执行。</p><h2 id="KkgUv">生成一个stream对象</h2>Java 8中，引入了4个stream的接口：Stream、IntStream、LongStream、DoubleStream，分别对应Object类型，以及基础类型int、long和double。如下图所示：  ![](https://cdn.nlark.com/yuque/0/2024/png/28066124/1720158405946-ae6c963b-89d4-4952-83e1-e0b5a096b3c8.png)<p>在Java中，与stream相关的操作基本都是通过上述的4个接口来实现的，不会涉及到具体的stream实现类。要得到一个stream，通常不会手动创建，而是调用对应的工具方法。</p><p>常用的工具方法包括：</p><ol><li>Collection方法：Collection.stream() 或 Collection.parallelStream()</li><li>数组方法：Arrays.stream(Object[])</li><li>工厂方法：Stream.of(Object[]), IntStream.range(int, int) 或 Stream.iterate(Object, UnaryOperator) 等等</li><li>读取文件方法：BufferedReader.lines()</li><li>类 java.nio.file.Files 中，也提供了Stream相关的API，例如 Files.list, Files.walk 等等</li></ol><h2 id="rA7vV">Stream的基本操作</h2>我们以接口Stream为例，先介绍stream的一些基本操作。<h2 id="zIJ9P">forEach()</h2>Stream中的forEach方法和Collection中的forEach方法相似，都是对每个元素执行指定的操作。<p>forEach方法签名为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void forEach(Consumer&lt;? super T&gt; action)</span><br></pre></td></tr></table></figure><p>forEach方法是一个终止操作，意味着在它之前的所有中间操作都将会被执行，然后再马上执行 action 。</p><h2 id="jbk30">filter()</h2>filter方法的方法签名是：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</span><br></pre></td></tr></table></figure><p>filter方法是一个中间操作，它的作用是根据参数 predicate 过滤元素，返回一个只包含满足predicate条件元素的Stream。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void filterStream() &#123;</span><br><span class="line">    List&lt;String&gt; words = Arrays.asList(&quot;hello&quot;, &quot;world&quot;, &quot;I&quot;, &quot;love&quot;, &quot;you&quot;);</span><br><span class="line">    words.stream()</span><br><span class="line">            .filter(s -&gt; s.length() &gt; 3)  // 过滤掉长度小于等于3的单词</span><br><span class="line">            .forEach(s -&gt; System.out.println(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">love</span><br></pre></td></tr></table></figure><h2 id="rlQkT">limit()</h2>limit方法签名为：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; limit(long maxSize);</span><br></pre></td></tr></table></figure><p>limit方法是一个短路型（short-circuiting）的中间操作，作用是将当前的Stream截断，只留下最多 maxSize 个元素组成一个新的Stream。短路型（short-circuiting）的含义是指将一个无限元素的Stream转换为一个有限元素的Stream。</p><p>例如，Random.ints 可以生成一个近似无限的随机整数流，我们可以通过limit方法限制生成随机整数的个数。示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void limitStream() &#123;</span><br><span class="line">    Random random = new Random();</span><br><span class="line"> </span><br><span class="line">    // 打印左闭右开区间中 [1, 100) 中的 5 个随机整数</span><br><span class="line">    random.ints(1, 100)</span><br><span class="line">            .limit(5)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的输出类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">90</span><br><span class="line">31</span><br><span class="line">31</span><br><span class="line">52</span><br><span class="line">63</span><br></pre></td></tr></table></figure><h2 id="jUw5q">distinct()</h2>distinct的方法签名是：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; distinct();</span><br></pre></td></tr></table></figure><p>distinct是一个中间操作，作用是返回一个去除重复元素后的Stream。</p><p>作者曾遇到过一个有趣的场景：要生成10个不重复的随机数字。可以结合Random.ints （Random.ints 可以生成一个近似无限的随机整数流）方法来实现这个需求。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void distinctStream() &#123;</span><br><span class="line">    Random random = new Random();</span><br><span class="line"> </span><br><span class="line">    // 在左闭右开区间中 [1, 100) 随机生成 10 个不重复的数字</span><br><span class="line">    random.ints(1, 100)</span><br><span class="line">            .distinct()</span><br><span class="line">            .limit(10)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line"> </span><br><span class="line">    /*</span><br><span class="line">    // 一个有趣的问题，如果 limit 方法放在 distinct 前面，</span><br><span class="line">    // 结果和上面的代码有什么区别吗？</span><br><span class="line">    // 欢迎加群讨论。</span><br><span class="line">    random.ints(1, 100)</span><br><span class="line">            .limit(10)</span><br><span class="line">            .distinct()</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dNWVz">sorted()</h2>sorted的方法签名有两个，分别是：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; sorted();</span><br><span class="line"></span><br><span class="line">Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator);</span><br></pre></td></tr></table></figure><p>前者是按照自然顺序排序，后者是根据指定的比较器进行排序。</p><p>sorted方法是一个中间操作，和Collection.sort方法作用相似。</p><p>示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void sortedStream() &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;Guangdong&quot;, &quot;Fujian&quot;, &quot;Hunan&quot;, &quot;Guangxi&quot;);</span><br><span class="line"> </span><br><span class="line">    // 自然排序</span><br><span class="line">    list.stream().sorted().forEach(System.out::println);</span><br><span class="line"> </span><br><span class="line">    System.out.println(&quot;===============&quot;);</span><br><span class="line"> </span><br><span class="line">    // 对省份进行排序，首先按照长度排序，如果长度一样，则按照字母顺序排序</span><br><span class="line">    list.stream().sorted((first, second) -&gt; &#123;</span><br><span class="line">        int lenDiff = first.length() - second.length();</span><br><span class="line">        return lenDiff == 0 ? first.compareTo(second) : lenDiff;</span><br><span class="line">    &#125;).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Fujian</span><br><span class="line">Guangdong</span><br><span class="line">Guangxi</span><br><span class="line">Hunan</span><br><span class="line">===============</span><br><span class="line">Hunan</span><br><span class="line">Fujian</span><br><span class="line">Guangxi</span><br><span class="line">Guangdong</span><br></pre></td></tr></table></figure><h2 id="WQIa9">结语</h2>欢迎来到 Java 的函数式编程世界！！！<p>本文介绍了 Stream 的概念和基本操作。大家尤其要理解中间操作和终止操作的概念。</p><p>认真阅读完本文后，你应该对 Stream 有了一个初步的认识，但这只是 Stream 编程的入门，更有趣更有挑战性更有可玩性的还是随后即将要介绍的 map-reduce 操作。</p><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LGKzq&quot;&gt;写在前面&lt;/h2&gt;
如果说函数式接口和lambda表达式是Java中函数式编程的基石，那么stream就是在基石上的最富丽堂皇的大厦。
&lt;p&gt;只有熟悉了stream，你才能说熟悉了Java 的函数式编程。&lt;/p&gt;
&lt;p&gt;本文主要介绍Stream的基础</summary>
      
    
    
    
    <category term="java" scheme="http://www.bojiboqi.fun/categories/java/"/>
    
    
    <category term="函数式编程" scheme="http://www.bojiboqi.fun/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>lambda表达式</title>
    <link href="http://www.bojiboqi.fun/2024/09/24/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://www.bojiboqi.fun/2024/09/24/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2024-09-24T15:15:43.048Z</published>
    <updated>2024-09-24T15:54:03.446Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面</p><p>lambda表达式是一个匿名函数。在Java 8中，它和函数式接口一起，共同构建了函数式编程的框架。</p><p>lambda表达式乍看像是匿名内部类的一种语法糖，但实际上，它们是两种本质不同的事物。匿名内部类本质是一个类，只是不需要程序员显示指定类名，编译器会自动为该类取名。而 lambda 表达式本质是一个函数，当然，编译器也会为它取名。在JVM层面，匿名内部类对应的是一个 class 文件，而 lambda 表达式对应的是它所在主类的一个私有方法。</p><p>lambda 表达式可以在函数体中引用外部的变量，从而实现了闭包。但 Java 对进入闭包的变量有 final 的限制，当然我们可以绕开这个限制。</p><h2 id="lambda表达式与匿名内部类">lambda表达式与匿名内部类</h2><p>lambda表达式可以用来简化某些匿名内部类（Anonymous Inner Classes）的写法，但仅限于对函数式接口的简写。</p><h3 id="无参的函数式接口">无参的函数式接口</h3><p>以最常用的Runnable接口为例：</p><p>在Java 7中，如果需要新建一个线程，使用匿名内部类的写法是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void createThreadWithAnonymousClass() &#123;</span><br><span class="line">    // Runnable 是接口名。我们通过匿名内部类的方式，构造了一个 Runnable 的实例。</span><br><span class="line">    Thread t = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;Thread is running&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用匿名内部类的一个重要目的，就是为了减轻程序员的代码负担，不需要额外再定义一个类，而且这个类是一个一次性的类，没有太多的重用价值。但是，我们会发现，这个对象看起来也是多余的，因为我们实际上并不是要传入一个对象，而只是想传入一个方法。</p><p>在Java 8中，因为 Runnable 接口是一个函数式接口（只有一个抽象方法的接口都属于函数式接口），因此我们可以用lambda表达式来简化匿名内部类的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void createThreadWithLambda() &#123;</span><br><span class="line">    // 在Java 8中，Runnable 是一个函数式接口，因此我们可以使用 lambda 表达式来实现它。</span><br><span class="line">    Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;Thread is running&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带参的函数式接口">带参的函数式接口</h3><p>Runnable是一个无参的函数式接口，我们再来看一个典型的带参数的函数式接口 Comparator：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Comparator&lt;T&gt; &#123;</span><br><span class="line">    int compare(T o1, T o2);</span><br><span class="line">  </span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设一个场景：给定一个省份的拼音列表，需要对该列表中的省份进行排序，排序规则是字母长度最小的省份排在前面，如果两个省份字母长度一样，则按字母顺序排序。</p><p>使用匿名内部类的示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void sortProvincesWithAnonymousClass() &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;Guangdong&quot;, &quot;Zhejiang&quot;, &quot;Jiangsu&quot;, &quot;Xizang&quot;, &quot;Fujian&quot;, &quot;Hunan&quot;, &quot;Guangxi&quot;);</span><br><span class="line"></span><br><span class="line">    list.sort(new Comparator&lt;String&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(String first, String second) &#123;</span><br><span class="line">            int lenDiff = first.length() - second.length();</span><br><span class="line">            return lenDiff == 0 ? first.compareTo(second) : lenDiff;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    list.forEach(s -&gt; System.out.println(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出为：</p><p>Hunan</p><p>Fujian</p><p>Xizang</p><p>Guangxi</p><p>Jiangsu</p><p>Zhejiang</p><p>Guangdong</p><p>使用lambda表达式来简化Comparator的实现，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void sortProvincesWithLambda() &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;Guangdong&quot;, &quot;Zhejiang&quot;, &quot;Jiangsu&quot;, &quot;Xizang&quot;, &quot;Fujian&quot;, &quot;Hunan&quot;, &quot;Guangxi&quot;);</span><br><span class="line"> </span><br><span class="line">    // 下面的参数列表 first 和 second ，即方法 Comparator.compare 的参数列表</span><br><span class="line">    list.sort((first, second) -&gt; &#123;</span><br><span class="line">        int lenDiff = first.length() - second.length();</span><br><span class="line">        return lenDiff == 0 ? first.compareTo(second) : lenDiff;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    list.forEach(s -&gt; System.out.println(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到，带参数的lambda表达式，甚至不需要声明类型，因为编译器可以通过上下文来推断出参数的类型。当然，我们也可以显式指定参数类型，尤其是在参数类型推断失败的时候：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second) -&gt; &#123;</span><br><span class="line">    int lenDiff = first.length() - second.length();</span><br><span class="line">    return lenDiff == 0 ? first.compareTo(second) : lenDiff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this关键字的作用域">this关键字的作用域</h3><p>前面提到过，匿名内部类和lambda表达式本质是不同的：匿名内部类本质是一个类，而lambda表达式本质是一个函数。在JVM层面，匿名内部类对应的是一个class文件，而lambda表达式对应的是它所在主类的一个私有方法。</p><p>这就导致了this关键字在匿名内部类和lambda表达式中是不一样的。在匿名内部类中，this关键字指向匿名内部类的实例，而在lambda表达式中，this关键字指向的是主类的实例。</p><p>我们用代码验证一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class ThisScopeExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThisScopeExample example = new ThisScopeExample();</span><br><span class="line"></span><br><span class="line">        // 输出 &quot;I am Anonymous Class.&quot;</span><br><span class="line">        example.runWithAnonymousClass();</span><br><span class="line">        // 输出 &quot;I am ThisScopeExample Class.&quot;</span><br><span class="line">        example.runWithLambda();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void runWithAnonymousClass() &#123;</span><br><span class="line">        // 以匿名类的方式运行</span><br><span class="line">        run(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                // this 是实现了接口 Runnable 的匿名内部类的实例</span><br><span class="line">                System.out.println(this);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public String toString() &#123;</span><br><span class="line">                return &quot;I am Anonymous Class.&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void runWithLambda() &#123;</span><br><span class="line">        // 以lambda表达式的方式运行</span><br><span class="line">        run(() -&gt; &#123;</span><br><span class="line">            // this 是类 ThisScopeExample 的实例</span><br><span class="line">            System.out.println(this);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run(Runnable runnable) &#123;</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;I am ThisScopeExample Class.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出为：</p><p>I am Anonymous Class.</p><p>I am ThisScopeExample Class.</p><h2 id="lambda表达式的语法">lambda表达式的语法</h2><p>lambda表达式的语法是：参数，箭头(-&gt;) 以及方法体。如果方法体无法用一个表达式来完成，就可以像写普通的方法一样，把代码放在大括号 { } 中。反之，如果方法体只有一个表达式，那么就可以省略大括号 { }。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second) -&gt; &#123;</span><br><span class="line">    int lenDiff = first.length() - second.length();</span><br><span class="line">    return lenDiff == 0 ? first.compareTo(second) : lenDiff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述是一个典型的而且完整的lambda表达式。</p><p>对无参数的lambda表达式，参数部分也不能省略，需要提供空括号，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Integer&gt; supplier = () -&gt; &#123;</span><br><span class="line">    return new Random().nextInt(100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的lambda表达式，可以发现它的方法体只有一个表达式，所以，它可以省略大括号，甚至return关键字也省略了，因为编译器可以根据上下文推断是否需要返回值：如果需要，那么就返回该唯一表达式的返回值，如果不需要，则在该唯一表达式后直接return。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Supplier 是需要返回值的，所以下面的lambda表达式等同于：</span><br><span class="line">// () -&gt; &#123; return new Random().nextInt(100); &#125;</span><br><span class="line">Supplier&lt;Integer&gt; supplier = () -&gt; new Random().nextInt(100);</span><br><span class="line"> </span><br><span class="line">// Runnable 是不需要返回值的，所以下面的lambda表达式等同于：</span><br><span class="line">// () -&gt; &#123; new Random().nextInt(100); return; &#125;</span><br><span class="line">Runnable runnable = () -&gt; new Random().nextInt(100);</span><br></pre></td></tr></table></figure><p>如果编译器可以推断出lambda表达式的参数类型，则可以忽略其类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 在这里，编译器可以推断出 first 和 second 的类型是 String。</span><br><span class="line">Comparator&lt;String&gt; comp = (first, second) -&gt; &#123;</span><br><span class="line">    int lenDiff = first.length() - second.length();</span><br><span class="line">    return lenDiff == 0 ? first.compareTo(second) : lenDiff;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果lambda表达式只有一个参数，那么参数列表中的小括号也可以省略掉：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这里的 value ，等同于 (value)</span><br><span class="line">Consumer&lt;String&gt; consumer = value -&gt; System.out.println(value);</span><br></pre></td></tr></table></figure><p>与普通的函数不一样，lambda表达式不需要指定返回类型，它总是由编译器自行推断出返回类型。如果推断失败，则默认为Object类型。</p><h2 id="lambda表达式与闭包">lambda表达式与闭包</h2><p>首先要理解lambda表达式和闭包（closure）是两个不同的概念，但两者有着紧密的联系。在不追求概念精确的场合，甚至可以说Java中的lambda表达式就是闭包。</p><p>闭包又称为函数闭包（function closure），是一种延长变量生命周期的技术，从这个意义上说，闭包和面向对象实现的功能是等价的。</p><p>闭包的定义是：在创建或定义一个函数的时候，除了记录函数本身以外，同时还记录了在创建函数时所能访问到的自由变量（自由变量 free variable，是指在函数外部定义的变量，它既不是函数的参数，也不是函数内的局部变量）。这样一来，闭包的变量作用域除了包含函数运行时的局部变量域外，还包含了函数定义时的外部变量域。</p><p>文字表达可能不够直观，我们来看一个代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ClosureExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 平方</span><br><span class="line">        IntUnaryOperator square = getPowOperator(2);</span><br><span class="line"> </span><br><span class="line">        // 立方</span><br><span class="line">        IntUnaryOperator cube = getPowOperator(3);</span><br><span class="line"> </span><br><span class="line">        // 四次方</span><br><span class="line">        IntUnaryOperator fourthPower = getPowOperator(4);</span><br><span class="line"> </span><br><span class="line">        // 5的平方</span><br><span class="line">        System.out.println(square.applyAsInt(5));</span><br><span class="line">        // 5的立方</span><br><span class="line">        System.out.println(cube.applyAsInt(5));</span><br><span class="line">        // 5的四次方</span><br><span class="line">        System.out.println(fourthPower.applyAsInt(5));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static IntUnaryOperator getPowOperator(int exp) &#123;</span><br><span class="line">        return base -&gt; &#123;</span><br><span class="line">            // 变量 exp 是 getPowOperator 的参数，属于lambda 表达式定义时的自由变量，</span><br><span class="line">            // 它的生命周期会延长到和返回的 lambda 表达式一样长。</span><br><span class="line">            return (int) Math.pow(base, exp);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的输出是：</p><p>25</p><p>125</p><p>625</p><p>可以看到，exp是方法 getPowOperator 的参数，但通过闭包技术，它“逃逸”出 getPowOperator 的作用域了。</p><p>很显然，变量“逃逸”，在多线程环境下，容易导致线程安全问题，防不胜防。因此，Java规定了，在lambda表达式内部引用外部变量的话，必须是final的，即不可变对象，只能赋值一次，不可修改。（在这说句题外话，并不是所有的语言都这么要求闭包的，譬如Python和JavaScript，闭包中引用的外部变量是可以任意修改的。）</p><p>为了书写代码方便，Java 8不要求显式将变量声明为final，但如果你尝试修改变量的值，编译器将会报错。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static IntUnaryOperator getPowOperator(int exp) &#123;</span><br><span class="line">    // 尝试修改 exp 的值，但编译器会在lambda表达式中报错</span><br><span class="line">    exp++;</span><br><span class="line">    return base -&gt; &#123;</span><br><span class="line">        // 如果尝试修改 exp 的值，会在此处报错：</span><br><span class="line">        // Error: 从lambda 表达式引用的本地变量必须是final变量或实际上的final变量</span><br><span class="line">        return (int) Math.pow(base, exp);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这种限制也是有限的，因为我们可以通过将变量声明为一个数组或一个类就可以修改其中的值。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static IntUnaryOperator getPowOperator(int[] exp) &#123;</span><br><span class="line">    // exp 是一个int数组：exp = new int[1];</span><br><span class="line">    exp[0]++;</span><br><span class="line">    return base -&gt; &#123;</span><br><span class="line">        // 此时不会报错，可以正常运行</span><br><span class="line">        return (int) Math.pow(base, exp[0]);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语">结语</h2><p>lambda表达式的出现，一方面为函数式编程提供了支持，另一方面也提升了Java程序员的生产力。我们要熟悉常见的函数式接口，灵活使用lambda表达式和闭包。</p><blockquote><p>为方便大家在移动端浏览，已注册微信公众号【员说】，欢迎关注。第一时间更新技术文章，也会不定时分享圈内热门动态和一线大厂内幕。</p><p>感谢您阅读本篇文章，如果觉得本文对您有帮助，欢迎点击推荐和关注，您的支持是我最大的写作动力。</p><p>文章欢迎转载，但需在文章页面明显位置，给出作者和原文链接，否则保留追究法律责任的权利！</p><p>注意！应各位朋友的邀请，创建了一个技术交流群，（聊技术/看内幕/找内推/读书分享等，拒绝水群，保证品质），可添加微信号【yuanshuo824】，备注：交流，即可入群。</p></blockquote><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写在前面&lt;/p&gt;
&lt;p&gt;lambda表达式是一个匿名函数。在Java 8中，它和函数式接口一起，共同构建了函数式编程的框架。&lt;/p&gt;
&lt;p&gt;lambda表达式乍看像是匿名内部类的一种语法糖，但实际上，它们是两种本质不同的事物。匿名内部类本质是一个类，只是不需要程序员显示指定</summary>
      
    
    
    
    <category term="java" scheme="http://www.bojiboqi.fun/categories/java/"/>
    
    
    <category term="函数式编程" scheme="http://www.bojiboqi.fun/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Stream中的Pipeline理解</title>
    <link href="http://www.bojiboqi.fun/2024/09/24/Stream%E4%B8%AD%E7%9A%84Pipeline%E7%90%86%E8%A7%A3/"/>
    <id>http://www.bojiboqi.fun/2024/09/24/Stream%E4%B8%AD%E7%9A%84Pipeline%E7%90%86%E8%A7%A3/</id>
    <published>2024-09-24T15:14:35.328Z</published>
    <updated>2024-09-24T16:14:45.275Z</updated>
    
    <content type="html"><![CDATA[<p>基于下面一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;123&quot;, &quot;123123&quot;);</span><br><span class="line">    list.stream().map(item -&gt; item+&quot;&quot;).forEach(System.out::print);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这里的list对象是一个ArrayList实例，debug代码进入stream方法，可以看见进入到<code>Collection.java</code>类中的<code>stream()</code>中<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1719991486648-89350fd9-1b56-4e85-bcac-bd98abecefed.png" alt=""><br>这里的源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">default Stream&lt;E&gt; stream() &#123;</span><br><span class="line">        return StreamSupport.stream(spliterator(), false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>关于分割迭代器的内容会在另外一篇文章详解，这里不再赘述。进入<code>StreamSupport.stream()</code>方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StreamSupport.java</span><br><span class="line">    public static &lt;T&gt; Stream&lt;T&gt; stream(Spliterator&lt;T&gt; spliterator, boolean parallel) &#123;</span><br><span class="line">        Objects.requireNonNull(spliterator);</span><br><span class="line">        return new ReferencePipeline.Head&lt;&gt;(spliterator,</span><br><span class="line">                                            StreamOpFlag.fromCharacteristics(spliterator),</span><br><span class="line">                                            parallel);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>咱们可以看到Stream是一个<code>ReferencePipeline.Head</code>类的实例，通过idea的类图结构功能，我们可以看到下面这个层次结构：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1719991486634-dc5655b9-12da-4204-bd37-517bf2899a2c.png" alt=""></p><p>所有的流基本都是来自于<code>BaseStream</code>，<code>AbstractPipeline</code>，<code>ReferencePipeline</code>这三个抽象类或接口。</p><p>ReferencePipeline的实现类一共就三种：</p><ol><li>Head</li><li>StatelessOp</li><li>StatefulOp</li></ol><p>查看了源码即可知道：AbstractPipeline其实就是一个双向链表中的一个节点。【我是这么理解的】</p><p>Head：代表的是流的源头，刚构建的时候流的一些属性被包含在这个对象。比如这个集合的元素，毕竟流的存在还是为了对一组元素的操作。</p><p>StatelessOp：代表的是无状态的操作，如map()</p><p>StatefulOp：代表的是有状态的操作，如sorted()</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1719991486841-39e4e1ee-944f-4f76-8bb4-81d2fab2de45.png" alt=""></p><p>所以stream()方法执行之后，拿到的是一个<code>ReferencePipeline.Head</code>实例，并没有构建<code>StatelessOp</code>，<code>StatefulOp</code>实例。</p><p>因为stream方法返回值是一个Head实例，而Head类并未重写map方法，所以map方法的实际执行还是走的ReferencePipeline类的map方法，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public final &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super P_OUT, ? extends R&gt; mapper) &#123;</span><br><span class="line">        Objects.requireNonNull(mapper);</span><br><span class="line">        return new StatelessOp&lt;P_OUT, R&gt;(this, StreamShape.REFERENCE,</span><br><span class="line">                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            Sink&lt;P_OUT&gt; opWrapSink(int flags, Sink&lt;R&gt; sink) &#123;</span><br><span class="line">                return new Sink.ChainedReference&lt;P_OUT, R&gt;(sink) &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void accept(P_OUT u) &#123;</span><br><span class="line">                        downstream.accept(mapper.apply(u));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的返回是一个继承于StatelessOp的匿名类。</p><p>关于<code>Sink</code>和<code>TerminalOp</code>的详解后续会单独开文章分析。这里只需要理解这个map的返回值是一个继承于StatelessOp的匿名类。（StatelessOp是一个ReferencePipeline的实现）</p><p>前提：流是含有流源的对象，并且它<strong>支持0个或多个中间操作，1个终止操作的特性</strong>。</p><p>通过idea查看发现foreach的实现有2个：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1719991486774-5eefbec8-0423-4405-bb24-ffab93053b9e.png" alt=""></p><p>第一个是Head的实现，因为流源构造出来之后，直接调用forEach，有它自己的实现，对迭代做了优化。这里可后续添加细致分析。</p><p>第二个是ReferencePipeline的实现，即调用终止操作的节点不是流源节点。</p><p>我们这里只分析<code>ReferencePipeline</code>中的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void forEach(Consumer&lt;? super P_OUT&gt; action) &#123;</span><br><span class="line">        /**</span><br><span class="line">         *  ForEachOps.makeRef(action, false) 是构建终止操作，参考3.1</span><br><span class="line">         *  evaluate()是触发终止操作的调用，参考3.2</span><br><span class="line">         */</span><br><span class="line">        evaluate(ForEachOps.makeRef(action, false));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的<code>evaluate</code>方法可以想象成“执行”的意思。</p><p><code>ForEachOps.makeRef(action, false)</code>方法可以想象成“构造一个终止操作”。–终止操作是一个名词，这里只是一个对象而已，如果这个“操作”没有得到触发，那么流什么也不会干。所以这个<code>evaluate</code>可以理解成fire action performed.</p><p>首先来看看<code>TerminalOp</code>接口，这是所有终止操作的抽象，每一个终止操作都是它的子类。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1719991486925-467458ba-f4c6-47b0-bacd-330866bbd0d2.png" alt=""></p><p>查看它的实现类，可以发现它的实现类的特点：</p><ul><li>FindOp in FindOps</li></ul><p>示例：findFirst()</p><ul><li>ReduceOp in ReduceOps<br>示例：reduce(BigDecimal.Zero, BigDecimal::add)</li><li>ForEachOp in ForEachOps<br>示例：forEach()</li><li>MatchOp in MatchOps<br>示例：anyMatch()</li></ul><p>其中带s的是一个工厂类，用于生产不同的“终止操作”。不带s的才是一个“终止操作”TerminalOp的实现类。</p><p>其实这里也不是仅仅触发终止操作，这个方法里会把前面所有的中间操作apply到每一个元素上，并执行终止操作。</p><p><code>evaluate()</code>的实现如下，暂时这里不做过多讨论，后续在sink的单独一篇文章中，分析具体流的执行过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final &lt;R&gt; R evaluate(TerminalOp&lt;E_OUT, R&gt; terminalOp) &#123;</span><br><span class="line">        assert getOutputShape() == terminalOp.inputShape();</span><br><span class="line">        if (linkedOrConsumed)</span><br><span class="line">            throw new IllegalStateException(MSG_STREAM_LINKED);</span><br><span class="line">        linkedOrConsumed = true;</span><br><span class="line"></span><br><span class="line">        return isParallel()</span><br><span class="line">               ? terminalOp.evaluateParallel(this, sourceSpliterator(terminalOp.getOpFlags()))</span><br><span class="line">               : terminalOp.evaluateSequential(this, sourceSpliterator(terminalOp.getOpFlags()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>本文只是为了理解：流pipeline是一个什么概念，以及它有什么样的基本特性？</p><p>1、流pipeline是一个双向链表的节点，前后引用。</p><p>2、流由流源，中间操作和终止操作组成。</p><p>3、终止操作被触发的时候，所有的操作（中间+终止）才会被一一应用到元素上。这称为流的惰性。</p><p>4、有一些操作是具有短路的特性的，如：findFirst等。</p><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基于下面一段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;</summary>
      
    
    
    
    <category term="java" scheme="http://www.bojiboqi.fun/categories/java/"/>
    
    
    <category term="函数式编程" scheme="http://www.bojiboqi.fun/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java Consumer示例</title>
    <link href="http://www.bojiboqi.fun/2024/09/24/Java%20Consumer%E7%A4%BA%E4%BE%8B/"/>
    <id>http://www.bojiboqi.fun/2024/09/24/Java%20Consumer%E7%A4%BA%E4%BE%8B/</id>
    <published>2024-09-24T15:13:29.942Z</published>
    <updated>2024-09-24T15:48:16.939Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Java-Consumer示例">Java Consumer示例</h4><ul><li><a href="https://blog.csdn.net/qq_31635851/article/details/116207886#accept_15">功能方法：accept</a></li><li><a href="https://blog.csdn.net/qq_31635851/article/details/116207886#LambdaConsumer_43">使用Lambda表达式创建Consumer</a><ul><li><a href="https://blog.csdn.net/qq_31635851/article/details/116207886#1__45">例1 基础类型操作</a></li><li><a href="https://blog.csdn.net/qq_31635851/article/details/116207886#2__98">例2 对象类型操作</a></li></ul></li><li><a href="https://blog.csdn.net/qq_31635851/article/details/116207886#Consumer_147">使用方法引用创建Consumer</a></li><li><a href="https://blog.csdn.net/qq_31635851/article/details/116207886#andThen_194">使用andThen方法</a><ul><li><a href="https://blog.csdn.net/qq_31635851/article/details/116207886#1_Consumer_204">例1 简单拼接Consumer</a></li><li><a href="https://blog.csdn.net/qq_31635851/article/details/116207886#2_Consumer_240">例2 多个拼接Consumer</a></li></ul></li><li><a href="https://blog.csdn.net/qq_31635851/article/details/116207886#_298">参考文献</a></li></ul><p>Java <code>Consumer</code>接口来自Java 8中引入的 <code>java.util.function</code>包。</p><p><code>Consumer</code>是一个功能接口，用来作为<code>lambda</code>表达式或方法引用的任务目标(传递一个参数执行指定的方法)。</p><p><code>Consumer</code>的功能接口是一个接受单一参数并且不返回任何结果的操作。</p><p><code>Consumer</code>的功能方法是<code>accept(T t)</code>。</p><p><code>Consumer</code>具有以下方法。</p><p><strong>1. accept :</strong> 这是<code>Consumer</code>功能接口的功能方法。<code>accept</code> 方法对给定的参数进行这一操作。</p><p><strong>2. andThen :</strong> 此方法返回一个组合的<code>Consumer</code>，该<code>Consumer</code>先执行原始的<code>Consumer</code>操作，然后按照从左到右的顺序执行给定的<code>andThen</code>操作。</p><h2 id="功能方法：accept">功能方法：accept</h2><p>功能方法<code>accept</code>在功能接口<code>Consumer</code>中的定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void accept(T t)</span><br></pre></td></tr></table></figure><p>使用示例</p><p><strong>ConsumerAccept.java</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line">public class ConsumerAccept &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Consumer&lt;String&gt; nameConsumer = s -&gt; System.out.println(s); </span><br><span class="line">  </span><br><span class="line">    nameConsumer.accept(&quot;Mahesh&quot;);</span><br><span class="line">    nameConsumer.accept(&quot;Krishna&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mahesh</span><br><span class="line">Krishna</span><br></pre></td></tr></table></figure><h2 id="使用Lambda表达式创建Consumer">使用<a href="https://so.csdn.net/so/search?q=Lambda&amp;spm=1001.2101.3001.7020">Lambda</a>表达式创建Consumer</h2><p>可以使用<code>lambda</code>表达式创建<code>Consumer</code>。</p><h3 id="例1-基础类型操作">例1 基础类型操作</h3><p>在我们的示例中，我们将使用<code>lambda</code>表达式在此处创建两个<code>Consumer</code>。</p><p>一个用于将数字添加到列表的方法，如果数字为奇数，则将添加到具有奇数的列表中；如果数字为偶数，则将其添加到具有偶数的另一个列表中。</p><p><strong>ConsumerLambda1.java</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line">public class ConsumerLambda1 &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">List&lt;Integer&gt; oddList = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; evenList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Consumer&lt;Integer&gt; storeNumber = n -&gt; &#123;</span><br><span class="line">   if (n % 2 == 0) &#123;</span><br><span class="line"> evenList.add(n);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line"> oddList.add(n);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Consumer&lt;List&lt;Integer&gt;&gt; printList = list -&gt; list.forEach(n -&gt; System.out.println(n));</span><br><span class="line"></span><br><span class="line">storeNumber.accept(10);</span><br><span class="line">storeNumber.accept(15);</span><br><span class="line">storeNumber.accept(25);</span><br><span class="line">storeNumber.accept(30);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;--- Odd number ---&quot;);</span><br><span class="line"></span><br><span class="line">printList.accept(oddList);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;--- Even number ---&quot;);</span><br><span class="line"></span><br><span class="line">printList.accept(evenList);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--- Odd number ---</span><br><span class="line">15</span><br><span class="line">25</span><br><span class="line">--- Even number ---</span><br><span class="line">10</span><br><span class="line">30</span><br></pre></td></tr></table></figure><h3 id="例2-对象类型操作">例2 对象类型操作</h3><p>我们将使用<code>lambda</code>表达式创建一个<code>Consumer</code>，它将决定并显示一个公民在选举中是否可以投票的数据。</p><p><strong>ConsumerLambda2.java</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line">public class ConsumerLambda2 &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">     Consumer&lt;Citizen&gt; electionConsumer = c -&gt; &#123;</span><br><span class="line">       if (c.getAge() &lt; 18) &#123;</span><br><span class="line">     System.out.println(c.getName() + &quot; is not eligible to vote.&quot;);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">     System.out.println(c.getName() + &quot; can vote.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">   </span><br><span class="line">     electionConsumer.accept(new Citizen(&quot;Ritesh&quot;, 15));</span><br><span class="line">   </span><br><span class="line">     electionConsumer.accept(new Citizen(&quot;Shreya&quot;, 20));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Citizen &#123;</span><br><span class="line">  private String name;</span><br><span class="line">  private int age;</span><br><span class="line"></span><br><span class="line">  public Citizen(String name, int age) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ritesh is not eligible to vote.</span><br><span class="line">Shreya can vote.</span><br></pre></td></tr></table></figure><h2 id="使用方法引用创建Consumer">使用方法引用创建Consumer</h2><p><code>Consumer</code>可以使用方法引用来创建。</p><p>在我们的例子中，我们有一个有两个方法的实用类<code>Utility</code>，其中一个方法将替换<code>Map</code>中的值，第二个方法显示<code>Map</code>中的数据。我们将使用方法引用来创建<code>Consumer</code>。</p><p><strong>ConsumerMethodRef.java</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line">public class ConsumerMethodRef &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">Map&lt;Integer, String&gt; persons = new HashMap&lt;Integer, String&gt;();</span><br><span class="line">persons.put(101, &quot;Mahesh&quot;);</span><br><span class="line">persons.put(102, &quot;Krishna&quot;);</span><br><span class="line"></span><br><span class="line">Consumer&lt;Map&lt;Integer, String&gt;&gt; updatePersons = Utility::updateData;</span><br><span class="line"></span><br><span class="line">Consumer&lt;Map&lt;Integer, String&gt;&gt; displayPersons = Utility::displayData;</span><br><span class="line"></span><br><span class="line">updatePersons.accept(persons);</span><br><span class="line"></span><br><span class="line">displayPersons.accept(persons);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Utility &#123;</span><br><span class="line">  static void updateData(Map&lt;Integer, String&gt; persons) &#123;</span><br><span class="line">persons.replaceAll((k, v) -&gt; &quot;Shree &quot;.concat(v));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void displayData(Map&lt;Integer, String&gt; persons) &#123;</span><br><span class="line">for (Map.Entry&lt;Integer, String&gt; entry : persons.entrySet()) &#123;</span><br><span class="line">  System.out.println(entry.getKey() + &quot; - &quot; + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">101 - Shree Mahesh</span><br><span class="line">102 - Shree Krishna</span><br></pre></td></tr></table></figure><h2 id="使用andThen方法">使用andThen方法</h2><p>在<code>Java</code>文档中<code>andThen</code>方法声明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after)</span><br></pre></td></tr></table></figure><ol><li>这个方法返回一个组合的<code>Consumer</code>，先执行当前<code>Consumer</code>操作，然后再执行<code>after</code>的<code>Consumer</code>操作。</li><li>如果在此操作或操作之后有异常，则将其中继到当前组合操作。</li><li>如果这个操作出现异常，那么后面的操作将不会被执行。</li></ol><h3 id="例1-简单拼接Consumer">例1 简单拼接Consumer</h3><p>我们的示例中有两个<code>Consumer</code>。</p><p>首先将执行<code>squareConsumer</code>，然后将执行<code>printConsumer</code>。</p><p><strong>ConsumerAndThen1.java</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line">public class ConsumerAndThen1 &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">List&lt;Integer&gt; numList = Arrays.asList(3, 4, 5, 6);</span><br><span class="line"></span><br><span class="line">Consumer&lt;List&lt;Integer&gt;&gt; squareConsumer = list -&gt; &#123;</span><br><span class="line">  for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">list.set(i, list.get(i) * list.get(i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Consumer&lt;List&lt;Integer&gt;&gt; printConsumer = list -&gt; list.forEach(n -&gt; System.out.println(n));</span><br><span class="line"></span><br><span class="line">squareConsumer.andThen(printConsumer).accept(numList);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">16</span><br><span class="line">25</span><br><span class="line">36</span><br></pre></td></tr></table></figure><h3 id="例2-多个拼接Consumer">例2 多个拼接Consumer</h3><p>我们多次使用<code>andThen</code>。首先将执行<code>oddNumConsumer</code>，然后将执行<code>evenNumConsumer</code>，然后将执行<code>taskFinishConsumer</code>。</p><p><strong>ConsumerAndThen2.java</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line">public class ConsumerAndThen2 &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(12, 13, 14, 15, 16, 17);</span><br><span class="line"></span><br><span class="line">Consumer&lt;List&lt;Integer&gt;&gt; oddNumConsumer = MyNumber::printOddNum;</span><br><span class="line"></span><br><span class="line">Consumer&lt;List&lt;Integer&gt;&gt; evenNumConsumer = MyNumber::printEvenNum;</span><br><span class="line"></span><br><span class="line">Consumer&lt;List&lt;Integer&gt;&gt; taskFinishConsumer = MyNumber::taskFinishMsg;</span><br><span class="line"></span><br><span class="line">oddNumConsumer.andThen(evenNumConsumer).andThen(taskFinishConsumer).accept(list);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyNumber &#123;</span><br><span class="line">  static void printOddNum(List&lt;Integer&gt; myNumbers) &#123;</span><br><span class="line">System.out.println(&quot;--- odd numbers ---&quot;);</span><br><span class="line">myNumbers.forEach(n -&gt; &#123;</span><br><span class="line">  if (n % 2 == 1) &#123;</span><br><span class="line">System.out.print(n + &quot; &quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void printEvenNum(List&lt;Integer&gt; myNumbers) &#123;</span><br><span class="line">System.out.println(&quot;\n--- even numbers ---&quot;);</span><br><span class="line">myNumbers.forEach(n -&gt; &#123;</span><br><span class="line">  if (n % 2 == 0) &#123;</span><br><span class="line">System.out.print(n + &quot; &quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void taskFinishMsg(List&lt;Integer&gt; myNumbers) &#123;</span><br><span class="line">System.out.println(&quot;\nTotal &quot; + myNumbers.size() + &quot; number processed.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--- odd numbers ---</span><br><span class="line">13 15 17 </span><br><span class="line">--- even numbers ---</span><br><span class="line">12 14 16 </span><br><span class="line">Total 6 number processed.</span><br></pre></td></tr></table></figure><h2 id="参考文献">参考文献</h2><p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Consumer.html">【1】Java doc: Consumer</a><br><a href="https://www.concretepage.com/java/java-8/java-consumer">【2】Java Consumer Example</a></p><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Java-Consumer示例&quot;&gt;Java Consumer示例&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_31635851/article/details/116207886#accept_15&quot;&gt;功能方法：</summary>
      
    
    
    
    <category term="java" scheme="http://www.bojiboqi.fun/categories/java/"/>
    
    
    <category term="函数式编程" scheme="http://www.bojiboqi.fun/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java Supplier示例</title>
    <link href="http://www.bojiboqi.fun/2024/09/24/Java%20Supplier%E7%A4%BA%E4%BE%8B/"/>
    <id>http://www.bojiboqi.fun/2024/09/24/Java%20Supplier%E7%A4%BA%E4%BE%8B/</id>
    <published>2024-09-24T15:13:01.743Z</published>
    <updated>2024-09-24T15:48:27.924Z</updated>
    
    <content type="html"><![CDATA[<p><code>Java``Supplier</code>是一个功能接口，代表结果的提供者。</p><p><code>Supplier</code>的功能方法是<code>get()</code>。</p><p>一个<code>Supplier</code>可以通过<code>lambda</code>表达式、方法引用或默认构造函数来实例化。</p><p><code>Supplier</code>在<code>Java 8</code>中被引入，属于<code>java.util.function</code>包。</p><p><code>Supplier</code>功能接口的源代码如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Supplier&lt;T&gt; &#123;</span><br><span class="line">    T get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到在上面的代码中，<code>Supplier</code>有<code>get()</code>方法，可以返回通用类型的值。</p><p><code>get()</code>方法不接受任何参数，只返回通用类型的值。</p><p>我们可以按以下方式实例化<code>Supplier</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;String&gt; s = () -&gt; &quot;Hello World!&quot;;</span><br></pre></td></tr></table></figure><p><code>Java</code>还提供了返回特定类型值的<code>Suppplier</code>。</p><p><code>BooleanSupplier</code>返回<code>Boolean</code>数据类型，<code>IntSupplier</code>返回<code>Integer</code>数据类型，<code>LongSupplier</code>返回<code>Long</code>数据类型，<code>DoubleSupplier</code>返回<code>Double</code>数据类型值。</p><p>我们还可以根据我们的要求创建自定义的功能接口。</p><h2 id="使用Lambda表达式实例化Supplier">使用<a href="https://so.csdn.net/so/search?q=Lambda&amp;spm=1001.2101.3001.7020">Lambda</a>表达式实例化Supplier</h2><p>我们将在这里使用<code>lambda</code>表达式来实例化<code>Supplier</code>。</p><p>因为我们知道它的方法<code>get()</code>只返回值，不接受任何参数，所以我们的<code>lambda</code>表达式将有空的参数部分。</p><p><strong>SupplierWithLambda.java</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line">import java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line">public class SupplierWithLambda &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">     Supplier&lt;String&gt; s1 = () -&gt; &quot;Hello World!&quot;; </span><br><span class="line">     System.out.println(s1.get());</span><br><span class="line"></span><br><span class="line">     Random random = new Random();</span><br><span class="line">     Supplier&lt;Integer&gt; s2 = () -&gt; random.nextInt(10); </span><br><span class="line">     System.out.println(s2.get());   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="使用方法引用实例化Supplier">使用方法引用实例化Supplier</h2><p>方法引用使用(<code>::</code>)符号来调用方法。假设我们有一个<code>MyUtil</code>类和一个静态方法<code>getFavoriteBook()</code>，那么我们可以用类名来调用它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyUtil::getFavoriteBook</span><br></pre></td></tr></table></figure><p>如果我们有非静态方法，我们可以使用类的实例来调用这个方法。</p><p>假设<code>myUtil</code>是<code>MyUtil</code>类的实例，<code>getAge()</code>是一个非静态方法，那么我们使用实例来调用它，如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myUtil::getAge</span><br></pre></td></tr></table></figure><p>我们知道，<code>Supplier</code>功能接口的get()方法没有参数，所以我们的<code>getFavoriteBook()</code>和<code>getAge()</code>方法不应该接受任何参数。</p><p>找到这个例子。</p><p><strong>SupplierWithMethodReference.java</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line">import java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line">public class SupplierWithMethodReference &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">     Supplier&lt;String&gt; s1 = MyUtil::getFavoriteBook;</span><br><span class="line">     System.out.println(s1.get());</span><br><span class="line"></span><br><span class="line">     MyUtil myUtil = new MyUtil();    </span><br><span class="line">     Supplier&lt;Integer&gt; s2 = myUtil::getAge;</span><br><span class="line">     System.out.println(s2.get());   </span><br><span class="line">   </span><br><span class="line">     Random random = new Random();</span><br><span class="line">     Supplier&lt;Integer&gt; s3 = random::nextInt;</span><br><span class="line">     System.out.println(s3.get());     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyUtil &#123;</span><br><span class="line">  private Integer age = 30;</span><br><span class="line">  public static String getFavoriteBook()&#123;</span><br><span class="line">      return &quot;Mahabharat&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  public Integer getAge()&#123;</span><br><span class="line">      return age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mahabharat</span><br><span class="line">30</span><br><span class="line">-682408931</span><br></pre></td></tr></table></figure><h2 id="使用默认构造函数实例化Supplier">使用默认构造函数实例化Supplier</h2><p>我们可以使用没有参数的构造函数来实例化<code>Supplier</code>，即默认构造函数。</p><p>找到<code>Book</code>类的构造函数参考。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Book::new</span><br></pre></td></tr></table></figure><p>找到使用默认构造函数来实例化<code>Supplier</code>的例子。</p><p><strong>SupplierWithConstructorRef.java</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line">import java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line">public class SupplierWithConstructorRef &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">     Supplier&lt;Random&gt; s1 = Random::new; </span><br><span class="line">     Random random = s1.get();</span><br><span class="line">     System.out.println(random.nextInt(10));   </span><br><span class="line">   </span><br><span class="line">     Supplier&lt;Book&gt; s2 = Book::new; </span><br><span class="line">     Book book = s2.get();</span><br><span class="line">     System.out.println(book.getBookName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Book &#123;</span><br><span class="line">  private String bookName = &quot;Mahabharat&quot;;</span><br><span class="line">  public String getBookName()&#123;</span><br><span class="line">      return bookName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">Mahabharat</span><br></pre></td></tr></table></figure><h2 id="自定义Supplier功能接口">自定义Supplier功能接口</h2><p>我们可以使用<code>@FunctionalInterface</code>注解创建一个自定义的<code>Supplier</code>功能接口。</p><p>我们的<code>Supplier</code>不接受参数，但返回一个通用类型的值。</p><p><strong>CustomSupplierDemo.java</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface MySupplier&lt;T&gt; &#123;</span><br><span class="line">    T fetch();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CustomSupplierDemo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">     //Using Lambda Expression</span><br><span class="line">     MySupplier&lt;String&gt; s1 = () -&gt; &quot;Hello World!&quot;; </span><br><span class="line">     System.out.println(s1.fetch());</span><br><span class="line"></span><br><span class="line">     //Using Method Reference</span><br><span class="line">     Random random = new Random();</span><br><span class="line">     MySupplier&lt;Integer&gt; s2 = random::nextInt;</span><br><span class="line">     System.out.println(s2.fetch());     </span><br><span class="line">   </span><br><span class="line">     //Using Constructor</span><br><span class="line">     MySupplier&lt;Random&gt; s3 = Random::new; </span><br><span class="line">     Random rdm = s3.fetch();</span><br><span class="line">     System.out.println(rdm.nextInt(10));    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br><span class="line">521143516</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="BooleanSupplier-IntSupplier-LongSupplier-DoubleSupplier">BooleanSupplier, IntSupplier, LongSupplier, DoubleSupplier</h2><p>Java提供了以下功能接口，用于特定数据类型的<code>Supplier</code>。</p><p><strong>BooleanSupplier:</strong><code>Supplier</code>返回<code>Boolean</code>数据类型。它的方法是<code>getAsBoolean()</code>。</p><p><strong>IntSupplier:</strong><code>Supplier</code>返回<code>Integer</code>数据类型。它的方法是<code>getAsInt()</code>。</p><p><strong>LongSupplier:</strong><code>Supplier</code>返回<code>Long</code>数据类型。它的方法是<code>getAsLong()</code>。</p><p><strong>DoubleSupplier:</strong><code>Supplier</code>返回<code>Double</code>数据类型。它的方法是<code>getAsDouble()</code>。</p><p>下面是代码示例</p><p><strong>SpecificDataTypeSupplier.java</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line">import java.util.function.BooleanSupplier;</span><br><span class="line">import java.util.function.DoubleSupplier;</span><br><span class="line">import java.util.function.IntSupplier;</span><br><span class="line">import java.util.function.LongSupplier;</span><br><span class="line"></span><br><span class="line">public class SpecificDataTypeSupplier &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    int age = 30;</span><br><span class="line">    BooleanSupplier bs = () -&gt; age &gt; 20;</span><br><span class="line">    System.out.println(bs.getAsBoolean());</span><br><span class="line">  </span><br><span class="line">    Random random = new Random();</span><br><span class="line">    IntSupplier is = random::nextInt;</span><br><span class="line">    System.out.println(is.getAsInt());</span><br><span class="line">  </span><br><span class="line">    LongSupplier ls = random::nextLong;</span><br><span class="line">    System.out.println(ls.getAsLong());  </span><br><span class="line"></span><br><span class="line">    DoubleSupplier ds = random::nextDouble;</span><br><span class="line">    System.out.println(ds.getAsDouble());  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">-429015737</span><br><span class="line">5525406112169000010</span><br><span class="line">0.7553680537299522</span><br></pre></td></tr></table></figure><h2 id="Java-Supplier与Consumer区别">Java Supplier与Consumer区别</h2><p><code>Java``Supplier</code>和<code>Consumer</code>都是功能接口。</p><p><code>Supplier</code>表示结果的提供者，该结果返回一个对象且不接受任何参数，而<code>Consumer</code>表示一个操作，其接受单个输入参数且不返回任何结果。</p><p><code>Supplier</code>功能接口的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T get()</span><br></pre></td></tr></table></figure><p><code>Consumer</code>功能界面的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void accept(T t)</span><br></pre></td></tr></table></figure><p>示例</p><p><strong>SupplierConsumerDemo.java</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.function.Consumer;</span><br><span class="line">import java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line">public class SupplierConsumerDemo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Supplier&lt;String&gt; s = Country::getPMName;</span><br><span class="line">    Consumer&lt;String&gt; c = Country::printMessage;   </span><br><span class="line">    c.accept(s.get());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Country &#123;</span><br><span class="line">  public static String getPMName() &#123;</span><br><span class="line">return &quot;Narendra Modi&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  public static void printMessage(String msg) &#123;</span><br><span class="line">System.out.println(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Narendra Modi</span><br></pre></td></tr></table></figure><h2 id="参考文献">参考文献</h2><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html">【1】Interface Supplier</a><a href="https://www.concretepage.com/java/java-8/java-functional-interface">【2】Java Functional Interface</a><a href="https://www.concretepage.com/java/java-8/java-supplier">【2】Java Supplier Example</a></p><blockquote><p>来自: <a href="https://blog.csdn.net/qq_31635851/article/details/116497765">【Java 8 新特性】Java Supplier示例-CSDN博客</a></p></blockquote><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;Java``Supplier&lt;/code&gt;是一个功能接口，代表结果的提供者。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Supplier&lt;/code&gt;的功能方法是&lt;code&gt;get()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;一个&lt;code&gt;Supplier&lt;/code&gt;可以通过&lt;cod</summary>
      
    
    
    
    <category term="java" scheme="http://www.bojiboqi.fun/categories/java/"/>
    
    
    <category term="函数式编程" scheme="http://www.bojiboqi.fun/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>流Stream的Map-Reduce操作</title>
    <link href="http://www.bojiboqi.fun/2024/09/24/%E6%B5%81Stream%E7%9A%84Map-Reduce%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.bojiboqi.fun/2024/09/24/%E6%B5%81Stream%E7%9A%84Map-Reduce%E6%93%8D%E4%BD%9C/</id>
    <published>2024-09-24T15:12:36.534Z</published>
    <updated>2024-09-24T16:11:46.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><strong>写在前面</strong></h2><p>Stream 的 Map-Reduce 操作是Java 函数式编程的精华所在，同时也是最为复杂的部分。但一旦你啃下了这块硬骨头，那你就真正熟悉Java的函数式编程了。</p><p>如果你有大数据的编程经验，你会对术语 Map-Reduce 十分熟悉亲切。如果你不熟悉大数据编程，也无所谓，通过本文的学习，相信你会对 Map-Reduce 会有一定的理解。下面我们将开始一次有趣的历程。</p><p>如有疑问，欢迎加群讨论。</p><p>本文的示例代码可从gitee上获取：<a href="https://gitee.com/cnmemset/javafp">https://gitee.com/cnmemset/javafp</a></p><h2 id="Stream的map操作"><strong>Stream的map操作</strong></h2><p>map操作又称为映射操作，是处理Stream的重要操作。它的作用是将当前Stream中的每个元素都映射转换为另一个元素，从而得到一个新的Stream。转换前后的元素类型也可以不同。</p><p>下面介绍 Stream 中常用的 Map 方法。</p><h2 id="map"><strong>map()</strong></h2><p>map的方法签名是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</span><br></pre></td></tr></table></figure><p>map方法是一个中间操作，作用是将当前Stream中的每个元素通过参数 mapper 转换为另一个元素，转换前的元素类型为T，转换后的元素类型为 R。</p><p>一个简单例子是字符串转换为字符串的长度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void mapStream() &#123;</span><br><span class="line">    List&lt;String&gt; words = Arrays.asList(&quot;hello&quot;, &quot;world&quot;, &quot;I&quot;, &quot;love&quot;, &quot;you&quot;);</span><br><span class="line">    words.stream()</span><br><span class="line">            .map(String::length)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出每个单词的长度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="mapToInt-、mapToLong-和mapToDouble"><strong>mapToInt()、mapToLong()和mapToDouble()</strong></h2><p>它们的方法签名分别是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper);</span><br><span class="line"></span><br><span class="line">LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper);</span><br><span class="line"></span><br><span class="line">DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper);</span><br></pre></td></tr></table></figure><p>它们和map()方法大同小异，分别是针对基础类型 int 、long 和 double 的特殊处理，省去了装拆箱的消耗。</p><h2 id="flatMap"><strong>flatMap()</strong></h2><p>flatMap的方法签名是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; flatMap(</span><br><span class="line">        Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper);</span><br></pre></td></tr></table></figure><p>flatMap是一个中间操作，作用是将当前Stream的每个元素通过参数 mapper 转换成一个类型为 Stream 的元素，然后将这些 Stream 合并为一个新的 Stream。顾名思义，flat的含义就是将当前Stream中的元素“摊平”，从一个单独的元素，转换为多个元素组成的Stream。</p><p>文字表述总是苍白无力，我们先用一个实例来辅助说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void flatMapStream() &#123;</span><br><span class="line">    Stream&lt;List&lt;Integer&gt;&gt; stream = Stream.of(Arrays.asList(1,2), Arrays.asList(3, 4, 5));</span><br><span class="line">    stream.flatMap(list -&gt; list.stream())</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>stream的元素类型是一个 List，总共有两个元素 —— [1, 2] 和 [3, 4, 5]。</p><p>在 flatMap 方法中，首先将2个 List 转换为2个 Stream，然后再将这2个Stream合并为一个新的Stream并返回。图解如下：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1720158418141-0d6f8ec0-0502-4f80-8a07-9859b5d8c566.png" alt=""></p><h2 id="Stream的reduce操作"><strong>Stream的reduce操作</strong></h2><p>reduce操作（reduction operation），翻译为规约操作，是Stream中最复杂的操作。</p><p>规约操作，是通过重复执行指定的合并操作（combining operation），将Stream中的所有元素合并得到一个汇总结果的过程。例如，求和（sum）、求最大或最小值（max / min）、求平均数（average）、求元素总个数（count）、将所有元素汇总到一个列表（collect），这些都属于规约操作。</p><p>规约操作都属于终止操作（terminal operations）。</p><p>Stream类库有两个通用的规约操作 reduce() 和collect()。下面我们着重介绍相关的方法。</p><h2 id="reduce"><strong>reduce()</strong></h2><p>reduce方法有3种重写形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);</span><br><span class="line"></span><br><span class="line">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);</span><br><span class="line"></span><br><span class="line">&lt;U&gt; U reduce(U identity,</span><br><span class="line">             BiFunction&lt;U, ? super T, U&gt; accumulator,</span><br><span class="line">             BinaryOperator&lt;U&gt; combiner);</span><br></pre></td></tr></table></figure><p>虽然参数和返回值不同，但它们的语义是相似的。下面逐一介绍。</p><h3 id="reduce-BinaryOperator"><strong>reduce(BinaryOperator)</strong></h3><p>先看第一个reduce方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);</span><br></pre></td></tr></table></figure><p>其中 T 是 Stream 的泛型类型。</p><p>参数 accumulator 是指定的合并操作（combining operation）。</p><p>在串行执行时，整个方法等价于下面的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">boolean foundAny = false;</span><br><span class="line">T result = null;</span><br><span class="line">for (T element : this stream) &#123;</span><br><span class="line">    if (!foundAny) &#123;</span><br><span class="line">        foundAny = true;</span><br><span class="line">        result = element;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        result = accumulator.apply(result, element);</span><br><span class="line">&#125;</span><br><span class="line">return foundAny ? Optional.of(result) : Optional.empty();</span><br></pre></td></tr></table></figure><p>要注意的是，参数 accumulator 定义的函数必须满足<strong>结合律</strong>（associative），否则在一些顺序不确定的或并行的场景中会导致不正确的结果。譬如数据源是一个HashSet的话，其中的元素顺序是不确定的。</p><blockquote><p>结合律（associative）就是我们在小学时候学的结合律（加法结合律，乘法结合律）。对于一个函数或操作 op ，给定三个操作数 a、b、c，当 op 满足结合律时，即：<br>(a op b) op c == a op (b op c)</p></blockquote><p>以上述的 accumulator 为例，accumulator 满足结合律，即：</p><p>accumulator(accumulator(a, b), c) == accumulator(a, accumulator(b, c))</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void reduceStream() &#123;</span><br><span class="line">    Stream&lt;Integer&gt; stream = Stream.of(1, 3, 5, 7, 9);</span><br><span class="line">    Integer sum = stream.reduce((x, y) -&gt; x + y).get();</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure><h3 id="reduce-T-BinaryOperator"><strong>reduce(T, BinaryOperator)</strong></h3><p>第二个reduce的方法签名是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);</span><br></pre></td></tr></table></figure><p>其中 T 是 Stream 的泛型类型。</p><p>与第一个reduce方法比较，多了一个参数 identity 。</p><p>参数 identity 是reduce操作的初始值。</p><p>参数accumulator 要求满足结合律（associative）。</p><p>在串行的场景中，整个方法等价于下面的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T result = identity;</span><br><span class="line">for (T element : this stream)</span><br><span class="line">    result = accumulator.apply(result, element)</span><br><span class="line">return result;</span><br></pre></td></tr></table></figure><p>和第一个reduce方法一样，参数 accumulator 定义的函数必须满足结合律（associative），否则在一些顺序不确定的或并行的场景中会导致不正确的结果。</p><p>此外，如果涉及到并行操作（parallel operations），对参数 identity 还有一个要求：</p><p><strong>对任意值 t，要满足 accumulator(identity, t) == t 。否则，会导致错误的结果。</strong></p><p>还是求和的场景，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void reduceStream2() &#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 7, 9);</span><br><span class="line"></span><br><span class="line">    // 串行执行，对参数 identity 并没有实际的约束。</span><br><span class="line">    Integer sum = list.stream().reduce(0, (x, y) -&gt; x + y);</span><br><span class="line">    System.out.println(sum);  // sum = 0+1+3+5+7+9 = 25</span><br><span class="line"></span><br><span class="line">    // 串行执行，对参数 identity 并没有实际的约束。</span><br><span class="line">    sum = list.stream().reduce(5, (x, y) -&gt; x + y);</span><br><span class="line">    System.out.println(sum);  // sum = 5+1+3+5+7+9 = 30</span><br><span class="line"></span><br><span class="line">    // 并行执行。这是正确的范例：因为数字 0 是累加操作的 identity 。</span><br><span class="line">    sum = list.parallelStream().reduce(0, (x, y) -&gt; x + y);</span><br><span class="line">    System.out.println(sum);  // sum = 0+1+3+5+7+9 = 25</span><br><span class="line"></span><br><span class="line">    // 并行执行。这是错误的范例：因为数字 5 并不是累加操作的 identity 。</span><br><span class="line">    sum = list.parallelStream().reduce(5, (x, y) -&gt; x + y);</span><br><span class="line">    System.out.println(sum);  // 会输出一个大于 30 的数字</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">25</span><br><span class="line">30</span><br><span class="line">25</span><br><span class="line">50</span><br></pre></td></tr></table></figure><p>可以看到，在最后一个范例中，得出了一个错误的结果（正确结果应该是30）。</p><h3 id="reduce-U-BiFunction-BinaryOperator"><strong>reduce(U, BiFunction, BinaryOperator)</strong></h3><p>第三个reduce方法的签名是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; U reduce(U identity,</span><br><span class="line">             BiFunction&lt;U, ? super T, U&gt; accumulator,</span><br><span class="line">             BinaryOperator&lt;U&gt; combiner);</span><br></pre></td></tr></table></figure><p>其中 U 是返回值的类型，T 是 Stream 的泛型类型。</p><p>参数 identity 是规约操作的初始值。</p><p>参数accumulator 是与Stream中单个元素的合并操作，等同于函数 U apply(U u, T t)。</p><p>参数 combiner 是将并行执行得到的多个中间结果进行合并的操作，等同于函数 U apply(U u1, U u2)。</p><p>图解如下：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1720158418362-b1a72735-7074-46f8-a151-aac775f3573f.png" alt=""></p><p>在串行的场景中，整个方法等价于下面的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">U result = identity;</span><br><span class="line">for (T element : this stream)</span><br><span class="line">    result = accumulator.apply(result, element)</span><br><span class="line">return result;</span><br></pre></td></tr></table></figure><p>从伪代码中可以看到，串行时不涉及到参数 combiner ，串行时甚至可以将其设置为任一个非null值即可，不影响执行。</p><p>但在并行编程中，对3个参数都有一些特殊要求：</p><ol><li><p>参数 combiner 必须满足结合律</p></li><li><p>参数 identity，对于任意值 u，必须满足 combiner(identity, u) == u</p></li><li><p>参数 accumulator 和 combiner 两者必须兼容，即对于任意值 u 和 t，必须满足：</p></li></ol><p>combiner(u, accumulator(identity, t)) == accumulator(u, t)</p><p>假设一个场景，我们要求一篇文章中字母的总长度，示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void reduceStream3() &#123;</span><br><span class="line">    List&lt;String&gt; article = Arrays.asList(&quot;hello&quot;, &quot;world&quot;, &quot;I&quot;, &quot;love&quot;, &quot;you&quot;);</span><br><span class="line">    Integer letterCount = article.stream().reduce(</span><br><span class="line">            0, // identity 初始值　</span><br><span class="line">            (count, str) -&gt; count + str.length(), // accumulator 累加器，也起到了 map 的作用</span><br><span class="line">            (a, b) -&gt; a + b // combiner 拼接器，并行执行时才会用到</span><br><span class="line">    );</span><br><span class="line"> </span><br><span class="line">    // 输出 18</span><br><span class="line">    // 5(hello) + 5(world) + 1(I) + 4(love) + 3(you) = 18</span><br><span class="line">    System.out.println(letterCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，</p><ol><li><p>combiner 是求和函数，满足结合律；</p></li><li><p>identity 是0，也满足 0 + u == u;</p></li><li><p>对于任意的整数 count 和 字符串 str，也满足 count + (0 + str.length()) == count + str.length()</p></li></ol><p>因此，上述的示例是可以通过并行的方式执行的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void reduceStream4() &#123;</span><br><span class="line">    List&lt;String&gt; article = Arrays.asList(&quot;hello&quot;, &quot;world&quot;, &quot;I&quot;, &quot;love&quot;, &quot;you&quot;);</span><br><span class="line"> </span><br><span class="line">    // parallelStream()：以并行的方式执行</span><br><span class="line">    Integer letterCount = article.parallelStream().reduce(</span><br><span class="line">            0, // identity 初始值　</span><br><span class="line">            (count, str) -&gt; count + str.length(), // accumulator 累加器，也起到了 map 的作用</span><br><span class="line">            (a, b) -&gt; a + b // combiner 拼接器，并行执行时才会用到</span><br><span class="line">    );</span><br><span class="line"> </span><br><span class="line">    // 输出 18</span><br><span class="line">    // 5(hello) + 5(world) + 1(I) + 4(love) + 3(you) = 18</span><br><span class="line">    System.out.println(letterCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第三个reduce方法，参数 accumulator 同时也是一个mapper（映射器），在进行合并操作的同时，也做了map操作。因此，我们是可以通过 “map方法 + 第二个reduce方法”来实现第三个reduce方法的。但在某些场景中，将mapper和accumulator 混合起来，可以避免一些不必要的计算操作，使得程序更有效率。</p><p>用“map方法 + 第二个reduce方法”实现同样的功能，示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void reduceStream5() &#123;</span><br><span class="line">    List&lt;String&gt; article = Arrays.asList(&quot;hello&quot;, &quot;world&quot;, &quot;I&quot;, &quot;love&quot;, &quot;you&quot;);</span><br><span class="line"> </span><br><span class="line">    // parallelStream()：以并行的方式执行</span><br><span class="line">    // 分开的 map + accumulator</span><br><span class="line">    Integer letterCount = article.parallelStream()</span><br><span class="line">            .map(s-&gt;s.length())</span><br><span class="line">            .reduce(0, (a, b) -&gt; a + b);</span><br><span class="line"> </span><br><span class="line">    // 输出 18</span><br><span class="line">    // 5(hello) + 5(world) + 1(I) + 4(love) + 3(you) = 18</span><br><span class="line">    System.out.println(letterCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="collect"><strong>collect()</strong></h2><p>collect方法，顾名思义，它的作用是将Stream中的元素“收集”起来。它是Stream类库中最灵活、最通用的方法之一。一个常见的应用场景就是通过collect方法将Stream中的汇总到一个List中。</p><p>先给一个简单的例子直观感受一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void collectToList() &#123;</span><br><span class="line">    Stream&lt;String&gt; stream = Stream.of(&quot;hello&quot;, &quot;world&quot;, &quot;I&quot;, &quot;love&quot;, &quot;you&quot;);</span><br><span class="line">    List&lt;String&gt; list = stream.collect(Collectors.toList());</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是collect方法最简单的应用：将一个Stream转换为一个List。</p><p>collect方法有2种重写形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,</span><br><span class="line">              BiConsumer&lt;R, ? super T&gt; accumulator,</span><br><span class="line">              BiConsumer&lt;R, R&gt; combiner);</span><br><span class="line"> </span><br><span class="line">&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);</span><br></pre></td></tr></table></figure><p>这2种重写形式的语义是一致的，虽然细节上有差异，但仍然可以认为第二个collect方法的参数 collector 就是对第一个collect方法中三个参数supplier、accumulator和combiner的封装。</p><h3 id="collect-Supplier-BiConsumer-BiConsumer"><strong>collect(Supplier, BiConsumer, BiConsumer)</strong></h3><p>第一个collect方法的签名是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,</span><br><span class="line">              BiConsumer&lt;R, ? super T&gt; accumulator,</span><br><span class="line">              BiConsumer&lt;R, R&gt; combiner);</span><br></pre></td></tr></table></figure><p>其中 R 是返回值的类型，通常是一个容器类（例如 Collection 或 Map）。T 是Stream中的元素类型。</p><p>在解释3个参数的作用之前，我们先思考一个问题：如果要把Stream中的元素“收集”到一个容器中，需要哪些信息呢？很显然：</p><p>首先我们要知道 1) 是哪个容器（supplier）；</p><p>其次我们要知道 2) 如何将单个元素加入到该容器中（accumulator）；</p><p>最后我们要知道 3) 在并行执行的时候，如何将多个中间结果的容器合并为一个（combiner）。</p><p>对应参数的含义也自然而然出来了：</p><p>参数 supplier 是用来创建一个容器实例的函数。</p><p>参数 accumulator 是将Stream中的一个元素合并到容器中的函数。</p><p>参数 combiner 是将两个容器归并为一个容器的函数，只在并行执行的时候用到。</p><p>在串行执行的场景下，整个方法等价于以下的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">R result = supplier.get();</span><br><span class="line">for (T element : this stream)</span><br><span class="line">    accumulator.accept(result, element);</span><br><span class="line">return result;</span><br></pre></td></tr></table></figure><p>而在并行执行的场景下，我们有一些额外的要求：</p><ol><li>combiner函数满足结合律</li><li>要求combiner 和 accumulator 是兼容的（compatible），即对于任意的r和t，满足 combiner(r, accumulator(supplier.get(), t)) == accumulator(r, t)</li></ol><p>以一个简单的例子加以说明，假设我们要将Stream中的字符串“collect”到一个ArrayList中，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void collectToList1() &#123;</span><br><span class="line">    Stream&lt;String&gt; stream = Stream.of(&quot;hello&quot;, &quot;world&quot;, &quot;I&quot;, &quot;love&quot;, &quot;you&quot;);</span><br><span class="line">    List&lt;String&gt; list = stream.collect(</span><br><span class="line">        ArrayList::new, // supplier 创建一个 ArrayList 实例</span><br><span class="line">        ArrayList::add, // accumulator将一个 String 加入到 ArrayList 中</span><br><span class="line">        ArrayList::addAll // combiner 将两个 ArrayList 合并成一个</span><br><span class="line">    );</span><br><span class="line"> </span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码也是符合并行执行的要求的：ArrayList的addAll方法满足结合律；addAll方法是与add方法兼容的（compatible）。因此，在上述的collect过程中，我们允许以并行的方式来执行 —— 即使 ArrayList 不是线程安全的，我们也无需考虑这个问题，这是Stream并行编程的优势之一。</p><h3 id="collect-Collector"><strong>collect(Collector)</strong></h3><p>第二个collect方法的签名是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);</span><br></pre></td></tr></table></figure><p>其中，T是Stream元素的类型；R是返回值的类型；A是一个中间结果的类型，最后需要将结果从A转换到R。</p><p>类Collector（收集器）可以看做是对前一个collect方法中的三个参数supplier、accumulator和combiner的封装，但Collector更加灵活和通用。</p><p>类Collector的原理和源码相对比较复杂，限于篇幅，本文就不做详细阐述，如果读者感兴趣，可以加群讨论。</p><p>Collector是如此的灵活，我们决定从一个现实场景出发，逐步向大家展示Collector的强大功能。</p><p><strong>场景描述</strong></p><p>假设一个场景：我们接到了一个公司的需求，需要对公司的信息进行一些分析，包括性别、部门、薪酬等维度。为简单起见，我们不考虑员工重名的情形。</p><p>首先，我们定义一个Employee 的类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Employee &#123;</span><br><span class="line">    /** 姓名 */</span><br><span class="line">    private String name;</span><br><span class="line">    /** 性别：0 女 1 男 */</span><br><span class="line">    private int gender;</span><br><span class="line">    /** 部门 */</span><br><span class="line">    private String department;</span><br><span class="line">    /** 薪酬 */</span><br><span class="line">    private int salary;</span><br><span class="line"></span><br><span class="line">    // getter and setter</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们假定员工的信息可以通过一个工具类获取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Utils &#123;</span><br><span class="line">    public static List&lt;Employee&gt; makeEmployees() &#123;</span><br><span class="line">        Employee e1 = new Employee(&quot;张三&quot;, 1, &quot;DEV&quot;, 17200);</span><br><span class="line">        Employee e2 = new Employee(&quot;李四&quot;, 1, &quot;OPS&quot;, 12000);</span><br><span class="line">        Employee e3 = new Employee(&quot;韩梅梅&quot;, 0, &quot;HR&quot;, 9000);</span><br><span class="line">        Employee e4 = new Employee(&quot;李雷&quot;, 1, &quot;DEV&quot;, 20000);</span><br><span class="line">        Employee e5 = new Employee(&quot;杜芳芳&quot;, 0, &quot;OPS&quot;, 16500);</span><br><span class="line">        return new ArrayList&lt;&gt;(Arrays.asList(e1, e2, e3, e4, e5));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需求1：要将所有员工的姓名转换为一个List</strong></p><p>实现这个需求的代码很简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void collectEmployeeNamesToList() &#123;</span><br><span class="line">    List&lt;Employee&gt; employees = Utils.makeEmployees();</span><br><span class="line">    List&lt;String&gt; names = employees.stream()</span><br><span class="line">            .map(Employee::getName)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    // 如果要指定返回的List具体类型，譬如指定为 ArrayList</span><br><span class="line">    ArrayList&lt;String&gt; arrayNames = employees.stream()</span><br><span class="line">            .map(Employee::getName)</span><br><span class="line">            .collect(Collectors.toCollection(ArrayList::new));</span><br><span class="line">            </span><br><span class="line">    System.out.println(arrayNames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[张三, 李四, 韩梅梅, 李雷, 杜芳芳]</span><br></pre></td></tr></table></figure><p><strong>Collectors工具类提供了一系列内置的Collector，包括:</strong></p><p>a. Collectors.toList(): 转换为List</p><p>b. Collectors.toSet()：转换为Set</p><p>c. Collectors.toCollection(Supplier)：转换为指定的Collection类</p><blockquote><p>一个有趣的问题：为什么没有toQueue()？先不给答案了，有兴趣的同学可以加群讨论。</p></blockquote><p><strong>需求2：将员工列表转换成&lt;姓名，薪酬&gt;组成的Map</strong></p><p>Collector除了可以将Stream转换为Collection之外，还可以转换为Map。</p><p>示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void collectEmployeeNamesToMap() &#123;</span><br><span class="line">    List&lt;Employee&gt; employees = Utils.makeEmployees();</span><br><span class="line">    Map&lt;String, Integer&gt; nameScoreMap = employees.stream()</span><br><span class="line">            .collect(Collectors.toMap(Employee::getName, Employee::getSalary));</span><br><span class="line">    System.out.println(nameScoreMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;李四=12000, 张三=17200, 李雷=20000, 杜芳芳=16500, 韩梅梅=9000&#125;</span><br></pre></td></tr></table></figure><p>示例代码中，Employee::getName用来生成Map的key ，而Employee::getSalary则用来生成Map中key对应的value。</p><p>Collectors.toMap方法还有两个重写形式，主要用来处理key重复时的情形以及指定Map的具体类型。</p><p><strong>需求3：将员工按男女分成两组</strong></p><p>对于这个需求，使用方法 Collectors.partitioningBy 。示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void partitionEmployeesToMap() &#123;</span><br><span class="line">    List&lt;Employee&gt; employees = Utils.makeEmployees();</span><br><span class="line">    Map&lt;Boolean, List&lt;Employee&gt;&gt; map = employees.stream()</span><br><span class="line">            .collect(Collectors.partitioningBy(e -&gt; e.getGender() == 1));</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;false=[Employee&#123;name=&#x27;韩梅梅&#125;, Employee&#123;name=&#x27;杜芳芳&#125;], true=[Employee&#123;name=&#x27;张三&#125;, Employee&#123;name=&#x27;李四&#125;, Employee&#123;name=&#x27;李雷&#125;]&#125;</span><br></pre></td></tr></table></figure><p>Collectors.partitioningBy 可以用更通用的 Collectors.groupingBy 来实现。下面接着介绍 Collectors.groupingBy 。</p><p><strong>需求4：将员工按照部门分组</strong></p><p>使用简化版 Collectors.groupingBy(Function) 方法来实现，示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void groupEmployeesToMap() &#123;</span><br><span class="line">    List&lt;Employee&gt; employees = Utils.makeEmployees();</span><br><span class="line">    Map&lt;String, List&lt;Employee&gt;&gt; map = employees.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(Employee::getDepartment));</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;OPS=[Employee&#123;name=&#x27;李四&#125;, Employee&#123;name=&#x27;杜芳芳&#125;], DEV=[Employee&#123;name=&#x27;张三&#125;, Employee&#123;name=&#x27;李雷&#125;], HR=[Employee&#123;name=&#x27;韩梅梅&#125;]&#125;</span><br></pre></td></tr></table></figure><p><strong>需求5：将员工按照部门分组后，计算每个部门的员工薪酬总数</strong></p><p>使用通用版 Collectors.groupingBy(Function, Collector) 方法来实现，示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void groupEmployeesToMap1() &#123;</span><br><span class="line">    List&lt;Employee&gt; employees = Utils.makeEmployees();</span><br><span class="line"> </span><br><span class="line">    // 使用通用版的 groupingBy</span><br><span class="line">    Map&lt;String, Integer&gt; map = employees.stream()</span><br><span class="line">            .collect(</span><br><span class="line">                    // 上游收集器</span><br><span class="line">                    Collectors.groupingBy(</span><br><span class="line">                            Employee::getDepartment,</span><br><span class="line">                            // 下游收集器 downstream collector</span><br><span class="line">                            Collectors.summingInt(Employee::getSalary)</span><br><span class="line">                    )</span><br><span class="line">            );</span><br><span class="line"> </span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;OPS=28500, DEV=37200, HR=9000&#125;</span><br></pre></td></tr></table></figure><p>通用版 Collectors.groupingBy 方法签名为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T, K, A, D&gt;</span><br><span class="line">Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(</span><br><span class="line">           Function&lt;? super T, ? extends K&gt; classifier,</span><br><span class="line">           Collector&lt;? super T, A, D&gt; downstream);</span><br></pre></td></tr></table></figure><p>首先通过参数 classifier 定义的函数对Stream的元素分组，然后使用下游收集器（downstream collector），对分组后的元素进行再处理（甚至可以再次分组）。</p><p>阅读源码可以发现，需求4中的简化版 groupingBy ，实际上是通用版groupingBy 的简写：</p><p>groupingBy(classifier) == groupingBy(classifier, toList())</p><p>其中，toList() 是 groupingBy 的下游收集器。</p><h3 id="自定义Collector"><strong>自定义Collector</strong></h3><p>除了可以使用Collectors工具类已经封装好的收集器，我们还可以自定义收集器，收集任何形式你想要的信息。</p><p>但是，不夸张的说，<strong>Collectors工具类中内置的Collector，基本能满足我们所有的需求</strong>。在你决定要自定义一个Collector之前，请务必确认内置的Collector无法实现你的需求。</p><p>具体如何自定义Collector，限于篇幅，在本文不做详细描述，有兴趣的同学可以加群讨论。</p><h2 id="结语"><strong>结语</strong></h2><p>本文介绍了 Stream 的 Map-Reduce 操作。</p><p>如果你从头到尾认真阅读了本文，那么恭喜你，你的Java函数式编程已经正式入门了。</p><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Stream 的 Map-Reduce 操作是Java 函数式编程的精华所在，同时也是最为复杂的部分。但一旦你啃下了这块硬骨头，那你就真正熟悉Java的函数式编程了。&lt;/p&gt;
&lt;p&gt;如果你有大</summary>
      
    
    
    
    <category term="java" scheme="http://www.bojiboqi.fun/categories/java/"/>
    
    
    <category term="函数式编程" scheme="http://www.bojiboqi.fun/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>流Stream并行编程</title>
    <link href="http://www.bojiboqi.fun/2024/09/24/%E6%B5%81Stream%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.bojiboqi.fun/2024/09/24/%E6%B5%81Stream%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/</id>
    <published>2024-09-24T15:11:55.405Z</published>
    <updated>2024-09-24T16:11:42.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><strong>写在前面</strong></h2><p>在本系列文章的第一篇，我们提到了函数式编程的优点之一是“易于并发编程”。</p><p>Java作为一个多线程的语言，它通过 Stream 来提供了并发编程的便利性。</p><p>题外话：</p><blockquote><p>严格来说，并发和并行是两个不同的概念。<br>“并发（Concurrency）”强调的是在同一时间开始执行多个任务，通常会涉及多线程之间的上下文切换；<br>“并行（Parallelism）”强调的是将一个大任务分解为多个小任务后，再同时执行这些小任务，得到多个中间结果后再汇总为一个最终结果。<br>但在多CPU和分布式的时代，并发和并行的概念联系越来越紧密。至少在Java的Stream中，我们可以将并发和并行理解为同一个意思：基于多线程技术，对一个大任务分拆为多个小任务，分配到不同的线程中执行，得到多个中间结果后再汇总为一个最终结果。</p></blockquote><p>本文的示例代码可从gitee上获取：<a href="https://gitee.com/cnmemset/javafp">https://gitee.com/cnmemset/javafp</a></p><h2 id="Stream的并行编程"><strong>Stream的并行编程</strong></h2><p>并行编程是Stream的一个重要功能和特性。它的一个优点是：不管数据源是否线程安全，通过并行流（parallel stream）都可以轻松的实现并行编程。</p><p>Stream的并行编程，底层是基于 ForkJoinPool 技术来实现的。ForkJoinPool是Java 7引入的用于并行执行的任务框架，核心思想是将一个大任务拆分成多个小任务（即fork），然后再将多个小任务的处理结果汇总到一个结果上（即join）。此外，它也提供基本的线程池功能，譬如设置最大并发线程数，关闭线程池等。</p><p>在本系列之前的文章中，也零零散散的提到了一些关于并行编程的知识点。本文再做一个更系统的总结。</p><h2 id="并行流（parallel-stream）"><strong>并行流</strong>（parallel stream）</h2><p>Stream的并行操作都是基于并行流（parallel stream）。</p><p>生成一个并行流也非常简单：</p><ol><li><p>通过 Collection.parallelStream 方法可以得到一个并行流</p></li><li><p>生成一个串行的Stream后，可以通过方法 BaseStream.parallel() 将一个串行流（serial stream）转换成并行流。当然，我们也可以通过方法 BaseStream.sequential() 将一个并行流转换成串行流。</p></li></ol><p>通过方法 BaseStream.isParallel() 可以判断一个 stream 是否是并行流。</p><p>不管数据源是否线程安全（譬如ArrayList、HashSet，它们都不支持多线程），我们都可以使用parallelStream 轻松实现并行编程，不需要额外的线程同步操作，这是parallelStream 最大的优点。</p><h2 id="顺序性"><strong>顺序性</strong></h2><p>encounter order，指的是Stream中元素的出现顺序。如果觉得encounter order过于抽象，可以将它简单理解为数据源（data source）的元素顺序。本小节涉及到的有序或无序都特指encounter order。</p><p>一个Stream是否具备encounter order的有序性，取决于它的数据源（data source）和中间操作（intermediate operations）。例如，List或者数组的Steam是有序的，但HashSet的Steam则是无序的。而中间操作Stream.sorted，可以将一个无序的Stream转换成有序的；中间操作Stream.unordered 则将一个有序的Stream转换成无序的。</p><p>有趣的是，有些终止操作（terminal operations）是无视encounter order的。什么意思呢？以最常见的Stream.forEach 为例，在并行执行的时候，即使数据源是List，forEach方法处理元素的顺序也是无序的。要保证处理顺序，需要使用方法 Stream.forEachOrdered 。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void forEachExample() &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5));</span><br><span class="line"> </span><br><span class="line">    System.out.println(&quot;===forEach====&quot;);</span><br><span class="line"> </span><br><span class="line">    // 在并行流中， forEach 方法是无视 Stream 的 encounter order 的</span><br><span class="line">    list.parallelStream().forEach(i -&gt; &#123;</span><br><span class="line">        System.out.println(i + &quot;：thread-&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    System.out.println(&quot;===forEachOrdered====&quot;);</span><br><span class="line"> </span><br><span class="line">    // 在并行流中， forEachOrdered 方法可以保持 encounter order</span><br><span class="line">    list.parallelStream().forEachOrdered(i -&gt; &#123;</span><br><span class="line">        System.out.println(i + &quot;：thread-&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的输出类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">===forEach====</span><br><span class="line">3：thread-main</span><br><span class="line">5：thread-ForkJoinPool.commonPool-worker-2</span><br><span class="line">1：thread-main</span><br><span class="line">4：thread-ForkJoinPool.commonPool-worker-3</span><br><span class="line">2：thread-ForkJoinPool.commonPool-worker-1</span><br><span class="line">===forEachOrdered====</span><br><span class="line">1：thread-ForkJoinPool.commonPool-worker-4</span><br><span class="line">2：thread-ForkJoinPool.commonPool-worker-1</span><br><span class="line">3：thread-ForkJoinPool.commonPool-worker-1</span><br><span class="line">4：thread-ForkJoinPool.commonPool-worker-1</span><br><span class="line">5：thread-ForkJoinPool.commonPool-worker-1</span><br></pre></td></tr></table></figure><p>可以看出，在并行执行时，forEach 是无视Stream的encounter order的，而 forEachOrdered 虽然也是在多线程环境下执行，但仍然可以保证Stream的encounter order。</p><p>在Stream并行编程中，理解encounter order很重要。因为对于大多数的Stream操作，即使是并行执行，如果Stream是有序的，那么操作后得到的Stream也保持有序。例如，对一个数据源为List [1,2,3] 的有序Stream，执行 map(x -&gt; x * x) 操作后，结果一定是 [1, 4, 9]。</p><p>对encounter order的有序性和无序性，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static void unorderedExample() &#123;</span><br><span class="line">    // 我们用 TreeMap 来做实验，因为 ArrayList 的特殊性，很难展示 unordered 的特性</span><br><span class="line"> </span><br><span class="line">    // TreeSet 中的元素是按从小到大排序的，即 [-7, -3, 1, 5, 12]</span><br><span class="line">    TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(Arrays.asList(1, 12, 5, -7, -3));</span><br><span class="line"> </span><br><span class="line">    // 按 encounter order 打印 set，输出为：-7, -3, 1, 5, 12</span><br><span class="line">    System.out.println(&quot;The encounter order of set: &quot;);</span><br><span class="line">    set.stream().forEachOrdered(s -&gt; System.out.print(s + &quot; &quot;));</span><br><span class="line">    System.out.println();</span><br><span class="line"> </span><br><span class="line">    // TreeSet 是有序的，所以来自 TreeSet 的 Stream 也是有序的</span><br><span class="line">    // 当 Stream 是有序时，执行操作 limit(2) ，不管是串行还是并行，也不管执行多少次，结果都是前两位数字 [-7, -3]</span><br><span class="line">    System.out.println(&quot;Limit ordered Stream: &quot;);</span><br><span class="line">    set.stream().parallel().limit(2).forEachOrdered(s -&gt; System.out.print(s + &quot; &quot;));</span><br><span class="line">    System.out.println();</span><br><span class="line"> </span><br><span class="line">    // 我们使用 unordered 方法将 Stream 转换为无序的。</span><br><span class="line">    // 当 Stream 是无序时，并行执行操作 limit(2) ，会发现执行多次时，输出的数字是不一样的（不确定性）</span><br><span class="line">    System.out.println(&quot;Limit unordered Stream: &quot;);</span><br><span class="line">    System.out.print(&quot;first time: &quot;);</span><br><span class="line">    set.stream().unordered().parallel().limit(2).forEachOrdered(s -&gt; System.out.print(s + &quot; &quot;));</span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.print(&quot;second time: &quot;);</span><br><span class="line">    set.stream().unordered().parallel().limit(2).forEachOrdered(s -&gt; System.out.print(s + &quot; &quot;));</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例代码的输出类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The encounter order of set:</span><br><span class="line">-7 -3 1 5 12</span><br><span class="line">Limit ordered Stream:</span><br><span class="line">-7 -3</span><br><span class="line">Limit unordered Stream:</span><br><span class="line">first time: -3 5</span><br><span class="line">second time: 5 12</span><br></pre></td></tr></table></figure><p>大家可以仔细体会。欢迎加群讨论！！！</p><h2 id="纯函数操作"><strong>纯函数操作</strong></h2><p>回顾本系列文章的第一篇，纯函数（purely function）指的是它不会改变函数以外的其它状态，换而言之，即不会改变在该函数之外定义的变量值。纯函数不会导致“副作用（side-effects）。</p><p>在Stream的并行编程中，纯函数操作非常关键，否则我们依然需要考虑线程安全的问题。</p><p>举例说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void unsafeParallelOperation() &#123;</span><br><span class="line">    List&lt;String&gt; provinces = Arrays.asList(&quot;Guangdong&quot;, &quot;Jiangsu&quot;, &quot;Guangxi&quot;, &quot;Jiangxi&quot;, &quot;Shandong&quot;);</span><br><span class="line"></span><br><span class="line">    // &quot;副作用&quot; 导致的线程不安全问题</span><br><span class="line">    ArrayList&lt;String&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">    provinces.parallelStream()</span><br><span class="line">            // 过滤掉以 G 开头的省份</span><br><span class="line">            .filter(s -&gt; !s.startsWith(&quot;G&quot;))</span><br><span class="line">            // 在 lambda表达式中修改了 results 的值，</span><br><span class="line">            // 说明了 &quot;s -&gt; results.add(s)&quot; 并非一个纯函数，</span><br><span class="line">            // 带来了不必要的 &quot;副作用&quot;，</span><br><span class="line">            // 在并行执行时，会导致线程不安全的问题。</span><br><span class="line">            .forEach(s -&gt; results.add(s));</span><br><span class="line"></span><br><span class="line">    System.out.println(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例代码存在线程不安全的问题 —— 多个线程会同时修改 ArrayList 类型的 results ，我们需要对 results 变量加锁。</p><p>正确的做法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void safeParallelOperation() &#123;</span><br><span class="line">    List&lt;String&gt; provinces = Arrays.asList(&quot;Guangdong&quot;, &quot;Jiangsu&quot;, &quot;Guangxi&quot;, &quot;Jiangxi&quot;, &quot;Shandong&quot;);</span><br><span class="line">    </span><br><span class="line">    List&lt;String&gt; results = provinces.parallelStream()</span><br><span class="line">            // 过滤掉以 G 开头的省份</span><br><span class="line">            .filter(s -&gt; !s.startsWith(&quot;G&quot;))</span><br><span class="line">            // 没有 &quot;副作用&quot;</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    System.out.println(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过内置的 Collectors.toList() 方法，就不存在“副作用”，从而也无需考虑线程安全问题。</p><h2 id="Collectors与ConcurrentMap"><strong>Collectors与ConcurrentMap</strong></h2><p>回顾一下，在介绍Stream的规约方法 Stream.collect(Collector) 时，我们提到了一个需求场景：将员工按照部门分组。</p><p>并行执行的实现代码类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void groupEmployeesToMap() &#123;</span><br><span class="line">    List&lt;Employee&gt; employees = Utils.makeEmployees();</span><br><span class="line">    Map&lt;String, List&lt;Employee&gt;&gt; map = employees.parallelStream()</span><br><span class="line">            .collect(Collectors.groupingBy(Employee::getDepartment));</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然上述代码可以实现功能，但性能可能并不尽如人意，因为在并行执行时，需要将多个中间结果汇总为最终的结果，但合并两个Map，性能损耗可能非常大（例如HashMap，底层是数组+红黑树实现的，合并时复杂度不低）。</p><p>自然而然，聪明的Java程序员会想到：如果并行执行得到的中间结果和最终结果都是使用同一个Map实例，那就不需要合并两个Map了，当然，因为并行执行涉及到多线程，因此，这个Map实例要求是线程安全的。典型的线程安全的Map，当然首选ConcurrentHashMap 啦。</p><p>这就是Collectors工具类中与ConcurrentMap相关的方法的实现原理，主要包括：</p><ol><li><p>toConcurrentMap 系列方法</p></li><li><p>groupingByConcurrent 系列方法</p></li></ol><p>但使用 ConcurrentHashMap 有个缺点：它不能保证 Stream 的 encounter order，所以只有当你确定元素的顺序不影响最终结果时，才使用与ConcurrentMap相关的方法。</p><p>最后，还要注意，只有在并行编程时，我们才要考虑使用 toConcurrentMap 或者 groupingByConcurrent 方法，否则会因为不必要的线程同步操作，反而影响了性能。</p><h2 id="规约操作的注意事项"><strong>规约操作的注意事项</strong></h2><p>在本系列介绍规约操作的文章中，已经提到了很多关于并行编程的注意事项，本小节将它们汇总起来，供大家参考。</p><h3 id="reduce-T-BinaryOperator"><strong>reduce(T, BinaryOperator)</strong></h3><p>reduce(T, BinaryOperator)的方法签名是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);</span><br></pre></td></tr></table></figure><p>其中 T 是 Stream 的泛型类型。</p><p>参数 identity 是规约操作的初始值。</p><p>参数accumulator 要求满足结合律（associative）。</p><p>参数 accumulator 定义的函数必须满足结合律（associative），否则在一些顺序不确定的或并行的场景中会导致不正确的结果。</p><p>此外，如果是并行执行的话，对参数 identity 还有一个要求：对任意值 t，要满足 accumulator.apply(identity, t) == t 。否则，会导致错误的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void reduceStream2() &#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 7, 9);</span><br><span class="line"> </span><br><span class="line">    // 这是正确的范例：因为数字 0 是累加操作的 identity 。</span><br><span class="line">    sum = list.parallelStream().reduce(0, (x, y) -&gt; x + y);</span><br><span class="line">    // 输出为 0+1+3+5+7+9 = 25</span><br><span class="line">    System.out.println(sum);</span><br><span class="line"> </span><br><span class="line">    // 这是错误的范例：因为数字 5 并不是累加操作的 identity 。</span><br><span class="line">    sum = list.parallelStream().reduce(5, (x, y) -&gt; x + y);</span><br><span class="line">    // 本意是输出为 5+1+3+5+7+9 = 30，但实际上会输出一个比30大的数字。</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reduce-U-BiFunction-BinaryOperator"><strong>reduce(U, BiFunction, BinaryOperator)</strong></h3><p>具体的方法签名是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; U reduce(U identity,</span><br><span class="line">             BiFunction&lt;U, ? super T, U&gt; accumulator,</span><br><span class="line">             BinaryOperator&lt;U&gt; combiner);</span><br></pre></td></tr></table></figure><p>其中 U 是返回值的类型，T 是 Stream 的泛型类型。</p><p>参数 identity 是规约操作的初始值。</p><p>参数accumulator 是与Stream中单个元素的合并操作，等同于函数 U apply(U u, T t)。</p><p>参数 combiner 是将并行执行得到的多个中间结果进行合并的操作，等同于函数 U apply(U u1, U u2)。</p><p>在并行编程中，对3个参数都有一些特殊要求：</p><ol><li><p>参数 combiner 必须满足结合律</p></li><li><p>参数 identity，对于任意值 u，必须满足 combiner.apply(identity, u) == u</p></li><li><p>参数 accumulator 和 combiner 两者必须兼容，即对于任意值 u 和 t，必须满足：</p></li></ol><p>combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)</p><h3 id="collect-Supplier-BiConsumer-BiConsumer"><strong>collect(Supplier, BiConsumer, BiConsumer)</strong></h3><p>ollect方法的签名是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,</span><br><span class="line">              BiConsumer&lt;R, ? super T&gt; accumulator,</span><br><span class="line">              BiConsumer&lt;R, R&gt; combiner);</span><br></pre></td></tr></table></figure><p>其中 R 是返回值的类型，通常是一个容器类（例如 Collection 或 Map）。T 是Stream中的元素类型。</p><p>参数 supplier 是用来创建一个容器实例的函数。</p><p>参数 accumulator 是将Stream中的一个元素合并到容器中的函数。</p><p>参数 combiner 是将两个容器归并为一个容器的函数，只在并行执行的时候用到。</p><p>在并行执行的场景下，我们有一些额外的要求：</p><ol><li><p>combiner函数满足结合律</p></li><li><p>要求combiner 和 accumulator 是兼容的（compatible），即对于任意的r和t， combiner.accept(r, accumulator.accept(supplier.get(), t)) == accumulator.accept(r, t)</p></li></ol><h2 id="结语"><strong>结语</strong></h2><p>Stream 提供了非常方便的并行编程API，但它还是存在很多问题，非常容易踩坑。</p><p>其中，最为人诟病的是它的不可控性。因为 Parallel Stream 的底层是基于 ForkJoinPool ，而 ForkJoinPool 的工作线程数是在虚拟机启动时指定的，如果 Stream 并行执行的任务数量过多或耗时过多，甚至会影响应用程序中其它使用 ForkJoinPool 的功能。</p><p><strong>总的来说，除非你非常了解你正在做的事情，否则不要使用 Stream 的并行编程API 。取而代之，我们可以直接使用Java中多线程技术（例如线程池）来处理。</strong></p><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在本系列文章的第一篇，我们提到了函数式编程的优点之一是“易于并发编程”。&lt;/p&gt;
&lt;p&gt;Java作为一个多线程的语言，它通过 Stream 来提供了并发编程的便利性。&lt;/p&gt;
&lt;p&gt;题外话：&lt;</summary>
      
    
    
    
    <category term="java" scheme="http://www.bojiboqi.fun/categories/java/"/>
    
    
    <category term="函数式编程" scheme="http://www.bojiboqi.fun/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Stream流 collect()方法</title>
    <link href="http://www.bojiboqi.fun/2024/09/24/Stream%E6%B5%81%20collect()%E6%96%B9%E6%B3%95/"/>
    <id>http://www.bojiboqi.fun/2024/09/24/Stream%E6%B5%81%20collect()%E6%96%B9%E6%B3%95/</id>
    <published>2024-09-24T15:11:16.285Z</published>
    <updated>2024-09-24T16:09:11.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Stream流-collect-方法的使用介绍"><a href="https://so.csdn.net/so/search?q=Stream%E6%B5%81&amp;spm=1001.2101.3001.7020">Stream流</a> collect() 方法的使用介绍</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.</span></span><br><span class="line">&lt;R&gt; R <span class="title function_">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span><br><span class="line"><span class="params">              BiConsumer&lt;R, ? <span class="built_in">super</span> T&gt; accumulator,</span></span><br><span class="line"><span class="params">              BiConsumer&lt;R, R&gt; combiner)</span>;</span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line">&lt;R, A&gt; R <span class="title function_">collect</span><span class="params">(Collector&lt;? <span class="built_in">super</span> T, A, R&gt; collector)</span>;</span><br></pre></td></tr></table></figure><p>Stream 流的注意事项：<strong>Stream不调用终止方法，中间的操作不会执行</strong>。</p><p>但是，当我们对 Stream 流中的数据操作完成之后，如果需要将流的结果进行保存，方便我们接下来对结果的继续操作，该怎么办呢？</p><p>Stream 流提供了一个 **collect() 方法，**可以收集流中的数据到【<strong>集合</strong>】或者【<strong>数组</strong>】中去。</p><h3 id="1-收集-Stream-流中的数据到集合中"><strong>1.收集 Stream 流中的数据到集合中</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.收集数据到list集合中</span></span><br><span class="line">stream.collect(Collectors.toList())</span><br><span class="line"><span class="comment">//2.收集数据到set集合中</span></span><br><span class="line">stream.collect(Collectors.toSet())</span><br><span class="line"><span class="comment">//3.收集数据到指定的集合中</span></span><br><span class="line">Collectors.toCollection(Supplier&lt;C&gt; collectionFactory)</span><br><span class="line">stream.collect(Collectors.joining())</span><br></pre></td></tr></table></figure><p><strong>示例如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 收集Stream流中的数据到集合中</span></span><br><span class="line"><span class="comment"> * 备注：切记Stream流只能被消费一次,流就失效了</span></span><br><span class="line"><span class="comment"> * 如下只是示例代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectDataToCollection</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Stream 流</span></span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        <span class="comment">//收集流中的数据到集合中</span></span><br><span class="line">        <span class="comment">//1.收集流中的数据到 list</span></span><br><span class="line">        List&lt;String&gt; list = stream.collect(Collectors.toList());</span><br><span class="line">        System.out.println(list);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//2.收集流中的数据到 set</span></span><br><span class="line">        Set&lt;String&gt; collect = stream.collect(Collectors.toSet());</span><br><span class="line">        System.out.println(collect);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//3.收集流中的数据(ArrayList)(不收集到list,set等集合中,而是)收集到指定的集合中</span></span><br><span class="line">        ArrayList&lt;String&gt; arrayList = stream.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//4.收集流中的数据到 HashSet</span></span><br><span class="line">        HashSet&lt;String&gt; hashSet = stream.collect(Collectors.toCollection(HashSet::<span class="keyword">new</span>));</span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[aaa, bbb, ccc, bbb]</span><br><span class="line">[aaa, ccc, bbb]</span><br><span class="line">[aaa, bbb, ccc, bbb]</span><br><span class="line">[aaa, ccc, bbb]</span><br></pre></td></tr></table></figure><h3 id="2-收集-Stream-流中的数据到数组中"><strong>2.收集 Stream 流中的数据到数组中</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.使用无参,收集到数组,返回值为 Object[](Object类型将不好操作)</span></span><br><span class="line">Object[] toArray();</span><br><span class="line"><span class="comment">//2.使用有参,可以指定将数据收集到指定类型数组,方便后续对数组的操作</span></span><br><span class="line">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</span><br></pre></td></tr></table></figure><p><strong>示例如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 收集Stream流中的数据到数组中</span></span><br><span class="line"><span class="comment"> * 备注：切记Stream流只能被消费一次,流就失效了</span></span><br><span class="line"><span class="comment"> * 如下只是示例代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectDataToArray</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Stream 流</span></span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//2.1 使用 toArray()无参</span></span><br><span class="line">        Object[] objects = stream.toArray();</span><br><span class="line">        <span class="keyword">for</span> (Object o: objects) &#123;<span class="comment">//此处无法使用.length() 等方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;data:&quot;</span>+o);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//2.2 使用有参返回指定类型数组</span></span><br><span class="line">        <span class="comment">//无参不好的一点就是返回的是 Object[] 类型,操作比较麻烦.想要拿到长度，Object是拿不到长度的</span></span><br><span class="line">        String[] strings = stream.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">        <span class="keyword">for</span>(String str : strings)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;data:&quot;</span>+str + <span class="string">&quot;,length:&quot;</span>+str.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data:aaa</span><br><span class="line">data:bbb</span><br><span class="line">data:ccc</span><br><span class="line">data:bbb</span><br><span class="line">-----------------</span><br><span class="line">data:aaa,length:<span class="number">3</span></span><br><span class="line">data:bbb,length:<span class="number">3</span></span><br><span class="line">data:ccc,length:<span class="number">3</span></span><br><span class="line">data:bbb,length:<span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="3-Stream流中数据聚合-分组-分区-拼接操作"><strong>3.Stream流中数据聚合/分组/分区/拼接操作</strong></h3><p>除了 collect() 方法将数据收集到集合/数组中。对 Stream流 的收集还有其他的方法。比如说：聚合计算，分组，多级分组，分区，拼接等。</p><p><strong>附：Student实体类（接下来介绍，将根据Student类来进行聚合、分组、分区、拼接介绍）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TODO Student实体类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzebiao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-1-10 13:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, score=&quot;</span> + score +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-聚合操作">1.聚合操作</h4><p>当我们使用 Stream 流处理数据后，可以像数据库的聚合函数一样对某个字段进行操作。比如获取最大值，获取最小值，求总和，求平均值，统计数量等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大值</span></span><br><span class="line">Collectors.maxBy();</span><br><span class="line"><span class="comment">//最小值</span></span><br><span class="line">Collectors.minBy();</span><br><span class="line"><span class="comment">//总和</span></span><br><span class="line">Collectors.summingInt();/Collectors.summingDouble();/Collectors.summingLong();</span><br><span class="line"><span class="comment">//平均值</span></span><br><span class="line">Collectors.averagingInt();/Collectors.averagingDouble();/Collectors.averagingLong();</span><br><span class="line"><span class="comment">//总个数</span></span><br><span class="line">Collectors.counting();</span><br></pre></td></tr></table></figure><p><strong>示例如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stream流数据--聚合操作</span></span><br><span class="line"><span class="comment"> * 备注：切记Stream流只能被消费一次,流就失效了</span></span><br><span class="line"><span class="comment"> * 如下只是示例代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzebiao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-1-10 13:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectDataToArray</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;Student&gt; studentStream = Stream.of(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;赵丽颖&quot;</span>, <span class="number">58</span>, <span class="number">95</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;杨颖&quot;</span>, <span class="number">56</span>, <span class="number">88</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">56</span>, <span class="number">99</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;柳岩&quot;</span>, <span class="number">52</span>, <span class="number">77</span>)</span><br><span class="line">        );</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//聚合操作</span></span><br><span class="line">        <span class="comment">//获取最大值(Stream流 max()方法亦可)</span></span><br><span class="line">        <span class="comment">//max()方法实现</span></span><br><span class="line">        <span class="comment">//Optional&lt;Student&gt; max = studentStream.max((s1, s2) -&gt; s1.getScore() - s2.getScore());</span></span><br><span class="line">        <span class="comment">//(聚合)实现</span></span><br><span class="line">        Optional&lt;Student&gt; max = studentStream.collect(Collectors.maxBy((s1, s2) -&gt; s1.getScore() - s2.getScore()));</span><br><span class="line">        System.out.println(<span class="string">&quot;最大值:&quot;</span>+max.get());</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//获取最小值(Stream流 min()方法亦可)</span></span><br><span class="line">        <span class="comment">//min()方法实现</span></span><br><span class="line">        <span class="comment">//Optional&lt;Student&gt; min = studentStream.max((s1, s2) -&gt; s2.getScore() - s1.getScore());</span></span><br><span class="line">        <span class="comment">//(聚合)实现</span></span><br><span class="line">        Optional&lt;Student&gt; min = studentStream.collect(Collectors.minBy((s1, s2) -&gt; s1.getScore() - s2.getScore()));</span><br><span class="line">        System.out.println(<span class="string">&quot;最小值:&quot;</span>+min.get());</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//求总和(使用Stream流的map()和reduce()方法亦可求和)</span></span><br><span class="line">        <span class="comment">//map()和reduce()方法实现</span></span><br><span class="line">        <span class="comment">//Integer reduce = studentStream.map(s -&gt; s.getAge()).reduce(0, Integer::sum);</span></span><br><span class="line">        <span class="comment">//(聚合)简化前</span></span><br><span class="line">        <span class="comment">//Integer ageSum = studentStream.collect(Collectors.summingInt(s-&gt;s.getAge()));</span></span><br><span class="line">        <span class="comment">//(聚合)使用方法引用简化</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">ageSum</span> <span class="operator">=</span> studentStream.collect(Collectors.summingInt(Student::getAge));</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄总和:&quot;</span>+ageSum);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//求平均值</span></span><br><span class="line">        <span class="comment">//(聚合)简化前</span></span><br><span class="line">        <span class="comment">//Double avgScore = studentStream.collect(Collectors.averagingInt(s-&gt;s.getScore()));</span></span><br><span class="line">        <span class="comment">//(聚合)使用方法引用简化</span></span><br><span class="line">        <span class="type">Double</span> <span class="variable">avgScore</span> <span class="operator">=</span> studentStream.collect(Collectors.averagingInt(Student::getScore));</span><br><span class="line">        System.out.println(<span class="string">&quot;分数平均值:&quot;</span>+avgScore);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//统计数量(Stream流 count()方法亦可)</span></span><br><span class="line">        <span class="comment">//count()方法实现</span></span><br><span class="line">        <span class="comment">//long count = studentStream.count();</span></span><br><span class="line">        <span class="comment">//(聚合)统计数量</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> studentStream.collect(Collectors.counting());</span><br><span class="line">        System.out.println(<span class="string">&quot;数量为:&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最大值:Student&#123;name=<span class="string">&#x27;迪丽热巴&#x27;</span>, age=<span class="number">56</span>, score=<span class="number">99</span>&#125;</span><br><span class="line">最小值:Student&#123;name=<span class="string">&#x27;柳岩&#x27;</span>, age=<span class="number">52</span>, score=<span class="number">77</span>&#125;</span><br><span class="line">年龄总和:<span class="number">222</span></span><br><span class="line">分数平均值:<span class="number">89.75</span></span><br><span class="line">数量为:<span class="number">4</span></span><br></pre></td></tr></table></figure><h4 id="2-分组操作">2.分组操作</h4><p>当我们使用 Stream 流处理数据后，可以根据某个属性来将数据进行分组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收一个 Function 参数</span></span><br><span class="line">groupingBy(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; classifier)</span><br></pre></td></tr></table></figure><p><strong>示例如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stream流数据--分组操作</span></span><br><span class="line"><span class="comment"> * 备注：切记Stream流只能被消费一次,流就失效了</span></span><br><span class="line"><span class="comment"> * 如下只是示例代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzebiao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-1-10 13:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectDataToArray</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;Student&gt; studentStream = Stream.of(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;赵丽颖&quot;</span>, <span class="number">52</span>, <span class="number">56</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;杨颖&quot;</span>, <span class="number">56</span>, <span class="number">88</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">56</span>, <span class="number">99</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;柳岩&quot;</span>, <span class="number">52</span>, <span class="number">53</span>)</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.按照具体年龄分组</span></span><br><span class="line">        Map&lt;Integer, List&lt;Student&gt;&gt; map = studentStream.collect(Collectors.groupingBy((s -&gt; s.getAge())));</span><br><span class="line">        map.forEach((key,value)-&gt;&#123;</span><br><span class="line">            System.out.println(key + <span class="string">&quot;----&gt;&quot;</span>+value);</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//2.按照分数&gt;=60 分为&quot;及格&quot;一组  &lt;60 分为&quot;不及格&quot;一组</span></span><br><span class="line">        Map&lt;String, List&lt;Student&gt;&gt; map = studentStream.collect(Collectors.groupingBy(s -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.getScore() &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;及格&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;不及格&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">        map.forEach((key,value)-&gt;&#123;</span><br><span class="line">            System.out.println(key + <span class="string">&quot;----&gt;&quot;</span>+value.get());</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//3.按照年龄分组,规约求每组的最大值最小值(规约：reducing)</span></span><br><span class="line">        Map&lt;Integer, Optional&lt;Student&gt;&gt; reducingMap = studentStream.collect(</span><br><span class="line">                Collectors.groupingBy(Student::getAge, </span><br><span class="line">                        Collectors.reducing(</span><br><span class="line">                                BinaryOperator.maxBy(</span><br><span class="line">                                        Comparator.comparingInt(Student::getScore)</span><br><span class="line">                                )</span><br><span class="line">                        )</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">        reducingMap .forEach((key,value)-&gt;&#123;</span><br><span class="line">            System.out.println(key + <span class="string">&quot;----&gt;&quot;</span>+value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">52</span>----&gt;[Student&#123;name=<span class="string">&#x27;赵丽颖&#x27;</span>, age=<span class="number">52</span>, score=<span class="number">56</span>&#125;, Student&#123;name=<span class="string">&#x27;柳岩&#x27;</span>, age=<span class="number">52</span>, score=<span class="number">53</span>&#125;]</span><br><span class="line"><span class="number">56</span>----&gt;[Student&#123;name=<span class="string">&#x27;杨颖&#x27;</span>, age=<span class="number">56</span>, score=<span class="number">88</span>&#125;, Student&#123;name=<span class="string">&#x27;迪丽热巴&#x27;</span>, age=<span class="number">56</span>, score=<span class="number">99</span>&#125;]</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line">不及格----&gt;[Student&#123;name=<span class="string">&#x27;赵丽颖&#x27;</span>, age=<span class="number">52</span>, score=<span class="number">56</span>&#125;, Student&#123;name=<span class="string">&#x27;柳岩&#x27;</span>, age=<span class="number">52</span>, score=<span class="number">53</span>&#125;]</span><br><span class="line">及格----&gt;[Student&#123;name=<span class="string">&#x27;杨颖&#x27;</span>, age=<span class="number">56</span>, score=<span class="number">88</span>&#125;, Student&#123;name=<span class="string">&#x27;迪丽热巴&#x27;</span>, age=<span class="number">56</span>, score=<span class="number">99</span>&#125;]</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">52</span>----&gt;Student&#123;name=<span class="string">&#x27;赵丽颖&#x27;</span>, age=<span class="number">52</span>, score=<span class="number">95</span>&#125;</span><br><span class="line"><span class="number">56</span>----&gt;Student&#123;name=<span class="string">&#x27;杨颖&#x27;</span>, age=<span class="number">56</span>, score=<span class="number">88</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="3-多级分组操作">3.多级分组操作</h4><p>当我们使用 Stream 流处理数据后，可以根据某个属性来将数据进行分组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收两个参数: 1.Function 参数  2.Collector多级分组</span></span><br><span class="line">groupingBy(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; classifier,Collector&lt;? <span class="built_in">super</span> T, A, D&gt; downstream) </span><br></pre></td></tr></table></figure><p><strong>示例如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stream流数据--多级分组操作</span></span><br><span class="line"><span class="comment"> * 备注：切记Stream流只能被消费一次,流就失效了</span></span><br><span class="line"><span class="comment"> * 如下只是示例代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzebiao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-1-10 13:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectDataToArray</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;Student&gt; studentStream = Stream.of(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;赵丽颖&quot;</span>, <span class="number">52</span>, <span class="number">95</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;杨颖&quot;</span>, <span class="number">56</span>, <span class="number">88</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">56</span>, <span class="number">55</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;柳岩&quot;</span>, <span class="number">52</span>, <span class="number">33</span>)</span><br><span class="line">        );</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//多级分组</span></span><br><span class="line">        <span class="comment">//1.先根据年龄分组,然后再根据成绩分组</span></span><br><span class="line">        <span class="comment">//分析:第一个Collectors.groupingBy() 使用的是(年龄+成绩)两个维度分组,所以使用两个参数 groupingBy()方法</span></span><br><span class="line">        <span class="comment">//    第二个Collectors.groupingBy() 就是用成绩分组,使用一个参数 groupingBy() 方法</span></span><br><span class="line">        Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;Student&gt;&gt;&gt;&gt; map = studentStream.collect(Collectors.groupingBy(str -&gt; str.getAge(), Collectors.groupingBy(str -&gt; str.getScore(), Collectors.groupingBy((student) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (student.getScore() &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;及格&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;不及格&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;))));</span><br><span class="line"> </span><br><span class="line">        map.forEach((key,value)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄:&quot;</span> + key);</span><br><span class="line">            value.forEach((k2,v2)-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;\t&quot;</span> + v2);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">年龄:<span class="number">52</span></span><br><span class="line">&#123;不及格=[Student&#123;name=<span class="string">&#x27;柳岩&#x27;</span>, age=<span class="number">52</span>, score=<span class="number">33</span>&#125;]&#125;</span><br><span class="line">&#123;及格=[Student&#123;name=<span class="string">&#x27;赵丽颖&#x27;</span>, age=<span class="number">52</span>, score=<span class="number">95</span>&#125;]&#125;</span><br><span class="line">年龄:<span class="number">56</span></span><br><span class="line">&#123;不及格=[Student&#123;name=<span class="string">&#x27;迪丽热巴&#x27;</span>, age=<span class="number">56</span>, score=<span class="number">55</span>&#125;]&#125;</span><br><span class="line">&#123;及格=[Student&#123;name=<span class="string">&#x27;杨颖&#x27;</span>, age=<span class="number">56</span>, score=<span class="number">88</span>&#125;]&#125;</span><br></pre></td></tr></table></figure><h4 id="4-分区操作">4.分区操作</h4><p>我们在前面学习了 Stream流中数据的分组操作，我们可以根据属性完成对数据的分组。接下来我们介绍分区操作，我们通过使用 <strong><font style="color:#f33b45;">Collectors.partitioningBy() </font></strong>，根据返回值是否为 true，把集合分为两个列表，一个 true 列表，一个 false 列表。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1719994581863-0b23b3d3-e4cb-4f1c-bb8e-b9af595c3876.png" alt=""></p><p>**分组和分区的区别就在：**分组可以有多个组。分区只会有两个区( true 和 false)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.一个参数</span></span><br><span class="line">partitioningBy(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//2.两个参数(多级分区)</span></span><br><span class="line">partitioningBy(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate, Collector&lt;? <span class="built_in">super</span> T, A, D&gt; downstream)</span><br></pre></td></tr></table></figure><p><strong>示例如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stream流数据--多级分组操作</span></span><br><span class="line"><span class="comment"> * 备注：切记Stream流只能被消费一次,流就失效了</span></span><br><span class="line"><span class="comment"> * 如下只是示例代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzebiao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-1-10 13:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectDataToArray</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;Student&gt; studentStream = Stream.of(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;赵丽颖&quot;</span>, <span class="number">52</span>, <span class="number">95</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;杨颖&quot;</span>, <span class="number">56</span>, <span class="number">88</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">56</span>, <span class="number">55</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;柳岩&quot;</span>, <span class="number">52</span>, <span class="number">33</span>)</span><br><span class="line">        );</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//分区操作</span></span><br><span class="line">        Map&lt;Boolean, List&lt;Student&gt;&gt; partitionMap = studentStream.collect(Collectors.partitioningBy(s -&gt; s.getScore() &gt; <span class="number">60</span>));</span><br><span class="line">        partitionMap.forEach((key,value)-&gt;&#123;</span><br><span class="line">            System.out.println(key + <span class="string">&quot;----&gt;&quot;</span> + value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span>----&gt;[Student&#123;name=<span class="string">&#x27;迪丽热巴&#x27;</span>, age=<span class="number">56</span>, score=<span class="number">55</span>&#125;, Student&#123;name=<span class="string">&#x27;柳岩&#x27;</span>, age=<span class="number">52</span>, score=<span class="number">33</span>&#125;]</span><br><span class="line"><span class="literal">true</span>----&gt;[Student&#123;name=<span class="string">&#x27;赵丽颖&#x27;</span>, age=<span class="number">52</span>, score=<span class="number">95</span>&#125;, Student&#123;name=<span class="string">&#x27;杨颖&#x27;</span>, age=<span class="number">56</span>, score=<span class="number">88</span>&#125;]</span><br></pre></td></tr></table></figure><h4 id="5-拼接操作">5.拼接操作</h4><p>**<font style="color:#f33b45;">Collectors.joining() </font>**会根据指定的连接符，将所有元素连接成一个字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参数--等价于 joining(&quot;&quot;);</span></span><br><span class="line">joining()</span><br><span class="line"><span class="comment">//一个参数</span></span><br><span class="line">joining(CharSequence delimiter)</span><br><span class="line"><span class="comment">//三个参数(前缀+后缀)</span></span><br><span class="line">joining(CharSequence delimiter, CharSequence prefix,CharSequence suffix)</span><br></pre></td></tr></table></figure><p><strong>示例如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stream流数据--多级分组操作</span></span><br><span class="line"><span class="comment"> * 备注：切记Stream流只能被消费一次,流就失效了</span></span><br><span class="line"><span class="comment"> * 如下只是示例代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzebiao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-1-10 13:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectDataToArray</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;Student&gt; studentStream = Stream.of(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;赵丽颖&quot;</span>, <span class="number">52</span>, <span class="number">95</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;杨颖&quot;</span>, <span class="number">56</span>, <span class="number">88</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">56</span>, <span class="number">55</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;柳岩&quot;</span>, <span class="number">52</span>, <span class="number">33</span>)</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//拼接操作</span></span><br><span class="line">        <span class="comment">//无参:join()</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">joinStr1</span> <span class="operator">=</span> studentStream.map(s -&gt; s.getName()).collect(Collectors.joining());</span><br><span class="line">        System.out.println(joinStr1);</span><br><span class="line">        <span class="comment">//一个参数:joining(CharSequence delimiter)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">joinStr2</span> <span class="operator">=</span> studentStream.map(s -&gt; s.getName()).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">        System.out.println(joinStr2);</span><br><span class="line">        <span class="comment">//三个参数:joining(CharSequence delimiter, CharSequence prefix,CharSequence suffix)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">joinStr3</span> <span class="operator">=</span> studentStream.map(s -&gt; s.getName()).collect(Collectors.joining(<span class="string">&quot;—&quot;</span>,<span class="string">&quot;^_^&quot;</span>,<span class="string">&quot;&gt;_&lt;&quot;</span>));</span><br><span class="line">        System.out.println(joinStr3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">赵丽颖杨颖迪丽热巴柳岩</span><br><span class="line">赵丽颖,杨颖,迪丽热巴,柳岩</span><br><span class="line">^_^赵丽颖—杨颖—迪丽热巴—柳岩&gt;_&lt;</span><br></pre></td></tr></table></figure><hr><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Stream流-collect-方法的使用介绍&quot;&gt;&lt;a href=&quot;https://so.csdn.net/so/search?q=Stream%E6%B5%81&amp;amp;spm=1001.2101.3001.7020&quot;&gt;Stream流&lt;/a&gt; collect()</summary>
      
    
    
    
    <category term="java" scheme="http://www.bojiboqi.fun/categories/java/"/>
    
    
    <category term="函数式编程" scheme="http://www.bojiboqi.fun/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java集合框架中的高阶函数</title>
    <link href="http://www.bojiboqi.fun/2024/09/24/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <id>http://www.bojiboqi.fun/2024/09/24/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</id>
    <published>2024-09-24T15:06:27.535Z</published>
    <updated>2024-09-24T15:52:48.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面">写在前面</h2><p>随着Java 8引入了函数式接口和lambda表达式，Java 8中的集合框架（Java Collections Framework, JCF）也增加相应的接口以适应函数式编程。</p><p>本文的目标是带领大家熟悉Java 8中集合框架新增的常用接口，让我们的代码更简洁、更高级。</p><h2 id="Java-8中的集合框架">Java 8中的集合框架</h2><p>首先，和大家从整体上了解Java集合框架。</p><p>Java集合框架，主要是由两个根接口派生出来的：一个是 Collecton接口，用于存放单个元素；另一个是 Map 接口，主要用于存放键值对。</p><p>Java集合框架的接口继承结构如下图：</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1720158393233-99521a73-45a3-4cb4-ab87-215a05828ca1.png" alt=""></p><p>Java 8中，主要是Collection、List和Map三个接口新增了一些方法，部分常用的新增函数如下表所示：</p><table><thead><tr><th style="text-align:left">接口名</th><th style="text-align:left">Java8新加入的方法</th></tr></thead><tbody><tr><td style="text-align:left">Collection</td><td style="text-align:left">forEach(), removeIf(), stream(), parallelStream()</td></tr><tr><td style="text-align:left">List</td><td style="text-align:left">replaceAll(), sort()</td></tr><tr><td style="text-align:left">Map</td><td style="text-align:left">forEach(), replaceAll(), compute(), computeIfAbsent(), computeIfPresent(), merge()</td></tr></tbody></table><p>上述这些函数，它们都包含一个函数式接口类型的参数。这类函数有一个专门的术语：高阶函数（high order function）。</p><p>高阶函数（定义）：</p><blockquote><p>一个函数，如果它有一个或多个参数是函数类型的，或者它的返回值是函数类型的，那么我们称这个函数为高阶函数。</p></blockquote><p>题外话：</p><p>可以发现，这些新增的方法基本都有默认实现（default implementation），这大大减少了具体子类的负担。接口中的默认方法是Java 8的新特性，一个重要的作用就是“接口演化（interface evolution）”。举例说明，假设在Java 8之前，我们有一个类实现了Collection接口：</p><p>public class Container implements Collection { … }</p><p>升级到Java 8后，因为Collection中新增了方法 forEach，假设没有默认方法，之前的类 Container 将编译失败。</p><h2 id="Collection中的高阶函数">Collection中的高阶函数</h2><h3 id="1-forEach"><strong>1. forEach</strong></h3><p>严格来说，forEach方法是定义在接口 Iterable 中的，它的方法签名和默认实现是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">default void forEach(Consumer&lt;? super T&gt; action) &#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    for (T t : this) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的作用是遍历集合中的每一个元素，然后依次对每个元素执行参数 action 指定的动作。参数 action 是一个 Consumer 类型的函数式接口，我们可以通过lambda表达式或方法引用来实现一个 Consumer 。因此，在Java 8或以后的版本中，不要用 for 语句来迭代 Collection 了，不妨使用 forEach 方法。</p><p>示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void collectionForEach() &#123;</span><br><span class="line">    Collection&lt;String&gt; list = Arrays.asList(&quot;Guangdong&quot;, &quot;Zhejiang&quot;, &quot;Jiangsu&quot;);</span><br><span class="line"> </span><br><span class="line">    // for 语句</span><br><span class="line">    for (String s : list) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // forEach 方法 + lambda表达式</span><br><span class="line">    list.forEach(s -&gt; System.out.println(s));</span><br><span class="line"> </span><br><span class="line">    // forEach 方法 + 方法引用</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-removeIf">2. removeIf</h3><p>removeIf的方法签名为：</p><p>default boolean removeIf(Predicate&lt;? super E&gt; filter) { … }</p><p>removeIf的作用是遍历集合中的每一个元素，然后依次对每个元素进行指定的过滤操作。filter 参数是一个 Predicate 类型的函数式接口。</p><p>示例代码如下，假定我们要过滤掉以字母 G 开头的省份：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void collectionRemoveIf() &#123;</span><br><span class="line">    List&lt;String&gt; provinces = new ArrayList&lt;&gt;(Arrays.asList(&quot;Guangdong&quot;, &quot;Jiangsu&quot;, &quot;Guangxi&quot;, &quot;Jiangxi&quot;, &quot;Shandong&quot;));</span><br><span class="line"> </span><br><span class="line">    boolean removed = provinces.removeIf(s -&gt; &#123;</span><br><span class="line">        return s.startsWith(&quot;G&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    System.out.println(removed);</span><br><span class="line">    System.out.println(provinces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出为：</p><p>true</p><p>[Jiangsu, Jiangxi, Shandong]</p><h3 id="3-replaceAll">3. replaceAll</h3><p>replaceAll的方法签名是：</p><p>default void replaceAll(UnaryOperator<E> operator) { … }</p><p>replaceAll方法的作用是对集合中的每个元素执行 operator 指定的计算，并用计算结果替换原来的元素。参数 operator 是类型为 UnaryOperator 的函数式接口，它的参数和返回值类型是相同的。</p><p>示例代码如下：将所有的省份的拼音转换为大写字母</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void listReplaceAll() &#123;</span><br><span class="line">    List&lt;String&gt; provinces = Arrays.asList(&quot;Guangdong&quot;, &quot;Jiangsu&quot;, &quot;Guangxi&quot;, &quot;Jiangxi&quot;, &quot;Shandong&quot;);</span><br><span class="line">    provinces.replaceAll(s -&gt; s.toUpperCase());</span><br><span class="line">    System.out.println(provinces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的输出为：</p><blockquote><p>[GUANGDONG, JIANGSU, GUANGXI, JIANGXI, SHANDONG]</p></blockquote><h3 id="4-sort">4. sort</h3><p>sort的方法签名如下：</p><p>default void sort(Comparator&lt;? super E&gt; c) { … }</p><p>sort方法是根据比较器 c 指定的排序规则，对 List 中的元素进行排序。参数 c 的类型是Comparator，同样是一个函数式接口。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void listSort() &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;Guangdong&quot;, &quot;Zhejiang&quot;, &quot;Jiangsu&quot;, &quot;Xizang&quot;, &quot;Fujian&quot;, &quot;Hunan&quot;, &quot;Guangxi&quot;);</span><br><span class="line"> </span><br><span class="line">    // 对省份进行排序，首先按照长度排序，如果长度一样，则按照字母顺序排序</span><br><span class="line">    list.sort((first, second) -&gt; &#123;</span><br><span class="line">        int lenDiff = first.length() - second.length();</span><br><span class="line">        return lenDiff == 0 ? first.compareTo(second) : lenDiff;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    list.forEach(s -&gt; System.out.println(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的输出为：</p><p>Hunan</p><p>Fujian</p><p>Xizang</p><p>Guangxi</p><p>Jiangsu</p><p>Zhejiang</p><p>Guangdong</p><h3 id="5-stream-和-parallelStream">5. stream 和 parallelStream</h3><p>Stream是Java中函数式编程的重要组成部分，我们会在随后的文章中加以详述。</p><h2 id="Map中的高阶函数">Map中的高阶函数</h2><h3 id="1-forEach-2">1. forEach</h3><p>和Collection类似，Map中也有forEach方法，它的方法签名和默认实现如下：</p><p>default void forEach(BiConsumer&lt;? super K, ? super V&gt; action) { … }</p><p>可以看到，Map的forEach方法的作用是遍历Map中所有的键值对，并执行参数 action 指定的操作。参数 action 的类型是函数式接口 BiConsumer，要求有2个参数，分别代表键值对的key和value。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void mapForEach() &#123;</span><br><span class="line">    Map&lt;String, String&gt; cityMap = new HashMap&lt;&gt;();</span><br><span class="line">    cityMap.put(&quot;Guangdong&quot;, &quot;Guangzhou&quot;);</span><br><span class="line">    cityMap.put(&quot;Zhejiang&quot;, &quot;Hangzhou&quot;);</span><br><span class="line">    cityMap.put(&quot;Jiangsu&quot;, &quot;Nanjing&quot;);</span><br><span class="line"> </span><br><span class="line">    cityMap.forEach((key, value) -&gt; &#123;</span><br><span class="line">        System.out.println(String.format(&quot;%s 的省会是 %s&quot;, key, value));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的输出为：</p><p>Guangdong 的省会是 Guangzhou</p><p>Zhejiang 的省会是 Hangzhou</p><p>Jiangsu 的省会是 Nanjing</p><h3 id="2-replaceAll">2. replaceAll</h3><p>Map的replaceAll的方法签名和默认实现如下：</p><p>default void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) { … }</p><p>和Collection的replaceAll类似，Map的replaceAll方法对Map中的每个键值对执行 operator 指定的计算，并用计算结果替换原来的value值。注意到参数 function 是一个 BiFunction，意味着需要提供这样的一个函数实现：它需要有2个参数，参数类型分别和键类型（K）和值类型（V）一一对应，并且它还需要返回一个类型为值类型（V）的返回值。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void mapReplaceAll() &#123;</span><br><span class="line">    Map&lt;String, String&gt; cityMap = new HashMap&lt;&gt;();</span><br><span class="line">    cityMap.put(&quot;Guangdong&quot;, &quot;Guangzhou&quot;);</span><br><span class="line">    cityMap.put(&quot;Zhejiang&quot;, &quot;Hangzhou&quot;);</span><br><span class="line">    cityMap.put(&quot;Jiangsu&quot;, &quot;Nanjing&quot;);</span><br><span class="line"></span><br><span class="line">    // 将省府的拼音转换为大写</span><br><span class="line">    cityMap.replaceAll((key, value) -&gt; &#123;</span><br><span class="line">        return value.toUpperCase();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    cityMap.forEach((key, value) -&gt; &#123;</span><br><span class="line">        System.out.println(String.format(&quot;%s 的省会大写是 %s&quot;, key, value));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出为：</p><p>Guangdong 的省会大写是 GUANGZHOU</p><p>Zhejiang 的省会大写是 HANGZHOU</p><p>Jiangsu 的省会大写是 NANJING</p><h3 id="3-compute">3. compute</h3><p>compute的方法签名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default V compute(K key,</span><br><span class="line">        BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>compute方法的作用是将参数 remappingFunction 的计算结果关联到参数 key 上，但如果计算结果为null，则在Map中删除key的映射。</p><p>示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void mapCompute() &#123;</span><br><span class="line">    Map&lt;String, String&gt; cityMap = new HashMap&lt;&gt;();</span><br><span class="line">    cityMap.put(&quot;Guangdong&quot;, &quot;null&quot;);</span><br><span class="line">    cityMap.put(&quot;Zhejiang&quot;, &quot;Hangzhou&quot;);</span><br><span class="line">    cityMap.put(&quot;Jiangsu&quot;, &quot;null&quot;);</span><br><span class="line"> </span><br><span class="line">    // 稍显复杂的语句，先调用 forEach 遍历 cityMap 中的键，然后根据原有的键值对计算新的值</span><br><span class="line">    Set keys = new HashSet&lt;&gt;(cityMap.keySet());</span><br><span class="line">    keys.forEach(key -&gt; &#123;</span><br><span class="line">        cityMap.compute(key, (k, v) -&gt; &#123;</span><br><span class="line">            // 如果是 Guangdong，则返回 Guangzhou</span><br><span class="line">            if (&quot;Guangdong&quot;.equals(k)) &#123;</span><br><span class="line">                return &quot;Guangzhou&quot;;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            // 如果旧的键值对中，值是字符串 &quot;null&quot; ，则返回 null。</span><br><span class="line">            // 这意味着 cityMap 会删除对应的key</span><br><span class="line">            if (&quot;null&quot;.equals(v)) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            // 否则，返回原来的 value 值</span><br><span class="line">            return v;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    cityMap.forEach((key, value) -&gt; &#123;</span><br><span class="line">        System.out.println(String.format(&quot;%s 的省会是 %s&quot;, key, value));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的输出为：</p><p>Guangdong 的省会是 Guangzhou</p><p>Zhejiang 的省会是 Hangzhou</p><p>注意到，Jiangsu 已经从cityMap中被删除了。</p><h3 id="4-computeIfPresent">4. computeIfPresent</h3><p>computeIfPresent的方法签名和默认实现是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">default V computeIfPresent(K key,</span><br><span class="line">        BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123;</span><br><span class="line">    Objects.requireNonNull(remappingFunction);</span><br><span class="line">    V oldValue;</span><br><span class="line">    if ((oldValue = get(key)) != null) &#123;</span><br><span class="line">        V newValue = remappingFunction.apply(key, oldValue);</span><br><span class="line">        if (newValue != null) &#123;</span><br><span class="line">            put(key, newValue);</span><br><span class="line">            return newValue;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            remove(key);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>computeIfPresent 的方法签名和compute一样，作用也和compute类似，但与compute不同的是，只有在Map中存在key并且对应的value非空时，才会调用参数 remappingFunction 指定的计算函数（函数编程特性之惰性求值：只有触发或满足某种条件后，才会执行函数）。如果计算结果为null，则删除key的映射，否则使用该结果替换key原来的映射。</p><h3 id="5-computeIfAbsent">5. computeIfAbsent</h3><p>computeIfAbsent的方法签名和默认实现是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">default V computeIfAbsent(K key,</span><br><span class="line">        Function&lt;? super K, ? extends V&gt; mappingFunction) &#123;</span><br><span class="line">    Objects.requireNonNull(mappingFunction);</span><br><span class="line">    V v;</span><br><span class="line">    if ((v = get(key)) == null) &#123;</span><br><span class="line">        V newValue;</span><br><span class="line">        if ((newValue = mappingFunction.apply(key)) != null) &#123;</span><br><span class="line">            put(key, newValue);</span><br><span class="line">            return newValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>computeIfAbsent的作用和computeIfPresent 相反，只有在Map中不存在key或对应的value为null时，才调用参数 mappingFunction 指定的计算函数（函数编程特性之惰性求值：只有触发或满足某种条件后，才会执行函数），并且当计算结果非null时，才将计算结果跟key关联。如果计算结果为null，则Map不做任何修改，不会增加新的映射关系。</p><p>computeIfAbsent总是会返回操作之后Map中key对应的value，这个value可能是之前已存在的值（如果之前存在的话），也有可能是计算出来的新值。</p><p>computeIfAbsent特别适合用来初始化Map。假设这么一个实践场景公司里的员工已经有一个“姓名-&gt;年龄”的Map了，我们需要根据它来构建一个“年龄-&gt;姓名列表”的新Map，此时，使用 computeIfAbsent 会使得代码简洁而有效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void mapComputeIfAbsent() &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; staffMap = new HashMap&lt;&gt;();</span><br><span class="line">    staffMap.put(&quot;Lilei&quot;, 24);</span><br><span class="line">    staffMap.put(&quot;Hanmeimei&quot;, 22);</span><br><span class="line">    staffMap.put(&quot;Liming&quot;, 24);</span><br><span class="line">    staffMap.put(&quot;Jim&quot;, 22);</span><br><span class="line">    staffMap.put(&quot;David&quot;, 24);</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, List&lt;String&gt;&gt; staffInvertMap = new HashMap&lt;&gt;();</span><br><span class="line">    staffMap.forEach((key, value) -&gt; &#123;</span><br><span class="line">        // 以年龄为键，构建一个新的Map</span><br><span class="line">        // 以 22 岁为例：</span><br><span class="line">        // 如果 staffInvertMap 之前不存在 22 岁对应的映射关系，</span><br><span class="line">        // 则新建一个 &quot;年龄 -&gt; ArrayList&lt;String&gt;&quot; 的映射，并且把新建的 ArrayList 返回。</span><br><span class="line">        // 如果 staffInvertMap 已经存在 22 岁对应的映射关系了，则将已存在的 ArrayList 返回。</span><br><span class="line">        List&lt;String&gt; nameList = staffInvertMap.computeIfAbsent(value, age -&gt; &#123;</span><br><span class="line">            // 对于同一个 age，这句代码只会执行一次</span><br><span class="line">            return new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        nameList.add(key);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(staffInvertMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的输出为：</p><p>{22=[Hanmeimei, Jim], 24=[Lilei, David, Liming]}</p><p>题外话：</p><p>作者特别喜欢computeIfPresent和computeIfAbsent这两个函数，除了它们可以简化我们的代码外，它俩还有一个特性：在ConcurrentHashMap 中，computeIfPresent和computeIfAbsent中的系列操作具备原子性。原子性的含义，欢迎添加公众号，员说，一起讨论。</p><h3 id="6-merge">6. merge</h3><p>merge的方法签名和默认实现为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">default V merge(K key, V value,</span><br><span class="line">        BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) &#123;</span><br><span class="line">    Objects.requireNonNull(remappingFunction);</span><br><span class="line">    Objects.requireNonNull(value);</span><br><span class="line">    V oldValue = get(key);</span><br><span class="line">    V newValue = (oldValue == null) ? value :</span><br><span class="line">               remappingFunction.apply(oldValue, value);</span><br><span class="line">    if(newValue == null) &#123;</span><br><span class="line">        remove(key);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        put(key, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    return newValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>merge方法的作用是合并key对应的旧值和新值：当Map中不存在key对应的映射或者映射值为null时，则将参数 value 关联到 key 上；否则，将旧值 oldValue 和 参数 value 作为函数 remappingFunction 的两个参数，计算得出一个新值，如果新值不为null，则将新值关联到 key 上，如果新值为null，则删除 key 对应的映射关系。</p><p>一个典型的场景是针对某个用户进行备注，如果之前有过备注，则将新的备注信息加到后面，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void mapMerge() &#123;</span><br><span class="line">    Map&lt;String, String&gt; staffMap = new HashMap&lt;&gt;();</span><br><span class="line">    staffMap.put(&quot;Lilei&quot;, &quot;性别男 &quot;);</span><br><span class="line"></span><br><span class="line">    // 等价于 staffMap.merge(&quot;Lilei&quot;, &quot;年龄 24&quot;, String::concat)</span><br><span class="line">    // oldValue 即之前添加的值 “性别男 ”，value 即merge函数的第二个参数 “年龄24”</span><br><span class="line">    staffMap.merge(&quot;Lilei&quot;, &quot; 年龄24&quot;, (oldValue, value) -&gt; oldValue.concat(value));</span><br><span class="line">    staffMap.merge(&quot;Hanmeimei&quot;, &quot;年龄22&quot;, String::concat);</span><br><span class="line"></span><br><span class="line">    System.out.println(staffMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的输出为：</p><p>{Lilei=性别男 年龄24, Hanmeimei=年龄22}</p><h2 id="结语">结语</h2><p>Java 8引入了函数式编程，也因此为Java中的集合框架带来了许多新的功能，使得我们能更好的进行函数式编程。</p><p>作为一个优秀的Java程序员，要有意识的在实际编码中运用这些新方法，使得我们的代码更简洁更清晰。</p><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;随着Java 8引入了函数式接口和lambda表达式，Java 8中的集合框架（Java Collections Framework, JCF）也增加相应的接口以适应函数式编程。&lt;/p&gt;
&lt;p&gt;本文的目标是带领大家熟悉Java</summary>
      
    
    
    
    <category term="java" scheme="http://www.bojiboqi.fun/categories/java/"/>
    
    
    <category term="函数式编程" scheme="http://www.bojiboqi.fun/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="集合" scheme="http://www.bojiboqi.fun/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>方法引用method reference</title>
    <link href="http://www.bojiboqi.fun/2024/09/24/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8method%20reference/"/>
    <id>http://www.bojiboqi.fun/2024/09/24/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8method%20reference/</id>
    <published>2024-09-24T15:04:46.878Z</published>
    <updated>2024-09-24T15:39:12.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面">写在前面</h2><p>我们已经知道，lambda表达式是一个匿名函数，可以用lambda表达式来实现一个函数式接口。</p><p>很自然的，我们会想到类的方法也是函数，本质上和lambda表达式是一样的，那是否也可以用类的方法来实现一个函数式接口呢？答案是可以的。我们称之为方法引用（method reference）。</p><h2 id="方法引用">方法引用</h2><p>一个典型例子，向一个Map中写入单词以及它的长度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void simpleMethodReference() &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; wordMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // 等同于 wordMap.computeIfAbsent(&quot;hello&quot;, s -&gt; s.length());</span><br><span class="line">    wordMap.computeIfAbsent(&quot;hello&quot;, String::length);</span><br><span class="line"> </span><br><span class="line">    // 输出为 &#123;hello=5&#125;</span><br><span class="line">    System.out.println(wordMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，String::length 就是方法引用，它用 :: 来分割类名或对象与方法名，:: 左侧是类名或对象，:: 右侧是方法名。</p><p>一般来说，方法引用有4种情况：</p><ol><li><p>object::instanceMethod —— 对象 + 实例方法</p></li><li><p>Class::staticMethod —— 类名 + 静态方法</p></li><li><p>Class::instanceMethod —— 类名 + 实例方法</p></li><li><p>Class::new —— 类名 + 关键字 new ，这种情况又称为构造器引用(constructor reference)</p></li></ol><h3 id="1-object-instanceMethod">1. object::instanceMethod</h3><p>object::instanceMethod，:: 左侧是一个对象，:: 右侧是实例方法名。</p><p>它等价于提供了 instanceMethod 方法的参数列表的 lambda表达式。</p><p>形象来说，假设方法 instanceMethod 的参数列表为 (x, y)，那么 object::instanceMethod 等价于 (x, y) -&gt; object.instanceMethod(x, y) 。</p><p>例如对于字符串 str （String str = “”）：</p><p>str::compareTo 等价于  s -&gt; str.compareTo(s)</p><p>示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void objectInstanceMethodReference() &#123;</span><br><span class="line">    String me = &quot;me&quot;;</span><br><span class="line"></span><br><span class="line">    // wordMap 的 key 是给定的单词，value是不区分大小写，与单词 &quot;me&quot; 比较后得出的值</span><br><span class="line">    Map&lt;String, Integer&gt; wordMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // me::compareToIgnoreCase 等价于 s -&gt;  me.compareToIgnoreCase(s)</span><br><span class="line">    wordMap.computeIfAbsent(&quot;him&quot;, me::compareToIgnoreCase);</span><br><span class="line">    wordMap.computeIfAbsent(&quot;you&quot;, s -&gt;  me.compareToIgnoreCase(s));</span><br><span class="line"></span><br><span class="line">    System.out.println(wordMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的输出是：</p><p>{him=5, you=-12}</p><h3 id="2-Class-staticMethod">2. Class::staticMethod</h3><p>Class::staticMethod，:: 左侧是一个类，:: 右侧是静态方法名。</p><p>它等价于提供了staticMethod方法的参数列表的lambda表达式。</p><p>形象来说，假设静态方法 staticMethod 的参数列表为 (x, y)，那么 Class::staticMethod 等价于 (x, y) -&gt; Class.staticMethod(x, y) 。</p><p>例如：</p><p>System.out::println 等价于 x -&gt; System.out.print(x)</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void classStaticMethodReference() &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;Guangdong&quot;, &quot;Zhejiang&quot;, &quot;Jiangsu&quot;);</span><br><span class="line"></span><br><span class="line">    // System.out::println 等价于 s -&gt; System.out.println(s)</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出为：</p><p>Guangdong</p><p>Zhejiang</p><p>Jiangsu</p><h3 id="3-Class-instanceMethod">3. Class::instanceMethod</h3><p>对于Class::instanceMethod，:: 左侧是一个类，:: 右侧是实例方法名。</p><p>假设 instanceMethod 的参数列表是 (x, y)，那么Class::instanceMethod 等价于lambda表达式  (obj, x, y) -&gt; obj.instanceMethod(x, y)，其中 obj 是 Class 的对象实例。</p><p>例如：</p><p>String::length 等价于 s -&gt; s.length()</p><p>String::compareToIgnoreCase 等价于 (s1, s2) -&gt; s1.compareToIgnoreCase(s2)</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void classInstanceMethodReference() &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; wordMap = new HashMap&lt;&gt;();</span><br><span class="line">    Integer wordLen = wordMap.computeIfAbsent(&quot;hello&quot;, String::length);</span><br><span class="line">    System.out.println(wordMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出为：</p><p>{hello=5}</p><h3 id="4-Class-new">4. Class::new</h3><p>对于Class::new，new的含义是指Class的构造函数，所以又称为构造器引用(constructor reference)。</p><p>假设Class的构造函数有两个，它们的参数列表分别是(x)和(x, y)，那么 Class::new 可能等价于 x -&gt; new Class(x)，也有可能等价于 (x, y) -&gt; new Class(x, y)，具体是哪个，编译器会在编译阶段通过上下文推断出来。</p><p>例如：</p><p>BigDecimal::new ，根据上下文，可能等价于 (String s) -&gt; new BigDecimal(s)</p><p>特别的，数组类型也可以使用构造器引用。数组类型只有一个构造参数，表示数组的长度：</p><p>String[]::new 等价于 x -&gt; new String[x]</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void ctorMethodReference() &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;1.1&quot;, &quot;2.2&quot;, &quot;3.3&quot;);</span><br><span class="line"></span><br><span class="line">    // BigDecimal::new 根据上下文推断，等价于 s -&gt; new BigDecimal(s)</span><br><span class="line">    Stream&lt;BigDecimal&gt; stream = list.stream().map(BigDecimal::new);</span><br><span class="line">    List&lt;BigDecimal&gt; decimalList = stream.collect(Collectors.toList());</span><br><span class="line">    System.out.println(decimalList);</span><br><span class="line"></span><br><span class="line">    // 构建一个新的 Stream ，之前的 Stream 已经被关闭了</span><br><span class="line">    Stream&lt;BigDecimal&gt; stream1 = list.stream().map(BigDecimal::new);</span><br><span class="line"></span><br><span class="line">    // BigDecimal[]::new ，数组的构造器引用，等价于 x -&gt; new BigDecimal[x]</span><br><span class="line">    BigDecimal[] decimalArray = stream1.toArray(BigDecimal[]::new);</span><br><span class="line">    for (BigDecimal d : decimalArray) &#123;</span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的输出为：</p><p>[1.1, 2.2, 3.3]</p><p>1.1</p><p>2.2</p><p>3.3</p><h3 id="5-this-instanceMethod和super-instanceMethod">5. this::instanceMethod和super::instanceMethod</h3><p>对于this::instanceMethod，很容易理解，相当于把this关键字看做是当前类的实例对象即可。</p><p>例如：</p><p>this::equals 等价于 x -&gt; this.equals(x)</p><p>对于super::instanceMethod，会相对复杂一些，相当于在this对象上，调用的指定方法父类版本。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class SuperMethodReferenceExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadWaiter waiter = new ThreadWaiter();</span><br><span class="line">        waiter.run();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static class Waiter &#123;</span><br><span class="line">        public void sayHi() &#123;</span><br><span class="line">            System.out.println(&quot;Hello, man!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static class ThreadWaiter extends Waiter &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void sayHi() &#123;</span><br><span class="line">            System.out.println(&quot;Hello, thread!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public void run() &#123;</span><br><span class="line">            // 指定调用父类 Waiter 的 sayHi 方法</span><br><span class="line">            Thread t = new Thread(super::sayHi);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的输出为：</p><p>Hello, man!</p><h2 id="结语">结语</h2><p>方法引用可以视为lambda表达式的一个语法糖。</p><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;我们已经知道，lambda表达式是一个匿名函数，可以用lambda表达式来实现一个函数式接口。&lt;/p&gt;
&lt;p&gt;很自然的，我们会想到类的方法也是函数，本质上和lambda表达式是一样的，那是否也可以用类的方法来实现一个函数式接口</summary>
      
    
    
    
    <category term="java" scheme="http://www.bojiboqi.fun/categories/java/"/>
    
    
    <category term="jvm" scheme="http://www.bojiboqi.fun/tags/jvm/"/>
    
  </entry>
  
</feed>
