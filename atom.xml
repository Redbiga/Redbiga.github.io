<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>山麋一笑</title>
  
  
  <link href="http://www.bojiboqi.fun/atom.xml" rel="self"/>
  
  <link href="http://www.bojiboqi.fun/"/>
  <updated>2024-02-23T12:59:21.229Z</updated>
  <id>http://www.bojiboqi.fun/</id>
  
  <author>
    <name>山麋一笑</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>免费下载网易云付费音乐</title>
    <link href="http://www.bojiboqi.fun/2024/02/23/%E4%B8%8B%E8%BD%BD%E7%BD%91%E6%98%93%E4%BA%91%E4%BB%98%E8%B4%B9%E9%9F%B3%E4%B9%90/"/>
    <id>http://www.bojiboqi.fun/2024/02/23/%E4%B8%8B%E8%BD%BD%E7%BD%91%E6%98%93%E4%BA%91%E4%BB%98%E8%B4%B9%E9%9F%B3%E4%B9%90/</id>
    <published>2024-02-23T12:56:39.392Z</published>
    <updated>2024-02-23T12:59:21.229Z</updated>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id="只适用PC：">只适用PC：</h2><h2 id="1-搜索要下载的付费音乐打开开发者模式：">1.搜索要下载的付费音乐打开开发者模式：</h2><h4 id="打开开发者模式：">打开开发者模式：</h4><p>按F12或者鼠标右键选择检查：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1708692555387-c1748ef6-c7bf-421a-bab5-c3d3d3a1d2f2.png#averageHue=%23d8bd9b&amp;clientId=u4ebd3624-36cf-4&amp;from=paste&amp;height=510&amp;id=u75200f3d&amp;originHeight=637&amp;originWidth=1561&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=195670&amp;status=done&amp;style=none&amp;taskId=u94f765c6-2a22-4437-9062-085a675a424&amp;title=&amp;width=1248.8" alt="image.png"><br>刚开始进入开发者模式是这个界面！我们需要的不是这个界面，按照如下的步骤进入下个界面：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1708692645419-e1000f56-536e-4377-a0e9-60637e0fdb08.png#averageHue=%23d7c5a2&amp;clientId=u4ebd3624-36cf-4&amp;from=paste&amp;height=507&amp;id=uc4550e92&amp;originHeight=634&amp;originWidth=1708&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=177283&amp;status=done&amp;style=none&amp;taskId=u92330f53-e65a-4aba-bd11-de564939d38&amp;title=&amp;width=1366.4" alt="image.png"><br>点击播放刷新页面或者按住ctrl+r，然后页面变成下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1708692785653-f4853c1a-9836-44ac-bf8f-eb8fbde6189a.png#averageHue=%23d9dcc4&amp;clientId=u4ebd3624-36cf-4&amp;from=paste&amp;height=586&amp;id=u0c1eb7de&amp;originHeight=733&amp;originWidth=1716&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=262338&amp;status=done&amp;style=none&amp;taskId=u91b9bb7c-5a80-4fdc-89cf-b5e5bffc7b0&amp;title=&amp;width=1372.8" alt="image.png"><br>如果走到这步上图的右侧没有下面没有请求，就是没有点击播放！<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1708692884296-f2c155b2-5013-4ca4-a130-a4921276a6b5.png#averageHue=%23d8dbc3&amp;clientId=u4ebd3624-36cf-4&amp;from=paste&amp;height=553&amp;id=u8e9444a7&amp;originHeight=691&amp;originWidth=1618&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=235327&amp;status=done&amp;style=none&amp;taskId=ue0eba2ba-a203-4f2c-ab3b-836563101ef&amp;title=&amp;width=1294.4" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1708692930533-f93a36a8-2f52-4f85-a2fd-8d6c5ac74274.png#averageHue=%23dac298&amp;clientId=u4ebd3624-36cf-4&amp;from=paste&amp;height=608&amp;id=ufa76291c&amp;originHeight=760&amp;originWidth=1552&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=243818&amp;status=done&amp;style=none&amp;taskId=ue8a73002-e414-4c7e-a001-e372c46597e&amp;title=&amp;width=1241.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1708692986619-5018024f-1c4a-4250-9707-c8e25623817a.png#averageHue=%23000000&amp;clientId=u4ebd3624-36cf-4&amp;from=paste&amp;height=365&amp;id=ub81e2a9f&amp;originHeight=456&amp;originWidth=705&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=21754&amp;status=done&amp;style=none&amp;taskId=u81efb9b2-9ca0-44e9-a7ec-eaeb0b43592&amp;title=&amp;width=564" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html"> &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h2 id=&quot;只适用PC：&quot;&gt;只适用PC：&lt;/h2&gt;
&lt;h2 id=&quot;1-搜索要下载的付费音乐打开开发者模式：&quot;&gt;1.搜索要下载的付费音乐打开开发者模式：&lt;/h2&gt;
&lt;h4 id=&quot;打开</summary>
      
    
    
    
    <category term="杂项" scheme="http://www.bojiboqi.fun/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="白嫖技能" scheme="http://www.bojiboqi.fun/tags/%E7%99%BD%E5%AB%96%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>搜索技巧</title>
    <link href="http://www.bojiboqi.fun/2024/01/26/%E6%90%9C%E7%B4%A2%E7%9A%84%E6%8A%80%E5%B7%A7%EF%BC%9A/"/>
    <id>http://www.bojiboqi.fun/2024/01/26/%E6%90%9C%E7%B4%A2%E7%9A%84%E6%8A%80%E5%B7%A7%EF%BC%9A/</id>
    <published>2024-01-26T11:19:15.021Z</published>
    <updated>2024-02-02T14:36:15.370Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><a href="https://www.youtube.com/watch?v=tiN6T1LewmQ">视频</a><br><a href="https://cloud.tencent.com/developer/article/2240162">Google 和 Baidu 的 16 个高级搜索技巧，干货满满！建议收藏学习！-腾讯云开发者社区-腾讯云</a></p><h2 id="搜索引擎技巧（重要）：">搜索引擎技巧（重要）：</h2><h4 id="1-精确搜索：双引号">1.精确搜索：双引号</h4><p>精确搜索，就是在你要搜索的词上，加上双引号，那个 Google 搜索引擎，就会完全的匹配你所要的词</p><h4 id="2-站内搜索：site">2.站内搜索：site</h4><p>这是一个比较常用的搜索方法，site 搜索，就是在站内进行搜索.<br>语法是：site:stackoverflow.com ，其中 site:后面加上你要搜索的网站地址。<br>一般程序猿解决问题，用 site:stackoverflow.com，大部分解决不了的问题，都会有答案了。</p><h4 id="intitle-搜索范围限定在网页标题（也就是intitle后面的内容是标题的一部分）"><strong>intitle - 搜索范围限定在网页标题（也就是intitle后面的内容是标题的一部分）</strong></h4><p>搜索范围限定在包含 keyword 的网页标题中，这也是最普通的搜索。<br>intitle: 和后面的关键词之间不要有空格。</p><h4 id="allintitle-限定标题多个关键字：">allintitle 限定标题多个关键字：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allintitle:李子柒 微念</span><br><span class="line">上面的意思是搜索结果的标题中要出现李子柒和微念两个关键词</span><br></pre></td></tr></table></figure><h4 id="inurl-搜索范围限定在-url-链接中"><strong>inurl 搜索范围限定在 url 链接中</strong></h4><p><strong>搜索范围限定在 url 链接中</strong>.<br>网页 url 中的某些信息，常常有某种有价值的含义。您如果对搜索结果的 url 做某种限定，可以获得良好的效果。<br>例如：前端教程 inurl:video</p><h4 id="imagesize-限定图片大小">imagesize:限定图片大小</h4><h4 id="filetype-限定文档：">filetype:限定文档：</h4><h2 id="导航网站（比较重要）：">导航网站（比较重要）：</h2><p>直接谷歌搜某某行业导航网站或某某岗位/行业必逛网站。</p><h2 id="寻找相似的网站：">寻找相似的网站：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1702707274512-a461297e-ad20-4d75-b773-a705963eaa7b.png#averageHue=%23363636&amp;clientId=u3b86627d-2b3e-4&amp;from=paste&amp;height=337&amp;id=ubb915741&amp;originHeight=421&amp;originWidth=900&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=273502&amp;status=done&amp;style=none&amp;taskId=u71acd269-4266-436e-b322-392a28d79c5&amp;title=&amp;width=720" alt="image.png"></p><h2 id="论文搜索：">论文搜索：</h2><p>谷歌学术和SCI-HUB，高校图书馆</p><h2 id="电子书（重要）：">电子书（重要）：</h2><p><a href="https://www.thinkdoc.vip/">欢乐图书馆|收录最优质的电子书网站的导航网站 | 最好的zlibrary电子书网址导航网站</a></p><h2 id="百度网盘搜索引擎：">百度网盘搜索引擎：</h2><p><a href="https://www.dalipan.com/#/main/search?restype=1">大力盘 - 网盘搜索引擎</a><br><a href="https://www.xuesousou.net/">学搜搜(酷搜kolsou) - 百度网盘搜索引擎,百度云资源搜索,网盘资源下载</a><br><a href="https://pansou.cc/">盘搜搜 - 百度网盘资源搜索神器</a><br><a href="https://www.yunpangou.com/2155351113250243?p=4">Attention Required! | Cloudflare</a><br>个人感觉网盘搜索用处较少，有点鸡肋。</p><h2 id="素材搜索：">素材搜索：</h2><p><a href="https://www.pexels.com/zh-cn/">pexels</a><br><a href="https://pixabay.com/">pixabay</a><br><a href="https://www.videvo.net/">videvo</a><br><a href="https://mixkit.co/">mixkit</a></p><h2 id="以图搜片：">以图搜片：</h2><p><a href="https://www.youtube.com/watch?v=tERFkMjRGaE">视频教学</a><br><a href="https://xslist.org/tw">xslist</a>（根据图片寻找女优信息）<br><a href="https://tineye.com/">老牌搜图</a><br><a href="https://trace.moe/">搜索动漫</a><br>search by image浏览器插件</p><h2 id="galgame资源：">galgame资源：</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=tiN6T1LewmQ&quot;&gt;视频&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;https://cloud.tenc</summary>
      
    
    
    
    
    <category term="零散知识点" scheme="http://www.bojiboqi.fun/tags/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>springCloud</title>
    <link href="http://www.bojiboqi.fun/2024/01/26/%E9%BB%91%E9%A9%AC%E6%95%99%E7%A8%8B%EF%BC%9A/"/>
    <id>http://www.bojiboqi.fun/2024/01/26/%E9%BB%91%E9%A9%AC%E6%95%99%E7%A8%8B%EF%BC%9A/</id>
    <published>2024-01-26T11:17:53.150Z</published>
    <updated>2024-01-26T11:18:43.630Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1>基础概念：</h1><p>1.Eureka:<br><a href="https://blog.csdn.net/Pireley/article/details/133784749">Eureka（服务注册和发现）——Eureka的简介和原理 &amp; Eureka的使用和分析 &amp; 心跳续约策略，服务的下线和剔除，自我保护 &amp; Eureka集群的搭建-CSDN博客</a></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在微服务架构中，一个应用通常被拆分成多个独立的服务，这些服务需要能够相互通信和调用。通过使用Eureka，服务提供者向Eureka服务端注册自己，并将其元数据信息（如IP地址、端口号、机群名称等）注册到Eureka服务器中。服务消费者则通过向Eureka服务端查询，获取服务提供者的地址，并通过Eureka的服务调用机制与服务提供者进行通信。</span><br></pre></td></tr></table></figure><p>2.@EnableEurekaServer:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@EnableEurekaServer是Spring Cloud中用于配置一个Eureka Server的注解。使用这个注解可以将一个Spring Boot应用配置为Eureka Server，用于注册和发现其他服务提供者（Service Provider）。 被@EnableEurekaServer注解标记的类中需要包含一个基于Web的控制器（Controller），用于处理客户端的请求。Eureka Server通过这个控制器对外提供注册和发现服务的接口。</span><br></pre></td></tr></table></figure><p>3.RestTemplate:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.用于发送HTTP请求和接收HTTP响应的工具类</span><br><span class="line"><span class="number">2</span>.restTemplate.getForObject(url, User.class):根据url路径发送http请求，返回的数据映射到User类上</span><br></pre></td></tr></table></figure><p>4.@LoadBalanced</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">    @LoadBalanced</span><br><span class="line">    public RestTemplate restTemplate() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">让注入的 RestTemplate具有负载均衡的能力</span><br></pre></td></tr></table></figure><h1>RestTemplate结合@LoadBalanced：</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h1&gt;基础概念：&lt;/h1&gt;
&lt;p&gt;1.Eureka:&lt;br&gt;
&lt;a href=&quot;https://blog.csdn.net/Pireley/article/details/13378474</summary>
      
    
    
    
    <category term="springboot2" scheme="http://www.bojiboqi.fun/categories/springboot2/"/>
    
    
    <category term="springCloud" scheme="http://www.bojiboqi.fun/tags/springCloud/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习</title>
    <link href="http://www.bojiboqi.fun/2024/01/26/Docker%E5%AD%A6%E4%B9%A0%EF%BC%9A/"/>
    <id>http://www.bojiboqi.fun/2024/01/26/Docker%E5%AD%A6%E4%B9%A0%EF%BC%9A/</id>
    <published>2024-01-26T11:16:44.802Z</published>
    <updated>2024-01-26T11:17:33.774Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1>1.Linux-ubuntu20.04 docker的镜像加速配置:</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1、 建立deamon.json 配置docker国内镜像加速地址</span></span><br><span class="line">$ sudo vim /etc/docker/daemon.json</span><br><span class="line"><span class="comment">#添加镜像的内容如下：这行注释在添加的时候要删除的</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line"><span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://hub-mirror.c.163.com/&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://reg-mirror.qiniu.com&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://registry.docker-cn.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#2、添加完成之后重启docker服务</span></span><br><span class="line">sudo systemctl reload docker</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"><span class="comment">#注意：如果重启docker服务时遇到 docker.service is not active,cannot reload问题需要重启ubuntu系统</span></span><br><span class="line"><span class="comment">#3、查看docker 相关信息</span></span><br><span class="line">sudo docker info</span><br><span class="line"><span class="comment">#使用命令之后在最后几行出现一下信息代表配置成功</span></span><br><span class="line"> Registry Mirrors:</span><br><span class="line">  https://docker.mirrors.ustc.edu.cn/</span><br><span class="line">  https://hub-mirror.c.163.com/</span><br><span class="line">  https://reg-mirror.qiniu.com/</span><br><span class="line">  https://registry.docker-cn.com/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>2.相关概念：</h1><ol><li>容器（Container）：容器是Docker中运行应用程序的实例。它们是基于镜像创建的，可以独立运行，并且具有自己的文件系统、进程空间和网络接口。容器提供了一个轻量级、可移植和隔离的环境，使应用程序可以在不同的计算机或环境中一致地运行。</li><li>镜像（Image）：镜像是Docker中用于创建容器的模板。它包含了一个完整的文件系统，其中包括应用程序所需的所有文件、库和依赖项。镜像是只读的，可以从一个基础镜像构建，然后通过在其上应用更改和配置来定制。镜像是构建和分发应用程序的基本单元，可以在不同的环境中重复使用。</li><li>仓库（Repository）：仓库是用于存储和共享Docker镜像的地方。它类似于代码仓库，可以存储多个镜像，并提供版本控制和标签管理。Docker Hub是一个公共仓库，其中包含了大量的官方和社区维护的镜像。此外，你也可以创建私有仓库来存储和管理自己的镜像。</li></ol><h1>常用的命令：</h1><p><a href="https://cloud.tencent.com/developer/article/1772136">一张脑图整理Docker常用命令-腾讯云开发者社区-腾讯云</a><br>Docker最常见的命令就是操作镜像、容器的命令，详见官方文档： <a href="https://docs.docker.com/">https://docs.docker.com/</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701929033107-ca6aa435-7381-47eb-a12b-32fcf5ccdad2.png#averageHue=%23f9f9f8&amp;clientId=ufdf80702-067d-4&amp;from=paste&amp;height=414&amp;id=u7bc6c6c6&amp;originHeight=518&amp;originWidth=1256&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=74185&amp;status=done&amp;style=none&amp;taskId=u897341c8-b655-4763-a87e-fff75e8ad79&amp;title=&amp;width=1004.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701929206068-511fc274-0834-4a9f-a6e6-fb12c892db52.png#averageHue=%23fbf9f7&amp;clientId=ufdf80702-067d-4&amp;from=paste&amp;id=u4ed052f0&amp;originHeight=958&amp;originWidth=1942&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6df0f28c-805a-4ad2-aa8a-52d1da7444e&amp;title=" alt=""><br>1.从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure><ol start="2"><li></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> ubuntu:18.04 bash以交互式启动一个容器，如果启动后想退出，输入<span class="built_in">exit</span>就可以了</span><br></pre></td></tr></table></figure><h1>Docker部署Mysql:</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701934094635-162132cc-e61b-404f-9050-c64f7f54afa7.png#averageHue=%23fbf9f8&amp;clientId=ufdf80702-067d-4&amp;from=paste&amp;height=462&amp;id=ude019f64&amp;originHeight=578&amp;originWidth=1062&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=109651&amp;status=done&amp;style=none&amp;taskId=u17d4b19a-5081-46dd-948c-972c6bd1973&amp;title=&amp;width=849.6" alt="image.png"><br>mysql中的数据卷是由容器运行时创建的卷，称为匿名卷<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701934330675-b5e91097-e7c4-4a6f-8938-7282969848fd.png#averageHue=%23103138&amp;clientId=ufdf80702-067d-4&amp;from=paste&amp;height=303&amp;id=ud210a64c&amp;originHeight=379&amp;originWidth=1408&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=266040&amp;status=done&amp;style=none&amp;taskId=u98f2b8cf-b2c1-42e2-bf45-ff3c9d295ef&amp;title=&amp;width=1126.4" alt="image.png"><br><a href="https://www.runoob.com/docker/docker-install-mysql.html">Docker 安装 MySQL | 菜鸟教程</a></p><h1>Docker部署nginx:</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701931317900-c2c44426-7cdf-4a6e-9555-b4faa6bcc1da.png#averageHue=%23fcfbfa&amp;clientId=ufdf80702-067d-4&amp;from=paste&amp;height=114&amp;id=u1b7dce6a&amp;originHeight=142&amp;originWidth=920&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=28641&amp;status=done&amp;style=none&amp;taskId=u7c189199-7958-4b1a-86ca-1404e04900c&amp;title=&amp;width=736" alt="image.png"><br>nginx镜像只包括了nginx运行所需要的资源，当我们想要修改nginx中的index.html的时候，在该容器中无法用vi等编辑器修改；因为nginx镜像中没有vi等编辑器的资源。如果我们想要修改index.html的时候可以通过数据卷的方式修改；<br>挂载：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701933349995-9b5a10d5-e2c0-438b-945a-eb1764ef9a98.png#averageHue=%23f6faed&amp;clientId=ufdf80702-067d-4&amp;from=paste&amp;height=76&amp;id=u29698b62&amp;originHeight=95&amp;originWidth=724&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=43572&amp;status=done&amp;style=none&amp;taskId=u2fb5d0cd-b8eb-40ea-8a1a-19eb95dfc5f&amp;title=&amp;width=579.2" alt="image.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 -v html:/usr/share/nginx/html --name my-nginx nginx</span><br></pre></td></tr></table></figure><p>这里的html是我们的数据卷，是一个虚拟目录；/usr/share/nginx/html是一个映射容器内的目录；<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701933798439-7e62346f-2dbb-4335-8993-388bb01bd37c.png#averageHue=%23e4c99a&amp;clientId=ufdf80702-067d-4&amp;from=paste&amp;height=80&amp;id=u343f946a&amp;originHeight=100&amp;originWidth=895&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=16538&amp;status=done&amp;style=none&amp;taskId=ucb70c40d-504f-4cb1-844b-3fac0ec1c85&amp;title=&amp;width=716" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701933934780-a0a00d0b-540e-4162-9c3a-3b25fb257411.png#averageHue=%23201f1e&amp;clientId=ufdf80702-067d-4&amp;from=paste&amp;height=230&amp;id=ucdfedb85&amp;originHeight=288&amp;originWidth=872&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=36056&amp;status=done&amp;style=none&amp;taskId=ue9439c90-9910-4013-b1a2-ce21646fed5&amp;title=&amp;width=697.6" alt="image.png"></p><h1>数据卷：</h1><p>数据卷只是虚拟的目录只是当成件容器内的目录和主机目录联系起来。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701929484358-fdb371a0-d78b-40b2-b28d-2ecf5f8c23c1.png#averageHue=%23fdfcfc&amp;clientId=ufdf80702-067d-4&amp;from=paste&amp;height=458&amp;id=uf3c6aad1&amp;originHeight=573&amp;originWidth=1284&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=85829&amp;status=done&amp;style=none&amp;taskId=u7d0e1528-b473-4a44-9d65-02187d010f8&amp;title=&amp;width=1027.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701929550714-d8ae9d2a-93a2-40b6-ab11-5fb7569ca287.png#averageHue=%23d1aa79&amp;clientId=ufdf80702-067d-4&amp;from=paste&amp;height=433&amp;id=u2b7f4e0e&amp;originHeight=541&amp;originWidth=1213&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=68371&amp;status=done&amp;style=none&amp;taskId=ud1083521-c2c6-4916-a11a-927b88e4c62&amp;title=&amp;width=970.4" alt="image.png"></p><h1>自定义镜像：</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701935784876-7116fc00-2913-4fd6-8168-803d0f431f63.png#averageHue=%2397ac7e&amp;clientId=ufdf80702-067d-4&amp;from=paste&amp;height=308&amp;id=uea723465&amp;originHeight=385&amp;originWidth=926&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=155767&amp;status=done&amp;style=none&amp;taskId=u0eaa9ac7-e6f7-49da-83ac-5a37ce6b9a0&amp;title=&amp;width=740.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701936239863-1d3b6d89-ea56-4012-a751-76eaa9e3624b.png#averageHue=%23e0e4e9&amp;clientId=ufdf80702-067d-4&amp;from=paste&amp;height=338&amp;id=u1b938984&amp;originHeight=423&amp;originWidth=927&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=181885&amp;status=done&amp;style=none&amp;taskId=u5a54000a-492e-4ff9-b189-59afeac0cea&amp;title=&amp;width=741.6" alt="image.png"></p><h1>网络：</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701936913349-7159f054-30d3-4df8-967a-4513b9f0af98.png#averageHue=%23f8f5f3&amp;clientId=ufdf80702-067d-4&amp;from=paste&amp;height=498&amp;id=uf1ddafb6&amp;originHeight=622&amp;originWidth=1184&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=51900&amp;status=done&amp;style=none&amp;taskId=u45c4309a-28aa-4907-beb7-d43a3bac732&amp;title=&amp;width=947.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1701936961559-af663492-d566-40b9-b6e7-ec4e3b99a3a3.png#averageHue=%23ebe0df&amp;clientId=ufdf80702-067d-4&amp;from=paste&amp;height=450&amp;id=u258f69b9&amp;originHeight=563&amp;originWidth=1263&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=113035&amp;status=done&amp;style=none&amp;taskId=u2e721c35-bf12-41dc-8c33-e290c18d55a&amp;title=&amp;width=1010.4" alt="image.png"></p><h1>IDEA运行Docker</h1><p>入门：<br><a href="https://www.cnblogs.com/mayhot/p/15904506.html">https://www.cnblogs.com/mayhot/p/15904506.html</a><br><a href="https://blog.csdn.net/u010675669/article/details/114368037">Idea使用Docker部署SpringBoot项目_idea docker springboot-CSDN博客</a><br>1.配置pom.xml的build：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;excludes&gt;</span><br><span class="line">                        &lt;exclude&gt;</span><br><span class="line">                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">                        &lt;/exclude&gt;</span><br><span class="line">                    &lt;/excludes&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;!--使用docker-maven-plugin插件--&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">                &lt;!--将插件绑定在某个phase执行--&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;<span class="built_in">id</span>&gt;build-image&lt;/id&gt;</span><br><span class="line">                        &lt;!--用户只需执行mvn package ，就会自动执行mvn docker:build--&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;build&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;!--指定生成的镜像名--&gt;</span><br><span class="line">          <span class="comment"># $&#123;project.artifactId&#125;是一个Maven变量，它代表项目的构件ID，即项目的唯一标识符。</span></span><br><span class="line">                    &lt;imageName&gt;zrs/<span class="variable">$&#123;project.artifactId&#125;</span>&lt;/imageName&gt;</span><br><span class="line">                    &lt;!--指定标签--&gt;</span><br><span class="line">                    &lt;imageTags&gt;</span><br><span class="line">                        &lt;imageTag&gt;latest&lt;/imageTag&gt;</span><br><span class="line">                    &lt;/imageTags&gt;</span><br><span class="line">                    &lt;!-- 指定 Dockerfile 路径--&gt;</span><br><span class="line"><span class="comment">#$&#123;project.basedir&#125; 是一个Maven变量，它代表项目的根目录路径。在Maven构建过程中，</span></span><br><span class="line"><span class="comment"># $&#123;project.basedir&#125;会被解析为项目根目录的实际路径。</span></span><br><span class="line">                    &lt;dockerDirectory&gt;<span class="variable">$&#123;project.basedir&#125;</span>&lt;/dockerDirectory&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--                    指定远程 docker api地址，其中指定的ip地址是远程主机的ip地址，</span><br><span class="line">2375是Docker监听的端口--&gt;</span><br><span class="line">                    &lt;dockerHost&gt;http://192.168.44.130:2375&lt;/dockerHost&gt;</span><br><span class="line">                    &lt;!-- 这里是复制 jar 包到 docker 容器指定目录配置 --&gt;</span><br><span class="line">                    &lt;resources&gt;</span><br><span class="line">                        &lt;resource&gt;</span><br><span class="line"><span class="comment"># &lt;targetPath&gt;：这是指定资源在Docker容器中的目标路径。在这里，/表示根目录，即将资源复制到容</span></span><br><span class="line"><span class="comment"># 器的根目录。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;directory&gt;：这是指定资源所在的目录。$&#123;project.build.directory&#125;是一个Maven变量，它代表项</span></span><br><span class="line"><span class="comment"># 目构建的输出目录，通常是target目录。这意味着插件将从$&#123;project.build.directory&#125;目录中寻找资源。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;include&gt;：这是指定要包含在Docker容器中的jar包的文件名。$&#123;project.build.finalName&#125;.jar是</span></span><br><span class="line"><span class="comment"># 一个Maven变量，它代表项目构建的最终名称，通常是项目的名称加上版本号和构建时间。这个变量将被</span></span><br><span class="line"><span class="comment"># 解析为实际的jar包文件名。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因此，这段代码的作用是将$&#123;project.build.directory&#125;/$&#123;project.build.finalName&#125;.jar这个</span></span><br><span class="line"><span class="comment"># jar包复制到Docker容器的根目录(/)下。</span></span><br><span class="line">                            &lt;targetPath&gt;/&lt;/targetPath&gt;</span><br><span class="line">                            &lt;!--jar 包所在的路径  此处配置的 即对应 target 目录--&gt;</span><br><span class="line">                            &lt;directory&gt;<span class="variable">$&#123;project.build.directory&#125;</span>&lt;/directory&gt;</span><br><span class="line">                            &lt;!-- 需要包含的 jar包 ，这里对应的是 Dockerfile中添加的文件名　--&gt;</span><br><span class="line">                            &lt;include&gt;<span class="variable">$&#123;project.build.finalName&#125;</span>.jar&lt;/include&gt;</span><br><span class="line">                        &lt;/resource&gt;</span><br><span class="line">                    &lt;/resources&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br></pre></td></tr></table></figure><p>Dockerfile的书写：位置在项目根路径下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:17</span><br><span class="line"><span class="comment"># 作者信息</span></span><br><span class="line">LABEL maintainer=<span class="string">&quot;reda&quot;</span></span><br><span class="line"><span class="comment"># 挂载临时目录</span></span><br><span class="line">VOLUME /tmp</span><br><span class="line"><span class="comment"># 将jar包添加到容器中并更名</span></span><br><span class="line">COPY ./target/DockerDome-0.0.1-SNAPSHOT.jar pms.jar</span><br><span class="line"><span class="comment"># 运行jar</span></span><br><span class="line">RUN sh -c <span class="string">&#x27;touch /pms.jar&#x27;</span></span><br><span class="line"><span class="comment"># 容器启动命令</span></span><br><span class="line"></span><br><span class="line">ENTRYPOINT [ <span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/pms.jar&quot;</span> ]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h1&gt;1.Linux-ubuntu20.04 docker的镜像加速配置:&lt;/h1&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class</summary>
      
    
    
    
    <category term="中间件" scheme="http://www.bojiboqi.fun/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Docker" scheme="http://www.bojiboqi.fun/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Rabbits学习总结</title>
    <link href="http://www.bojiboqi.fun/2024/01/26/Rabbits_/"/>
    <id>http://www.bojiboqi.fun/2024/01/26/Rabbits_/</id>
    <published>2024-01-26T11:15:04.222Z</published>
    <updated>2024-01-26T11:16:27.600Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><a href="https://kangshitao.github.io/2021/10/26/rabbitmq/">https://kangshitao.github.io/2021/10/26/rabbitmq/</a></p><h2 id="基础知识：">基础知识：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1702457198211-27a90a27-4567-449b-b17e-b869cd5adfe5.png#averageHue=%23ba9036&amp;clientId=u4d991bf9-5f69-4&amp;from=paste&amp;height=463&amp;id=u3d2c52db&amp;originHeight=579&amp;originWidth=1305&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=102416&amp;status=done&amp;style=none&amp;taskId=u7533b0ce-ebbb-486a-a056-ada26df96a9&amp;title=&amp;width=1044" alt="image.png"><br>2.消息应答：**消费者在接 收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。 **</p><h2 id="1-安装：">1.安装：</h2><p><a href="https://blog.csdn.net/luiluier/article/details/124167341">Ubuntu20.04安装RabbitMQ，并配置远程调用，详细教程_ubuntu20.04 rabbitmq安装使用-CSDN博客</a></p><h2 id="2-hello项目：">2.hello项目：</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.生产者创建连接工厂，连接工厂创建连接</span><br><span class="line"><span class="number">2</span>.发送消息（创建Channel)</span><br><span class="line"><span class="number">3</span>.消费者创建连接工厂，连接工厂创建连接（需要提供服务器地址，端口，用户，密码）</span><br><span class="line"><span class="number">4</span>.接收信息（创建Channel,</span><br><span class="line"><span class="number">5</span>.消费者内部有消费成功的回调函数和失败的回调函数，消费者会监听生产者生成消息</span><br><span class="line"><span class="number">6</span>.当只有一个生产者，多个消费者的时候，消费者默认按照轮询的方式消费信息</span><br><span class="line"><span class="number">7</span>.</span><br></pre></td></tr></table></figure><h2 id="消息应答：">消息应答：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1702459231088-99fb3d4c-7e08-453b-bb93-1ce513bf8742.png#averageHue=%23c5c4c4&amp;clientId=u4d991bf9-5f69-4&amp;from=paste&amp;height=346&amp;id=uf3a9aaa3&amp;originHeight=432&amp;originWidth=1080&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=97870&amp;status=done&amp;style=none&amp;taskId=u322a182b-447f-4416-b783-10a96e6723d&amp;title=&amp;width=864" alt="image.png"><br>1.默认为自动应答，也就是信息发出去后队列就删除这条信息。我们可以设置为手动应答，当我们发送成功后，但是某一个消费者挂掉了，这个时候发送丢失的消息就会重写入队。</p><h2 id="持久化：">持久化：</h2><p>1.保障当 RabbitMQ 服务停掉以后消 息生产者发送过来的消息不丢失。默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列 和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：<strong>我们需要将队列和消息都标 记为持久化。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1702460422423-363f570e-1836-4f96-a847-c9c40a4bb406.png#averageHue=%23c5c2c0&amp;clientId=u4d991bf9-5f69-4&amp;from=paste&amp;height=289&amp;id=u86632831&amp;originHeight=361&amp;originWidth=1319&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=170633&amp;status=done&amp;style=none&amp;taskId=u1d8a6660-724c-4b92-a3af-f6407dc0da4&amp;title=&amp;width=1055.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1702460503297-f61a699e-7dfe-48a8-94c8-3302aed89403.png#averageHue=%23bfbebc&amp;clientId=u4d991bf9-5f69-4&amp;from=paste&amp;height=405&amp;id=uff419f1d&amp;originHeight=506&amp;originWidth=1330&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=243829&amp;status=done&amp;style=none&amp;taskId=u652007f0-16fc-44c3-89b3-b5faedafc8c&amp;title=&amp;width=1064" alt="image.png"></p><h2 id="发布确认：">发布确认：</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//开启发布确认</span><br><span class="line"> channel.confirmSelect();</span><br></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//服务端返回 false 或超时时间内未返回，生产者可以消息重发，等待发布的确认</span><br><span class="line"> boolean flag = channel.waitForConfirms();</span><br></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import <span class="keyword">com</span>.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">public class AsyncPublisher &#123;</span><br><span class="line"></span><br><span class="line">    private static final String EXCHANGE_NAME = <span class="string">&quot;async_exchange&quot;</span>;</span><br><span class="line">    private static final String ROUTING_KEY = <span class="string">&quot;async_routing_key&quot;</span>;</span><br><span class="line">    private static final String QUEUE_NAME = <span class="string">&quot;async_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 创建连接工厂</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line"></span><br><span class="line">        // 创建连接</span><br><span class="line">        try (Connection connection = factory.newConnection();</span><br><span class="line">             Channel channel = connection.createChannel()) &#123;</span><br><span class="line"></span><br><span class="line">            // 声明交换机和队列</span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT, true);</span><br><span class="line">            channel.queueDeclare(QUEUE_NAME, true, false, false, null);</span><br><span class="line">            channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ROUTING_KEY);</span><br><span class="line"></span><br><span class="line">            // 设置发布者确认模式</span><br><span class="line">            channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">            // 异步确认发布的回调函数</span><br><span class="line">            ConfirmCallback confirmCallback = (deliveryTag, multiple) -&gt; &#123;</span><br><span class="line">                <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="string">&quot;消息发布成功，deliveryTag: &quot;</span> + deliveryTag);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            // 异步确认发布失败的回调函数</span><br><span class="line">            ConfirmCallback nackCallback = (deliveryTag, multiple) -&gt; &#123;</span><br><span class="line">                <span class="keyword">System</span>.<span class="keyword">err</span>.println(<span class="string">&quot;消息发布失败，deliveryTag: &quot;</span> + deliveryTag);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            // 设置异步确认发布的回调函数</span><br><span class="line">            channel.addConfirmListener(confirmCallback, nackCallback);</span><br><span class="line"></span><br><span class="line">            // 发布消息</span><br><span class="line">            String message = <span class="string">&quot;Hello, RabbitMQ!&quot;</span>;</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</span><br><span class="line"></span><br><span class="line">            // 等待回调确认</span><br><span class="line">            channel.waitForConfirmsOrDie();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="string">&quot;消息发布完成&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="交换机：">交换机：</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kangshitao.github.io/2021/10/26/rabbitmq/&quot;&gt;https://kangshitao.github.io/202</summary>
      
    
    
    
    <category term="中间件" scheme="http://www.bojiboqi.fun/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Rabbits" scheme="http://www.bojiboqi.fun/tags/Rabbits/"/>
    
  </entry>
  
  <entry>
    <title>SpirngBoot开源Demo源码分析：</title>
    <link href="http://www.bojiboqi.fun/2024/01/26/SpirngBoot%E5%BC%80%E6%BA%90Demo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A/"/>
    <id>http://www.bojiboqi.fun/2024/01/26/SpirngBoot%E5%BC%80%E6%BA%90Demo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A/</id>
    <published>2024-01-26T11:13:22.535Z</published>
    <updated>2024-01-26T11:14:33.907Z</updated>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><p><a href="https://github.com/ityouknow/spring-boot-examples">https://github.com/ityouknow/spring-boot-examples</a></p><h1>dockercompose-springboot-mysql-nginx：</h1><h2 id="1，DockerCompose">1，DockerCompose:</h2><p><a href="https://yeasy.gitbook.io/docker_practice/compose/introduction">简介 - Docker — 从入门到实践</a><br><a href="https://www.runoob.com/docker/docker-compose.html">Docker Compose | 菜鸟教程</a></p><ul><li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">   container_name: v-nginx</span><br><span class="line">   image: nginx:1.13</span><br><span class="line">   restart: always</span><br><span class="line">   ports:</span><br><span class="line">   - 80:80</span><br><span class="line">   - 443:443</span><br><span class="line">   volumes:</span><br><span class="line">   - ./nginx/conf.d:/etc/nginx/conf.d</span><br><span class="line">    </span><br><span class="line">  mysql:</span><br><span class="line">   container_name: v-mysql</span><br><span class="line">   image: mysql/mysql-server:5.7</span><br><span class="line">   environment:</span><br><span class="line">    MYSQL_DATABASE: <span class="built_in">test</span></span><br><span class="line">    MYSQL_ROOT_PASSWORD: root</span><br><span class="line">    MYSQL_ROOT_HOST: <span class="string">&#x27;%&#x27;</span></span><br><span class="line">   ports:</span><br><span class="line">   - <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">   restart: always</span><br><span class="line">    </span><br><span class="line">  app:</span><br><span class="line">    restart: always</span><br><span class="line">    build: ./app</span><br><span class="line">    working_dir: /app</span><br><span class="line">    volumes:</span><br><span class="line">      - ./app:/app</span><br><span class="line">      - ~/.m2:/root/.m2</span><br><span class="line">    expose:</span><br><span class="line">      - <span class="string">&quot;8080&quot;</span></span><br><span class="line">    depends_on:</span><br><span class="line">      - nginx</span><br><span class="line">      - mysql</span><br><span class="line">    <span class="built_in">command</span>: mvn clean spring-boot:run -Dspring-boot.run.profiles=docker</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">这个docker-compose文件定义了三个服务：nginx、mysql和app。让我逐个解释每个服务的配置：</span><br><span class="line"></span><br><span class="line">nginx服务：</span><br><span class="line"></span><br><span class="line">container_name：指定容器的名称为 v-nginx。</span><br><span class="line">image：使用 nginx:1.13 镜像作为基础镜像。</span><br><span class="line">restart：设置容器在退出时总是自动重启。</span><br><span class="line">ports：将主机的80端口映射到容器的80端口，以及将主机的443端口映射到容器的443端口。</span><br><span class="line">volumes：将主机上的 ./nginx/conf.d 目录挂载到容器的 /etc/nginx/conf.d 目录，用于提供Nginx的配置文件。</span><br><span class="line">mysql服务：</span><br><span class="line"></span><br><span class="line">container_name：指定容器的名称为 v-mysql。</span><br><span class="line">image：使用 mysql/mysql-server:5.7 镜像作为基础镜像。</span><br><span class="line">environment：设置MySQL容器的环境变量，包括数据库名称、root用户的密码和允许访问的主机。</span><br><span class="line">ports：将主机的3306端口映射到容器的3306端口，以便可以通过主机访问MySQL服务。</span><br><span class="line">restart：设置容器在退出时总是自动重启。</span><br><span class="line">app服务：</span><br><span class="line"></span><br><span class="line">restart：设置容器在退出时总是自动重启。</span><br><span class="line">build：使用 ./app 目录中的Dockerfile构建镜像。</span><br><span class="line">working_dir：设置容器的工作目录为 /app。</span><br><span class="line">volumes：将主机上的 ./app 目录挂载到容器的 /app 目录，用于提供应用程序的代码文件。同时，将主机上的 ~/.m2 目录挂载到容器的 /root/.m2 目录，用于提供Maven的依赖文件。</span><br><span class="line">expose：将容器的8080端口暴露给其他容器或主机。</span><br><span class="line">depends_on：指定app服务依赖于nginx和mysql服务，以确保在启动app服务之前，nginx和mysql服务已经启动。</span><br><span class="line"><span class="built_in">command</span>：在容器内部运行命令 mvn clean spring-boot:run -Dspring-boot.run.profiles=docker，用于启动应用程序。</span><br><span class="line">这个docker-compose文件定义了一个多容器应用程序的架构，其中nginx负责处理HTTP和HTTPS请求，mysql负责提供数据库服务，而app服务则是一个基于Spring Boot的应用程序。</span><br></pre></td></tr></table></figure><h2 id="2-在Docker容器中执行sql脚本：">2.在Docker容器中执行sql脚本：</h2><p><a href="https://blog.csdn.net/Entity_G/article/details/122615009">Docker简单部署mysql并导入SQL文件_docker mysql 导入sql-CSDN博客</a><br>1.部署和运行docker:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name mysql \</span><br><span class="line">    --restart=always \</span><br><span class="line">-p 3306:3306 \</span><br><span class="line">-v mysql:/etc/mysql/ \</span><br><span class="line">-v /tmp/mysql:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=12345 \</span><br><span class="line">    mysql:8 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>-v mysql:/etc/mysql/:其中的mysql是虚拟目录对应容器里面的/etc/mysql目录；<br>上面的是在后台启动一个mysql容器，该容器的密码是12345，其中服务端采用的字符集是utf8mb4，并设置了相关的数据集mysql；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/mysql/ 储存配置信息相关文件</span><br><span class="line">/var/lib/mysql 储存mysql实际的数据文件</span><br></pre></td></tr></table></figure><p>2.运行mysql容器（方法1）：直接使用sql语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql bash <span class="comment">#给容器打开一个新的终端</span></span><br><span class="line">mysql -uroot -p123456 <span class="comment">#在新的终端中运行mysql服务器，如果是自己使用mysql语句创建sql时，可以直接</span></span><br><span class="line"><span class="comment">#在这后面创建数据库和表</span></span><br></pre></td></tr></table></figure><p>3.导入sql文件（方法2）：使用sql脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.拷贝SQL文件到mysql容器中</span></span><br><span class="line">docker <span class="built_in">cp</span> yyy.sql mysql:/yyy.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建数据库</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql mysql -h 192.168.6.88 -uroot -p12345  </span><br><span class="line">mysql&gt; create database yyy;</span><br><span class="line">mysql&gt; use yyy;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.登陆控制台执行source 命令</span></span><br><span class="line">mysql&gt; <span class="built_in">source</span> yyy.sql</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>3.Nginx:</h1><p><a href="https://xuexb.github.io/learn-nginx/guide/">Nginx 简介 | Nginx 入门教程</a></p><h1>springboot多环境配置：</h1><p><a href="https://www.cnblogs.com/Chenjiabing/p/13968781.html">https://www.cnblogs.com/Chenjiabing/p/13968781.html</a><br>日常开发中至少有三个环境，分别是开发环境（<strong>dev</strong>），测试环境（<strong>test</strong>），生产环境（<strong>prod</strong>）。<br>既然每个环境的配置都不相同，索性将不同环境的配置放在不同的配置文件中，因此需要创建三个不同的配置文件，分别是<strong>application-dev.properties</strong>、<strong>application-test.properties</strong>、<strong>application-prod.properties</strong>。<br><strong>「注意」</strong>：配置文件的名称一定要是<strong>application-name.properties</strong>或者<strong>application-name.yml</strong>格式。这个<strong>name</strong>可以自定义，主要用于区分。<br>指定运行的环境：1.在<strong>application.properties</strong>或者<strong>application.yml</strong>文件中指定；2.运行jar的时候指定，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxx.jar --spring.profiles.active=<span class="built_in">test</span></span><br></pre></td></tr></table></figure><h1>知识点：</h1><p>1.@RequestMapping：对任意类型的请求都可以进行处理的。<br>如果想要修改springboot启动的banner可以：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1702014637534-970c4ea4-b5d2-4083-b646-0f5f88b8fbc0.png#averageHue=%23394358&amp;clientId=u0be32230-d55e-4&amp;from=paste&amp;height=99&amp;id=u1067a1df&amp;originHeight=124&amp;originWidth=925&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=71568&amp;status=done&amp;style=none&amp;taskId=u4ca5a637-481d-4fda-a134-659afadc6a4&amp;title=&amp;width=740" alt="image.png"></p><h1><a href="https://www.cnblogs.com/caoweixiong/p/15325382.html">Spring boot——Actuator 详解</a>：</h1><p><a href="https://cloud.tencent.com/developer/article/1489997">Springboot actuator使用详解 -腾讯云开发者社区-腾讯云</a></p><h1>Spring Boot Admin ：</h1><p><a href="https://cloud.tencent.com/developer/article/1923688">Spring Boot Admin 2.0 详解-腾讯云开发者社区-腾讯云</a><br>Spring Boot Admin ：是一种监控技术</p><h1>CommandLineRunner和order注解：</h1><p><a href="https://blog.csdn.net/weixin_45433031/article/details/126884328">ApplicationRunner、CommandLineRunner+@order注解学习-CSDN博客</a><br>1.ApplicationRunner和CommandLineRunner：<br>是一个接口，常用于项目启动后，（也就是ApringApplication.run()执行结束），立马执行某些逻辑。<br>可用于项目的准备工作，比如加载配置文件，加载执行流，<a href="https://so.csdn.net/so/search?q=%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1&amp;spm=1001.2101.3001.7020">定时任务</a>等等。<br>2.ApplicationRunner和CommandLineRunner：接口中的run方法都是容器启动后执行的逻辑，其run方法执行的顺序和bean加载的顺序一致，可以通过order注解来实现bean加载的顺序。<br>3.ApplicationRunner中run方法的参数是：ApplicationArguments，其可以获取到当前项目执行的命令参数；而CommandLineRunner接口中run方法的参数是<a href="https://so.csdn.net/so/search?q=String%E6%95%B0%E7%BB%84&amp;spm=1001.2101.3001.7020">String数组</a>；<br>4.注入容器中的bean如果没有指定order那么默认为优先级最低的。</p><h1>Springboot中实现定时任务：</h1><p><a href="https://cloud.tencent.com/developer/article/1445905">Spring Boot 实现定时任务的 4 种方式-腾讯云开发者社区-腾讯云</a></p><h1>Docker整合Springboot:</h1><p>1.在pom中导入Docker依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Docker maven plugin --&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;imageName&gt;<span class="variable">$&#123;docker.image.prefix&#125;</span>/<span class="variable">$&#123;project.artifactId&#125;</span>&lt;/imageName&gt;</span><br><span class="line">&lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;resource&gt;</span><br><span class="line">&lt;targetPath&gt;/&lt;/targetPath&gt;</span><br><span class="line">&lt;directory&gt;<span class="variable">$&#123;project.build.directory&#125;</span>&lt;/directory&gt;</span><br><span class="line">&lt;include&gt;<span class="variable">$&#123;project.build.finalName&#125;</span>.jar&lt;/include&gt;</span><br><span class="line">&lt;/resource&gt;</span><br><span class="line">&lt;/resources&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;!-- Docker </span><br></pre></td></tr></table></figure><p>2.编写Dockerfiler:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jdk-alpine</span><br><span class="line">VOLUME /tmp</span><br><span class="line">ADD spring-boot-docker-1.0.jar app.jar</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-Djava.security.egd=file:/dev/./urandom&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app.jar&quot;</span>]</span><br></pre></td></tr></table></figure><p>注意上面的spring-boot-docker-1.0.jar的位置，上面的&quot;-Djava.security.egd=file:/dev/./urandom&quot;,是一个Java命令行参数，用于设置Java安全随机数生成器（SecureRandom）使用的随机源。  在这个参数中，“file:/dev/./urandom&quot;表示使用系统的随机设备文件作为随机源。”/dev/./urandom&quot;是Linux系统中的随机设备文件，它可以提供高质量的随机数据。  这个参数的作用是确保Java应用程序在启动时使用足够的随机数据来初始化SecureRandom对象，以增强应用程序的安全性。</p><h1>springboot中elasticsearch：</h1><p><a href="https://blog.csdn.net/qq_45297578/article/details/116273017">【SpringBoot高级篇】SpringBoot集成Elasticsearch搜索引擎_springboot集成elasticsearch 生成索引-CSDN博客</a></p><h1>文件上传：</h1><p><a href="https://github.com/search?q=springboot%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0&amp;type=repositories&amp;s=&amp;o=desc&amp;p=1">https://github.com/search?q=springboot%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0&amp;type=repositories&amp;s=&amp;o=desc&amp;p=1</a>差一个项目</p><h1>JPA：</h1><p><a href="https://springdoc.cn/spring-data-jpa/">Spring Data JPA 中文文档</a><br><a href="https://blog.csdn.net/cmx1060220219/article/details/106259423">SpringBoot集成jpa 一篇就够了 超详细_springboot集成jpa切面-CSDN博客</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface UserRepository extends JpaRepository&lt;User, Long&gt; 中的</span><br><span class="line">JpaRepository&lt;User, Long&gt;中，User表示存储库中的实体类类型，Long表示实体类中的主键类型。</span><br><span class="line">因此，JpaRepository&lt;User, Long&gt;表示一个存储库，其中的实体类使用Long类型的主键.</span><br><span class="line">而上面的这个接口就是Dao层，在Service注入的就是上面的接口。但是上面的接口没有相关注解修饰</span><br><span class="line">，但是因为其继承了JpaRepository&lt;User, Long&gt;该接口被注入到容器中了。因此Service层中就可以</span><br><span class="line">自动注入该接口的bean。</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  @Query(<span class="string">&quot;select u from User u where u.emailAddress = ?1&quot;</span>)</span><br><span class="line">  User findByEmailAddress(String emailAddress);</span><br><span class="line">&#125;上面的?1表示用下面方法中的第一个参数代替。</span><br></pre></td></tr></table></figure><p>JPA的配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据库连接的配置</span></span><br><span class="line">spring.datasource.url=jdbc:mysql://192.168.44.130:3306/test?serverTimezone=UTC&amp;useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf-8&amp;useSSL=<span class="literal">true</span></span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line"><span class="comment"># jpa的配置，hibernate.hbm2ddl.auto：create，</span></span><br><span class="line"><span class="comment"># 表示每次启动时都重新创建数据库表结构（慎用，会清空原有数据）</span></span><br><span class="line"><span class="comment"># hibernate.dialect：org.hibernate.dialect.MySQL5InnoDBDialect，表示使用MySQL数据库的</span></span><br><span class="line"><span class="comment"># InnoDB方言</span></span><br><span class="line"><span class="comment"># show-sql：true，表示在控制台上显示生成的SQL语句</span></span><br><span class="line"><span class="comment"># format_sql：true，表示格式化生成的SQL语句，使其更易读</span></span><br><span class="line">spring.jpa.properties.hibernate.hbm2ddl.auto=create</span><br><span class="line">spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect</span><br><span class="line"><span class="comment">#sql\u8F93\u51FA</span></span><br><span class="line">spring.jpa.show-sql=<span class="literal">true</span></span><br><span class="line"><span class="comment">#format\u4E00\u4E0Bsql\u8FDB\u884C\u8F93\u51FA</span></span><br><span class="line">spring.jpa.properties.hibernate.format_sql=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>JPA多数据源：<a href="https://www.cnblogs.com/daimenglaoshi/p/16953667.html">https://www.cnblogs.com/daimenglaoshi/p/16953667.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.多数据源要可以在配置文件写多个连接数据库的连接配置</span><br><span class="line">2.DataSourceConfig配置类要注入2个数据源，且这2个数据源的配置文件的前缀不一样，bean的名称也不一样</span><br><span class="line">3.DataSourceConfig实现的是将2个根据配置文件生成的不同配置源注入到容器中</span><br><span class="line">4.分别写2个数据源的配置文件，表名每个数据源所关联的Dao层和实体类</span><br><span class="line">5.在控制层注入不同的Dao就实现了采用不同的数据源访问数据库了</span><br><span class="line">6.</span><br></pre></td></tr></table></figure><p>JPA常见的数据库关系：<a href="https://niocoder.com/2018/02/28/JPA%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84%E7%B3%BB%E5%88%97%E4%B8%80-one-to-one%E5%A4%96%E9%94%AE%E5%85%B3%E8%81%94/#%E5%87%86%E5%A4%87">JPA关系映射系列一：one-to-one外键关联</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@OneToOne(cascade = CascadeType.ALL)</span><br><span class="line">@JoinColumn(name = <span class="string">&quot;book_detail_id&quot;</span>)</span><br><span class="line">// @Lazy(<span class="literal">false</span>)</span><br><span class="line">private BookDetail bookDetail</span><br><span class="line">@OneToOne(cascade = CascadeType.ALL)：这是一个注解，表示这个字段与另一个实体类的字段之间建</span><br><span class="line">立了一对一的关联关系。CascadeType.ALL表示级联操作，即当对该实体进行操作时，也会对关联的实体</span><br><span class="line">进行相同的操作。</span><br><span class="line"></span><br><span class="line">@JoinColumn(name = <span class="string">&quot;book_detail_id&quot;</span>)：这是一个注解，表示指定关联的外键列的名称。在数据库中</span><br><span class="line">，这个字段将被用作与关联实体的主键进行关联的外键列。</span><br><span class="line"></span><br><span class="line">private BookDetail bookDetail：这个字段表示关联的另一个实体类的对象。在这个例子中，</span><br><span class="line">它表示与Book实体关联的BookDetail实体。</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@OneToOne(mappedBy = <span class="string">&quot;bookDetail&quot;</span>)</span><br><span class="line">    private Book book;</span><br><span class="line">@OneToOne(mappedBy = <span class="string">&quot;bookDetail&quot;</span>)：这是一个注解，表示这个字段与另一个实体类的字段之</span><br><span class="line">间建立了一对一的关联关系。通过<span class="string">&quot;mappedBy&quot;</span>属性指定了与之关联的另一个实体类的字段名，</span><br><span class="line">这里是<span class="string">&quot;bookDetail&quot;</span>，表示该关联关系由Book实体类中的<span class="string">&quot;bookDetail&quot;</span>字段来维护。</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@TableGenerator(</span><br><span class="line">name = <span class="string">&quot;AppSeqStore&quot;</span>,</span><br><span class="line">table = <span class="string">&quot;APP_SEQ_STORE&quot;</span>,</span><br><span class="line">pkColumnName = <span class="string">&quot;APP_SEQ_NAME&quot;</span>,</span><br><span class="line">pkColumnValue = <span class="string">&quot;LISTENER_PK&quot;</span>,</span><br><span class="line">valueColumnName = <span class="string">&quot;APP_SEQ_VALUE&quot;</span>,</span><br><span class="line">initialValue = 10000,</span><br><span class="line">allocationSize = 1 )</span><br><span class="line">@GeneratedValue( strategy = GenerationType.TABLE, generator = <span class="string">&quot;AppSeqStore&quot;</span> )</span><br><span class="line">private long <span class="built_in">id</span>;</span><br><span class="line">@TableGenerator：这是一个注解，用于定义一个表生成器，用于生成主键的值。它具有以下属性：</span><br><span class="line">name：生成器的名称，用于关联到`@GeneratedValue这段代码是用于生成实体类中的主键（ID）的配置。</span><br><span class="line">以下是对代码的解释：</span><br><span class="line"></span><br><span class="line">@TableGenerator：这是一个注解，用于定义一个表生成器，用于生成主键的值。它具有以下属性：</span><br><span class="line"></span><br><span class="line">name：生成器的名称，用于关联到@GeneratedValue注解中的generator属性。</span><br><span class="line">table：生成器使用的数据库表的名称。</span><br><span class="line">pkColumnName：指定存储主键名称的列的名称。</span><br><span class="line">pkColumnValue：指定存储主键值的列的值。</span><br><span class="line">valueColumnName：指定存储下一个可用主键值的列的名称。</span><br><span class="line">initialValue：指定生成器的初始值。</span><br><span class="line">allocationSize：指定每次从数据库中获取的主键值的数量。</span><br><span class="line">@GeneratedValue：这是一个注解，用于指定生成主键值的策略。在这个例子中，使用GenerationType.TABLE作为主键生成策略，并将生成器的名称设置为AppSeqStore，与@TableGenerator中的name属性对应。</span><br><span class="line"></span><br><span class="line">private long <span class="built_in">id</span>：这个字段表示实体类的主键（ID），通过以上配置的表生成器来生成主键值。</span><br></pre></td></tr></table></figure><h1>springboot发送邮箱：</h1><p><a href="https://blog.csdn.net/qq_26383975/article/details/121957917">Springboot实现发送邮件功能-CSDN博客</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.发送邮件需要知道邮件的发送者和接收者，而发送者和接受者可以在spring项目的配置文件中配置也可以</span><br><span class="line">通过前端传递过来。</span><br><span class="line">2.邮件发送靠的是spring中的JavaMailSenderImpl实例来实现的，这个实例已经注入到容器中了；可以通过</span><br><span class="line"> @Autowired注解来使用</span><br><span class="line"> 3.如果发送的邮件是复杂类型则需要借助MimeMessageHelper类来实现，这个类可以配置发送者，接受者</span><br><span class="line"> ，主题，内容（其中的内容可以是html，text),附件地址。MimeMessageHelper接受一个MimeMessage对象</span><br><span class="line"> 的参数</span><br></pre></td></tr></table></figure><h1>Spring Boot 集成 Memcached：</h1><p><a href="https://blog.csdn.net/qq_39052513/article/details/109893782">Spring Boot 集成 Memcached_springboot 继承 memcached-CSDN博客</a></p><h1>Spring boot集成mongodb：</h1><p><a href="https://blog.csdn.net/weixin_47343544/article/details/127175205">https://blog.csdn.net/weixin_47343544/article/details/127175205</a></p><h1>Springboot和mybatis:</h1><p>其实mybatis可以不用写mapper.xml文件，而是直接通过注解在方法名前写sql语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Select(<span class="string">&quot;SELECT * FROM users&quot;</span>)</span><br><span class="line">@Results(&#123;</span><br><span class="line">@Result(property = <span class="string">&quot;userSex&quot;</span>,  column = <span class="string">&quot;user_sex&quot;</span>, javaType = UserSexEnum.class),</span><br><span class="line">@Result(property = <span class="string">&quot;nickName&quot;</span>, column = <span class="string">&quot;nick_name&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">List&lt;User&gt; getAll();</span><br><span class="line"> 上面的@Results是把查询的结果集映射到那种实体上；</span><br><span class="line"> @Result(property = <span class="string">&quot;userSex&quot;</span>,  column = <span class="string">&quot;user_sex&quot;</span>, javaType = UserSexEnum.class)</span><br><span class="line"> 中的含义是将查询表中的user_sex列和User类的userSex属性关联，至于为什么是user类是因为该方法</span><br><span class="line"> 的返回值是一个User的List；而后面的javaType意思是映射的属性userSex为UserSexEnum类型的</span><br></pre></td></tr></table></figure><p>整合多数据源：<br>1.整合数据源一定，可以设置特定的配置类来实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@MapperScan(basePackages = <span class="string">&quot;com.neo.mapper.test2&quot;</span>, sqlSessionTemplateRef  = <span class="string">&quot;test2SqlSessionTemplate&quot;</span>)</span><br><span class="line">上面的代码是该配置类是处理com.neo.mapper.test2接口的； sqlSessionTemplateRef表示该</span><br><span class="line">接口中使用的sqlSessionTemplate来源是什么；其中的sqlSessionTemplate是对sqlSsion进行封装的；</span><br><span class="line">其中的SqlSession是 是 MyBatis 中用于执行 SQL 语句的主要接口；</span><br><span class="line">sqlSessionTemplateRef  = <span class="string">&quot;test2SqlSessionTemplate”表示将容器中的test2SqlSessionTemplate实例</span></span><br><span class="line"><span class="string">作为com.neo.mapper.test2该接口的sqlSessionTemplate；</span></span><br><span class="line"><span class="string">sqlSessionTemplate的产生需要SqlSessionFactory的；所以我们需要在容器中注入SqlSessionFactory；</span></span><br><span class="line"><span class="string">我们在sql操作中常进行事务操作，我们应该在配置类中配置事务管理器：DataSourceTransactionManager ；</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>2.h2数据库</p><h1>springboot的打包jar包和war包的区别：</h1><p><a href="https://cloud.tencent.com/developer/article/2081558">SpringBoot项目打成war和jar的区别「建议收藏」-腾讯云开发者社区-腾讯云</a><br>1.jar包可以直接通过java -jar 项目名.jar的方式运行，不依赖外部 Servlet 容器；而war包的必须将应用部署到传统的 Servlet 容器时，如 Tomcat、Jetty 等，才能运行。<br>2.spring项目选择打成了war包可以直接通过springboot启动，这个时候使用的是springboot项目内置的容器（常为tomcat);这个运行的端口是根据项目的配置文件来决定的；当我们把war包放进一个新的tomcat容器中时，这个时候的端口不由配置文件决定而是用新的tomcat设置的端口决定。<br>3.打成war包的方法：<br><strong>修改pom.xml文件：</strong><br>在项目的 <strong>pom.xml</strong> 文件中，确保以下配置项的存在或根据需要进行修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong><packaging>war</packaging></strong> 表示你将打包成 WAR 文件。</li><li><strong><dependency></strong> 部分中，<strong>spring-boot-starter-tomcat</strong> 的 <strong><scope></strong> 设置为 <strong>provided</strong>，表示这个依赖在编译和运行时由 Servlet 容器提供，而不是包含在 WAR 文件中。</li></ul><p><strong>修改主应用类：</strong><br>如果你的应用的主类继承了 <strong>SpringBootServletInitializer</strong>，确保它的 <strong>configure</strong> 方法被正确地重写。如果还没有重写，可以添加如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line">import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;</span><br><span class="line"></span><br><span class="line">public class YourApplication extends SpringBootServletInitializer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123;</span><br><span class="line">        <span class="built_in">return</span> application.sources(YourApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>springboot和redis:</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public KeyGenerator <span class="function"><span class="title">keyGenerator</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> new <span class="function"><span class="title">KeyGenerator</span></span>() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object generate(Object target, Method method, Object... params) &#123;</span><br><span class="line">                StringBuilder sb = new StringBuilder();</span><br><span class="line">                sb.append(target.getClass().getName());</span><br><span class="line">                sb.append(method.getName());</span><br><span class="line">                <span class="keyword">for</span> (Object obj : params) &#123;</span><br><span class="line">                    sb.append(obj.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">return</span> sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面是一个缓存键的生成策略</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(value=<span class="string">&quot;user-key&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>@Cacheable</strong> 注解被用于某个方法，并指定了一个缓存的名称为 <strong>“user-key”</strong>。但是其缓存键不是这个，</p><h1>定时任务：</h1><p><a href="https://cloud.tencent.com/developer/article/1968344">SpringBoot实现定时任务的三种方式，总有一款适合你！-腾讯云开发者社区-腾讯云</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Scheduled(cron=<span class="string">&quot;*/6 * * * * ?&quot;</span>)</span><br><span class="line">Cron表达式参数分别表示：秒，分，时，日，月，周几，年，？表示无特定值，什么都可以</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Scheduled(fixedRate = 6000)</span><br><span class="line">fixedRate表示固定间隔时间执行，单位为毫秒，1000毫秒为1秒</span><br></pre></td></tr></table></figure><h1>springboot+Swaager:</h1><h1>Webflux:</h1><p><a href="https://blog.csdn.net/crazymakercircle/article/details/112977951">webflux + springboot 整合（史上最全）_spring boot集成webflux-CSDN博客</a><br><a href="https://www.cnblogs.com/crazymakercircle/p/16127013.html">https://www.cnblogs.com/crazymakercircle/p/16127013.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(<span class="string">&quot;/hello&quot;</span>)</span><br><span class="line">   public Mono&lt;String&gt; <span class="function"><span class="title">hello</span></span>() &#123;</span><br><span class="line">       <span class="built_in">return</span> Mono.just(<span class="string">&quot;Welcome to reactive world ~&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>Mono：实现发布者，并返回 0 或 1 个元素，即单对象</li><li>Flux：实现发布者，并返回 N 个元素，即 List 列表对象</li></ul>]]></content>
    
    
      
      
    <summary type="html"> &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ityouknow/spring-boot-examples&quot;&gt;https://github.com/ityouknow/sp</summary>
      
    
    
    
    <category term="springboot2" scheme="http://www.bojiboqi.fun/categories/springboot2/"/>
    
    
    <category term="springboot2" scheme="http://www.bojiboqi.fun/tags/springboot2/"/>
    
    <category term="项目" scheme="http://www.bojiboqi.fun/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.bojiboqi.fun/2024/01/26/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%EF%BC%9A/"/>
    <id>http://www.bojiboqi.fun/2024/01/26/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%EF%BC%9A/</id>
    <published>2024-01-26T11:11:35.890Z</published>
    <updated>2024-01-26T11:12:28.852Z</updated>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h5 id="1-网关：">1.网关：</h5><p><a href="https://www.itheima.com/news/20211130/153644.html">网关是什么意思？3分钟了解网关的作用</a><br>是一种网间连接器，协议转换器，**它是信息从一个网络发往另一个网络需经过的一道“关口”。**仅用于两个高层协议不同的网络互联。<br>如果网络A中的主机发现数据包的目的地址不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某台主机。假设网络A的IP地址范围为“192.168.1.1~192.168.1.254”，子网掩码为255.255.255.0;网络B的IP地址范围为“192.168.2.1~192.168.2.254”,子网掩码为255.255.255.0，那么网络A向网络B发送数据包的过程如下图所示。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700194845233-5198e879-64d8-41e7-81ac-57c7f55cff70.png#averageHue=%23faf9f9&amp;clientId=u3b084d49-ee67-4&amp;from=paste&amp;height=322&amp;id=u0f6f2455&amp;originHeight=403&amp;originWidth=821&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=118902&amp;status=done&amp;style=none&amp;taskId=u82529152-0ca1-411e-aa0c-5d460ac4ebd&amp;title=&amp;width=656.8" alt="image.png"><br>（上图中的255.255.255.0是掩码地址）<br>网关的IP地址是用来实现不同网络之间的通信的。网关是一种网络设备，它可以将数据包从一个网络转发到另一个网络中的设备。网关的IP地址就是它的网络接口的地址，它用于标识网关在网络中的位置。网关的IP地址可以是任意的，只要符合IP地址的分配规则就行。但是为了方便管理和区分，一般会将一个网段的第一个或最后一个IP地址作为网关的IP地址。</p><h5 id="2-域名和域名查询：">2.域名和域名查询：</h5><p><a href="https://www.cnblogs.com/crazylqy/p/7110357.html">一张图看懂DNS域名解析全过程 - crazyYong - 博客园</a><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1700195208909-17d6aae4-083c-4957-9232-bbfc7e155bc4.jpeg#averageHue=%23dcdfb5&amp;clientId=u3b084d49-ee67-4&amp;from=paste&amp;id=ua2fd401b&amp;originHeight=713&amp;originWidth=1029&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uec578ac1-ac87-40d2-8485-7fd5b220f9b&amp;title=" alt=""></p><h5 id="HTTP-304状态码的详细讲解：">HTTP 304状态码的详细讲解：</h5><p>自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容（因为浏览器缓存了上次请求的内容，外加网页没有修改）。</p><h5 id="get和post的区别：">get和post的区别：</h5><ul><li>GET请求是用来从服务器获取数据的，而POST请求是用来向服务器发送数据的。GET请求的参数会附加在URL后面，而POST请求的参数会放在请求体中。</li><li>GET请求的参数有长度限制，一般不能超过2048个字符，而POST请求的参数没有长度限制。GET请求的参数只能是ASCII字符，而POST请求的参数可以是任意类型的数据。</li><li>GET请求可以被缓存、收藏为书签、保存在浏览器历史记录中，而POST请求不会。GET请求在回退和刷新时不会有影响，而POST请求可能会导致数据被重复提交。</li><li>GET请求相对于POST请求更不安全，因为参数会暴露在URL中，可能会泄露敏感信息。POST请求相对于GET请求更安全，因为参数不会显示在URL中。</li><li>GET请求和POST请求的语义不同，GET请求一般用于获取资源，而POST请求一般用于创建或修改资源。</li><li>GET请求参数只支持ASCLL字符集（这也说明get只支持字符串参数，而post可以支持各种类型的参数，这同时也说明get请求中不能传递中文，如果要传递中文，需要对url进行额外的编码操作），其中URL中用?分割请求地址和参数列表，参数是键值对形式，每对键值对用&amp;分割开。</li><li></li></ul><p><a href="https://cloud.tencent.com/developer/article/1529973">GET方法传递中文参数乱码解决办法-腾讯云开发者社区-腾讯云</a></p><h5 id="servlet和servlet容器：">servlet和servlet容器：</h5><p><a href="https://blog.csdn.net/lz233333/article/details/68065749">理解Servlet和Servlet容器、Web服务器等概念-CSDN博客</a></p><h6 id="他们之间的关系：">他们之间的关系：</h6><p>1.servlet是运行在servlet容器中的小程序，由Servlet容器所管理，用于生成动态的内容。Servlet没有main方法，不能独立运行，它必须被部署到Servlet容器中，由容器来实例化和调用 Servlet的方法（如doGet()和doPost()），Servlet容器在Servlet的生命周期内包括生成和管理Servlet。有了servlet之后，用户通过单击某个链接或者直接在浏览器的地址栏中输入URL来访问Servlet，Web服务器接收到该请求后，并不是将 请求直接交给Servlet，而是交给Servlet容器。Servlet容器实例化Servlet，调用Servlet的一个特定方法对请求进行处理， 并产生一个响应。这个响应由Servlet容器返回给Web服务器，Web服务器包装这个响应，以HTTP响应的形式发送给Web浏览器。</p><h6 id="servlet容器的作用：">servlet容器的作用：</h6><p>1.通信支持:利用容器提供的方法，你能轻松的让servlet与web服务器对话，而不用自己建立serversocket、监听某个端口、创建流等 等。</p><h6 id="2-常见的servlet容器：tomcat">2.常见的servlet容器：tomcat</h6><p>Tomcat服务器接受客户请求并做出响应的过程如下：<br>1）客户端（通常都是浏览器）访问Web服务器，发送HTTP请求。<br>2）Web服务器接收到请求后，传递给Servlet容器。<br>3）Servlet容器加载Servlet，产生Servlet实例后，向其传递表示请求和响应的对象。<br>4）Servlet实例使用请求对象得到客户端的请求信息，然后进行相应的处理。<br>5）Servlet实例将处理结果通过响应对象发送回客户端，容器负责确保响应正确送出，同时将控制返回给Web服务器。</p><h6 id="servlet生命周期：">servlet生命周期：</h6><p><a href="https://juejin.cn/post/7147162584137859108">Servlet 的生命周期，什么是cookie，Session的详细解析，servletContext对象的详细解析 - 掘金</a><br><img src="https://cdn.nlark.com/yuque/0/2023/webp/28066124/1700201967861-0e3bffd7-f786-40d8-bc9b-f87c6083ce7f.webp#averageHue=%23fafafa&amp;clientId=u3b084d49-ee67-4&amp;from=paste&amp;id=u2d8dd9cc&amp;originHeight=676&amp;originWidth=1512&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4ff7aea7-5476-4904-94b5-3a3985f3f82&amp;title=" alt=""><br>1.init()<br>init方法设计为只调用一次。如果servlet的实例不存在，则Web容器：<br>加载servlet类<br>创建servlet类的实例<br>通过调用init方法初始化它<br>init方法必须成功完成之后，servlet才能接收任何请求。如果init方法抛出ServletException或在Web服务器定义的时间段内未返回，servlet容器将无法将servlet放入服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="comment">// Initialization code like set up database etc....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.service()<br>此方法仅在servlet的init（）方法成功完成后调用。<br>Container调用service（）方法来处理来自客户端的请求，解释HTTP请求类型（GET、POST、PUT、DELETE等）并酌情调用doGet、doPost、doput、doDelete等方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest request, ServletResponse response)</span> </span><br><span class="line">  <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>destroy()</li></ol><p>由Servlet容器调用以使Servlet退出服务。<br>此方法仅在servlet的服务方法中的所有线程都退出或超时后调用。容器调用此方法后，不会在Servlet上再次调用服务方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="servlet实践：">servlet实践：</h6><p><a href="https://www.cnblogs.com/xuwc/p/13991809.html">spring-Servlet/Tomcat/Spring - 秦羽的思考 - 博客园</a>(重要较难）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700204213622-a5f6b128-f463-463d-b576-eb9d9325baab.png#averageHue=%23e7c48d&amp;clientId=u14ed016d-7def-4&amp;from=paste&amp;height=251&amp;id=u9b4d4163&amp;originHeight=314&amp;originWidth=667&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=29108&amp;status=done&amp;style=none&amp;taskId=u06d79a7f-58f0-4fdc-8580-d9fb2fb258c&amp;title=&amp;width=533.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700204216495-f638fb78-c0bd-4683-9ab1-ea6ccfbc7ea3.png#averageHue=%2321221f&amp;clientId=u14ed016d-7def-4&amp;from=paste&amp;height=125&amp;id=u769039da&amp;originHeight=156&amp;originWidth=384&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=19420&amp;status=done&amp;style=none&amp;taskId=u0dd1e5b9-07a3-463b-ae29-b0fe157a1f9&amp;title=&amp;width=307.2" alt="image.png"></p><h5 id="serveltContext">serveltContext:</h5><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1700204599469-ffc6e277-8ddc-48c1-b916-d80d748263ce.jpeg#averageHue=%23faf9f8&amp;clientId=u14ed016d-7def-4&amp;from=paste&amp;id=uf370d912&amp;originHeight=849&amp;originWidth=1520&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u0ab560b1-b4e5-4f98-9091-e8f8fa3192b&amp;title=" alt=""><br>你可以把它想象成一个公用的空间，可以被所有的客户访问，也就是说A客户端可以访问D，B客户端可以访问D，C客户端也可以访问D。<br>WEB容器在启动时，它会为每个Web应用程序都创建一个对应的ServletContext，它代表当前Web应用。并且它被所有客户端共享。<br>ServletContext对象可以通过ServletConfig.getServletContext()方法获得对ServletContext对象的引用，也可以通过this.getServletContext()方法获得其对象的引用。<br>由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为context域对象。公共聊天室就会用到它。<br>当web应用关闭、Tomcat关闭或者Web应用reload的时候，ServletContext对象会被销毁<br>l练习：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700204615594-2b427ada-8b10-4522-a70a-9ea5e3eb9d67.png#averageHue=%23fefdfc&amp;clientId=u14ed016d-7def-4&amp;from=paste&amp;height=285&amp;id=u87d516e9&amp;originHeight=356&amp;originWidth=918&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=32572&amp;status=done&amp;style=none&amp;taskId=u4b13422f-df8c-4e10-8c70-86f9df1ffce&amp;title=&amp;width=734.4" alt="image.png"></p><h5 id="sessionStorage-、localStorage-和-cookie-之间的区别">sessionStorage 、localStorage 和 cookie 之间的区别</h5><p><a href="https://juejin.cn/post/6844903713098694664">sessionStorage 、localStorage 和 cookie 之间的区别 - 掘金</a></p><h5 id="html知识点：">html知识点：</h5><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700205658192-5e94b6ed-db2d-4a02-99ee-c2f3e7330d38.png#averageHue=%23fefefd&amp;clientId=u14ed016d-7def-4&amp;from=paste&amp;height=272&amp;id=u1083fb3b&amp;originHeight=340&amp;originWidth=416&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=14726&amp;status=done&amp;style=none&amp;taskId=u0db03197-f0b5-40f0-93b2-915cc776ec3&amp;title=&amp;width=332.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700205776261-18a3aba0-275a-48b6-97d6-59087c3a94c7.png#averageHue=%23fefefd&amp;clientId=u14ed016d-7def-4&amp;from=paste&amp;height=262&amp;id=u80c9fc87&amp;originHeight=327&amp;originWidth=820&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=21516&amp;status=done&amp;style=none&amp;taskId=uf4157dd9-6290-4776-8eaa-c6d1124d560&amp;title=&amp;width=656" alt="image.png"></p><h5 id="JS知识点：">JS知识点：</h5><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700750535386-ebe77b78-8b6c-406a-9ec5-19c3061bbccb.png#averageHue=%23fefdfc&amp;clientId=u31d300d4-d8fe-4&amp;from=paste&amp;height=593&amp;id=u2bf67d9b&amp;originHeight=741&amp;originWidth=623&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=42614&amp;status=done&amp;style=none&amp;taskId=uf1c5a699-758c-4b7b-a2fd-4f4ce027930&amp;title=&amp;width=498.4" alt="image.png"><br>这是一个闭包问题，原因是：js脚本是从上往下执行的，每次循环都会为每个elements[i]元素绑定一个click事件处理函数该函数监听click事件。当元素被点击时，该事件处理函数会被调用，并且该函数会显示一个弹窗，内容是当前的i值。 所有的事件处理函数共享同一个i变量，因此它们都会显示循环结束后的i值。<br>闭包问题：<a href="https://juejin.cn/post/6844904174077870087">理解Js的闭包问题 - 掘金</a><br><a href="https://cloud.tencent.com/developer/article/1012622?areaSource=106002.5">JavaScript学习总结(三)——闭包、IIFE、原型、函数与对象-腾讯云开发者社区-腾讯云</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700753920325-bc7ca01b-e14b-4782-8e3f-00836c428c36.png#averageHue=%23fefdfd&amp;clientId=u31d300d4-d8fe-4&amp;from=paste&amp;height=277&amp;id=uf9d98854&amp;originHeight=346&amp;originWidth=536&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=17820&amp;status=done&amp;style=none&amp;taskId=ue1409026-7c29-4adc-8681-ebd2be42379&amp;title=&amp;width=428.8" alt="image.png"><br>上面的题目应该这样理解：js只有单线程，可以分为主线程和任务队列，主线程执行完后才从队列中拿出没有执行完的任务，这里的setTimeout就是把里面的任务放进任务队列中，而其他任务在主线程中。<br><a href="https://coolnuanfeng.github.io/javascriptRun">深入理解 Javascript 运行机制及原型</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">事件执行</span><br><span class="line">JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。</span><br><span class="line"></span><br><span class="line">单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，</span><br><span class="line">后一个任务就不得不一直等着。</span><br><span class="line"></span><br><span class="line">JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，</span><br><span class="line">先运行排在后面的任务。于是，所有任务可以分成两种，一种是同步任务（synchronous），</span><br><span class="line">另一种是异步任务（asynchronous）。</span><br><span class="line"></span><br><span class="line">因此Javascript运行机制可以简单理解成一个主线程（执行栈）和一个任务队列，脚本运行时</span><br><span class="line">先运行主线程，主线程运行完后，从”任务队列”中读取事件，运行任务队列的任务，这个过程是循环不断的</span><br><span class="line">，又称Event Loop（事件循环）。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1700754363644-c59d58a0-a651-4aa4-88dc-ee0b42f40a76.png#averageHue=%23fefefe&amp;clientId=u31d300d4-d8fe-4&amp;from=paste&amp;height=488&amp;id=ucae36bdb&amp;originHeight=610&amp;originWidth=817&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=42879&amp;status=done&amp;style=none&amp;taskId=ub3437b14-542e-4219-97d7-e2f2e355e1a&amp;title=&amp;width=653.6" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html"> &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h5 id=&quot;1-网关：&quot;&gt;1.网关：&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;https://www.itheima.com/news/20211130/153644.html&quot;&gt;网关是什么</summary>
      
    
    
    
    
    <category term="零散知识点" scheme="http://www.bojiboqi.fun/tags/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>javafx</title>
    <link href="http://www.bojiboqi.fun/2024/01/26/javaFX/"/>
    <id>http://www.bojiboqi.fun/2024/01/26/javaFX/</id>
    <published>2024-01-26T11:09:54.110Z</published>
    <updated>2024-01-26T11:10:32.539Z</updated>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><p><a href="https://openjfx.cn/">JavaFX中文官方网站</a><br><a href="https://blog.csdn.net/qq_45295475/article/details/125736509">全面详细的JavaFX国语核心教程（持续更新）_javafx教程_亻乍屯页女子白勺的博客-CSDN博客</a><br><a href="https://fxdocs.github.io/docs/html5/#_scene_graph">https://fxdocs.github.io/docs/html5/#_scene_graph</a></p>]]></content>
    
    
      
      
    <summary type="html"> &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://openjfx.cn/&quot;&gt;JavaFX中文官方网站&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;https://blog.csdn.net/qq_452954</summary>
      
    
    
    
    
    <category term="javafx" scheme="http://www.bojiboqi.fun/tags/javafx/"/>
    
  </entry>
  
  <entry>
    <title>周记</title>
    <link href="http://www.bojiboqi.fun/2024/01/26/day1_/"/>
    <id>http://www.bojiboqi.fun/2024/01/26/day1_/</id>
    <published>2024-01-26T11:08:04.470Z</published>
    <updated>2024-01-26T11:09:05.740Z</updated>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id="1-SpringBoot项目的搭建：">1.SpringBoot项目的搭建：</h2><h4 id="项目介绍：">项目介绍：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688027568791-f55ba44c-eec5-48a2-b3da-8c38a2e16a69.png#averageHue=%23eae8e7&amp;clientId=ucabb86a5-8dff-4&amp;from=paste&amp;height=562&amp;id=u5ff7ad24&amp;originHeight=703&amp;originWidth=1365&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=176982&amp;status=done&amp;style=none&amp;taskId=ua6f0773f-df4b-47f7-b722-6f2d9f3f02c&amp;title=&amp;width=1092" alt="image.png"></p><h4 id="添加依赖包的介绍：">添加依赖包的介绍：</h4><p>Spring Boot DevTools依赖包的介绍<br>Spring Boot DevTools 是 Spring Boot 中一个非常实用的开发工具，它提供了许多方便开发的功能，例如自动重启、自动显示错误页面、自动刷新等。DevTools 是一个可选的依赖，可以通过在 pom.xml 文件中添加依赖来引入。<br>具体来说，添加 Spring Boot DevTools 依赖的方法如下：<br>xml<br>Copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这个依赖包含了许多实用的工具类和功能，例如：</p><ul><li>自动重启：在修改代码后，可以自动重新启动应用程序，从而减少开发过程中的重复操作。</li><li>自动显示错误页面：当出现错误时，可以自动显示错误页面，便于开发人员进行排查和调试。</li><li>自动刷新：当修改了静态资源（例如 HTML、CSS、JavaScript）时，可以自动刷新页面，从而方便开发人员进行调试。</li><li>热部署：可以在运行时替换类文件，从而避免应用程序重启，提高开发效率。</li></ul><p>需要注意的是，Spring Boot DevTools 只适用于开发环境，不建议在生产环境中使用。此外，由于 DevTools 中包含了许多自动化功能，可能会影响应用程序的性能和稳定性，因此需要根据实际情况进行选择和配置。<br>Lombok依赖包<br>Lombok 是一个 Java 库，它提供了许多简化 Java 代码编写的功能，例如自动生成 getter/setter 方法、构造函数、equals 和 hashCode 方法等。Lombok 是一个可选的依赖，可以通过在 pom.xml 文件中添加依赖来引入。<br>具体来说，添加 Lombok 依赖的方法如下：<br>xml<br>Copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这个依赖包含了许多实用的注解和工具类，例如：</p><ul><li>@Getter 和 @Setter：自动生成属性的 getter/setter 方法。</li><li>@Data：自动生成属性的 getter/setter 方法、equals 和 hashCode 方法、toString 方法和无参构造函数。</li><li>@Builder：自动生成 Builder 模式的代码，用于构建复杂的对象。</li><li>@NoArgsConstructor 和 @AllArgsConstructor：自动生成无参和全参构造函数。</li><li>@Slf4j：自动生成日志记录器，可以使用 log 变量进行日志记录。</li></ul><p>需要注意的是，Lombok 通过注解来简化代码编写，但是这些注解并不是标准的 Java 注解，因此需要使用 Lombok 的插件来解析和编译这些注解。在使用 Lombok 时，需要在开发环境中安装 Lombok 插件，以便正确地解析和编译 Lombok 注解。<br>Spring Configuration Processor依赖包<br>Spring Configuration Processor 是一个用于处理 Spring Boot 应用程序的注解处理器，可以生成用于配置 Spring 应用程序的元数据。在使用 Spring Boot 2.2 及以上版本时，可以使用 Spring Configuration Processor 来生成配置元数据，从而提高应用程序的性能和可维护性。<br>要使用 Spring Configuration Processor，需要在项目的依赖中添加以下依赖项：<br>xml<br>Copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在这个依赖中，spring-boot-configuration-processor 是 Spring Configuration Processor 的实现依赖。optional 标记表示该依赖项是可选的，因为 Spring Configuration Processor 不是必需的依赖项。如果不需要使用 Spring Configuration Processor，则可以将该依赖项从项目中删除。<br>需要注意的是，Spring Configuration Processor 只能处理使用 Spring Boot 配置注解（例如 @ConfigurationProperties、@Value 等）的类，如果没有使用这些注解，则无法从中生成配置元数据。在使用 Spring Configuration Processor 时，应该遵循以下几个最佳实践：</p><ol><li>遵循 Spring Boot 的命名约定，例如将配置类命名为 application.properties 或 application.yml 中的属性名。</li><li>使用 @ConfigurationProperties 和 @Value 注解来标记配置类和属性，以便生成配置元数据。</li><li>在配置类和属性上添加必要的注释，以便生成的配置元数据具有可读性和可维护性。</li></ol><h4 id="创建配置文件：">创建配置文件：</h4><p>Spring boot 的配置文件主要用来配置项目的核心配置内容， 配置文件有两种格式一种事  .properties<br>的属性文件。  另一中是  .yml/.yaml 为后缀的  yaml 格式文件。<br>创建好springboot项目后默认会有一个属性配置文件：    application.properties<br>注意：两种配置文件只需要存在其中一种即可。    yml 格式的文件配置更加简洁明了，相较于属性<br>配置文件。</p><h6 id="属性配置文件：">属性配置文件：</h6><p>**# 修改服务器的默认端口号 **<br>server.port=8888</p><h1>修改一下项目的根路径</h1><p>server.servlet.context-path=/test<br>注意： 第一个等号左边是key , 右边是值， 不要在等号两边加空格。<br><strong>6.2 yaml 配置文件</strong><br>application.yml文件，全称是 YAML Ain’t Markup Language，它是以数据为中心的标记语言，比XML和<br>JSON更适合作为配置文件</p><h1>端口号    注意不同层级通过缩进来识别，    同一级要对齐，    属性和值之间必须用空格来分隔，    空格不能省</h1><p>server:<br>port: 9999<br>servlet:<br>   context-path: /demo（这里要求在项目文件下有demo文件）<br>同一级要左对齐， key和值之间需要一个空格， 不能省略，  key 的不同级使用缩进来表示<br>对于springboot的主配置文件名称必须是  application.properties 或者<br>application.yml/yaml .</p><h4 id="SpringMVC">SpringMVC:</h4><p>上面pom.xml里面导入 spring-boot-starter-web 就已经引入springmvc的环境了.<br>对应的依赖：</p><!--   springMVC 应用的依赖， 包含tomcat服务等的配置     --><dependency>   <groupId>org.springframework.boot</groupId>   <artifactId>spring-boot-starter-web</artifactId> </dependency>spring-boot-starter-web 是 Spring Boot 框架提供的一个 Starter 模块，用于构建基于 Web 的应用程序。它提供了一组常用的依赖项，例如 Spring MVC、Tomcat、Jackson 和 Spring Web 等，这些依赖项可以帮助开发人员快速构建 Web 应用程序。通过在 Maven 或 Gradle 项目中引入 spring-boot-starter-web Starter 模块，开发人员可以轻松地构建一个 Web 应用程序，并且不需要手动添加依赖项。此外，Spring Boot 还为该 Starter 模块提供了默认配置，以帮助开发人员快速启动应用程序，而无需进行复杂的配置。#### 表单提交请求流程：![image.png](https://cdn.nlark.com/yuque/0/2023/png/28066124/1688087188138-19666bb0-884c-4275-b365-c7a0c75cc802.png#averageHue=%23f2f0ef&clientId=ucabb86a5-8dff-4&from=paste&height=526&id=u1e5c2d90&originHeight=658&originWidth=1359&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=174427&status=done&style=none&taskId=ud813ea41-d14e-4d7c-b546-f4df6469bbf&title=&width=1087.2)#### 相关注解：###### @RestController@RestController 是 Spring Framework 中的一个注解，用于将一个类标记为 RESTful web 服务的控制器。与传统的 Spring MVC 控制器不同，使用 @RestController 注解的类会自动将返回值转换为 JSON 或 XML 格式，并将其写入 HTTP 响应。这意味着开发人员可以更轻松地构建 RESTful Web 服务，而无需手动编写代码来序列化和反序列化数据。当一个类使用 @RestController 注解时，Spring 会自动将其识别为一个控制器，并自动进行一些配置，例如将该类中的方法映射到相应的 URL 路径上。开发人员可以使用其他注解，例如 @GetMapping、@PostMapping、@PutMapping 和 @DeleteMapping 等来定义不同的请求方法，以及它们所处理的不同 URL。Spring Framework 的核心是 Spring IOC 容器，它是一个负责管理应用程序组件的容器。在 IOC 容器中，组件之间的依赖关系被自动注入，这使得开发人员可以更加专注于编写业务逻辑，而不需要处理组件之间的耦合度。[The Spring @Controller and @RestController Annotations | Baeldung](https://www.baeldung.com/spring-controller-vs-restcontroller)###### RESTful web 服务RESTful web 服务是一种基于 REST 架构风格的 Web 服务，它使用 HTTP 协议提供数据和功能，以便其他应用程序或客户端可以通过 HTTP 请求进行访问和使用。REST 是一种架构风格，它是 Representational State Transfer 的缩写，其中表述（Representational）指的是资源的表现形式，状态（State）指的是资源在某一时间点的状态，转移（Transfer）指的是客户端根据资源状态做出的一些行为。在 RESTful web 服务中，资源通常是通过 URL（统一资源定位符）来表示的，并且可以使用 HTTP 动词（GET、POST、PUT、DELETE 等）来定义对资源的操作。例如，可以使用 GET 请求来获取资源的状态，使用 POST 请求来创建资源，使用 PUT 请求来更新资源，使用 DELETE 请求来删除资源等。此外，RESTful web 服务通常使用 JSON 或 XML 等格式来表示数据。RESTful web 服务的优点包括可伸缩性、可重用性、可扩展性和可靠性等。它已成为构建 Web 服务的一种主流架构风格，并被广泛应用于各种 Web 应用程序和移动应用程序中。]]></content>
    
    
      
      
    <summary type="html"> &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h2 id=&quot;1-SpringBoot项目的搭建：&quot;&gt;1.SpringBoot项目的搭建：&lt;/h2&gt;
&lt;h4 id=&quot;项目介绍：&quot;&gt;项目介绍：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;htt</summary>
      
    
    
    
    
    <category term="零散知识点" scheme="http://www.bojiboqi.fun/tags/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>SSM学习总结</title>
    <link href="http://www.bojiboqi.fun/2024/01/26/SSM%E3%80%81/"/>
    <id>http://www.bojiboqi.fun/2024/01/26/SSM%E3%80%81/</id>
    <published>2024-01-26T11:07:01.787Z</published>
    <updated>2024-01-26T11:07:32.690Z</updated>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h1>Mybits:</h1><h4 id="mybits核心配置文件：">mybits核心配置文件：</h4><p>用于配置 MyBatis 的各种参数和属性，以及引入映射文件（Mapper）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!--&lt;!DOCTYPE&gt; 标签：声明了XML文档类型的声明，指定了使用的DTD(文档类型定义）文件的路径和版本。--&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;!--configuration 标签：MyBatis的配置文件必须以这个标签作为根标签，包含了所有的配置信息。--&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!--设置连接数据库的环境--&gt;</span><br><span class="line">&lt;!--environments 标签：用于配置 MyBatis 的环境，通过 default 属性指定默认的环境。</span><br><span class="line">environment 标签：定义了一个具体的环境，通过 id 属性指定环境的名称，id=test是测试环境，id是</span><br><span class="line">唯一标识不能重复。</span><br><span class="line">environments是一个复数标签，里面可以存放很多environment标签--&gt;</span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">&lt;!--transactionManager 标签：用于配置事务管理器（数据库操作的管理和实现，</span><br><span class="line">数据库领域，事务管理器通常是由数据库管理系统（DBMS）提供的服务，</span><br><span class="line">用于确保数据库操作的原子性、一致性、隔离性和持久性（ACID）。</span><br><span class="line">事务管理器提供了一种机制，使得多个数据库操作可以作为一个整体执行，</span><br><span class="line">而不是独立的操作，从而避免了数据不一致和丢失的问题。），这里使用的是 JDBC 事务管理器。--&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">            &lt;!--设置数据库连接--&gt;</span><br><span class="line">&lt;!--dataSource 标签：用于配置数据库连接池，这里使用的是 POOLED (mybits提供是数据池连接技术）</span><br><span class="line">数据源类型。--&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">&lt;!--property 标签：用于设置数据源的属性，包括数据库驱动、URL、用户名和密码等。--&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/myemployees?</span><br><span class="line">serverTimezone=UTC&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;A86789234&quot;/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line">   &lt;!--引入映射文件--&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;!--本配置文件和mappers文件是平行的，默认的当前目录下的mappers下的UserMapper--&gt;</span><br><span class="line">        &lt;mapper  resource=&quot;mappers/UserMapper.xml&quot;/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h4 id="mapper映射文件：">mapper映射文件：</h4><p>用于定义与用户（User）相关的数据库操作。这个映射文件使用了 MyBatis 的 XML 映射语言来定义 SQL 语句和数据库操作方法。映射文件写好后要和mybits的核心配置文件关联，通过<mapper>标签关联。当我们对数据库进行操作的时候，通过调用相关的mapper接口（与xml文件映射关联了的）中的方法，其中的方法通过xml映射文件关联，然后通过映射文件完成数据库的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;!--mapper 标签：MyBatis的映射文件必须以这个标签作为根标签，包含了所有的映射信息。</span><br><span class="line">namespace 属性：指定了映射器的命名空间，用于与其他映射器区分开来。--&gt;</span><br><span class="line">&lt;!--映射器：映射器（Mapper）是 MyBatis 框架中的一个组件，用于定义数据库操作和 SQL 语句与 Java 方法之间的映射关系。</span><br><span class="line">映射器将 Java 对象和数据库表之间的数据映射起来，将数据库操作封装成一个个方法，使得 Java 开发人员可以使用面向对象的方式操作数据库，</span><br><span class="line">而不需要编写大量的 SQL 语句。</span><br><span class="line">在 MyBatis 中，映射器通常是一个接口，其中的方法定义了对数据库的操作。映射器的具体实现由 MyBatis 框架自动生成，</span><br><span class="line">可以使用 XML 或者注解的方式来描述 SQL 语句以及与 Java 方法之间的映射关系--&gt;</span><br><span class="line">        &lt;mapper namespace=&quot;com.example.demo.mapper.UserMapper&quot;&gt;</span><br><span class="line">       &lt;!--int insertUser();insert 标签：定义了一个插入（Insert）操作的 SQL 语句，通过 id 属性指定操作的名称。--&gt;</span><br><span class="line">        &lt;insert id=&quot;InsertUser&quot;&gt;</span><br><span class="line">         insert into t_user values(&#x27;admin&#x27;,&#x27;123456&#x27;)</span><br><span class="line">      &lt;/insert&gt;</span><br><span class="line">        &lt;/mapper&gt;</span><br></pre></td></tr></table></figure><h4 id="测试数据库添加数据操作：在test文件中建立测试类">测试数据库添加数据操作：在test文件中建立测试类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//读取MyBatis的核心配置文件</span><br><span class="line">InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); </span><br><span class="line">//创建SqlSessionFactoryBuilder对象</span><br><span class="line">SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new </span><br><span class="line">SqlSessionFactoryBuilder();</span><br><span class="line">//通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象 </span><br><span class="line">SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); </span><br><span class="line">//创建SqlSession对象，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务 </span><br><span class="line">//SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">//创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交 </span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession(true); </span><br><span class="line">//通过代理模式创建UserMapper接口的代理实现类对象</span><br><span class="line">UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">//调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配 </span><br><span class="line">映射文件中的SQL标签，并执行标签中的SQL语句</span><br><span class="line">int result = userMapper.insertUser(); </span><br><span class="line">//上面可以不通过创建类来实现对sql的操作：</span><br><span class="line">// int result = sqlSession.insert(&quot;com.example.demo.mapper.UserMapper.InsertUser&quot;);</span><br><span class="line">sqlSession.commit();</span><br><span class="line">System.out.println(&quot;结果：&quot;+result);</span><br></pre></td></tr></table></figure><h4 id="添加日志功能：log4j4日志框架">添加日志功能：log4j4日志框架</h4><p>1.在pom文件中添加相关的依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;log4j&lt;/artifactId&gt; </span><br><span class="line">   &lt;version&gt;1.2.17&lt;/version&gt; </span><br><span class="line">&lt;/dependency</span><br></pre></td></tr></table></figure><p>选择的日志级别打印出来的是大于等于当前日志级别的信息。</p><h4 id="查询操作：">查询操作：</h4><p>设置程序的测试程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  public  void  selectUser() throws IOException &#123;</span><br><span class="line">    InputStream is =  Resources.getResourceAsStream(&quot;mybatis.config.xml&quot;);</span><br><span class="line">    SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new</span><br><span class="line">            SqlSessionFactoryBuilder();</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession(true);</span><br><span class="line">    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    User user = userMapper.getUserById();</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    sqlSession.close(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改UserMapper.xml文件<br>添加：查询的结果放在List<user>的时候其中的resultType不变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;getUserById&quot; resultType=&quot;com.example.demo.object.User&quot;&gt;</span><br><span class="line">        select  *from user where  id = 1</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;!--resultType:设置结果类型，即是查询结果的类型；resultMap：自定义映射，</span><br><span class="line">处理多对1或者1对多的映射关系--&gt;</span><br></pre></td></tr></table></figure><h4 id="获取参数的情况：">获取参数的情况：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688218734317-c8b32cba-caba-4a3e-85ec-135be182b45d.png#averageHue=%23efecde&amp;clientId=ub061bfe9-9d20-4&amp;from=paste&amp;height=73&amp;id=ua6f05f43&amp;originHeight=91&amp;originWidth=625&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=62494&amp;status=done&amp;style=none&amp;taskId=uddfba630-ba37-43b5-ba9b-b25b221df27&amp;title=&amp;width=500" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688219517886-1a40d78f-68af-4464-9413-c21f9674d09c.png#averageHue=%23ede9db&amp;clientId=ub061bfe9-9d20-4&amp;from=paste&amp;height=85&amp;id=u084a63b8&amp;originHeight=106&amp;originWidth=662&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=64138&amp;status=done&amp;style=none&amp;taskId=uac3440e7-d8c8-46d1-8d53-1473464335e&amp;title=&amp;width=529.6" alt="image.png"><br>之所以用arg0和arg1是因为当有多个参数的时候，底层会把参数储存到一个map集合中的，arg0和arg1分别对应传递过来的第一个参数和第二个参数。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688220154533-ffb0cb74-c2c9-46c7-bdd9-b1cf09d7938d.png#averageHue=%23efebdd&amp;clientId=ub061bfe9-9d20-4&amp;from=paste&amp;height=42&amp;id=ub2775b52&amp;originHeight=53&amp;originWidth=647&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=38063&amp;status=done&amp;style=none&amp;taskId=u5c80b38c-1536-48b6-85e3-68a114f8414&amp;title=&amp;width=517.6" alt="image.png"><br>相当于自己手动把数值放在map集合中了，访问的时候就用自己设置的键访问即可<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688220822207-5ee1466f-9eef-479a-9975-3a0000d923f7.png#averageHue=%23efece0&amp;clientId=ub061bfe9-9d20-4&amp;from=paste&amp;height=42&amp;id=u1fafbb68&amp;originHeight=52&amp;originWidth=718&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=47270&amp;status=done&amp;style=none&amp;taskId=ueac6e9f7-f54a-492d-8ff9-a22dd37c639&amp;title=&amp;width=574.4" alt="image.png"><br>因为底层将属性（get和set方法去掉get和set后的字符转小写组成的，当成员变量没有get和set方法的时候，不能当作属性）名和属性值通过map映射的，与上面的访问类似，直接在#{}括号中添加属性名即可。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688221370849-9b9d27ff-7562-4e22-8b11-a47007648023.png#averageHue=%23e5e4df&amp;clientId=ub061bfe9-9d20-4&amp;from=paste&amp;height=73&amp;id=ue4c60bfc&amp;originHeight=91&amp;originWidth=484&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=46966&amp;status=done&amp;style=none&amp;taskId=uac55351b-f70b-4405-8fe2-9f6dd41400a&amp;title=&amp;width=387.2" alt="image.png">相当于在底层的map中的键是直接设置Param注解的参数绑定的</p><h4 id="mybatis的查询：">mybatis的查询：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688226051068-fa423388-0538-4c3f-9bae-d6573c8b6f69.png#averageHue=%23f6f4eb&amp;clientId=ub061bfe9-9d20-4&amp;from=paste&amp;height=48&amp;id=u57b2519a&amp;originHeight=60&amp;originWidth=535&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=31220&amp;status=done&amp;style=none&amp;taskId=u3f373f8b-4593-4011-bc06-b4c795ebc60&amp;title=&amp;width=428" alt="image.png"><br>select count(age) user:查询的时候会把age列为null的值不算入count中。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688226539314-0e2239b3-1ea3-4496-85a8-b35048a4b1d1.png#averageHue=%23588988&amp;clientId=ub061bfe9-9d20-4&amp;from=paste&amp;height=84&amp;id=u498bfa18&amp;originHeight=105&amp;originWidth=498&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=13606&amp;status=done&amp;style=none&amp;taskId=u034aeca4-53cc-4b04-88c9-5e57462e5d5&amp;title=&amp;width=398.4" alt="image.png">这里的resultType实际上是别名是不区分大小写的，mybatis已经设置了常见类型的别名，这里的int和interger都可以而且不区分大小写。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688226653051-0e5fcb54-3b4d-41b0-9206-7f28f9329264.png#averageHue=%23fbfaf6&amp;clientId=ub061bfe9-9d20-4&amp;from=paste&amp;height=106&amp;id=uf1224bc8&amp;originHeight=132&amp;originWidth=400&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=26785&amp;status=done&amp;style=none&amp;taskId=u923a0bd8-64cc-4e12-ac29-0b5301ae0f3&amp;title=&amp;width=320" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688227493245-b069a3f0-4244-4ba8-b8a6-8af90d7f36a7.png#averageHue=%23f7f6f4&amp;clientId=ub061bfe9-9d20-4&amp;from=paste&amp;height=179&amp;id=uaee9cf78&amp;originHeight=224&amp;originWidth=657&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=97741&amp;status=done&amp;style=none&amp;taskId=uf5ac061a-d8b2-444d-86c2-809e13ebc23&amp;title=&amp;width=525.6" alt="image.png"><br>@MapKey(“id”)<br>以id为返回map的键，其中值为查询结果（通常用在有多个返回结果的查询中），如果有多个结果就返回最后一个结果。其中的id如果无法识别就用null代替，@MapKey(“id”) 注解中的 id 表示一个属性名，表示返回结果集中以哪个属性的值作为 Map 的键。</p><h4 id="特殊sql">特殊sql:</h4><p>模糊查询：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688255363510-f86f1244-96dd-4d98-9027-0145bc8a7f47.png#averageHue=%23ebf0e6&amp;clientId=ub061bfe9-9d20-4&amp;from=paste&amp;height=103&amp;id=u51962662&amp;originHeight=129&amp;originWidth=630&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=83538&amp;status=done&amp;style=none&amp;taskId=ucfe563e8-86a4-4fdc-aa5f-be8c1cc360d&amp;title=&amp;width=504" alt="image.png"><br>批量删除：<br>动态设置表名：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688256223477-294241c0-f767-4832-92f4-e978ccac4762.png#averageHue=%231e6123&amp;clientId=ub061bfe9-9d20-4&amp;from=paste&amp;height=47&amp;id=u59acb7a9&amp;originHeight=59&amp;originWidth=845&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=12730&amp;status=done&amp;style=none&amp;taskId=u8ddcbc86-9942-4a7a-b93c-affdfac9470&amp;title=&amp;width=676" alt="image.png">这里不能用#{}是因为#{}在拼接sql语句的时候自动添加了引发。</p><h4 id="处理多对1映射：注意在映射为实体类的时候，实体类中必须要有无参构造器">处理多对1映射：注意在映射为实体类的时候，实体类中必须要有无参构造器</h4><p>1.级联:<br>在核心配置文件<mapper>中添加内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=&quot;empDeptMap&quot; type=&quot;com.example.demo.object.Emp&quot;&gt;</span><br><span class="line">       &lt;id column=&quot;emp_id&quot; property=&quot;empId&quot;&gt;&lt;/id&gt;</span><br><span class="line">       &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot;&gt;&lt;/result&gt;</span><br><span class="line">     &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt;</span><br><span class="line">      &lt;result column=&quot;gender&quot; property=&quot;gender&quot;&gt;&lt;/result&gt;</span><br><span class="line">       &lt;result column=&quot;dept_id&quot; property=&quot;dept.id&quot;&gt;&lt;/result&gt;</span><br><span class="line">       &lt;result column=&quot;dept_name&quot; property=&quot;dept.name&quot;&gt;&lt;/result&gt;</span><br><span class="line">   &lt;/resultMap&gt;</span><br><span class="line">   &lt;select id=&quot;getEmpById&quot; resultMap=&quot;empDeptMap&quot;&gt;</span><br><span class="line">    select  *from  t_emp left join  t_dept on t_emp.dept_id=t_dept.dept_id where  t_emp.emp_id = #&#123;empId&#125;</span><br><span class="line">   &lt;/select&gt;</span><br></pre></td></tr></table></figure> <resultMap><resultMap>元素可以包含多个<result>子元素，每个<result>子元素定义了如何将查询结果中的一列映射到Java对象的一个属性中。<result>子元素通常包含以下属性：<ul><li>column：指定要映射的查询结果列的名称或别名。</li><li>property：指定要映射到Java对象的属性的名称。</li><li>jdbcType：指定查询结果列的JDBC类型。</li><li>javaType：指定要映射到Java对象属性的类型。</li><li>typeHandler：指定要使用的类型处理器，用于在Java对象和数据库类型之间进行转换。<id>子元素用于定义主键的映射，<result>子元素用于定义其他属性的映射。一旦你定义了<resultMap>元素，你可以在<select>或<selectKey>元素中使用它来指定查询结果的映射方式。</li><li>java中的无参构造器在Java中，无参构造器是指一个没有参数的构造器方法。如果你在一个Java类中没有显式地定义构造器，则编译器会自动为该类生成一个无参构造器。如果你显式地定义了一个构造器方法，但没有为其指定参数，则也会生成一个无参构造器。无参构造器通常用于创建一个新的对象实例，并初始化其状态。当你创建一个Java对象时，Java编译器会自动调用该对象的无参构造器，以便初始化对象的状态。如果你要创建一个对象，并使用默认值初始化其属性，则通常可以使用无参构造器。如果你显式地定义了一个有参数的构造器，则编译器不会自动为该类生成无参构造器。如果你需要一个无参构造器，你需要显式地定义一个。</li></ul><p>2.使用<association>标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=&quot;empDeptMap&quot; type=&quot;com.example.demo.object.Emp&quot;&gt;</span><br><span class="line">    &lt;id column=&quot;emp_id&quot; property=&quot;empId&quot;&gt;&lt;/id&gt;</span><br><span class="line">    &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot;&gt;&lt;/result&gt;</span><br><span class="line">  &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt;</span><br><span class="line">   &lt;result column=&quot;gender&quot; property=&quot;gender&quot;&gt;&lt;/result&gt;</span><br><span class="line">    &lt;association property=&quot;dept&quot; javaType=&quot;com.example.demo.object.Dept&quot;&gt;</span><br><span class="line">    &lt;id column=&quot;dept_id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;</span><br><span class="line">    &lt;result column=&quot;dept_name&quot; property=&quot;name&quot;&gt;&lt;/result&gt;</span><br><span class="line">     &lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;select id=&quot;getEmpById&quot; resultMap=&quot;empDeptMap&quot;&gt;</span><br><span class="line"> select  *from  t_emp left join  t_dept on t_emp.dept_id=t_dept.dept_id where  t_emp.emp_id = #&#123;empId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p><association>元素用于将两个对象之间的关联关系映射到查询结果中。</p><ul><li>property：指定要映射到Java对象的属性的名称。</li><li>javaType：指定要映射到Java对象的类型。（别名或者全类名）</li><li>select：指定关联查询的语句ID，用于查询关联对象的详细信息。</li></ul><p>4.分步查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=&quot;EmpAndDepByStep&quot; type=&quot;com.example.demo.object.Emp&quot;&gt;</span><br><span class="line">     &lt;id column=&quot;emp_id&quot; property=&quot;empId&quot;&gt;&lt;/id&gt;</span><br><span class="line">     &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot;&gt;&lt;/result&gt;</span><br><span class="line">     &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt;</span><br><span class="line">     &lt;result column=&quot;gender&quot; property=&quot;gender&quot;&gt;&lt;/result&gt;</span><br><span class="line">     &lt;association property=&quot;dept&quot;</span><br><span class="line">            select=&quot;com.example.demo.mapper.DepMapper.getEmpTwoStep&quot;</span><br><span class="line">                  column=&quot;dept_id&quot;&gt;</span><br><span class="line">     &lt;/association&gt;</span><br><span class="line"> &lt;/resultMap&gt;</span><br><span class="line"> &lt;select id=&quot;getEmpAndDepByStep&quot; resultMap=&quot;EmpAndDepByStep&quot;&gt;</span><br><span class="line">     select *from t_emp where  emp_id = #&#123;empid&#125;</span><br><span class="line"> &lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>select属性指定了一个名为com.example.demo.mapper.DepMapper.getEmpTwoStep的映射语句，该语句用于查询当前员工所属的部门对象。column属性指定了查询结果中用于关联的列名（即部门ID列）。注意这里的select语句指明的映射语句后的函数没有小括号。<br>如果分步查询中的Dep类的属性和表中的属性不一致的时候，可能会导致查询的dept为null这个时候使用resultMap将属性和列名重写映射就可以了。</p><h4 id="延迟加载：">延迟加载：</h4><p>延迟加载是一种优化数据库访问的方式，可以提高系统性能和响应速度。在MyBatis中，延迟加载主要通过基于代理的方式实现。<br>基于代理的延迟加载是指，MyBatis在查询关联对象时，不会立即查询所有关联对象的数据，而是创建一个代理对象代替关联对象，在需要访问关联对象时，再实际访问数据库加载数据。这样可以避免不必要的数据库查询，提高系统性能和响应速度。<br>例如，假设你有两个实体类Emp和Dept，其中Emp类包含一个dept属性，表示员工所在的部门：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Emp &#123;</span><br><span class="line">    private Integer empId;</span><br><span class="line">    private String empName;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String gender;</span><br><span class="line">    private Dept dept;</span><br><span class="line"></span><br><span class="line">    // getter和setter方法</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Dept &#123;</span><br><span class="line">    private Integer deptId;</span><br><span class="line">    private String deptName;</span><br><span class="line"></span><br><span class="line">    // getter和setter方法</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你使用MyBatis查询Emp对象，并同时查询dept对象，可以使用以下的XML配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;getEmpAndDepByStep&quot; resultMap=&quot;empResult&quot;&gt;</span><br><span class="line">  select e.emp_id, e.emp_name, e.age, e.gender, d.dept_id, d.dept_name</span><br><span class="line">  from t_emp e</span><br><span class="line">  inner join t_dept d on e.dept_id = d.dept_id</span><br><span class="line">  where e.emp_id = #&#123;empId&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;resultMap id=&quot;empResult&quot; type=&quot;Emp&quot;&gt;</span><br><span class="line">  &lt;id property=&quot;empId&quot; column=&quot;emp_id&quot;/&gt;</span><br><span class="line">  &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;/&gt;</span><br><span class="line">  &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt;</span><br><span class="line">  &lt;result property=&quot;gender&quot; column=&quot;gender&quot;/&gt;</span><br><span class="line">  &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot;&gt;</span><br><span class="line">    &lt;id property=&quot;deptId&quot; column=&quot;dept_id&quot;/&gt;</span><br><span class="line">    &lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot;/&gt;</span><br><span class="line">  &lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><p>在上述配置中，association标签用于配置dept属性，resultMap属性用于指定empResult结果映射。这样，当你查询Emp对象时，MyBatis会自动查询关联的Dept对象，并将查询结果封装到Emp对象中的dept属性中。<br>如果你使用基于代理的延迟加载方式，可以在查询Emp对象时，不立即查询关联的Dept对象，而是创建一个代理对象代替Dept对象。这样，在访问dept属性时，MyBatis会自动触发查询操作，并将查询结果封装到代理对象中。<br>例如，你可以使用以下的XML配置文件启用基于代理的延迟加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;getEmpAndDepByStep&quot; resultMap=&quot;empResult&quot;&gt;</span><br><span class="line">  select e.emp_id, e.emp_name, e.age, e.gender, e.dept_id</span><br><span class="line">  from t_emp e</span><br><span class="line">  where e.emp_id = #&#123;empId&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;resultMap id=&quot;empResult&quot; type=&quot;Emp&quot;&gt;</span><br><span class="line">  &lt;id property=&quot;empId&quot; column=&quot;emp_id&quot;/&gt;</span><br><span class="line">  &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;/&gt;</span><br><span class="line">  &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt;</span><br><span class="line">  &lt;result property=&quot;gender&quot; column=&quot;gender&quot;/&gt;</span><br><span class="line">  &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot; select=&quot;getDeptById&quot;&gt;</span><br><span class="line">  &lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;getDeptById&quot; resultType=&quot;Dept&quot;&gt;</span><br><span class="line">  select dept_id, dept_name</span><br><span class="line">  from t_dept</span><br><span class="line">  where dept_id = #&#123;deptId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>在上述配置中，association标签用于配置dept属性，select属性用于指定查询关联对象的SQL语句，getDeptById为查询关联对象的ID。这样，在查询Emp对象时，MyBatis会创建一个代理对象代替Dept对象，当你访问dept属性时，MyBatis会自动触发查询操作，并将查询结果封装到代理对象中。<br>需要注意的是，使用基于代理的延迟加载方式时，需要在查询结束后手动访问关联对象的属性，以触发数据加载。例如，在上述配置中，你需要手动访问Emp对象的dept属性，以触发关联对象的查询操作，代码示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Emp emp = sqlSession.selectOne(&quot;getEmpAndDepByStep&quot;, empId);</span><br><span class="line">System.out.println(emp.getEmpName()); // 访问Emp对象的属性，不会触发关联对象的查询操作</span><br><span class="line">System.out.println(emp.getDept().getDeptName()); // 访问关联对象的属性，会触发关联对象的查询操作</span><br></pre></td></tr></table></figure><p>在上述代码中，你需要先访问Emp对象的属性，例如empName，以确保Emp对象已经被查询出来。然后再访问dept属性，以触发关联对象的查询操作。<br>如果你使用基于XML配置的延迟加载方式，可以在查询Emp对象时，不立即查询关联的Dept对象，而是将查询操作延迟到访问dept属性时。这样，MyBatis会自动创建代理对象，并在访问dept属性时，触发查询操作，并将查询结果封装到代理对象中。<br>例如，你可以使用以下的XML配置文件启用基于XML配置的延迟加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;getEmpAndDepByLazyLoading&quot; resultMap=&quot;empResult&quot;&gt;</span><br><span class="line">  select e.emp_id, e.emp_name, e.age, e.gender, e.dept_id</span><br><span class="line">  from t_emp e</span><br><span class="line">  where e.emp_id = #&#123;empId&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;resultMap id=&quot;empResult&quot; type=&quot;Emp&quot;&gt;</span><br><span class="line">  &lt;id property=&quot;empId&quot; column=&quot;emp_id&quot;/&gt;</span><br><span class="line">  &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;/&gt;</span><br><span class="line">  &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt;</span><br><span class="line">  &lt;result property=&quot;gender&quot; column=&quot;gender&quot;/&gt;</span><br><span class="line">  &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot; select=&quot;getDeptById&quot; lazyLoadingEnabled=&quot;true&quot;&gt;</span><br><span class="line">  &lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;getDeptById&quot; resultType=&quot;Dept&quot;&gt;</span><br><span class="line">  select dept_id, dept_name</span><br><span class="line">  from t_dept</span><br><span class="line">  where dept_id = #&#123;deptId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>在上述配置中，lazyLoadingEnabled属性用于启用基于XML配置的延迟加载。这样，在访问dept属性时，MyBatis会自动创建代理对象，并触发查询操作。<br>需要注意的是，使用基于XML配置的延迟加载方式时，需要确保在访问关联对象的属性时，MyBatis会自动触发查询操作。如果你手动访问关联对象的属性，而没有启用基于XML配置的延迟加载，那么查询操作会立即执行，而不是延迟加载。所以，建议在使用基于XML配置的延迟加载时，不要手动访问关联对象的属性，以便MyBatis可以自动触发查询操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;true&quot;/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这两个设置都与MyBatis的延迟加载相关。<br>lazyLoadingEnabled设置决定是否启用延迟加载。如果设置为true，则启用延迟加载；如果设置为false，则禁用延迟加载。启用延迟加载后，MyBatis将会创建代理对象代替关联对象，在需要访问关联对象时，再实际访问数据库加载数据。这样可以减少不必要的数据库访问，提高系统性能和响应速度。<br>aggressiveLazyLoading设置决定是否启用积极的延迟加载。如果设置为true，则启用积极的延迟加载；如果设置为false，则禁用积极的延迟加载。启用积极的延迟加载后，MyBatis将会尽可能多地延迟加载关联对象的数据，包括嵌套的关联对象。这样可以进一步减少不必要的数据库访问，提高系统性能和响应速度。但需要注意，启用积极的延迟加载可能会导致一些副作用，例如N+1查询问题等。<br>一般来说，启用延迟加载可以提高系统性能和响应速度，但需要根据具体的场景和需求做出权衡和选择。如果你的数据量较小，或者关联对象的数据量较少，可以考虑禁用延迟加载，直接一次性查询所有关联对象的数据。而如果你的数据量较大，或者关联对象的数据量较大，可以考虑启用延迟加载，以减少不必要的数据库访问。<br>需要注意的是，启用延迟加载后，需要在访问关联对象的属性时，才会触发数据库查询操作。因此，如果你需要使用关联对象的数据，建议在查询时同时查询关联对象的数据，以避免不必要的延迟加载操作。另外，如果你使用了基于代理的延迟加载方式，需要在访问关联对象的属性时，手动触发数据加载操作，以确保关联对象的数据已经被加载到代理对象中。</p><h4 id="通过collection处理一对多映射关系：">通过collection处理一对多映射关系：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688284752974-610d453d-40df-4cf7-a210-545e1ec8fd48.png#averageHue=%23fbf9f2&amp;clientId=ub061bfe9-9d20-4&amp;from=paste&amp;height=59&amp;id=u5ad784bd&amp;originHeight=74&amp;originWidth=316&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=11977&amp;status=done&amp;style=none&amp;taskId=u00797a95-d021-4a47-9b35-71f49b75973&amp;title=&amp;width=252.8" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;collection property=&quot;emps&quot; ofType=&quot;com.example.demo.object.Emp&quot;&gt;</span><br><span class="line">            &lt;id column=&quot;emp_id&quot; property=&quot;empId&quot;&gt;&lt;/id&gt;</span><br><span class="line">            &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot;&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt;</span><br><span class="line">            &lt;result column=&quot;gender&quot; property=&quot;gender&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;/collection&gt;</span><br></pre></td></tr></table></figure><p>这段XML配置代码用于配置一个集合类型的结果映射。<br><collection>标签用于指定集合属性的结果映射。其中，property属性指定集合属性的名称，ofType属性指定集合元素的类型。<br>在<collection>标签中，可以使用<id>标签和<result>标签配置集合元素的属性。<id>标签用于指定集合元素的主键属性，column属性指定数据库表中的主键列名，property属性指定Java对象中的属性名。<result>标签用于指定集合元素的普通属性，column属性指定数据库表中的列名，property属性指定Java对象中的属性名。<br>例如，上述XML配置代码中，<collection>标签配置了一个名为emps的集合属性，元素类型为com.example.demo.object.Emp。<id>标签指定了集合元素的主键属性为empId，<result>标签指定了集合元素的普通属性为empName、age和gender。当MyBatis查询结果包含多个Emp对象时，会自动将这些对象封装到emps集合中，其中每个Emp对象的属性值根据XML配置进行映射。<br>需要注意的是，如果你在查询结果中包含了集合类型的属性，需要使用<collection>标签进行结果映射。另外，如果你使用了基于代理的延迟加载方式，需要在访问集合属性时，手动触发数据加载操作，以确保集合元素的数据已经被加载到代理对象中。</p><h4 id="分步查询处理一对多的关系：">分步查询处理一对多的关系：</h4><p>depMapper中的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;/select&gt;</span><br><span class="line">  &lt;resultMap id=&quot;DeptAndEmpStepOne&quot; type=&quot;com.example.demo.object.Dept&quot;&gt;</span><br><span class="line">      &lt;id column=&quot;dept_id&quot; property=&quot;Id&quot;&gt;&lt;/id&gt;</span><br><span class="line">      &lt;result column=&quot;dept_name&quot; property=&quot;name&quot;&gt;&lt;/result&gt;</span><br><span class="line">      &lt;collection property=&quot;emps&quot;</span><br><span class="line">                  select=&quot;com.example.demo.mapper.EmpMapper.DeptAndDeptTwo&quot;</span><br><span class="line">                  column=&quot;dept_id&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/collection&gt;</span><br><span class="line">  &lt;/resultMap&gt;</span><br><span class="line">  &lt;select id=&quot;getDeptAndEmpStepOne&quot; resultMap=&quot;DeptAndEmpStepOne&quot;&gt;</span><br><span class="line">      select *from  t_dept where  dept_id = #&#123;deptId&#125;</span><br><span class="line">  &lt;/select&gt;</span><br></pre></td></tr></table></figure><p>employees中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q &lt;select id=&quot;DeptAndDeptTwo&quot; resultType=&quot;com.example.demo.object.Emp&quot;&gt;</span><br><span class="line">        select  *from  t_emp where  dept_id=#&#123;deptId&#125;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure><h4 id="动态sql">动态sql:</h4><p>前段没有传递某些参数，而服务器获取这些参数，器结果为null；如果前端传来的表单文本框内容没有填写，后端获取的就是空字符串。</p><h6 id="if标签：">if标签：</h6><p>下面（代码2）是根据empName和age,gender来查找的，但是当empName为null或者空字符串的时候，会报sql语法错误（原因是拼接的时候empName那个sql片段没有拼接进去，可能拼接了后面的sql片段对了and)解决方法在在第一个if标签前面添加一个恒成立条件：方法2是用where标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select  *from  t_emp where  1 = 1 &lt;if test = &quot;emp.empName != null and emp.empName != &#x27;&#x27;&quot;&gt;</span><br><span class="line">    and emp_name = #&#123;emp.empName&#125;</span><br><span class="line"></span><br><span class="line">&lt;/if&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;getEmpsByCondition&quot; resultType=&quot;com.example.demo.object.Emp&quot;&gt;</span><br><span class="line">select  *from  t_emp where  &lt;if test = &quot;emp.empName != null and emp.empName != &#x27;&#x27;&quot;&gt;</span><br><span class="line">    emp_name = #&#123;emp.empName&#125;</span><br><span class="line"></span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;emp.age !=null and emp.age != &#x27;&#x27;&quot; &gt;</span><br><span class="line">    and age = #&#123;emp.age&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;emp.gender != null and emp.gender!=&#x27;&#x27;&quot;&gt;</span><br><span class="line">    and gender = #&#123;emp.gender&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>注意上面的if标签中的属性要添加变量名，不然会报找不到empName的错误。<br><if test = "empName != null and empName != ''"><br>emp_name = #{empName}<br></if>（这个会报错的）</p><h6 id="where">where:</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688383957268-bb9ca8b7-ef7c-438d-b045-e1745a67f96f.png#averageHue=%23f7f6f3&amp;clientId=u8aa2d897-50f1-4&amp;from=paste&amp;height=108&amp;id=u55e2024c&amp;originHeight=135&amp;originWidth=673&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=70114&amp;status=done&amp;style=none&amp;taskId=ua3be383d-c361-4141-b8dd-b3becf137d8&amp;title=&amp;width=538.4" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;/select&gt;</span><br><span class="line">    &lt;select id=&quot;getEmpsByConditionWhere&quot; resultType=&quot;com.example.demo.object.Emp&quot;&gt;</span><br><span class="line">        select  *from  t_emp</span><br><span class="line">        &lt;where&gt;</span><br><span class="line">            &lt;if test = &quot;emp.empName != null and emp.empName != &#x27;&#x27;&quot;&gt;</span><br><span class="line">                and emp_name = #&#123;emp.empName&#125;</span><br><span class="line"></span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">            &lt;if test=&quot;emp.age !=null and emp.age != &#x27;&#x27;&quot; &gt;</span><br><span class="line">                and age = #&#123;emp.age&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">            &lt;if test=&quot;emp.gender != null and emp.gender!=&#x27;&#x27;&quot;&gt;</span><br><span class="line">                and gender = #&#123;emp.gender&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">        &lt;/where&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure><h6 id="trim标签：">trim标签：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;/select&gt;</span><br><span class="line">   &lt;select id=&quot;getEmpsByConditionTrim&quot; resultType=&quot;com.example.demo.object.Emp&quot;&gt;</span><br><span class="line">       select  *from  t_emp</span><br><span class="line">       &lt;trim prefix=&quot;where&quot;  suffixOverrides=&quot;and&quot;&gt;</span><br><span class="line">           &lt;if test = &quot;emp.empName != null and emp.empName != &#x27;&#x27;&quot;&gt;</span><br><span class="line">                emp_name = #&#123;emp.empName&#125; and</span><br><span class="line"></span><br><span class="line">           &lt;/if&gt;</span><br><span class="line">           &lt;if test=&quot;emp.age !=null and emp.age != &#x27;&#x27;&quot; &gt;</span><br><span class="line">                age = #&#123;emp.age&#125; and</span><br><span class="line">           &lt;/if&gt;</span><br><span class="line">           &lt;if test=&quot;emp.gender != null and emp.gender!=&#x27;&#x27;&quot;&gt;</span><br><span class="line">                gender = #&#123;emp.gender&#125;</span><br><span class="line">           &lt;/if&gt;</span><br><span class="line">       &lt;/trim&gt;</span><br><span class="line"></span><br><span class="line">   &lt;/select&gt;</span><br></pre></td></tr></table></figure><p><trim> 标签是 MyBatis 中用于生成动态 SQL 的标签之一，它可以用于去除 SQL 语句中不必要的逗号、AND 或者 OR 等关键字，从而生成更加紧凑的 SQL 语句。<br><trim> 标签有以下属性：</p><ul><li>prefix：在 SQL 语句开头添加的字符串。</li><li>suffix：在 SQL 语句结尾添加的字符串。</li><li>prefixOverrides：需要去除的 SQL 语句开头的字符串。</li><li>suffixOverrides：需要去除的 SQL 语句结尾的字符串。</li></ul><p><trim> 标签的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;trim prefix=&quot;&quot; suffix=&quot;&quot; prefixOverrides=&quot;&quot; suffixOverrides=&quot;&quot;&gt;</span><br><span class="line">  SQL statement</span><br><span class="line">&lt;/trim&gt;</span><br></pre></td></tr></table></figure><p>其中，prefix 和 suffix 属性用于添加前缀和后缀，prefixOverrides 和 suffixOverrides 属性用于去除开头和结尾的字符串。<br>下面是一个使用 <trim> 标签的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findUsersByCondition&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">  SELECT * FROM user</span><br><span class="line">  &lt;where&gt;</span><br><span class="line">    &lt;trim prefix=&quot;AND&quot; prefixOverrides=&quot;AND (&quot;&gt;</span><br><span class="line">      &lt;if test=&quot;username != null&quot;&gt;</span><br><span class="line">        username = #&#123;username&#125;</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;age != null&quot;&gt;</span><br><span class="line">        AND age = #&#123;age&#125;</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">  &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>在这个示例中，<trim> 标签用于去除 SQL 语句中多余的 AND 关键字。如果 username 或者 age 参数不为空，则会生成类似于 AND username = #{username} AND age = #{age} 的 SQL 语句，否则只会生成 SELECT * FROM user 的 SQL 语句。</p><h6 id="choose-when-otherwise等标签">choose,when,otherwise等标签</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688384511573-607a6751-25cb-46ca-b1f5-51cc3930e8c8.png#averageHue=%23f7f5ef&amp;clientId=u8aa2d897-50f1-4&amp;from=paste&amp;height=60&amp;id=u0073258c&amp;originHeight=75&amp;originWidth=360&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=25763&amp;status=done&amp;style=none&amp;taskId=ucb5a20f8-c3ba-4791-91b7-5e77c316ed1&amp;title=&amp;width=288" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findUsers&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">  SELECT * FROM users</span><br><span class="line">  &lt;where&gt;</span><br><span class="line">    &lt;choose&gt;</span><br><span class="line">      &lt;when test=&quot;username != null&quot;&gt;</span><br><span class="line">        AND username = #&#123;username&#125;</span><br><span class="line">      &lt;/when&gt;</span><br><span class="line">      &lt;when test=&quot;email != null&quot;&gt;</span><br><span class="line">        AND email = #&#123;email&#125;</span><br><span class="line">      &lt;/when&gt;</span><br><span class="line">      &lt;otherwise&gt;</span><br><span class="line">        AND status = 1</span><br><span class="line">      &lt;/otherwise&gt;</span><br><span class="line">    &lt;/choose&gt;</span><br><span class="line">  &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>在这个示例中，<choose> 标签用于选择一个条件分支，如果 username 参数不为空，则会生成 AND username = #{username} 的 SQL 语句，否则如果 email 参数不为空，则会生成 AND email = #{email} 的 SQL 语句，否则会生成 AND status = 1 的 SQL 语句。<br><choose> 标签通常与 <when> 和 <otherwise> 标签配合使用。<when> 标签用于定义一个条件分支，<otherwise> 标签定义了一个默认的条件分支，它会在所有其他条件都不成立时执行。</p><h6 id="foreach">foreach:</h6><p>批量添加：注意<foreach>标签中的#{emp.empName}中的emp不能省略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--如果以List传递过来，底层仍旧是map只不过是以list为键,如果以@Parame注解的参数，传递给@Parame的参数就是底层map的键--&gt;</span><br><span class="line">  &lt;insert id=&quot;insertMoreEmp&quot; &gt;</span><br><span class="line">      insert  into  t_emp values</span><br><span class="line">                              &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">                                  (null,#&#123;emp.empName&#125;,#&#123;emp.age&#125;,#&#123;emp.gender&#125;,null)</span><br><span class="line">                              &lt;/foreach&gt;</span><br><span class="line">  &lt;/insert&gt;</span><br></pre></td></tr></table></figure><h4 id="Param">@Param</h4><p>@Param 是 MyBatis 中用于指定方法参数名称的注解。在 MyBatis 中，如果一个方法有多个参数，则必须使用 @Param 注解来指定每个参数的名称，以便 MyBatis 可以正确地将参数传递给 SQL 语句。<br>@Param 注解有一个可选的 value 属性，用于指定参数的名称。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br><span class="line">  List&lt;User&gt; findUsersByUsernameAndEmail(</span><br><span class="line">    @Param(&quot;username&quot;) String username,</span><br><span class="line">    @Param(&quot;email&quot;) String email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，findUsersByUsernameAndEmail 方法有两个参数，分别是 username 和 email，并且使用 @Param 注解指定了它们的名称。在 SQL 语句中，可以使用 #{username} 和 #{email} 占位符来引用这两个参数。<br>需要注意的是，如果方法只有一个参数，并且这个参数是一个简单类型（如 int、String 等），则可以不使用 @Param 注解。在这种情况下，MyBatis 会将参数默认命名为 arg0、arg1 等。但是，为了代码的可读性和可维护性，建议在所有情况下都使用 @Param 注解来指定参数名称。<br>在 XML 映射文件中，可以使用 parameterType 属性来指定方法参数的类型，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findUsersByUsernameAndEmail&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">  SELECT * FROM users</span><br><span class="line">  WHERE username = #&#123;username&#125; AND email = #&#123;email&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>在这个示例中，parameterType 属性指定了方法参数的类型为 java.util.Map，并且在 SQL 语句中使用了 #{username} 和 #{email} 占位符来引用参数。如果使用了 @Param 注解，则可以省略 parameterType 属性。</p><h4 id="List-Emp-list-Arrays-asList-emp1-emp2-emp3">List<Emp> list = Arrays.asList(emp1,emp2,emp3);</h4><p>这段代码使用了 Java 的 Arrays.asList() 方法将多个 Emp 对象封装成一个 List<Emp> 对象。<br>Arrays.asList() 方法是 Java 中一个常用的工具方法，它可以将一个数组转换为一个 List 对象。在这个示例中，Arrays.asList() 方法将多个 Emp 对象封装成一个 List<Emp> 对象，并将这个 List<Emp> 对象赋给了变量 list。<br>需要注意的是，Arrays.asList() 方法返回的 List 对象是一个固定大小的 List 对象，不能进行添加或删除操作。如果需要进行添加或删除操作，可以使用 ArrayList 等可变大小的 List 实现类来创建 List 对象。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Emp&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(emp1);</span><br><span class="line">list.add(emp2);</span><br><span class="line">list.add(emp3);</span><br></pre></td></tr></table></figure><p>在这个示例中，使用 ArrayList 来创建 List<Emp> 对象，并分别添加了三个 Emp 对象。ArrayList 是一个可变大小的 List 实现类，可以进行添加和删除操作。</p><h4 id="foreach标签实现批量删除（通过数组）：">foreach标签实现批量删除（通过数组）：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688389747602-947eb4c7-4bfd-4da1-a301-37291e46e86d.png#averageHue=%23f8f7f3&amp;clientId=u8aa2d897-50f1-4&amp;from=paste&amp;height=109&amp;id=ub9b07fed&amp;originHeight=136&amp;originWidth=495&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=50545&amp;status=done&amp;style=none&amp;taskId=u814a3966-0855-45ff-951d-b2b8fbff284&amp;title=&amp;width=396" alt="image.png"><br>方法1:<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688389723082-9bb1dfaa-9058-436c-9232-69886af988cf.png#averageHue=%23f4e8be&amp;clientId=u8aa2d897-50f1-4&amp;from=paste&amp;height=88&amp;id=udc12c1a4&amp;originHeight=110&amp;originWidth=598&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=44948&amp;status=done&amp;style=none&amp;taskId=uf6b698b0-12f4-479a-a3af-4344566010d&amp;title=&amp;width=478.4" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;delete id=&quot;deleteMoreEmp&quot;&gt;</span><br><span class="line">     delete  from t_emp where emp_id in </span><br><span class="line"></span><br><span class="line">                            &lt;foreach collection=&quot;empIds&quot; item=&quot;empId&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;</span><br><span class="line">                                #&#123;empId&#125;</span><br><span class="line">                            &lt;/foreach&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/delete&gt;</span><br></pre></td></tr></table></figure><p>在 <delete> 标签中使用了 <foreach> 标签，将 empIds 集合中的多个 empId 值循环插入到 SQL 语句中。其中，collection 属性指定了要循环遍历的集合，item 属性指定了集合中的每个 empId 值在 SQL 语句中的占位符名称。，separator 属性的值为逗号 ,，表示在循环遍历 empIds 集合时，每个 empId 值之间会使用逗号作为分隔符分隔。这样，在 SQL 语句中生成的 IN 子句就会以逗号分隔 emp_id 值。open 属性的值为左括号 (，close 属性的值为右括号 )，表示在循环遍历 empIds 集合时，会在 emp_id 值的前后分别添加一个左括号和一个右括号，以便生成正确的 IN 子句。</p><h4 id="数据库中的某条数据不为空但是利用mybatis中的mapper查询的时候返回的部分属性为null的原因：">数据库中的某条数据不为空但是利用mybatis中的mapper查询的时候返回的部分属性为null的原因：</h4><p>1，返回为null的属性没有正确的get和set方法或者返回的类没有无参构造方法。<br>2.数据库中的列的数据类型和类中的数据类型不一致<br>3.<strong>有get和set方法但是类中的属性和数据库列中的名字（不区分大小写）不一样（可以通过resultMap重新映射或者设置别名解决</strong><br>4。查询语句正确指定数据库列的别名（可以通过在 SQL 语句中使用 SELECT 子句并为列指定别名来指定列的别名。例如，假设要查询 employees 表中的 emp_id 和 emp_name 两列，可以使用以下 SQL 语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT emp_id AS empId, emp_name AS empName FROM employees</span><br></pre></td></tr></table></figure><p>在这个 SQL 语句中，使用 AS 关键字为 emp_id 和 emp_name 列指定了别名 empId 和 empName。这样，在 MyBatis 将查询结果映射为 Emp 对象时，就会将 empId 列的值映射到 Emp 对象的 empId 属性中，将 empName 列的值映射到 Emp 对象的 empName 属性中。<br>如果使用 MyBatis 提供的 Mapper XML 文件来编写 SQL 语句，可以在 <resultMap> 标签中使用 <result> 标签来指定列的别名。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=&quot;empResultMap&quot; type=&quot;Emp&quot;&gt;</span><br><span class="line">  &lt;result column=&quot;emp_id&quot; property=&quot;empId&quot;/&gt;</span><br><span class="line">  &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;selectEmps&quot; resultMap=&quot;empResultMap&quot;&gt;</span><br><span class="line">  SELECT emp_id, emp_name FROM employees</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>在这个示例中，使用 <result> 标签为 emp_id 和 emp_name 列指定了别名 empId 和 empName。在 <select> 标签中，使用 resultMap 属性指定了要使用的结果映射规则。这样，在 MyBatis 映射查询结果时，就会将 empId 列的值映射到 Emp 对象的 empId 属性中，将 empName 列的值映射到 Emp 对象的 empName 属性中。）</p><h4 id="sql标签：">sql标签：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688389907859-50743d07-8203-4331-88fa-a19ddf64a86e.png#averageHue=%23f7f8f3&amp;clientId=u8aa2d897-50f1-4&amp;from=paste&amp;height=110&amp;id=ubc3e8d00&amp;originHeight=137&amp;originWidth=492&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=46143&amp;status=done&amp;style=none&amp;taskId=u491a6728-31dc-42f3-80fb-0e67c23ee9c&amp;title=&amp;width=393.6" alt="image.png"><br>MyBatis 中的 <sql> 标签用于定义可重用的 SQL 片段，可以在 Mapper XML 文件中定义 <sql> 标签，并在需要使用这些 SQL 片段的地方引用它们。<br>例如，可以在 Mapper XML 文件中定义一个 <sql> 标签，用于定义一个可重用的 SQL 片段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;sql id=&quot;selectColumns&quot;&gt;</span><br><span class="line">  emp_id, emp_name, emp_salary</span><br><span class="line">&lt;/sql&gt;</span><br></pre></td></tr></table></figure><p>在这个示例中，<sql> 标签的 id 属性指定了 SQL 片段的名称为 selectColumns，<sql> 标签的内容为 SQL 片段的内容，包括查询的列名。<br>在需要使用这个 SQL 片段的地方，可以使用 ${} 占位符来引用它。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;selectEmp&quot; resultType=&quot;Emp&quot;&gt;</span><br><span class="line">  select &lt;include refid=&quot;selectColumns&quot;/&gt; from t_emp</span><br><span class="line">  where emp_id = #&#123;empId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>在这个示例中，使用 <include> 标签引用了之前定义的 SQL 片段，refid 属性指定了 SQL 片段的名称为 selectColumns。这样，在生成 SQL 语句时，MyBatis 会将 <include> 标签替换为 SQL 片段的内容，生成完整的 SQL 语句。<br>使用 <sql> 标签可以避免在 Mapper XML 文件中重复编写相同的 SQL 片段，提高了代码的重用性和可维护性。同时，使用 <sql> 标签还可以将复杂的 SQL 语句拆分为多个可重用的 SQL 片段，使 SQL 语句更加清晰易懂。</p><h4 id="Mybatis的一级缓存：">Mybatis的一级缓存：</h4><p>MyBatis 的一级缓存是指在同一个 SqlSession 中，对于相同的查询语句和查询条件，MyBatis 可以将查询结果缓存起来，以便后续的查询可以直接使用缓存中的数据，而不需要再次执行 SQL 查询。<br>一级缓存是 MyBatis 默认开启的，它存储在 SqlSession 中，可以提高查询效率，减少与数据库的交互次数。在同一个 SqlSession 中，如果多次查询相同的数据，那么只有第一次查询会触发 SQL 查询，后续的查询都会从缓存中获取数据，从而提高查询效率。<br>一级缓存的实现方式是将查询结果存储在一个 Map 对象中，Map 的键值是查询语句和查询条件的组合，Map 的值是查询结果。在同一个 SqlSession 中，如果执行了更新、插入或删除操作，那么 MyBatis 会自动清空一级缓存，以保证缓存中的数据与数据库保持一致。<br>需要注意的是，一级缓存的作用范围仅限于同一个 SqlSession 中，如果使用多个 SqlSession 进行查询，那么每个 SqlSession 都会独立地维护自己的一级缓存。因此，在某些情况下，如果需要共享缓存，可以考虑使用 MyBatis 的二级缓存。<br>另外，MyBatis 还提供了一些配置选项，可以对一级缓存进行调整或禁用。例如，可以通过设置 localCacheScope 属性为 STATEMENT 来禁用一级缓存，或者通过设置 flushCache=“true” 属性来强制清空一级缓存。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688396424415-687b36d7-e3c3-4a5f-9f23-a02fb1b58f9b.png#averageHue=%23f8f6f2&amp;clientId=u8aa2d897-50f1-4&amp;from=paste&amp;height=73&amp;id=u8026bf37&amp;originHeight=91&amp;originWidth=652&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=41428&amp;status=done&amp;style=none&amp;taskId=uc01ff294-247e-46ce-8889-263a6b86699&amp;title=&amp;width=521.6" alt="image.png"></p><h4 id="一级缓存失效的方法：">一级缓存失效的方法：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688396541434-1cd69218-c8aa-41cf-aaf4-5a5c0eef141d.png#averageHue=%23f3f0e3&amp;clientId=u8aa2d897-50f1-4&amp;from=paste&amp;height=76&amp;id=uefa3461d&amp;originHeight=95&amp;originWidth=539&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=52768&amp;status=done&amp;style=none&amp;taskId=u3b11ab90-74ff-40ea-879d-d74e672b542&amp;title=&amp;width=431.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688396659083-f001f90c-23d1-4c6a-9a20-94fbd5b384b3.png#averageHue=%230c105a&amp;clientId=u8aa2d897-50f1-4&amp;from=paste&amp;height=26&amp;id=u1fa572bb&amp;originHeight=33&amp;originWidth=430&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=5630&amp;status=done&amp;style=none&amp;taskId=uc3449976-cac5-4456-b241-d26d5e2d19b&amp;title=&amp;width=344" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688396689464-0d97e285-c710-4b7a-a84d-259467bc55ae.png#averageHue=%230a0806&amp;clientId=u8aa2d897-50f1-4&amp;from=paste&amp;height=186&amp;id=u2d7e60d4&amp;originHeight=233&amp;originWidth=1205&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=58398&amp;status=done&amp;style=none&amp;taskId=u0dedc2b5-5b5e-4488-b223-9360949ed46&amp;title=&amp;width=964" alt="image.png"><br>执行结果的日志有2次sql语句，表示从数据库中进行了2次操作</p><h4 id="Mybatis的二级缓存：">Mybatis的二级缓存：</h4><p>MyBatis 的二级缓存是指在多个 SqlSession 之间共享查询结果的缓存机制。与一级缓存不同，二级缓存的作用范围不仅限于同一个 SqlSession，而是可以跨越多个 SqlSession，甚至是多个应用程序实例。使用二级缓存可以减少与数据库的交互次数，提高应用程序的性能。<br>二级缓存的实现方式是将查询结果存储在一个可插拔的缓存实现中，可以选择使用 Ehcache、Redis 等第三方缓存框架，也可以使用 MyBatis 内置的缓存实现。在同一个应用程序实例中，多个 SqlSession 可以共享同一个缓存实现，从而实现数据的共享。<br>开启二级缓存需要在 Mapper XML 文件中配置 <cache> 标签，并在 MyBatis 配置文件中开启二级缓存功能。例如，可以在 MyBatis 配置文件中添加以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;settings&gt;</span><br><span class="line">    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">  &lt;/settings&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>在 Mapper XML 文件中，可以添加 <cache> 标签来配置二级缓存的相关属性。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;cache</span><br><span class="line">    eviction=&quot;LRU&quot;</span><br><span class="line">    flushInterval=&quot;60000&quot;</span><br><span class="line">    size=&quot;1024&quot;</span><br><span class="line">    readOnly=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure><p>在这个示例中，eviction 属性指定了缓存的清除策略为 LRU（Least Recently Used），flushInterval 属性指定了缓存的自动刷新时间为 60 秒，size 属性指定了缓存的最大大小为 1024，readOnly 属性指定了缓存是否只读。这些属性的含义和配置方式可以参考 MyBatis 的官方文档。<br>需要注意的是，二级缓存有一些限制和注意事项。例如，二级缓存中存储的数据是序列化后的对象，可能会导致性能下降；同时，如果数据被频繁地更新，那么缓存的命中率会降低，甚至会出现脏数据。因此，在使用二级缓存时，需要根据具体的业务场景进行适当的配置和调整。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688397300290-7655560e-531b-452a-ac89-479a70cb3094.png#averageHue=%23f2eee3&amp;clientId=u8aa2d897-50f1-4&amp;from=paste&amp;height=150&amp;id=u7faa80f9&amp;originHeight=187&amp;originWidth=724&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=119020&amp;status=done&amp;style=none&amp;taskId=u450db797-c8a8-4f62-abea-2d36114a7a2&amp;title=&amp;width=579.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688397344021-b232c95d-45e8-4f83-b402-09c4fa5359ed.png#averageHue=%23efebdc&amp;clientId=u8aa2d897-50f1-4&amp;from=paste&amp;height=49&amp;id=u2cf0333d&amp;originHeight=61&amp;originWidth=524&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=30065&amp;status=done&amp;style=none&amp;taskId=u93b7c066-d641-44c1-9212-6c90f53913d&amp;title=&amp;width=419.2" alt="image.png"></p><h4 id="Mybatis缓存查询顺序：">Mybatis缓存查询顺序：</h4><p>一级缓存只有在关闭或者提交的时候才会在二级缓存中生成数据。</p><h4 id="整合第三方缓存：">整合第三方缓存：</h4><p>是在二级缓存的基础上存在的。</p><h4 id="Mybatis的逆向工程：">Mybatis的逆向工程：</h4><p>1.在pom.xml增加插件的配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;1.3.0&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">                &lt;!-- 插件的依赖    --&gt;</span><br><span class="line">                &lt;dependencies&gt;</span><br><span class="line">                &lt;!-- 逆向工程的核心依赖    --&gt;</span><br><span class="line">                &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">                &lt;/dependency&gt;</span><br><span class="line">                &lt;!-- MySQL驱动    --&gt;</span><br><span class="line">                &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;8.0.16&lt;/version&gt;</span><br><span class="line">              &lt;/dependency&gt;</span><br><span class="line">               &lt;/dependencies&gt;</span><br><span class="line">                &lt;/plugin&gt;</span><br></pre></td></tr></table></figure><p>2.新增generatoeConfig.xml配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration</span><br><span class="line">       PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line">        &lt;generatorConfiguration&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">targetRuntime: 执行生成的逆向工程的版本</span><br><span class="line">MyBatis3Simple: 生成基本的CRUD（清新简洁版）</span><br><span class="line">MyBatis3: 生成带条件的CRUD（奢华尊享版）</span><br><span class="line"> --&gt;</span><br><span class="line">        &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;</span><br><span class="line">        &lt;!-- 数据库的连接信息    --&gt;</span><br><span class="line">        &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;</span><br><span class="line">        connectionURL=&quot;jdbc:mysql://localhost:3306/myemployees?serverTimezone=UTC&quot;</span><br><span class="line">        userId=&quot;root&quot;</span><br><span class="line">       password=&quot;A86789234&quot;&gt;</span><br><span class="line">        &lt;/jdbcConnection&gt;</span><br><span class="line">        &lt;!-- javaBean的生成策略targetPackage是javaBean生成的目标包，targetProject是生成的路径，.表示</span><br><span class="line">        项目根目录路径，..表示上一级路径,配置这种类似的时候注意路径--&gt;</span><br><span class="line">      &lt;javaModelGenerator targetPackage=&quot;com.example.demo.pojo&quot;</span><br><span class="line">        targetProject=&quot;.\src\main\java&quot;&gt;</span><br><span class="line">          &lt;!--能否使用子包--&gt;</span><br><span class="line">       &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">          &lt;!--把当前字段的前后空格字符去掉生成实体类的属性--&gt;</span><br><span class="line">      &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">       &lt;/javaModelGenerator&gt;</span><br><span class="line">       &lt;!-- SQL映射文件的生成策略 生成在com.example.mybatis.mapper包中的.\src\main\resources路径下   --&gt;</span><br><span class="line">        &lt;sqlMapGenerator targetPackage=&quot;com.example.demo.mapper&quot;</span><br><span class="line">        targetProject=&quot;.\src\main\resources&quot;&gt;</span><br><span class="line">       &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;/sqlMapGenerator&gt;</span><br><span class="line">       &lt;!-- Mapper接口的生成策略    --&gt;</span><br><span class="line">        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;</span><br><span class="line">        targetPackage=&quot;com.example.demo.mapper&quot; targetProject=&quot;.\src\main\java&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;/javaClientGenerator&gt;</span><br><span class="line">        &lt;!-- 逆向分析的表    --&gt;</span><br><span class="line">       &lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;</span><br><span class="line">        &lt;!-- domainObjectName属性指定生成出来的实体类的类名    --&gt;</span><br><span class="line">        &lt;table tableName=&quot;t_emp&quot; domainObjectName=&quot;Emp&quot;/&gt;</span><br><span class="line">        &lt;table tableName=&quot;t_dept&quot; domainObjectName=&quot;Dept&quot;/&gt;</span><br><span class="line">        &lt;/context&gt;</span><br><span class="line">        &lt;/generatorConfiguration&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688456443867-c4b537bf-6dc4-4261-90a3-20cb0e92b210.png#averageHue=%23faf9f5&amp;clientId=u378e3c4c-7292-4&amp;from=paste&amp;height=164&amp;id=ue439f11f&amp;originHeight=205&amp;originWidth=396&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=49632&amp;status=done&amp;style=none&amp;taskId=u384443b0-43f4-4288-a120-e26c7288230&amp;title=&amp;width=316.8" alt="image.png">insert和insertSelective的区别：如果某个属性为null的时候，insert是给改属性对应的列赋值为null,(如果该列有默认值就不会把改列赋值为默认值）,insertSelective是当某个属性为null的时候，不会把该属性对应的列插入数据，使其为默认值（如果有默认值的话）</p><h6 id="3-生成的特殊EmpExample类和EmpMapper接口的分析：">3.生成的特殊EmpExample类和EmpMapper接口的分析：</h6><p>MyBatis3 逆向工程生成的 EmpExample 类是用于封装 MyBatis 查询条件的一个实例。EmpExample 类主要包含以下属性和方法：<br><strong>属性：</strong></p><ul><li>oredCriteria：一个 List<Criteria> 类型的属性，用于存放多个 Criteria 对象，每个 Criteria 对象代表一个查询条件。</li><li>orderByClause：一个 String 类型的属性，用于存放查询结果的排序方式。相当于 SQL 中的 order by 子句。</li><li>distinct：一个 boolean 类型的属性，用于指定查询结果是否去重。相当于 SQL 中的 distinct 关键字。</li></ul><p><strong>方法：</strong></p><ul><li>EmpExample()：无参构造方法，用于创建一个 EmpExample 对象。</li><li>createCriteria()：创建一个 Criteria 对象，并将该对象添加到 oredCriteria 列表中。</li><li>getOredCriteria()：获取 oredCriteria 列表，用于设置多个查询条件的情况。</li><li>setOrderByClause(String orderByClause)：设置查询结果的排序方式。</li><li>getOrderByClause()：获取查询结果的排序方式。</li><li>setDistinct(boolean distinct)：设置查询结果是否去重。</li><li>isDistinct()：获取查询结果是否去重。</li><li>clear()：清空查询条件。</li></ul><p>通过 EmpExample 类，可以方便地构建查询条件，实现更加灵活的查询操作。可以通过 createCriteria() 方法创建一个 Criteria 对象，然后通过 Criteria 对象的方法设置查询条件，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EmpExample example = new EmpExample();</span><br><span class="line">Criteria criteria = example.createCriteria();</span><br><span class="line">criteria.andNameEqualTo(&quot;Tom&quot;);</span><br><span class="line">criteria.andAgeGreaterThan(20);</span><br></pre></td></tr></table></figure><p>这个示例代码中，首先创建一个 EmpExample 对象，然后调用 createCriteria() 方法创建一个 Criteria 对象，使用 andNameEqualTo(“Tom”) 方法和 andAgeGreaterThan(20) 方法设置查询条件，表示查询名称为 Tom 并且年龄大于 20 的数据。其中Criteria是内部类。<br>除了设置查询条件之外，还可以通过 setOrderByClause() 方法设置查询结果的排序方式，通过 setDistinct() 方法设置查询结果是否去重。最后，可以通过调用 empMapper.selectByExample(example) 方法执行查询操作，获取查询结果列表。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688472828411-60ffd7e0-98c9-44f1-a245-fe4adad4e778.png#averageHue=%233c4144&amp;clientId=u25015969-4d62-4&amp;from=paste&amp;height=362&amp;id=ub36475a5&amp;originHeight=453&amp;originWidth=551&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=40207&amp;status=done&amp;style=none&amp;taskId=ufcf6ef16-df2c-4ba8-a361-5f1d5ed75b9&amp;title=&amp;width=440.8" alt="image.png">其实还有一些内部类，在使用的时候可以通过图来快速查看。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688472719439-4c5f8b0a-b6f8-47f9-af20-38bb50934042.png#averageHue=%233c4242&amp;clientId=u25015969-4d62-4&amp;from=paste&amp;height=375&amp;id=ubc2c4168&amp;originHeight=469&amp;originWidth=558&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=47881&amp;status=done&amp;style=none&amp;taskId=u0162f579-9579-4c01-aa03-7b36c40064f&amp;title=&amp;width=446.4" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.int insertSelective(Emp record)：选择性地插入一条记录到 Emp 表中，只插入指定属性不为 null 的字段。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">EmpMapper empMapper = sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"></span><br><span class="line">// 查询操作</span><br><span class="line">EmpExample example = new EmpExample();</span><br><span class="line">example.createCriteria().andNameEqualTo(&quot;Tom&quot;);</span><br><span class="line">List&lt;Emp&gt; empList = empMapper.selectByExample(example);</span><br><span class="line"></span><br><span class="line">// 插入操作</span><br><span class="line">Emp emp = new Emp();</span><br><span class="line">emp.setName(&quot;Jerry&quot;);</span><br><span class="line">emp.setAge(30);</span><br><span class="line">int rows = empMapper.insert(emp);</span><br><span class="line"></span><br><span class="line">// 更新操作</span><br><span class="line">Emp emp = new Emp();</span><br><span class="line">emp.setId(1);</span><br><span class="line">emp.setName(&quot;Tom&quot;);</span><br><span class="line">int rows = empMapper.updateByPrimaryKey(emp);</span><br><span class="line"></span><br><span class="line">// 删除操作</span><br><span class="line">int rows = empMapper.deleteByPrimaryKey(1);</span><br></pre></td></tr></table></figure><h4 id="分页功能；">分页功能；</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688467784015-e3f4255f-74c4-4104-b1c0-4d6d725cc6af.png#averageHue=%23fbfbfa&amp;clientId=u378e3c4c-7292-4&amp;from=paste&amp;height=98&amp;id=u21bfceb8&amp;originHeight=123&amp;originWidth=305&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=24673&amp;status=done&amp;style=none&amp;taskId=u0e79f71a-6dd2-4a0c-896c-ffe26862945&amp;title=&amp;width=244" alt="image.png"><br>在pom.xml中添加分页插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">        &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;&lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br></pre></td></tr></table></figure><p>可以通过IDEA搜索获取插件的地址<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688468705713-fca2e56f-8e44-439f-8706-467ae1d38c42.png#averageHue=%23c1b040&amp;clientId=u378e3c4c-7292-4&amp;from=paste&amp;height=98&amp;id=ud86358a9&amp;originHeight=122&amp;originWidth=862&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=15158&amp;status=done&amp;style=none&amp;taskId=uf8a27513-52c4-4f2b-9024-a2ac900ba32&amp;title=&amp;width=689.6" alt="image.png"></p><h4 id="开启分页查询：PageHelper-startPage-1-4">开启分页查询：PageHelper.startPage(1,4);</h4><p><strong>PageHelper.startPage(1,4) 是一个 Mybatis 分页插件的方法，它的作用是在执行查询之前设置分页参数，表示从第 1 页开始，每页显示 4 条记录。PageHelper 会自动拦截查询语句，添加 limit 子句，实现物理分页</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public  void  testPage() throws IOException &#123;</span><br><span class="line">       InputStream is =  Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">       SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new</span><br><span class="line">               SqlSessionFactoryBuilder();</span><br><span class="line">       SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);</span><br><span class="line">       SqlSession sqlSession = sqlSessionFactory.openSession(true);</span><br><span class="line">       EmpMapper emp = sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">       //查询功能前开启分页</span><br><span class="line">       Page&lt;Object&gt; page = PageHelper.startPage(1,4);</span><br><span class="line">       List&lt;Emp&gt; list = emp.selectByExample(null);</span><br><span class="line">       System.out.println(list);</span><br><span class="line">       System.out.println(page);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>显示的结果为：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">19:36:56.157 [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - Checked out connection 417301556 from pool.</span><br><span class="line">19:36:56.159 [main] DEBUG com.example.demo.mapper.EmpMapper.selectByExample_COUNT - ==&gt;  Preparing: SELECT count(0) FROM t_emp</span><br><span class="line">19:36:56.180 [main] DEBUG com.example.demo.mapper.EmpMapper.selectByExample_COUNT - ==&gt; Parameters: </span><br><span class="line">19:36:56.197 [main] DEBUG com.example.demo.mapper.EmpMapper.selectByExample_COUNT - &lt;==      Total: 1</span><br><span class="line">19:36:56.199 [main] DEBUG com.example.demo.mapper.EmpMapper.selectByExample - ==&gt;  Preparing: select emp_id, emp_name, age, gender, dept_id from t_emp LIMIT ?</span><br><span class="line">19:36:56.199 [main] DEBUG com.example.demo.mapper.EmpMapper.selectByExample - ==&gt; Parameters: 4(Integer)</span><br><span class="line">19:36:56.202 [main] DEBUG com.example.demo.mapper.EmpMapper.selectByExample - &lt;==      Total: 4</span><br><span class="line">Page&#123;count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=4, pages=1, reasonable=false, pageSizeZero=false&#125;[Emp&#123;empId=1, empName=&#x27;张三&#x27;, age=20, gender=&#x27;男&#x27;, deptId=1&#125;, Emp&#123;empId=2, empName=&#x27;李四&#x27;, age=21, gender=&#x27;女&#x27;, deptId=2&#125;, Emp&#123;empId=3, empName=&#x27;王五&#x27;, age=22, gender=&#x27;男&#x27;, deptId=3&#125;, Emp&#123;empId=4, empName=&#x27;赵六&#x27;, age=23, gender=&#x27;女&#x27;, deptId=1&#125;]</span><br><span class="line">Page&#123;count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=4, pages=1, reasonable=false, pageSizeZero=false&#125;[Emp&#123;empId=1, empName=&#x27;张三&#x27;, age=20, gender=&#x27;男&#x27;, deptId=1&#125;, Emp&#123;empId=2, empName=&#x27;李四&#x27;, age=21, gender=&#x27;女&#x27;, deptId=2&#125;, Emp&#123;empId=3, empName=&#x27;王五&#x27;, age=22, gender=&#x27;男&#x27;, deptId=3&#125;, Emp&#123;empId=4, empName=&#x27;赵六&#x27;, age=23, gender=&#x27;女&#x27;, deptId=1&#125;]</span><br><span class="line"></span><br><span class="line">进程已结束,退出代码0</span><br><span class="line">//可以看出显示的list被分页显示了。</span><br><span class="line">//查询结果通过 selectByExample() 方法获取，这个方法的参数是一个空的 Example 对象，表示查询所有数据。查询结果是一个 Emp 对象列表。</span><br><span class="line">//最后，分页信息可以通过输出 Page 对象来获取。Page 是 PageHelper 插件提供的一个分页信息类，它包含了当前页码、每页数据条数、总数据条数等分页信息。在这个示例代码中，通过输出 page 对象来获取分页信息。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为什么输出的list会有多余的Pagr信息<br>在这个示例代码中，输出的 list 中包含了多余的 Page 信息，是因为 PageHelper.startPage() 方法返回的是一个 Page 对象，这个 Page 对象包含了分页信息和查询结果列表。<br>因此，在查询操作完成之后，如果直接输出查询结果列表，会同时输出 Page 对象的信息和查询结果列表的信息。如果只想输出查询结果列表，可以通过调用 Page 对象的 getList() 方法来获取查询结果列表，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Emp&gt; list = emp.selectByExample(null);</span><br><span class="line">Page&lt;Object&gt; page = PageHelper.startPage(1, 4);</span><br><span class="line">List&lt;Emp&gt; resultList = page.getResult();</span><br><span class="line">System.out.println(resultList);</span><br></pre></td></tr></table></figure><p>在这个示例代码中，先调用 emp.selectByExample(null) 方法获取查询结果列表，然后再调用 Page 对象的 getResult() 方法获取查询结果列表。这样就可以避免输出多余的 Page 信息。</p><h4 id="PageInfo">PageInfo&lt;&gt;</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">PageInfo&lt;T&gt; 是 MyBatis 分页插件 PageHelper 提供的一个分页信息类，用于封装分页信息和查询结果列表。</span><br><span class="line"></span><br><span class="line">PageInfo&lt;T&gt; 类包含以下属性：</span><br><span class="line"></span><br><span class="line">pageNum：当前页码。</span><br><span class="line"></span><br><span class="line">pageSize：每页显示的数据条数。</span><br><span class="line"></span><br><span class="line">size：当前页的实际数据条数。</span><br><span class="line"></span><br><span class="line">startRow：当前页第一条数据的行号。</span><br><span class="line"></span><br><span class="line">endRow：当前页最后一条数据的行号。</span><br><span class="line"></span><br><span class="line">total：总数据条数。</span><br><span class="line"></span><br><span class="line">pages：总页数。</span><br><span class="line"></span><br><span class="line">list：查询结果列表。</span><br><span class="line"></span><br><span class="line">prePage：上一页页码。</span><br><span class="line"></span><br><span class="line">nextPage：下一页页码。</span><br><span class="line"></span><br><span class="line">isFirstPage：是否为第一页。</span><br><span class="line"></span><br><span class="line">isLastPage：是否为最后一页。</span><br><span class="line"></span><br><span class="line">hasPreviousPage：是否有上一页。</span><br><span class="line"></span><br><span class="line">hasNextPage：是否有下一页。</span><br><span class="line"></span><br><span class="line">navigatePages：导航页码数。</span><br><span class="line"></span><br><span class="line">navigatepageNums：所有导航页号。</span><br><span class="line"></span><br><span class="line">PageInfo&lt;T&gt; 类常用的方法有：</span><br><span class="line"></span><br><span class="line">PageInfo(List&lt;T&gt; list, int navigatePages)：构造方法，用于创建一个 PageInfo 对象。</span><br><span class="line"></span><br><span class="line">getPageNum()：获取当前页码。</span><br><span class="line"></span><br><span class="line">getPageSize()：获取每页显示的数据条数。</span><br><span class="line"></span><br><span class="line">getSize()：获取当前页的实际数据条数。</span><br><span class="line"></span><br><span class="line">getStartRow()：获取当前页第一条数据的行号。</span><br><span class="line"></span><br><span class="line">getEndRow()：获取当前页最后一条数据的行号。</span><br><span class="line"></span><br><span class="line">getTotal()：获取总数据条数。</span><br><span class="line"></span><br><span class="line">getPages()：获取总页数。</span><br><span class="line"></span><br><span class="line">getList()：获取查询结果列表。</span><br><span class="line"></span><br><span class="line">getPrePage()：获取上一页页码。</span><br><span class="line"></span><br><span class="line">getNextPage()：获取下一页页码。</span><br><span class="line"></span><br><span class="line">isFirstPage()：判断是否为第一页。</span><br><span class="line"></span><br><span class="line">isLastPage()：判断是否为最后一页。</span><br><span class="line"></span><br><span class="line">hasPreviousPage()：判断是否有上一页。</span><br><span class="line"></span><br><span class="line">hasNextPage()：判断是否有下一页。</span><br><span class="line"></span><br><span class="line">getNavigatePages()：获取导航页码数。</span><br><span class="line"></span><br><span class="line">getNavigatepageNums()：获取所有导航页号。</span><br></pre></td></tr></table></figure><p>输出的信息”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PageInfo&#123;pageNum=1, pageSize=4, size=4, startRow=1, endRow=4, total=4, pages=1,</span><br><span class="line">list=Page&#123;count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=4, pages=1,</span><br><span class="line">reasonable=false, pageSizeZero=false&#125;</span><br><span class="line">[Emp&#123;empId=1, empName=&#x27;张三&#x27;, age=20, gender=&#x27;男&#x27;, deptId=1&#125;,</span><br><span class="line">Emp&#123;empId=2, empName=&#x27;李四&#x27;, age=21, gender=&#x27;女&#x27;, deptId=2&#125;, Emp&#123;empId=3, </span><br><span class="line">empName=&#x27;王五&#x27;, age=22, gender=&#x27;男&#x27;, deptId=3&#125;, Emp&#123;empId=4, empName=&#x27;赵六&#x27;,</span><br><span class="line">age=23, gender=&#x27;女&#x27;, deptId=1&#125;], prePage=0, nextPage=0, isFirstPage=true, </span><br><span class="line">isLastPage=true, hasPreviousPage=false, hasNextPage=false, navigatePages=5, </span><br><span class="line">navigateFirstPage=1, navigateLastPage=1, navigatepageNums=[1]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>Spring:</h1><h4 id="spring-Framework简介：">spring Framework简介：</h4><p><a href="https://blog.csdn.net/weixin_46081816/article/details/123116901">SpringFramework教程_springframework的教程在官网哪里_疯了的程序员的博客-CSDN博客</a><br><a href="https://blog.csdn.net/pedro7k/article/details/115415675">Java中的面向切面编程（AOP）_切面java_pedro7k的博客-CSDN博客</a></p><h4 id="Spring-IOC简介：">Spring IOC简介：</h4><p>Spring IOC 是 Spring 框架的核心，它是一种实现了 IoC（Inversion of Control，控制反转）原则的容器，负责创建、配置、管理和装配应用程序中的对象（称为 bean）<br><a href="https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html">5. The IoC container</a><br>。IoC 原则是指将对象的依赖关系（即它们需要协作的其他对象）交由外部容器或框架来设置，而不是由对象自己控制，从而实现对象之间的松耦合和动态绑定<br><a href="https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring">Just a moment…</a><br>Spring IOC 容器有两种类型：BeanFactory 和 ApplicationContext。BeanFactory 是最基本的容器，提供了依赖注入（Dependency Injection，DI）的功能，即根据配置元数据（可以是 XML、注解或 Java 代码）来注入 bean 的属性或构造参数<br><a href="https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html">5. The IoC container</a><br>。ApplicationContext 是 BeanFactory 的子接口，提供了更多的高级功能，如 AOP 集成、消息资源处理、事件发布等<a href="https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html">5. The IoC container</a>。</p><h4 id="Spring-DI-简介：">Spring DI 简介：</h4><p><a href="https://juejin.cn/post/6959753065297608711">Spring Boot注解全攻略(四)：@Autowired - 掘金</a><br>Spring DI（Dependency Injection，依赖注入）是 Spring Framework 的核心之一，它是实现 Spring IOC 的一种方式，用于解决对象之间的依赖关系。Spring DI 通过将对象之间的依赖关系的控制权反转给容器，来解决这些问题。具体来说，它在对象中定义依赖关系的接口，容器则负责实现这些接口并将实现注入到对象中</p><h4 id="Autowired注解详解">@Autowired注解详解</h4><p><a href="https://blog.csdn.net/weixin_45755816/article/details/118654961">@Autowired注解详解——超详细易懂_子时不睡的博客-CSDN博客</a><br><a href="https://juejin.cn/post/6959753065297608711">Spring Boot注解全攻略(四)：@Autowired - 掘金</a></p><h4 id="IOC容器在Spirng中的实现：">IOC容器在Spirng中的实现：</h4><p>基于XML的实现<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688519520570-48f60a06-3c87-4d24-8461-0d81d7aaded3.png#averageHue=%23faf9f6&amp;clientId=u25015969-4d62-4&amp;from=paste&amp;height=108&amp;id=uadf55962&amp;originHeight=135&amp;originWidth=454&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=31539&amp;status=done&amp;style=none&amp;taskId=ucf41a50b-9c9b-4f1d-a0e9-16f546edf4c&amp;title=&amp;width=363.2" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);</span><br></pre></td></tr></table></figure><p>解释：<br>ClassPathXmlApplicationContext 类是 Spring 框架提供的一个实现类，它实现了 ApplicationContext 接口，用于创建和管理 Spring 容器。ClassPathXmlApplicationContext 类的构造器接受一个或多个字符串参数，表示要加载的 XML 配置文件的路径。这些路径是相对于类路径（classpath）的根目录的路径（也就是下图中的classes目录），如果以 / 开头，则表示相对于类路径的根目录，否则表示相对于当前类所在的包。在这行代码中，传入了一个字符串参数 “application.xml”，表示要加载类路径根目录下的 application.xml 文件，该文件定义了 Spring 容器中的 bean。通过这样的方式，就可以创建一个 Spring 容器，并根据 XML 配置文件来初始化和管理 bean。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688521560666-80ac8ae4-d4a3-4d2d-8c91-334fe069e83b.png#averageHue=%23412105&amp;clientId=u25015969-4d62-4&amp;from=paste&amp;height=165&amp;id=u376387fd&amp;originHeight=206&amp;originWidth=334&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=8596&amp;status=done&amp;style=none&amp;taskId=ub730a5b6-c25f-4fb1-9908-28be2b46f06&amp;title=&amp;width=267.2" alt="image.png"><br>其实上面的代码可以改成下面的也可以正常运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;/ application.xml&quot;);</span><br></pre></td></tr></table></figure><h4 id="理解相对路径：">理解相对路径：</h4><p>在 Java 项目中，相对路径是指相对于某个参照点的路径，而不是绝对路径。相对路径的好处是可以避免硬编码文件的位置，使得代码更加灵活和可移植。相对路径的参照点可以有以下几种：</p><p>•  当前工作目录（working directory），即启动 Java 程序时所在的目录，或者通过 System.setProperty(“user.dir”, path) 方法设置的目录。如果使用 new File(path) 方法来访问文件，那么 path 就是相对于当前工作目录的路径。</p><p>•  当前类所在的包（package），即当前类的源文件所在的目录。如果使用 Class.getResource(path) 或 Class.getResourceAsStream(path) 方法来访问文件，那么 path 就是相对于当前类所在的包的路径，如果以 / 开头，则表示相对于类路径（classpath）的根目录。</p><p>•  类路径（classpath）的根目录，即 Java 程序加载类和资源的根目录。如果使用 ClassLoader.getResource(path) 或 ClassLoader.getResourceAsStream(path) 方法来访问文件，那么 path 就是相对于类路径的根目录的路径。</p><p>•  web 工程（web project）的根目录，即 web 工程部署到服务器上的根目录。如果使用 ServletContext.getResource(path) 或 ServletContext.getResourceAsStream(path) 方法来访问文件，那么 path 就是相对于 web 工程的根目录的路径。<br>也就是相对路径也不一定是相对与当前类所在的目录。</p><h4 id="获取bean的三种方法：">获取bean的三种方法：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688524352145-bbed48c4-4b9f-49fd-bc03-d572a3027197.png#averageHue=%23f9f8f4&amp;clientId=u25015969-4d62-4&amp;from=paste&amp;height=129&amp;id=uda18b195&amp;originHeight=161&amp;originWidth=665&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=78699&amp;status=done&amp;style=none&amp;taskId=u7546ee82-c37d-4698-81dd-fac681e2239&amp;title=&amp;width=532" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688524508058-a35f1e6a-8385-4dc9-b2fe-35f006b386f9.png#averageHue=%23f7f4e4&amp;clientId=u25015969-4d62-4&amp;from=paste&amp;height=60&amp;id=uc187c925&amp;originHeight=75&amp;originWidth=510&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=45670&amp;status=done&amp;style=none&amp;taskId=ue427ec23-92d3-40b9-bcc6-bd086110dbb&amp;title=&amp;width=408" alt="image.png">person是Student实现的接口，可以根据接口获取bean,当然这个接口只能有一个实现类。<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688524591560-ec1e07ae-2a22-40a0-beb4-3a0381331b21.png#averageHue=%23f6f5f1&amp;clientId=u25015969-4d62-4&amp;from=paste&amp;height=83&amp;id=u1459a351&amp;originHeight=104&amp;originWidth=678&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=63103&amp;status=done&amp;style=none&amp;taskId=ua96d2c56-915b-4fc7-93b1-8eab6045021&amp;title=&amp;width=542.4" alt="image.png"></p><h4 id="依赖注入setter注入：">依赖注入setter注入：</h4><h6 id="什么是依赖注入：">什么是依赖注入：</h6><p><a href="https://blog.csdn.net/taijianyu/article/details/2338311">什么是依赖注入_taijianyu的博客-CSDN博客</a><br>。在 Spring 中，依赖注入是指 Spring 容器负责创建和管理 bean（即 Spring 容器中管理的对象），并根据 bean 之间的依赖关系，将依赖的 bean 注入到需要它的 bean 中，从而实现控制反转（Inversion of Control，IoC），即控制权由原来的 bean 转移到了 Spring 容器，从而降低了 bean 之间的耦合度，提高了代码的可维护性和可测试性。Spring 支持基于 XML、注解和 Java 代码的三种依赖注入方式，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    &lt;bean id=&quot;studentTwo&quot; class=&quot;com.example.demo.pojo.Student&quot;&gt;</span><br><span class="line">               &lt;constructor-arg value=&quot;1002&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">               &lt;constructor-arg value=&quot;李四&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">               &lt;constructor-arg value=&quot;33&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">               &lt;constructor-arg value=&quot;女&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;!--只有一个 &lt;constructor-arg &gt;匹配的只有一个有参构造的构造器--&gt;</span><br></pre></td></tr></table></figure><h4 id="通过属性赋值，赋值为空：">通过属性赋值，赋值为空：</h4><p><property name="sex" value="null"></property>这给sex属性赋值为null字符串；<br><property name="sex" ><null/></property>这给sex属性赋值为空。</p><h4 id="array-标签"><array>标签</h4><p>在 Spring Framework 的 XML 配置文件中，可以使用 <array> 标签来定义一个数组类型的属性值。<array> 标签可以包含多个 <value> 或 <ref> 子标签，每个子标签表示数组中的一个元素。<br>例如，假设我们有一个 Person 类，它包含一个 hobbies 属性，表示一个人的爱好。hobbies 属性是一个字符串数组类型的属性。我们可以在 XML 配置文件中使用 <array> 标签来定义这个数组类型的属性值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;person&quot; class=&quot;com.example.Person&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;hobbies&quot;&gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">            &lt;value&gt;篮球&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;足球&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;游泳&lt;/value&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>这个配置将会创建一个 Person 实例，并将 “篮球”、“足球” 和 “游泳” 作为 hobbies 属性的值。在这个配置中，<array> 标签包含了三个 <value> 子标签，每个子标签表示一个字符串类型的数组元素。<br>除了 <value> 子标签外，<array> 标签还可以包含 <ref> 子标签，用于引用其他 Bean 的实例作为数组元素。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;basketball&quot; class=&quot;com.example.Hobby&quot; /&gt;</span><br><span class="line">&lt;bean id=&quot;football&quot; class=&quot;com.example.Hobby&quot; /&gt;</span><br><span class="line">&lt;bean id=&quot;swimming&quot; class=&quot;com.example.Hobby&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;person&quot; class=&quot;com.example.Person&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;hobbies&quot;&gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">            &lt;ref bean=&quot;basketball&quot; /&gt;</span><br><span class="line">            &lt;ref bean=&quot;football&quot; /&gt;</span><br><span class="line">            &lt;ref bean=&quot;swimming&quot; /&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>这个配置定义了三个 Hobby 类型的 Bean，并将它们分别命名为 “basketball”、“football” 和 “swimming”。然后，它又在 <array> 标签中使用了三个 <ref> 子标签，分别引用了这三个 Bean 的实例，作为 Person 类的 hobbies 属性的值。</p><h4 id="集合类型的依赖注入：依赖注入中util标签的引用和List和Map集和的使用：其实所缺的命名空间的绑定可以在IDEA中自动补充的">集合类型的依赖注入：依赖注入中util标签的引用和List和Map集和的使用：其实所缺的命名空间的绑定可以在IDEA中自动补充的</h4><p>util 是 Spring 框架提供的一个命名空间，用于提供一些常用的工具和辅助类。在 Spring 的 XML 配置文件中，我们可以使用 <a href="util:*">util:*</a> 标签来引用 util 命名空间中的定义，并将其应用到 Bean 的定义中。<br>在 Spring Framework 的 XML 配置文件中，可以使用 <list> 标签来定义一个列表类型的属性值。<list> 标签可以包含多个 <value> 或 <ref> 子标签，每个子标签表示列表中的一个元素。<br>例如，假设我们有三个 Student 类型的 Bean，分别命名为 “studentOne”、“studentTwo” 和 “studentThree”。我们可以在 XML 配置文件中使用 <a href="util:list">util:list</a> 标签来定义这三个 Bean 实例的列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;studentOne&quot; class=&quot;com.example.Student&quot; /&gt;</span><br><span class="line">&lt;bean id=&quot;studentTwo&quot; class=&quot;com.example.Student&quot; /&gt;</span><br><span class="line">&lt;bean id=&quot;studentThree&quot; class=&quot;com.example.Student&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;util:list id=&quot;students&quot;&gt;</span><br><span class="line">    &lt;ref bean=&quot;studentOne&quot; /&gt;</span><br><span class="line">    &lt;ref bean=&quot;studentTwo&quot; /&gt;</span><br><span class="line">    &lt;ref bean=&quot;studentThree&quot; /&gt;</span><br><span class="line">&lt;/util:list&gt;</span><br></pre></td></tr></table></figure><p>这个配置将会创建一个列表类型的 Bean，将 “studentOne”、“studentTwo” 和 “studentThree” 作为列表元素。在这个配置中，<a href="util:list">util:list</a> 标签包含了三个 <ref> 子标签，每个子标签表示一个引用类型的列表元素。<br>除了 <ref> 子标签外，<a href="util:list">util:list</a> 标签还可以包含 <value> 子标签，用于定义值类型的列表元素。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;util:list id=&quot;numbers&quot;&gt;</span><br><span class="line">    &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">    &lt;value&gt;2&lt;/value&gt;</span><br><span class="line">    &lt;value&gt;3&lt;/value&gt;</span><br><span class="line">&lt;/util:list&gt;</span><br></pre></td></tr></table></figure><p>这个配置将会创建一个列表类型的 Bean，将 1、2 和 3 作为列表元素，它们都是整数类型的值。在这个配置中，<a href="util:list">util:list</a> 标签包含了三个 <value> 子标签，每个子标签表示一个整数类型的值类型的列表元素。<br><a href="util:list">util:list</a> 是 Spring Framework 中的一个实用工具标签，用于定义列表类型的 Bean。为了使用 <a href="util:list">util:list</a> 标签，我们需要在 XML 配置文件中导入 Spring 的 util 命名空间。具体方法是在 XML 文件的根标签中添加xmlns:util=“<a href="http://www.springframework.org/schema/util">http://www.springframework.org/schema/util</a>” 命名空间声明，同时在<br>xsi:schemaLocation中添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://www.springframework.org/schema/util</span><br><span class="line">                           http://www.springframework.org/schema/util/spring-util.xsd&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:util=&quot;http://www.springframework.org/schema/util&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">                           http://www.springframework.org/schema/util</span><br><span class="line">                           http://www.springframework.org/schema/util/spring-util.xsd&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;</span><br><span class="line">       </span><br><span class="line">    &lt;!-- 这里可以定义 Bean --&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;util:list id=&quot;students&quot;&gt;</span><br><span class="line">        &lt;ref bean=&quot;studentOne&quot; /&gt;</span><br><span class="line">        &lt;ref bean=&quot;studentTwo&quot; /&gt;</span><br><span class="line">        &lt;ref bean=&quot;studentThree&quot; /&gt;</span><br><span class="line">    &lt;/util:list&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/lengxiao1993/article/details/77914155?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-77914155-blog-114280229.235%5Ev38%5Epc_relevant_yljh&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-77914155-blog-114280229.235%5Ev38%5Epc_relevant_yljh&amp;utm_relevant_index=10">详解 xml 文件头部的 xmlns:xsi_萧萧九宸的博客-CSDN博客</a><br>xml：命名空间，防止命名冲突<br>xsi是XML Schema Instance的缩写，它是一个预定义的命名空间前缀，用于引用XML Schema的实例。 xsi:schemaLocation是一个预定义的属性，用于指定XML文档所引用的XML Schema的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">       public  void TestList() &#123;</span><br><span class="line">           ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);</span><br><span class="line">           List&lt;Student&gt; students = (List&lt;Student&gt;) context.getBean(&quot;students&quot;);</span><br><span class="line">           for (Student student : students) &#123;</span><br><span class="line">               System.out.println(student);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>测试结果：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688540312902-5751d031-2dfb-4087-9bc5-4e3d96105748.png#averageHue=%23130f0c&amp;clientId=ua77d9b4f-0672-4&amp;from=paste&amp;height=62&amp;id=u3c89fbd3&amp;originHeight=77&amp;originWidth=946&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=20364&amp;status=done&amp;style=none&amp;taskId=u268ab9a1-10cb-469d-b722-3809d789332&amp;title=&amp;width=756.8" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--map集合类型的bean--&gt;</span><br><span class="line">&lt;util:map id=&quot;teacherMap&quot;&gt;</span><br><span class="line">   &lt;entry&gt;</span><br><span class="line">       &lt;key&gt;</span><br><span class="line">           &lt;value&gt;10010&lt;/value&gt;</span><br><span class="line">       &lt;/key&gt;</span><br><span class="line">       &lt;ref bean=&quot;teacherOne&quot;&gt;&lt;/ref&gt;</span><br><span class="line">   &lt;/entry&gt;</span><br><span class="line">   &lt;entry&gt;</span><br><span class="line">       &lt;key&gt;</span><br><span class="line">           &lt;value&gt;10086&lt;/value&gt;</span><br><span class="line">       &lt;/key&gt;</span><br><span class="line">       &lt;ref bean=&quot;teacherTwo&quot;&gt;&lt;/ref&gt;</span><br><span class="line">   &lt;/entry&gt;</span><br><span class="line">&lt;/util:map&gt;</span><br></pre></td></tr></table></figure><p>总结：其实<map>中的键值对还可以这样写：  <entry key="1" value="游泳"/>（当值为字符串的时候）<br>由于<value> 标签中的内容会被解析为字符串类型，当值不为字符串的时候用<ref >或者<br><value-ref/>标签， <ref bean="teacherOne"></ref>和&lt;value-ref=“teacherOne”/&gt;是等价的。</p><h4 id="依赖注入之p命名空间：">依赖注入之p命名空间：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688542214770-39434523-eeeb-46d1-8208-8ddb7d9a11ec.png#averageHue=%23121923&amp;clientId=ua77d9b4f-0672-4&amp;from=paste&amp;height=182&amp;id=u43edee01&amp;originHeight=228&amp;originWidth=1077&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=38429&amp;status=done&amp;style=none&amp;taskId=u7cb701c5-f79b-40f4-8d4b-c1bd9d68933&amp;title=&amp;width=861.6" alt="image.png"><br>p:前缀是一个命名空间前缀，用于简化property元素的写法，它表示该属性是一个property元素的简写形式。<br>添加后配置文件新增的内容：（红线部分）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688542371493-97cb2579-faf2-413e-ad5b-ef52d389f4b6.png#averageHue=%23121220&amp;clientId=ua77d9b4f-0672-4&amp;from=paste&amp;height=214&amp;id=u2eb14b9f&amp;originHeight=267&amp;originWidth=824&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=56931&amp;status=done&amp;style=none&amp;taskId=u0d593b70-ed69-4948-9bf4-15d8c4918b6&amp;title=&amp;width=659.2" alt="image.png"><br>依赖注入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id = &quot;studentSix&quot; class=&quot;com.example.demo.pojo.Student&quot; p:id=&quot;1005&quot; p:name=&quot;小明&quot;</span><br><span class="line">          p:sex=&quot;女&quot; p:clazz-ref=&quot;clazzOne&quot; p:hobbies=&quot;游泳,跑步,阅读&quot; &gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public  void TestP() &#123;</span><br><span class="line">       ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);</span><br><span class="line">       Student studentSix = context.getBean(&quot;studentSix&quot;, Student.class);</span><br><span class="line">       System.out.println(studentSix);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student&#123;id=1005, name=&#x27;小明&#x27;, age=null, sex=&#x27;女&#x27;, clazz=Clazz&#123;clazzId=3333, clazzName=&#x27;最强王者班&#x27;, students=null&#125;, hobbies=[游泳, 跑步, 阅读], teacherMap=null&#125;</span><br><span class="line">//没有赋值的属性都是null</span><br></pre></td></tr></table></figure><h4 id="特殊情况p语法糖配置的属性为List或者Map的情况：">特殊情况p语法糖配置的属性为List或者Map的情况：</h4><p>如果 p:hobbies 是一个 List 或 Map 类型的属性，我们可以使用 <a href="util:list">util:list</a> 或 <a href="util:map">util:map</a> 标签来配置它的属性值。例如，假设 com.example.demo.pojo.Student 类中的 hobbies 属性是一个 List<String> 类型的列表，我们可以将 <bean> 标签修改为以下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;studentSix&quot; class=&quot;com.example.demo.pojo.Student&quot;</span><br><span class="line">      p:id=&quot;1005&quot; p:name=&quot;小明&quot; p:sex=&quot;女&quot; p:clazz-ref=&quot;clazzOne&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;hobbies&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;游泳&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;跑步&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;阅读&lt;/value&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用了 <property> 标签来设置 Student 类中的 hobbies 属性。<property> 标签中的 name 属性指定了要设置的属性名，而 <a href="util:list">util:list</a> 标签中包含了若干个 <value> 标签，每个 <value> 标签的文本内容即为列表中的一个元素。在这个例子中，<a href="util:list">util:list</a> 标签中包含了三个 <value> 标签，分别设置了 hobbies 列表的三个元素为 “游泳”、“跑步” 和 “阅读”。<br>如果 p:hobbies 是一个 Map 类型的属性，我们可以使用 <a href="util:map">util:map</a> 标签来配置它的属性值。例如，假设 com.example.demo.pojo.Student 类中的 hobbies 属性是一个 Map&lt;String, String&gt; 类型的映射表，我们可以将 <bean> 标签修改为以下形式：<br>在这个例子中，我们同样使用了 <property> 标签来设置 Student 类中的 hobbies 属性。<a href="util:map">util:map</a> 标签中包含了若干个 <entry> 标签，每个 <entry> 标签分别表示一个键值对。在这个例子中，我们设置了 hobbies 映射表中的三个键值对，分别为 “1”-“游泳”、“2”-“跑步” 和 “3”-“阅读”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;studentSix&quot; class=&quot;com.example.demo.pojo.Student&quot;</span><br><span class="line">      p:id=&quot;1005&quot; p:name=&quot;小明&quot; p:sex=&quot;女&quot; p:clazz-ref=&quot;clazzOne&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;hobbies&quot;&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=&quot;1&quot; value=&quot;游泳&quot;/&gt;</span><br><span class="line">            &lt;entry key=&quot;2&quot; value=&quot;跑步&quot;/&gt;</span><br><span class="line">            &lt;entry key=&quot;3&quot; value=&quot;阅读&quot;/&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h4 id="Spring管理数据源：druid事例">Spring管理数据源：druid事例</h4><p>导入依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- MySQL驱动    --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;8.0.16&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 数据源    --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.0.31&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在您提供的代码片段中，包含了两个 Maven 依赖项，分别是 mysql-connector-java 和 druid，它们用于在 Java 应用程序中使用 MySQL 数据库和数据源。<br>具体来说，mysql-connector-java 是 MySQL 官方提供的 Java JDBC 驱动程序，用于连接 MySQL 数据库。在 Maven 项目中添加该依赖项后，我们可以在 Java 代码中使用 com.mysql.cj.jdbc.Driver 类来加载 MySQL JDBC 驱动程序，从而连接到 MySQL 数据库。<br>druid 是阿里巴巴提供的一个高性能 JDBC 连接池框架，它提供了许多高级功能，例如连接池缓存、连接池监控、SQL 防火墙等。在 Maven 项目中添加该依赖项后，我们可以在 Java 代码中使用 com.alibaba.druid.pool.DruidDataSource 类来创建一个 Druid 数据源，从而在应用程序中管理 JDBC 连接池。<br>设置配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;datasource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;driverClassName&quot;  value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot;  value=&quot;jdbc:mysql://localhost:3306/myemployees?serverTimezone=UTC&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot;  value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot;  value=&quot;A86789234&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>配置文件都是关于数据库连接的文件，一般这些是放在一个数据库配置文件中的。其实可以通过jdbc资源配置文件配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.user=root</span><br><span class="line">jdbc.password=A86789234</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/myemployees?serverTimezone=UTC</span><br><span class="line">jdbc.driver=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;context:property-placeholder location=&quot;jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt;</span><br><span class="line">    &lt;bean id=&quot;datasource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;driverClassName&quot;  value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot;  value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot;  value=&quot;$&#123;jdbc.user&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot;  value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   @Test</span><br><span class="line">    public  void  testDatasource() throws SQLException &#123;</span><br><span class="line">        ClassPathXmlApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;spring-datasource.xml&quot;);</span><br><span class="line">        //也可以通过其父类或者所实现的接口</span><br><span class="line">//        DataSource dataSource = ioc.getBean(DataSource.class);</span><br><span class="line">        DruidDataSource druidDataSource = ioc.getBean(DruidDataSource.class);</span><br><span class="line">        System.out.println(druidDataSource.getConnection());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">//输出结果：</span><br><span class="line">//com.mysql.cj.jdbc.ConnectionImpl@3e694b3f</span><br></pre></td></tr></table></figure><h4 id="bean的作用域：">bean的作用域：</h4><p>在 Spring 容器中，Bean 的作用域决定了 Bean 实例的生命周期和可见范围。Spring 提供了以下五种 Bean 作用域：</p><ol><li>singleton：单例模式。在整个 Spring 容器中，只会创建一个 Bean 实例，并在需要时共享该实例。默认情况下，所有未显式指定作用域的 Bean 都会使用单例模式。</li><li>prototype：原型模式。每次从容器中获取该 Bean 时，都会创建一个新的实例，并返回给调用者。</li><li>request：Web 应用程序中的请求作用域。在一次 HTTP 请求中，容器会为每个请求创建一个新的实例，并在请求结束时销毁该实例。</li><li>session：Web 应用程序中的会话作用域。在用户会话期间，容器会为每个会话创建一个新的实例，并在会话结束时销毁该实例。</li><li>global session：Web 应用程序中的全局会话作用域。与 session 作用域类似，但仅适用于 Portlet 环境。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;myBean&quot; class=&quot;com.example.MyBean&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">    &lt;!-- Bean 的配置信息 --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h4 id="1-在IOC容器中默认为单例-也即是scope默认为singleton">1.在IOC容器中默认为单例,也即是scope默认为singleton</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id = &quot;student&quot; class=&quot;com.example.demo.pojo.Student&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;id&quot; value=&quot;1009&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;钱九&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;age&quot; value=&quot;29&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  @Test</span><br><span class="line">    public void  testScope()</span><br><span class="line">    &#123;</span><br><span class="line">        ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;spring-scope.xml&quot;);</span><br><span class="line">        Student student1 = ioc.getBean(Student.class);</span><br><span class="line">        Student student2 = ioc.getBean(Student.class);</span><br><span class="line">        System.out.println(student1);</span><br><span class="line">        System.out.println(&quot;-----------&quot;);</span><br><span class="line">        System.out.println(student2);</span><br><span class="line">        System.out.println(student1==student2);</span><br><span class="line">    &#125;</span><br><span class="line">//Student&#123;id=1009, name=&#x27;钱九&#x27;, age=29, sex=&#x27;女&#x27;, clazz=null, hobbies=null, teacherMap=null&#125;</span><br><span class="line">//-----------</span><br><span class="line">//Student&#123;id=1009, name=&#x27;钱九&#x27;, age=29, sex=&#x27;女&#x27;, clazz=null, hobbies=null, teacherMap=null&#125;</span><br><span class="line">//true</span><br></pre></td></tr></table></figure><p>2.设置为scope=“prototype”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id = &quot;student&quot; class=&quot;com.example.demo.pojo.Student&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;id&quot; value=&quot;1009&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;钱九&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;age&quot; value=&quot;29&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student&#123;id=1009, name=&#x27;钱九&#x27;, age=29, sex=&#x27;女&#x27;, clazz=null, hobbies=null, teacherMap=null&#125;</span><br><span class="line">-----------</span><br><span class="line">Student&#123;id=1009, name=&#x27;钱九&#x27;, age=29, sex=&#x27;女&#x27;, clazz=null, hobbies=null, teacherMap=null&#125;</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h4 id="bean的生命周期：">bean的生命周期：</h4><p><a href="https://juejin.cn/post/6866075598184906766">一篇文章让你彻底搞懂Bean后置处理器及执行时机 - 掘金</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.pojo;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">   private Integer id;</span><br><span class="line">   private String username;</span><br><span class="line">   private String password;</span><br><span class="line">   private Integer age;</span><br><span class="line">   public User() &#123;</span><br><span class="line">       System.out.println(&quot;生命周期1：实例化&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">   public User(Integer id, String username, String password, Integer age) &#123;</span><br><span class="line">       this.id = id;</span><br><span class="line">       this.username = username;</span><br><span class="line">       this.password = password; </span><br><span class="line">       this.age = age;</span><br><span class="line"> &#125;</span><br><span class="line">   public Integer getId() &#123; </span><br><span class="line">       return id;</span><br><span class="line"> &#125;</span><br><span class="line">   public void setId(Integer id) &#123;</span><br><span class="line">       System.out.println(&quot;生命周期2：依赖注入&quot;);</span><br><span class="line">       this.id = id;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">   public String getUsername() &#123; </span><br><span class="line">       return username;</span><br><span class="line"> &#125;</span><br><span class="line">   public void setUsername(String username) &#123; </span><br><span class="line">       this.username = username;</span><br><span class="line"> &#125;</span><br><span class="line">   public String getPassword() &#123; </span><br><span class="line">       return password;</span><br><span class="line"> &#125;</span><br><span class="line">   public void setPassword(String password) &#123; </span><br><span class="line">       this.password = password;</span><br><span class="line"> &#125;</span><br><span class="line">   public Integer getAge() &#123; </span><br><span class="line">       return age;</span><br><span class="line"> &#125;</span><br><span class="line">   public void setAge(Integer age) &#123; </span><br><span class="line">       this.age = age;</span><br><span class="line"> &#125;</span><br><span class="line">   @Override</span><br><span class="line">   public String toString() &#123; </span><br><span class="line">       return &quot;User&#123;&quot; +</span><br><span class="line">               &quot;id=&quot; + id +</span><br><span class="line">               &quot;, username=&#x27;&quot; + username + &#x27;\&#x27;&#x27; + </span><br><span class="line">               &quot;, password=&#x27;&quot; + password + &#x27;\&#x27;&#x27; + </span><br><span class="line">               &quot;, age=&quot; + age +</span><br><span class="line">               &#x27;&#125;&#x27;;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> public void  initMethod()</span><br><span class="line"> &#123;</span><br><span class="line">     System.out.println(&quot;生命周期3：初始化！&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">    public void  destroyMethod()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;生命周期4：销毁！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建</span><br><span class="line">    对象   init-method 和destroy-method分别表示初始化和摧毁时调用的方法--&gt;</span><br><span class="line">    &lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象    --&gt;</span><br><span class="line">    &lt;bean class=&quot;com.example.demo.pojo.User&quot; scope=&quot;prototype&quot; init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;id&quot; value=&quot;1009&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;钱九&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;age&quot; value=&quot;29&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  @Test</span><br><span class="line">    public  void  testLife()</span><br><span class="line">    &#123;</span><br><span class="line">        ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-lifetime.xml&quot;);</span><br><span class="line">            User user1 = ac.getBean(User.class);</span><br><span class="line">            User user2 = ac.getBean(User.class);</span><br><span class="line">            System.out.println(user1==user2);</span><br><span class="line">            ac.close();//刷新关闭容器关闭刷新</span><br><span class="line">    &#125;</span><br><span class="line">//生命周期1：实例化</span><br><span class="line">//生命周期2：依赖注入</span><br><span class="line">//生命周期3：初始化！</span><br><span class="line">//生命周期1：实例化</span><br><span class="line">//生命周期2：依赖注入</span><br><span class="line">//生命周期3：初始化！</span><br><span class="line">//false</span><br><span class="line">//20:52:59.913 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Closing org.springframework.context.support.ClassPathXmlApplicationContext@6b2fad11, started on Wed Jul 05 20:52:59 CST 2023</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那什么时候实例化呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象    --&gt;</span><br><span class="line">&lt;bean id=&quot;user&quot; class=&quot;com.example.demo.pojo.User&quot; scope=&quot;prototype&quot; init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;id&quot; value=&quot;1009&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;钱九&quot;&gt;&lt;/property&gt;</span><br><span class="line">     &lt;property name=&quot;age&quot; value=&quot;29&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> @Test</span><br><span class="line">    public  void  testLife()</span><br><span class="line">    &#123;</span><br><span class="line">        ConfigurableApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-lifetime.xml&quot;);</span><br><span class="line">//            User user1 = ac.getBean(User.class);</span><br><span class="line">           /* User user2 = ac.getBean(User.class);</span><br><span class="line">            System.out.println(user1==user2);</span><br><span class="line">            ac.close();*/</span><br><span class="line">    &#125;</span><br><span class="line">//无输出结果</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> @Test</span><br><span class="line">    public  void  testLife()</span><br><span class="line">    &#123;</span><br><span class="line">        ConfigurableApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-lifetime.xml&quot;);</span><br><span class="line">          User user1 = ac.getBean(User.class);</span><br><span class="line">           /* User user2 = ac.getBean(User.class);</span><br><span class="line">            System.out.println(user1==user2);</span><br><span class="line">            ac.close();*/</span><br><span class="line">    &#125;</span><br><span class="line">//生命周期1：实例化</span><br><span class="line">//生命周期2：依赖注入</span><br><span class="line">//生命周期3：初始化</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  @Test</span><br><span class="line">    public  void  testLife()</span><br><span class="line">    &#123;</span><br><span class="line">        ConfigurableApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-lifetime.xml&quot;);</span><br><span class="line">          User user1 = ac.getBean(User.class);</span><br><span class="line">            User user2 = ac.getBean(User.class);</span><br><span class="line">            System.out.println(user1==user2);</span><br><span class="line">            ac.close();</span><br><span class="line">    &#125;</span><br><span class="line">//生命周期1：实例化</span><br><span class="line">//生命周期2：依赖注入</span><br><span class="line">//生命周期3：初始化！</span><br><span class="line">//生命周期1：实例化</span><br><span class="line">//生命周期2：依赖注入</span><br><span class="line">//生命周期3：初始化！</span><br><span class="line">//false</span><br><span class="line">//21:51:58.077 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Closing org.springframework.context.support.ClassPathXmlApplicationContext@6b2fad11, started on Wed Jul 05 21:51:57 CST 2023</span><br><span class="line"></span><br><span class="line">//进程已结束,退出代码0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出多例模式（scope=“prototype”）是在或者bean对象时实例化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;com.example.demo.pojo.User&quot; scope=&quot;singleton&quot; init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot;&gt;</span><br><span class="line">       &lt;property name=&quot;id&quot; value=&quot;1009&quot;&gt;&lt;/property&gt;</span><br><span class="line">       &lt;property name=&quot;username&quot; value=&quot;钱九&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;age&quot; value=&quot;29&quot;&gt;&lt;/property&gt;</span><br><span class="line">       &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  @Test</span><br><span class="line">    public  void  testLife()</span><br><span class="line">    &#123;</span><br><span class="line">        ConfigurableApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-lifetime.xml&quot;);</span><br><span class="line">//          User user1 = ac.getBean(User.class);</span><br><span class="line">           /* User user2 = ac.getBean(User.class);</span><br><span class="line">            System.out.println(user1==user2);</span><br><span class="line">            ac.close();*/</span><br><span class="line">    &#125;</span><br><span class="line">//生命周期1：实例化</span><br><span class="line">//生命周期2：依赖注入</span><br><span class="line">//生命周期3：初始化！</span><br></pre></td></tr></table></figure><p>总结：这里可以看出单例为啥后面创建的类和第一个类的地址一样,单例模式在创建容器的时候实例化，依赖注入，初始化，随着容器的关闭而摧毁，多例模式在创建对象的时候实例化，依赖注入，初始化，容器关闭不会摧毁bean<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688565300195-fa73648e-ab3b-4fa5-a716-6c21979c83f1.png#averageHue=%23f2eedf&amp;clientId=u03b8032e-d2db-4&amp;from=paste&amp;height=42&amp;id=uacbe958a&amp;originHeight=53&amp;originWidth=637&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=36090&amp;status=done&amp;style=none&amp;taskId=u94654dea-0468-4695-99d0-cfddb2aae05&amp;title=&amp;width=509.6" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688561711858-4f5b5480-aec5-4dc9-9308-83fc4912b1d7.png#averageHue=%23f9f8f5&amp;clientId=u03b8032e-d2db-4&amp;from=paste&amp;height=93&amp;id=u11602db8&amp;originHeight=116&amp;originWidth=620&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=45923&amp;status=done&amp;style=none&amp;taskId=u60a7bcae-e924-4b64-a56c-5b04cbe6a6c&amp;title=&amp;width=496" alt="image.png"><br>在 Spring 容器中，每个 Bean 的生命周期包括以下三个阶段：</p><ol><li>实例化阶段：在这个阶段，容器会使用 Bean 的构造函数或工厂方法创建一个新的 Bean 实例。</li><li>初始化阶段：在这个阶段，容器会对 Bean 进行属性注入和其他初始化操作，例如调用 Bean 的 init-method 方法。</li><li>销毁阶段：在这个阶段，容器会销毁 Bean 实例，并在销毁前调用 Bean 的 destroy-method 方法进行清理操作。</li></ol><h4 id="bean的后置处理器：">bean的后置处理器：</h4><p>bean的后置处理器可以在生命周期的初始化前后添加额外的操作，需要实现BeanPostProcessor接口（有2个默认方法），<br>且配置到IOC容器中，需要注意的是，bean后置处理器不是单独针对某一个bean生效，而是针对IOC容<br>器中所有bean都会执行<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688566339927-81ed4340-966a-4a88-bedb-26c8d44fcf24.png#averageHue=%23eeebdd&amp;clientId=u03b8032e-d2db-4&amp;from=paste&amp;height=71&amp;id=u546492a2&amp;originHeight=89&amp;originWidth=635&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=61617&amp;status=done&amp;style=none&amp;taskId=u420ac884-47e3-4240-b82d-184ac46a1f3&amp;title=&amp;width=508" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"></span><br><span class="line">public class MybeanPostProcessor implements BeanPostProcessor &#123;</span><br><span class="line">    //初始化之前执行</span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;☆☆☆&quot; + beanName + &quot; = &quot; + bean);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">    //初始化之后执行</span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;★★★&quot; + beanName + &quot; = &quot; + bean);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- bean的后置处理器要放入IOC容器才能生效    --&gt;</span><br><span class="line">&lt;bean id=&quot;myBeanProcessor&quot; class=&quot;com.example.demo.pojo.MybeanPostProcessor&quot;/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    @Test</span><br><span class="line">    public  void  testProcessor()</span><br><span class="line">    &#123;</span><br><span class="line">        ConfigurableApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-lifetime.xml&quot;);</span><br><span class="line">        User user1 = ac.getBean(User.class);</span><br><span class="line">        System.out.println(user1);</span><br><span class="line">        ac.close();</span><br><span class="line">    &#125;</span><br><span class="line">  /*  生命周期1：实例化</span><br><span class="line">    生命周期2：依赖注入</span><br><span class="line">☆☆☆user = User&#123;id=1009, username=&#x27;钱九&#x27;, password=&#x27;123456&#x27;, age=29&#125;</span><br><span class="line">    生命周期3：初始化！</span><br><span class="line">        ★★★user = User&#123;id=1009, username=&#x27;钱九&#x27;, password=&#x27;123456&#x27;, age=29&#125;</span><br><span class="line">    User&#123;id=1009, username=&#x27;钱九&#x27;, password=&#x27;123456&#x27;, age=29&#125;</span><br><span class="line">22:13:39.564 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Closing org.springframework.context.support.ClassPathXmlApplicationContext@73f792cf, started on Wed Jul 05 22:13:39 CST 2023</span><br><span class="line"></span><br><span class="line">    进程已结束,退出代码0</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h4 id="接口的默认方法">接口的默认方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface MyInterface &#123;</span><br><span class="line">    // 抽象方法</span><br><span class="line">    void myMethod();</span><br><span class="line"></span><br><span class="line">    // 默认方法</span><br><span class="line">    default void myDefaultMethod() &#123;</span><br><span class="line">        // 方法体</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认方法使用default关键字进行声明， 接口的默认方法可以访问接口中的静态变量和静态方法，但是不能访问实现类中的成员变量和成员方法。当一个类实现了多个接口并且这些接口中都有相同名称的默认方法时，编译器会报错。此时需要在实现类中覆盖默认方法并指定具体的实现。接口的默认方法可以被实现类直接使用，也可以被实现类重写。  接口的默认方法可以被继承，如果一个子接口继承了一个父接口，并且重写了父接口中的默认方法，那么子接口中的默认方法会覆盖父接口中的默认方法。 接口的默认方法可以被多继承，如果一个类实现了多个接口，并且这些接口中有相同签名的默认方法，那么这个类必须重写这个默认方法，或者使用super关键字来指定使用哪个接口中的默认方法。</p><h4 id="FactoryBean">FactoryBean:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.pojo;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.FactoryBean;</span><br><span class="line"></span><br><span class="line">public class UserFactoryBean implements FactoryBean&lt;User&gt; &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public User getObject() throws Exception &#123; </span><br><span class="line">       return new User();</span><br><span class="line"> &#125;</span><br><span class="line">   @Override</span><br><span class="line">   public Class&lt;?&gt; getObjectType() &#123; </span><br><span class="line">       return User.class;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;com.example.demo.pojo.UserFactoryBean&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  @Test</span><br><span class="line">    public  void  factoryTest()</span><br><span class="line">    &#123;</span><br><span class="line">        //获取IOC容器</span><br><span class="line">        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-factory.xml&quot;);</span><br><span class="line">        //因为交给IOC容器管理的是user对象</span><br><span class="line">        User user = (User) ac.getBean(&quot;user&quot;);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">/*    生命周期1：实例化</span><br><span class="line">    User&#123;id=null, username=&#x27;null&#x27;, password=&#x27;null&#x27;, age=null&#125;*/</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688568299407-d1351508-cd00-4d10-bf82-8f32b10b3ddd.png#averageHue=%23f8f7f4&amp;clientId=u03b8032e-d2db-4&amp;from=paste&amp;height=114&amp;id=uf226db02&amp;originHeight=143&amp;originWidth=713&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=75650&amp;status=done&amp;style=none&amp;taskId=uf5053da9-4cfc-42d5-8eab-0f6bcf536ed&amp;title=&amp;width=570.4" alt="image.png"></p><h4 id="基于XML的自动装配：">基于XML的自动装配：</h4><p><strong>简单来说就是要装配的bean的中，其中有属性为类（可以创建bean的），这个时候可以不用指定ref或者vaule，指定寻找IOC中的bean</strong></p><h6 id="写在前面：">写在前面：</h6><p><a href="https://blog.csdn.net/m0_45067620/article/details/118274014">【Spring】使用xml文件实现自动装配；使用注解@Autowired和@Resource实现自动装配_StudiousTiger的博客-CSDN博客</a><br>基于xml的自动装配是Spring框架提供的一种简化Bean依赖注入的方式，它可以让Spring容器根据Bean的名称或类型自动查找并注入相应的属性值，而不需要手动指定ref或value属性。在Spring配置文件中，为需要自动装配的Bean添加autowire属性，并指定其值为byName、byType、constructor、default或no。</p><p>•  byName表示根据Bean的名称进行自动装配，要求Bean的id与被注入属性的名称相同。</p><p>•  byType表示根据Bean的类型进行自动装配，要求Bean的类型与被注入属性的类型相同，且在容器中只有一个该类型的Bean。</p><p>•  constructor表示根据构造器参数进行自动装配，要求容器中有与构造器参数类型和顺序相匹配的Bean。</p><p>•  default表示使用容器默认的自动装配策略，通常是no，即不进行自动装配。</p><p>•  no表示不进行自动装配，需要手动指定ref或value属性。</p><p>下面举一个简单的例子来说明基于xml的自动装配。假设我们有一个Person类，它有一个name属性和一个Car属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">private String name;</span><br><span class="line">private Car car;</span><br><span class="line"></span><br><span class="line">// 省略构造器、getter和setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Car &#123;</span><br><span class="line">private String brand;</span><br><span class="line">private double price;</span><br><span class="line"></span><br><span class="line">// 省略构造器、getter和setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们想要让Spring容器自动为Person对象注入Car对象，而不需要手动指定ref属性。我们可以在Spring配置文件中，为Person Bean添加autowire属性，并设置其值为byName或byType：</p><bean id="car" class="com.example.Car"><property name="brand" value="BMW"/><property name="price" value="300000"/></bean><bean id="person" class="com.example.Person" autowire="byName"><property name="name" value="Tom"/></bean><p>或者</p><bean id="car" class="com.example.Car"><property name="brand" value="BMW"/><property name="price" value="300000"/></bean><bean id="person" class="com.example.Person" autowire="byType"><property name="name" value="Tom"/></bean>#### xml的自动装配开始：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class UserController &#123;</span><br><span class="line">   private UserService userService;</span><br><span class="line">   public void setUserService(UserService userService) &#123;</span><br><span class="line">       this.userService = userService;</span><br><span class="line"> &#125;</span><br><span class="line">   public void saveUser()&#123;</span><br><span class="line">       userService.saveUser();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line">     void saveUser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">   private UserDao userDao;</span><br><span class="line">   public void setUserDao(UserDao userDao) &#123;</span><br><span class="line">         this.userDao = userDao; </span><br><span class="line"> &#125;</span><br><span class="line">   @Override</span><br><span class="line">   public void saveUser() &#123; </span><br><span class="line">       userDao.saveUser(); </span><br><span class="line"> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDao &#123;</span><br><span class="line">    void saveUser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public void saveUser() &#123;</span><br><span class="line">       System.out.println(&quot;保存成功&quot;); </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>上面的类和接口有一环一环的依赖，controller依赖server，server依赖Dap<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userController&quot; class=&quot;com.example.demo.controller.UserController&quot; &gt;</span><br><span class="line">    &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;userService&quot; class=&quot;com.example.demo.service.impl.UserServiceImpl&quot; &gt;</span><br><span class="line">        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;userDao&quot; class=&quot;com.example.demo.UserDao.impl.UserDaoImpl&quot; &gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"> public  void  testAutowire ()</span><br><span class="line"> &#123;</span><br><span class="line">     ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-autowire.xml&quot;);</span><br><span class="line">     UserController userController = context.getBean(UserController.class);</span><br><span class="line">    userController.saveUser();</span><br><span class="line"> &#125;</span><br><span class="line"> //输出</span><br><span class="line"> //保存成功</span><br></pre></td></tr></table></figure>###### 修改配置文件自动装配：byType使用bean标签的autowire属性设置自动装配效果 自动装配方式：byTypebyType：根据类型匹配IOC容器中的某个兼容类型的bean，为属性自动赋值若在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值 null若在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常 NoUniqueBeanDefinitionException自动装配方式：byName byName：将自动装配的属性的属性名，作为bean的id在IOC容器中匹配相对应的bean进行赋值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userController&quot;</span><br><span class="line">          class=&quot;com.example.demo.controller.UserController&quot; autowire=&quot;byType&quot;&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;userService&quot;</span><br><span class="line">          class=&quot;com.example.demo.service.impl.UserServiceImpl&quot; autowire=&quot;byType&quot;&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;userDao&quot; class=&quot;com.example.demo.UserDao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>###### 总结：![image.png](https://cdn.nlark.com/yuque/0/2023/png/28066124/1688572395284-7fc48f55-6850-4e8f-9b82-148eb630de6a.png#averageHue=%23ede9d9&clientId=u03b8032e-d2db-4&from=paste&height=49&id=u8f11fe5c&originHeight=61&originWidth=687&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=34049&status=done&style=none&taskId=ub921892a-9e64-42ec-bee0-6b2bc914922&title=&width=549.6)**（自动装配只能装配那些接口，类等属性，也就是要用ref标签引用的属性，其他的不能，需要手动设置属性）**![image.png](https://cdn.nlark.com/yuque/0/2023/png/28066124/1688572942220-8d320593-000c-45a1-b796-a434a5b204c4.png#averageHue=%23edeada&clientId=u03b8032e-d2db-4&from=paste&height=62&id=u7f7b0613&originHeight=77&originWidth=690&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=58220&status=done&style=none&taskId=u87b52934-0a7f-4080-a642-a755a0a4fe8&title=&width=552)![image.png](https://cdn.nlark.com/yuque/0/2023/png/28066124/1688573407060-7980193b-507e-44a1-8659-d909df492fab.png#averageHue=%23f5f4ef&clientId=u03b8032e-d2db-4&from=paste&height=93&id=u6ed64cfc&originHeight=116&originWidth=682&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=85159&status=done&style=none&taskId=u128337dc-3339-46fa-bb84-27541f90112&title=&width=545.6)###### 自动装配byName:byName自动装配它的作用是根据bean的属性名和xml中定义的bean的id进行匹配，如果匹配成功，则将对应的bean注入到属性中。#### 基于注解的bean管理：基于xml的管理常用于第三方提供的bean①注解和 XML 配置文件一样，注解本身并不能执行，注解本身仅仅只是做一个标记，具体的功能是框架检测 到注解标记的位置，然后针对这个位置按照注解标记的功能来执行具体操作。本质上：所有一切的操作都是Java代码来完成的，XML和注解只是告诉框架中的Java代码如何执行。**注意：基于注解管理bean的时候，注解是要加到实现类的，不能加到接口的**#### 相关注解：@Component：将类标识为普通组件  @Controller：将类标识为控制层组件  @Service：将类标 识为业务层组件  @Repository：将类标识为持久层组件（这4个注解功能都是将类标记为组件，只不过他们各自的含义不一样。对应spring管理ioc的时候，这4个注解是等效的，也就是说这4个注解可以替换，但是对于开发人员来说，他们是有各自不同的含义的）<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Component注解是标记一个类为Spring管理的组件的基本注解。被@Component注解标记的类会被自动扫描并创建为Bean对象，可以通过IoC容器进行管理和使用。通常情况下，使用@Component注解被标记的类都是一些通用的Bean类，没有特别的业务逻辑。</span><br><span class="line">@Component还有一些扩展的注解，如@Repository, @Service, @Controller等，它们都是@Component的元注解（注解注解的注解），具有相同的功能，但是在不同的层次上有不同的含义。@Component还可以配合@PostConstruct和@PreDestroy注解来指定bean的初始化和销毁方法。</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">@Controller注解是标记一个类为Spring MVC中的控制器的注解。被@Controller注解标记的类会被自动扫描并创建为Bean对象，并且会被Spring MVC框架用作请求处理器。@Controller注解通常用于处理用户请求，并返回相应的视图。</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Service注解是标记一个类为服务层组件的注解。被@Service注解标记的类会被自动扫描并创建为Bean对象，并且通常用于业务逻辑的处理，例如数据的处理、计算等。@Service注解通常被用作一个服务类的标志。</span><br><span class="line"></span><br><span class="line">@Repository</span><br><span class="line">@Repository注解是标记一个类为数据访问层组件的注解。被@Repository注解标记的类会被自动扫描并创建为Bean对象，并且通常用于数据的访问和持久化操作，例如数据库的访问、文件的读写等。</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">@Autowired注解是自动装配的注解，它可以自动将一个Bean注入到另一个Bean中。它可以用于属性、构造函数和方法上。当一个Bean需要使用其他Bean时，可以使用@Autowired注解将需要的Bean注入到当前Bean中，完成依赖注入。</span><br><span class="line">当用在构造器上时，Spring会自动查找与构造器参数类型匹配的Bean，并将它们注入到相应的位置。如果存在多个类型匹配的Bean，Spring会抛出一个异常。在这种情况下，我们可以使用@Qualifier注解来指定要注入的Bean。</span><br><span class="line">@Qualifier</span><br><span class="line">@Qualifier注解是用于注入特定Bean的注解。当一个接口有多个实现类时，可以使用@Qualifier注解指定需要注入的实现类，避免自动装配出现歧义。</span><br><span class="line"></span><br><span class="line">@Value</span><br><span class="line">@Value注解是用于注入属性值的注解，可以将配置文件中的属性值注入到Bean中。@Value注解可以用于属性、构造函数和方法上。</span><br><span class="line"></span><br><span class="line">@PostConstruct</span><br><span class="line">@PostConstruct注解是在Bean初始化之后执行的方法级别注解。当Bean初始化完成后，@PostConstruct注解的方法会被自动调用，可以在该方法中进行一些初始化操作。</span><br><span class="line"></span><br><span class="line">@PreDestroy</span><br><span class="line">@PreDestroy注解是在Bean销毁之前执行的方法级别注解。当Bean销毁之前，@PreDestroy注解的方法会被自动调用，可以在该方法中进行一些清理操作。</span><br></pre></td></tr></table></figure>#### 扫描组件：###### 最基本的：为了让spring能够扫描到注解，需要在spring的配置文件添加关于扫描的配置，和在pom文件中添加相关的依赖<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.example&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">   &lt;!-component-scan:组件扫描，base-package:通过包来扫描，包名写的越精确扫描的时间越短-&gt;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>###### 指定排除的：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span>&gt;</span> </span><br><span class="line">   <span class="comment">&lt;!-- context:exclude-filter标签：指定排除规则    --&gt;</span> </span><br><span class="line">   <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">type：设置排除或包含的依据</span></span><br><span class="line"><span class="comment">type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名</span></span><br><span class="line"><span class="comment">type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名</span></span><br><span class="line"><span class="comment">在IDE中，可以使用快捷键或右键菜单来复制类的全类名，</span></span><br><span class="line"><span class="comment">例如在IDEA中，可以选中一个类名，然后右键选择Copy Reference，</span></span><br><span class="line"><span class="comment">  或者使用Ctrl+Alt+Shift+C快捷键。--&gt;</span></span><br><span class="line">expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; </span><br><span class="line">       <span class="comment">&lt;!--&lt;context:exclude-filter type=&quot;assignable&quot; </span></span><br><span class="line"><span class="comment">expression=&quot;com.atguigu.controller.UserController&quot;/&gt;--&gt;</span></span><br><span class="line">&lt;/context:component-scan</span><br></pre></td></tr></table></figure>###### 只扫描指定的：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span> </span><br><span class="line">   <span class="comment">&lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则    --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则    --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 此时必须设置use-default-filters=&quot;false&quot;，因为默认规则即扫描指定包下所有类    --&gt;</span> </span><br><span class="line">   <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">type：设置排除或包含的依据</span></span><br><span class="line"><span class="comment">type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名</span></span><br><span class="line"><span class="comment">type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;context:include-filter type=&quot;assignable&quot; </span></span><br><span class="line"><span class="comment">expression=&quot;com.atguigu.controller.UserController&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>#### bean的id:在Spring中，Bean ID可以通过多种方式指定，包括：<ol><li>默认规则:扫描加注解<br>当使用@Component等注解标记一个类时，如果没有显式指定Bean ID，则默认使用类名的首字母小写作为Bean ID。例如，一个名为UserService的类，其默认的Bean ID为userService。</li><li>使用@Bean注解<br>当使用@Bean注解在配置类中定义一个Bean时，可以显式指定Bean ID。例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Bean(&quot;userService&quot;)</span><br><span class="line">    public UserService userService() &#123;</span><br><span class="line">        return new UserServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，@Bean注解用于定义一个Bean，并指定了Bean ID为userService。<br>3.使用注解的value属性自定义id：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688795689516-49cc89a8-1ca6-44a3-8e53-f23746ed1356.png#averageHue=%23141124&amp;clientId=u2b1598f3-93fd-4&amp;from=paste&amp;height=163&amp;id=u564574e3&amp;originHeight=204&amp;originWidth=519&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=26990&amp;status=done&amp;style=none&amp;taskId=u2fc2ea09-7a87-43f5-a45b-cb706c12abf&amp;title=&amp;width=415.2" alt="image.png"></p><ol><li>使用XML配置<br>在XML配置文件中，可以使用<bean>元素来定义一个Bean，并指定Bean ID。例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;com.example.demo.UserService&quot;&gt;</span><br><span class="line">    &lt;!-- 配置其他属性 --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，使用<bean>元素定义了一个名为userService的Bean，并指定其类为com.example.demo.UserService。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688795401819-1715b01b-338a-4464-a56a-efc65c120801.png#averageHue=%23191529&amp;clientId=u2b1598f3-93fd-4&amp;from=paste&amp;height=205&amp;id=u2e8de501&amp;originHeight=256&amp;originWidth=823&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=49167&amp;status=done&amp;style=none&amp;taskId=u46321d7e-f1a1-4c67-b479-65d93cf66c6&amp;title=&amp;width=658.4" alt="image.png"></p><h4 id="基于注解的自动装配：">基于注解的自动装配：</h4><h6 id="注意：">注意：</h6><p><strong>基于注解的自动装配，不需要在本类中为该属性设置get和set方法</strong></p><h6 id="Autowired">@Autowired:</h6><p>用法：在基于注解的自动装配中用于将一个Bean注入到另一个Bean中。<br>1.可以标识在成员变量上，这个时候该成员方法可以不用在它所在的类中设置相关的get和set方法。<br>2.当我们使用@Autowired注解时，Spring会自动查找与被注入的属性或方法参数类型匹配的Bean，并将它们注入到相应的位置。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDao userDao;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用@Autowired注解将UserDao注入到了UserServiceImpl中的userDao属性中。当Spring容器启动时，它会自动找到一个类型为UserDao的Bean，并将它注入到userDao属性中。<br>@Autowired注解可以用在构造器、属性、方法上。当用在构造器上时，Spring会自动查找与构造器参数类型匹配的Bean，并将它们注入到相应的位置。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public UserController(UserService userService) &#123;</span><br><span class="line">        this.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用@Autowired注解将userService注入到了构造器中。当Spring容器启动时，它会自动查找一个类型为UserService的Bean，并将它注入到构造器中。<br>需要注意的是，如果存在多个类型匹配的Bean，Spring会抛出一个异常。在这种情况下，我们可以使用@Qualifier注解来指定要注入的Bean。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;userDaoImpl&quot;)</span><br><span class="line">    private UserDao userDao;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用@Qualifier注解指定了要注入的Bean的名称为&quot;userDaoImpl&quot;。这样，当存在多个类型为UserDao的Bean时，Spring会查找名称为&quot;userDaoImpl&quot;的Bean并将它注入到userDao属性中。<br>required: 这个属性可以指定是否必须存在一个匹配的bean。默认值是true，如果没有找到匹配的bean，会抛出异常。如果设置为false，那么当没有找到匹配的bean时，字段或者参数会被设置为null。</p><h6 id="原理：">原理：</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688861603142-9afafff6-f7cc-4ea5-a103-a6bdfff4f5cb.png#averageHue=%23efebdf&amp;clientId=u581d0f14-5c03-4&amp;from=paste&amp;height=136&amp;id=u7388e55c&amp;originHeight=170&amp;originWidth=743&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=137106&amp;status=done&amp;style=none&amp;taskId=u13fb6161-b3c4-4948-aa03-ec4476286a9&amp;title=&amp;width=594.4" alt="image.png"></p><h4 id="代理模式的介绍：">代理模式的介绍：</h4><p>二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标<br>方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑<br>的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调<br>用和打扰，同时让附加功能能够集中在一起也有利于统一维护。<strong>（简单来说就是在调用目标对象之前进行额外的操作，这个时候就需要进行代理，用代理对象来调用目标对象的操作，并且在代理对象中实现额外操作。可能是使用到代理的情况：<strong>当创建一个对象的开销很大时，可以使用代理来延迟对象的创建，只有在需要访问对象时才会创建对象，从而减少了开销。当需要控制对对象的访问时，可以使用代理来限制对对象的访问。代理可以检查调用者的权限，从而保护对象的安全性。</strong>）</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688864926855-30f62a2a-4dab-4cf2-a6ad-c34cd7061f78.png#averageHue=%23ececec&amp;clientId=u581d0f14-5c03-4&amp;from=paste&amp;height=418&amp;id=u74fd2868&amp;originHeight=522&amp;originWidth=733&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=128453&amp;status=done&amp;style=none&amp;taskId=ub1d549b4-1699-4c3b-802d-de767a3e791&amp;title=&amp;width=586.4" alt="image.png"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line">    void save(User user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void save(User user) &#123;</span><br><span class="line">        // 保存用户信息</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserProxy implements UserService &#123;</span><br><span class="line">    private UserService userService = new UserServiceImpl();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void save(User user) &#123;</span><br><span class="line">        // 在保存用户信息之前进行一些操作，例如记录日志等</span><br><span class="line">        userService.save(user);</span><br><span class="line">        // 在保存用户信息之后进行一些操作，例如发送消息等</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，UserProxy类是UserService接口的实现类，它包含一个UserService类型的成员变量userService。在UserProxy类的save方法中，我们可以在调用userService的save方法之前和之后执行其他操作。这样，我们就可以通过UserProxy类来控制对UserServiceImpl对象的访问，从而实现代理模式。</p><h4 id="静态代理：">静态代理：</h4><p>静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来<br>说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代<br>码，日志功能还是分散的，没有统一管理。<br>提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理<br>类来实现。这就需要使用动态代理技术了</p><h4 id="动态代理：">动态代理：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688867552440-d719ebc6-8e68-4af2-81ab-88259681a121.png#averageHue=%23faf9f7&amp;clientId=u280da01d-7a94-4&amp;from=paste&amp;height=126&amp;id=u3d72dfb1&amp;originHeight=157&amp;originWidth=617&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=56798&amp;status=done&amp;style=none&amp;taskId=u47a084bc-7dd2-4269-a126-54af38e5a40&amp;title=&amp;width=493.6" alt="image.png"></p><h6 id="jdk动态代理">jdk动态代理</h6><p>JDK动态代理是Java提供的一种动态代理实现方式，它基于接口实现，通过反射机制在运行时生成代理类，实现对接口方法的代理。JDK动态代理的代理对象名称是由Proxy类的静态方法newProxyInstance动态生成的，它的格式是$Proxy+数字，其中的数字是随机生成的，所以其名称是不可预测的。<br>JDK动态代理需要实现InvocationHandler接口，该接口只有一个方法invoke，该方法会在代理对象调用方法时被调用，从而实现对被代理方法的增强逻辑。<br>下面是一个简单的JDK动态代理示例，假设有一个UserService接口和一个UserServiceImpl类，我们可以使用JDK动态代理来对UserServiceImpl对象进行代理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line">    void save(User user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void save(User user) &#123;</span><br><span class="line">        // 保存用户信息</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    public MyInvocationHandler(Object target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        // 在调用被代理对象的方法之前执行一些操作，例如记录日志等</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        // 在调用被代理对象的方法之后执行一些操作，例如发送消息等</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UserService userService = new UserServiceImpl();</span><br><span class="line">        MyInvocationHandler handler = new MyInvocationHandler(userService);</span><br><span class="line">        UserService proxy = (UserService) Proxy.newProxyInstance(</span><br><span class="line">            userService.getClass().getClassLoader(),</span><br><span class="line">            userService.getClass().getInterfaces(),</span><br><span class="line">            handler</span><br><span class="line">        );</span><br><span class="line">        proxy.save(new User());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个MyInvocationHandler类来实现对UserServiceImpl对象的代理。在MyInvocationHandler类中，我们通过反射调用被代理对象的方法，并在调用之前和之后执行一些操作。然后，我们使用Proxy类的静态方法newProxyInstance来创建代理对象，并将其强制转换为UserService类型。最后，我们调用代理对象的save方法来保存用户信息。</p><h4 id="AOP介绍：">AOP介绍：</h4><p>简单来说就是我们要调用目标对象方法的之前或者之后，我们要进行额外的操作，我们不通过修改目标对象的方法来实现，而是通过其他方法实现这就是AOP要解决的问题。<br>见尚硅谷笔记</p><h4 id="基于注解的AOP：">基于注解的AOP：</h4><h6 id="准备：">准备：</h6><p>配置pom文件依赖：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基于Maven依赖传递性，导入spring-context依赖(是IOC的依赖)即可导入当前所需所有jar包    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- junit测试    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688871638743-64ecae28-865e-4cac-8ce2-bcf7ea27d0e4.png#averageHue=%230e0c09&amp;clientId=u280da01d-7a94-4&amp;from=paste&amp;height=209&amp;id=u6578205b&amp;originHeight=261&amp;originWidth=618&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=30999&amp;status=done&amp;style=none&amp;taskId=u5e2c5f5b-a607-45c4-b493-f27fd006994&amp;title=&amp;width=494.4" alt="image.png"><br>配置Spring配置文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> 基于注解的AOP的实现：</span></span><br><span class="line"><span class="comment"> 1、将目标对象和切面交给IOC容器管理（注解+扫描）</span></span><br><span class="line"><span class="comment"> 2、开启AspectJ的自动代理，为目标对象自动生成代理</span></span><br><span class="line"><span class="comment"> 3、将切面类通过注解@Aspect标识</span></span><br><span class="line"><span class="comment"> &lt;context:component-scan&gt;标签用于自动扫描指定包及其子包下的类，并将其注册为bean。</span></span><br><span class="line"><span class="comment">     在启用基于注解的AOP时，我们需要使用该标签来扫描所有带有@Aspect注解的类，并将其转换为切面</span></span><br><span class="line"><span class="comment">&lt;aop:aspectj-autoproxy /&gt;元素表示开启基于AspectJ注解的AOP自动代理，</span></span><br><span class="line"><span class="comment">让Spring容器能够识别@Aspect注解标注的切面类，并根据切面类中的通知和切入点配置为目标对象生成</span></span><br><span class="line"><span class="comment">代理对象。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.example&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.example;</span><br><span class="line"></span><br><span class="line">public interface Calculator &#123;</span><br><span class="line">int add(int i, int j);</span><br><span class="line">int sub(int i, int j);</span><br><span class="line">int mul(int i, int j);</span><br><span class="line">int div(int i, int j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.example;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class CalculatorPureImpl implements Calculator &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int add(int i, int j) &#123;</span><br><span class="line">        int result = i + j;</span><br><span class="line">        System.out.println(&quot;方法内部    result = &quot; + result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int sub(int i, int j) &#123;</span><br><span class="line">        int result = i - j;</span><br><span class="line">        System.out.println(&quot;方法内部    result = &quot; + result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int mul(int i, int j) &#123;</span><br><span class="line">        int result = i * j;</span><br><span class="line">              System.out.println(&quot;方法内部    result = &quot; + result);</span><br><span class="line">       return result;</span><br><span class="line"> &#125;</span><br><span class="line">   </span><br><span class="line">    @Override</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    public int div(int i, int j) &#123;</span><br><span class="line">       int result = i / j;</span><br><span class="line">       System.out.println(&quot;方法内部    result = &quot; + result);</span><br><span class="line">       return result;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package com.example;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.JoinPoint;</span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.*;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">//在切面中需要通过指定的注解，将方法标识为通知方法</span><br><span class="line">// @Aspect表示这个类是一个切面类</span><br><span class="line">@Aspect</span><br><span class="line">// @Component注解保证这个切面类能够放入IOC容器，切面类必须要做IOC容器中 </span><br><span class="line">@Component</span><br><span class="line">public class LogAspect &#123;</span><br><span class="line">    //@Before前置通知，在方法执行之前执行,下面的*表示当前类中的所有方法，..表示任意参数</span><br><span class="line">   @Before(&quot;execution(public int  CalculatorPureImpl.* (..))&quot;)</span><br><span class="line">   //JoinPoint连接点</span><br><span class="line">               public void beforeMethod(JoinPoint joinPoint)&#123;</span><br><span class="line">       //joinPoint.getSignature()获取当前连接点方法的签名信息，getName()获取连接点方法的方法名</span><br><span class="line">       String methodName = joinPoint.getSignature().getName();</span><br><span class="line">       //joinPoint.getArgs()获取连接点方法的参数列表</span><br><span class="line">       String args = Arrays.toString(joinPoint.getArgs());</span><br><span class="line">       System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);</span><br><span class="line">                 &#125;</span><br><span class="line">     //@After后置通知，也就是方法返回值返回之后才直接执行。</span><br><span class="line">   @After(&quot;execution(*  com.example.CalculatorPureImpl.*(..))&quot;)</span><br><span class="line">   public void afterMethod(JoinPoint joinPoint)&#123;</span><br><span class="line">       String methodName = joinPoint.getSignature().getName();</span><br><span class="line">       System.out.println(&quot;Logger--&gt;后置通知，方法名：&quot;+methodName);</span><br><span class="line"> &#125;</span><br><span class="line">    //在返回通知中若要获取目标对象的返回值，只需要通过 @AfterReturning注解的returning属性，</span><br><span class="line">//    returning：参数名称，用于指定返回结果的变量名。在通知方法中，可以使用该变量来访问返回结果。这里的返回结果变量名为result。</span><br><span class="line">//    throwing：参数名称，用于指定抛出的异常变量名。在通知方法中，可以使用该变量来访问抛出的异常。这里的异常变量名为ex。</span><br><span class="line">    @AfterReturning(value = &quot;execution(* com.example.CalculatorPureImpl.*(..))&quot;, returning = &quot;result&quot;)</span><br><span class="line">               public void afterReturningMethod(JoinPoint joinPoint, Object result)&#123;</span><br><span class="line">       String methodName = joinPoint.getSignature().getName();</span><br><span class="line">       System.out.println(&quot;Logger--&gt;返回通知，方法名：&quot;+methodName+&quot;，结 果：&quot;+result);</span><br><span class="line">                 &#125;</span><br><span class="line">//环绕通知（前面几种通知的集合）：ProceedingJoinPoint继承自JoinPoint接口。相对于JoinPoint，</span><br><span class="line">//ProceedingJoinPoint多了一个proceed()方法，用于手动调用目标方法并获取返回值。</span><br><span class="line">//环绕通知必须有返回值，返回值的类型是proceed方法返回的类型</span><br><span class="line"></span><br><span class="line">   @Around(&quot;execution(*  com.example.CalculatorPureImpl.*(..))&quot;)</span><br><span class="line">   public Object aroundMethod(ProceedingJoinPoint joinPoint)&#123;</span><br><span class="line">             String methodName = joinPoint.getSignature().getName(); </span><br><span class="line">       String args = Arrays.toString(joinPoint.getArgs());</span><br><span class="line">       Object result = null; </span><br><span class="line">       try &#123;</span><br><span class="line"></span><br><span class="line">           System.out.println(&quot;环绕通知--&gt;目标对象方法执行之前&quot;); </span><br><span class="line">   //目标对象（连接点）方法的执行，只有下面这条语句执行后才能在目标对象方法中添加额外的操作</span><br><span class="line">           result = joinPoint.proceed();</span><br><span class="line">           System.out.println(&quot;环绕通知--&gt;目标对象方法返回值之后&quot;); </span><br><span class="line">       &#125; catch (Throwable throwable) &#123;//捕获目标对象方法的异常</span><br><span class="line">           throwable.printStackTrace();</span><br><span class="line">           System.out.println(&quot;环绕通知--&gt;目标对象方法出现异常时&quot;); </span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           System.out.println(&quot;环绕通知--&gt;目标对象方法执行完毕&quot;); </span><br><span class="line">     &#125;</span><br><span class="line">       return result; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void  test()</span><br><span class="line">   &#123;</span><br><span class="line">       ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;aop.annotation.xml&quot;);</span><br><span class="line">       //AOP底层是代理模式，这里我们应该获取代理对象的bean,如果获取的是目标对象会报该对象的bean不可用</span><br><span class="line">       //注意这里的代理对象表示LogAspect,代理对象而是AOP底层JDK动态代理生成的，名称是不可预测的</span><br><span class="line">       //但是它却实现了目标对象的接口，可以通过接口声明</span><br><span class="line">        Calculator logAspect= ioc.getBean(Calculator.class);</span><br><span class="line">        logAspect.add(1,1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="切面的优先级：">切面的优先级：</h4><p>@Order注解是Spring AOP中用于指定通知顺序的注解。通常情况下，多个切面的通知会按照它们定义的顺序依次执行。但是，如果我们需要显式地指定通知的执行顺序，可以使用@Order注解来实现。<br>@Order注解可以用于类级别和方法级别，它的值越小，优先级越高</p><h4 id="jdbcTemplate">jdbcTemplate:</h4><p>Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包    --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- Spring 持久化层支持jar包    --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个 </span></span><br><span class="line"><span class="comment">jar包    --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 导入    orm 包就可以通过    Maven 的依赖传递性把其他两个也导入    --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- Spring 测试相关 ,后面在引入junit是为了让junit在Spring测试环境中运行   --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- junit测试    --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- MySQL驱动    --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 数据源    --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">&lt;/dependencies</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=A86789234</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/myemployees?serverTimezone=UTC</span><br><span class="line">jdbc.driver=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 导入外部属性文件 classpath:类路径，web资源中要指定，   --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置数据源    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;druidDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置    JdbcTemplate --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 装配数据源    --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;druidDataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//指定当前测试类在Spring的测试环境中执行，此时就可以通过注入的方式直接获取IOC容器的bean</span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">//表示通过类路径的方式配置当前Spring测试环境的配置</span><br><span class="line">@ContextConfiguration(&quot;classpath:springJdbc.xml&quot;)</span><br><span class="line">public class jdbcTest &#123;</span><br><span class="line">        //使用spring的测试环境进行测试，需要将测试中要使用的对象注入spring容器中，这里采用注解自动装配注入</span><br><span class="line">        @Autowired</span><br><span class="line">        private JdbcTemplate jdbcTemplate;</span><br><span class="line">        @Test</span><br><span class="line">        public  void  testInsert()</span><br><span class="line">        &#123;//没有insert插入，可以通过update实现</span><br><span class="line">            jdbcTemplate.update(&quot;insert into t_emp values(5,?,?,?,2)&quot;,&quot;赵士&quot;,29,&quot;女&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">//查询一条数据为一个实体类对象 </span><br><span class="line">public void testSelectEmpById()&#123;</span><br><span class="line">   String sql = &quot;select * from t_emp where id = ?&quot;;</span><br><span class="line">//BeanPropertyRowMapper将查询结果映射到Emp对象中。</span><br><span class="line">   Emp emp = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper<span class="tag">&lt;&gt;</span> </span><br><span class="line">(Emp.class), 1);</span><br><span class="line">   System.out.println(emp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用BeanPropertyRowMapper进行映射时，Emp类中的属性需要满足以下要求：</p><ol><li>Emp类必须有一个无参构造函数，否则会在映射时抛出InstantiationException异常。</li></ol><p>要映射的类必须有一个默认的或无参的构造方法，不能只有带参的构造方法。要映射的类要有公共的setter和getter方法，不能只有其中一个。 要映射的类必须是一个顶级类或静态内部类，不能是非静态的内部类。</p><ol start="2"><li>Emp类中的属性名必须与数据库表中的列名相对应，也可以可以通过使用“驼峰”大小写将用下划线分隔的部分的名称转换为相同的名称来匹配。比如：first_name可以转换为firstName</li><li>Emp类中的属性类型必须与数据库表中相应列的数据类型一致或可以自动转换。例如，如果数据库表中某个列的数据类型为VARCHAR，对应的Emp类中的属性类型可以是String或者其他类型，只要可以进行自动转换即可。</li></ol><h4 id="声明式事务：">声明式事务：</h4><p><a href="https://blog.csdn.net/zxlyx/article/details/120446177">详解 spring 声明式事务(@Transactional)_purple.taro的博客-CSDN博客</a><br>所谓声明式事务，就是通过配置的方式，比如通过配置文件（xml）或者注解的方式，告诉spring，哪些方法需要spring帮忙管理事务，然后开发者只用关注业务代码，而事务的事情spring自动帮我们控制。</p><h6 id="基于注解的声明式事务：">基于注解的声明式事务：</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包    --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- Spring 持久化层支持jar包    --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个 </span></span><br><span class="line"><span class="comment">jar包    --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 导入    orm 包就可以通过    Maven 的依赖传递性把其他两个也导入    --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- Spring 测试相关    --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- junit测试    --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- MySQL驱动    --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 数据源    --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=A86789234</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/myemployees?serverTimezone=UTC</span><br><span class="line">jdbc.driver=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tool http://www.springframework.org/schema/tool/spring-tool.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导入外部属性文件 classpath:类路径，web资源中要指定，   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;druidDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置    JdbcTemplate --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 装配数据源    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;druidDataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这段代码用来告诉Spring框架需要扫描哪个包下的类，并将这些类注册</span></span><br><span class="line"><span class="comment">          为Spring容器中的Bean对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.example&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务管理器 这里的ref是链接数据源的id这里使用的是druidDataSource数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;druidDataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启事务注解驱动(annotion选择tx中的）注意此处的tx要导入的命名空间。</span></span><br><span class="line"><span class="comment">    &lt;tx:annotation-driven&gt;：用来开启Spring的声明式事务支持</span></span><br><span class="line"><span class="comment">    transaction-manager：用来指定事务管理器的bean名称。</span></span><br><span class="line"><span class="comment">    transaction-manager后面的值是事务管理器的id，若事务管理器的id为transactionManager</span></span><br><span class="line"><span class="comment">    那么transaction-manager可以省略不写·</span></span><br><span class="line"><span class="comment">    开启后将可以使用@Transaction注解所标识的的方法或类中的所有方法使用事务管理。</span></span><br><span class="line"><span class="comment">    @Transaction加到方法上，该方法就是连接点，加到类上，该类的所有方法都是连接点。</span></span><br><span class="line"><span class="comment">    这样可以对@Transaction注解方法或者类进行事务性管理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t_book` (</span><br><span class="line">`book_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, </span><br><span class="line">`book_name` varchar(20) DEFAULT NULL COMMENT &#x27;图书名称&#x27;, </span><br><span class="line">`price` int(11) DEFAULT NULL COMMENT &#x27;价格&#x27;,</span><br><span class="line">`stock` int(10) unsigned DEFAULT NULL COMMENT &#x27;库存（无符号）&#x27;, </span><br><span class="line">PRIMARY KEY (`book_id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;</span><br><span class="line">insert  into `t_book`(`book_id`,`book_name`,`price`,`stock`) values (1,&#x27;斗破苍 </span><br><span class="line">穹&#x27;,80,100),(2,&#x27;斗罗大陆&#x27;,50,100);</span><br><span class="line">CREATE TABLE `t_user` (</span><br><span class="line">`user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, </span><br><span class="line">`username` varchar(20) DEFAULT NULL COMMENT &#x27;用户名&#x27;,</span><br><span class="line">`balance` int(10) unsigned DEFAULT NULL COMMENT &#x27;余额（无符号）&#x27;, </span><br><span class="line">PRIMARY KEY (`user_id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;</span><br><span class="line">insert  into `t_user`(`user_id`,`username`,`balance`) values (1,&#x27;admin&#x27;,50);</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> @Controller</span><br><span class="line">public class BookController &#123; </span><br><span class="line">   @Autowired</span><br><span class="line">   private BookService bookService;</span><br><span class="line">   public void buyBook(Integer bookId, Integer userId)&#123; </span><br><span class="line">       bookService.buyBook(bookId, userId);</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookService &#123;</span><br><span class="line">   void buyBook(Integer bookId, Integer userId); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookServiceImpl implements BookService &#123; </span><br><span class="line">   @Autowired</span><br><span class="line"> @Transactional </span><br><span class="line">   private BookDao bookDao; </span><br><span class="line">   @Override</span><br><span class="line">   public void buyBook(Integer bookId, Integer userId) &#123; </span><br><span class="line">       //查询图书的价格</span><br><span class="line">       Integer price = bookDao.getPriceByBookId(bookId); </span><br><span class="line">       //更新图书的库存</span><br><span class="line">       bookDao.updateStock(bookId); </span><br><span class="line">       //更新用户的余额</span><br><span class="line">       bookDao.updateBalance(userId, price); </span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface BookDao &#123;</span><br><span class="line">   Integer getPriceByBookId(Integer bookId); </span><br><span class="line">   void updateStock(Integer bookId);</span><br><span class="line">   void updateBalance(Integer userId, Integer price); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class BookDaoImpl implements BookDao &#123; </span><br><span class="line">   @Autowired</span><br><span class="line">   private JdbcTemplate jdbcTemplate; </span><br><span class="line">   @Override</span><br><span class="line">   public Integer getPriceByBookId(Integer bookId) &#123;</span><br><span class="line">       String sql = &quot;select price from t_book where book_id = ?&quot;;</span><br><span class="line">       return jdbcTemplate.queryForObject(sql, Integer.class, bookId); </span><br><span class="line"> &#125;</span><br><span class="line">   @Override</span><br><span class="line">   public void updateStock(Integer bookId) &#123;</span><br><span class="line">       String sql = &quot;update t_book set stock = stock - 1 where book_id = ?&quot;; </span><br><span class="line">       jdbcTemplate.update(sql, bookId);</span><br><span class="line"> &#125;</span><br><span class="line">   @Override</span><br><span class="line">   public void updateBalance(Integer userId, Integer price) &#123;</span><br><span class="line">       String sql = &quot;update t_user set balance = balance - ? where user_id = </span><br><span class="line">?&quot;;</span><br><span class="line">       jdbcTemplate.update(sql, price, userId); </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tool http://www.springframework.org/schema/tool/spring-tool.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导入外部属性文件 classpath:类路径，web资源中要指定，   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;druidDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置    JdbcTemplate --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 装配数据源    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;druidDataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;druidDataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启事务注解驱动(annotion选择tx中的）注意此处的tx要导入的命名空间。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(&quot;classpath:tx-annotation.xml&quot;) </span><br><span class="line">public class TxByAnnotationTest &#123;</span><br><span class="line">   @Autowired</span><br><span class="line">   private BookController bookController; </span><br><span class="line">   @Test</span><br><span class="line">   public void testBuyBook()&#123;</span><br><span class="line">       bookController.buyBook(1, 1); </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事务的属性：">事务的属性：</h4><p>readonly<br>未完待续。。。。</p><h1>SpringMvc:（只包括相关的知识点，相关程序没有走，只是结合老师给的）</h1><h4 id="MVC介绍：">MVC介绍：</h4><p>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分<br>M：Model，模型层，指工程中的JavaBean，作用是处理数据<br>JavaBean分为两类：<br>一类称为实体类Bean：专门存储业务数据的，如 Student、User 等<br>一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。<br>V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据<br>C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器<br>MVC的工作流程： 用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller<br>调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果<br>找到相应的View视图，渲染数据后最终响应给浏览器</p><h4 id="SpringMVC的特点：">SpringMVC的特点：</h4><p>SpringMVC是Spring的一个后续产品，是Spring的一个子项目<br>SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、<br>WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目<br>表述层开发的首选方案。<br>注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台 servlet<br>Spring 家族原生产品，与 IOC 容器等基础设施无缝对接基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一 处理。表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案 。代码清新简洁，大幅度提升开发效率。内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可 。性能卓著，尤其适合现代大型、超大型互联网项目要求。</p><h4 id="入门案例：（下面方法由于IDEA是2023的有错误的，后面完全是跟着老师的源码）">入门案例：（下面方法由于IDEA是2023的有错误的，后面完全是跟着老师的源码）</h4><h6 id="项目创建：">项目创建：</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688915710064-4a470bf2-c79f-4ae8-9a17-10668f3fc10c.png#averageHue=%23050403&amp;clientId=ub6a7cc0c-d91b-4&amp;from=paste&amp;height=589&amp;id=u89facdbc&amp;originHeight=983&amp;originWidth=988&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=67634&amp;status=done&amp;style=none&amp;taskId=ub6753472-537f-4f6e-b5e9-caef004519c&amp;title=&amp;width=592" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688915736077-a7d8e962-2afe-4bdb-98f3-0b9d926ef415.png#averageHue=%230b0a09&amp;clientId=ub6a7cc0c-d91b-4&amp;from=paste&amp;height=710&amp;id=u768996e3&amp;originHeight=888&amp;originWidth=739&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=77930&amp;status=done&amp;style=none&amp;taskId=u5b648a25-7878-4c48-8c30-6dbfb8ca621&amp;title=&amp;width=591.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688915746620-15adf4dc-b3c5-4356-a81a-cd2e9e609314.png#averageHue=%23080605&amp;clientId=ub6a7cc0c-d91b-4&amp;from=paste&amp;height=274&amp;id=uef640c46&amp;originHeight=343&amp;originWidth=584&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=18968&amp;status=done&amp;style=none&amp;taskId=uadfe8256-8bbf-477f-ac5d-b51f95de508&amp;title=&amp;width=467.2" alt="image.png">（选择Web应用程序）</p><h6 id="常见新的mvc工程：项目结构图如下">常见新的mvc工程：项目结构图如下</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688915793967-5188083d-d94e-44f4-871e-f8e763b3343c.png#averageHue=%230a0807&amp;clientId=ub6a7cc0c-d91b-4&amp;from=paste&amp;height=330&amp;id=ub1889d38&amp;originHeight=412&amp;originWidth=389&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=19311&amp;status=done&amp;style=none&amp;taskId=u4e091b0b-3e7d-46e4-a19e-2519f30c1c3&amp;title=&amp;width=311.2" alt="image.png"></p><h6 id="导入相关依赖：">导入相关依赖：</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- SpringMVC --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 日志    --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- ServletAPI --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- Spring5和Thymeleaf整合包    --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：由于 Maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠 传递性导入。</p><h6 id="配置web-xml">配置web.xml</h6><p>注册SpringMVC的前端控制器DispatcherServlet，此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为<servlet-name>- servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC- servlet.xml</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet&lt;/servlet- </span><br><span class="line">class&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line">   <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">       设置springMVC的核心控制器所能处理的请求的请求路径</span></span><br><span class="line"><span class="comment">       /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 </span></span><br><span class="line"><span class="comment">       但是/不能匹配.jsp请求路径的请求</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>扩展配置方式</strong><br><strong>可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置 SpringMVC前端控制器DispatcherServlet的初始化时间。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet&lt;/servlet- </span><br><span class="line">class&gt;</span><br><span class="line">   <span class="comment">&lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称    --&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- contextConfigLocation为固定值    --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的 </span></span><br><span class="line"><span class="comment">src/main/resources --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">作为框架的核心组件，在启动过程中有大量的初始化操作要做 </span></span><br><span class="line"><span class="comment">而这些操作放在第一次请求时才执行会严重影响访问速度</span></span><br><span class="line"><span class="comment">因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时 </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line">   <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">       设置springMVC的核心控制器所能处理的请求的请求路径</span></span><br><span class="line"><span class="comment">       /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 </span></span><br><span class="line"><span class="comment">       但是/不能匹配.jsp请求路径的请求</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><url-pattern>标签中使用/和/*的区别：/所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请 求.因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面 /*则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/*的写法</p><h6 id="创建请求控制器">创建请求控制器</h6><p>由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要 创建处理具体请求的类，即请求控制器.请求控制器中每一个处理请求的方法成为控制器方法,因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识 .为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class HelloController &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="创建SpringMVC的配置文件">创建SpringMVC的配置文件</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自动扫描包    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.mvc.controller&quot;</span>/&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 配置Thymeleaf视图解析器：实现视图渲染和页面跳转    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span> </span><br><span class="line">  <span class="comment">&lt;!--name属性设置为order，value属性设置为1，</span></span><br><span class="line"><span class="comment">  这将设置Thymeleaf视图解析器的顺序为1。在Spring MVC中，</span></span><br><span class="line"><span class="comment">  有多个视图解析器可用，按顺序运行，</span></span><br><span class="line"><span class="comment">  直到找到能够处理请求的视图解析器为止。--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateEngine&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span> </span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateResolver&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--配置前缀和后缀可以通过路径路径访问--&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!-- 视图前缀    --&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span></span><br><span class="line">                   <span class="comment">&lt;!-- 视图后缀    --&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>/&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateMode&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HTML5&quot;</span>/&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  处理静态资源，例如html、js、css、jpg</span></span><br><span class="line"><span class="comment"> 若只设置该标签，则只能访问静态资源，其他请求则无法访问</span></span><br><span class="line"><span class="comment">  此时必须设置&lt;mvc:annotation-driven/&gt;解决问题 </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启mvc注解驱动    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 处理响应中文内容乱码    --&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultCharset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;supportedMediaTypes&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/html<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688948429310-fa23137f-afe9-4c6a-9852-6d02441450e4.png#averageHue=%23f8f6ef&amp;clientId=ucdf75339-60f9-4&amp;from=paste&amp;height=57&amp;id=u35dc23a1&amp;originHeight=71&amp;originWidth=636&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=36570&amp;status=done&amp;style=none&amp;taskId=u88ce7f1e-3a7f-4d80-b16e-29191bef367&amp;title=&amp;width=508.8" alt="image.png"></p><h6 id="测试HelloWorld">测试HelloWorld</h6><p>首先配置tomcat服务器<br>实现对首页的访问,在请求控制器中创建处理请求的方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// @RequestMapping注解：处理请求和控制器方法之间的映射关系</span><br><span class="line">// @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径 </span><br><span class="line">// localhost:8080/springMVC/</span><br><span class="line">@RequestMapping(&quot;/&quot;) </span><br><span class="line">public String index() &#123; </span><br><span class="line">   //设置视图名称</span><br><span class="line">   return &quot;index&quot;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②通过超链接跳转到指定页面<br>在主页index.html中设置超链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/hello&#125;&quot;</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在请求控制器中创建处理请求的方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/hello&quot;) </span><br><span class="line">public String HelloWorld() &#123; </span><br><span class="line">   return &quot;target&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RequestMapping注解">@RequestMapping注解</h4><p><strong>位置：</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688991101360-096000ef-2636-40d6-8ac6-97a2a1043b55.png#averageHue=%23111221&amp;clientId=u2b3dc9ad-44f6-4&amp;from=paste&amp;height=142&amp;id=u8fcb248b&amp;originHeight=178&amp;originWidth=650&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=49138&amp;status=done&amp;style=none&amp;taskId=u070b129b-f8c9-4090-8e09-11b33e3afcb&amp;title=&amp;width=520" alt="image.png"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">1、@RequestMapping注解标识的位置</span><br><span class="line">* @RequestMapping标识一个类：设置映射请求的请求路径的初始信息</span><br><span class="line">* @RequestMapping标识一个方法：设置映射请求请求路径的具体信息</span><br><span class="line">* 2、@RequestMapping注解value属性</span><br><span class="line">* 作用：通过请求的请求路径匹配请求</span><br><span class="line">* value属性是数组类型，即当前浏览器所发送请求的请求路径匹配value属性中的任何一个值</span><br><span class="line">* 则当前请求就会被注解所标识的方法进行处理</span><br><span class="line">* 3、@RequestMapping注解的method属性</span><br><span class="line">* 作用：通过请求的请求方式匹配请求</span><br><span class="line">* method属性是RequestMethod类型的数组，即当前浏览器所发送请求的请求方式匹配method属性中的任何一中请求方式</span><br><span class="line">* 则当前请求就会被注解所标识的方法进行处理</span><br><span class="line">* 若浏览器所发送的请求的请求路径和@RequestMapping注解value属性匹配，但是请求方式不匹配</span><br><span class="line">* 此时页面报错：405 - Request method &#x27;xxx&#x27; not supported</span><br><span class="line">* 在@RequestMapping的基础上，结合请求方式的一些派生注解：</span><br><span class="line">* @GetMapping,@PostMapping,@DeleteMapping,@PutMapping</span><br><span class="line">* 4、@RequestMapping注解的params属性</span><br><span class="line">* 作用：通过请求的请求参数匹配请求，即浏览器发送的请求的请求参数必须满足params属性的设置</span><br><span class="line">* params可以使用四种表达式：</span><br><span class="line">* &quot;param&quot;：表示当前所匹配请求的请求参数中必须携带param参数</span><br><span class="line">* &quot;!param&quot;：表示当前所匹配请求的请求参数中一定不能携带param参数</span><br><span class="line">* &quot;param=value&quot;：表示当前所匹配请求的请求参数中必须携带param参数且值必须为value</span><br><span class="line">* &quot;param!=value&quot;：表示当前所匹配请求的请求参数中可以不携带param，若携带值一定不能是value</span><br><span class="line">* 若浏览器所发送的请求的请求路径和@RequestMapping注解value属性匹配，但是请求参数不匹配</span><br><span class="line">* 此时页面报错：400 - Parameter conditions &quot;username&quot; not met for actual request parameters:</span><br><span class="line">* 5、@RequestMapping注解的headers属性</span><br><span class="line">* 作用：通过请求的请求头信息匹配请求，即浏览器发送的请求的请求头信息必须满足headers属性的设置</span><br><span class="line">* 若浏览器所发送的请求的请求路径和@RequestMapping注解value属性匹配，但是请求头信息不匹配</span><br><span class="line">* 此时页面报错：404</span><br><span class="line">* 6、SpringMVC支持ant风格的路径</span><br><span class="line">* 在@RequestMapping注解的value属性值中设置一些特殊字符</span><br><span class="line">* ?:任意的单个字符（不包括?）</span><br><span class="line">* *:任意个数的任意字符（不包括?和/）</span><br><span class="line">* **:任意层数的任意目录，注意使用方式只能**写在双斜线中，前后不能有任何的其他字符</span><br><span class="line">* 7、@RequestMapping注解使用路径中的占位符</span><br><span class="line">* 传统：/deleteUser?id=1</span><br><span class="line">* rest：/user/delete/1</span><br><span class="line">* 需要在@RequestMapping注解的value属性中所设置的路径中，使用&#123;xxx&#125;的方式表示路径中的数据</span><br><span class="line">* 在通过@PathVariable注解，将占位符所标识的值和控制器方法的形参进行绑定</span><br><span class="line">* 获取请求参数的方式：</span><br><span class="line">* 1、通过servletAPI获取</span><br><span class="line">* 只需要在控制器方法的形参位置设置HttpServletRequest类型的形参</span><br><span class="line">* 就可以在控制器方法中使用request对象获取请求参数</span><br><span class="line">* 2、通过控制器方法的形参获取</span><br><span class="line">* 只需要在控制器方法的形参位置，设置一个形参，形参的名字和请求参数的名字一致即可</span><br><span class="line">* 3、@RequestParam：将请求参数和控制器方法的形参绑定</span><br><span class="line">* @RequestParam注解的三个属性：value、required、defaultValue</span><br><span class="line">* value:设置和形参绑定的请求参数的名字</span><br><span class="line">* required:设置是否必须传输value所对应的请求参数</span><br><span class="line">* 默认值为true，表示value所对应的请求参数必须传输，否则页面报错：</span><br><span class="line">* 400 - Required String parameter &#x27;xxx&#x27; is not present</span><br><span class="line">* 若设置为false，则表示value所对应的请求参数不是必须传输，若为传输，则形参值为null</span><br><span class="line">* defaultValue:设置当没有传输value所对应的请求参数时，为形参设置的默认值，此时和required属性值无关</span><br><span class="line">* 4、@RequestHeader：将请求头信息和控制器方法的形参绑定</span><br><span class="line">* 5、@CookieValue：将cookie数据和控制器方法的形参绑定</span><br><span class="line">* 6、通过控制器方法的实体类类型的形参获取请求参数</span><br><span class="line">* 需要在控制器方法的形参位置设置实体类类型的形参，要保证实体类中的属性的属性名和请求参数的名字一致</span><br><span class="line">* 可以通过实体类类型的形参获取请求参数</span><br><span class="line">* 7、解决获取请求此参数的乱码问题</span><br><span class="line">* 在web.xml中配置Spring的编码过滤器CharacterEncodingFilter</span><br><span class="line">* 向域对象共享数据：</span><br><span class="line">* 1、通过ModelAndView向请求域共享数据</span><br><span class="line">* 使用ModelAndView时，可以使用其Model功能向请求域共享数据</span><br><span class="line">* 使用View功能设置逻辑视图，但是控制器方法一定要将ModelAndView作为方法的返回值</span><br><span class="line">* 2、使用Model向请求域共享数据</span><br><span class="line">* 3、使用ModelMap向请求域共享数据</span><br><span class="line">* 4、使用map向请求域共享数据</span><br><span class="line">* 5、Model和ModelMap和map的关系</span><br><span class="line">* 其实在底层中，这些类型的形参最终都是通过BindingAwareModelMap创建</span><br><span class="line">* public class BindingAwareModelMap extends ExtendedModelMap &#123;&#125;</span><br><span class="line">* public class ExtendedModelMap extends ModelMap implements Model &#123;&#125;</span><br><span class="line">* public class ModelMap extends LinkedHashMap&lt;String, Object&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>表单提交和axios是post请求，超链接和地址栏输出的都是get请求。<br>请求头和响应头不区分的键不区分大小写，但是值区分。<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">HTTP Cookie - HTTP | MDN</a><br><a href="https://www.cnblogs.com/blknemo/p/13202619.html">【Web】Servlet三大作用域、JSP四大作用域 - Nemo&amp; - 博客园</a><br><a href="https://blog.csdn.net/lingxiyizhi_ljx/article/details/102514560">form表单中的enctype=“multipart/form-data“什么意思?_夜阑卧听风吹雨，铁马冰河入梦来的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html"> &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h1&gt;Mybits:&lt;/h1&gt;
&lt;h4 id=&quot;mybits核心配置文件：&quot;&gt;mybits核心配置文件：&lt;/h4&gt;
&lt;p&gt;用于配置 MyBatis 的各种参数和属性，以及引入映射文件（M</summary>
      
    
    
    
    <category term="springboot2" scheme="http://www.bojiboqi.fun/categories/springboot2/"/>
    
    
    <category term="ssm" scheme="http://www.bojiboqi.fun/tags/ssm/"/>
    
  </entry>
  
  <entry>
    <title>知识点</title>
    <link href="http://www.bojiboqi.fun/2024/01/26/%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A%EF%BC%88BUG%EF%BC%89/"/>
    <id>http://www.bojiboqi.fun/2024/01/26/%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A%EF%BC%88BUG%EF%BC%89/</id>
    <published>2024-01-26T11:04:58.916Z</published>
    <updated>2024-01-26T11:05:38.910Z</updated>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h4 id="找不到mybatis文件：java-io-IOException-Could-not-find-resource-mybatis-config-xml">找不到mybatis文件：java.io.IOException: Could not find resource mybatis.config.xml</h4><p>bug:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688470269608-4fd3e82c-3631-4e0b-8beb-476c4d5ecdac.png#averageHue=%23080302&amp;clientId=u485c1c2b-dc00-4&amp;from=paste&amp;height=144&amp;id=u3d173d10&amp;originHeight=180&amp;originWidth=824&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=28618&amp;status=done&amp;style=none&amp;taskId=uaf61014d-875b-4936-b7c1-15aa27842ac&amp;title=&amp;width=659.2" alt="image.png"><br>原因：mybatis中的<mapper>映射不正确外加生成sqlssesion的文件引用不正确<br>修改后：这里的mybatis-config.xm;和com在同一个目录下的，EmpMapper.xml使用相对路径表示为：com/example/demo/mapper/EmpMapper<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688469950619-71023303-ad70-4420-b551-9f37823c8a45.png#averageHue=%231f5043&amp;clientId=u485c1c2b-dc00-4&amp;from=paste&amp;height=214&amp;id=uaf338d14&amp;originHeight=268&amp;originWidth=1191&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=57097&amp;status=done&amp;style=none&amp;taskId=u9ac5034a-e989-49c8-a528-373d7d2ca32&amp;title=&amp;width=952.8" alt="image.png"><br>修改文件引用：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688470214376-cfb36d91-a17c-4da4-98e9-fbd48850bf9e.png#averageHue=%23141624&amp;clientId=u485c1c2b-dc00-4&amp;from=paste&amp;height=160&amp;id=u03f0c4f0&amp;originHeight=200&amp;originWidth=939&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=47710&amp;status=done&amp;style=none&amp;taskId=u723765e0-d52d-4b36-97d7-098d7693021&amp;title=&amp;width=751.2" alt="image.png"></p><h4 id="复制代码出现NBSP乱码解决：">复制代码出现NBSP乱码解决：</h4><p>现象：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688525778810-d3623e70-93ba-442d-ac3d-927546917921.png#averageHue=%23141618&amp;clientId=uac13984f-90f3-4&amp;from=paste&amp;height=282&amp;id=u8819c1e9&amp;originHeight=352&amp;originWidth=515&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=47152&amp;status=done&amp;style=none&amp;taskId=u3db9185b-8b9b-4a40-ac2b-c41dd916243&amp;title=&amp;width=412" alt="image.png"><br>分析：NBSP（Non-Breaking SPace）是一个不换行的空格字符，它的 Unicode 编码是 U+00A0。有时候，当我们从其他地方复制文本到 IDEA 中，可能会出现 NBSP 字符<br>解决方法：<br>按下ctrl+shift+r打开全局替换：在全局替换中找到有问题的地方，可能直接输入\u00A0查找无法查找，这个时候可以找到有问题的内容（也就是刚刚复制过来的），选择NBSP复制后（复制后粘贴在第一个搜索框中，这个时候显示的是空格）在第二个搜索框中输入空格。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688525869991-7e4727b9-4297-412c-9bd3-fc66dcce6ae8.png#averageHue=%23628d64&amp;clientId=uac13984f-90f3-4&amp;from=paste&amp;height=711&amp;id=u9d096788&amp;originHeight=889&amp;originWidth=704&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=103409&amp;status=done&amp;style=none&amp;taskId=u33a200ee-a893-457e-b8cd-4c945c924fd&amp;title=&amp;width=563.2" alt="image.png"></p><h4 id="org-springframework-beans-factory-xml-XmlBeanDefinitionStoreException-Line-6-in-XML-document-from-class-path-resource-spring-datasource-xml-is-invalid-nested-exception-is-org-xml-sax-SAXParseException-lineNumber-6-columnNumber-62-cvc-complex-type-2-4-c-通配符的匹配很全面-但无法找到元素-‘context-property-placeholder’-的声明。">org.springframework.beans.factory.xml.XmlBeanDefinitionStoreException: Line 6 in XML document from class path resource [spring-datasource.xml] is invalid; nested exception is org.xml.sax.SAXParseException; lineNumber: 6; columnNumber: 62; cvc-complex-type.2.4.c: 通配符的匹配很全面, 但无法找到元素 ‘context:property-placeholder’ 的声明。</h4><p>原因：Spring配置文件中的xsi:schemaLocation不全，上面是差context标签的<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688547837996-e5cb89c8-82d1-4a26-9861-9ee5261fa7ec.png#averageHue=%23131317&amp;clientId=ua2de3bac-fb89-4&amp;from=paste&amp;height=119&amp;id=u5b2faab4&amp;originHeight=149&amp;originWidth=1170&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=36135&amp;status=done&amp;style=none&amp;taskId=ud3fe35d5-0254-47d1-adb9-919a77e9882&amp;title=&amp;width=936" alt="image.png"><br>解决方法：添加<a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a><br><a href="http://www.springframework.org/schema/context/spring-context.xsd">http://www.springframework.org/schema/context/spring-context.xsd</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688547915036-3729279c-19a4-4b3a-9bf8-787bdd66c6fe.png#averageHue=%23102128&amp;clientId=ua2de3bac-fb89-4&amp;from=paste&amp;height=218&amp;id=ubd390c4e&amp;originHeight=273&amp;originWidth=1088&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=51474&amp;status=done&amp;style=none&amp;taskId=ue9a6a315-d7c6-442a-9ab7-52019860091&amp;title=&amp;width=870.4" alt="image.png"></p><h4 id="编译失败-内部java编译器错误：打开设置对照下面图片">编译失败:内部java编译器错误：打开设置对照下面图片</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688988544489-1206a90e-2389-4eba-ac69-e911b209fc40.png#averageHue=%23090808&amp;clientId=ud1bacd7a-acda-4&amp;from=paste&amp;height=364&amp;id=u68d27fb0&amp;originHeight=455&amp;originWidth=1192&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=46683&amp;status=done&amp;style=none&amp;taskId=uee17bef8-9089-45af-9356-97ccc8ea041&amp;title=&amp;width=953.6" alt="image.png"></p><h4 id="ctrl点击类可以进入类内部">ctrl点击类可以进入类内部</h4><p><a href="https://blog.csdn.net/BingTaiLi/article/details/109735778">解决Maven ‘parent.relativePath‘ of POM_BingTaiLi的博客-CSDN博客</a><br><parent>标签中加上<relativePath />是用来指定父级pom文件的相对路径为空的，也就是说，不会在本地文件系统中查找父级pom文件，而是直接从本地仓库或远程仓库中查找。这样可以避免一些不必要的错误或警告，</p><h4 id="class-lombok-javac-apt-LombokProcessor-in-unnamed-module-0x7be1ce6a-cannot-access-class-com-sun-tools-javac-processing-JavacProcessingEnvironment-in-module-jdk-compiler-because-module-jdk-compiler-does-not-export-com-sun-tools-javac-processing-to-unnamed-module-0x7be1ce6a">class lombok.javac.apt.LombokProcessor (in unnamed module @0x7be1ce6a) cannot access class com.sun.tools.javac.processing.JavacProcessingEnvironment (in module jdk.compiler) because module jdk.compiler does not export com.sun.tools.javac.processing to unnamed module @0x7be1ce6a</h4><p>原因分析：lombok的版本太低了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="IDEA鼠标光标变成了白色粗条，无法正常换行">IDEA鼠标光标变成了白色粗条，无法正常换行</h4><p>原因分析：按住了insert进入覆盖模式了。再次按insert就可以变成原本的模式。</p>]]></content>
    
    
      
      
    <summary type="html"> &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h4 id=&quot;找不到mybatis文件：java-io-IOException-Could-not-find-resource-mybatis-config-xml&quot;&gt;找不到mybati</summary>
      
    
    
    
    
    <category term="bug" scheme="http://www.bojiboqi.fun/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>前端bug</title>
    <link href="http://www.bojiboqi.fun/2024/01/26/%E5%89%8D%E7%AB%AF%E8%99%AB%E5%B7%A2%EF%BC%9A/"/>
    <id>http://www.bojiboqi.fun/2024/01/26/%E5%89%8D%E7%AB%AF%E8%99%AB%E5%B7%A2%EF%BC%9A/</id>
    <published>2024-01-26T11:03:51.328Z</published>
    <updated>2024-01-26T11:04:35.797Z</updated>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h4 id="Uncaught-TypeError-Vue-is-not-a-constructor">Uncaught TypeError: Vue is not a constructor</h4><p>错误描述：<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688607718270-92d49fc2-be09-47e1-be5b-d859947b381e.png#averageHue=%23ca9e64&amp;clientId=u3fbcc324-fcac-4&amp;from=paste&amp;height=610&amp;id=uc2ecf945&amp;originHeight=762&amp;originWidth=788&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=25150&amp;status=done&amp;style=none&amp;taskId=uec197f31-8ed4-4f45-9cd4-3c059ba9b74&amp;title=&amp;width=630.4" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Hello World!&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;!--通过CDN引入全局的vue.js文件--&gt;</span><br><span class="line">&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;&#123;&#123;mess&#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        Hello, Vue!</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        //创建Vue的实例并且绑定</span><br><span class="line">        var app = new Vue ( &#123;</span><br><span class="line">            el:&quot;#app&quot;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                mes:&quot;hello world!!&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      </span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>原因：通过CDN导入的vue3，应该导入vue2<br>修改：将</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--通过CDN引入全局的vue.js文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>改成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="启动vue项目管理显示断开连接：">启动vue项目管理显示断开连接：</h4><p>输入vue ui启动项目管理遇到的问题：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688713252188-4bec1391-94c0-4841-bca0-b7f8af05a9a4.png#averageHue=%232d2d2c&amp;clientId=u8b3834fa-4e23-4&amp;from=paste&amp;id=uf7c369f1&amp;originHeight=427&amp;originWidth=732&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=36947&amp;status=done&amp;style=none&amp;taskId=u01ba1473-7c1c-46b9-aa4e-e0f94f6560b&amp;title=" alt="image.png"><br>解决方法：添加系统环境变量：C:\Windows\System32；</p><h4 id="删除vue项目的一个自定义组件后报-error-Component-name-“elinput”-should-always-be-multi-word-vue-multi-word-component-namesimage-png">删除vue项目的一个自定义组件后报:error  Component name “elinput” should always be multi-word  vue/multi-word-component-names<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688782766237-782a2b10-9b07-4e14-8488-62f33a283ffd.png#averageHue=%23161617&amp;clientId=u5cbc3a4f-bffa-4&amp;from=paste&amp;height=285&amp;id=u4aeece03&amp;originHeight=356&amp;originWidth=1286&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=36451&amp;status=done&amp;style=none&amp;taskId=u19fc7b30-183f-4f96-be81-e5e974108cc&amp;title=&amp;width=1028.8" alt="image.png"></h4><p>原因：可能是你没有完全卸载eslint，它可能还存在于全局安装的包中。你可以使用npm list -g命令查看全局安装的包，如果看到eslint，就可以使用npm uninstall -g eslint --save命令卸载它。</p><h4 id="Duplicate-entry-‘1’-for-key-‘t-emp-PRIMARY’">Duplicate entry ‘1’ for key ‘t_emp.PRIMARY’</h4><p>Duplicate：重复；原因：插入sql的主键重复了</p><h4 id="Uncaught-runtime-errors-ERROR-vue-WEBPACK-IMPORTED-MODULE-0-default-is-undefined">Uncaught runtime errors:ERROR:vue__WEBPACK_IMPORTED_MODULE_0__.default is undefined</h4><p>错误描述：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688967384172-2dc1b1e9-349a-4014-80e1-e9e546981567.png#averageHue=%23332123&amp;clientId=ue1e7ae7b-b956-4&amp;from=paste&amp;height=366&amp;id=u9f359619&amp;originHeight=457&amp;originWidth=838&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=48331&amp;status=done&amp;style=none&amp;taskId=u8df096df-24a2-4ec8-83c2-9f62c2077ce&amp;title=&amp;width=670.4" alt="Snipaste_2023-07-10_13-36-22.png"><br>原因：<br>我的项目使用的是 vue 3.3.4 版本，但是你的 main.js 文件中使用的是 vue 2 的语法。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1688967460719-06ddfd72-8351-481a-bab4-7174989c78ed.png#averageHue=%23251c10&amp;clientId=ue1e7ae7b-b956-4&amp;from=paste&amp;height=122&amp;id=u0f48bdbc&amp;originHeight=153&amp;originWidth=550&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=14095&amp;status=done&amp;style=none&amp;taskId=ucb48d7ee-32a5-422d-95d1-f443209333d&amp;title=&amp;width=440" alt="image.png"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">Vue.config.productionTip = false </span><br><span class="line">Vue.use(Vuex)</span><br><span class="line">let store = new Vuex.Store(&#123; </span><br><span class="line">state:&#123;</span><br><span class="line">count: 100 </span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">new Vue(&#123; </span><br><span class="line">store,</span><br><span class="line">render: h =&gt; h(App), </span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure><p>修改方法：<br>方法1：main.js中使用vue3的语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line"></span><br><span class="line">let store = new Vuex.Store(&#123; </span><br><span class="line">state:&#123;</span><br><span class="line">count: 100 </span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const app = createApp(App)</span><br><span class="line">app.use(store)</span><br><span class="line">app.mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure><p>方法2：重新创建一个项目，创建项目的时候注意选择vue2版本的。</p><h4 id=""></h4>]]></content>
    
    
      
      
    <summary type="html"> &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h4 id=&quot;Uncaught-TypeError-Vue-is-not-a-constructor&quot;&gt;Uncaught TypeError: Vue is not a construc</summary>
      
    
    
    
    <category term="杂项" scheme="http://www.bojiboqi.fun/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="bug" scheme="http://www.bojiboqi.fun/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>Vue学习笔记</title>
    <link href="http://www.bojiboqi.fun/2024/01/26/Vue_/"/>
    <id>http://www.bojiboqi.fun/2024/01/26/Vue_/</id>
    <published>2024-01-26T11:02:03.445Z</published>
    <updated>2024-01-26T11:02:51.212Z</updated>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1698826781345-f33295d9-eb1c-4c57-bf25-a24336fbf099.jpeg" alt=""></p><h2 id="1-vuecli创建项目：">1.vuecli创建项目：</h2><p><a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">创建一个项目 | Vue CLI</a><br>先安装Vue CLI:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure><p>方法1：在要创建的项目所在的文件夹中使用：vue create 项目名，然后在选择要创建的Vue版本。<br>方法2：在要创建项目的所在位置使用: vue ui打开图形化界面来创建项目<br>2.Vue组件命令的时候，一定要使用大驼峰命名发，否则vueCli导入组<br>件的时候不成功。导入组件可以用。导入组件成功后使用导入的组件可以把大驼峰转化为小驼峰加下划线使用。<br>3.main.js进行的组件注册是全局注册。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1698624062058-a6666eeb-6f1b-4edb-bfd5-d71fafa6fd7f.jpeg" alt=""></p><ol><li><strong>全局样式</strong>: 默认组件中的样式会作用到全局，任何一个组件中都会受到此样式的影响</li><li><strong>局部样式</strong>: 可以给组件加上<strong>scoped</strong> 属性,可以<strong>让样式只作用于当前组件</strong></li></ol><h3 id="3-scoped原理">3.scoped原理</h3><ol><li>当前组件内标签都被添加<strong>data-v-hash值</strong> 的属性</li><li>css选择器都被添加 [<strong>data-v-hash值</strong>] 的属性选择器</li></ol><h3 id="data为什么要写成函数">data为什么要写成函数</h3><p>一个组件的 <strong>data</strong> 选项必须<strong>是一个函数</strong>。目的是为了：保证每个组件实例，维护<strong>独立</strong>的一份<strong>数据</strong>对象。<br>每次创建新的组件实例，都会新<strong>执行一次data 函数</strong>，得到一个新对象。</p><h3 id="父子通信流程">父子通信流程</h3><ol><li>父组件通过 <strong>props</strong> 将数据传递给子组件</li><li>子组件利用 <strong>$emit</strong> 通知父组件修改更新</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698626345412-e776382b-4d4e-43e4-9b59-255a383fd7c8.png#averageHue=%23e6f3ef&amp;clientId=u95097dde-b906-4&amp;from=paste&amp;height=406&amp;id=u08b5f34f&amp;originHeight=507&amp;originWidth=1173&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=66653&amp;status=done&amp;style=none&amp;taskId=u1cece604-df11-4e22-b9bc-96faef5930a&amp;title=&amp;width=938.4" alt="image.png"></p><h3 id="父向子通信：">父向子通信：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698626400257-f2d3adad-e74f-4951-80e2-55d2c762797a.png#averageHue=%2325201f&amp;clientId=u95097dde-b906-4&amp;from=paste&amp;height=368&amp;id=u1025f78c&amp;originHeight=460&amp;originWidth=1205&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=204825&amp;status=done&amp;style=none&amp;taskId=ubed31dde-a2bc-49d7-a8e7-5ca88e6589d&amp;title=&amp;width=964" alt="image.png"><br>父向子传值步骤</p><ol><li>给子组件以添加属性的方式传值</li><li>子组件内部通过props接收</li><li>模板中直接使用 props接收的值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>props是properties的缩写</span><br><span class="line"><span class="number">2.</span>可以理解为javaScript中给每个组件声明了一个属性，通过:属性名的方法，将属性和data绑定起来，父组件</span><br><span class="line">通过给属性赋值，从而达到给子组件传递信息的目的</span><br><span class="line"><span class="number">2.</span>组件的props可以为任意数量和任意类型</span><br><span class="line"><span class="number">3.</span>其属性赋值是通过外部父组件来赋值的，当父组件没有给某些属性赋值的时候为默认值</span><br></pre></td></tr></table></figure><h2 id="props校验完整写法">props校验完整写法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  校验的属性名: &#123;</span><br><span class="line">    type: 类型,  <span class="comment">// Number String Boolean ...</span></span><br><span class="line">    required: <span class="literal">true</span>, <span class="comment">// 是否必填</span></span><br><span class="line">    <span class="keyword">default</span>: 默认值, <span class="comment">// 默认值</span></span><br><span class="line">    validator (value) &#123;</span><br><span class="line">      <span class="comment">// 自定义校验逻辑</span></span><br><span class="line">      <span class="keyword">return</span> 是否通过校验</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>1.default和required一般不同时写（因为当时必填项时，肯定是有值的）<br>2.default后面如果是简单类型的值，可以直接写默认。如果是复杂类型的值，则需要以函数的形式return一个默认值</p><h2 id="props-data的区别：">props&amp;data的区别：</h2><ul><li>data 的数据是<strong>自己</strong>的  →   随便改</li><li>prop 的数据是<strong>外部</strong>的  →   不能直接改，要遵循 <strong>单向数据流</strong></li></ul><p>子组件向父组件传递信息：主要是通过事件冒泡来实现的<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698627545540-57bebd25-271c-46f9-965a-23c8618d8fe5.png#averageHue=%2388841b&amp;clientId=u95097dde-b906-4&amp;from=paste&amp;height=509&amp;id=u5239efe5&amp;originHeight=636&amp;originWidth=1491&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=380249&amp;status=done&amp;style=none&amp;taskId=uede67725-b835-485b-bf05-4df2fe583a3&amp;title=&amp;width=1192.8" alt="image.png"><br>子向父传值步骤</p><ol><li>$emit触发事件，给父组件发送消息通知</li><li>父组件监听$emit触发的事件</li><li>提供处理函数，在函数的性参中获取传过来的参数</li><li><a href="https://cn.vuejs.org/guide/components/props.html#prop-validation">Props | Vue.js</a></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698631510086-67d49f7b-b8cc-443f-b57f-5a76a2cede7c.png#averageHue=%23212121&amp;clientId=u95097dde-b906-4&amp;from=paste&amp;height=166&amp;id=uf3fd8966&amp;originHeight=207&amp;originWidth=1185&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=39141&amp;status=done&amp;style=none&amp;taskId=u5c86521e-ae81-4c6d-8b14-f711a9dc2a7&amp;title=&amp;width=948" alt="image.png"></p><h2 id="非父子通信-event-bus-事件总线">非父子通信-event bus 事件总线</h2><h3 id="2-步骤">2.步骤</h3><ol><li>在一个js文件中创建一个都能访问的事件总线 （空Vue实例）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue from <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="type">const</span> <span class="variable">Bus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vue</span>()</span><br><span class="line">export <span class="keyword">default</span> Bus</span><br></pre></td></tr></table></figure><p>A组件（接受方），监听Bus的 $on事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">  Bus.$on(<span class="string">&#x27;sendMsg&#x27;</span>, (msg) =&gt; &#123;</span><br><span class="line">    <span class="built_in">this</span>.msg = msg</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B组件（发送方），触发Bus的$emit事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bus.$emit(<span class="string">&#x27;sendMsg&#x27;</span>, <span class="string">&#x27;这是一个消息&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698636317024-ed96fe9a-a0e1-4fed-a41f-9d3bc47c8f13.png#averageHue=%23f7f3f2&amp;clientId=u95097dde-b906-4&amp;from=paste&amp;height=530&amp;id=u3eab1ac4&amp;originHeight=662&amp;originWidth=1069&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=149416&amp;status=done&amp;style=none&amp;taskId=ub9fc78d3-3b61-4635-974c-25487e8f786&amp;title=&amp;width=855.2" alt="image.png"><br>这种通信实际上是通过总线也就是第三方vue来实现的，接受方使用$on方法在总线中注册事件（包括事件处理函数）或者说是注册监听器，然后发送方可以使用$emit调用接收方往总线中添加的事件，使用$emit方法调用总线中的事件的时候通过$emit的第二个参数就实现了传递数据了。简单来说就是接受数据的一方将要对数据的处理写入总线Vue中，发送数据的一凡通过$emit方法传递数据并调用方法进行处理。</p><h2 id="非父子通信-provide-inject：">非父子通信-provide&amp;inject：</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698635901968-0cd2aa5a-e07a-4c1e-b375-bd44716e3694.png#averageHue=%237db093&amp;clientId=u95097dde-b906-4&amp;from=paste&amp;height=417&amp;id=u32c84a3f&amp;originHeight=521&amp;originWidth=1056&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=51141&amp;status=done&amp;style=none&amp;taskId=u1770605b-da88-4f7b-bc78-b73dbe41271&amp;title=&amp;width=844.8" alt="image.png"></p><ol><li>父组件 provide提供数据</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> &#123;</span><br><span class="line">  provide () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">       <span class="comment">// 普通类型【非响应式】</span></span><br><span class="line">       color: <span class="built_in">this</span>.color, </span><br><span class="line">       <span class="comment">// 复杂类型【响应式】</span></span><br><span class="line">       userInfo: <span class="built_in">this</span>.userInfo, </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.子/孙组件 inject获取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> &#123;</span><br><span class="line">  inject: [<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;userInfo&#x27;</span>],</span><br><span class="line">  created () &#123;</span><br><span class="line">    console.log(<span class="built_in">this</span>.color, <span class="built_in">this</span>.userInfo)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-注意">4.注意</h3><ul><li>provide提供的简单类型的数据不是响应式的，复杂类型数据是响应式。（推荐提供复杂类型数据）</li><li>子/孙组件通过inject获取的数据，不能在自身组件内修改</li></ul><h2 id="v-model">v-model:</h2><p>提供数据的双向绑定</p><ul><li>数据变，视图跟着变 :value</li><li>视图变，数据跟着变 <a href="/input">@input </a></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1698637980586-383af282-f155-4287-bcc5-aef301ea9041.png#averageHue=%23202020&amp;clientId=u95097dde-b906-4&amp;from=paste&amp;height=174&amp;id=u72bd7179&amp;originHeight=217&amp;originWidth=677&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=40698&amp;status=done&amp;style=none&amp;taskId=uf83fb5e0-7535-4e96-8f7c-599f7e57a2a&amp;title=&amp;width=541.6" alt="image.png"><br><a href="https://blog.csdn.net/muzidigbig/article/details/85317387">vue中$nextTick的用法(视图渲染完，操作dom)-CSDN博客</a><br><a href="https://blog.csdn.net/zhouzuoluo/article/details/84752280">vue.nextTick()方法的使用详解（简单明了）_$nexttick-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html"> &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1698826781345-f33295d9-eb1c-4c57</summary>
      
    
    
    
    <category term="前端" scheme="http://www.bojiboqi.fun/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://www.bojiboqi.fun/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="vue" scheme="http://www.bojiboqi.fun/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Springboot学习笔记</title>
    <link href="http://www.bojiboqi.fun/2024/01/26/Springboot_/"/>
    <id>http://www.bojiboqi.fun/2024/01/26/Springboot_/</id>
    <published>2024-01-26T10:58:38.778Z</published>
    <updated>2024-01-26T11:00:18.847Z</updated>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h1>1.创建第一个项目：</h1><h2 id="1-引入依赖：">1.引入依赖：</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    所有springboot项目都必须继承自 spring-boot-starter-parent ,如果报--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里可能会报错：<a href="https://blog.csdn.net/BingTaiLi/article/details/109735778">解决Maven ‘parent.relativePath‘ of POM_BingTaiLi的博客-CSDN博客</a></p><h3 id="2-导入场景">2. 导入场景</h3><p>场景启动器</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        web开发的场景启动器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-主程序">3. 主程序</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication //这是一个SpringBoot应用</span><br><span class="line">public class MainApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-业务">4. 业务</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RestController//将返回内容写入返回体中</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello()&#123;</span><br><span class="line"></span><br><span class="line">        return &quot;Hello,Spring Boot 3!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-测试">5. 测试</h3><p>默认启动访问： localhost:8080/hello</p><h3 id="6-打包">6. 打包</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    SpringBoot应用打包插件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>mvn clean package把项目打成可执行的jar包<br>java -jar demo.jar启动项目<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1689254342403-1c7d5be2-59f7-4d6a-8fa3-8cdcff5aa805.png#averageHue=%233b1f02&amp;clientId=uc9135780-ac3d-4&amp;from=paste&amp;height=262&amp;id=u4bd0926f&amp;originHeight=327&amp;originWidth=581&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=29111&amp;status=done&amp;style=none&amp;taskId=u817b6fc9-a2b3-41c6-beca-6e10804204b&amp;title=&amp;width=464.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1689254431253-f1db82c5-2aff-4240-bbea-b4abbaeb24aa.png#averageHue=%23fbfaf8&amp;clientId=uc9135780-ac3d-4&amp;from=paste&amp;height=269&amp;id=u27e3853e&amp;originHeight=336&amp;originWidth=720&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=38821&amp;status=done&amp;style=none&amp;taskId=ua69cfde8-d2bd-4782-ab37-348c54090d6&amp;title=&amp;width=576" alt="image.png"><br>在该路径下输入cmd，然后运行jar包（命令:jva -jar demo.jar,注意这里必须要字面-jar，因为运行的是jar包）<br>但是能够成功运行要求系统java的环境变量配置的jdk17以上。</p><h1>3、应用分析</h1><p>思考：<br>1、为什么导入starter-web所有相关依赖都导入进来？</p><ul><li>开发什么场景，导入什么<strong>场景启动器。</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--● 官方提供的场景：命名为：spring-boot-starter-*</span></span><br><span class="line"><span class="comment">● 第三方提供场景：命名为：*-spring-boot-starter</span></span><br><span class="line"><span class="comment">ctrl+鼠标右键即可在IDEA查看相关场景所依赖的jar包和场景--&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>maven依赖传递原则。A-B-C： A就拥有B和C</strong></li><li>导入 场景启动器。 场景启动器 自动把这个场景的所有核心依赖全部导入进来</li></ul><p>2、为什么版本号都不用写？</p><ul><li>每个boot项目都有一个父项目spring-boot-starter-parent（它也是一个场景）</li><li>parent的父项目是spring-boot-dependencies（其中的<properties>标签中把所有常见的jar的依赖版本都声明好了。）</li><li>父项目 <strong>版本仲裁中心</strong>，把所有常见的jar的依赖版本都声明好了。</li><li>比如：mysql-connector-j</li><li><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1689258459738-3f6e1e17-aff8-45a2-9c3e-e5e00b943868.png#averageHue=%2312151c&amp;clientId=uc9135780-ac3d-4&amp;from=paste&amp;height=410&amp;id=u0c91b9c1&amp;originHeight=512&amp;originWidth=890&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=95403&amp;status=done&amp;style=none&amp;taskId=ua520442b-66a3-465a-bfe4-8badcfef6af&amp;title=&amp;width=712" alt="image.png"></li></ul><p>3、自定义版本号</p><ul><li>利用maven的就近原则<ul><li>直接在当前项目properties标签中声明父项目用的版本属性的key</li><li>直接在<strong>导入依赖的时候声明版本</strong></li></ul></li></ul><p>4、第三方的jar包</p><ul><li>boot父项目没有管理的需要自行声明好</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1689257659269-0968fa4d-b7a3-45a8-9fde-d2d34eb062bf.png#averageHue=%23dcb88c&amp;clientId=uc9135780-ac3d-4&amp;from=paste&amp;height=343&amp;id=u81f02c80&amp;originHeight=429&amp;originWidth=864&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=35824&amp;status=done&amp;style=none&amp;taskId=u601e8e76-00f7-4aec-86cf-eb00c95aad8&amp;title=&amp;width=691.2" alt="image.png"></p><h2 id="2-自动配置机制">2. 自动配置机制</h2><h3 id="1-初步理解">1. 初步理解</h3><ul><li><strong>自动配置</strong>的 Tomcat、SpringMVC 等<ul><li><strong>导入场景</strong>，容器中就会自动配置好这个场景的核心组件。</li><li>以前：DispatcherServlet、ViewResolver、CharacterEncodingFilter…</li><li>现在：自动配置好的这些组件</li><li>验证：<strong>容器中有了什么组件，就具有什么功能</strong></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    //java10： 局部变量类型的自动推断（可以不用声明变量的类型，直接根据右边的表达式推断）</span><br><span class="line">    var ioc = SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">    //1、获取容器中所有组件的名字</span><br><span class="line">    String[] names = ioc.getBeanDefinitionNames();</span><br><span class="line">    //2、挨个遍历：</span><br><span class="line">    // dispatcherServlet、beanNameViewResolver、characterEncodingFilter、multipartResolver</span><br><span class="line">    // SpringBoot把以前配置的核心组件现在都给我们自动配置好了。</span><br><span class="line">    for (String name : names) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>默认的包扫描规则</strong><ul><li>@SpringBootApplication 标注的类就是主程序类</li><li><strong>SpringBoot只会扫描主程序所在的包及其下面的子包，自动的component-scan功能</strong></li><li><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1689259030746-d45575cd-4785-4951-aea6-41a141d23f5c.png#averageHue=%23267d49&amp;clientId=uc9135780-ac3d-4&amp;from=paste&amp;height=202&amp;id=x93dY&amp;originHeight=252&amp;originWidth=1193&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=55265&amp;status=done&amp;style=none&amp;taskId=u319fb788-593b-49b5-a964-acbd641d340&amp;title=&amp;width=954.4" alt="image.png"></li><li><strong>自定义扫描路径</strong><ul><li>@SpringBootApplication(scanBasePackages = “com.atguigu”)//scanBasePackages指定扫描的位置</li><li>@ComponentScan(“com.atguigu”) 直接指定扫描的路径</li></ul></li></ul></li><li><strong>配置默认值</strong><ul><li><strong>配置文件</strong>的所有配置项是和某个<strong>类的对象</strong>值进行一一绑定的。</li><li>绑定了配置文件中每一项值的类： <strong>属性类</strong>。</li><li>比如：<ul><li>ServerProperties绑定了所有Tomcat服务器有关的配置</li><li>MultipartProperties绑定了所有文件上传相关的配置</li><li>…参照<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.server">官方文档</a>：或者参照 绑定的 <strong>属性类</strong>。</li></ul></li></ul></li><li>按需加载自动配置<ul><li>导入场景spring-boot-starter-web</li><li>场景启动器除了会导入相关功能依赖(ctrl+鼠标右击可以查看导入的依赖），还导入一个spring-boot-starter(每个场景ctrl点进去的配置文件都有一个的spring-boot-starter），是所有starter的starter，这个starter基础核心starter</li><li>spring-boot-starter导入了一个包 spring-boot-autoconfigure。包里面都是各种场景的AutoConfiguration<strong>自动配置类</strong></li><li>虽然全场景的自动配置都在 spring-boot-autoconfigure这个包，但是不是全都开启的。<ul><li>导入哪个场景就开启哪个自动配置</li></ul></li></ul></li></ul><p>总结： 导入场景启动器、触发 spring-boot-autoconfigure这个包的自动配置生效、容器中就会具有相关场景的功能</p><h2 id="1-常用注解">1. 常用注解</h2><p>SpringBoot摒弃XML配置方式，改为<strong>全注解驱动</strong></p><h3 id="1-组件注册">1. 组件注册</h3><p><strong>@Configuration</strong>、<strong>@SpringBootConfiguration</strong><br><strong>@Bean</strong>、<strong>@Scope</strong><br><strong>@Controller、 @Service、@Repository、@Component</strong><br><strong>@Import</strong><br>@ComponentScan<br>步骤：<br><strong>1、@Configuration 编写一个配置类</strong><br><strong>2、在配置类中，自定义方法给容器中注册组件。配合@Bean</strong><br><strong>3、或使用@Import 导入第三方的组件</strong></p><h3 id="2-条件注解">2. 条件注解</h3><p>如果注解指定的<strong>条件成立</strong>，则触发指定行为<br><em><strong>@ConditionalOnXxx</strong></em><br><strong>@ConditionalOnClass：如果类路径中存在这个类，则触发指定行为</strong><br><strong>@ConditionalOnMissingClass：如果类路径中不存在这个类，则触发指定行为</strong><br><strong>@ConditionalOnBean：如果容器中存在这个Bean（组件），则触发指定行为</strong><br><strong>@ConditionalOnMissingBean：如果容器中不存在这个Bean（组件），则触发指定行为</strong><br>场景：</p><ul><li>如果存在FastsqlException这个类，给容器中放一个Cat组件，名cat01，</li><li>否则，就给容器中放一个Dog组件，名dog01</li><li>如果系统中有dog01这个组件，就给容器中放一个 User组件，名zhangsan</li><li>否则，就放一个User，名叫lisi</li></ul><p><strong>@ConditionalOnBean（value=组件类型，name=组件名字）：判断容器中是否有这个类型的组件，并且名字是指定的值</strong></p><p>@ConditionalOnRepositoryType (org.springframework.boot.autoconfigure.data)<br>@ConditionalOnDefaultWebSecurity (org.springframework.boot.autoconfigure.security)<br>@ConditionalOnSingleCandidate (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnWebApplication (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnWarDeployment (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnJndi (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnResource (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnExpression (org.springframework.boot.autoconfigure.condition)<br><strong>@ConditionalOnClass</strong> (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnEnabledResourceChain (<a href="http://org.springframework.boot.autoconfigure.web">org.springframework.boot.autoconfigure.web</a>)<br><strong>@ConditionalOnMissingClass</strong>(org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnNotWebApplication (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnProperty (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnCloudPlatform (org.springframework.boot.autoconfigure.condition)<br><strong>@ConditionalOnBean</strong> (org.springframework.boot.autoconfigure.condition)<br><strong>@ConditionalOnMissingBean</strong> (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnMissingFilterBean (org.springframework.boot.autoconfigure.web.servlet)<br>@Profile (org.springframework.context.annotation)<br>@ConditionalOnInitializedRestarter (org.springframework.boot.devtools.restart)<br>@ConditionalOnGraphQlSchema (org.springframework.boot.autoconfigure.graphql)<br>@ConditionalOnJava (org.springframework.boot.autoconfigure.condition)</p><h3 id="3-属性绑定">3. 属性绑定</h3><p><strong>@ConfigurationProperties： 声明组件的属性和配置文件哪些前缀开始项进行绑定</strong><br><strong>@EnableConfigurationProperties：快速注册注解：</strong></p><ul><li><strong>场景：<strong>SpringBoot默认只扫描自己主程序所在的包。如果导入第三方包，即使组件上标注了 @Component、@ConfigurationProperties 注解，也没用。因为组件都扫描不进来，此时使用这个注解就可以快</strong>速进行属性绑定并把组件注册进容器</strong></li></ul><p>将容器中任意<strong>组件（Bean）的属性值</strong>和<strong>配置文件</strong>的配置项的值<strong>进行绑定</strong></p><ul><li><strong>1、给容器中注册组件（@Component、@Bean）</strong></li><li><strong>2、使用@ConfigurationProperties 声明组件和配置文件的哪些配置项进行绑定</strong></li></ul><p>更多注解参照：<a href="https://www.bilibili.com/video/BV1gW411W7wy">Spring注解驱动开发</a>【1-26集】</p><h2 id="待复习常用注解（视频1-26集）：">待复习常用注解（视频1-26集）：</h2><h3 id="核心容器：">核心容器：</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1689338993030-dddbdbb3-8d2a-4fb6-99df-400c6bffe713.png#averageHue=%23f6f9f6&amp;clientId=u50cc7f0e-9aa6-4&amp;from=paste&amp;height=117&amp;id=u6123668b&amp;originHeight=146&amp;originWidth=414&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=22183&amp;status=done&amp;style=none&amp;taskId=u609bdd38-2b1f-48b5-86cc-fdde5105864&amp;title=&amp;width=331.2" alt="image.png"></p><h3 id="组件注册：">组件注册：</h3><h4 id="Congfiguration">@Congfiguration:</h4><p>基于xml的注入方式，需要根据<bean>标签逐渐赋值注入容器的。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1689341306219-26dac878-fe79-4a28-9b71-acf8d3693b8c.png#averageHue=%23f7fcfb&amp;clientId=u50cc7f0e-9aa6-4&amp;from=paste&amp;height=21&amp;id=u5063fa94&amp;originHeight=26&amp;originWidth=468&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=15894&amp;status=done&amp;style=none&amp;taskId=u791ed171-4320-4022-8d64-0e763d147b7&amp;title=&amp;width=374.4" alt="image.png">都有注入容器的功能</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.example.annotationstudy.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.core.io.Resource;</span><br><span class="line">import org.springframework.core.type.AnnotationMetadata;</span><br><span class="line">import org.springframework.core.type.ClassMetadata;</span><br><span class="line">import org.springframework.core.type.classreading.MetadataReader;</span><br><span class="line">import org.springframework.core.type.classreading.MetadataReaderFactory;</span><br><span class="line">import org.springframework.core.type.filter.TypeFilter;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.lang.annotation.Annotation;</span><br><span class="line"></span><br><span class="line">public class MytypeFilter implements TypeFilter</span><br><span class="line">    &#123;</span><br><span class="line">    @Override</span><br><span class="line">//    MetadataReader读取到当前真正扫描的类，MetadataReaderFactory可以获取其他任何类的信息</span><br><span class="line">    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException</span><br><span class="line">    &#123;</span><br><span class="line">//        获取当前正在扫描的类的注解信息</span><br><span class="line">        AnnotationMetadata annotation= metadataReader.getAnnotationMetadata();</span><br><span class="line">        //获取当前真正扫描类的类信息，比如它的类型是什么，实现了什么接口</span><br><span class="line">         ClassMetadata classMetadata = metadataReader.getClassMetadata();</span><br><span class="line">        //获取当前类资源信息(类路径）</span><br><span class="line">       Resource resource =  metadataReader.getResource();</span><br><span class="line">       String className =classMetadata.getClassName();</span><br><span class="line">        System.out.println(&quot;---&gt;&quot;+className);</span><br><span class="line">        if(className.contains(&quot;er&quot;))</span><br><span class="line">        return  true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">package com.example.annotationstudy;</span><br><span class="line"></span><br><span class="line">import com.example.annotationstudy.config.test;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line">//SpringApplication.run(AnnotationStudyApplication.class, args);</span><br><span class="line">public class AnnotationStudyApplication</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        ApplicationContext applicationContext =  new AnnotationConfigApplicationContext(test.class);</span><br><span class="line">        System.out.println( applicationContext.getBean(Person.class));</span><br><span class="line">        String[] nameType = applicationContext.getBeanNamesForType(Person.class);//查看Person类的Bean数组在容器中的id数组</span><br><span class="line">        for (String string:nameType)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//    Person&#123;name=&#x27;1&#x27;, age=1&#125;</span><br><span class="line">//     person1</span><br><span class="line">@Test</span><br><span class="line">public void  test01()</span><br><span class="line">&#123;</span><br><span class="line">    ApplicationContext applicationContext =  new AnnotationConfigApplicationContext(test.class);</span><br><span class="line">    String[] nameType = applicationContext.getBeanDefinitionNames();//查看Person类的Bean数组在容器中的id数组</span><br><span class="line">    for (String string:nameType)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*没有加过滤器前的结果：</span><br><span class="line">test//@Configuration注入的组件,@Configuration注解有@Component修饰</span><br><span class="line">bookController//@Controller注入的组件</span><br><span class="line">bookDao//@Repository注入的组件</span><br><span class="line">bookService//@Service注入的组件</span><br><span class="line">person//  @Bean(&quot;person&quot;)注入的组件</span><br><span class="line">*/</span><br><span class="line">/*加了过滤器:</span><br><span class="line">test</span><br><span class="line">bookDao</span><br><span class="line">bookService</span><br><span class="line">person*/</span><br><span class="line">/*自定义过滤规则的输出结果</span><br><span class="line">---&gt;com.example.annotationstudy.AnnotationStudyApplication</span><br><span class="line">---&gt;com.example.annotationstudy.config.MytypeFilter</span><br><span class="line">---&gt;com.example.annotationstudy.controller.BookController</span><br><span class="line">---&gt;com.example.annotationstudy.dao.BookDao</span><br><span class="line">---&gt;com.example.annotationstudy.Person</span><br><span class="line">---&gt;com.example.annotationstudy.service.bookService</span><br><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">        test</span><br><span class="line">bookDao</span><br><span class="line">        person</span><br><span class="line"></span><br><span class="line">进程已结束,退出代码0*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.example.annotationstudy.config;</span><br><span class="line"></span><br><span class="line">import com.example.annotationstudy.Person;</span><br><span class="line">import com.example.annotationstudy.service.bookService;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.FilterType;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line">//配置类===配置文件</span><br><span class="line">@Configuration//告诉spring这是一个配置类</span><br><span class="line">@ComponentScan(value=&quot;com.example.annotationstudy&quot;,</span><br><span class="line">        includeFilters = &#123;@ComponentScan.Filter(type = FilterType.CUSTOM,classes = MytypeFilter.class)&#125;)</span><br><span class="line">//将Controller注解过滤掉</span><br><span class="line">//类似xml中的包扫描标签<span class="tag">&lt;<span class="name">context:component-sacn</span> <span class="attr">base-package</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">//@ComponentScan value（数组类型）指定要扫描的包， Filter[] excludeFilters();指定过滤规则；</span><br><span class="line">// Filter[] includeFilters()指定扫描只包含哪些注解</span><br><span class="line">//FilterType.ANNOTATION按照给定的注解加载（type = FilterType.ANNOTATION,classes = Controller.class)排除/只加载Contorller注解</span><br><span class="line">//FilterType.ASSIGNABLE_TYPE按照给定类型加载,type = FilterType.ASSIGNABLE_TYPE,classes = bookService.class排除/只加载bookService类型的bean</span><br><span class="line">//FilterType.REGEX按照正则表达式，</span><br><span class="line">//FilterType.CUSTOM;使用自定义规则；@ComponentScan.Filter(type = FilterType.CUSTOM,classes = MytypeFilter.class)</span><br><span class="line">//MytypeFilter.class返回ture或false决定是否排除/加载类到容器，如果为ture就加载/排除bean到容器内，其中value指定的路径下所有的类</span><br><span class="line">// 都会在MytypeFilter中进行判断，看能否加入到容器中</span><br><span class="line">public class test</span><br><span class="line">&#123;</span><br><span class="line">//    给容器中注册一个bean,类型为方法的返回值的类型，id默认为方法名作为id,其中该注解的vaule值赋值id的优先级高于方法名</span><br><span class="line">    @Bean(&quot;person&quot;)//也可以这样给bean赋值为person,最后这里注入bean的id是person;类似xml中的bean标签</span><br><span class="line">    public Person person1()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Person(&quot;1&quot;,1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-完整流程">2. 完整流程</h2><p>思考：<br><strong>1、SpringBoot怎么实现导一个starter、写一些简单配置，应用就能跑起来，我们无需关心整合</strong><br>2、为什么Tomcat的端口号可以配置在application.properties中，并且Tomcat能启动成功？<br>3、导入场景后哪些<strong>自动配置能生效</strong>？<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1679970508234-3c6b8ecc-6372-4eb5-8c67-563054d1a72d.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_37%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23b9b985&amp;from=url&amp;id=Xvkxy&amp;originHeight=583&amp;originWidth=1281&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p><em><strong>自动配置流程细节梳理：</strong></em><br>**1、**导入starter-web：导入了web开发场景</p><ul><li>1、场景启动器导入了相关场景的所有依赖：starter-json、starter-tomcat、springmvc</li><li>2、每个场景启动器都引入了一个spring-boot-starter，核心场景启动器。</li><li>3、<strong>核心场景启动器</strong>引入了spring-boot-autoconfigure包。</li><li>4、spring-boot-autoconfigure里面囊括了所有场景的所有配置。</li><li>5、只要这个包下的所有类都能生效，那么相当于SpringBoot官方写好的整合功能就生效了。</li><li>6、SpringBoot默认却扫描不到 spring-boot-autoconfigure下写好的所有<strong>配置类</strong>。（这些<strong>配置类</strong>给我们做了整合操作），<strong>默认只扫描主程序所在的包</strong>。</li></ul><p><strong>2、主程序</strong>：@SpringBootApplication</p><ul><li>1、@SpringBootApplication由三个注解组成@SpringBootConfiguration、@EnableAutoConfiguratio、@ComponentScan</li><li>2、SpringBoot默认只能扫描自己主程序所在的包及其下面的子包，扫描不到 spring-boot-autoconfigure包中官方写好的<strong>配置类</strong></li><li>3、<strong>@EnableAutoConfiguration</strong>：SpringBoot <strong>开启自动配置的核心</strong>。<ul><li><ol><li>是由@Import(AutoConfigurationImportSelector.class){，@Import是一个注解，允许您将其他配置类导入到应用程序上下文中}提供功能：批量给容器中导入组件。</li></ol></li><li><ol start="2"><li>SpringBoot启动会默认加载 142个配置类。</li></ol></li><li><ol start="3"><li>这<strong>142个配置类</strong>来自于spring-boot-autoconfigure下 META-INF/spring/<strong>org.springframework.boot.autoconfigure.AutoConfiguration</strong>.imports文件指定的</li></ol></li><li>项目启动的时候利用 @Import 批量导入组件机制把 autoconfigure 包下的142 xxxxAutoConfiguration类导入进来（<strong>自动配置类</strong>）</li><li>虽然导入了142个自动配置类</li></ul></li><li>4、按需生效：<ul><li>并不是这142个自动配置类都能生效</li><li>每一个自动配置类，都有条件注解@ConditionalOnxxx，只有条件成立，才能生效</li></ul></li></ul><p><strong>3、xxxxAutoConfiguration自动配置类</strong></p><ul><li><strong>1、给容器中使用@Bean 放一堆组件。</strong></li><li>2、每个<strong>自动配置类</strong>都可能有这个注解@EnableConfigurationProperties(<strong>ServerProperties</strong>.class)，用来把配置文件中配的指定前缀的属性值封装到 xxxProperties<strong>属性类</strong>中</li><li>3、以Tomcat为例：把服务器的所有配置都是以server开头的。配置都封装到了属性类中。</li><li>4、给<strong>容器</strong>中放的所有<strong>组件</strong>的一些<strong>核心参数</strong>，都来自于<strong>xxxProperties。xxxProperties都是和配置文件绑定。</strong></li><li><strong>只需要改配置文件的值，核心组件的底层参数都能修改</strong></li></ul><p>**4、**写业务，全程无需关心各种整合（底层这些整合写好了，而且也生效了）</p><p><strong>核心流程总结：</strong><br>1、导入starter，就会导入autoconfigure包。<br>2、autoconfigure 包里面 有一个文件 META-INF/spring/<strong>org.springframework.boot.autoconfigure.AutoConfiguration</strong>.imports,里面指定的所有启动要加载的自动配置类<br>3、@EnableAutoConfiguration 会自动的把上面文件里面写的所有<strong>自动配置类都导入进来。xxxAutoConfiguration 是有条件注解进行按需加载</strong><br>4、xxxAutoConfiguration给容器中导入一堆组件，组件都是从 xxxProperties中提取属性值<br>5、xxxProperties又是和<strong>配置文件</strong>进行了绑定<br>**效果：**导入starter、修改配置文件，就能修改底层行为。</p><h2 id="2-YAML配置文件">2. YAML配置文件</h2><p><strong>痛点</strong>：SpringBoot 集中化管理配置，application.properties<br><strong>问题</strong>：配置多以后难阅读和修改，<strong>层级结构辨识度不高</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1689294105675-0b73afd6-0887-4d7c-9d56-9e988a84a0ae.png#averageHue=%23fbfaf9&amp;clientId=uc9135780-ac3d-4&amp;from=paste&amp;height=255&amp;id=uc7eaf023&amp;originHeight=319&amp;originWidth=357&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=56709&amp;status=done&amp;style=none&amp;taskId=u8e460c2b-84b7-458e-8da8-d7cc2244fd0&amp;title=&amp;width=285.6" alt="image.png"></p><p>YAML 是 “YAML Ain’t a Markup Language”（YAML 不是一种标记语言）。在开发的这种语言时，YAML 的意思其实是：“Yet Another Markup Language”（是另一种标记语言）。</p><ul><li>设计目标，就是<strong>方便人类读写</strong></li><li><strong>层次分明</strong>，更适合做配置文件</li><li>使用.yaml或 .yml作为文件后缀</li></ul><h3 id="1-基本语法">1. 基本语法</h3><ul><li><strong>大小写敏感</strong></li><li>使用<strong>缩进表示层级关系，k: v，使用空格分割k,v</strong></li><li>缩进时不允许使用Tab键，只允许<strong>使用空格</strong>。换行</li><li>缩进的空格数目不重要，只要<strong>相同层级</strong>的元素<strong>左侧对齐</strong>即可</li><li><strong># 表示注释</strong>，从这个字符一直到行尾，都会被解析器忽略。</li></ul><p>支持的写法：</p><ul><li><strong>对象</strong>：<strong>键值对</strong>的集合，如：映射（map）/ 哈希（hash） / 字典（dictionary）</li><li><strong>数组</strong>：一组按次序排列的值，如：序列（sequence） / 列表（list）</li><li><strong>纯量</strong>：单个的、不可再分的值，如：字符串、数字、bool、日期</li></ul><h3 id="2-示例">2. 示例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;person&quot;) //和配置文件person前缀的所有配置进行绑定，</span><br><span class="line">//ConfigurationProperties注解可以将配置文件中的属性映射到一个Java Bean中。</span><br><span class="line">@Data //自动生成JavaBean属性的getter/setter</span><br><span class="line">//@NoArgsConstructor //自动生成无参构造器</span><br><span class="line">//@AllArgsConstructor //自动生成全参构造器</span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Date birthDay;</span><br><span class="line">    private Boolean like;</span><br><span class="line">    private Child child; //嵌套对象</span><br><span class="line">    private List<span class="tag">&lt;<span class="name">Dog</span>&gt;</span> dogs; //数组（里面是对象）</span><br><span class="line">    private Map&lt;String,Cat&gt; cats; //表示Map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class Dog &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class Child &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Date birthDay;</span><br><span class="line">    private List<span class="tag">&lt;<span class="name">String</span>&gt;</span> text; //数组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class Cat &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>properties表示法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">person.name=张三</span><br><span class="line">person.age=18</span><br><span class="line">person.birthDay=2010/10/12 12:12:12</span><br><span class="line">person.like=true</span><br><span class="line">person.child.name=李四</span><br><span class="line">person.child.age=12</span><br><span class="line">person.child.birthDay=2018/10/12</span><br><span class="line">person.child.text[0]=abc</span><br><span class="line">person.child.text[1]=def</span><br><span class="line">person.dogs[0].name=小黑</span><br><span class="line">person.dogs[0].age=3</span><br><span class="line">person.dogs[1].name=小白</span><br><span class="line">person.dogs[1].age=2</span><br><span class="line">person.cats.c1.name=小蓝</span><br><span class="line">person.cats.c1.age=3</span><br><span class="line">person.cats.c2.name=小灰</span><br><span class="line">person.cats.c2.age=2</span><br></pre></td></tr></table></figure><p>yaml表示法：注意数组的写法：text和dogs两种写法，cat是map的写法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">person:</span><br><span class="line">  name: 张三</span><br><span class="line">  age: 18</span><br><span class="line">  birthDay: 2010/10/10 12:12:12</span><br><span class="line">  like: true</span><br><span class="line">  child:</span><br><span class="line">    name: 李四</span><br><span class="line">    age: 20</span><br><span class="line">    birthDay: 2018/10/10</span><br><span class="line">    text: [&quot;abc&quot;,&quot;def&quot;]</span><br><span class="line">#数组的2中写法，可以是text形式还可以是dogs的形式（每一个元素用一个-表示，下面的age是一个元素里</span><br><span class="line">#面的内容，要同级并没有-表示。</span><br><span class="line">  dogs:</span><br><span class="line">    - name: 小黑</span><br><span class="line">      age: 3</span><br><span class="line">    - name: 小白</span><br><span class="line">      age: 2</span><br><span class="line">  cats:</span><br><span class="line">    c1:</span><br><span class="line">      name: 小蓝</span><br><span class="line">      age: 3</span><br><span class="line">    c2: &#123;name: 小绿,age: 2&#125; #对象也可用&#123;&#125;表示</span><br></pre></td></tr></table></figure><h3 id="3-细节">3. 细节</h3><ul><li>birthDay 推荐写为 birth-day,@ConfigurationProperties(prefix = “person”) //和配置文件person前缀的所有配置进行绑定，</li><li><strong>文本</strong>：<ul><li><strong>单引号</strong>不会转义【\n 则为普通字符串显示】</li><li><strong>双引号</strong>会转义【\n会显示为<strong>换行符</strong>】</li></ul></li><li><strong>大文本</strong><ul><li>|开头，大文本写在下层，<strong>保留文本格式</strong>，<strong>换行符正确显示</strong></li><li><blockquote><p>开头，大文本写在下层，折叠换行符</p></blockquote></li></ul></li><li><strong>多文档合并</strong><ul><li>使用—可以把多个yaml文档合并在一个文档中，每个文档区依然认为内容独立</li></ul></li></ul><h3 id="4-小技巧：lombok">4. 小技巧：lombok</h3><p>简化JavaBean 开发。自动生成构造器、getter/setter、自动生成Builder模式等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>使用@Data等注解</p><h2 id="3-日志配置">3. 日志配置</h2><p>规范：项目开发不要编写System.out.println()，应该用<strong>日志</strong>记录信息<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1680232037132-d2fa8085-3847-46f2-ac62-14a6188492aa.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_29%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23b5c5db&amp;from=url&amp;id=ZTIkc&amp;originHeight=251&amp;originWidth=1029&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br><strong>感兴趣日志框架关系与起源可参考</strong>：<a href="https://www.bilibili.com/video/BV1gW411W76m">https://www.bilibili.com/video/BV1gW411W76m</a> 视频 21~27集</p><h3 id="1-简介">1. 简介</h3><ol><li>Spring使用commons-logging作为内部日志，但底层日志实现是开放的。可对接其他日志框架。<ol><li>spring5及以后 commons-logging被spring直接自己写了。</li></ol></li><li>支持 jul，log4j2,logback。SpringBoot 提供了默认的控制台输出配置，也可以配置输出为文件。</li><li>logback是默认使用的。</li><li>虽然<strong>日志框架很多</strong>，但是我们不用担心，使用 SpringBoot 的<strong>默认配置就能工作的很好</strong>。</li></ol><p><strong>SpringBoot怎么把日志默认配置好的</strong><br>1、每个starter场景，都会导入一个核心场景spring-boot-starter<br>2、核心场景引入了日志的所用功能spring-boot-starter-logging（eg:spring-boot-starter-web-&gt;spring-boot-starter-&gt;spring-boot-starter-logging)<br>3、默认使用了logback + slf4j 组合作为默认底层日志<br>4、日志是系统一启动就要用，xxxAutoConfiguration是系统启动好了以后放好的组件，后来用的。<br>5、日志是利用<strong>监听器机制</strong>配置好的。ApplicationListener。<br>6、日志所有的配置都可以通过修改配置文件实现。以logging开始的所有配置。</p><h3 id="2-日志格式">2. 日志格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2023-03-31T13:56:17.511+08:00  INFO 4944 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]</span><br><span class="line">2023-03-31T13:56:17.511+08:00  INFO 4944 --- [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.7]</span><br></pre></td></tr></table></figure><p>默认输出格式：</p><ul><li>时间和日期：毫秒级精度</li><li>日志级别：ERROR,WARN,INFO,DEBUG, orTRACE.</li><li>进程 ID(可以在终端使用jps列出当前java程序的进程）</li><li>—： 消息分割符</li><li>线程名： 使用[]包含</li><li>Logger 名： 通常是产生日志的<strong>类名</strong></li><li>消息： 日志记录的内容</li></ul><p>注意： logback 没有FATAL级别，对应的是ERROR<br>默认值：参照：spring-boot包additional-spring-configuration-metadata.json文件<br>默认输出格式值：%clr(%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd’T’HH:mm:ss.SSSXXX}}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(—){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}<br>可修改为：‘%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level [%thread] %logger{15} ===&gt; %msg%n’</p><h3 id="3-记录日志">3. 记录日志</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Logger logger = LoggerFactory.getLogger(getClass());//使用日志工厂生成日志类</span><br><span class="line"> log.info(&quot;info 日志..... 参数a:&#123;&#125; b:&#123;&#125;&quot;,a,b);</span><br><span class="line">或者使用Lombok的@Slf4j注解,在该类上使用，就可以不用日志工厂生成日志类直接使用log</span><br></pre></td></tr></table></figure><h3 id="4-日志级别">4. 日志级别</h3><ul><li>由低到高：ALL,TRACE, DEBUG, INFO, WARN, ERROR,FATAL,OFF；<ul><li><strong>只会打印指定级别及以上级别的日志</strong></li><li>ALL：打印所有日志</li><li>TRACE：追踪框架详细流程日志，一般不使用</li><li>DEBUG：开发调试细节日志</li><li>INFO：关键、感兴趣信息日志</li><li>WARN：警告但不是错误的信息日志，比如：版本过时</li><li>ERROR：业务错误日志，比如出现各种异常</li><li>FATAL：致命错误日志，比如jvm系统崩溃</li><li>OFF：关闭所有日志记录</li></ul></li><li>不指定级别的所有类，都使用root指定的级别作为默认级别</li><li>SpringBoot日志<strong>默认级别是 INFO</strong></li></ul><ol><li>在application.properties/yaml中配置logging.level.<logger-name>=<level>指定日志级别</li><li>level可取值范围：TRACE, DEBUG, INFO, WARN, ERROR, FATAL, or OFF，定义在 LogLevel类中</li><li>root 的logger-name叫root，可以配置logging.level.root=warn，代表所有未指定日志级别都使用 root 的 warn 级别</li></ol><h3 id="5-日志分组">5. 日志分组</h3><p>比较有用的技巧是：<br>将相关的logger分组在一起，统一配置。SpringBoot 也支持。比如：Tomcat 相关的日志统一设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logging.group.tomcat=org.apache.catalina,org.apache.coyote,org.apache.tomcat</span><br><span class="line">//这里是将org.apache.catalina,org.apache.coyote,org.apache.tomcat2个包当成一个组为tomcat</span><br><span class="line">logging.level.tomcat=trace</span><br><span class="line">//这里是将tomcat组的日志级别设置为trace级别</span><br></pre></td></tr></table></figure><p>SpringBoot 预定义两个组</p><table><thead><tr><th>Name</th><th>Loggers</th></tr></thead><tbody><tr><td>web</td><td>org.springframework.core.codec,org.springframework.http,<a href="http://org.springframework.web">org.springframework.web</a>,<a href="http://org.springframework.boot.actuate.endpoint.web">org.springframework.boot.actuate.endpoint.web</a>,org.springframework.boot.web.servlet.ServletContextInitializerBeans</td></tr><tr><td>sql</td><td>org.springframework.jdbc.core,org.hibernate.SQL,org.jooq.tools.LoggerListener</td></tr></tbody></table><h3 id="6-文件输出">6. 文件输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> #指定文件路径路径，日志文件默认叫spring.log</span><br><span class="line">#logging.file.path=D:\\</span><br><span class="line">#指定日志文件的名，只写名字就在当前项目的同位置生成相对应的日志文件。</span><br><span class="line">#也可以写名字+路径，就会在指定的路径下生成相应的日志文件然后把日志写进去</span><br><span class="line">logging.file.name </span><br><span class="line">#file.name和file.path同时存在,只有file.name生效</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SpringBoot 默认只把日志写在控制台，如果想额外记录到文件，<a href="http://xn--application-2u0r773cbuk.xn--propertieslogging-4g60al23dy78j.file.name">可以在application.properties中添加logging.file.name</a> or logging.file.path配置项。</p><table><thead><tr><th><a href="http://logging.file.name">logging.file.name</a></th><th>logging.file.path</th><th>示例</th><th>效果</th></tr></thead><tbody><tr><td>未指定</td><td>未指定</td><td></td><td>仅控制台输出</td></tr><tr><td><strong>指定</strong></td><td>未指定</td><td>my.log</td><td>写入指定文件。可以加路径</td></tr><tr><td>未指定</td><td><strong>指定</strong></td><td>/var/log</td><td>写入指定目录，文件名为spring.log</td></tr><tr><td><strong>指定</strong></td><td><strong>指定</strong></td><td></td><td>以logging.file.name为准</td></tr></tbody></table><h3 id="7-文件归档与滚动切割">7. 文件归档与滚动切割</h3><p>归档：每天的日志单独存到一个文档中。<br>切割：每个文件10MB，超过大小切割成另外一个文件。</p><ol><li>每天的日志应该独立分割出来存档。如果使用logback（SpringBoot 默认整合），可以通过application.properties/yaml文件指定日志滚动规则。</li><li>如果是其他日志系统，需要自行配置（添加log4j2.xml或log4j2-spring.xml）</li><li>不用特意配置日志，会使用默认的日志</li><li>支持的滚动规则设置如下<br>| 配置项 | 描述 |<br>| — | — |<br>| logging.logback.rollingpolicy.file-name-pattern | 日志存档的文件名（类似每天产生的日志单独生成在一个文件中） 格式（默认值：${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz） |<br>| logging.logback.rollingpolicy.clean-history-on-start | 应用启动时是否清除以前存档（默认值：false） |<br>| logging.logback.rollingpolicy.max-file-size | 存档前，每个日志文件的最大大小（默认值：10MB） |<br>| logging.logback.rollingpolicy.total-size-cap | 日志文件被删除之前，可以容纳的最大大小（默认值：0B）。设置1GB则磁盘存储超过 1GB 日志后就会删除旧日志文件 |<br>| logging.logback.rollingpolicy.max-history | 日志文件保存的最大天数(默认值：7). |</li></ol><h3 id="8-自定义配置">8. 自定义配置</h3><p>通常我们配置 application.properties 就够了。当然也可以自定义。比如：</p><table><thead><tr><th>日志系统</th><th>自定义</th></tr></thead><tbody><tr><td>Logback</td><td>logback-spring.xml,logback-spring.groovy,</td></tr><tr><td>logback.xml, or logback.groovy</td><td></td></tr><tr><td>Log4j2</td><td>log4j2-spring.xmlorlog4j2.xml</td></tr><tr><td>JDK (Java Util Logging)</td><td>logging.properties</td></tr></tbody></table><p>如果可能，我们建议您在日志配置中使用-spring 变量（例如，logback-spring.xml 而不是 logback.xml）。如果您使用标准配置文件，spring 无法完全控制日志初始化。<br>最佳实战：自己要写配置，配置文件名加上 xx-spring.xml</p><h3 id="9-切换日志组合">9. 切换日志组合</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>log4j2支持yaml和json格式的配置文件</p><table><thead><tr><th>格式</th><th>依赖</th><th>文件名</th></tr></thead><tbody><tr><td>YAML</td><td>com.fasterxml.jackson.core:jackson-databind+com.fasterxml.jackson.dataformat:jackson-dataformat-yaml</td><td>log4j2.yaml+log4j2.yml</td></tr><tr><td>JSON</td><td>com.fasterxml.jackson.core:jackson-databind</td><td>log4j2.json+log4j2.jsn</td></tr></tbody></table><h3 id="10-最佳实战">10. 最佳实战</h3><ol><li>导入任何第三方框架，先排除它的日志包，因为Boot底层控制好了日志</li><li>修改 application.properties 配置文件，就可以调整日志的所有行为。如果不够，可以编写日志框架自己的配置文件放在类路径下就行，比如logback-spring.xml，log4j2-spring.xml</li><li>如需对接<strong>专业日志系统</strong>，也只需要把 logback 记录的<strong>日志</strong>灌倒** kafka**之类的中间件，这和SpringBoot没关系，都是日志框架自己的配置，<strong>修改配置文件即可</strong></li><li><strong>业务中使用slf4j-api记录日志。不要再 sout 了</strong></li></ol><h1>2、SpringBoot3-Web开发</h1><p>SpringBoot的Web开发能力，由<strong>SpringMVC</strong>提供。</p><h2 id="1-Web场景">1. Web场景</h2><p>1、整合web场景</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2、引入了 autoconfigure功能（是spring-boot-starter-web下的spring-boot-starter里面的一个依赖）<br>3、springboot起点的时候会加载一个@EnableAutoConfiguration注解（@SpringBootApplication注解里被@EnableAutoConfiguration注解修饰）。@EnableAutoConfiguration注解使用@Import(AutoConfigurationImportSelector.class)批量导入组件，加载 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 文件中配置的所有组件<br>5、所有自动配置类如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration</span><br><span class="line">====以下是响应式web场景和现在的没关系======</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.ReactiveMultipartAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.WebSessionIdResolverAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration</span><br><span class="line">================以上没关系=================</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration</span><br></pre></td></tr></table></figure><p>6、绑定了配置文件的一堆配置项</p><ul><li>1、SpringMVC的所有配置 spring.mvc</li><li>2、Web场景通用配置 <a href="http://spring.web">spring.web</a></li><li>3、文件上传配置 spring.servlet.multipart</li><li>4、服务器的配置 server: 比如：编码方式</li></ul><h2 id="2-默认效果">2. 默认效果</h2><p>默认配置：</p><ol><li>包含了 ContentNegotiatingViewResolver 和 BeanNameViewResolver 组件，<strong>方便视图解析</strong></li><li><strong>默认的静态资源处理机制</strong>： 静态资源放在 static 文件夹下即可直接访问</li><li><strong>自动注册</strong>了 <strong>Converter</strong>,GenericConverter,<strong>Formatter</strong>组件，适配常见<strong>数据类型转换</strong>和<strong>格式化需求</strong></li><li><strong>支持 HttpMessageConverters</strong>，可以<strong>方便返回</strong>json等<strong>数据类型（比如：</strong>@RestController 注解会自动将处理方法的返回值序列化为 JSON式的响应体，并将其发送给客户端。）</li><li><strong>注册 <strong>MessageCodesResolver，方便</strong>国际化</strong>及错误消息处理</li><li><strong>支持 静态</strong>index.html</li><li><strong>自动使用</strong>ConfigurableWebBindingInitializer，实现消息处理、数据绑定（比如将前段传递过来的参数和某些bean绑定)、类型转化、数据校验等功能</li></ol><p><strong>重要：</strong></p><ul><li><em>如果想保持 <em><strong><em>boot mvc 的默认配置</em></strong></em>，并且自定义更多的 mvc 配置，如：</em><strong><em>interceptors</em></strong><em>, <em><strong><em>formatters</em></strong></em>, <em><strong><em>view controllers</em></strong></em> 等。可以使用@Configuration注解添加一个 WebMvcConfigurer 类型的配置类，并不要标注 @EnableWebMvc</em></li><li><em>如果想保持 boot mvc 的默认配置，但要自定义核心组件实例，比如：RequestMappingHandlerMapping, RequestMappingHandlerAdapter, 或ExceptionHandlerExceptionResolver，给容器中放一个 WebMvcRegistrations 组件即可</em></li><li><em>如果想全面接管 Spring MVC，@Configuration 标注一个配置类，并加上 @EnableWebMvc注解，</em></li><li><em>实现 WebMvcConfigurer 接口</em></li></ul><h2 id="WebMvcAutoConfiguration原理">WebMvcAutoConfiguration原理</h2><p>WebMvcAutoConfiguration 是 Spring Boot 中的一个自动配置类，它负责自动配置 Spring MVC（Model-View-Controller）的相关功能。<br>在 Spring Boot 应用程序中，当您引入了 spring-boot-starter-web  依赖时，WebMvcAutoConfiguration 将自动生效。它会根据应用程序的类路径和配置属性来自动配置 Spring MVC。它是@EnableAutoConfiguration注解使用@Import(AutoConfigurationImportSelector.class)批量导入组件中的一个组件。</p><h3 id="1-生效条件">1. 生效条件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@AutoConfiguration(after = &#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span><br><span class="line">ValidationAutoConfiguration.class &#125;) //在这些自动配置之后,</span><br><span class="line">@ConditionalOnWebApplication(type = Type.SERVLET) //如果是web应用就生效，类型是SERVLETweb，其他还有、REACTIVE 响应式web</span><br><span class="line">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span><br><span class="line">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class) //容器中没有这个Bean，才生效。默认就是没有</span><br><span class="line">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)//优先级</span><br><span class="line">@ImportRuntimeHints(WebResourcesRuntimeHints.class)</span><br><span class="line">public class WebMvcAutoConfiguration &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-WebMvcAutoConfiguration产生的效果">2. WebMvcAutoConfiguration产生的效果</h3><ol><li>放了两个Filter：<ol><li>HiddenHttpMethodFilter；页面表单提交Rest请求（GET、POST、PUT、DELETE）<a href="https://blog.csdn.net/geloin/article/details/7444321">Spring MVC过滤器-HiddenHttpMethodFilter_Korbin Luo的博客-CSDN博客</a></li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">某些场景下，例如 HTML 表单只支持 GET 和 POST 方法，无法直接发送 PUT 或 DELETE 请求。</span><br><span class="line">为了解决这个问题，Spring Framework 提供了 HiddenHttpMethodFilter 过滤器。</span><br><span class="line">HiddenHttpMethodFilter 允许您在 HTML 表单中使用一个隐藏字段（通常命名为 &quot;_method&quot;）</span><br><span class="line">来指定要使用的 HTTP 方法，例如 PUT 或 DELETE。当表单提交时，过滤器会检查隐藏字段的值，并将请求方法转换为相应的 HTTP 方法。</span><br><span class="line">&lt;form action=&quot;/example&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot;&gt;</span><br><span class="line">    &lt;!-- 其他表单字段 --&gt;</span><br><span class="line">    &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">在上面的示例中，隐藏字段 _method 的值被设置为 &quot;put&quot;，表示要使用 PUT 方法进行请求。</span><br><span class="line">在您的控制器方法中，使用 @RequestMapping 注解或其他合适的注解来处理相应的请求方法。</span><br><span class="line">@RequestMapping(value = &quot;/example&quot;, method = RequestMethod.PUT)</span><br><span class="line">public ResponseEntity&lt;String&gt; updateExample() &#123;</span><br><span class="line">    // 处理 PUT 请求</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>FormContentFilter： 表单内容Filter，GET（数据放URL后面）、POST（数据放请求体）请求可以携带数据，PUT、DELETE 的请求体数据会被忽略.为了让put和delete的请求体内容不会被忽略，可以加一个FormContentFilter。</li><li>给容器中放了WebMvcConfigurer组件（WebMvcAutoConfigurationAdapter）；给SpringMVC添加各种定制功能</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration(proxyBeanMethods = false)</span><br><span class="line">@Import(EnableWebMvcConfiguration.class) //额外导入了其他配置</span><br><span class="line">@EnableConfigurationProperties(&#123; WebMvcProperties.class, WebProperties.class &#125;)</span><br><span class="line">@Order(0)</span><br><span class="line">public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer, </span><br><span class="line">ServletContextAware&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>所有的功能最终会和配置文件进行绑定</li><li>WebMvcProperties： spring.mvc配置文件</li><li>WebProperties： spring.web配置文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(</span><br><span class="line">prefix = &quot;spring.mvc&quot;</span><br><span class="line">)//@ConfigurationProperties 注解的 prefix 属性被设置为 &quot;spring.mvc&quot;，表示要绑定以</span><br><span class="line">&quot;spring.mvc&quot; 开头的配置属性。</span><br><span class="line">使用 @ConfigurationProperties 注解可以将配置文件中的属性值与 Java 类中的字段或方法关联起来，</span><br><span class="line">从而方便地获取、设置和管理配置属性。</span><br></pre></td></tr></table></figure><h3 id="WebMvcConfigurer接口">WebMvcConfigurer接口</h3><p>WebMvcAutoConfiguration中的WebMvcAutoConfigurationAdapter属性实现了该接口。<br>提供了配置SpringMVC底层的所有组件入口<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681093891854-26205c88-4c20-4b63-a2c3-02574778072f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_36%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23faf8f6&amp;from=url&amp;id=zLAUH&amp;originHeight=497&amp;originWidth=1267&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h3 id="2-静态资源">2. 静态资源</h3><h4 id="1-默认规则">1. 默认规则</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">    if (!this.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">        logger.debug(&quot;Default resource handling disabled&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //1、</span><br><span class="line">    addResourceHandler(registry, this.mvcProperties.getWebjarsPathPattern(),</span><br><span class="line">            &quot;classpath:/META-INF/resources/webjars/&quot;);</span><br><span class="line">    addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;</span><br><span class="line">        registration.addResourceLocations(this.resourceProperties.getStaticLocations());</span><br><span class="line">        if (this.servletContext != null) &#123;</span><br><span class="line">            ServletContextResource resource = new ServletContextResource(this.servletContext, SERVLET_LOCATION);</span><br><span class="line">            registration.addResourceLocations(resource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">//</span><br></pre></td></tr></table></figure><ol><li>规则一：访问： /webjars/**路径就去 classpath:/META-INF/resources/webjars/下找资源.</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/webjars/ 是一个特定的路径前缀，用于在Web应用程序中访问 WebJars 资源。</span><br><span class="line"></span><br><span class="line">WebJars 是一种将前端库以 JAR 文件的形式打包并发布到 Maven 仓库的方式。它们允许您通过 Maven </span><br><span class="line">或 Gradle 等构建工具来管理和引入前端库，就像管理其他 Java 依赖项一样。</span><br><span class="line"></span><br><span class="line">当您在 Maven 项目中引入 WebJars 依赖时，它们将被下载并存储在您的项目的 Maven 依赖目录中。</span><br><span class="line">为了在 Web 应用程序中有效地访问这些资源，Spring Boot 提供了一个特殊的处理器来映射 /webjars/</span><br><span class="line">路径。</span><br></pre></td></tr></table></figure><ol><li>maven 导入依赖</li><li>规则二：访问： /**路径就去 静态资源默认的四个位置找资源<ol><li>classpath:/META-INF/resources/</li><li>classpath:/resources/</li><li>classpath:/static/</li><li>classpath:/public/</li></ol></li><li>规则三：<strong>静态资源默认都有缓存规则的设置</strong><ol><li>所有缓存的设置，直接通过<strong>配置文件</strong>： <a href="http://spring.web">spring.web</a></li><li>cachePeriod： 缓存周期； 多久不用找服务器要新的。 默认没有，以s为单位</li><li>cacheControl： <strong>HTTP缓存</strong>控制；<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching#%E6%A6%82%E8%A7%88">https://develop er.mozilla.org/zh-CN/docs/Web/HTTP/Caching</a></li><li><strong>useLastModified</strong>：是否使用最后一次修改。配合HTTP Cache规则</li></ol></li></ol><p>如果浏览器访问了一个静态资源 index.js，如果服务这个资源没有发生变化，下次访问的时候就可以直接让浏览器用自己缓存中的东西，而不用给服务器发请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">registration.setCachePeriod(getSeconds(this.resourceProperties.getCache().getPeriod()));</span><br><span class="line">registration.setCacheControl(this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl());</span><br><span class="line">registration.setUseLastModified(this.resourceProperties.getCache().isUseLastModified());</span><br></pre></td></tr></table></figure><h4 id="1-静态资源映射">1. 静态资源映射</h4><p>静态资源映射规则在WebMvcAutoConfiguration中进行了定义：</p><ol><li>/webjars/**的所有路径 资源都在classpath:/META-INF/resources/webjars/</li><li>/**的所有路径 资源都在classpath:/META-INF/resources/、classpath:/resources/、classpath:/static/、classpath:/public/</li><li>所有静态资源都定义了缓存规则。【浏览器访问过一次，就会缓存一段时间】，但此功能参数无默认值<ol><li>period： 缓存间隔。 默认 0S；</li><li>cacheControl：缓存控制。 默认无；</li><li>useLastModified：是否使用lastModified头。 默认 false；</li></ol></li></ol><h4 id="2-静态资源缓存">2. 静态资源缓存</h4><p>如前面所述</p><ol><li>所有静态资源都定义了缓存规则。【浏览器访问过一次，就会缓存一段时间】，但此功能参数无默认值<ol><li>period： 缓存间隔。 默认 0S；</li><li>cacheControl：缓存控制。 默认无；</li><li>useLastModified：是否使用lastModified头。 默认 false；</li></ol></li></ol><h4 id="3-欢迎页">3. 欢迎页</h4><p>欢迎页规则在WebMvcAutoConfiguration中进行了定义：</p><ol><li>在<strong>静态资源</strong>目录下找 index.html</li><li>没有就在 templates下找index模板页</li></ol><h4 id="4-Favicon">4. Favicon</h4><ol><li>在静态资源目录下找 favicon.ico</li></ol><h4 id="5-缓存实验">5. 缓存实验</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">9000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#1、spring.web：</span></span><br><span class="line"><span class="comment"># 1.配置国际化的区域信息</span></span><br><span class="line"><span class="comment"># 2.静态资源策略(开启、处理链、缓存)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#开启静态资源映射规则</span></span><br><span class="line"><span class="attr">spring.web.resources.add-mappings</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#设置缓存</span></span><br><span class="line"><span class="comment">#spring.web.resources.cache.period=3600</span></span><br><span class="line"><span class="comment">##缓存详细合并项控制，覆盖period配置：</span></span><br><span class="line"><span class="comment">## 浏览器第一次请求服务器，服务器告诉浏览器此资源缓存7200秒，7200秒以内的所有此资源访问</span></span><br><span class="line"><span class="comment">#不用发给服务器请求，7200秒以后发请求给服务器</span></span><br><span class="line"><span class="attr">spring.web.resources.cache.cachecontrol.max-age</span>=<span class="string">7200</span></span><br><span class="line"><span class="comment">#使用资源 last-modified 时间，来对比服务器和浏览器的资源是否相同没有变化。相同返回 304,默认开启</span></span><br><span class="line"><span class="attr">spring.web.resources.cache.use-last-modified</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><h3 id="2-自定义静态资源规则">2. 自定义静态资源规则</h3><p>自定义静态资源路径、自定义缓存规则</p><h4 id="1-配置方式">1. 配置方式</h4><p>spring.mvc： 静态资源访问前缀路径<br><a href="http://spring.web">spring.web</a>：</p><ul><li>静态资源目录</li><li>静态资源缓存策略</li></ul><h4 id="2-代码方式">2. 代码方式</h4><ul><li>容器中只要有一个 WebMvcConfigurer 组件。配置的底层行为都会生效</li><li>@EnableWebMvc //禁用boot的默认配置</li></ul><h3 id="5-EnableWebMvcConfiguration-源码">5. EnableWebMvcConfiguration 源码</h3><p>也是WebMvcAutoConfiguration的内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SpringBoot 给容器中放 WebMvcConfigurationSupport 组件。</span></span><br><span class="line"><span class="comment">//我们如果自己放了 WebMvcConfigurationSupport 组件，Boot的WebMvcAutoConfiguration都会失效。</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(WebProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EnableWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title class_">DelegatingWebMvcConfiguration</span> <span class="keyword">implements</span> <span class="title class_">ResourceLoaderAware</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>HandlerMapping： 根据请求路径  找那个handler能处理请求</li></ol><p><a href="https://www.jianshu.com/p/f04816ee2495">SpringMVC工作原理之处理映射[HandlerMapping]</a><br>SpringMVC 内部是根据 HandlerMapping 将 Request 和 Controller 里面的方法对应起来的</p><ol><li>WelcomePageHandlerMapping(webmvcAutoConfiguration里面注入所依赖的bean)：<ol><li>访问 /**路径下的所有请求，都在以前四个静态资源路径下找，欢迎页也一样</li><li>找index.html：只要静态资源的位置有一个 index.html页面，项目启动默认访问（意思是如果静态资源里面有index.html，那么项目启动也就是根路径默认跳转到index.html）</li></ol></li></ol><h4 id="Favicon：网站图标">Favicon：网站图标</h4><ol><li>在静态资源目录下找 favicon.ico</li></ol><p>理解：springboot启动成功后会在静态资源文件中寻找favicon.ico文件，如果存在这个文件就把网站的图标设置为这个，当然这里的favicon.ico文件名要正确。如果删除了favicon.ico文件，但是浏览器的图标仍然存在，那是因为浏览器的缓存机制缓存了该图标。</p><h4 id="5-缓存实验-2">5. 缓存实验</h4><p>1.跟缓存有关的配置是spring.web前缀的配置属性 。<br>2.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties 是一个 Spring Boot 注解，用于将配置属性绑定到 Java 类的字段上。</span><br><span class="line"></span><br><span class="line">在 Spring Boot 应用程序中，配置属性通常存储在配置文件（如 application.properties </span><br><span class="line">或 application.yml）中。@ConfigurationProperties 注解可以使用在一个类上，用于将配置文件中的</span><br><span class="line">属性值绑定到该类的字段上，实现属性的自动注入。</span><br><span class="line">@ConfigurationProperties(&quot;spring.web&quot;)是将以 &quot;spring.web&quot; 为前缀的配置属性绑定到 Java 类</span><br><span class="line">的字段上。</span><br><span class="line">使用 @ConfigurationProperties 需要进行以下步骤：</span><br><span class="line">创建一个普通的 Java 类，该类的字段将用于存储配置属性的值。</span><br><span class="line">在该类上添加 @ConfigurationProperties 注解，并指定要绑定的配置属性的前缀。</span><br><span class="line">@Configuration</span><br><span class="line">@ConfigurationProperties(prefix = &quot;myapp&quot;)</span><br><span class="line">public class MyAppProperties &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String version;</span><br><span class="line">    // 其他属性及对应的 getter 和 setter 方法</span><br><span class="line">&#125;</span><br><span class="line">在上述示例中，MyAppProperties 类使用 @ConfigurationProperties 注解，并指定了 prefix 属性为</span><br><span class="line">&quot;myapp&quot;。这意味着该类的字段将与以 &quot;myapp&quot; 为前缀的配置属性进行绑定。</span><br><span class="line"></span><br><span class="line">假设在配置文件中有以下属性：</span><br><span class="line">myapp.name=My App</span><br><span class="line">myapp.version=1.0.0</span><br><span class="line">通过使用 @ConfigurationProperties 注解，可以将 &quot;My App&quot; 绑定到 name 字段上，</span><br><span class="line">将 &quot;1.0.0&quot; 绑定到 version 字段上。</span><br></pre></td></tr></table></figure><p>3.spring.web可以配置国际化的区域信息，配置静态资源策略（开启，处理链，缓存），</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server.port=9000</span><br><span class="line"></span><br><span class="line">#1、spring.web：</span><br><span class="line"># 1.配置国际化的区域信息</span><br><span class="line"># 2.静态资源策略(开启、处理链、缓存)</span><br><span class="line"></span><br><span class="line">#开启静态资源映射规则，默认结果为true,spring.web.resources.add-mappings和Resources类</span><br><span class="line">#的addMappings属性对应。</span><br><span class="line">spring.web.resources.add-mappings=true</span><br><span class="line"></span><br><span class="line">#设置缓存,设置了缓存时间为3600s</span><br><span class="line">#spring.web.resources.cache.period=3600</span><br><span class="line">##缓存详细合并项控制，覆盖period配置：</span><br><span class="line">## 浏览器第一次请求服务器，服务器告诉浏览器此资源缓存7200秒，7200秒以内的所有此资源访问不用发给服务器请求，7200秒以后发请求给服务器</span><br><span class="line">spring.web.resources.cache.cachecontrol.max-age=7200</span><br><span class="line">#使用资源 last-modified 时间，来对比服务器和浏览器的资源是否相同没有变化。相同返回 304</span><br><span class="line">spring.web.resources.cache.use-last-modified=true</span><br></pre></td></tr></table></figure><h2 id="2-自定义静态资源规则-2">2. 自定义静态资源规则</h2><p>自定义静态资源路径、自定义缓存规则</p><h3 id="1-配置方式-2">1. 配置方式</h3><p>spring.mvc： 静态资源访问前缀路径<br><a href="http://spring.web">spring.web</a>：</p><ul><li>静态资源目录</li><li>静态资源缓存策略</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1、spring.web：</span></span><br><span class="line"><span class="comment"># 1.配置国际化的区域信息</span></span><br><span class="line"><span class="comment"># 2.静态资源策略(开启、处理链、缓存)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#开启静态资源映射规则</span></span><br><span class="line"><span class="attr">spring.web.resources.add-mappings</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#设置缓存</span></span><br><span class="line"><span class="attr">spring.web.resources.cache.period</span>=<span class="string">3600</span></span><br><span class="line"><span class="comment">##缓存详细合并项控制，覆盖period配置：</span></span><br><span class="line"><span class="comment">## 浏览器第一次请求服务器，服务器告诉浏览器此资源缓存7200秒，7200秒以内的所有此资源访问不用发给服务器请求，7200秒以后发请求给服务器</span></span><br><span class="line"><span class="attr">spring.web.resources.cache.cachecontrol.max-age</span>=<span class="string">7200</span></span><br><span class="line"><span class="comment">## 共享缓存，只要是这个客户端其他用户都可以使用这个缓存</span></span><br><span class="line"><span class="attr">spring.web.resources.cache.cachecontrol.cache-public</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#使用资源 last-modified 时间，来对比服务器和浏览器的资源是否相同没有变化。相同返回 304</span></span><br><span class="line"><span class="attr">spring.web.resources.cache.use-last-modified</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#自定义静态资源文件夹位置</span></span><br><span class="line"><span class="attr">spring.web.resources.static-locations</span>=<span class="string">classpath:/a/,classpath:/b/,classpath:/static/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#2、 spring.mvc</span></span><br><span class="line"><span class="comment">## 2.1. 自定义webjars路径前缀,以后访问/wj/**路径的时候会在/wedjars/**路径下寻找 </span></span><br><span class="line"><span class="attr">spring.mvc.webjars-path-pattern</span>=<span class="string">/wj/**</span></span><br><span class="line"><span class="comment">## 2.2. 静态资源访问路径前缀常和spring.web.resources.static-locations联合使用</span></span><br><span class="line"><span class="attr">spring.mvc.static-path-pattern</span>=<span class="string">/static/**</span></span><br></pre></td></tr></table></figure><h3 id="2-代码方式-2">2. 代码方式</h3><ul><li>容器中只要有一个 WebMvcConfigurer 组件。配置的底层行为都会生效</li><li>@EnableWebMvc //禁用boot的默认配置</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">//@EnableWebMvc</span> <span class="string">//禁用boot的默认配置，添加了就会禁用boot的默认配置的规则。</span></span><br><span class="line"><span class="attr">//，没有添加就会保留以前的规则和自己新写的规则</span></span><br><span class="line"><span class="attr">@Configuration</span> <span class="string">//这是一个配置类</span></span><br><span class="line"><span class="attr">public</span> <span class="string">class MyConfig implements WebMvcConfigurer &#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">@Override</span></span><br><span class="line">    <span class="attr">public</span> <span class="string">void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span></span><br><span class="line">        <span class="attr">//保留以前规则</span></span><br><span class="line">        <span class="attr">//自己写新的规则。</span></span><br><span class="line">        <span class="attr">registry.addResourceHandler(&quot;/static/**&quot;)</span></span><br><span class="line">                <span class="attr">.addResourceLocations(&quot;classpath</span>:<span class="string">/a/&quot;,&quot;classpath:/b/&quot;)</span></span><br><span class="line">                <span class="attr">.setCacheControl(CacheControl.maxAge(1180,</span> <span class="string">TimeUnit.SECONDS));</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">@Configuration</span> <span class="string">//这是一个配置类,给容器中放一个 WebMvcConfigurer 组件，就能自定义底层</span></span><br><span class="line"><span class="attr">public</span> <span class="string">class MyConfig  /*implements WebMvcConfigurer*/ &#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">@Bean</span></span><br><span class="line">    <span class="attr">public</span> <span class="string">WebMvcConfigurer webMvcConfigurer()&#123;</span></span><br><span class="line">        <span class="attr">return</span> <span class="string">new WebMvcConfigurer() &#123;</span></span><br><span class="line">            <span class="attr">@Override</span></span><br><span class="line">            <span class="attr">public</span> <span class="string">void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span></span><br><span class="line">                <span class="attr">registry.addResourceHandler(&quot;/static/**&quot;)</span></span><br><span class="line">                        <span class="attr">.addResourceLocations(&quot;classpath</span>:<span class="string">/a/&quot;, &quot;classpath:/b/&quot;)</span></span><br><span class="line">                        <span class="attr">.setCacheControl(CacheControl.maxAge(1180,</span> <span class="string">TimeUnit.SECONDS));</span></span><br><span class="line">            <span class="attr">&#125;</span></span><br><span class="line">        <span class="attr">&#125;;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="6-为什么容器中放一个WebMvcConfigurer就能配置底层行为">6. 为什么容器中放一个WebMvcConfigurer就能配置底层行为</h3><ol><li>WebMvcAutoConfiguration 是一个自动配置类，它里面有一个 EnableWebMvcConfiguration</li><li>EnableWebMvcConfiguration继承与 DelegatingWebMvcConfiguration，这两个都生效</li><li>DelegatingWebMvcConfiguration利用 ID 把容器中 所有 WebMvcConfigurer 注入进来</li><li>别人调用 <code>DelegatingWebMvcConfiguration</code> 的方法配置底层规则，而它调用所有 WebMvcConfigurer的配置底层方法。</li></ol><h2 id="3-路径匹配">3. 路径匹配</h2><p><strong>Spring5.3</strong> 之后加入了更多的请求路径匹配的实现策略；<br>以前只支持 AntPathMatcher 策略, 现在提供了 <strong>PathPatternParser</strong>策略。并且可以让我们指定到底使用那种策略。</p><h3 id="1-Ant风格路径用法">1. Ant风格路径用法</h3><p>Ant 风格的路径模式语法具有以下规则：</p><ul><li>*：表示<strong>任意数量</strong>的字符。</li><li>?：表示任意<strong>一个字符</strong>。</li><li><strong>：表示</strong>任意数量的目录**。</li><li>{}：表示一个命名的模式<strong>占位符</strong>。</li><li>[]：表示<strong>字符集合</strong>，例如[a-z]表示小写字母。</li></ul><p>例如：</p><ul><li>*.html匹配任意名称，扩展名为.html的文件。</li><li>/folder1/<em>/</em>.java匹配在folder1目录下的任意两级目录下的.java文件。</li><li>/folder2/**/*.jsp匹配在folder2目录下任意目录深度的.jsp文件。</li><li>/{type}/{id}.html匹配任意文件名为{id}.html，在任意命名的{type}目录下的文件。</li></ul><p>注意：Ant 风格的路径模式语法中的特殊字符需要转义，如：</p><ul><li>要匹配文件路径中的星号，则需要转义为\*。</li><li>要匹配文件路径中的问号，则需要转义为\?。</li></ul><h3 id="2-模式切换">2. 模式切换</h3><h4 id="AntPathMatcher-与-PathPatternParser">AntPathMatcher 与 PathPatternParser</h4><ul><li>PathPatternParser在 jmh 基准测试下，有 6~8 倍吞吐量提升，降低 30%~40%空间分配率</li><li>PathPatternParser 兼容 AntPathMatcher语法，并支持更多类型的路径模式</li><li>PathPatternParser &quot;**<strong><strong>&quot; <strong>多段匹配</strong>的支持</strong>仅允许在模式末尾使用</strong></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">@GetMapping(&quot;/a*/b?/&#123;p1</span>:<span class="string">[a-f]+&#125;&quot;)</span></span><br><span class="line"><span class="attr">public</span> <span class="string">String hello(HttpServletRequest request, </span></span><br><span class="line">                    <span class="attr">@PathVariable(&quot;p1&quot;)</span> <span class="string">String path) &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">log.info(&quot;路径变量p1：</span> <span class="string">&#123;&#125;&quot;, path);</span></span><br><span class="line">    <span class="attr">//获取请求路径</span></span><br><span class="line">    <span class="attr">String</span> <span class="string">uri = request.getRequestURI();</span></span><br><span class="line">    <span class="attr">return</span> <span class="string">uri;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>使用默认的路径匹配规则，是由 PathPatternParser 提供的</li><li>如果路径中间需要有 **，替换成ant风格路径</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改变路径匹配策略：</span></span><br><span class="line"><span class="comment"># ant_path_matcher 老版策略；</span></span><br><span class="line"><span class="comment"># path_pattern_parser 新版策略；</span></span><br><span class="line"><span class="attr">spring.mvc.pathmatch.matching-strategy</span>=<span class="string">ant_path_matcher</span></span><br></pre></td></tr></table></figure><h2 id="4-内容协商">4. 内容协商</h2><p>一套系统适配多端数据返回<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681217799861-dde49224-a767-489b-80b7-7d8d503e33cf.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_23%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23faf9f7&amp;from=url&amp;id=gZ4iS&amp;originHeight=420&amp;originWidth=797&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h3 id="1-多端内容适配">1. 多端内容适配</h3><h4 id="1-默认规则-2">1. 默认规则</h4><ol><li><strong>SpringBoot 多端内容适配</strong>。<ol><li><strong>基于请求头内容协商</strong>：（默认开启）<ol><li>客户端向服务端发送请求，携带HTTP标准的<strong>Accept请求头</strong>。<ol><li><strong>Accept</strong>: application/json、text/xml、text/yaml</li><li>服务端根据客户端<strong>请求头期望的数据类型</strong>进行<strong>动态返回</strong></li><li>**1、默认支持把对象写为json。因为默认web场景导入了jackson处理json的包;jackson-core</li></ol></li></ol></li></ol></li></ol><ul><li>2、jackson也支持把数据写为xml。导入xml相关依赖**<br>2. <strong>基于请求参数内容协商：（需要开启）下面的?format就是要返回数据的格式。</strong><br>1. 发送请求 GET /projects/spring-boot?format=json<br>2. 匹配到 @GetMapping(“/projects/spring-boot”)<br>3. 根据<strong>参数协商</strong>，优先返回 json 类型数据【<strong>需要开启参数匹配设置</strong>】<br>4. 发送请求 GET /projects/spring-boot?format=xml,优先返回 xml 类型数据</li></ul><h4 id="2-效果演示">2. 效果演示</h4><p>请求同一个接口，可以返回json和xml不同格式数据,<strong>、默认支持把对象写为json。因为默认web场景导入了jackson处理json的包;jackson-core,jackson也支持把数据写为xml。导入xml相关依赖</strong></p><ol><li>引入支持写出xml内容依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>标注注解</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">@JacksonXmlRootElement</span>  <span class="string">// 可以写出为xml文档</span></span><br><span class="line"><span class="attr">@Data</span></span><br><span class="line"><span class="attr">public</span> <span class="string">class Person &#123;</span></span><br><span class="line">    <span class="attr">private</span> <span class="string">Long id;</span></span><br><span class="line">    <span class="attr">private</span> <span class="string">String userName;</span></span><br><span class="line">    <span class="attr">private</span> <span class="string">String email;</span></span><br><span class="line">    <span class="attr">private</span> <span class="string">Integer age;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>开启基于请求参数的内容协商</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启基于请求参数的内容协商功能。 默认参数名：format。 默认此功能不开启</span></span><br><span class="line"><span class="attr">spring.mvc.contentnegotiation.favor-parameter</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 指定内容协商时使用的参数名。默认是 format</span></span><br><span class="line"><span class="attr">spring.mvc.contentnegotiation.parameter-name</span>=<span class="string">type</span></span><br></pre></td></tr></table></figure><ol><li>效果</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681220124448-e8611612-97bc-4823-9b00-20dd9d579abf.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_17%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f9f8f8&amp;from=url&amp;id=tIIrj&amp;originHeight=306&amp;originWidth=594&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681220145378-86fabd90-a78c-4f60-9efa-eb2960915832.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_16%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f6f5f5&amp;from=url&amp;id=mh0xz&amp;originHeight=256&amp;originWidth=575&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h3 id="3-配置协商规则与支持类型">3. 配置协商规则与支持类型</h3><ol><li>修改<strong>内容协商方式</strong></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用参数进行内容协商</span></span><br><span class="line"><span class="attr">spring.mvc.contentnegotiation.favor-parameter</span>=<span class="string">true  </span></span><br><span class="line"><span class="comment">#自定义参数名，默认为format</span></span><br><span class="line"><span class="attr">spring.mvc.contentnegotiation.parameter-name</span>=<span class="string">myparam </span></span><br></pre></td></tr></table></figure><ol><li>大多数 MediaType 都是开箱即用的。也可以<strong>自定义内容类型，如：</strong></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.mvc.contentnegotiation.media-types.yaml</span>=<span class="string">text/yaml</span></span><br></pre></td></tr></table></figure><h3 id="2-自定义内容返回">2. 自定义内容返回</h3><h4 id="1-增加yaml返回支持">1. 增加yaml返回支持</h4><p>导入依赖</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;dependency&gt;</span></span><br><span class="line">    <span class="attr">&lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;</span></span><br><span class="line">    <span class="attr">&lt;artifactId&gt;jackson-dataformat-yaml&lt;/artifactId&gt;</span></span><br><span class="line"><span class="attr">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure><p>把对象写出成YAML</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="attr">public</span> <span class="string">static void main(String[] args) throws JsonProcessingException &#123;</span></span><br><span class="line">        <span class="attr">Person</span> <span class="string">person = new Person();</span></span><br><span class="line">        <span class="attr">person.setId(1L);</span></span><br><span class="line">        <span class="attr">person.setUserName(&quot;张三&quot;);</span></span><br><span class="line">        <span class="attr">person.setEmail(&quot;aaa@qq.com&quot;);</span></span><br><span class="line">        <span class="attr">person.setAge(18);</span></span><br><span class="line"><span class="attr">//禁用文档的开始标记</span></span><br><span class="line">        <span class="attr">YAMLFactory</span> <span class="string">factory = new YAMLFactory().disable(YAMLGenerator.Feature.WRITE_DOC_START_MARKER);</span></span><br><span class="line">        <span class="attr">ObjectMapper</span> <span class="string">mapper = new ObjectMapper(factory);</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">String</span> <span class="string">s = mapper.writeValueAsString(person);</span></span><br><span class="line">        <span class="attr">System.out.println(s);</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>编写配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#新增一种媒体类型，</span></span><br><span class="line"><span class="attr">spring.mvc.contentnegotiation.media-types.yaml</span>=<span class="string">text/yaml</span></span><br></pre></td></tr></table></figure><p>增加HttpMessageConverter组件，专门负责把对象写出为yaml格式</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">@Bean</span></span><br><span class="line"><span class="attr">public</span> <span class="string">WebMvcConfigurer webMvcConfigurer()&#123;</span></span><br><span class="line">    <span class="attr">return</span> <span class="string">new WebMvcConfigurer() &#123;</span></span><br><span class="line">        <span class="attr">@Override</span> <span class="string">//配置一个能把对象转为yaml的messageConverter</span></span><br><span class="line">        <span class="attr">public</span> <span class="string">void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;</span></span><br><span class="line">            <span class="attr">converters.add(new</span> <span class="string">MyYamlHttpMessageConverter());//将新增的配置格式和配置类关联起来</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-HttpMessageConverter的示例写法">3. HttpMessageConverter的示例写法</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">public</span> <span class="string">class MyYamlHttpMessageConverter extends AbstractHttpMessageConverter&lt;Object&gt; &#123;</span></span><br><span class="line"><span class="attr">//或者是实现</span> <span class="string">HttpMessageConverter</span></span><br><span class="line">    <span class="attr">private</span> <span class="string">ObjectMapper objectMapper = null; //把对象转成yaml</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">public</span> <span class="string">MyYamlHttpMessageConverter()&#123;</span></span><br><span class="line">        <span class="attr">//告诉SpringBoot这个MessageConverter支持哪种媒体类型</span>  <span class="string">//媒体类型</span></span><br><span class="line">        <span class="attr">super(new</span> <span class="string">MediaType(&quot;text&quot;, &quot;yaml&quot;, Charset.forName(&quot;UTF-8&quot;)));</span></span><br><span class="line">        <span class="attr">YAMLFactory</span> <span class="string">factory = new YAMLFactory()</span></span><br><span class="line">                <span class="attr">.disable(YAMLGenerator.Feature.WRITE_DOC_START_MARKER);</span></span><br><span class="line">        <span class="attr">this.objectMapper</span> = <span class="string">new ObjectMapper(factory);</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">@Override</span></span><br><span class="line">    <span class="attr">protected</span> <span class="string">boolean supports(Class&lt;?&gt; clazz) &#123;</span></span><br><span class="line">        <span class="attr">//只要是对象类型，不是基本类型</span></span><br><span class="line">        <span class="attr">return</span> <span class="string">true;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">@Override</span>  <span class="string">//@RequestBody,读取请求对象 </span></span><br><span class="line">    <span class="attr">protected</span> <span class="string">Object readInternal(Class&lt;?&gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException &#123;</span></span><br><span class="line">        <span class="attr">return</span> <span class="string">null;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">@Override</span> <span class="string">//@ResponseBody 把对象怎么写出去</span></span><br><span class="line">    <span class="attr">protected</span> <span class="string">void writeInternal(Object methodReturnValue, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">//try-with写法，自动关流</span></span><br><span class="line">        <span class="attr">try(OutputStream</span> <span class="string">os = outputMessage.getBody())&#123;</span></span><br><span class="line">            <span class="attr">this.objectMapper.writeValue(os,methodReturnValue);</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-思考：如何增加其他">2. 思考：如何增加其他</h4><ul><li>配置媒体类型支持:<ul><li>spring.mvc.contentnegotiation.media-types.yaml=text/yaml</li></ul></li><li>编写对应的HttpMessageConverter，要告诉Boot这个支持的媒体类型<ul><li>按照3的示例</li></ul></li><li>把MessageConverter组件加入到底层<ul><li>容器中放一个<code>WebMvcConfigurer</code> 组件，并配置底层的MessageConverter</li></ul></li></ul><h2 id="3-内容协商原理-HttpMessageConverter">3. 内容协商原理-HttpMessageConverter</h2><ul><li>HttpMessageConverter 怎么工作？合适工作？</li><li>定制 HttpMessageConverter 来实现多端内容协商</li><li>编写WebMvcConfigurer提供的configureMessageConverters底层，修改底层的MessageConverter</li></ul><h3 id="1-ResponseBody由HttpMessageConverter处理">1. @ResponseBody由HttpMessageConverter处理</h3><p>标注了@ResponseBody的返回值 将会由支持它的 HttpMessageConverter写给浏览器</p><ol><li>如果controller方法的返回值标注了 @ResponseBody 注解<ol><li>请求进来先来到DispatcherServlet的doDispatch()进行处理</li></ol></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">doDispatch()</span> <span class="string">是 Spring MVC 中的核心方法之一，用于处理请求的分发和调度。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">在</span> <span class="string">Spring MVC 中，请求的处理流程如下：</span></span><br><span class="line"></span><br><span class="line"><span class="attr">1.客户端发送一个</span> <span class="string">HTTP 请求到服务器。</span></span><br><span class="line"><span class="attr">2.前端控制器（Front</span> <span class="string">Controller）接收到请求，这个控制器通常是 DispatcherServlet，它是 </span></span><br><span class="line"><span class="attr">Spring</span> <span class="string">MVC 的核心组件。</span></span><br><span class="line"><span class="attr">3.DispatcherServlet</span> <span class="string">根据请求的 URL 找到相应的处理器（Handler）。</span></span><br><span class="line"><span class="attr">4.处理器执行相应的业务逻辑并返回一个</span> <span class="string">ModelAndView 对象。(其中执行目标方法要准备参数解析器和</span></span><br><span class="line"><span class="attr">返回值解析器）</span></span><br><span class="line"><span class="attr">5.DispatcherServlet</span> <span class="string">根据 ModelAndView 对象选择合适的视图（View）进行渲染。</span></span><br><span class="line"><span class="attr">最终将渲染结果返回给客户端。（</span></span><br><span class="line"><span class="attr">在这个处理流程中，doDispatch()</span> <span class="string">方法负责实际执行第 4 步和第 5 步的操作。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">具体而言，doDispatch()</span> <span class="string">方法会执行以下主要任务：</span></span><br><span class="line"></span><br><span class="line"><span class="attr">解析请求，包括解析请求的方法、路径、参数等信息。</span></span><br><span class="line"><span class="attr">根据请求的方法和路径，确定匹配的处理器（Handler）。</span></span><br><span class="line"><span class="attr">执行处理器的业务逻辑，处理请求并返回一个</span> <span class="string">ModelAndView 对象。</span></span><br><span class="line"><span class="attr">根据</span> <span class="string">ModelAndView 对象中的视图名字，选择合适的视图（View）进行渲染。</span></span><br><span class="line"><span class="attr">渲染视图，生成最终的响应结果。</span></span><br><span class="line"><span class="attr">doDispatch()</span> <span class="string">方法的具体实现会涉及到请求的映射、处理器适配器、处理器拦截器、参数解析器等等。</span></span><br><span class="line"><span class="attr">该方法是</span> <span class="string">Spring MVC 框架的核心之一，在请求的处理过程中起到了关键的作用。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">需要注意的是，doDispatch()</span> <span class="string">方法通常由 DispatcherServlet 自动调用，开发者一般不需要直接调用</span></span><br><span class="line"><span class="attr">该方法。开发者主要关注配置合适的请求映射、编写处理器方法以及配置视图解析器等，框架会自动根据</span></span><br><span class="line"><span class="attr">配置和规则来调用</span> <span class="string">doDispatch() 方法来处理请求。</span></span><br></pre></td></tr></table></figure><ol start="2"><li>找到一个 HandlerAdapter 适配器。利用适配器执行目标方法</li><li>RequestMappingHandlerAdapter来执行，调用invokeHandlerMethod（）来执行目标方法</li><li>目标方法执行之前，准备好两个东西<ol><li>HandlerMethodArgumentResolver：参数解析器，确定目标方法每个参数值</li><li>HandlerMethodReturnValueHandler：返回值处理器，确定目标方法的返回值改怎么处理</li></ol></li><li>RequestMappingHandlerAdapter 里面的invokeAndHandle()真正执行目标方法</li><li>目标方法执行完成，会返回<strong>返回值对象</strong></li><li>**找到一个合适的返回值处理器 **HandlerMethodReturnValueHandler</li><li>最终找到 RequestResponseBodyMethodProcessor能处理 标注了 @ResponseBody注解的方法</li><li>RequestResponseBodyMethodProcessor 调用writeWithMessageConverters ,利用MessageConverter把返回值写出去</li></ol><p>上面解释：@ResponseBody由HttpMessageConverter处理</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">HttpMessageConverter</span> <span class="string">是 Spring MVC 中的一个关键接口，用于处理 HTTP 请求和响应消息的转换。</span></span><br><span class="line"><span class="attr">它负责将</span> <span class="string">Java 对象与 HTTP 请求/响应的内容进行转换，使得应用程序可以方便地处理不同类型的数据格式，</span></span><br><span class="line"><span class="attr">如</span> <span class="string">JSON、XML、表单数据等。</span></span><br></pre></td></tr></table></figure><ol><li>HttpMessageConverter 会<strong>先进行内容协商</strong><ol><li>遍历所有的MessageConverter看谁支持这种<strong>内容类型的数据</strong></li><li>默认MessageConverter有以下</li><li><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681275459547-89d8d651-b52f-4d47-bff9-6db123624424.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_15%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f0eeeb&amp;from=url&amp;id=w9v5M&amp;originHeight=282&amp;originWidth=532&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></li><li>最终因为要json所以MappingJackson2HttpMessageConverter支持写出json</li><li>jackson用ObjectMapper（是一个类）把对象写出去</li></ol></li></ol><h3 id="2-WebMvcAutoConfiguration提供几种默认HttpMessageConverters">2. WebMvcAutoConfiguration提供几种默认HttpMessageConverters</h3><ul><li>EnableWebMvcConfiguration通过 addDefaultHttpMessageConverters添加了默认的MessageConverter；如下：<ul><li>ByteArrayHttpMessageConverter： 支持字节数据读写</li><li>StringHttpMessageConverter： 支持字符串读写</li><li>ResourceHttpMessageConverter：支持资源读写</li><li>ResourceRegionHttpMessageConverter: 支持分区资源写出</li><li>AllEncompassingFormHttpMessageConverter：支持表单xml/json读写</li><li>MappingJackson2HttpMessageConverter： 支持请求响应体Json读写</li></ul></li></ul><p>默认8个：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681302411019-0c0425aa-6679-4b2b-a456-b31c151c6e83.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_15%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f1eeec&amp;from=url&amp;id=WrjKA&amp;originHeight=237&amp;originWidth=532&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>系统提供默认的MessageConverter 功能有限，仅用于json或者普通返回数据。额外增加新的内容协商功能，必须增加新的HttpMessageConverter</p><h1>5. 模板引擎</h1><ul><li>由于 <strong>SpringBoot</strong> 使用了<strong>嵌入式 Servlet 容器</strong>。所以 <strong>JSP</strong> 默认是<strong>不能使用</strong>的。</li><li>如果需要<strong>服务端页面渲染</strong>，优先考虑使用 模板引擎。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681354523290-b89d7e0d-b9aa-40f5-8d22-d3d09d02b136.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_28%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f6f5f5&amp;from=url&amp;id=FMo0Z&amp;originHeight=654&amp;originWidth=999&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>模板引擎页面默认放在 src/main/resources/templates<br><strong>SpringBoot</strong> 包含以下模板引擎的自动配置</p><ul><li>FreeMarker</li><li>Groovy</li><li><strong>Thymeleaf</strong></li><li>Mustache</li></ul><p><strong>Thymeleaf官网</strong>：<a href="https://www.thymeleaf.org/">https://www.thymeleaf.org/</a></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;!DOCTYPE</span> <span class="string">html&gt;</span></span><br><span class="line"><span class="attr">&lt;html</span> <span class="string">xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span></span><br><span class="line"><span class="attr">&lt;head&gt;</span></span><br><span class="line"><span class="attr">&lt;title&gt;Good</span> <span class="string">Thymes Virtual Grocery&lt;/title&gt;</span></span><br><span class="line"><span class="attr">&lt;meta</span> <span class="string">http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;</span></span><br><span class="line"><span class="attr">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot; th:href=&quot;@&#123;/css/gtvg.css&#125;&quot; /&gt;</span></span><br><span class="line"><span class="attr">&lt;/head&gt;</span></span><br><span class="line"><span class="attr">&lt;body&gt;</span></span><br><span class="line"><span class="attr">&lt;p</span> <span class="string">th:text=&quot;#&#123;home.welcome&#125;&quot;&gt;Welcome to our grocery store!&lt;/p&gt;</span></span><br><span class="line"><span class="attr">&lt;/body</span></span><br><span class="line"><span class="attr">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-Thymeleaf整合（是前后端一体的开发）">1. Thymeleaf整合（是前后端一体的开发）</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;dependency&gt;</span></span><br><span class="line">    <span class="attr">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">    <span class="attr">&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span></span><br><span class="line"><span class="attr">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure><p>自动配置原理</p><ol><li>开启了org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration自动配置</li><li>属性绑定在 ThymeleafProperties类 中，对应配置文件 spring.thymeleaf 内容（也就是配置文件中以spring.thymeleaf开头的属性）</li><li>所有的模板页面默认在 classpath:/templates文件夹下</li><li>默认效果<ol><li>所有的模板页面在 classpath:/templates/下面找</li><li>找后缀名为.html的页面</li></ol></li></ol><p>事例：<br>1.使用Thymeleaf来处理的项目其controller类用@Controller //适配 服务端渲染 前后不分离模式开始;而前后端分离的项目用@Resttroller注解<br><a href="https://www.cnblogs.com/east7/p/10462279.html">Spring 注解之@RestController与@Controller的区别 - 楼兰胡杨 - 博客园</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RestController无法返回指定页面，而@Controller可以；前者可以直接返回数据，</span><br><span class="line">后者需要@ResponseBody辅助。</span><br><span class="line">如果需要返回JSON，XML或自定义mediaType内容到页面，@RestController自己就可以搞定，</span><br><span class="line">这个注解对于返回数据比较方便，因为它会自动将对象实体转换为JSON格式。而@Controller需要在对应的</span><br><span class="line">方法加上@ResponseBody注解。</span><br></pre></td></tr></table></figure><p>2.get请求其参数是写在url中的，而post请求参数是在请求体中的。<br>3.@GetMapping（）用来修饰处理get请求的方法。<br>4.//模板的逻辑视图名<br>//物理视图 = 前缀 + 逻辑视图名 + 后缀<br>//真实地址 = classpath:/templates/welcome.html其中的前缀和后缀在ThymeleafProperties类中指定了的<br>5.其Thymeleaf还提供了一些工具类，常用#类名表示，例如：#string。这些工具类可以进行简单的运行操作。<br>6.如果html中要使用Thymeleaf语法，需要提供其命名空间</p><h2 id="2-基础语法（在html中使用Thymeleaf）">2. 基础语法（在html中使用Thymeleaf）</h2><h3 id="1-核心用法">1. 核心用法</h3><p>导入命名空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">xmlns:th属性，该属性是Thymeleaf命名空间（http://www.thymeleaf.org）的声明。</span><br><span class="line">这个命名空间允许您在HTML代码中使用Thymeleaf特定的属性和表达式。</span><br></pre></td></tr></table></figure><p><strong>th:xxx：动态渲染指定的 html 标签属性值、或者th指令（遍历、判断等）</strong></p><ul><li>th:text：标签体内文本值渲染<ul><li>th:utext：不会转义，显示为html原本的样子。也就是文本中的html元素可以被解析</li></ul></li><li>th:属性：标签指定属性渲染</li><li>th:attr：标签任意属性渲染</li><li>th:if  （根据后端逻辑或数据的条件来控制是否在渲染过程中包含或显示某个元素。）  th:each…：其他th指令</li><li>例如：</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;p</span> <span class="string">th:text=&quot;$&#123;content&#125;&quot;&gt;原内容&lt;/p&gt;</span></span><br><span class="line"><span class="attr">&lt;a</span> <span class="string">th:href=&quot;$&#123;url&#125;&quot;&gt;登录&lt;/a&gt;</span></span><br><span class="line"><span class="attr">&lt;img</span> <span class="string">src=&quot;../../images/gtvglogo.png&quot; </span></span><br><span class="line">     <span class="attr">th</span>:<span class="string">attr=&quot;src=@&#123;/images/gtvglogo.png&#125;,title=#&#123;logo&#125;,alt=#&#123;logo&#125;&quot; /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>表达式：用来动态取值</strong></p><ul><li><strong>${}：变量取值；使用model共享给页面的值都直接用${}是用下面的方法实现的：</strong></li></ul><p>model.addAttribute(“imgUrl”<strong>,</strong>“/4.jpg”)<strong>;imgUrl就是共享的值</strong></p><ul><li><strong>@{}：url路径；@{}是一个Thymeleaf的URL表达式，它用来在HTML文档中生成一个相对于当前应用上下文的URL路径。当然也可以直接使用{}表示，例如：src=&quot;{}&quot;但是其如果在配置文件中配置了</strong>server.servlet.context-path=/demo那么要想配置的src路径生效需要在src的路径前添加/demo前缀否则无法访问，如果是使用的是src=的是@{}那么可以不用修改src仍旧可以正常访问。</li><li>**@{}路径中的内容会自动添加链接头部和尾部**</li><li>#{}：国际化消息</li><li>~{}：片段引用</li><li>*{}：变量选择：需要配合th:object绑定对象</li></ul><p><strong>系统工具&amp;内置对象：</strong><a href="https://www.thymeleaf.org/doc/tutorials/3.1/usingthymeleaf.html#appendix-a-expression-basic-objects">详细文档</a></p><ul><li>param：请求参数对象</li><li>session：session对象</li><li>application：application对象</li><li>#execInfo：模板执行信息</li><li>#messages：国际化消息</li><li>#uris：uri/url工具</li><li>#conversions：类型转换工具</li><li>#dates：日期工具，是java.util.Date对象的工具类</li><li>#calendars：类似#dates，只不过是java.util.Calendar对象的工具类</li><li>#temporals： JDK8+ <strong>java.time</strong> API 工具类</li><li>#numbers：数字操作工具</li><li>#strings：字符串操作</li><li>#objects：对象操作</li><li>#bools：bool操作</li><li>#arrays：array工具</li><li>#lists：list工具</li><li>#sets：set工具</li><li>#maps：map工具</li><li>#aggregates：集合聚合工具（sum、avg）</li><li>#ids：id生成工具</li></ul><h3 id="2-语法示例">2. 语法示例</h3><p><strong>表达式：</strong></p><ul><li>变量取值：${…}</li><li>url 取值：@{…}</li><li>国际化消息：#{…}</li><li>变量选择：*{…}</li><li>片段引用:~{…}</li></ul><p><strong>常见：</strong></p><ul><li>文本：‘one text’，‘another one!’,…</li><li>数字：0,34,3.0,12.3,…</li><li>布尔：true、false</li><li>null:null</li><li>变量名：one,sometext,main…</li></ul><p><strong>文本操作：</strong></p><ul><li>拼串：+</li><li>文本替换：| The name is ${name} |</li></ul><p><strong>布尔操作：</strong></p><ul><li>二进制运算：and,or</li><li>取反：!,not</li></ul><p><strong>比较运算：</strong></p><ul><li>比较：&gt;，&lt;，&lt;=，&gt;=（gt，lt，ge,le）</li><li>等值运算：==,!=（eq，ne）</li></ul><p><strong>条件运算：</strong></p><ul><li>if-then：(if)?(then)</li><li>if-then-else:(if)?(then):(else)</li><li>default:(value)?:(defaultValue)</li></ul><p><strong>特殊语法：</strong></p><ul><li>无操作：_</li></ul><p><strong>所有以上都可以嵌套组合</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;User is of type &#x27; + ($&#123;user.isAdmin()&#125; ? &#x27;Administrator&#x27; : ($&#123;user.type&#125; ?: &#x27;Unknown&#x27;))</span><br></pre></td></tr></table></figure><h2 id="3-属性设置">3. 属性设置</h2><ol><li>th:href=“@{/product/list}”</li><li>th:attr=“class=${active}”</li><li>th:attr=“src=@{/images/gtvglogo.png},title=${logo},alt=#{logo}”</li><li>th:checked=“${user.active}”</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p th:text=&quot;$&#123;content&#125;&quot;&gt;原内容&lt;/p&gt;</span><br><span class="line">&lt;a th:href=&quot;$&#123;url&#125;&quot;&gt;登录&lt;/a&gt;</span><br><span class="line">&lt;img src=&quot;../../images/gtvglogo.png&quot; </span><br><span class="line">     th:attr=&quot;src=@&#123;/images/gtvglogo.png&#125;,title=#&#123;logo&#125;,alt=#&#123;logo&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure><h2 id="4-遍历">4. 遍历</h2><p>语法： th:each=“元素名,迭代状态 : ${集合}”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr th:each=&quot;prod : $&#123;prods&#125;&quot;&gt;</span><br><span class="line">  &lt;td th:text=&quot;$&#123;prod.name&#125;&quot;&gt;Onions&lt;/td&gt;</span><br><span class="line">  &lt;td th:text=&quot;$&#123;prod.price&#125;&quot;&gt;2.41&lt;/td&gt;</span><br><span class="line">  &lt;td th:text=&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;&gt;yes&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">&lt;tr th:each=&quot;prod,iterStat : $&#123;prods&#125;&quot; th:class=&quot;$&#123;iterStat.odd&#125;? &#x27;odd&#x27;&quot;&gt;</span><br><span class="line">  &lt;td th:text=&quot;$&#123;prod.name&#125;&quot;&gt;Onions&lt;/td&gt;</span><br><span class="line">  &lt;td th:text=&quot;$&#123;prod.price&#125;&quot;&gt;2.41&lt;/td&gt;</span><br><span class="line">  &lt;td th:text=&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;&gt;yes&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure><p>iterStat 有以下属性：</p><ul><li>index：当前遍历元素的索引，从0开始</li><li>count：当前遍历元素的索引，从1开始</li><li>size：需要遍历元素的总数量</li><li>current：当前正在遍历的元素对象</li><li>even/odd：是否偶数/奇数行</li><li>first：是否第一个元素</li><li>last：是否最后一个元素</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;th scope=&quot;col&quot;&gt;#&lt;/th&gt;这里的th标签表示是一个表头标签，scope属性指定表头单元格的范围，这里的范围</span><br><span class="line">是一个表头占据一个单元格。</span><br></pre></td></tr></table></figure><h2 id="5-判断">5. 判断</h2><h3 id="th-if">th:if</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;td th:text=&quot;| $&#123;person.age&#125; / $&#123;person.age &gt;= 18?&#x27;成年&#x27;:&#x27;未成年&#x27; &#125;|&quot;&gt;  &lt;/td&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;a</span><br><span class="line">  href=&quot;comments.html&quot;</span><br><span class="line">  th:href=&quot;@&#123;/product/comments(prodId=$&#123;prod.id&#125;)&#125;&quot;</span><br><span class="line">  th:if=&quot;$&#123;not #lists.isEmpty(prod.comments)&#125;&quot;</span><br><span class="line">  &gt;view&lt;/a</span><br></pre></td></tr></table></figure><h3 id="th-switch">th:switch</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div th:switch=&quot;$&#123;user.role&#125;&quot;&gt;</span><br><span class="line">  &lt;p th:case=&quot;&#x27;admin&#x27;&quot;&gt;User is an administrator&lt;/p&gt;//这里的admin的单引号表示其为一个字符串</span><br><span class="line">//，和变量区分</span><br><span class="line"></span><br><span class="line">  &lt;p th:case=&quot;#&#123;roles.manager&#125;&quot;&gt;User is a manager&lt;/p&gt;</span><br><span class="line">  &lt;p th:case=&quot;*&quot;&gt;User is some other thing&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="6-属性优先级">6. 属性优先级</h2><ul><li>片段</li><li>遍历</li><li>判断</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li th:each=&quot;item : $&#123;items&#125;&quot; th:text=&quot;$&#123;item.description&#125;&quot;&gt;Item description here...&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>Order</th><th>Feature</th><th>Attributes</th></tr></thead><tbody><tr><td>1</td><td>片段包含</td><td>th:insertth:replace</td></tr><tr><td>2</td><td>遍历</td><td>th:each</td></tr><tr><td>3</td><td>判断</td><td>th:ifth:unlessth:switchth:case</td></tr><tr><td>4</td><td>定义本地变量</td><td>th:objectth:with</td></tr><tr><td>5</td><td>通用方式属性修改</td><td>th:attrth:attrprependth:attrappend</td></tr><tr><td>6</td><td>指定属性修改</td><td>th:valueth:hrefth:src…</td></tr><tr><td>7</td><td>文本值</td><td>th:textth:utext</td></tr><tr><td>8</td><td>片段指定</td><td>th:fragment</td></tr><tr><td>9</td><td>片段移除</td><td>th:remove</td></tr></tbody></table><h2 id="7-行内写法">7. 行内写法</h2><p>[[…]] or [(…)]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Hello, [[$&#123;session.user.name&#125;]]!&lt;/p&gt;</span><br></pre></td></tr></table></figure><h2 id="8-变量选择">8. 变量选择</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt;</span><br><span class="line">  &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;p&gt;Name: &lt;span th:text=&quot;$&#123;session.user.firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Surname: &lt;span th:text=&quot;$&#123;session.user.lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Nationality: &lt;span th:text=&quot;$&#123;session.user.nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;</span><br><span class="line">&lt;/div</span><br></pre></td></tr></table></figure><h2 id="9-模板布局">9. 模板布局</h2><ul><li>定义模板： th:fragment</li><li>引用模板：~{templatename::selector}</li><li>插入模板：th:insert、th:replace</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;footer th:fragment=&quot;copy&quot;&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div th:insert=&quot;~&#123;footer :: copy&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div th:replace=&quot;~&#123;footer :: copy&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  结果：</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">th:insert和th:replace是Thymeleaf模板引擎中的两个属性，用于在模板中插入或替换其他模板片段。</span><br><span class="line">th:insert属性用于在当前模板中插入另一个模板片段。</span><br><span class="line">th:replace属性用于在当前模板中替换自身的内容为另一个模板片段。</span><br></pre></td></tr></table></figure><h2 id="10-devtools">10. devtools</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>修改页面后；ctrl+F9刷新效果（热启动）；前提是配置了devtools。<br>java代码的修改，如果devtools热启动了，可能会引起一些bug，难以排查<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1691304138965-1792688e-a546-44c5-b225-df80d9bc8562.png#averageHue=%23f2f1dc&amp;clientId=u5acfc650-ecf6-4&amp;from=paste&amp;height=46&amp;id=u926de390&amp;originHeight=58&amp;originWidth=223&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=12806&amp;status=done&amp;style=none&amp;taskId=u16c89229-3bdc-4732-9eb3-5693e766448&amp;title=&amp;width=178.4" alt="image.png">（缓存机制）<br>spring.thymeleaf.check-template=false检查模板是否存在</p><h1>6. 国际化</h1><p>国际化的自动配置参照MessageSourceAutoConfiguration<br><strong>实现步骤</strong>：</p><ol><li>Spring Boot 在类路径根下查找messages资源绑定文件（配置。文件名为：messages.properties</li><li>多语言可以定义多个消息文件，命名为messages_区域代码.properties。如：<ol><li>messages.properties：默认</li><li>messages_zh_CN.properties：中文环境</li><li>messages_en_US.properties：英语环境</li></ol></li><li>在<strong>程序中</strong>可以自动注入 MessageSource组件，获取国际化的配置项值</li><li>在<strong>页面中</strong>可以使用表达式  #{}获取国际化的配置项值</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Autowired  //国际化取消息用的组件</span><br><span class="line">MessageSource messageSource;</span><br><span class="line">@GetMapping(&quot;/haha&quot;)</span><br><span class="line">public String haha(HttpServletRequest request)&#123;</span><br><span class="line"></span><br><span class="line">    Locale locale = request.getLocale();</span><br><span class="line">    //利用代码的方式获取国际化配置文件中指定的配置项的值</span><br><span class="line">    String login = messageSource.getMessage(&quot;login&quot;, null, locale);</span><br><span class="line">    return login;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>7. 错误处理</h1><h2 id="1-默认机制">1. 默认机制</h2><p><strong>错误处理的自动配置</strong>都在ErrorMvcAutoConfiguration中，两大核心机制：</p><ul><li><ol><li>SpringBoot 会<strong>自适应处理错误</strong>，<strong>响应页面</strong>或<strong>JSON数据</strong></li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Spring Boot 会根据请求的类型和接受的媒体类型，自适应地处理错误，返回合适的响应格式。</span><br><span class="line">如果请求是一个浏览器请求，Spring Boot 会返回一个 HTML 错误页面，这个页面也被称为白标错误页面。</span><br><span class="line">如果请求是一个 RESTful 请求，或者接受的媒体类型是 JSON，Spring Boot 会返回一个 JSON 响应，</span><br><span class="line">包含错误的详细信息，HTTP 状态码，和异常消息</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>2.** SpringMVC的错误处理机制<strong>依然保留，<strong>MVC处理不了</strong>，才会</strong>交给boot进行处理**</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/svg/1613913/1681723795095-828d2034-1e6c-4d98-8e47-573dd6b5463b.svg#from=url&amp;id=ez8nQ&amp;originHeight=842&amp;originWidth=1047&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>1.springMvc处理错误：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1691307013013-0d54dd7b-2189-4f1b-b63d-f880eeadd942.png#averageHue=%23fdfdfb&amp;clientId=u8fdb1034-8532-4&amp;from=paste&amp;height=370&amp;id=u8cfa0ee8&amp;originHeight=463&amp;originWidth=960&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=134823&amp;status=done&amp;style=none&amp;taskId=ud0d4529f-dec1-4e92-8baa-78f5b60dba9&amp;title=&amp;width=768" alt="image.png"><br>这里如果发生了错误，会执行@ExceptionHandler修饰的方法，这里是将handleException中的方法的返回值写到返回体中，然后返回该浏览器。<br>2.<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1691307230435-8c06a2a5-20ea-423f-b5e3-cc14688b812f.png#averageHue=%23f7f4e0&amp;clientId=u8fdb1034-8532-4&amp;from=paste&amp;height=66&amp;id=ubf31b11b&amp;originHeight=83&amp;originWidth=571&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=36513&amp;status=done&amp;style=none&amp;taskId=ua92b8fb3-30aa-4271-908a-08bf7d846ed&amp;title=&amp;width=456.8" alt="image.png"></p><ul><li>发生错误以后，转发给/error路径，SpringBoot在底层写好一个 BasicErrorController的组件，专门处理这个请求</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(produces = MediaType.TEXT_HTML_VALUE) //返回HTML</span><br><span class="line">public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">HttpStatus status = getStatus(request);</span><br><span class="line">Map&lt;String, Object&gt; model = Collections</span><br><span class="line">.unmodifiableMap(getErrorAttributes(request, getErrorAttributeOptions(request, MediaType.TEXT_HTML)));</span><br><span class="line">response.setStatus(status.value());</span><br><span class="line">ModelAndView modelAndView = resolveErrorView(request, response, status, model);</span><br><span class="line">return (modelAndView != null) ? modelAndView : new ModelAndView(&quot;error&quot;, model);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RequestMapping  //返回 ResponseEntity, JSON</span><br><span class="line">public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;</span><br><span class="line">HttpStatus status = getStatus(request);</span><br><span class="line">if (status == HttpStatus.NO_CONTENT) &#123;</span><br><span class="line">return new ResponseEntity&lt;&gt;(status);</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;String, Object&gt; body = getErrorAttributes(request, getErrorAttributeOptions(request, MediaType.ALL));</span><br><span class="line">return new ResponseEntity&lt;&gt;(body, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>错误页面是这么解析到的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//1、解析错误的自定义视图地址</span><br><span class="line">ModelAndView modelAndView = resolveErrorView(request, response, status, model);</span><br><span class="line">//2、如果解析不到错误页面的地址，默认的错误页就是 error</span><br><span class="line">return (modelAndView != null) ? modelAndView : new ModelAndView(&quot;error&quot;, model);</span><br></pre></td></tr></table></figure><p>容器中专门有一个错误视图解析器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@ConditionalOnBean(DispatcherServlet.class)</span><br><span class="line">@ConditionalOnMissingBean(ErrorViewResolver.class)</span><br><span class="line">DefaultErrorViewResolver conventionErrorViewResolver() &#123;</span><br><span class="line">    return new DefaultErrorViewResolver(this.applicationContext, this.resources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringBoot解析自定义错误页的默认规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123;</span><br><span class="line">ModelAndView modelAndView = resolve(String.valueOf(status.value()), model);</span><br><span class="line">if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123;</span><br><span class="line">modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);</span><br><span class="line">&#125;</span><br><span class="line">return modelAndView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123;</span><br><span class="line">String errorViewName = &quot;error/&quot; + viewName;</span><br><span class="line">TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName,</span><br><span class="line">this.applicationContext);</span><br><span class="line">if (provider != null) &#123;</span><br><span class="line">return new ModelAndView(errorViewName, model);</span><br><span class="line">&#125;</span><br><span class="line">return resolveResource(errorViewName, model);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ModelAndView resolveResource(String viewName, Map&lt;String, Object&gt; model) &#123;</span><br><span class="line">for (String location : this.resources.getStaticLocations()) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Resource resource = this.applicationContext.getResource(location);</span><br><span class="line">resource = resource.createRelative(viewName + &quot;.html&quot;);</span><br><span class="line">if (resource.exists()) &#123;</span><br><span class="line">return new ModelAndView(new HtmlResourceView(resource), model);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (Exception ex) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容器中有一个默认的名为 error 的 view； 提供了默认白页功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean(name = &quot;error&quot;)</span><br><span class="line">@ConditionalOnMissingBean(name = &quot;error&quot;)</span><br><span class="line">public View defaultErrorView() &#123;</span><br><span class="line">    return this.defaultErrorView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装了JSON格式的错误信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT)</span><br><span class="line">public DefaultErrorAttributes errorAttributes() &#123;</span><br><span class="line">return new DefaultErrorAttributes();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>规则：</p><ol><li><strong>解析一个错误页</strong><ol><li>如果发生了500、404、503、403 这些错误<ol><li>如果有<strong>模板引擎</strong>，默认在 classpath:/templates/error/<strong>精确码.html</strong></li><li>如果没有模板引擎，在静态资源文件夹下找 <strong>精确码.html</strong></li></ol></li><li>如果匹配不到精确码.html这些精确的错误页，就去找5xx.html，4xx.html<strong>模糊匹配</strong><ol><li>如果有模板引擎，默认在 classpath:/templates/error/5xx.html</li><li>如果没有模板引擎，在静态资源文件夹下找 5xx.html</li></ol></li></ol></li><li>如果模板引擎路径templates下有 error.html页面，就直接渲染</li></ol><h2 id="2-自定义错误响应">2. 自定义错误响应</h2><h3 id="1-自定义json响应">1. 自定义json响应</h3><p>使用@ControllerAdvice + @ExceptionHandler 进行统一异常处理</p><h3 id="2-自定义页面响应">2. 自定义页面响应</h3><p>根据boot的错误页面规则，自定义页面模板</p><h2 id="3-最佳实战">3. 最佳实战</h2><ul><li><strong>前后分离</strong><ul><li>后台发生的所有错误，@ControllerAdvice + @ExceptionHandler进行统一异常处理。</li></ul></li><li><strong>服务端页面渲染</strong><ul><li><strong>不可预知的一些，HTTP码表示的服务器或客户端错误</strong><ul><li>给classpath:/templates/error/下面，放常用精确的错误码页面。500.html，404.html</li><li>给classpath:/templates/error/下面，放通用模糊匹配的错误码页面。 5xx.html，4xx.html</li></ul></li><li><strong>发生业务错误</strong><ul><li><strong>核心业务</strong>，每一种错误，都应该代码控制，<strong>跳转到自己定制的错误页</strong>。</li><li><strong>通用业务</strong>，classpath:/templates/error.html页面，<strong>显示错误信息（可以通过在错误页面中添加[[${trance}]]来显示错误堆栈信息）</strong>。</li></ul></li><li></li></ul></li></ul><p>页面，JSON，可用的Model数据如下<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681724501227-077073b7-349d-414f-8916-a822eb86c772.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_26%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f5f4f3&amp;from=url&amp;id=PNxJP&amp;originHeight=196&amp;originWidth=919&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h1>8. 嵌入式容器</h1><p><strong>Servlet容器</strong>：管理、运行<strong>Servlet组件</strong>（Servlet、Filter、Listener）的环境，一般指<strong>服务器</strong></p><h2 id="1-自动配置原理">1. 自动配置原理</h2><ul><li>SpringBoot 默认嵌入Tomcat作为Servlet容器。</li><li><strong>自动配置类</strong>是ServletWebServerFactoryAutoConfiguration，EmbeddedWebServerFactoryCustomizerAutoConfiguration</li><li>自动配置类开始分析功能。<code>xxxxAutoConfiguration</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@AutoConfiguration</span><br><span class="line">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line">@ConditionalOnClass(ServletRequest.class)//@ConditionOn表示满足这些条件才将该类加载到容器中</span><br><span class="line">@ConditionalOnWebApplication(type = Type.SERVLET)</span><br><span class="line">@EnableConfigurationProperties(ServerProperties.class)</span><br><span class="line">@Import(&#123; ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,</span><br><span class="line">ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,</span><br><span class="line">ServletWebServerFactoryConfiguration.EmbeddedJetty.class,</span><br><span class="line">ServletWebServerFactoryConfiguration.EmbeddedUndertow.class &#125;)</span><br><span class="line">public class ServletWebServerFactoryAutoConfiguration &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@AutoConfiguration：该注解表示这是一个自动配置类，用于自动配置应用程序的某些功能或组件。</span><br><span class="line"></span><br><span class="line">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)：该注解指定了自动配置类的优先级，</span><br><span class="line">使用 Ordered.HIGHEST_PRECEDENCE 表示具有最高优先级。优先级较高的自动配置类将在启动过程中优先</span><br><span class="line">加载和应用。</span><br><span class="line"></span><br><span class="line">@ConditionalOnClass(ServletRequest.class)：该注解表示只有当类路径上存在 ServletRequest 类时</span><br><span class="line">，才会加载和应用该自动配置类。也就是说，只有当 Servlet 相关的类存在时，该自动配置类才会生效。</span><br><span class="line"></span><br><span class="line">@ConditionalOnWebApplication(type = Type.SERVLET)：该注解表示只有当应用程序类型为 Servlet</span><br><span class="line">Web 应用时，才会加载和应用该自动配置类。这意味着该自动配置类仅适用于基于 Servlet 的 Web </span><br><span class="line">应用程序，而不适用于其他类型的应用程序。web程序除了servlet外还有其他的，比如：响应式，JSP等。</span><br><span class="line">关于 Servlet 的特点，以下是一些主要的特点：</span><br><span class="line">平台无关性：Servlet 是基于 Java 技术的，可以在任何支持 Java 的平台上运行，无论是 Windows、</span><br><span class="line">Linux 还是其他操作系统。</span><br><span class="line">可移植性：Servlet 可以在不同的 Web 容器中运行，例如 Tomcat、Jetty、WebLogic 等。</span><br><span class="line">这使得开发人员可以在不同的容器中部署和运行 Servlet，而不需要修改代码。</span><br><span class="line"></span><br><span class="line">@EnableConfigurationProperties(ServerProperties.class)：用于启用配置属性的绑定并将其注入到</span><br><span class="line">Spring 容器中。</span><br><span class="line">在这种情况下，ServerProperties 类的配置属性将被绑定到该自动配置类中。</span><br><span class="line">其中ServerProperties 类被@ConfigurationProperties(</span><br><span class="line">    prefix = &quot;server&quot;,</span><br><span class="line">    ignoreUnknownFields = true</span><br><span class="line">)修饰，@ConfigurationProperties 是一个注解，用于将配置属性绑定到一个类上。在上述代码中，</span><br><span class="line">它被应用在类级别上，表示将配置属性绑定到带有 prefix 前缀的属性上，并且忽略未知的字段。</span><br><span class="line">但是其ServerProperties 类在此时并未注入到容器中。</span><br><span class="line"></span><br><span class="line">@Import(&#123; ... &#125;)：该注解用于导入其他的配置类或组件。在这个例子中，它导入了与 Servlet Web</span><br><span class="line">服务器工厂相关的配置类，包括 Tomcat、Jetty 和 Undertow 的配置。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>ServletWebServerFactoryAutoConfiguration 自动配置了嵌入式容器场景</li><li>绑定了ServerProperties配置类，所有和服务器有关的配置 server（也就是配置文件·中以server开头的配置属性是关于服务器的）</li><li>ServletWebServerFactoryAutoConfiguration 导入了 嵌入式的三大服务器 Tomcat、Jetty、Undertow</li></ol><p>1.servlet不仅支持Tomcat服务器还支持Jetty ，Netty，Undertow服务器<br>2.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ConditionalOnClass(&#123;Servlet.class, Tomcat.class, UpgradeProtocol.class&#125;)</span><br><span class="line">    @ConditionalOnMissingBean(</span><br><span class="line">        value = &#123;ServletWebServerFactory.class&#125;,</span><br><span class="line">        search = SearchStrategy.CURRENT</span><br><span class="line">    )</span><br><span class="line">    static class EmbeddedTomcat &#123;</span><br><span class="line">        EmbeddedTomcat() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">@ConditionalOnClass(&#123;Servlet.class, Tomcat.class, UpgradeProtocol.class&#125;)决定了web程序的服务器</span><br><span class="line">类型，而避免了其他类型的服务器。</span><br></pre></td></tr></table></figure><ol><li>导入 Tomcat、Jetty、Undertow 都有条件注解。系统中有这个类才行（也就是导了包）也是这种方式决定了web程序采用的服务器类型。</li><li>默认 Tomcat配置生效。给容器中放 TomcatServletWebServerFactory</li><li>都给容器中 ServletWebServerFactory放了一个** web服务器工厂（造web服务器的）可以在ServletWebServerFactoryAutoConfiguration类中查看到注入了不同的 ServletWebServerFactory**</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">       TomcatServletWebServerFactory tomcatServletWebServerFactory</span><br></pre></td></tr></table></figure><ol start="4"><li>**web服务器工厂 都有一个功能，**getWebServer获取web服务器。其中TomcatServletWebServerFactory 创建了tomcat而其他服务器工厂没有创建。</li><li>TomcatServletWebServerFactory 创建了 tomcat。</li><li>ServletWebServerFactory 什么时候会创建 webServer出来。</li><li>ServletWebServerApplicationContextioc容器，启动的时候会调用创建web服务器</li><li>Spring**容器刷新（启动）**的时候，会预留一个时机，刷新子容器。onRefresh()</li><li>refresh() 容器刷新 十二大步的刷新子容器会调用 onRefresh()；</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onRefresh() &#123;</span><br><span class="line">super.onRefresh();</span><br><span class="line">try &#123;</span><br><span class="line">createWebServer();</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">throw new ApplicationContextException(&quot;Unable to start web server&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Web场景的Spring容器启动，在onRefresh的时候，会调用创建web服务器的方法。<br>Web服务器的创建是通过WebServerFactory搞定的。容器中又会根据导了什么包条件注解，启动相关的 服务器配置，默认EmbeddedTomcat会给容器中放一个 TomcatServletWebServerFactory，导致项目启动，自动创建出Tomcat。<br>用法：<br>1.修改server下的相关配置就可以修改服务器的参数<br>2.通过给容器中放一个ServletWebServerFactory,来禁用掉springBoot默认配置的服务器工厂，实现自定义的嵌入式服务器。</p><h2 id="2-自定义">2. 自定义</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681725850466-2ecf12f4-8b66-469f-9d5d-377a33923b3c.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_19%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23ceae84&amp;from=url&amp;id=W0Ot4&amp;originHeight=268&amp;originWidth=668&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;servlet-api.version&gt;3.1.0&lt;/servlet-api.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;!-- Exclude the Tomcat dependency --&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- Use Jetty instead --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="3-最佳实践">3. 最佳实践</h2><p><strong>用法：</strong></p><ul><li>修改server下的相关配置就可以修改<strong>服务器参数</strong></li><li>通过给容器中放一个<strong>ServletWebServerFactory</strong>，来禁用掉SpringBoot默认放的服务器工厂，实现自定义嵌入<strong>任意服务器</strong>。</li></ul><h1>9. 全面接管SpringMVC</h1><ul><li>SpringBoot 默认配置好了 SpringMVC 的所有常用特性。</li><li>如果我们需要全面接管SpringMVC的所有配置并<strong>禁用默认配置</strong>，仅需要编写一个WebMvcConfigurer配置类，并标注 @EnableWebMvc 即可</li><li>全手动模式<ul><li>@EnableWebMvc : 禁用默认配置，该注解在@Configuration上</li><li><strong>WebMvcConfigurer</strong>组件：定义MVC的底层行为</li></ul></li></ul><h2 id="1-WebMvcAutoConfiguration-到底自动配置了哪些规则">1. WebMvcAutoConfiguration 到底自动配置了哪些规则</h2><p>SpringMVC自动配置场景给我们配置了如下所有<strong>默认行为</strong></p><ol><li>WebMvcAutoConfigurationweb场景的自动配置类<ol><li>支持RESTful的filter：HiddenHttpMethodFilter(HiddenHttpMethodFilter 的作用就是检查通过 POST 请求提交的表单数据中是否包含名为 _method 的隐藏字段，并将其值作为实际的 HTTP 方法进行处理。也就是新增了delete,和patch)</li><li>支持非POST请求，请求体携带数据：FormContentFilter(FormContentFilter 的作用是解析请求体中的表单数据，并将其转换为相应的请求参数，以便后续的处理器（Handler）能够方便地获取和使用这些参数。)</li><li>导入<strong>EnableWebMvcConfiguration</strong>：<ol><li>RequestMappingHandlerAdapter</li><li>WelcomePageHandlerMapping： <strong>欢迎页功能</strong>支持（模板引擎目录、静态资源目录放index.html），项目访问/ 就默认展示这个页面.</li><li>RequestMappingHandlerMapping：找每个请求由谁处理的映射关系</li><li>ExceptionHandlerExceptionResolver：默认的异常解析器</li><li>LocaleResolver：国际化解析器</li><li>ThemeResolver：主题解析器</li><li>FlashMapManager：临时数据共享</li><li>FormattingConversionService： 数据格式化 、类型转化</li><li>Validator： 数据校验JSR303提供的数据校验功能</li><li>WebBindingInitializer：请求参数的封装与绑定</li><li>ContentNegotiationManager：内容协商管理器</li></ol></li><li><strong>WebMvcAutoConfigurationAdapter</strong>配置生效，它是一个WebMvcConfigurer，定义mvc底层组件<ol><li>定义好 WebMvcConfigurer<strong>底层组件默认功能；所有功能详见列表</strong></li><li>视图解析器：InternalResourceViewResolver</li><li>视图解析器：BeanNameViewResolver,**视图名（controller方法的返回值字符串）**就是组件名</li><li>内容协商解析器：ContentNegotiatingViewResolver</li><li>请求上下文过滤器：RequestContextFilter: 任意位置直接获取当前请求</li><li>静态资源链规则</li><li>ProblemDetailsExceptionHandler：错误详情<ol><li>SpringMVC内部场景异常被它捕获：</li></ol></li></ol></li><li>定义了MVC默认的底层行为: WebMvcConfigurer</li></ol></li></ol><h2 id="2-EnableWebMvc-禁用默认行为">2. @EnableWebMvc 禁用默认行为</h2><ol><li>@EnableWebMvc给容器中导入 DelegatingWebMvcConfiguration组件，</li></ol><p>他是 WebMvcConfigurationSupport</p><ol><li>WebMvcAutoConfiguration有一个核心的条件注解, @ConditionalOnMissingBean(WebMvcConfigurationSupport.class)，容器中没有WebMvcConfigurationSupport，WebMvcAutoConfiguration才生效.</li><li>@EnableWebMvc 导入 WebMvcConfigurationSupport 导致 WebMvcAutoConfiguration 失效。导致禁用了默认行为</li></ol><ul><li>@EnableWebMVC 禁用了 Mvc的自动配置</li><li>WebMvcConfigurer 定义SpringMVC底层组件的功能类</li></ul><h2 id="2-WebMvcConfigurer-功能">2. WebMvcConfigurer 功能</h2><p>定义扩展SpringMVC底层功能</p><table><thead><tr><th>提供方法</th><th>核心参数</th><th>功能</th><th>默认</th></tr></thead><tbody><tr><td>addFormatters</td><td>FormatterRegistry</td><td><strong>格式化器</strong>：支持属性上@NumberFormat和@DatetimeFormat的数据类型转换</td><td>GenericConversionService</td></tr><tr><td>getValidator</td><td>无</td><td><strong>数据校验</strong>：校验 Controller 上使用@Valid标注的参数合法性。需要导入starter-validator</td><td>无</td></tr><tr><td>addInterceptors</td><td>InterceptorRegistry</td><td><strong>拦截器</strong>：拦截收到的所有请求</td><td>无</td></tr><tr><td>configureContentNegotiation</td><td>ContentNegotiationConfigurer</td><td><strong>内容协商</strong>：支持多种数据格式返回。需要配合支持这种类型的HttpMessageConverter</td><td>支持 json</td></tr><tr><td>configureMessageConverters</td><td>List&lt;HttpMessageConverter&lt;?&gt;&gt;</td><td><strong>消息转换器</strong>：标注@ResponseBody的返回值会利用MessageConverter直接写出去</td><td>8 个，支持byte，string,multipart,resource，json</td></tr><tr><td>addViewControllers</td><td>ViewControllerRegistry</td><td><strong>视图映射</strong>：直接将请求路径与物理视图映射。用于无 java 业务逻辑的直接视图页渲染</td><td>无</td></tr><tr><td><a href="mvc:view-controller">mvc:view-controller</a></td><td></td><td></td><td></td></tr><tr><td>configureViewResolvers</td><td>ViewResolverRegistry</td><td><strong>视图解析器</strong>：逻辑视图转为物理视图</td><td>ViewResolverComposite</td></tr><tr><td>addResourceHandlers</td><td>ResourceHandlerRegistry</td><td><strong>静态资源处理</strong>：静态资源路径映射、缓存控制</td><td>ResourceHandlerRegistry</td></tr><tr><td>configureDefaultServletHandling</td><td>DefaultServletHandlerConfigurer</td><td><strong>默认 Servlet</strong>：可以覆盖 Tomcat 的DefaultServlet。让DispatcherServlet拦截/</td><td>无</td></tr><tr><td>configurePathMatch</td><td>PathMatchConfigurer</td><td><strong>路径匹配</strong>：自定义 URL 路径匹配。可以自动为所有路径加上指定前缀，比如 /api</td><td>无</td></tr><tr><td>configureAsyncSupport</td><td>AsyncSupportConfigurer</td><td><strong>异步支持</strong>：</td><td>TaskExecutionAutoConfiguration</td></tr><tr><td>addCorsMappings</td><td>CorsRegistry</td><td><strong>跨域</strong>：</td><td>无</td></tr><tr><td>addArgumentResolvers</td><td>List<HandlerMethodArgumentResolver></td><td><strong>参数解析器</strong>：</td><td>mvc 默认提供</td></tr><tr><td>addReturnValueHandlers</td><td>List<HandlerMethodReturnValueHandler></td><td><strong>返回值解析器</strong>：</td><td>mvc 默认提供</td></tr><tr><td>configureHandlerExceptionResolvers</td><td>List<HandlerExceptionResolver></td><td><strong>异常处理器</strong>：</td><td>默认 3 个</td></tr><tr><td>ExceptionHandlerExceptionResolver</td><td></td><td></td><td></td></tr><tr><td>ResponseStatusExceptionResolver</td><td></td><td></td><td></td></tr><tr><td>DefaultHandlerExceptionResolver</td><td></td><td></td><td></td></tr><tr><td>getMessageCodesResolver</td><td>无</td><td><strong>消息码解析器</strong>：国际化使用</td><td>无</td></tr></tbody></table><h1>10. 最佳实践</h1><p>SpringBoot 已经默认配置好了<strong>Web开发</strong>场景常用功能。我们直接使用即可。</p><h2 id="三种方式">三种方式</h2><table><thead><tr><th>方式</th><th>用法</th><th></th><th>效果</th></tr></thead><tbody><tr><td><strong>全自动</strong></td><td>直接编写控制器逻辑</td><td></td><td>全部使用<strong>自动配置默认效果</strong></td></tr><tr><td><strong>手自一体</strong></td><td>@Configuration +</td><td></td><td></td></tr><tr><td>配置<strong>WebMvcConfigurer</strong>+</td><td></td><td></td><td></td></tr><tr><td><em>配置 WebMvcRegistrations</em></td><td><strong>不要标注</strong></td><td></td><td></td></tr><tr><td>@<strong>EnableWebMvc</strong></td><td><strong>保留自动配置效果</strong></td><td></td><td></td></tr><tr><td><strong>手动设置部分功能</strong></td><td></td><td></td><td></td></tr><tr><td>定义MVC底层组件</td><td></td><td></td><td></td></tr><tr><td><strong>全手动</strong></td><td>@Configuration +</td><td></td><td></td></tr><tr><td>配置<strong>WebMvcConfigurer</strong></td><td><strong>标注</strong></td><td></td><td></td></tr><tr><td>@<strong>EnableWebMvc</strong></td><td><strong>禁用自动配置效果</strong></td><td></td><td></td></tr><tr><td><strong>全手动设置</strong></td><td></td><td></td><td></td></tr></tbody></table><p>总结：<br><strong>给容器中写一个配置类@Configuration实现 WebMvcConfigurer但是不要标注 @EnableWebMvc注解，实现手自一体的效果。</strong></p><h1>11. Web新特性</h1><h2 id="1-Problemdetails">1. Problemdetails</h2><p>RFC 7807: <a href="https://www.rfc-editor.org/rfc/rfc7807">https://www.rfc-editor.org/rfc/rfc7807</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProblemDetails 是一种在Web API中表示错误和异常信息的规范化格式。它是根据RFC 7807规范定义的，</span><br><span class="line">旨在提供一种统一的方式来描述和传递错误信息。</span><br></pre></td></tr></table></figure><p><strong>错误信息</strong>返回新格式<br>原理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration(proxyBeanMethods = false)</span><br><span class="line">//配置过一个属性 spring.mvc.problemdetails.enabled=true才能让</span><br><span class="line">//ProblemDetailsErrorHandlingConfiguration生效，其中spring.mvc.problemdetails.enabled</span><br><span class="line">//默认是false的，也就是ProbleDetailsErroHandlingConfiguration默认是关闭的</span><br><span class="line">@ConditionalOnProperty(prefix = &quot;spring.mvc.problemdetails&quot;, name = &quot;enabled&quot;, havingValue = &quot;true&quot;)</span><br><span class="line">static class ProblemDetailsErrorHandlingConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(ResponseEntityExceptionHandler.class)</span><br><span class="line">    ProblemDetailsExceptionHandler problemDetailsExceptionHandler() &#123;</span><br><span class="line">        return new ProblemDetailsExceptionHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>ProblemDetailsExceptionHandler (被 @ControllerAdvice修饰的类）是一个 @ControllerAdvice集中处理系统异常,</strong></li><li><strong>ProblemDetailsExceptionHandler 继承</strong>ResponseEntityExceptionHandler ，而ResponseEntityExceptionHandler类有一个@ExceptionHandle注解用于修饰ResponseEntity<Object>类，其中@ExceptionHandle**处理以下异常。如果系统出现以下异常，会被SpringBoot支持以 **RFC 7807规范方式返回错误数据（但是该规范不是默认生效的）：</li></ol><p>使用@ExceptionHandler 注解时，您需要在方法中定义异常类型作为参数，并在方法体中编写相应的逻辑来处理该异常。当发生定义的异常时，Spring Boot将调用带有 @ExceptionHandler 注解的方法，并将异常传递给该方法进行处理。您可以在该方法中执行适当的操作，例如记录日志、返回自定义错误响应等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@ExceptionHandler(&#123;</span><br><span class="line">HttpRequestMethodNotSupportedException.class, //请求方式不支持</span><br><span class="line">HttpMediaTypeNotSupportedException.class,</span><br><span class="line">HttpMediaTypeNotAcceptableException.class,</span><br><span class="line">MissingPathVariableException.class,</span><br><span class="line">MissingServletRequestParameterException.class,</span><br><span class="line">MissingServletRequestPartException.class,</span><br><span class="line">ServletRequestBindingException.class,</span><br><span class="line">MethodArgumentNotValidException.class,</span><br><span class="line">NoHandlerFoundException.class,</span><br><span class="line">AsyncRequestTimeoutException.class,</span><br><span class="line">ErrorResponseException.class,</span><br><span class="line">ConversionNotSupportedException.class,</span><br><span class="line">TypeMismatchException.class,</span><br><span class="line">HttpMessageNotReadableException.class,</span><br><span class="line">HttpMessageNotWritableException.class,</span><br><span class="line">BindException.class</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>效果：也就是上面的ResponseEntity<Object>类处理异常的效果<br>默认响应错误的json。状态码 405</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;timestamp&quot;: &quot;2023-04-18T11:13:05.515+00:00&quot;,</span><br><span class="line">    &quot;status&quot;: 405,</span><br><span class="line">    &quot;error&quot;: &quot;Method Not Allowed&quot;,</span><br><span class="line">    &quot;trace&quot;: &quot;org.springframework.web.HttpRequestMethodNotSupportedException: Request method &#x27;POST&#x27; is not supported\r\n\tat org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.handleNoMatch(RequestMappingInfoHandlerMapping.java:265)\r\n\tat org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.lookupHandlerMethod(AbstractHandlerMethodMapping.java:441)\r\n\tat org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.getHandlerInternal(AbstractHandlerMethodMapping.java:382)\r\n\tat org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getHandlerInternal(RequestMappingInfoHandlerMapping.java:126)\r\n\tat org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getHandlerInternal(RequestMappingInfoHandlerMapping.java:68)\r\n\tat org.springframework.web.servlet.handler.AbstractHandlerMapping.getHandler(AbstractHandlerMapping.java:505)\r\n\tat org.springframework.web.servlet.DispatcherServlet.getHandler(DispatcherServlet.java:1275)\r\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057)\r\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)\r\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)\r\n\tat org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)\r\n\tat jakarta.servlet.http.HttpServlet.service(HttpServlet.java:563)\r\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)\r\n\tat jakarta.servlet.http.HttpServlet.service(HttpServlet.java:631)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)\r\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)\r\n\tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)\r\n\tat org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)\r\n\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)\r\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)\r\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)\r\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:493)\r\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)\r\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)\r\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)\r\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)\r\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:390)\r\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)\r\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)\r\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1741)\r\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)\r\n\tat org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)\r\n\tat org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)\r\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n\tat java.base/java.lang.Thread.run(Thread.java:833)\r\n&quot;,</span><br><span class="line">    &quot;message&quot;: &quot;Method &#x27;POST&#x27; is not supported.&quot;,</span><br><span class="line">    &quot;path&quot;: &quot;/list&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启ProblemDetails返回, 使用新的MediaType<br><strong>Content-Type: application/problem+json+ 额外扩展返回</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681816524680-e75cbe89-f90c-4ac4-8247-ec850308df65.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_29%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23fafaf9&amp;from=url&amp;id=xnTyF&amp;originHeight=40&amp;originWidth=1030&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="">**</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;: &quot;about:blank&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;Method Not Allowed&quot;,</span><br><span class="line">    &quot;status&quot;: 405,</span><br><span class="line">    &quot;detail&quot;: &quot;Method &#x27;POST&#x27; is not supported.&quot;,</span><br><span class="line">    &quot;instance&quot;: &quot;/list&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-函数式Web"><strong>2. 函数式Web</strong></h2><p><strong>SpringMVC 5.2 以后 允许我们使用函数式的方式，定义Web的请求处理流程。</strong><br><strong>函数式接口</strong><br><strong>Web请求处理的方式：</strong></p><ol><li><strong>@Controller + @RequestMapping：耦合式 （路由、业务耦合）</strong></li><li><strong>函数式Web：分离式（路由、业务分离）</strong></li></ol><h3 id="1-场景">1. 场景</h3><p>场景：User RESTful - CRUD</p><ul><li>GET /user/1 获取1号用户</li><li>GET /users 获取所有用户</li><li>POST /user ** 请求体**携带JSON，新增一个用户</li><li>PUT /user/1 <strong>请求体</strong>携带JSON，修改1号用户</li><li>DELETE /user/1** 删除**1号用户</li></ul><h3 id="2-核心类">2. 核心类</h3><ul><li><strong>RouterFunction</strong></li><li><strong>RequestPredicate</strong></li><li><strong>ServerRequest</strong></li><li><strong>ServerResponse</strong></li></ul><h3 id="3-示例">3. 示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.http.MediaType;</span><br><span class="line">import org.springframework.web.servlet.function.RequestPredicate;</span><br><span class="line">import org.springframework.web.servlet.function.RouterFunction;</span><br><span class="line">import org.springframework.web.servlet.function.ServerResponse;</span><br><span class="line"></span><br><span class="line">import static org.springframework.web.servlet.function.RequestPredicates.accept;</span><br><span class="line">import static org.springframework.web.servlet.function.RouterFunctions.route;</span><br><span class="line"></span><br><span class="line">@Configuration(proxyBeanMethods = false)</span><br><span class="line">public class MyRoutingConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    private static final RequestPredicate ACCEPT_JSON = accept(MediaType.APPLICATION_JSON);</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RouterFunction&lt;ServerResponse&gt; routerFunction(MyUserHandler userHandler) &#123;</span><br><span class="line">        return route()</span><br><span class="line">                .GET(&quot;/&#123;user&#125;&quot;, ACCEPT_JSON, userHandler::getUser)</span><br><span class="line">                .GET(&quot;/&#123;user&#125;/customers&quot;, ACCEPT_JSON, userHandler::getUserCustomers)</span><br><span class="line">                .DELETE(&quot;/&#123;user&#125;&quot;, ACCEPT_JSON, userHandler::deleteUser)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.web.servlet.function.ServerRequest;</span><br><span class="line">import org.springframework.web.servlet.function.ServerResponse;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class MyUserHandler &#123;</span><br><span class="line"></span><br><span class="line">    public ServerResponse getUser(ServerRequest request) &#123;</span><br><span class="line">        ...</span><br><span class="line">        return ServerResponse.ok().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ServerResponse getUserCustomers(ServerRequest request) &#123;</span><br><span class="line">        ...</span><br><span class="line">        return ServerResponse.ok().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ServerResponse deleteUser(ServerRequest request) &#123;</span><br><span class="line">        ...</span><br><span class="line">        return ServerResponse.ok().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.web.config;</span><br><span class="line"></span><br><span class="line">import com.atguigu.web.bean.Person;</span><br><span class="line">import com.atguigu.web.biz.UserBizHandler;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.http.MediaType;</span><br><span class="line">import org.springframework.web.servlet.function.RequestPredicates;</span><br><span class="line">import org.springframework.web.servlet.function.RouterFunction;</span><br><span class="line">import org.springframework.web.servlet.function.RouterFunctions;</span><br><span class="line">import org.springframework.web.servlet.function.ServerResponse;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author lfy</span><br><span class="line"> * @Description</span><br><span class="line"> * @create 2023-04-18 21:46</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 场景：User RESTful - CRUD</span><br><span class="line"> * ● GET /user/1  获取1号用户</span><br><span class="line"> * ● GET /users   获取所有用户</span><br><span class="line"> * ● POST /user  请求体携带JSON，新增一个用户</span><br><span class="line"> * ● PUT /user/1 请求体携带JSON，修改1号用户</span><br><span class="line"> * ● DELETE /user/1 删除1号用户</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class WebFunctionConfig &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 函数式Web：</span><br><span class="line">     * 1、给容器中放一个Bean：类型是 RouterFunction&lt;ServerResponse&gt;，集中所有路由信息</span><br><span class="line">     * 2、每个业务准备一个自己的Handler</span><br><span class="line">     *</span><br><span class="line">     *</span><br><span class="line">     * 核心四大对象</span><br><span class="line">     * 1、RouterFunction： 定义路由信息。发什么请求，谁来处理</span><br><span class="line">     * 2、RequestPredicate：定义请求规则：请求谓语。请求方式（GET、POST）、请求参数</span><br><span class="line">     * 3、ServerRequest：  封装请求完整数据</span><br><span class="line">     * 4、ServerResponse： 封装响应完整数据</span><br><span class="line">     */</span><br><span class="line">    @Bean//如果修饰在方法上，那么其方法的参数是从容器中获取的</span><br><span class="line">    public RouterFunction&lt;ServerResponse&gt; userRoute(UserBizHandler userBizHandler/*这个会被自动注入进来*/)&#123;</span><br><span class="line"></span><br><span class="line">        return RouterFunctions.route() //开始定义路由信息</span><br><span class="line">                .GET(&quot;/user/&#123;id&#125;&quot;, RequestPredicates.accept(MediaType.ALL), userBizHandler::getUser)</span><br><span class="line">                .GET(&quot;/users&quot;, userBizHandler::getUsers)</span><br><span class="line">                .POST(&quot;/user&quot;, RequestPredicates.accept(MediaType.APPLICATION_JSON), userBizHandler::saveUser)</span><br><span class="line">                .PUT(&quot;/user/&#123;id&#125;&quot;, RequestPredicates.accept(MediaType.APPLICATION_JSON), userBizHandler::updateUser)</span><br><span class="line">                .DELETE(&quot;/user/&#123;id&#125;&quot;, userBizHandler::deleteUser)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//    @Bean</span><br><span class="line">//    public RouterFunction&lt;ServerResponse&gt; groupRoute(UserBizHandler userBizHandler/*这个会被自动注入进来*/)&#123;</span><br><span class="line">//</span><br><span class="line">//        return RouterFunctions.route() //开始定义路由信息</span><br><span class="line">//                .GET(&quot;/user/&#123;id&#125;&quot;, RequestPredicates.accept(MediaType.ALL), userBizHandler::getUser)</span><br><span class="line">//                .GET(&quot;/users&quot;, userBizHandler::getUsers)</span><br><span class="line">//                .POST(&quot;/user&quot;, RequestPredicates.accept(MediaType.APPLICATION_JSON), userBizHandler::saveUser)</span><br><span class="line">//                .PUT(&quot;/user/&#123;id&#125;&quot;, RequestPredicates.accept(MediaType.APPLICATION_JSON), userBizHandler::updateUser)</span><br><span class="line">//                .DELETE(&quot;/user/&#123;id&#125;&quot;, userBizHandler::deleteUser)</span><br><span class="line">//                .build();</span><br><span class="line">//    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.web.biz;</span><br><span class="line"></span><br><span class="line">import com.atguigu.web.bean.Person;</span><br><span class="line">import jakarta.servlet.ServletException;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.web.servlet.function.ServerRequest;</span><br><span class="line">import org.springframework.web.servlet.function.ServerResponse;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author lfy</span><br><span class="line"> * @Description 专门处理User有关的业务</span><br><span class="line"> * @create 2023-04-18 21:55</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">@Service</span><br><span class="line">public class UserBizHandler &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询指定id的用户</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public ServerResponse getUser(ServerRequest request) throws Exception&#123;</span><br><span class="line">        String id = request.pathVariable(&quot;id&quot;);</span><br><span class="line">        log.info(&quot;查询 【&#123;&#125;】 用户信息，数据库正在检索&quot;,id);</span><br><span class="line">        //业务处理</span><br><span class="line">        Person person = new Person(1L,&quot;哈哈&quot;,&quot;aa@qq.com&quot;,18,&quot;admin&quot;);</span><br><span class="line">        //构造响应</span><br><span class="line">        return ServerResponse</span><br><span class="line">                .ok()</span><br><span class="line">                .body(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取所有用户</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public ServerResponse getUsers(ServerRequest request) throws Exception&#123;</span><br><span class="line">        log.info(&quot;查询所有用户信息完成&quot;);</span><br><span class="line">        //业务处理</span><br><span class="line">        List&lt;Person&gt; list = Arrays.asList(new Person(1L, &quot;哈哈&quot;, &quot;aa@qq.com&quot;, 18, &quot;admin&quot;),</span><br><span class="line">                new Person(2L, &quot;哈哈2&quot;, &quot;aa2@qq.com&quot;, 12, &quot;admin2&quot;));</span><br><span class="line"></span><br><span class="line">        //构造响应</span><br><span class="line">        return ServerResponse</span><br><span class="line">                .ok()</span><br><span class="line">                .body(list); //凡是body中的对象，就是以前@ResponseBody原理。利用HttpMessageConverter 写出为json</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 保存用户</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public ServerResponse saveUser(ServerRequest request) throws ServletException, IOException &#123;</span><br><span class="line">        //提取请求体</span><br><span class="line">        Person body = request.body(Person.class);</span><br><span class="line">        log.info(&quot;保存用户信息：&#123;&#125;&quot;,body);</span><br><span class="line">        return ServerResponse.ok().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 更新用户</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public ServerResponse updateUser(ServerRequest request) throws ServletException, IOException &#123;</span><br><span class="line">        Person body = request.body(Person.class);</span><br><span class="line">        log.info(&quot;保存用户信息更新: &#123;&#125;&quot;,body);</span><br><span class="line">        return ServerResponse.ok().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除用户</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public ServerResponse deleteUser(ServerRequest request) &#123;</span><br><span class="line">        String id = request.pathVariable(&quot;id&quot;);</span><br><span class="line">        log.info(&quot;删除【&#123;&#125;】用户信息&quot;,id);</span><br><span class="line">        return ServerResponse.ok().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1><strong>3、SpringBoot3-数据访问</strong></h1><p><strong>整合SSM场景SpringBoot 整合 Spring、SpringMVC、MyBatis 进行数据访问场景开发</strong><br>**创建SSM项目（在创建springboot的时候勾选要导入的包）：</p><p>**</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.0.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="2-配置数据源">2. 配置数据源</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://192.168.200.100:3306/demo</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br><span class="line">spring.datasource.type=com.zaxxer.hikari.HikariDataSource</span><br></pre></td></tr></table></figure><p>安装MyBatisX 插件，帮我们生成Mapper接口的xml文件即可。MyBatisX的使用：<br>选中接口名-&gt;点击右键-&gt;选择显示上下文操作-&gt;选择MybatisX的功能<br>或者选中接口名Altet+Enter<br>在接口下的方法使用Alter+Enter可以生成相应的sql语句 片段</p><h2 id="3-配置MyBatis">3. 配置MyBatis</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#指定mapper映射文件位置</span><br><span class="line">mybatis.mapper-locations=classpath:/mapper/*.xml</span><br><span class="line">#参数项调整，也就是可以把数据库表中的下划线命名的属性转换为驼峰命名</span><br><span class="line">mybatis.configuration.map-underscore-to-camel-case=true</span><br></pre></td></tr></table></figure><h2 id="4-CRUD编写"><strong>4. CRUD编写</strong></h2><p>CRUD 是一个常用的术语，用于描述对于持久化数据的基本操作。CRUD 是 Create（创建）、Read（读取）、Update（更新）和Delete（删除）的缩写。</p><ul><li><strong>编写Bean</strong></li><li><strong>编写Mapper</strong></li><li><strong>使用mybatisx插件，快速生成MapperXML</strong></li><li><strong>测试CRUD</strong></li></ul><p><strong>总结：</strong><br><strong>1.</strong>@Data//生成get和set方法<br><strong>2.controller类下的</strong><br>@Autowired//下面的提示的来源是因为这个时候，UserMapper中的接口没有注入到容器中，是springboot启动利用@MapperScan才将该接口注入到容器中的<br>UserMapper userMapper**;<strong>3.mapper接口中的</strong><em>每个方法都在Mapper文件中有一个sql标签对应。所有参数都应该用@Param进行签名，以后使用指定的名字在SQL中取值</em><br>4.mapper.xml文件中的<mapper>标签namespace属性也就是全类名接口的全类名和namespace的值是一一对应的<br>5.使用mybatis对数据库进行操作的时候，在spriongboot启动类的前要添加MapperScan(basePackages = “com.atguigu.boot3.ssm.mapper”)<br>_1、@MapperScan【批量扫描注解】； 告诉MyBatis，扫描哪个包下面的所有接口</p><ul><li><em>**</em>@MapperScan _**_是 MyBatis-Spring 框架提供的注解，用于扫描指定包下的 Mapper 接口，并将其注册为 Spring 的 Bean。</li><li>这样就可以在controller中使用自动注入</li><li>2、在配置文件中使用mybatis.mapper-locations，告诉MyBatis，每个接口的xml文件都在哪里_</li></ul><h2 id="5-自动配置原理"><strong>5. 自动配置原理</strong></h2><p><strong>SSM整合总结：</strong></p><ol><li><strong>导入 mybatis-spring-boot-starter</strong></li><li><strong>配置数据源信息</strong></li><li><strong>配置mybatis的mapper接口扫描与xml映射文件扫描</strong></li><li><strong>编写bean，mapper，生成xml，编写sql 进行crud。事务等操作依然和Spring中用法一样</strong></li><li><strong>效果：</strong><ol><li><strong>所有sql写在xml中</strong></li><li><strong>所有mybatis配置写在application.properties下面</strong></li></ol></li></ol><ul><li>jdbc场景的自动配置：<ul><li><strong>mybatis-spring-boot-starter导入 spring-boot-starter-jdbc，jdbc是操作数据库的场景</strong></li><li><strong>Jdbc场景的几个自动配置()</strong><ul><li><strong>org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</strong><ul><li><strong>数据源的自动配置</strong></li><li><strong>所有和数据源有关的配置都绑定在DataSourceProperties类中</strong></li><li><strong>默认使用 HikariDataSource。</strong></li></ul></li><li><strong>org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration</strong><ul><li><strong>给容器中放了JdbcTemplate操作数据库</strong></li></ul></li><li><strong>org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration</strong></li><li><strong>org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration</strong><ul><li><strong>基于XA二阶提交协议的分布式事务数据源</strong></li></ul></li><li><strong>org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration</strong><ul><li><strong>支持事务</strong></li></ul></li></ul></li><li><strong>具有的底层能力：数据源、JdbcTemplate、事务</strong></li></ul></li><li>MyBatisAutoConfiguration：配置了MyBatis的整合流程<ul><li>mybatis-spring-boot-starter导入 mybatis-spring-boot-autoconfigure（mybatis的自动配置包），</li><li>默认加载两个自动配置类：<ul><li>org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration</li><li>org.mybatis.spring.boot.autoconfigure.<strong>MybatisAutoConfiguration</strong><ul><li><strong>必须在数据源配置好之后才配置</strong></li><li>给容器中SqlSessionFactory组件。创建和数据库的一次会话</li><li>给容器中SqlSessionTemplate组件。操作数据库</li></ul></li></ul></li><li><strong>MyBatis的所有配置绑定在</strong>MybatisProperties</li><li>每个<strong>Mapper接口</strong>的<strong>代理对象</strong>是怎么创建放到容器中。详见**@MapperScan**原理：<ul><li>利用@Import(MapperScannerRegistrar.class)批量给容器中注册组件。解析指定的包路径里面的每一个类，为每一个Mapper接口类，创建Bean定义信息，注册到容器中。</li></ul></li></ul></li></ul><p>如何分析哪个场景导入以后，开启了哪些自动配置类。<br>找：classpath:/<strong>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</strong>文件中配置的所有值，就是要开启的自动配置类，但是每个类可能有条件注解，基于条件注解判断哪个自动配置类生效了。</p><h2 id="6-快速定位生效的配置">6. 快速定位生效的配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#开启调试模式，详细打印开启了哪些自动配置</span><br><span class="line">debug=true</span><br><span class="line"># Positive（生效的自动配置）  Negative（不生效的自动配置）</span><br></pre></td></tr></table></figure><h2 id="7-扩展：整合其他数据源">7. 扩展：整合其他数据源</h2><h3 id="1-Druid-数据源">1. Druid 数据源</h3><p>暂不支持 SpringBoot3</p><ul><li>导入druid-starter</li><li>写配置</li><li>分析自动配置了哪些东西，怎么用</li></ul><p>Druid官网：<a href="https://github.com/alibaba/druid">https://github.com/alibaba/druid</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#数据源基本配置</span><br><span class="line">spring.datasource.url=jdbc:mysql://192.168.200.100:3306/demo</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"></span><br><span class="line"># 配置StatFilter监控</span><br><span class="line">spring.datasource.druid.filter.stat.enabled=true</span><br><span class="line">spring.datasource.druid.filter.stat.db-type=mysql</span><br><span class="line">spring.datasource.druid.filter.stat.log-slow-sql=true</span><br><span class="line">spring.datasource.druid.filter.stat.slow-sql-millis=2000</span><br><span class="line"># 配置WallFilter防火墙</span><br><span class="line">spring.datasource.druid.filter.wall.enabled=true</span><br><span class="line">spring.datasource.druid.filter.wall.db-type=mysql</span><br><span class="line">spring.datasource.druid.filter.wall.config.delete-allow=false</span><br><span class="line">spring.datasource.druid.filter.wall.config.drop-table-allow=false</span><br><span class="line"># 配置监控页，内置监控页面的首页是 /druid/index.html</span><br><span class="line">spring.datasource.druid.stat-view-servlet.enabled=true</span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-username=admin</span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-password=admin</span><br><span class="line">spring.datasource.druid.stat-view-servlet.allow=*</span><br><span class="line"></span><br><span class="line"># 其他 Filter 配置不再演示</span><br><span class="line"># 目前为以下 Filter 提供了配置支持，请参考文档或者根据IDE提示（spring.datasource.druid.filter.*）进行配置。</span><br><span class="line"># StatFilter</span><br><span class="line"># WallFilter</span><br><span class="line"># ConfigFilter</span><br><span class="line"># EncodingConvertFilter</span><br><span class="line"># Slf4jLogFilter</span><br><span class="line"># Log4jFilter</span><br><span class="line"># Log4j2Filter</span><br><span class="line"># CommonsLogFilter</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="附录：示例数据库-要先自己创建test数据库）"><strong>附录：示例数据库(要先自己创建test数据库）</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t_user`</span><br><span class="line">(</span><br><span class="line">    `id`         BIGINT(20)   NOT NULL AUTO_INCREMENT COMMENT &#x27;编号&#x27;,</span><br><span class="line">    `login_name` VARCHAR(200) NULL DEFAULT NULL COMMENT &#x27;用户名称&#x27; COLLATE &#x27;utf8_general_ci&#x27;,</span><br><span class="line">    `nick_name`  VARCHAR(200) NULL DEFAULT NULL COMMENT &#x27;用户昵称&#x27; COLLATE &#x27;utf8_general_ci&#x27;,</span><br><span class="line">    `passwd`     VARCHAR(200) NULL DEFAULT NULL COMMENT &#x27;用户密码&#x27; COLLATE &#x27;utf8_general_ci&#x27;,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">);</span><br><span class="line">insert into t_user(login_name, nick_name, passwd) VALUES (&#x27;zhangsan&#x27;,&#x27;张三&#x27;,&#x27;123456&#x27;);</span><br></pre></td></tr></table></figure><h1><strong>4、SpringBoot3-基础特性</strong></h1><ol><li>SpringApplication1.1. 自定义 banner类路径添加banner.txt或设置spring.banner.location就可以定制<br>这里是在配置文件中设置spring.banner.location=classpath:banner.txt然后在banner.txt文件中填充即可。<br>banner.txt中可以存放Ascll类型的文本，当然图片生成的Ascall类型的也是可以的<br>banner推荐网站：<a href="https://www.bootschool.net/ascii"><strong>Spring Boot banner 在线生成工具，制作下载英文 banner.txt，修改替换 banner.txt 文字实现自定义，个性化启动 banner-bootschool.net</strong></a><br>**Spring Boot 中有一个名为 “Banner” 的功能，它用于在应用程序启动时显示自定义的启动横幅。横幅是一个包含 ASCII 艺术、应用程序名称和版本号等信息的文本，它可以用于个性化应用程序的启动过程。<br>上面的横幅就是启动成功的这个：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1691459425977-b78e1673-8a61-41ae-b1b0-d487510bd937.png#averageHue=%23383532&amp;clientId=u8fdb1034-8532-4&amp;from=paste&amp;height=173&amp;id=u65bf48e5&amp;originHeight=216&amp;originWidth=752&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=13871&amp;status=done&amp;style=none&amp;taskId=u3dae8db9-32d1-451c-8898-afe829c3c40&amp;title=&amp;width=601.6" alt="image.png"></li></ol><h2 id="1-2-自定义-SpringApplication">1.2. 自定义 SpringApplication</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.boot.Banner;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class MyApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication application = new SpringApplication(MyApplication.class);</span><br><span class="line">        application.setBannerMode(Banner.Mode.OFF);</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-FluentBuilder-API">1.3. FluentBuilder API</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new SpringApplicationBuilder()</span><br><span class="line">    .sources(Parent.class)</span><br><span class="line">    .child(Application.class)</span><br><span class="line">    .bannerMode(Banner.Mode.OFF)</span><br><span class="line">    .run(args);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication //主程序类</span><br><span class="line">public class  Boot306FeaturesApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //1、SpringApplication: Boot应用的核心API入口</span><br><span class="line">//        SpringApplication.run(Boot306FeaturesApplication.class, args);</span><br><span class="line">//        args是springboot应用启动的核心参数</span><br><span class="line"></span><br><span class="line">        //===============1、自定义 SpringApplication 的底层设置，也就是把SpringApplication.run(Boot306FeaturesApplication.class, args);</span><br><span class="line">//        分开，生成SpringApplication类,然后根据SpringApplication类来自定义启动的相关设置</span><br><span class="line">//        SpringApplication application = new SpringApplication(Boot306FeaturesApplication.class);</span><br><span class="line">//</span><br><span class="line">//        //程序化调整【SpringApplication的参数】</span><br><span class="line">////        application.setDefaultProperties();</span><br><span class="line">//        //这个配置不优先，作用是将banner的打印关闭。如果配置文件有类似的配置，配置文件优先</span><br><span class="line">//        application.setBannerMode(Banner.Mode.OFF);</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">//        //【配置文件优先级高于程序化调整的优先级】</span><br><span class="line">//</span><br><span class="line">//        //2、SpringApplication 运行起来</span><br><span class="line">//        application.run(args);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //================2、Builder方式构建 SpringApplication； 通过FluentAPI进行设置</span><br><span class="line">        ConfigurableApplicationContext context = new SpringApplicationBuilder()</span><br><span class="line">                .main(Boot306FeaturesApplication.class) //各种参数均可设置</span><br><span class="line">                .sources(Boot306FeaturesApplication.class)</span><br><span class="line">                .bannerMode(Banner.Mode.CONSOLE)</span><br><span class="line">                .properties(&quot;server.port=8888&quot;,&quot;aaa=bbb&quot;) //springboot所有配置项都可以在这里定义</span><br><span class="line">//                .environment(null)</span><br><span class="line">//                .listeners(null)</span><br><span class="line">                .run(args);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Cat cat = context.getBean(Cat.class);</span><br><span class="line">            log.info(&quot;组件cat：&#123;&#125;&quot;,cat);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Dog dog = context.getBean(Dog.class);</span><br><span class="line">            log.info(&quot;组件dog：&#123;&#125;&quot;,dog);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Pig pig = context.getBean(Pig.class);</span><br><span class="line">            log.info(&quot;组件pig：&#123;&#125;&quot;,pig);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Sheep sheep = context.getBean(Sheep.class);</span><br><span class="line">            log.info(&quot;组件sheep：&#123;&#125;&quot;,sheep);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#指定banner文本的路径</span><br><span class="line">spring.banner.location=classpath:banner.txt</span><br><span class="line">#关闭banner模式</span><br><span class="line">spring.main.banner-mode=off</span><br></pre></td></tr></table></figure><h1>2. Profiles</h1><p>环境隔离能力；快速切换开发、测试、生产环境(最好的例子就是在开发，测试，生产所需要的数据库不一样，这个时候就需要自动切换数据库）<br>步骤：</p><ol><li><strong>标识环境</strong>：指定哪些组件、配置在哪个环境生效</li><li><strong>切换环境</strong>：这个环境对应的所有组件和配置就应该生效</li></ol><h2 id="2-1-使用">2.1. 使用</h2><h3 id="2-1-1-指定环境"><strong>2.1.1 指定环境</strong></h3><ul><li>Spring Profiles 提供一种<strong>隔离配置</strong>的方式，使其仅在<strong>特定环境</strong>生效；</li><li>任何@Component, @Configuration 或 @ConfigurationProperties 可以使用 @Profile 标记，来指定何时被加载。【<strong>容器中的组件</strong>都可以被 @Profile标记】</li></ul><h3 id="2-1-2-环境激活（也就是指定当前系统运行的特定环境）"><strong>2.1.2 环境激活（也就是指定当前系统运行的特定环境）</strong></h3><ol><li>配置激活指定环境； 配置文件</li></ol><p>spring.profiles.active=production,hsqldb</p><ol><li>也可以使用命令行激活。–spring.profiles.active=dev,hsqldb</li><li>还可以配置<strong>默认环境</strong>； 不标注@Profile 的组件永远都存在。<ol><li>以前默认环境叫default</li><li>spring.profiles.default=test修改默认环境是test，变形激活了test环境</li></ol></li><li>推荐使用激活方式激活指定环境</li></ol><h3 id="2-1-3-环境包含"><strong>2.1.3 环境包含</strong></h3><p>注意：</p><ol><li>spring.profiles.active 和spring.profiles.default 只能用到** 无 profile 的文件<strong>中，如果在application-dev.yaml中编写就是</strong>无效的**</li><li>也可以额外添加生效文件，而不是激活替换。比如：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.include[0]=common</span><br><span class="line">spring.profiles.include[1]=local</span><br></pre></td></tr></table></figure><p>最佳实战：</p><ul><li>**生效的环境 **= <strong>激活的环境/默认环境</strong> + <strong>包含的环境</strong></li><li>项目里面这么用<ul><li>基础的配置mybatis、log、xxx：写到<strong>包含环境中</strong></li><li>需要动态切换变化的 db、redis：写到<strong>激活的环境中</strong></li></ul></li></ul><h2 id="2-2-Profile-分组">2.2. Profile 分组</h2><p>创建prod组，指定包含db和mq配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.group.prod[0]=db</span><br><span class="line">spring.profiles.group.prod[1]=mq</span><br></pre></td></tr></table></figure><p>使用–spring.profiles.active=prod ，就会激活prod，db，mq配置文件</p><h2 id="2-3-Profile-配置文件">2.3. Profile 配置文件</h2><ul><li>application-{profile}.properties可以作为<strong>指定环境的配置文件</strong>。</li><li>激活这个环境，<strong>配置</strong>就会生效。最终生效的所有<strong>配置</strong>是<ul><li>application.properties：主配置文件，任意时候都生效</li><li>application-{profile}.properties：指定环境配置文件，激活指定环境生效</li></ul></li></ul><p>profile优先级 &gt; application</p><h1>3. 外部化配置</h1><p><strong>场景</strong>：线上应用如何<strong>快速修改配置</strong>，并应<strong>用最新配置</strong>？</p><ul><li>SpringBoot 使用 <strong>配置优先级</strong> + <strong>外部配置</strong> 简化配置更新、简化运维。</li><li>只需要给jar应用所在的文件夹放一个application.properties最新配置文件，重启项目就能自动应用最新配置</li></ul><h2 id="3-1-配置优先级">3.1. 配置优先级</h2><p>Spring Boot 允许将<strong>配置外部化</strong>，以便可以在不同的环境中使用相同的应用程序代码。<br>我们可以使用各种<strong>外部配置源</strong>，包括Java Properties文件、YAML文件、环境变量和命令行参数。<br>@Value可以获取值，也可以用@ConfigurationProperties将所有属性绑定到java object中<br><strong>以下是 SpringBoot 属性源加载顺序。后面的会覆盖前面的值</strong>。由低到高，高优先级配置覆盖低优先级</p><ol><li><strong>默认属性</strong>（通过SpringApplication.setDefaultProperties指定的）</li><li>@PropertySource指定加载的配置（需要写在@Configuration类上才可生效）,其中指定加载 类的文件一般是配置文件</li><li><strong>配置文件（application.properties/yml等）</strong></li><li>RandomValuePropertySource支持的random.*配置（如：@Value(“${random.int}”)）</li><li>OS 环境变量</li><li>Java 系统属性（System.getProperties()）</li><li>JNDI 属性（来自java:comp/env）</li><li>ServletContext初始化参数</li><li>ServletConfig初始化参数</li><li>SPRING_APPLICATION_JSON属性（内置在环境变量或系统属性中的 JSON）</li><li><strong>命令行参数</strong></li><li>测试属性。(@SpringBootTest进行测试时指定的属性)</li><li>测试类@TestPropertySource注解</li><li>Devtools 设置的全局属性。($HOME/.config/spring-boot)</li></ol><p>结论：配置可以写到很多位置，常见的优先级顺序：</p><ul><li>命令行&gt; 配置文件&gt; springapplication配置（可以这样理解程序运行的时候，先运行springboot启动程序的默认配置，然后读取配置文件，然后是命令行运行。相当于后面的配置信息会覆盖前面的，可以这样理解但是实际上并非是这样的）</li></ul><p><strong>配置文件优先级</strong>如下：(<strong>后面覆盖前面</strong>)</p><ol><li><strong>jar 包内</strong>的application.properties/yml</li><li><strong>jar 包内</strong>的application-{profile}.properties/yml</li><li><strong>jar 包外</strong>的application.properties/yml</li><li><strong>jar 包外</strong>的application-{profile}.properties/yml</li></ol><p><strong>建议</strong>：<strong>用一种格式的配置文件</strong>。<strong>如果.properties和.yml同时存在,则.properties优先</strong><br>结论：包外 &gt; 包内； 同级情况：profile配置 &gt; application配置<br><strong>所有参数均可由命令行传入，使用–参数项=参数值，将会被添加到环境变量中，并优先于配置文件。</strong><br><strong>比如java -jar app.jar --name=“Spring”,可以使用@Value(“${name}”)获取</strong></p><p>演示场景：</p><ul><li>包内： application.properties server.port=8000</li><li>包内： application-dev.properties server.port=9000</li><li>包外：  application.properties server.port=8001</li><li>包外： application-dev.properties server.port=9001</li></ul><p>启动端口？：命令行 &gt; 9001 &gt; 8001 &gt; 9000 &gt; 8000</p><h2 id="3-2-外部配置">3.2. 外部配置</h2><p>SpringBoot 应用启动时会自动寻找application.properties和application.yaml位置，进行加载。顺序如下：（<strong>后面覆盖前面</strong>）</p><ol><li>类路径: 内部<ol><li>类根路径</li><li>类下/config包</li></ol></li><li>当前路径（项目所在的位置）<ol><li>当前路径</li><li>当前下/config子目录</li><li>/config目录的直接子目录</li></ol></li></ol><p>最终效果：优先级由高到低，前面覆盖后面</p><ul><li>命令行 &gt; 包外config直接子目录 &gt; 包外config目录 &gt; 包外根目录 &gt; 包内目录</li><li>同级比较：<ul><li>profile配置 &gt; 默认配置</li><li>properties配置 &gt; yaml配置</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/svg/28066124/1691418639180-bac5ede2-c3e2-4a60-bf81-b015e53ea599.svg#clientId=u8fdb1034-8532-4&amp;from=paste&amp;height=535&amp;id=u4b284044&amp;originHeight=669&amp;originWidth=694&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=91719&amp;status=done&amp;style=none&amp;taskId=ue9940951-a38d-4801-9025-9879191c5cd&amp;title=&amp;width=555.2" alt="未命名绘图.svg"><br>**规律：最外层的最优先。</p><ul><li><strong>命令行 &gt; 所有</strong></li><li><strong>包外 &gt; 包内</strong></li><li><strong>config目录 &gt; 根目录</strong></li><li>**profile &gt; application **</li></ul><p><strong>配置不同就都生效（互补），配置相同高优先级覆盖低优先级</strong></p><h2 id="3-3-导入配置">3.3. 导入配置</h2><p>使用spring.config.import可以导入额外配置：<br>导入配置的优先级低于配置文件的优先级。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.config.import=my.properties</span><br><span class="line">my.property=value</span><br></pre></td></tr></table></figure><p>无论以上写法的先后顺序，my.properties的值总是优先于直接在文件中编写的my.property。</p><h2 id="3-4-属性占位符">3.4. 属性占位符</h2><p>配置文件中可以使用 ${name:default}形式取出之前配置过的值，${name:default}这里的意思是配置文件中有name值，就采用该值，没有的换就让name的值为default的值。@Value可以获取配置文件中的值，@Value(${name：hahha}) String name表示如果配置文件没有name的配置那么name的值为haha,如果有name的值就是配置文件中的值，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Value注解是Spring框架提供的一种方式，可以从外部的配置文件、系统属性或表达式中获取值，</span><br><span class="line">并赋给Bean中的字段或参数。@Value注解的参数是一个字符串，可以是一个普通的字符串，也可以是一个占</span><br><span class="line">位符或表达式，用$ &#123;&#125;或# &#123;&#125;包围。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.name=MyApp</span><br><span class="line">app.description=$&#123;app.name&#125; is a Spring Boot application written by $&#123;username:Unknown&#125;</span><br></pre></td></tr></table></figure><h1><strong>4. 单元测试-JUnit5</strong></h1><h2 id="4-1-整合">4.1. 整合</h2><p>SpringBoot 提供一系列测试工具集及注解方便我们进行测试。<br>spring-boot-test提供核心测试能力，spring-boot-test-autoconfigure提供测试的一些自动配置。<br>我们只需要导入spring-boot-starter-test即可整合测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>spring-boot-starter-test默认提供了以下库供我们测试使用</p><ul><li><a href="https://junit.org/junit5/"><strong>JUnit 5</strong></a></li><li><a href="https://docs.spring.io/spring-framework/docs/6.0.4/reference/html/testing.html#integration-testing"><strong>Spring Test</strong></a></li><li><a href="https://assertj.github.io/doc/"><strong>AssertJ</strong></a></li><li><a href="https://github.com/hamcrest/JavaHamcrest"><strong>Hamcrest</strong></a></li><li><a href="https://site.mockito.org/"><strong>Mockito</strong></a></li><li><a href="https://github.com/skyscreamer/JSONassert"><strong>JSONassert</strong></a></li><li><a href="https://github.com/jayway/JsonPath"><strong>JsonPath</strong></a></li></ul><h2 id="4-2-测试"><strong>4.2. 测试</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.@SpringBootTest //具备测试SpringBoot应用容器中所有组件的功能,测试的时候会启动spingboot</span><br><span class="line"></span><br><span class="line">//测试类也必须在主程序所在的包及其子包;这里的主程序是springbootApplication修饰的类，之所以</span><br><span class="line">测试类必须在主程序所在的包及其子包的原因是：SpringBoot的默认扫描规则，只扫描自己主程序所在的包以</span><br><span class="line">及子包，这样测试类的注解才能被扫描到。</span><br></pre></td></tr></table></figure><h3 id="4-2-0-组件测试"><strong>4.2.0 组件测试</strong></h3><p><strong>直接@Autowired容器中的组件进行测试</strong><br>JUnit5的注解与JUnit4的注解有所变化<br><a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations"><strong>https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations</strong></a><br>@DisplayName(“测试1”)//自定义测试名字<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1691632824115-17aa44c2-d941-4cf4-9275-e179fff05255.png#averageHue=%23c19757&amp;clientId=u6136e5eb-a4ad-4&amp;from=paste&amp;height=159&amp;id=u91faa989&amp;originHeight=199&amp;originWidth=746&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=52561&amp;status=done&amp;style=none&amp;taskId=ue972d580-cb68-4f6e-babc-29509d58909&amp;title=&amp;width=596.8" alt="image.png"></p><h3 id="4-2-1-注解"><strong>4.2.1 注解</strong></h3><ul><li>**@Test :**表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试</li><li>**@ParameterizedTest :**表示方法是参数化测试，下方会有详细介绍</li><li>**@RepeatedTest :**表示方法可重复执行，下方会有详细介绍</li><li>**@DisplayName :**为测试类或者测试方法设置展示名称</li><li>**@BeforeEach :**表示在每个单元测试之前执行</li><li>**@AfterEach :**表示在每个单元测试之后执行</li><li>**@BeforeAll :**表示在所有单元测试之前执行</li><li>**@AfterAll :**表示在所有单元测试之后执行</li><li>**@Tag :**表示单元测试类别，类似于JUnit4中的@Categories</li><li>**@Disabled :**表示测试类或测试方法不执行，类似于JUnit4中的@Ignore</li><li>**@Timeout :**表示测试方法运行如果超过了指定时间将会返回错误</li><li>**@ExtendWith :**为测试类或测试方法提供扩展类引用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import static org.junit.jupiter.api.Assertions.fail;</span><br><span class="line">import static org.junit.jupiter.api.Assumptions.assumeTrue;</span><br><span class="line"></span><br><span class="line">import org.junit.jupiter.api.AfterAll;</span><br><span class="line">import org.junit.jupiter.api.AfterEach;</span><br><span class="line">import org.junit.jupiter.api.BeforeAll;</span><br><span class="line">import org.junit.jupiter.api.BeforeEach;</span><br><span class="line">import org.junit.jupiter.api.Disabled;</span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line">class StandardTests &#123;</span><br><span class="line"></span><br><span class="line">    @BeforeAll</span><br><span class="line">    static void initAll() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @BeforeEach</span><br><span class="line">    void init() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DisplayName(&quot;😱&quot;)</span><br><span class="line">    @Test</span><br><span class="line">    void succeedingTest() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void failingTest() &#123;</span><br><span class="line">        fail(&quot;a failing test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    @Disabled(&quot;for demonstration purposes&quot;)</span><br><span class="line">    void skippedTest() &#123;</span><br><span class="line">        // not executed</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void abortedTest() &#123;</span><br><span class="line">        assumeTrue(&quot;abc&quot;.contains(&quot;Z&quot;));</span><br><span class="line">        fail(&quot;test should have been aborted&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterEach</span><br><span class="line">    void tearDown() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterAll</span><br><span class="line">    static void tearDownAll() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-断言"><strong>4.2.2 断言</strong></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1691418910556-4050b5e8-46b0-4d5c-890a-2432fdb1491c.png#averageHue=%23fbfaf9&amp;clientId=u8fdb1034-8532-4&amp;from=paste&amp;height=526&amp;id=ue8811d01&amp;originHeight=658&amp;originWidth=938&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=51295&amp;status=done&amp;style=none&amp;taskId=u8fbc1a6a-e039-4e45-87a7-d19b86d95c6&amp;title=&amp;width=750.4" alt="image.png"></p><h3 id="4-2-3-嵌套测试"><strong>4.2.3 嵌套测试</strong></h3><p>JUnit 5 可以通过 Java 中的内部类和@Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用@BeforeEach 和@AfterEach 注解，而且嵌套的层次没有限制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">@DisplayName(&quot;A stack&quot;)</span><br><span class="line">class TestingAStackDemo &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Object&gt; stack;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    @DisplayName(&quot;is instantiated with new Stack()&quot;)</span><br><span class="line">    void isInstantiatedWithNew() &#123;</span><br><span class="line">        new Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nested</span><br><span class="line">    @DisplayName(&quot;when new&quot;)</span><br><span class="line">    class WhenNew &#123;</span><br><span class="line"></span><br><span class="line">        @BeforeEach</span><br><span class="line">        void createNewStack() &#123;</span><br><span class="line">            stack = new Stack&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Test</span><br><span class="line">        @DisplayName(&quot;is empty&quot;)</span><br><span class="line">        void isEmpty() &#123;</span><br><span class="line">            assertTrue(stack.isEmpty());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Test</span><br><span class="line">        @DisplayName(&quot;throws EmptyStackException when popped&quot;)</span><br><span class="line">        void throwsExceptionWhenPopped() &#123;</span><br><span class="line">            assertThrows(EmptyStackException.class, stack::pop);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Test</span><br><span class="line">        @DisplayName(&quot;throws EmptyStackException when peeked&quot;)</span><br><span class="line">        void throwsExceptionWhenPeeked() &#123;</span><br><span class="line">            assertThrows(EmptyStackException.class, stack::peek);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Nested</span><br><span class="line">        @DisplayName(&quot;after pushing an element&quot;)</span><br><span class="line">        class AfterPushing &#123;</span><br><span class="line"></span><br><span class="line">            String anElement = &quot;an element&quot;;</span><br><span class="line"></span><br><span class="line">            @BeforeEach</span><br><span class="line">            void pushAnElement() &#123;</span><br><span class="line">                stack.push(anElement);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Test</span><br><span class="line">            @DisplayName(&quot;it is no longer empty&quot;)</span><br><span class="line">            void isNotEmpty() &#123;</span><br><span class="line">                assertFalse(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Test</span><br><span class="line">            @DisplayName(&quot;returns the element when popped and is empty&quot;)</span><br><span class="line">            void returnElementWhenPopped() &#123;</span><br><span class="line">                assertEquals(anElement, stack.pop());</span><br><span class="line">                assertTrue(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Test</span><br><span class="line">            @DisplayName(&quot;returns the element when peeked but remains not empty&quot;)</span><br><span class="line">            void returnElementWhenPeeked() &#123;</span><br><span class="line">                assertEquals(anElement, stack.peek());</span><br><span class="line">                assertFalse(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-4-参数化测试"><strong>4.2.4 参数化测试</strong></h3><p>参数化测试是JUnit5很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。<br>**</p><p>利用**@ValueSource**等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。<br><strong>@ValueSource</strong>: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型<br><strong>@NullSource</strong>: 表示为参数化测试提供一个null的入参<br><strong>@EnumSource</strong>: 表示为参数化测试提供一个枚举入参<br><strong>@CsvFileSource</strong>：表示读取指定CSV文件内容作为参数化测试入参<br><strong>@MethodSource</strong>：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@ParameterizedTest</span><br><span class="line">@ValueSource(strings = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;)</span><br><span class="line">@DisplayName(&quot;参数化测试1&quot;)</span><br><span class="line">public void parameterizedTest1(String string) &#123;</span><br><span class="line">    System.out.println(string);</span><br><span class="line">    Assertions.assertTrue(StringUtils.isNotBlank(string));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@ParameterizedTest</span><br><span class="line">@MethodSource(&quot;method&quot;)    //指定方法名</span><br><span class="line">@DisplayName(&quot;方法来源参数&quot;)</span><br><span class="line">public void testWithExplicitLocalMethodSource(String name) &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    Assertions.assertNotNull(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static Stream&lt;String&gt; method() &#123;</span><br><span class="line">    return Stream.of(&quot;apple&quot;, &quot;banana&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><strong>5、SpringBoot3-核心原理</strong></h1><h2 id="1-事件和监听器">1. 事件和监听器</h2><p><strong>1. 生命周期监听场景：监听应用的</strong>生命周期<br><strong>1. 监听器-SpringApplicationRunListener</strong><br>自定义SpringApplicationRunListener来监听事件；编写SpringApplicationRunListener实现类在 META-INF/spring.factories 中配置 org.springframework.boot.SpringApplicationRunListener=自己的Listener，还可以指定一个有参构造器，接受两个参数(SpringApplication application, String[] args)springboot 在spring-boot.jar中配置了默认的 Listener，如下<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681829576654-d5e4b889-6fcf-4e65-91f1-8de8c78e98f1.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_23%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f3c9ac&amp;from=url&amp;id=kfTpf&amp;originHeight=61&amp;originWidth=792&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="">**</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Listener先要从 META-INF/spring.factories 读到</span><br><span class="line"> *</span><br><span class="line"> * 1、引导： 利用 BootstrapContext 引导整个项目启动</span><br><span class="line"> *      starting：              应用开始，SpringApplication的run方法一调用，只要有了 BootstrapContext 就执行</span><br><span class="line"> *      environmentPrepared：   环境准备好（把启动参数等绑定到环境变量中），但是ioc还没有创建；【调一次】</span><br><span class="line"> * 2、启动：</span><br><span class="line"> *      contextPrepared：       ioc容器创建并准备好，但是sources（主配置类）没加载。并关闭引导上下文；组件都没创建  【调一次】</span><br><span class="line"> *      contextLoaded：         ioc容器加载。主配置类加载进去了。但是ioc容器还没刷新（我们的bean没创建）。</span><br><span class="line"> *      =======截止以前，ioc容器里面还没造bean呢=======</span><br><span class="line"> *      started：               ioc容器刷新了（所有bean造好了），但是 runner 没调用。</span><br><span class="line"> *      ready:                  ioc容器刷新了（所有bean造好了），所有 runner 调用完了。</span><br><span class="line"> * 3、运行</span><br><span class="line"> *     以前步骤都正确执行，代表容器running。</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h3 id="2-生命周期全流程">2. 生命周期全流程</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1682322663331-25a89875-7ce3-40ae-9be7-9ea752fbab20.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_31%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23a7bd8b&amp;from=url&amp;id=Uwox4&amp;originHeight=758&amp;originWidth=1102&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在Spring Boot中，Runner是一个接口，用于在Spring应用程序启动完成后执行一些特定的任务。</span><br><span class="line">它是Spring Boot提供的一种扩展机制，允许开发人员在应用程序启动后立即执行一些代码逻辑。</span><br><span class="line">开发人员可以通过实现Runner接口并注入到Spring应用程序中，从而在应用程序启动后执行自定义的任务。</span><br><span class="line">runner是springboot底层用来感知生命周期特定阶段的一个回调。</span><br><span class="line">不同于SpringApplicationRunListener,这个是用来感知全生命周期的</span><br></pre></td></tr></table></figure><h2 id="2-事件触发时机">2. 事件触发时机</h2><h3 id="1-各种回调监听器">1. 各种回调监听器</h3><ul><li>BootstrapRegistryInitializer： ** 感知特定阶段：<strong>感知</strong>引导初始化**<ul><li>META-INF/spring.factories</li><li>创建引导上下文bootstrapContext的时候触发。</li><li>application.addBootstrapRegistryInitializer();</li><li>场景：进行密钥校对授权。</li></ul></li><li>ApplicationContextInitializer： ** 感知特定阶段：** 感知ioc容器初始化<ul><li>META-INF/spring.factories</li><li>application.addInitializers();</li></ul></li><li><strong>ApplicationListener： 感知全阶段：基于事件机制，感知事件。 一旦到了哪个阶段可以做别的事</strong><ul><li>@Bean或@EventListener： 事件驱动</li><li>SpringApplication.addListeners(…)或 SpringApplicationBuilder.listeners(…)</li><li>META-INF/spring.factories</li></ul></li><li><strong>SpringApplicationRunListener： 感知全阶段生命周期 + 各种阶段都能自定义操作； 功能更完善。</strong><ul><li>META-INF/spring.factories</li></ul></li><li><strong>ApplicationRunner: 感知特定阶段：感知应用就绪Ready。卡死应用，就不会就绪</strong><ul><li>@Bean</li></ul></li><li><strong>CommandLineRunner： 感知特定阶段：感知应用就绪Ready。卡死应用，就不会就绪</strong><ul><li>@Bean</li></ul></li></ul><p>最佳实战：</p><ul><li>如果项目启动前做事： BootstrapRegistryInitializer 和 ApplicationContextInitializer</li><li>如果想要在项目启动完成后做事：<strong>ApplicationRunner和 CommandLineRunner</strong></li><li><strong>如果要干涉生命周期做事：SpringApplicationRunListener</strong></li><li><strong>如果想要用事件机制：ApplicationListener</strong></li><li><strong>上面的都是接口，可以通过实现接口，然后在</strong>META-INF/spring.factories配置文件中填充实现上述接口的类，就可以实现在生命周期的特定阶段完成某项任务！</li></ul><h3 id="2-完整触发流程"><strong>2. 完整触发流程</strong></h3><p><strong>9大事件</strong>触发顺序&amp;时机</p><ol><li>ApplicationStartingEvent：应用启动但未做任何事情, 除过注册listeners and initializers.</li><li>ApplicationEnvironmentPreparedEvent： Environment 准备好，但context 未创建.</li><li>ApplicationContextInitializedEvent: ApplicationContext 准备好，ApplicationContextInitializers 调用，但是任何bean未加载</li><li>ApplicationPreparedEvent： 容器刷新之前，bean定义信息加载</li><li>ApplicationStartedEvent： 容器刷新完成， runner未调用</li></ol><p>=========以下就开始插入了<strong>探针机制</strong>============</p><ol><li>AvailabilityChangeEvent： LivenessState.CORRECT应用存活； <strong>存活探针</strong></li><li>ApplicationReadyEvent: 任何runner被调用</li><li>AvailabilityChangeEvent：ReadinessState.ACCEPTING_TRAFFIC<strong>就绪探针</strong>，可以接请求</li><li>ApplicationFailedEvent：启动出错</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1691887909080-a687294a-131b-4da8-9822-18298ade2f39.png#averageHue=%23c4d581&amp;clientId=uac0c1727-261a-4&amp;from=paste&amp;height=610&amp;id=ue472925a&amp;originHeight=762&amp;originWidth=1129&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=133115&amp;status=done&amp;style=none&amp;taskId=ue11d8088-eb18-4a04-ae32-ed763f0e0a8&amp;title=&amp;width=903.2" alt="image.png"><strong>应用事件发送顺序如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1691887919553-7c5e83d8-0a5c-4cae-bfca-bd50272bbb36.png#averageHue=%23f5eee4&amp;clientId=uac0c1727-261a-4&amp;from=paste&amp;height=157&amp;id=ufc92ec7f&amp;originHeight=196&amp;originWidth=937&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=100464&amp;status=done&amp;style=none&amp;taskId=ua7f8bbd0-7822-4907-8c9a-bd01dc2227b&amp;title=&amp;width=749.6" alt="image.png"><br>感知应用是否存活了：可能植物状态，虽然活着但是不能处理请求。<br>应用是否</strong>就绪**了：能响应请求，说明确实活的比较好。</p><h3 id="3-SpringBoot-事件驱动开发">3. SpringBoot 事件驱动开发</h3><p><strong>应用启动过程生命周期事件感知（9大事件）</strong>、<strong>应用运行中事件感知（无数种）</strong>。</p><ul><li><strong>事件发布</strong>：ApplicationEventPublisherAware或注入：ApplicationEventMulticaster</li><li><strong>事件监听</strong>：组件 + @EventListener</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1682327167479-8f634931-f8ca-48fb-9566-c914f1795ff2.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_33%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23f2eeec&amp;from=url&amp;id=b4csj&amp;originHeight=387&amp;originWidth=1153&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1682341921101-aa095a84-00cc-4815-b675-f4ed81cecf3b.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_22%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23fdfcfc&amp;from=url&amp;id=dk2IM&amp;originHeight=489&amp;originWidth=780&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br><strong>事件发布者</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class EventPublisher implements ApplicationEventPublisherAware &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 底层发送事件用的组件，SpringBoot会通过ApplicationEventPublisherAware接口自动注入给我们</span><br><span class="line">     * 事件是广播出去的。所有监听这个事件的监听器都可以收到</span><br><span class="line">     */</span><br><span class="line">    ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 所有事件都可以发</span><br><span class="line">     * @param event</span><br><span class="line">     */</span><br><span class="line">    public void sendEvent(ApplicationEvent event) &#123;</span><br><span class="line">        //调用底层API发送事件</span><br><span class="line">        applicationEventPublisher.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 会被自动调用，把真正发事件的底层组组件给我们注入进来</span><br><span class="line">     * @param applicationEventPublisher event publisher to be used by this object</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) &#123;</span><br><span class="line">        this.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>事件订阅者</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class CouponService &#123;</span><br><span class="line"></span><br><span class="line">    @Order(1)</span><br><span class="line">    @EventListener</span><br><span class="line">    public void onEvent(LoginSuccessEvent loginSuccessEvent)&#123;</span><br><span class="line">        System.out.println(&quot;===== CouponService ====感知到事件&quot;+loginSuccessEvent);</span><br><span class="line">        UserEntity source = (UserEntity) loginSuccessEvent.getSource();</span><br><span class="line">        sendCoupon(source.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sendCoupon(String username)&#123;</span><br><span class="line">        System.out.println(username + &quot; 随机得到了一张优惠券&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>**2. **自动配置原理</h1><h2 id="1-入门理解"><strong>1. 入门理解</strong></h2><p><strong>应用关注的三大核心：场景、配置、组件</strong></p><h3 id="1-自动配置流程"><strong>1. 自动配置流程</strong></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681829645812-0f0cad01-66d4-42fc-8111-091e33a062c6.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_32%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#averageHue=%23cfe1c6&amp;from=url&amp;id=B0IdI&amp;originHeight=602&amp;originWidth=1113&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="">**</p><ol><li><strong>导入starter</strong></li><li><strong>依赖导入autoconfigure</strong></li><li><strong>寻找类路径下 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件</strong></li><li><strong>启动，加载所有 自动配置类xxxAutoConfiguration</strong><ol><li><strong>给容器中配置功能组件</strong></li><li><strong>组件参数绑定到 属性类中。xxxProperties</strong></li><li><strong>属性类和配置文件前缀项绑定</strong></li><li><strong>@Contional派生的条件注解进行判断是否组件生效</strong></li></ol></li><li><strong>效果：</strong><ol><li><strong>修改配置文件，修改底层参数</strong></li><li><strong>所有场景自动配置好直接使用</strong></li><li><strong>可以注入SpringBoot配置好的组件随时使用</strong></li></ol></li></ol><h3 id="2-SPI机制">2. SPI机制</h3><ul><li><strong>Java中的SPI（Service Provider Interface）是一种软件设计模式，用于在应用程序中动态地发现和加载组件。SPI的思想</strong>是，定义一个接口或抽象类，然后通过在classpath中定义实现该接口的类来实现对组件的动态发现和加载。</li><li>SPI的主要目的是解决在应用程序中使用可插拔组件的问题。例如，一个应用程序可能需要使用不同的日志框架或数据库连接池，但是这些组件的选择可能取决于运行时的条件。通过使用SPI，应用程序可以在运行时发现并加载适当的组件，而无需在代码中硬编码这些组件的实现类。</li><li>在Java中，<strong>SPI</strong>的实现方式是通过在META-INF/services目录下创建一个以服务接口全限定名为名字的文件，文件中包含实现该服务接口的类的全限定名。当应用程序启动时，Java的SPI机制会自动扫描classpath中的这些文件，并根据文件中指定的类名来加载实现类。</li><li>通过使用SPI，应用程序可以实现更灵活、可扩展的架构，同时也可以避免硬编码依赖关系和增加代码的可维护性。</li></ul><p>以上回答来自ChatGPT-3.5<br>在SpringBoot中，META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports<br>作业：写一段java的spi机制代码</p><h3 id="3-功能开关">3. 功能开关</h3><ul><li>自动配置：全部都配置好，什么都不用管。 自动批量导入<ul><li>项目一启动，spi文件中指定的所有都加载。</li></ul></li><li>@EnableXxxx：手动控制哪些功能的开启； 手动导入。<ul><li>开启xxx功能</li></ul></li></ul><h2 id="2-进阶理解"><strong>2. 进阶理解</strong></h2><h3 id="1-SpringBootApplication"><strong>1. @SpringBootApplication</strong></h3><h4 id="SpringBootConfiguration"><strong>@SpringBootConfiguration</strong></h4><p><strong>就是： @Configuration ，容器中的组件，配置类。spring ioc启动就会加载创建这个类对象</strong></p><h4 id="EnableAutoConfiguration：开启自动配置"><strong>@EnableAutoConfiguration：开启自动配置</strong></h4><p><strong>开启自动配置</strong></p><h5 id="AutoConfigurationPackage：扫描主程序包：加载自己的组件"><strong>@AutoConfigurationPackage：扫描主程序包：加载自己的组件</strong></h5><ul><li><strong>利用 @Import(AutoConfigurationPackages.Registrar.class) 想要给容器中导入组件。</strong></li><li><strong>把主程序所在的包的所有组件导入进来。</strong></li><li><strong>为什么SpringBoot默认只扫描主程序所在的包及其子包</strong></li></ul><p>**</p><h5 id="Import-AutoConfigurationImportSelector-class-：加载所有自动配置类：加载starter导入的组件"><strong>@Import(AutoConfigurationImportSelector.class)：加载所有自动配置类：加载starter导入的组件</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; configurations = ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader())</span><br><span class="line">.getCandidates();</span><br></pre></td></tr></table></figure><p>**扫描SPI文件：META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</p><p>**</p><h4 id="ComponentScan"><strong>@ComponentScan</strong></h4><p><strong>组件扫描：排除一些组件（哪些不要）</strong><br><strong>排除前面已经扫描进来的配置类、和自动配置类。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br></pre></td></tr></table></figure><h3 id="2-完整启动加载流程">2. 完整启动加载流程</h3><p>生命周期启动加载流程<br><img src="https://cdn.nlark.com/yuque/0/2023/svg/1613913/1682569555020-b6cbc750-3171-44c6-810f-1c59e590b792.svg#from=url&amp;id=kMVFr&amp;originHeight=794&amp;originWidth=1453&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h1><strong>3. 自定义starter</strong></h1><p><strong>场景：抽取聊天机器人场景，它可以打招呼。</strong><br><strong>效果：任何项目导入此starter都具有打招呼功能，并且问候语中的人名需要可以在配置文件中修改</strong></p><ul><li><ol><li>创建自定义starter项目，引入spring-boot-starter基础依赖</li></ol></li><li><ol start="2"><li>编写模块功能，引入模块所有需要的依赖。</li></ol></li><li><ol start="3"><li>编写xxxAutoConfiguration自动配置类，帮其他项目导入这个模块需要的所有组件</li></ol></li><li><ol start="4"><li>编写配置文件META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports指定启动需要加载的自动配置</li></ol></li></ul><h2 id="1-业务代码"><strong>1. 业务代码</strong></h2><p>自定义配置有提示。导入以下依赖重启项目，再写配置文件就有提示**</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;robot&quot;)  //此属性类和配置文件指定前缀绑定</span><br><span class="line">@Component</span><br><span class="line">@Data</span><br><span class="line">public class RobotProperties &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String age;</span><br><span class="line">    private String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        导入配置处理器，配置文件自定义的properties配置都会有提示--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="2-基本抽取">2. 基本抽取</h2><ul><li>创建starter项目，把公共代码需要的所有依赖导入</li><li>把公共代码复制进来</li><li>自己写一个 RobotAutoConfiguration，给容器中导入这个场景需要的所有组件<ul><li>为什么这些组件默认不会扫描进去？</li><li><strong>starter所在的包和 引入它的项目的主程序所在的包不是父子层级</strong></li></ul></li><li>别人引用这个starter，直接导入这个 RobotAutoConfiguration,就能把这个场景的组件导入进来</li><li>功能生效。</li><li>测试编写配置文件</li></ul><h2 id="3-使用-EnableXxx机制"><strong>3. 使用@EnableXxx机制</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Documented</span><br><span class="line">@Import(RobotAutoConfiguration.class)</span><br><span class="line">public @interface EnableRobot &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>****别人引入starter需要使用 @EnableRobot开启功能 **</p><h2 id="4-完全自动配置">4. 完全自动配置</h2><ul><li>依赖SpringBoot的SPI机制</li><li>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 文件中编写好我们自动配置类的全类名即可</li><li>项目启动，自动加载我们的自动配置类</li></ul><h1>SpringBoot3-场景整合</h1><h2 id="0-云服务器">0. 云服务器</h2><ul><li><a href="https://promotion.aliyun.com/ntms/act/ambassador/sharetouser.html?userCode=50sid5bu&amp;utm_source=50sid5bu"><strong>阿里云</strong></a><strong>、</strong><a href="https://curl.qcloud.com/iyFTRSJb"><strong>腾讯云</strong></a><strong>、</strong><a href="https://activity.huaweicloud.com/discount_area_v5/index.html?fromacct=d1a6f32e-d6d0-4702-9213-eafe022a0708&amp;utm_source=bGVpZmVuZ3lhbmc==&amp;utm_medium=cps&amp;utm_campaign=201905"><strong>华为云</strong></a>** 服务器开通； 按量付费，省钱省心**</li><li><strong>安装以下组件</strong></li><li>[ ] <strong>docker</strong></li><li>[ ] <strong>redis</strong></li><li>[ ] <strong>kafka</strong></li><li>[ ] <strong>prometheus</strong></li><li>[ ] <strong>grafana</strong></li><li><a href="https://github.com/kingToolbox/WindTerm/releases/download/2.5.0/WindTerm_2.5.0_Windows_Portable_x86_64.zip"><strong>https://github.com/kingToolbox/WindTerm/releases/download/2.5.0/WindTerm_2.5.0_Windows_Portable_x86_64.zip</strong></a>** 下载windterm**</li></ul><p><strong>重要：开通云服务器以后，请一定在安全组设置规则，放行端口</strong></p><h2 id="1-Docker安装">1. Docker安装</h2><p>还不会docker的同学，参考【云原生实战（10~25集）】快速入门<br><a href="https://www.bilibili.com/video/BV13Q4y1C7hS?p=10">https://www.bilibili.com/video/BV13Q4y1C7hS?p=10</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class="line"></span><br><span class="line">sudo systemctl enable docker --now</span><br><span class="line"></span><br><span class="line">#测试工作</span><br><span class="line">docker ps</span><br><span class="line">#  批量安装所有软件</span><br><span class="line">docker compose  </span><br></pre></td></tr></table></figure><p><strong>创建 /prod 文件夹，准备以下文件</strong></p><h2 id="2-prometheus-yml">2. prometheus.yml</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval: 15s</span><br><span class="line">  evaluation_interval: 15s</span><br><span class="line"></span><br><span class="line">scrape_configs:</span><br><span class="line">  - job_name: &#x27;prometheus&#x27;</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&#x27;localhost:9090&#x27;]</span><br><span class="line"></span><br><span class="line">  - job_name: &#x27;redis&#x27;</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&#x27;redis:6379&#x27;]</span><br><span class="line"></span><br><span class="line">  - job_name: &#x27;kafka&#x27;</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&#x27;kafka:9092&#x27;]</span><br></pre></td></tr></table></figure><h2 id="3-docker-compose-yml">3. docker-compose.yml</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3.9&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:latest</span><br><span class="line">    container_name: redis</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379:6379&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line"></span><br><span class="line">  zookeeper:</span><br><span class="line">    image: bitnami/zookeeper:latest</span><br><span class="line">    container_name: zookeeper</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      ZOOKEEPER_CLIENT_PORT: 2181</span><br><span class="line">      ZOOKEEPER_TICK_TIME: 2000</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line"></span><br><span class="line">  kafka:</span><br><span class="line">    image: bitnami/kafka:3.4.0</span><br><span class="line">    container_name: kafka</span><br><span class="line">    restart: always</span><br><span class="line">    depends_on:</span><br><span class="line">      - zookeeper</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;9092:9092&quot;</span><br><span class="line">    environment:</span><br><span class="line">      ALLOW_PLAINTEXT_LISTENER: yes</span><br><span class="line">      KAFKA_CFG_ZOOKEEPER_CONNECT: zookeeper:2181</span><br><span class="line">      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line">  </span><br><span class="line">  kafka-ui:</span><br><span class="line">    image: provectuslabs/kafka-ui:latest</span><br><span class="line">    container_name:  kafka-ui</span><br><span class="line">    restart: always</span><br><span class="line">    depends_on:</span><br><span class="line">      - kafka</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    environment:</span><br><span class="line">      KAFKA_CLUSTERS_0_NAME: dev</span><br><span class="line">      KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS: kafka:9092</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line"></span><br><span class="line">  prometheus:</span><br><span class="line">    image: prom/prometheus:latest</span><br><span class="line">    container_name: prometheus</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - ./prometheus.yml:/etc/prometheus/prometheus.yml</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;9090:9090&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line"></span><br><span class="line">  grafana:</span><br><span class="line">    image: grafana/grafana:latest</span><br><span class="line">    container_name: grafana</span><br><span class="line">    restart: always</span><br><span class="line">    depends_on:</span><br><span class="line">      - prometheus</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;3000:3000&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  backend:</span><br><span class="line">    name: backend</span><br></pre></td></tr></table></figure><h2 id="4-启动环境">4. 启动环境</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose -f docker-compose.yml up -d</span><br></pre></td></tr></table></figure><h2 id="5-验证">5. 验证:</h2><p>如果通过浏览器验证没有通过的话，原因可能是没有配置安全组：例如<strong>Kafka-ui通过浏览器无法访问！</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1692062258198-3076f00d-7f1c-4d16-b118-d5602186ac58.png#averageHue=%23fcfcfc&amp;clientId=uac0c1727-261a-4&amp;from=paste&amp;height=75&amp;id=ucb808ef1&amp;originHeight=94&amp;originWidth=1264&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=7142&amp;status=done&amp;style=none&amp;taskId=u66261308-30e0-4c55-9da2-3ed8eed8757&amp;title=&amp;width=1011.2" alt="image.png">添加安全组8080，这里的来源是：可以设置为 0.0.0.0/0，表示允许来自任何 IP 地址的流量，或者您可以指定特定的 IP 地址范围或单个 IP 地址。</p><ul><li><strong>Redis：你的ip:6379</strong><ul><li><strong>填写表单，下载官方可视化工具：</strong></li><li><a href="https://redis.com/redis-enterprise/redis-insight/#insight-form"><strong>https://redis.com/redis-enterprise/redis-insight/#insight-form</strong></a></li></ul></li><li><strong>Kafka：你的ip:9092</strong><ul><li><strong>idea安装大数据插件</strong></li></ul></li><li><strong>Prometheus：你的ip:9090</strong><ul><li><strong>直接浏览器访问</strong></li></ul></li><li><strong>Grafana：你的ip:3000</strong><ul><li><strong>直接浏览器访问</strong></li></ul></li></ul><h2 id="Docker-10-25">Docker:(10-25)</h2><h3 id="Docker基本概念">Docker基本概念</h3><h4 id="1、解决的问题">1、解决的问题:</h4><p><strong>1、统一标准</strong><br>应用构建<br>Java、C++、JavaScript<br>打成软件包<br>.exe<br>docker build … 镜像<br><strong>应用分享:</strong><br>所有软件的镜像放到一个指定地方 docker hub<br>安卓，应用市场应用运行统一标准的镜像docker run<br>…<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1692069227456-eaaf5b70-3097-4576-b385-7518d3348588.png#averageHue=%23f0f1ed&amp;clientId=uac0c1727-261a-4&amp;from=paste&amp;height=274&amp;id=u3bdf5779&amp;originHeight=343&amp;originWidth=651&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=89111&amp;status=done&amp;style=none&amp;taskId=u3784a1e0-8b8e-4304-81c3-2a5c657fe94&amp;title=&amp;width=520.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1692069318112-64c8ca5e-79f7-41e5-9c62-bf61b0757143.png#averageHue=%23efefe8&amp;clientId=uac0c1727-261a-4&amp;from=paste&amp;height=285&amp;id=uff9e6b90&amp;originHeight=356&amp;originWidth=671&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=83511&amp;status=done&amp;style=none&amp;taskId=ue0c0164f-30fd-418f-ad07-ab8dfe21483&amp;title=&amp;width=536.8" alt="image.png"></p><h4 id="2、资源隔离">2、资源隔离</h4><ul><li>cpu、memory资源隔离与限制</li><li>访问设备隔离与限制</li><li>网络隔离与限制</li><li>用户、用户组隔离限制</li><li>…</li></ul><h3 id="2、架构">2、架构</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/svg/28066124/1692064439987-d4ad84f3-0582-4676-9c49-39734e7ef6f4.svg#clientId=uac0c1727-261a-4&amp;from=paste&amp;height=422&amp;id=uc0bf46e6&amp;originHeight=527&amp;originWidth=1009&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=187350&amp;status=done&amp;style=none&amp;taskId=u62a00463-37f0-4bac-9d79-bc88a76f6e2&amp;title=&amp;width=807.2" alt="architecture.svg"></p><ul><li>Docker_Host：<ul><li>安装Docker的主机</li></ul></li><li>Docker Daemon：<ul><li>运行在Docker主机上的Docker后台进程</li></ul></li><li>Client：<ul><li>操作Docker主机的客户端（命令行、UI等）</li></ul></li><li>Registry：<ul><li>镜像仓库</li><li>Docker Hub</li></ul></li><li>Images：<ul><li>镜像，带环境打包好的程序，可以直接启动运行</li></ul></li><li>Containers：<ul><li>容器，由镜像启动起来正在运行中的程序</li></ul></li></ul><p>交互逻辑<br>装好<strong>Docker</strong>，然后去 <strong>软件市场(doucker hub)</strong> 寻找<strong>镜像</strong>，下载并运行，查看<strong>容器</strong>状态日志等排错</p><h3 id="3、安装">3、安装</h3><h4 id="1、centos下安装docker">1、centos下安装docker</h4><p>其他系统参照如下文档<br><a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p><h4 id="1、移除以前docker相关包">1、移除以前docker相关包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><h4 id="2、配置yum源并且添加镜像仓库：">2、配置yum源并且添加镜像仓库：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3、安装docker">3、安装docker</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#以下是在安装k8s的时候使用</span><br><span class="line">yum install -y docker-ce-20.10.7 docker-ce-cli-20.10.7  containerd.io-1.4.6</span><br></pre></td></tr></table></figure><h4 id="4、启动">4、启动</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker --now</span><br></pre></td></tr></table></figure><h4 id="5、配置加速">5、配置加速</h4><p>这里额外添加了docker的生产环境核心配置cgroup：<br>其中仓库加速镜像可以去阿里云的：容器镜像服务-&gt;镜像加速器中选择加速地址替换下面的加速地址也就是registry-mirrors；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://82m9ar63.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;max-size&quot;: &quot;100m&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;storage-driver&quot;: &quot;overlay2&quot;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h4 id="6-镜像和容器的区别">6.镜像和容器的区别</h4><h3 id="Docker命令实战">Docker命令实战</h3><h4 id="常用命令">常用命令</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1692071527786-0d52ba68-3e36-4c18-b8eb-96a6ab5a7d03.png#averageHue=%23e3e2e1&amp;clientId=uac0c1727-261a-4&amp;from=paste&amp;height=478&amp;id=u8ac5de6b&amp;originHeight=597&amp;originWidth=1066&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=235950&amp;status=done&amp;style=none&amp;taskId=u6a7c6476-c964-4a45-bda6-bab61e7b3ce&amp;title=&amp;width=852.8" alt="image.png"></p><h4 id="基础实战">基础实战</h4><h5 id="1、找镜像">1、找镜像</h5><p>去<a href="http://hub.docker.com">docker hub</a>，找到nginx镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx  #下载最新版</span><br><span class="line"></span><br><span class="line">镜像名:版本名（标签）</span><br><span class="line"></span><br><span class="line">docker pull nginx:1.20.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker pull redis  #下载最新</span><br><span class="line">docker pull redis:6.2.4</span><br><span class="line"></span><br><span class="line">## 下载来的镜像都在本地</span><br><span class="line">docker images  #查看所有镜像</span><br><span class="line">##删除镜像</span><br><span class="line">docker rmi redis</span><br><span class="line">##删除中的redis为</span><br><span class="line">redis = redis:latest</span><br><span class="line">docker rmi 镜像名:版本号/镜像id</span><br><span class="line">##每个镜像都有一个id,可以根据id删除镜像</span><br><span class="line">##如果要删除的镜像真正使用，</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Nginx（发音为 “engine-x”）是一个用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议的开源反向代理服务器，以及负载均衡器、HTTP 缓存和 Web 服务器（原始服务器）。 nginx 项目一开始就非常注重高并发、高性能和低内存占用。它是根据 2 条款 BSD 类许可证获得许可的，并且可以在 Linux、BSD 变体、Mac OS X、Solaris、AIX、HP-UX 以及其他 *nix 版本上运行。它还具有适用于 Microsoft Windows 的概念验证端口。</p><h5 id="docker删除：">docker删除：</h5><p>docker rm 和docker rmi的区别</p><ul><li>docker rm 用于删除容器，而 docker rmi 用于删除镜像。</li><li>docker rm 可以删除正在运行的容器，而 docker rmi 只能删除未被使用的镜像。</li><li>删除容器可以使用容器 ID 或容器名称，而删除镜像可以使用镜像 ID 或镜像标签。</li></ul><p>如何批量删除运行中的容器<br>docker rm -f $(docker ps -q)这里的docker ps -q是列出正在运行的容器，$()是将括号里面执行结果当做参数传递给docker rm 命令。<br>要删除多个镜像，可以将它们列在一个命令中<br>docker rmi image1:tag image2:tag image3:tag<br>要删除多个容器，你可以使用以下命令：<br>docker rm container1 container2 container3 …</p><h5 id="2、启动容器">2、启动容器</h5><p>启动nginx应用容器，并映射88端口，测试的访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">【docker run  设置项   镜像名  】 镜像启动运行的命令（镜像里面默认有的</span><br><span class="line">，一般不会写）</span><br><span class="line"></span><br><span class="line"># -d：后台运行</span><br><span class="line"># --restart=always: 开机自启</span><br><span class="line">docker run --name=mynginx   -d  --restart=always -p  88:80  nginx</span><br><span class="line">##--name：给启动的镜像生成的容器起一个名字（启动后通过docker ps可以查看启动的容器</span><br><span class="line">其中有个names属性，这里的--name就是设置names属性的，</span><br><span class="line">##-d:是后台启动也就是不在当前的终端启动，而是在后台启动。如果不选择这个</span><br><span class="line">就会在当前的终端启动，且占据着当前的终端，无法在当前的终端使用其他命令。</span><br><span class="line">##88：80就是端口映射，其中的88是主机的端口，80是容器的端口。</span><br><span class="line"># 查看正在运行的容器</span><br><span class="line">docker ps</span><br><span class="line"># 查看所有，包括停止运行的容器</span><br><span class="line">docker ps -a</span><br><span class="line"># 删除停止的容器（要指定容器的id/名字）</span><br><span class="line">docker rm  容器id/名字</span><br><span class="line">docker rm -f mynginx   #强制删除正在运行中的</span><br><span class="line"></span><br><span class="line">#停止容器</span><br><span class="line">docker stop 容器id/名字</span><br><span class="line">#再次启动</span><br><span class="line">docker start 容器id/名字</span><br><span class="line"></span><br><span class="line">#应用开机自启</span><br><span class="line">docker update 容器id/名字 --restart=always</span><br></pre></td></tr></table></figure><h5 id="端口映射：">端口映射：</h5><h5 id="image-png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693661640773-7d47d1c1-5dc0-43aa-844b-46ebc764ac6e.png#averageHue=%236faab3&amp;clientId=u199a9dfb-f232-4&amp;from=paste&amp;height=270&amp;id=u0a4fc328&amp;originHeight=337&amp;originWidth=609&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=37379&amp;status=done&amp;style=none&amp;taskId=u205d8096-4b14-4c4a-8abc-bbf708f17d8&amp;title=&amp;width=487.2" alt="image.png"></h5><p>每个容器相当于一个小的Linux,每个容器都可以设置自己的端口，但是主机也有个端口88.端口映射就是后面我们通过公网ip访问88端口的时候实际上是访问nginx容器的80端口。其中容器启动的时候设置了端口映射可以通过docker ps命名查看到的<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693661968373-5247f323-5162-4d5b-88d6-e5a4021ff1d5.png#averageHue=%23202969&amp;clientId=u199a9dfb-f232-4&amp;from=paste&amp;height=65&amp;id=u215928cb&amp;originHeight=81&amp;originWidth=1155&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=105387&amp;status=done&amp;style=none&amp;taskId=ubeac012b-f2a1-4f31-addf-172b56a0f42&amp;title=&amp;width=924" alt="image.png"><br>这里就可以通过公网ip，端口88(注意不要添加http)访问80的nginx.<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693662068364-ed63640f-d323-413e-b3ca-8822b1ab1c30.png#averageHue=%23f6f5f4&amp;clientId=u199a9dfb-f232-4&amp;from=paste&amp;height=286&amp;id=uad59c2ba&amp;originHeight=358&amp;originWidth=806&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=38541&amp;status=done&amp;style=none&amp;taskId=u6fedb865-c35a-4f6e-bafa-ebce95595a8&amp;title=&amp;width=644.8" alt="image.png"></p><h5 id="3、修改容器内容（可以去dockpub官网查看相关容器的用法）">3、修改容器内容（可以去dockpub官网查看相关容器的用法）</h5><p>修改默认的index.html 页面</p><h6 id="1、进容器内部修改">1、进容器内部修改</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 进入容器内部的系统，修改容器内容</span><br><span class="line">docker exec -it 容器id  /bin/bash</span><br><span class="line">##容器相当于一个小的linux这里是进入小linux中的shell当然这里也可以选择</span><br><span class="line">/bin/sh，</span><br></pre></td></tr></table></figure><h6 id="image-png-2"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693662555584-0f50aa80-013f-4ef2-b825-2cc4e08f0746.png#averageHue=%231f2869&amp;clientId=u199a9dfb-f232-4&amp;from=paste&amp;height=54&amp;id=u3c41def4&amp;originHeight=68&amp;originWidth=1285&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=95065&amp;status=done&amp;style=none&amp;taskId=uf2b7db52-7049-40c2-8a43-6e9f0820f09&amp;title=&amp;width=1028" alt="image.png"></h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693664468867-2975cbcf-a97d-48d0-83a8-dfff635bd638.png#averageHue=%23223071&amp;clientId=u199a9dfb-f232-4&amp;from=paste&amp;height=233&amp;id=uc54b05ff&amp;originHeight=291&amp;originWidth=1427&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=497796&amp;status=done&amp;style=none&amp;taskId=uf5b39572-2572-4c63-b16e-7e914595699&amp;title=&amp;width=1141.6" alt="image.png"><br>再次登录的结果：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693664502030-7539f9e6-9251-4553-9953-92cc83e59f6f.png#averageHue=%23e5e4e3&amp;clientId=u199a9dfb-f232-4&amp;from=paste&amp;height=72&amp;id=u98dda7c1&amp;originHeight=90&amp;originWidth=353&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=4561&amp;status=done&amp;style=none&amp;taskId=u58eca5aa-3888-4200-b270-af1659e196d&amp;title=&amp;width=282.4" alt="image.png"><br>使用exit就退出容器。</p><h6 id="2、挂载数据到外部修改">2、挂载数据到外部修改</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=mynginx   \</span><br><span class="line">-d  --restart=always \</span><br><span class="line">-p  88:80 -v /data/html:/usr/share/nginx/html:ro  \</span><br><span class="line">nginx</span><br><span class="line"></span><br><span class="line"># 修改页面只需要去 主机的 /data/html</span><br></pre></td></tr></table></figure><h6 id="4、提交改变">4、提交改变</h6><p>将自己修改好的镜像提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">docker commit -a &quot;leifengyang&quot;  -m &quot;首页变化&quot; 341d81f7504f guignginx:v1.0</span><br><span class="line">##这个命令有以下几个部分：</span><br><span class="line"></span><br><span class="line">-a &quot;leifengyang&quot;：指定作者信息为 &quot;leifengyang&quot;，表示创建镜像的作者。</span><br><span class="line">-m &quot;首页变化&quot;：指定提交消息为 &quot;首页变化&quot;，用于描述这个镜像的变化</span><br><span class="line">或修改。</span><br><span class="line">341d81f7504f：容器的 ID，表示要基于此容器创建新的镜像。</span><br><span class="line">guignginx:v1.0：新镜像的名称和标签，这里将创建一个名为 &quot;guignginx&quot;</span><br><span class="line">，标签为 &quot;v1.0&quot; 的镜像。</span><br><span class="line">执行该命令后，Docker 将根据容器的当前状态创建一个新的镜像，并将其命</span><br><span class="line">名为 &quot;guignginx:v1.0&quot;，包含了您在容器中所做的更改。</span><br></pre></td></tr></table></figure><p>提交改变后，如果后面删除了原来的镜像，想要运行新的镜像的时候，如果用<br>docker run --name=mynginx   -d  --restart=always -p  88:80  nginx命令<br>运行镜像时，运行的是默认镜像。这个时候可以运行刚刚提交的镜像<br>docker run --name=mynginx   -d  --restart=always -p  88:80  guignginx:v1.0<br>这样就可以运行和刚刚删除的容器一样的容器而不必重新在新的容器上修改。</p><h6 id="镜像保存：">镜像保存：</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693666166503-76847856-5dbd-41c1-b985-d573593d50ee.png#averageHue=%2319191a&amp;clientId=u199a9dfb-f232-4&amp;from=paste&amp;height=198&amp;id=u4444ecb0&amp;originHeight=247&amp;originWidth=855&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=88985&amp;status=done&amp;style=none&amp;taskId=u432223cc-3ccb-4a43-bafa-c67f0b00a05&amp;title=&amp;width=684" alt="image.png"></p><h6 id="1、镜像传输">1、镜像传输</h6><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693666351488-fcc58253-ce49-485b-a0dd-b0f91e801603.png#averageHue=%231a1a1b&amp;clientId=u199a9dfb-f232-4&amp;from=paste&amp;height=387&amp;id=u19a7bd17&amp;originHeight=484&amp;originWidth=951&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=212480&amp;status=done&amp;style=none&amp;taskId=u8e036015-3d49-43b5-9c69-60df8df3dc8&amp;title=&amp;width=760.8" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 将镜像保存成压缩包</span><br><span class="line">docker save -o abc.tar guignginx:v1.0</span><br><span class="line"></span><br><span class="line"># 别的机器加载这个镜像</span><br><span class="line">docker load -i abc.tar</span><br><span class="line">#-i 表示输入文件（input file），指定要加载的镜像存储文件的路径。</span><br><span class="line">abc.tar 是一个镜像存储文件，通过该命令，Docker 将读取该文件并加载其</span><br><span class="line">中的镜像到本地 Docker 引擎中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 离线安装</span><br></pre></td></tr></table></figure><h6 id="5、推送远程仓库">5、推送远程仓库</h6><p>推送镜像到docker hub；应用市场（前提要注册，然后自己创建一个仓库）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag local-image:tagname new-repo:tagname</span><br><span class="line">docker push new-repo:tagname</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 把旧镜像的名字，改成仓库要求的新版名字</span><br><span class="line">docker tag guignginx:v1.0 leifengyang/guignginx:v1.0</span><br><span class="line">#</span><br><span class="line">通过执行该命令，Docker 将为镜像 guignginx:v1.0 创建一个新的标签</span><br><span class="line">leifengyang/guignginx:v1.0。这个操作不会创建新的镜像副本，</span><br><span class="line">只是为现有镜像添加了一个新的标签。这样，您可以通过两个不同的标签来</span><br><span class="line">引用同一个镜像。</span><br><span class="line"># 登录到docker hub，只需要登录一次，下次启动服务器的时(没有退出）不需要登录直接</span><br><span class="line">push</span><br><span class="line">docker login       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker logout（推送完成镜像后退出）</span><br><span class="line"></span><br><span class="line"># 推送</span><br><span class="line">docker push leifengyang/guignginx:v1.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 别的机器下载</span><br><span class="line"></span><br><span class="line">docker pull leifengyang/guignginx:v1.0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693668015733-b27ce633-6a8d-4fbe-bb30-53fe273d574d.png#averageHue=%232c3d7e&amp;clientId=u199a9dfb-f232-4&amp;from=paste&amp;height=370&amp;id=u06e55159&amp;originHeight=462&amp;originWidth=1240&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=692661&amp;status=done&amp;style=none&amp;taskId=uf8fbd6a9-51b2-4511-9175-91e09c11c57&amp;title=&amp;width=992" alt="image.png"></p><h6 id="6、补充">6、补充</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">docker logs 容器名/id   排错</span><br><span class="line"></span><br><span class="line">docker exec -it 容器id /bin/bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># docker 经常修改nginx配置文件</span><br><span class="line">docker run -d -p 80:80 \</span><br><span class="line">-v /data/html:/usr/share/nginx/html:ro \</span><br><span class="line">-v /data/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">--name mynginx-02 \</span><br><span class="line">nginx</span><br><span class="line">#-v /data/html:/usr/share/nginx/html:ro：将主机的 /data/html </span><br><span class="line">目录挂载到容器内的 /usr/share/nginx/html 目录，并设置为只读模式 (ro)。这样，容器内的 Nginx 将使用主机上的 HTML 文件。</span><br><span class="line">-v /data/conf/nginx.conf:/etc/nginx/nginx.conf：</span><br><span class="line">将主机的 /data/conf/nginx.conf 文件挂载到容器内的</span><br><span class="line">/etc/nginx/nginx.conf 文件，用于替换容器内的 Nginx 配置文件。</span><br><span class="line">--name mynginx-02：指定容器的名称为 mynginx-02。</span><br><span class="line">nginx：要运行的镜像名称。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#把容器指定位置的东西复制出来 </span><br><span class="line">docker cp 5eff66eec7e1:/etc/nginx/nginx.conf  /data/conf/nginx.conf</span><br><span class="line">#把外面的内容复制到容器里面</span><br><span class="line">docker cp  /data/conf/nginx.conf  5eff66eec7e1:/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><h3 id="进阶实战">进阶实战</h3><h4 id="1、编写自己的应用">1、编写自己的应用</h4><p>编写一个HelloWorld应用<br><a href="https://start.spring.io/">https://start.spring.io/</a></p><p>示例代码： <a href="https://gitee.com/leifengyang/java-demo.git">https://gitee.com/leifengyang/java-demo.git</a></p><h5 id="2、将应用打包成镜像">2、将应用打包成镜像</h5><p>编写Dockerfile将自己的应用打包镜像</p><h5 id="1、以前">1、以前</h5><p>Java为例</p><ul><li>SpringBoot打包成可执行jar</li><li>把jar包上传给服务</li><li>服务器运行java -jar</li></ul><h5 id="2、现在">2、现在</h5><p>所有机器都安装Docker，任何应用都是镜像，所有机器都可以运行</p><h5 id="3、怎么打包-Dockerfile">3、怎么打包-Dockerfile</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jdk-slim</span><br><span class="line">LABEL maintainer=leifengyang</span><br><span class="line"></span><br><span class="line">COPY target/*.jar   /app.jar</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t java-demo:v1.0 .</span><br></pre></td></tr></table></figure><p>思考：<br>每个应用每次打包，都需要本地编译、再上传服务器、再进行docker构建，如果有1000个应用要打包镜像怎么办？有没有更好的方式？</p><h5 id="3、启动容器">3、启动容器</h5><p>启动应用容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:8080 --name myjava-app java-demo:v1.0 </span><br></pre></td></tr></table></figure><p>分享镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 登录docker hub</span><br><span class="line">docker login</span><br><span class="line"></span><br><span class="line">#给旧镜像起名</span><br><span class="line">docker tag java-demo:v1.0  leifengyang/java-demo:v1.0</span><br><span class="line"></span><br><span class="line"># 推送到docker hub</span><br><span class="line">docker push leifengyang/java-demo:v1.0</span><br><span class="line"></span><br><span class="line"># 别的机器</span><br><span class="line">docker pull leifengyang/java-demo:v1.0</span><br><span class="line"></span><br><span class="line"># 别的机器运行</span><br><span class="line">docker run -d -p 8080:8080 --name myjava-app java-demo:v1.0 </span><br></pre></td></tr></table></figure><h5 id="4、部署中间件">4、部署中间件</h5><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693720409476-cdc02b96-0977-43bb-8468-a5e95524479e.png#averageHue=%2382bec8&amp;clientId=ubd7ce99a-c7e7-4&amp;from=paste&amp;height=362&amp;id=XUcBO&amp;originHeight=452&amp;originWidth=909&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=112189&amp;status=done&amp;style=none&amp;taskId=u246d6b70-14f7-4ec4-86d9-7f461209255&amp;title=&amp;width=727.2" alt="image.png"><br>部署一个Redis+应用，尝试应用操作Redis产生数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">#redis使用自定义配置文件启动</span><br><span class="line"></span><br><span class="line">docker run -v /data/redis/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-v /data/redis/data:/data \</span><br><span class="line">-d --name myredis \</span><br><span class="line">-p 6379:6379 \</span><br><span class="line">redis:latest  redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Redis配置密码：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693721336317-8222233b-4a16-424e-aa2f-c6ddb6ad2f6c.png#averageHue=%23151516&amp;clientId=ubd7ce99a-c7e7-4&amp;from=paste&amp;height=190&amp;id=u6e8c45ae&amp;originHeight=237&amp;originWidth=583&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=35158&amp;status=done&amp;style=none&amp;taskId=u26f9ab92-c709-4582-88b0-ec1e8978e04&amp;title=&amp;width=466.4" alt="image.png"><br>连接Redis:<br>测试使用redis:</p><h2 id="1、NoSQL">1、NoSQL</h2><h3 id="Redis整合">Redis整合</h3><p>**Redis不会的同学：参照 阳哥-《Redis7》 **<a href="https://www.bilibili.com/video/BV13R4y1v7sP?p=1"><strong>https://www.bilibili.com/video/BV13R4y1v7sP?p=1</strong></a><br>**HashMap： key：value</p><p>**</p><h2 id="1-场景整合"><strong>1. 场景整合</strong></h2><p><strong>依赖导入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.data.redis.host=192.168.200.100</span><br><span class="line">spring.data.redis.password=Lfy123!@!</span><br></pre></td></tr></table></figure><p><strong>测试</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">void redisTest()&#123;</span><br><span class="line">    redisTemplate.opsForValue().set(&quot;a&quot;,&quot;1234&quot;);</span><br><span class="line">    Assertions.assertEquals(&quot;1234&quot;,redisTemplate.opsForValue().get(&quot;a&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-自动配置原理"><strong>2. 自动配置原理</strong></h2><ol><li>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports中导入了<code>RedisAutoConfiguration</code>、RedisReactiveAutoConfiguration和RedisRepositoriesAutoConfiguration。所有属性绑定在<code>RedisProperties</code>中</li><li>RedisReactiveAutoConfiguration属于响应式编程，不用管。RedisRepositoriesAutoConfiguration属于 JPA 操作，也不用管</li><li>RedisAutoConfiguration 配置了以下组件<ol><li>LettuceConnectionConfiguration： 给容器中注入了连接工厂LettuceConnectionFactory，和操作 redis 的客户端DefaultClientResources。</li><li><code>RedisTemplate&lt;Object, Object&gt;</code>： 可给 redis 中存储任意对象，会使用 jdk 默认序列化方式。</li><li><code>StringRedisTemplate</code>： 给 redis 中存储字符串，如果要存对象，需要开发人员自己进行序列化。key-value都是字符串进行操作··,如果key和value中有一个是实体对象可以将对象转化为json数据（字符串）来进行操作、，</li></ol></li></ol><h2 id="3-定制化">3. 定制化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppRedisConfiguration &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 允许Object类型的key-value，都可以被转为json进行存储。</span><br><span class="line">     * @param redisConnectionFactory 自动配置好了连接工厂</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        //把对象转为json字符串的序列化工具</span><br><span class="line">        template.setDefaultSerializer(new GenericJackson2JsonRedisSerializer());</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-redis客户端"><strong>2. redis客户端</strong></h3><blockquote><p><strong>RedisTemplate、StringRedisTemplate： 操作redis的工具类</strong></p><ul><li><strong>要从redis的连接工厂获取链接才能操作redis</strong></li><li><strong>Redis客户端</strong><ul><li><strong>Lettuce： 默认</strong></li><li><strong>Jedis：可以使用以下切换</strong></li></ul></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--        切换 jedis 作为操作redis的底层客户端--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="3-配置参考"><strong>3. 配置参考</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring.data.redis.host=8.130.74.183</span><br><span class="line">spring.data.redis.port=6379</span><br><span class="line">#spring.data.redis.client-type=lettuce</span><br><span class="line"></span><br><span class="line">#设置lettuce的底层参数</span><br><span class="line">#spring.data.redis.lettuce.pool.enabled=true</span><br><span class="line">#spring.data.redis.lettuce.pool.max-active=8</span><br><span class="line"></span><br><span class="line">spring.data.redis.client-type=jedis</span><br><span class="line">spring.data.redis.jedis.pool.enabled=true</span><br><span class="line">spring.data.redis.jedis.pool.max-active=8</span><br></pre></td></tr></table></figure><h3 id="总结：">总结：</h3><p><strong>1.</strong></p><h2 id="消息服务：">消息服务：</h2><h2 id="1-docker安装kafka（没学完）">1.docker安装kafka（没学完）</h2><p><a href="https://blog.csdn.net/y393016244/article/details/126405864">Docker安装Kafka教程（超详细）_乾坤鸟的博客-CSDN博客</a><br>docker network create app-tier --driver bridge</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用命令 docker network create app-tier --driver bridge 可以创建一个</span><br><span class="line">名为 &quot;app-tier&quot; 的 Docker 网络，并使用桥接（bridge）驱动程序。</span><br><span class="line"></span><br><span class="line">这个命令会创建一个桥接网络，桥接网络是 Docker 中默认的网络驱动程序。</span><br><span class="line">桥接网络用于连接运行在同一 Docker 主机上的多个容器，使它们能够使用容</span><br><span class="line">器名称作为主机名进行通信。</span><br><span class="line"></span><br><span class="line">通过创建 &quot;app-tier&quot; 网络，您可以启动容器并将它们连接到该网络，以便</span><br><span class="line">实现容器之间的通信。同一网络内的容器可以使用它们的容器名称作为主机名</span><br><span class="line">来相互访问。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name kafka-server \</span><br><span class="line">    --network app-tier \</span><br><span class="line">    -p 9092:9092 \</span><br><span class="line">    -e ALLOW_PLAINTEXT_LISTENER=yes \</span><br><span class="line">    -e KAFKA_CFG_ZOOKEEPER_CONNECT=zookeeper-server:2181 \</span><br><span class="line">    -e KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://8.130.50.249:9092\</span><br><span class="line">    bitnami/kafka:latest</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.安装kafkaUi<br><a href="https://blog.csdn.net/qq_42987796/article/details/129799473">【docker】docker安装带ui界面的kafka_docker ui 安装_努力的gopher的博客-CSDN博客</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;2&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  zookeeper:</span><br><span class="line">    image: docker.io/bitnami/zookeeper:3.8</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;22181:2181&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;zookeeper_data:/bitnami&quot;</span><br><span class="line">    environment:</span><br><span class="line">      - ALLOW_ANONYMOUS_LOGIN=yes</span><br><span class="line">  kafka:</span><br><span class="line">    container_name: kafka1</span><br><span class="line">    image: docker.io/bitnami/kafka:3.4</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;9192:9092&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;kafka_data:/bitnami&quot;</span><br><span class="line">    environment:</span><br><span class="line">      - KAFKA_CFG_ZOOKEEPER_CONNECT=zookeeper:2181</span><br><span class="line">      - ALLOW_PLAINTEXT_LISTENER=yes</span><br><span class="line">      - KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://8.130.50.249:9192</span><br><span class="line">      - KAFKA_CFG_AUTO_CREATE_TOPICS_ENABLE=true</span><br><span class="line">    depends_on:</span><br><span class="line">      - zookeeper</span><br><span class="line"></span><br><span class="line">  kafka-ui:</span><br><span class="line">    image: provectuslabs/kafka-ui:latest</span><br><span class="line">    container_name: kafka-ui</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">        - 10010:8080</span><br><span class="line">    volumes:</span><br><span class="line">        - /etc/localtime:/etc/localtime</span><br><span class="line">    environment:</span><br><span class="line">        - KAFKA_CLUSTERS_0_NAME=local</span><br><span class="line">        - KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=kafka1:9092</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  zookeeper_data:</span><br><span class="line">    driver: local</span><br><span class="line">  kafka_data:</span><br><span class="line">    driver: local</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html"> &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h1&gt;1.创建第一个项目：&lt;/h1&gt;
&lt;h2 id=&quot;1-引入依赖：&quot;&gt;1.引入依赖：&lt;/h2&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t</summary>
      
    
    
    
    <category term="springboot2" scheme="http://www.bojiboqi.fun/categories/springboot2/"/>
    
    
    <category term="springboot2" scheme="http://www.bojiboqi.fun/tags/springboot2/"/>
    
  </entry>
  
  <entry>
    <title>杂记</title>
    <link href="http://www.bojiboqi.fun/2024/01/26/%E6%9D%82%E8%AE%B0%EF%BC%9A/"/>
    <id>http://www.bojiboqi.fun/2024/01/26/%E6%9D%82%E8%AE%B0%EF%BC%9A/</id>
    <published>2024-01-26T10:57:24.240Z</published>
    <updated>2024-01-26T10:57:59.928Z</updated>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h4 id="云服务器的实例id可以修改吗？">云服务器的实例id可以修改吗？</h4><p><a href="https://help.aliyun.com/zh/ecs/user-guide/modify-the-properties-of-an-instance">实例 ID 是由系统自动生成的，无法修改。但是您可以修改实例的名称、主机名和实例描述等实例属性以提高云资源的管理效率和可读性，同时也可以提高云资源的安全性和自动化运维的支持程度。</a></p><h4 id="什么是分布式存储？">什么是分布式存储？</h4><p>分布式存储就像我们的拉货的货车（传统的集中储存），改用一节一节连接起来的火车拉货，当不能满足存储需求的时候，我们只需要添加一节一节的车厢就能满足需求了（易扩展性）。</p><h4 id="什么是流量穿透？">什么是流量穿透？</h4><p>就是中国移动，电信等国企提供的接入互联网服务时，对中小运营企业收费高，但是对非运营企业收费低。故存在套利空间（中小运营商通过利用非运营企业空余的带宽资源从而节约成本）</p><h4 id="密匙对是什么">密匙对是什么?</h4><p><strong>一、概念</strong><br>1、<strong>密钥对</strong>：在非对称加密技术中，有两种密钥，分为公钥和私钥。<br>公钥是密钥对所有者持有，<strong>公布给他人的</strong>；私钥也是密钥对所有者持有，<strong>不可公布</strong>。<br>2、<strong>密钥</strong>：指公钥或私钥。<br>3、<strong>公钥</strong>：公钥用来给数据加密，用公钥加密的数据只能使用私钥解密。<br>4、<strong>私钥</strong>：如上，用来解密公钥加密的数据。<br>总结：<strong>公钥和私钥是通过一种算法得到的一个密钥对(即一个公钥和一个私钥)，将其中的一个向外界公开，称为公钥；另一个自己保留，称为私钥。通过这种算法得到的密钥对能保证在世界范围内是唯一的。</strong><br>公钥和私钥是成对的，它们互相解密（密钥指公钥或私钥，密钥对指公钥加私钥）。<br>公钥和私钥都可以加密和解密。<br>私钥数字签名，公钥验证。</p><h4 id="通过宝塔面板出现数据库连接错误的解决方法（注意搜索不到问题的答案的时候要冷静下来思考搜索的输入，不要盲目点点搜索引擎）">通过宝塔面板出现数据库连接错误的解决方法（注意搜索不到问题的答案的时候要冷静下来思考搜索的输入，不要盲目点点搜索引擎）</h4><p><a href="https://www.bt.cn/bbs/thread-40225-1-1.html">MySQL 报 1045 错误解决方法 - Linux面板 - 宝塔面板论坛</a><br>1.通过宝塔面板查看数据库日志看看是什么原因造成的<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693650814661-d2c4920e-7035-4377-acda-109ddbdf28ce.png#averageHue=%238e8c8a&amp;clientId=u4ccb6c37-25e4-4&amp;from=paste&amp;height=546&amp;id=ud487d339&amp;originHeight=682&amp;originWidth=1020&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=134848&amp;status=done&amp;style=none&amp;taskId=ud724d708-9279-4f0e-81eb-ce79cab50a8&amp;title=&amp;width=816" alt="image.png"><br>2.浏览器搜索原因（可以添加宝塔面板字样）</p><h4 id="wordpress登录忘记了密码且无法通过邮箱找回">wordpress登录忘记了密码且无法通过邮箱找回</h4><p><a href="https://blog.csdn.net/qq_41990268/article/details/118875760">WordPress忘记密码且邮箱无法发送找回密码链接时的解决办法_wordpress忘记密码无法发送邮件_虎鲸不是鱼的博客-CSDN博客</a><br>方法1：邮箱找回：不过前提是服务器可以发送重置密码的邮件；<br>方法2：修改wordpress储存用户的数据库的密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p这里写刚查看到的root密码;</span><br><span class="line">show databases;</span><br><span class="line"> use wordpress;</span><br><span class="line">show tables;</span><br><span class="line">select * from wp_users;</span><br><span class="line">update wp_users set user_pass=md5(&quot;123456&quot;) where user_login=&#x27;admin&#x27;;</span><br><span class="line">##123456是你的Wordpress新密码，admin是管理员账号,wordpress采用的是</span><br><span class="line">md5加密，而user_pass列的内容是md5加密后的字符串</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法3：使用重置文件(也就是自己写的脚本）<br>将下面的代码另存为 reset_pw.php ，<em><strong>注意根据里面的注释修改 2-15行的相关信息</strong></em>（如果你不知道数据库的信息，可以查看你网站根目录下的 wp-config.php），然后通过FTP将 reset_pw.php 上传到网站根目录，在浏览器中访问这个文件，就会提示修改成功！<strong>使用完以后，记得删除 reset_pw.php ，以免存在安全隐患！！</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/*你的数据库服务器地址，一般保持默认*/</span><br><span class="line">$servername = &quot;localhost:3306&quot;;</span><br><span class="line">/*数据库用户名*/</span><br><span class="line">$phpMyadminUser = &quot;root&quot;;</span><br><span class="line">/*数据库密码*/</span><br><span class="line">$phpMyadminKey = &quot;yiduqiang&quot;;</span><br><span class="line">/*数据库名称*/</span><br><span class="line">$phpMyadminName = &quot;test&quot;;</span><br><span class="line">/*wordpress数据表格前缀*/</span><br><span class="line">$QZ = &quot;wp_&quot;;</span><br><span class="line">/*你要设置的wordpress新密码*/</span><br><span class="line">$NewKey = &quot;yiduqiang&quot;;</span><br><span class="line">/*你要设置新密码的用户名*/</span><br><span class="line">$wordpress_User = &quot;yiduqiang&quot;;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</span><br><span class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;wordpress密码找回工具&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">if(!mysql_connect($servername,$phpMyadminUser,$phpMyadminKey))</span><br><span class="line">&#123;</span><br><span class="line">    echo &quot;对不起，数据库链接出错。</span><br><span class="line">&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    echo &quot;数据库链接成功。</span><br><span class="line">&quot;;</span><br><span class="line">    mysql_select_db($phpMyadminName,mysql_connect($servername,$phpMyadminUser,$phpMyadminKey));</span><br><span class="line">    if (!mysql_query(&quot;update &quot;.$QZ.&quot;users set user_pass=&#x27;&quot;.md5($NewKey).&quot;&#x27; where user_login=&#x27;&quot;.$wordpress_User.&quot;&#x27;&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;对不起，修改密码失败。&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;修改密码成功。&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="知识点：">知识点：</h4><p>1.浏览器输入<a href="http://xn--ip-im8ckc280ctnmtkc921cdp0bv8m/var/www/html">http://ip地址解析通常的是/var/www/html</a> 或 /var/www文件下的index<br>2.nginx是反向代理，其中可以设置http服务,它和http服务占据的端口都是80,其中通过wordpress建立网站的时候要安装nginx，不然<a href="http://xn--ipwordpress-538rp16romu962acm1ghk2a">http://ip无法转到wordpress界面</a><br>3.mysql中的用户和密码放在mysql数据库中的user表中的<br>4.可以通过在mysql的配置文件中添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure><p>实现免密登录<br>5.更改mysql密码的步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.停止 MySQL 服务：</span><br><span class="line">sudo systemctl stop mysqld；</span><br><span class="line">2.启动 MySQL 服务，并跳过权限验证：</span><br><span class="line">sudo mysqld_safe --skip-grant-tables &amp;</span><br><span class="line">3.连接到 MySQL 服务器：</span><br><span class="line">mysql -u root</span><br><span class="line">4.在 MySQL 提示符下，切换到 mysql 数据库：</span><br><span class="line">use mysql;</span><br><span class="line">5.更新 root 用户的密码：</span><br><span class="line">update user set authentication_string=password(&#x27;新密码&#x27;) where user=&#x27;root&#x27;;</span><br><span class="line">6.刷新权限：</span><br><span class="line">flush privileges;</span><br><span class="line">7.退出 MySQL 提示符：</span><br><span class="line">exit;</span><br><span class="line">8.停止 MySQL 服务：</span><br><span class="line">sudo systemctl stop mysqld</span><br><span class="line">9.启动 MySQL 服务：</span><br><span class="line">sudo systemctl start mysqld</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>8.centos查看占用端口的进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lsof -i :80##查看占用80端口的进程</span><br></pre></td></tr></table></figure><p>通常一个端口只能被一个进程占用，但是有时候会出现多个进程占据一个端口的情况：<br>1.多个进程占据不同的ip，然后占据同样一个端口<br>2.不同用户下的进程占据同一个端口<br>9.grant all privileges on wordpress.* to ‘wpadmin’@‘localhost’ identified(识别) by ‘Edualiyun@123’;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">这是一个授予 MySQL 数据库用户权限的 SQL 语句。该语句将授予名为 &#x27;wpadmin&#x27; 的用户在名为 &#x27;wordpress&#x27; 的数据库上的所有权限，并使用密码 &#x27;Edualiyun@123&#x27; 进行身份验证。</span><br><span class="line"></span><br><span class="line">解释该语句的各个部分：</span><br><span class="line"></span><br><span class="line">GRANT ALL PRIVILEGES: 授予所有权限。</span><br><span class="line">ON wordpress.*: 应用权限到名为 &#x27;wordpress&#x27; 的数据库中的所有表。</span><br><span class="line">TO &#x27;wpadmin&#x27;@&#x27;localhost&#x27;: 授予用户 &#x27;wpadmin&#x27; 权限，并限制该用户只能从本地主机（localhost）连接。</span><br><span class="line">IDENTIFIED BY &#x27;Edualiyun@123&#x27;: 设置用户的密码为 &#x27;Edualiyun@123&#x27;。</span><br></pre></td></tr></table></figure><p>10.chown -R apache.apache /var/www/html/wordpress</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chown -R apache.apache /var/www/html/wordpress 是一个 Linux 命令，用于更改 /var/www/html/wordpress 目录及其下所有文件和子目录的所有者和所属组。</span><br><span class="line"></span><br><span class="line">解释该命令的各个部分：</span><br><span class="line"></span><br><span class="line">chown: 表示更改文件或目录的所有者和所属组。</span><br><span class="line">-R: 表示递归地修改目录及其下的所有文件和子目录。</span><br><span class="line">apache.apache: 表示将所有者设置为 apache 用户，所属组设置为 apache 组。</span><br><span class="line">/var/www/html/wordpress: 是要修改所有者和所属组的目标目录路径。</span><br></pre></td></tr></table></figure><p>11.更改用户的密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;username&#x27;@&#x27;host&#x27; IDENTIFIED BY &#x27;new_password&#x27;;</span><br><span class="line">● username&#x27;：要更改密码的用户名。</span><br><span class="line">● &#x27;host&#x27;：用户的主机名。如果要更改所有主机上的密码，可以使用 &#x27;%&#x27; 代替。</span><br><span class="line">● &#x27;new_password&#x27;：要设置的新密码。</span><br><span class="line">DENTIFIED BY 是用于指定用户的新密码的子句。当使用 ALTER USER 命令更</span><br><span class="line">改用户密码时，您可以使用 IDENTIFIED BY 子句来指定新密码。</span><br></pre></td></tr></table></figure><h4 id="如何让每次创建maven项目直接使用直接甚至的maven而不是每次去修改？">如何让每次创建maven项目直接使用直接甚至的maven而不是每次去修改？</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693670856318-9adb6278-35e9-4092-82c7-88bb3c3cc211.png#averageHue=%233c795f&amp;clientId=u8360c880-6e71-4&amp;from=paste&amp;height=690&amp;id=u019a597e&amp;originHeight=863&amp;originWidth=1329&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=177783&amp;status=done&amp;style=none&amp;taskId=uc3d99e9c-a9d7-44b0-b174-28232a0e0d1&amp;title=&amp;width=1063.2" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693670901031-7f8b4645-ebb4-49e3-bff9-28be4ba7f223.png#averageHue=%23070606&amp;clientId=u8360c880-6e71-4&amp;from=paste&amp;height=634&amp;id=u436f769d&amp;originHeight=793&amp;originWidth=1261&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=103388&amp;status=done&amp;style=none&amp;taskId=ub568af7d-ceca-4446-8760-4c124457c22&amp;title=&amp;width=1008.8" alt="image.png"></p><h4 id="docker-load-i-abc-tar">docker load -i abc.tar</h4><p>docker load 命令用于从一个镜像存储文件（如 .tar 文件）加载镜像到 Docker 引擎。在您提供的命令中：<br>Copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i abc.tar</span><br></pre></td></tr></table></figure><p>这个命令的作用是从名为 abc.tar 的镜像存储文件加载镜像到 Docker 引擎中。<br>-i 参数用于从标准输入（stdin）加载镜像</p><h4 id="docker-tag-guignginx-v1-0-leifengyang-guignginx-v1-0">docker tag guignginx:v1.0 leifengyang/guignginx:v1.0</h4><p>docker tag 命令用于为现有的镜像创建一个新的标签。在您提供的命令中：<br>Copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag guignginx:v1.0 leifengyang/guignginx:v1.0</span><br></pre></td></tr></table></figure><p>这个命令的作用是为已存在的 guignginx:v1.0 镜像创建一个新的标签 leifengyang/guignginx:v1.0。<br>通过执行该命令，Docker 将为镜像 guignginx:v1.0 创建一个新的标签 leifengyang/guignginx:v1.0。这个操作不会创建新的镜像副本，只是为现有镜像添加了一个新的标签。这样，您可以通过两个不同的标签来引用同一个镜像。</p><h4 id="查看redis的版本">查看redis的版本</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --version</span><br></pre></td></tr></table></figure><p>redis的命令是redis-server而不是一般的redis</p><h4 id="yum-install-centos-release-scl-scl-utils-build">yum install centos-release-scl scl-utils-build</h4><p>yum install -y devtoolset-8-toolchain<br>scl enable devtoolset-8 bash<br>这些命令用于在 CentOS 系统上安装和启用 Devtoolset-8 工具链。Devtoolset 是用于在 CentOS/RHEL 系统上使用新版本编译工具的软件集合。<br>以下是对每个命令的解释：</p><ol><li><strong>yum install centos-release-scl scl-utils-build</strong>：<br>这个命令用于安装 CentOS SCL（Software Collections）存储库和 scl-utils-build 工具包。SCL 存储库提供了一组额外的软件包，包括 Devtoolset。</li><li><strong>yum install -y devtoolset-8-toolchain</strong>：<br>这个命令用于安装 Devtoolset-8 工具链。Devtoolset-8 包含了一系列编译工具，如 GCC、G++、调试器等。通过安装这个工具链，你可以在 CentOS 系统上使用更新的编译器和工具。</li><li><strong>scl enable devtoolset-8 bash</strong>：<br>这个命令启用 Devtoolset-8 工具链，使其成为当前会话中的默认编译工具。通过执行这个命令，你将在当前终端会话中使用 Devtoolset-8 提供的编译器和工具。</li></ol><p>请注意，这些命令需要以 root 或具有管理员权限的用户来执行。在执行这些命令之前，确保你的系统已连接到互联网，并且已正确配置了软件包管理器（yum）以从正确的软件源中获取软件包。</p><h4 id="tar-zxvf-redis-6-2-1-tar-gz解读选项">tar -zxvf redis-6.2.1.tar.gz解读选项</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-6.2.1.tar.gz 是一个解压缩 tar 压缩文件的命令，其中</span><br><span class="line">包含了一些选项。下面是对每个选项的解释：</span><br><span class="line"></span><br><span class="line">-z：表示使用 gzip 压缩算法解压缩。tar 命令通常用于创建和提取 tar </span><br><span class="line">归档文件，但是压缩的归档文件通常会使用 gzip 进行压缩。这个选项告诉</span><br><span class="line">tar 命令在解压缩时使用 gzip 解压缩算法。</span><br><span class="line"></span><br><span class="line">-x：表示提取（解压缩）归档文件。这个选项告诉 tar 命令执行解压缩操作，</span><br><span class="line">将归档文件中的内容提取到文件系统中。</span><br><span class="line"></span><br><span class="line">-v：表示详细模式（verbose mode）。这个选项告诉 tar 命令在执行操作时</span><br><span class="line">显示详细的输出，以便用户可以看到正在进行的操作和提取的文件列表。</span><br><span class="line"></span><br><span class="line">-f：表示指定归档文件。这个选项后面需要指定要操作的归档文件的名称。</span><br><span class="line">在这个命令中，redis-6.2.1.tar.gz 是要解压缩的归档文件的名称。</span><br></pre></td></tr></table></figure><h4 id="make-distclean">make distclean</h4><p>用于清理并还原由 GNU Make 构建过程生成的文件和目录。它通常用于清理构建环境，以便重新开始构建过程或将项目还原到初始状态。</p><h4 id="vi命令打开的文件搜索">vi命令打开的文件搜索</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">在 Vi 编辑器中，你可以使用 / 命令来搜索打开的文件中的特定内容。以下是搜索的基本步骤：</span><br><span class="line"></span><br><span class="line">打开 Vi 编辑器：</span><br><span class="line">在终端中输入 vi 文件名，其中 文件名 是你要编辑的文件的名称。</span><br><span class="line"></span><br><span class="line">进入搜索模式：</span><br><span class="line">按下 / 键进入搜索模式。此时，你将在 Vi 编辑器的底部看到一个斜线 / 作为提示符。</span><br><span class="line"></span><br><span class="line">输入搜索内容：</span><br><span class="line">在斜线 / 后面输入你要搜索的内容，并按下回车键。Vi 将会定位到第一个匹配到的内容。</span><br><span class="line"></span><br><span class="line">查看搜索结果：</span><br><span class="line">Vi 将会高亮显示匹配到的搜索结果。按下 n 键可以跳转到下一个匹配项，按下 N 键可以跳转到上一个匹配项。</span><br><span class="line"></span><br><span class="line">退出搜索模式：</span><br><span class="line">如果你想退出搜索模式并返回正常编辑模式，按下 Esc 键。</span><br></pre></td></tr></table></figure><h4 id="阿里云非root用户无法远程登录：">阿里云非root用户无法远程登录：</h4><p><a href="https://blog.csdn.net/weixin_42041419/article/details/104774027">阿里云 root ssh远程登录 及 普通非root用户 ssh远程登录 Ubuntu1604_ecs除了root用户_哒哒哒哒哒撞的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html"> &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h4 id=&quot;云服务器的实例id可以修改吗？&quot;&gt;云服务器的实例id可以修改吗？&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://help.aliyun.com/zh/ecs/user-</summary>
      
    
    
    
    <category term="杂项" scheme="http://www.bojiboqi.fun/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="零散知识点" scheme="http://www.bojiboqi.fun/tags/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Redis尚硅谷课件</title>
    <link href="http://www.bojiboqi.fun/2024/01/26/%E5%B0%9A%E7%A1%85%E8%B0%B7_Redis6%E8%AF%BE%E4%BB%B6/"/>
    <id>http://www.bojiboqi.fun/2024/01/26/%E5%B0%9A%E7%A1%85%E8%B0%B7_Redis6%E8%AF%BE%E4%BB%B6/</id>
    <published>2024-01-26T10:55:43.354Z</published>
    <updated>2024-01-26T10:56:57.476Z</updated>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h2 id="框架高级课程系列之Redis6">框架高级课程系列之Redis6</h2><p>尚硅谷JavaEE教研组</p><ol><li><strong>NoSQL数据库简介</strong><ol><li><strong>技术发展</strong></li></ol></li></ol><p>技术的分类<br>1、解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN<br>2、解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis<br>3、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</p><pre><code>  1. **Web1.0时代**</code></pre><p>Web1.0的时代，数据访问量很有限(数据量只是部署到一个服务器中，可是一个服务器的访问量是有上限的），用一夫当关的高性能的单点服务器可以解决大部分问题。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730024175-de0e4e42-179e-4e3b-895e-17700759e95e.png#averageHue=%23f5f5f4&amp;id=bVpXM&amp;originHeight=206&amp;originWidth=625&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **Web2.0时代**</code></pre><p>随着Web2.0的时代的到来，用户访问量大幅度提升，同时产生了大量的用户数据。加上后来的智能移动设备的普及，所有的互联网平台都面临了巨大的性能挑战。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730024434-0ade84eb-da30-4a92-ace5-09cea2dc1024.png#averageHue=%23fbfbf9&amp;id=QgJNI&amp;originHeight=249&amp;originWidth=549&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **解决CPU及内存压力**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730024678-7d3c02dc-2b5c-41d2-b8c9-b877787a94cb.jpeg#averageHue=%23fdfdfb&amp;id=RMHWz&amp;originHeight=412&amp;originWidth=612&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **解决IO压力**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730024920-7b0502f1-7db6-46a2-b691-dde5d51cfec8.jpeg#averageHue=%23ecdac9&amp;id=iztPi&amp;originHeight=395&amp;originWidth=534&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>NoSQL数据库</strong><ol><li><strong>NoSQL数据库概述</strong></li></ol></li></ol><p>NoSQL(NoSQL = <strong>Not Only SQL</strong> )，意即“不仅仅是SQL”，泛指<strong>非关系型的数据库</strong>。<br>NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。</p><ul><li><p>不遵循SQL标准。</p></li><li><p>不支持ACID。</p></li><li><p>远超于SQL的性能。<br>1. **NoSQL适用场景 **</p></li><li><p>对数据高并发的读写</p></li><li><p>海量数据的读写</p></li><li><p>对数据高可扩展性的<br>1. <strong>NoSQL不适用场景</strong></p></li><li><p>需要事务支持</p></li><li><p>基于sql的结构化查询存储，处理复杂的关系,需要即席查询。</p></li><li><p><strong>（用不着sql的和用了sql也不行的情况，请考虑用NoSql）</strong><br>1. <strong>Memcache</strong><br>| <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730025094-1199db9b-a0b2-4ad7-86d8-c2d6f03e7b47.jpeg#averageHue=%237a7771&amp;id=kcfXq&amp;originHeight=81&amp;originWidth=78&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""> |</p></li><li><p>很早出现的NoSql数据库</p></li><li><p>数据都在内存中，一般不持久化</p></li><li><p>支持简单的key-value模式，支持类型单一</p></li><li><p>一般是作为缓存数据库辅助持久化的数据库<br>|<br>| — | — |</p><pre><code>1. **Redis**</code></pre></li></ul><p>| <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730025274-325bc689-39ae-48c4-b6bc-3994276b632d.jpeg#averageHue=%23583b39&amp;id=Kyfuz&amp;originHeight=58&amp;originWidth=157&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""> |</p><ul><li><p>几乎覆盖了Memcached的绝大部分功能</p></li><li><p>数据都在内存中，支持持久化，主要用作备份恢复</p></li><li><p>除了支持简单的key-value模式，还支持多种数据结构的存储，比如 list、set、hash、zset等。</p></li><li><p>一般是作为缓存数据库辅助持久化的数据库<br>|<br>| — | — |</p><pre><code>1. **MongoDB**</code></pre></li></ul><p>| <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730025458-d1ba96a0-c4b1-4d64-8c1b-19dfaca31068.jpeg#averageHue=%23353638&amp;id=xvUtK&amp;originHeight=60&amp;originWidth=172&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>  |</p><ul><li><p>高性能、开源、模式自由(schema  free)的<strong>文档型数据库</strong></p></li><li><p>数据都在内存中， 如果内存不足，把不常用的数据保存到硬盘</p></li><li><p>虽然是key-value模式，但是对value（尤其是<strong>json</strong>）提供了丰富的查询功能</p></li><li><p>支持二进制数据及大型对象</p></li><li><p>可以根据数据的特点<strong>替代RDBMS</strong> ，成为独立的数据库。或者配合RDBMS，存储特定的数据。<br>|<br>| — | — |</p><ol><li><strong>行式存储数据库（大数据时代）</strong><ol><li><strong>行式数据库</strong></li></ol></li></ol></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730025714-33f52a5c-1350-4b6a-b103-4390136ce59a.jpeg#averageHue=%23fefefc&amp;id=aR4FU&amp;originHeight=294&amp;originWidth=614&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **列式数据库**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730025979-8afc701f-d64a-4b50-b1af-29add5d7ef85.jpeg#averageHue=%23fefefc&amp;id=To3RC&amp;originHeight=297&amp;originWidth=615&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>     1. **Hbase**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730026188-acabbd4f-c8b9-487d-a7c7-4c56f3e7ec94.jpeg#averageHue=%23e0bbb8&amp;id=p0QYN&amp;originHeight=68&amp;originWidth=197&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>HBase是<strong>Hadoop</strong>项目中的数据库。它用于需要对大量的数据进行随机、实时的读写操作的场景中。<br>HBase的目标就是处理数据量<strong>非常庞大</strong>的表，可以用<strong>普通的计算机</strong>处理超过<strong>10亿行数据</strong>，还可处理有数百万<strong>列</strong>元素的数据表。</p><pre><code>     1. **Cassandra[kəˈsændrə]**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730026415-e41587d3-9c91-4657-a9da-ae4d12dc7b51.jpeg#averageHue=%2396be5e&amp;id=ZYRSN&amp;originHeight=79&amp;originWidth=316&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>Apache Cassandra是一款免费的开源NoSQL数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的<strong>海量数据集(数据量通常达到PB级别)</strong>。在众多显著特性当中，Cassandra最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程。</p><p>| 计算机存储单位 计算机存储单位一般用B，KB，MB，GB，TB，EB，ZB，YB，BB来表示，它们之间的关系是：<br>位 bit (比特)(Binary Digits)：存放一位二进制数，即 0 或 1，最小的存储单位。<br>字节 byte：8个二进制位为一个字节(B)，最常用的单位。<br>1KB (Kilobyte 千字节)=1024B，<br>1MB (Megabyte 兆字节 简称“兆”)=1024KB，<br>1GB (Gigabyte 吉字节 又称“千兆”)=1024MB，<br>1TB (Trillionbyte 万亿字节 太字节)=1024GB，其中1024=2^10 ( 2 的10次方)，<br>1PB（Petabyte 千万亿字节 拍字节）=1024TB，<br>1EB（Exabyte 百亿亿字节 艾字节）=1024PB，<br>1ZB (Zettabyte 十万亿亿字节 泽字节)= 1024 EB,<br>1YB (Jottabyte 一亿亿亿字节 尧字节)= 1024 ZB,<br>1BB (Brontobyte 一千亿亿亿字节)= 1024 YB.</p><table><thead><tr><th>注：“兆”为百万级数量单位。</th></tr></thead></table><ol><li><strong>图关系型数据库</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730026617-54037f85-76e9-436a-a371-2025ee7eb66e.jpeg#averageHue=%23256d7e&amp;id=lVgOG&amp;originHeight=45&amp;originWidth=184&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>主要应用：社会关系，公共交通网络，地图及网络拓谱(n*(n-1)/2)<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730026840-d4e86748-4ccc-492d-bb02-a042f37e3178.jpeg#averageHue=%23fcfcfc&amp;id=Qe1bj&amp;originHeight=374&amp;originWidth=614&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>DB-Engines 数据库排名</strong></li></ol><p><a href="http://db-engines.com/en/ranking"><strong>http://db-engines.com/en/ranking</strong></a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730027053-000a8467-9e14-4d82-9d9b-67acd902b0bf.png#averageHue=%23f4f1f1&amp;id=KR0mx&amp;originHeight=529&amp;originWidth=1030&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>Redis概述安装</strong></li></ol><ul><li>Redis是一个开源的key-value存储系统。</li><li>和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。</li><li>这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</li><li>在此基础上，Redis支持各种不同方式的排序。</li><li>与memcached一样，为了保证效率，数据都是缓存在内存中。</li><li>区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</li><li>并且在此基础上实现了master-slave(主从)同步。<ol><li><strong>应用场景</strong><ol><li><strong>配合关系型数据库做高速缓存</strong></li></ol></li></ol></li><li>高频次，热门访问的数据，降低数据库IO</li><li>分布式架构，做session共享</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730027296-d0ed1746-398d-4ad6-a069-95a13289b15e.jpeg#averageHue=%23fefefe&amp;id=ytubD&amp;originHeight=288&amp;originWidth=612&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **多样的数据结构存储持久化数据**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730027552-e85a412b-f826-4aeb-90f4-3d3938f57f33.jpeg#averageHue=%23f6e1b3&amp;id=BvZuL&amp;originHeight=259&amp;originWidth=589&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>Redis安装</strong><br>| Redis官方网站 | Redis中文官方网站 |<br>| — | — |<br>| <a href="http://redis.io"><strong>http://redis.io</strong></a> | <a href="http://redis.cn/">http://redis.cn/</a> |</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730027790-fc5e341b-4503-46d1-be3d-25f94aa9768d.png#averageHue=%23d8d7d7&amp;id=ZUvxl&amp;originHeight=520&amp;originWidth=904&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730028065-2e2e9d14-3fa4-4681-b917-8fb752aaec0a.png#averageHue=%23e7e6e5&amp;id=cNR9K&amp;originHeight=602&amp;originWidth=868&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **安装版本**</code></pre><ul><li>6.2.1 for Linux（redis-6.2.1.tar.gz）</li><li>不用考虑在windows环境下对Redis的支持</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730028304-e77217ee-2e83-47d8-b3d7-113d77246779.jpeg#averageHue=%23e3e1dc&amp;id=AXZed&amp;originHeight=62&amp;originWidth=618&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **安装步骤**     1. **准备工作：下载安装最新版的gcc编译器**</code></pre><p>安装C 语言的编译环境<br><strong>yum install centos-release-scl scl-utils-build</strong><br><strong>yum install -y devtoolset-8-toolchain</strong><br><strong>scl enable devtoolset-8 bash</strong><br>**测试 gcc版本 **<br><strong>gcc --version</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730028505-f0f903ef-6226-47d3-b2ca-0e33aaf8c6e4.png#averageHue=%23110d09&amp;id=l2q01&amp;originHeight=95&amp;originWidth=724&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>     1. **下载redis-6.2.1.tar.gz放/opt目录**     2. **解压命令：tar -zxvf redis-6.2.1.tar.gz**     3. **解压完成后进入目录：cd redis-6.2.1**     4. **在redis-6.2.1目录下再次执行make命令（只是编译好）**     5. **如果没有准备好C语言编译环境，make 会报错—Jemalloc/jemalloc.h：没有那个文件**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730028763-7c216a0e-fd7c-439c-b8f4-3e83a3176204.jpeg#averageHue=%230b0908&amp;id=qjmPY&amp;originHeight=235&amp;originWidth=610&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>     1. **解决方案：运行make distclean**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730029022-e087da3f-8cfa-43c0-b7ab-f21c02ebb5f6.jpeg#averageHue=%23080706&amp;id=K3tab&amp;originHeight=165&amp;originWidth=613&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>     1. **在redis-6.2.1目录下再次执行make命令（只是编译好）**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730029271-b5265504-b824-449e-b6d9-9ce0cac16298.jpeg#averageHue=%230d0a06&amp;id=ZqZ35&amp;originHeight=234&amp;originWidth=311&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>     1. **跳过make test 继续执行: make install**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730029545-606e6f99-0021-4103-a63b-19121e66c882.jpeg#averageHue=%23584f46&amp;id=KtAlt&amp;originHeight=204&amp;originWidth=382&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **安装目录：/**usr/local/bin</code></pre><p>查看默认安装目录：<br>redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何<br>redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲<br>redis-check-dump：修复有问题的dump.rdb文件<br>redis-sentinel：Redis集群使用<br>redis-server：Redis服务器启动命令<br>redis-cli：客户端，操作入口</p><pre><code>  1. **前台启动（不推荐）**</code></pre><p>前台启动，命令行窗口不能关闭，否则服务器停止<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730029828-3bb4bd46-5323-4e46-b477-60de7a51a16f.jpeg#averageHue=%23443f39&amp;id=pNpen&amp;originHeight=441&amp;originWidth=619&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **后台启动（推荐）**     1. **备份redis.conf**</code></pre><p>拷贝一份redis.conf到其他目录<br>cp  /opt/redis-3.2.5/redis.conf  /myredis</p><pre><code>     1. **后台启动设置daemonize no改成yes**</code></pre><p>修改redis.conf(128行)文件将里面的daemonize no 改成 yes，让服务在后台启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Redis daemonize介绍</span><br><span class="line"></span><br><span class="line">1、daemonize介绍</span><br><span class="line"></span><br><span class="line">A、redis.conf配置文件中daemonize守护线程，默认是NO。</span><br><span class="line">B、daemonize是用来指定redis是否要用守护线程的方式启动。</span><br><span class="line">2、daemonize 设置yes或者no区别</span><br><span class="line"></span><br><span class="line">daemonize:yes:redis采用的是单进程多线程的模式。当redis.conf中选项</span><br><span class="line">daemonize设置成yes时，代表开启守护进程模式。在该模式下，</span><br><span class="line">redis会在后台运行，并将进程pid号写入至redis.conf选项pidfile</span><br><span class="line">设置的文件中，此时redis将一直运行，除非手动kill该进程。（有时候手动</span><br><span class="line">杀死了redis进程但是用ps -ef | grep redis 发现又以新的pid重启了，那</span><br><span class="line">可能是有父进程自动生成了redis进程。这个时候可以使用</span><br><span class="line">service redis-server stop命令关闭redis进程同时让父进程无法重启redis</span><br><span class="line">进程）。service redis-server stop命令会保存内存中的数据到磁盘上，</span><br><span class="line">然后关闭。解决无法关闭redis的方法2:</span><br><span class="line"></span><br><span class="line">daemonize:no: 当daemonize选项设置成no时，当前界面将进入redis</span><br><span class="line">的命令行界面，exit强制退出或者关闭连接工具(putty,xshell等)都</span><br><span class="line">会导致redis进程退出。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis中的daemonize配置为yes时，表示开启守护进程模式，redis会在后台运行，</span><br><span class="line">并将进程pid号写入至redis.conf选项pidfile设置的文件中，此时redis将一直运</span><br><span class="line">行，除非手动kill该进程</span><br><span class="line">如果你想要杀死redis进程，你可以先用ps -ef | grep redis-server命令</span><br><span class="line">找到redis的进程号，然后用sudo kill &lt;pid&gt;命令强制终止该进程</span><br><span class="line">如果你发现redis进程被重启了，可能是因为有其他的父进程在监控它，</span><br><span class="line">你可以用ps -o ppid= &lt;pid&gt;命令查看是否有父进程存在，</span><br><span class="line">如果有，你也需要杀死父进程</span><br></pre></td></tr></table></figure><pre><code>     1. **Redis启动**</code></pre><p>redis-server/myredis/redis.conf<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730030045-794a9dd4-34b6-457a-9354-349986f54973.jpeg#averageHue=%23504a41&amp;id=evehi&amp;originHeight=70&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>     1. **用客户端访问：redis-cli**</code></pre><ol><li></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730030271-7201ddb3-8d85-46f3-a8c9-cc0a74976dbd.jpeg#averageHue=%23395a32&amp;id=C6OLI&amp;originHeight=41&amp;originWidth=218&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>     1. **多个端口可以：redis-cli -p6379**</code></pre><p><a href="https://www.cnblogs.com/kongzhongqijing/p/6867960.html">redis cli命令 - milkty - 博客园</a></p><pre><code>     2. **测试验证： ping**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730030475-37d148f6-3826-4a8e-b952-d09b8b6404ea.jpeg#averageHue=%23635a4d&amp;id=RecC7&amp;originHeight=38&amp;originWidth=193&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>     1. **Redis关闭**</code></pre><p>单实例关闭：redis-cli shutdown<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730030719-2395f73a-ba68-46e1-b311-07705f9fc5c5.jpeg#averageHue=%234f473f&amp;id=xhvma&amp;originHeight=68&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>也可以进入终端后再关闭<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730030957-49053f95-1d0d-40b6-ac2f-b1c8c7941dff.jpeg#averageHue=%23676054&amp;id=QlgGg&amp;originHeight=41&amp;originWidth=231&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>多实例关闭，指定端口关闭：redis-cli -p 6379 shutdown<br>也可以找到redis的进程号然后用kill -9 pid杀掉也可以。</p><pre><code>  1. **Redis介绍相关知识**</code></pre><p>| 端口6379从何而来<br>Alessia  Merz<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730031186-7ab5b215-6ce9-4ce7-abb8-d9cce1f5422e.jpeg#averageHue=%237c7362&amp;id=aDfhF&amp;originHeight=72&amp;originWidth=136&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""> | 默认16个数据库，类似数组下标从0开始，初始默认使用0号库<br>使用命令 select   <dbid>来切换数据库。如: select 8<br>统一密码管理，所有库同样密码。<br>dbsize查看当前数据库的key的数量<br>flushdb清空当前库<br>flushall通杀全部库 |<br>| — | — |</p><p>Redis是单线程+多路IO复用技术<br>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）<br>串行   vs   多线程+锁（memcached） vs   单线程+多路IO复用(Redis)<br>（与Memcache三点不同: 支持多数据类型，支持持久化，单线程+多路IO复用）<br><img src="https://cdn.nlark.com/yuque/0/2023/gif/28066124/1693730031481-b7e58f7f-b4d9-4945-9a5d-ed8c0b68742a.gif#averageHue=%23f8f6f6&amp;id=MKIQH&amp;originHeight=119&amp;originWidth=400&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693795465201-5ba384c5-5020-4e21-8c5b-8f44ace04a47.png#averageHue=%23fefdfa&amp;clientId=uab116c27-7b29-4&amp;from=paste&amp;height=306&amp;id=uef5e8a80&amp;originHeight=383&amp;originWidth=686&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=54293&amp;status=done&amp;style=none&amp;taskId=u816f3de5-a661-48c5-95b1-d89f347cf1f&amp;title=&amp;width=548.8" alt="image.png"></p><ol><li><strong>常用五大数据类型</strong></li></ol><p>哪里去获得redis常见数据类型操作命令<a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p><ol><li><strong>Redis键(key)</strong></li></ol><p>keys *查看当前库所有key    (匹配：keys *1)<br>exists key判断某个key是否存在（返回为1就存在，返回为0就不存在）<br>type key 查看你的key是什么类型（使用set 10 10 设置的值key仍旧是string)<br>del key       删除指定的key数据<br>unlink key   根据value选择非阻塞删除(异步删除，并不是在执行命令的时候就删除了数据）<br>仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。<br>expire key 10   10秒钟：为给定的key设置过期时间（过期的 key 会被自动删除，不再可用。）<br>ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期，返回的正数表示还有多少s过期。</p><p>select命令切换数据库<br>dbsize查看当前数据库的key的数量<br>flushdb清空当前库<br>flushall通杀全部库</p><ol><li><strong>Redis字符串(String)</strong><ol><li><strong>简介</strong></li></ol></li></ol><p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。<br>String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。<br>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</p><pre><code>  1. **常用命令**</code></pre><p>set   <key><value>添加键值对<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730031776-944ce1d5-008e-44e0-8684-91a112c09a7a.png#averageHue=%230d0b0a&amp;id=JGNaN&amp;originHeight=35&amp;originWidth=972&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>*NX：当数据库中key不存在时，可以将key-value添加数据库<br>*XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥<br>*EX：key的超时秒数<br>*PX：key的超时毫秒数，与EX互斥</p><p>get   <key>查询对应键值<br>append  <key><value>将给定的<value> 追加到原值的末尾（返回值是追加后的value字符串的长度）<br>strlen  <key>获得值的长度<br>setnx  <key><value>只有在 key 不存在时    设置 key 的值（如果key存在时，无法覆盖原来的key)</p><p>incr  <key><br>将 key 中储存的数字值增1<br>只能对数字值操作，如果为空，新增值为1<br>decr  <key><br>将 key 中储存的数字值减1<br>只能对数字值操作，如果为空，新增值为-1<br>incr和decr的返回值都是加1减1的结果。<br>incrby / decrby  <key>&lt;步长&gt;将 key 中储存的数字值增减。自定义步长。（返回值也是增加或者减少后的值）</p><p>| 原子性<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730032028-b7a90996-a232-4807-a889-8e0c4f807ed2.jpeg#averageHue=%23f4f3f2&amp;id=aBiOH&amp;originHeight=138&amp;originWidth=244&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>所谓<strong>原子</strong>操作是指不会被线程调度机制打断的操作；<br>这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。<br>（1）在单线程中， 能够在单条指令中完成的操作都可以认为是&quot;原子操作&quot;，因为中断只能发生于指令之间。<br>（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。<br>Redis单命令的原子性主要得益于Redis的单线程。<br><strong>案例：</strong><br>java中的i++是否是原子操作？不是<strong>不是</strong></p><table><thead><tr><th>i=0;两个线程分别对i进行++100次,值是多少？不确定（2 -200）** 2~200**</th></tr></thead></table><p>mset  <key1><value1><key2><value2>  …<br>同时设置一个或多个 key-value对<br>mget  <key1><key2><key3> …<br>同时获取一个或多个 value<br>msetnx <key1><value1><key2><value2>  …<br>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。<br><strong>原子性，有一个失败则都失败（添加key和value失败）</strong></p><p>getrange  <key>&lt;起始位置&gt;&lt;结束位置&gt;<br>获得值的范围，类似java中的substring，<strong>前包，后包（其中的value的第一个值的索引是0）</strong><br>setrange  <key>&lt;起始位置&gt;<value><br>用 <value>  覆写<key>所储存的字符串值，从&lt;起始位置&gt;开始(<strong>索引从0开始</strong>)。</p><p><strong>setex  <key>&lt;过期时间&gt;<value></strong><br>设置键值的同时，设置过期时间，单位秒。<br>getset <key><value><br>以新换旧，设置了新值同时获得旧值。（就是该命令返回值是旧key的值，同时在返回的时候覆盖key的value下次访问key的时候，value就是更改后的值了）</p><pre><code>  1. **数据结构**</code></pre><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730032225-8d06e5d3-1805-4a7e-b541-a20f72392afa.png#averageHue=%23fdf8f4&amp;id=zgqOF&amp;originHeight=121&amp;originWidth=666&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p><ol><li><strong>Redis列表(List)</strong><ol><li><strong>简介</strong></li></ol></li></ol><p>单键多值<br>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。<br>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730032474-62d4cc76-7c20-41cb-9f95-fda5515498c1.jpeg#averageHue=%23fefefc&amp;id=ykK7q&amp;originHeight=92&amp;originWidth=614&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **常用命令**</code></pre><p>lpush/rpush  <key><value1><value2><value3> … 从左边/右边插入一个或多个值。（这里的从左右插入数据，是后面的数据在前面的数据的左边或者右边）<br>lpop/rpop  <key>从左边/右边吐出一个值。值在键在，值光键亡。</p><p>rpoplpush  <key1><key2>从<key1>列表右边吐出一个值，插到<key2>列表左边。</p><p>lrange <key><start><stop><br>按照索引下标获得元素(从左到右)<br>lrange mylist 0 -1   0左边第一个，-1右边第一个，（0-1表示获取所有）<br>lindex <key><index>按照索引下标获得元素(从左到右)<br>llen <key>获得列表长度</p><p>linsert <key>  before <value><newvalue>在<value>的后面插入<newvalue>插入值<br>lrem <key><n><value>从左边删除n个value(从左到右)<br>lset<key><index><value>将列表key下标为index的值替换成value</p><pre><code>  1. **数据结构**</code></pre><p>List的数据结构为快速链表quickList。<br>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。<br>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。<br>当数据量比较多的时候才会改成quicklist。<br>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730032728-a57a2672-9ab9-4127-ac84-260498627670.png#averageHue=%23f1f6fa&amp;id=gpMLd&amp;originHeight=78&amp;originWidth=748&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><ol><li><strong>Redis集合(Set)</strong><ol><li><strong>简介</strong></li></ol></li></ol><p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以<strong>自动排重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。<br>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的<strong>复杂度都是O(1)</strong>。<br>一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变</p><pre><code>  1. **常用命令**</code></pre><p>sadd <key><value1><value2> …<br>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略（返回值是添加成功的个数）<br>smembers <key>取出该集合的所有值。<br>sismember <key><value>判断集合<key>是否为含有该<value>值，有1，没有0<br>scard<key>返回该集合的元素个数。<br>srem <key><value1><value2> … 删除集合中的某个元素。（返回值是成功删除的个数）<br>spop <key><strong>随机从该集合中吐出一个值。（这里的吐出一个值表示从set集合删除一个数）</strong><br>srandmember <key><n>随机从该集合中取出n个值。不会从集合中删除 。<br>smove <source><destination>value把集合中一个值从一个集合移动到另一个集合<br>sinter <key1><key2>返回两个集合的交集元素。（但是并不会删除元素）<br>sunion <key1><key2>返回两个集合的并集元素。（也是一样不会删除颜色）<br>sdiff <key1><key2>返回两个集合的<strong>差集</strong>元素(key1中的，不包含key2中的)会改变k1中的集合。（k1的集合是查缉的元素）<br>sinter  sunion   sdiff 其实就是集合的运算而已。</p><pre><code>  1. **数据结构**</code></pre><p>Set数据结构是dict字典，字典是用哈希表实现的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ict 字典是指 Python 语言中的一种数据类型，它是一种可变的、无序的、可存储任意类型对象的容器。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">这里所说的所有的 value 都指向同一个内部值，是指 Redis 的 set 结构中，</span><br><span class="line">每个元素的 value 都是一个特殊的常量，叫做 REDIS_SHARED_INTEGERS ，</span><br><span class="line">它是一个包含 0 到 9999 的整数数组，用于节省内存空间。</span><br><span class="line">https://redis.io/commands/set/https://www.runoob.com/redis/strings-set.html</span><br><span class="line"></span><br><span class="line">也就是说，Redis 的 set 结构中，每个元素的 key 是实际存储的字符串值，</span><br><span class="line">而每个元素的 value 都是 REDIS_SHARED_INTEGERS[0] ，这个值在内存中</span><br><span class="line">只有一份，所有的 set 元素都共享它。</span><br><span class="line">https://redis.io/commands/set/https://www.runoob.com/redis/strings-set.html</span><br><span class="line"></span><br><span class="line">这样做的好处是，Redis 可以用 hash 结构来实现 set 的功能，</span><br><span class="line">而不需要额外分配内存空间来存储每个元素的 value </span><br></pre></td></tr></table></figure><ol><li><strong>Redis哈希(Hash)</strong><ol><li><strong>简介</strong></li></ol></li></ol><p>Redis hash 是一个键值对集合。<br>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。<br>类似Java里面的Map&lt;String,Object&gt;<br>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储<br>主要有以下2种存储方式：</p><p>| <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730032990-9e5593f0-4887-4ab7-ac65-8df3fd71ea0e.jpeg#averageHue=%23fcfdf9&amp;id=K6svc&amp;originHeight=161&amp;originWidth=271&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>每次修改用户的某个属性需要，先反序列化改好后再序列化回去。开销较大。 | <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730033258-17c5c182-f458-4034-92ce-18cd2b9d6faa.jpeg#averageHue=%23ececec&amp;id=VzaaA&amp;originHeight=156&amp;originWidth=277&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>用户ID数据冗余 |<br>| — | — |</p><p>| <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730033537-c99a4769-d614-44a1-81d9-f4bc881c84ce.jpeg#averageHue=%23f8f9f5&amp;id=TC7nl&amp;originHeight=151&amp;originWidth=320&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><table><thead><tr><th><strong>通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题</strong></th></tr></thead></table><pre><code>  1. **常用命令**</code></pre><p>hset <key><field><value>:给<key>集合中的  <field>键赋值<value></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> hset user:10 id 1</span><br><span class="line">给hash中添加一个key为user，fild为id，value为1的对象.如果存储的值为中文的</span><br><span class="line">话取出会有问题的</span><br></pre></td></tr></table></figure><p>hget <key1><field>:从<key1>集合<field>取出 value  eg: hget user:10 name<br>hmset <key1><field1><value1><field2><value2>… ：批量设置hash的值 eg:<br>hmset user:11 id 2 name lishi age 40<br>hexists<key1><field>查看哈希表 key 中，给定域 field 是否存在，存在返回1，不存在返回0。 eg: hexists user:10 id<br>判断user为10中是否存在id的field。<br>hkeys <key>列出该hash集合的所有field<br>hvals <key>列出该hash集合的所有value<br>hincrby <key><field><increment>：为哈希表 key 中的域 field 的值加上增量，返回值是fileld增加后的值。<br>hsetnx <key><field><value>将哈希表 key 中的域 中添加为 value的field ，当且仅当域 field 不存在时才能添加成功 .</p><pre><code>  1. **数据结构**</code></pre><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p><ol><li>**Redis有序集合Zset(sorted set) **<ol><li><strong>简介</strong></li></ol></li></ol><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。<br>不同之处是有序集合的每个成员都关联了一个<strong>评分（score）</strong>,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。<br>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。<br>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p><pre><code>  1. **常用命令**</code></pre><p>zadd  <key><score1><value1><score2><value2>…<br>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。<br>**zrange <key><start><stop>  [WITHSCORES]   **<br>返回有序集 key 中，下标在<start><stop>之间的元素<br>带WITHSCORES，可以让分数一起和值返回到结果集。<br>zrangebyscore key minmax [withscores] [limit offset count]<br>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。<br>zrevrangebyscore key maxmin [withscores] [limit offset count]<br>同上，改为从大到小排列。<br>zincrby <key><increment><value>      为元素的score加上增量<br>zrem  <key><value>删除该集合下，指定值的元素<br>zcount <key><min><max>统计该集合，分数区间内的元素个数<br>zrank <key><value>返回该值在集合中的排名，从0开始。<br>案例：如何利用zset实现一个文章访问量的排行榜？<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730033775-1fc94010-b543-452e-87d5-6894662bf634.jpeg#averageHue=%23060605&amp;id=Oe0tL&amp;originHeight=172&amp;originWidth=451&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693831031687-92c85b21-af19-4cff-b7ed-8558e780aaf7.png#averageHue=%23323a7b&amp;clientId=u937b6ec7-0521-4&amp;from=paste&amp;height=709&amp;id=u3d405017&amp;originHeight=886&amp;originWidth=1549&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=1497218&amp;status=done&amp;style=none&amp;taskId=u997b05f6-e2cc-4eb9-b1cf-74049528801&amp;title=&amp;width=1239.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693831423299-38eeba85-6ba5-49e0-a377-c4291397ccce.png#averageHue=%23383069&amp;clientId=u937b6ec7-0521-4&amp;from=paste&amp;height=464&amp;id=u0219068c&amp;originHeight=580&amp;originWidth=1175&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=700443&amp;status=done&amp;style=none&amp;taskId=u7e67e8ec-1c7d-4a5d-8da9-990740ef1b9&amp;title=&amp;width=940" alt="image.png"></p><pre><code>  1. **数据结构**</code></pre><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。<br>zset底层使用了两个数据结构<br>（1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。<br>（2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</p><pre><code>  1. **跳跃表（跳表）**</code></pre><p>1、简介<br>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。<br>2、实例<br>对比有序链表和跳跃表，从链表中查询出51</p><ol><li>有序链表</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730034017-e622ecb5-18ab-4430-aaed-bacc99ffdf92.png#averageHue=%23d5d5d4&amp;id=kTuYG&amp;originHeight=53&amp;originWidth=737&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p><ol><li>跳跃表</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730034386-79f4163c-95b0-4766-9ffa-fe70a3da037a.png#averageHue=%23e2e1e1&amp;id=OvSb1&amp;originHeight=228&amp;originWidth=778&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>从第2层开始，1节点比51节点小，向后比较。<br>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层<br>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下<br>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p><p>从此可以看出跳跃表比有序链表效率要高<br><a href="https://zhuanlan.zhihu.com/p/260075092">跳跃表详解</a></p><ol><li><strong>Redis配置文件介绍</strong></li></ol><p>自定义目录：/myredis/redis.conf</p><ol><li>**###Units单位### **</li></ol><p>配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit<br>大小写不敏感<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730034656-ba811a1d-4d97-402f-8c91-3c2edfcbc1a0.jpeg#averageHue=%23433e20&amp;id=HtasJ&amp;originHeight=297&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>###INCLUDES包含###</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730035011-c2232a6e-ac70-47b4-9c82-0dde4f477c8d.jpeg#averageHue=%23121106&amp;id=VgJME&amp;originHeight=250&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>类似jsp中的include，多实例的情况可以把公用的配置文件提取出来</p><ol><li><strong>###网络相关配置 ###</strong><ol><li><strong>bind</strong></li></ol></li></ol><p>默认情况bind=127.0.0.1只能接受本机的访问请求<br>不写的情况下，无限制接受任何ip地址的访问<br>生产环境肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要将其注释掉<br>如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730035267-6c663b0c-3c59-45f4-90ab-3ce0f7fee46d.jpeg#averageHue=%23121105&amp;id=HCbik&amp;originHeight=324&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>保存配置，停止服务，重启启动查看进程，不再是本机访问了。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730035537-13ecade4-af50-4ba3-bffc-6db989132305.jpeg#averageHue=%230e0b0a&amp;id=bF83z&amp;originHeight=115&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **protected-mode**</code></pre><p>将本机访问保护模式设置no<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730035811-d33ade2e-e632-42e6-983a-0cda31729d0b.jpeg#averageHue=%23141408&amp;id=iWb21&amp;originHeight=282&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **Port**</code></pre><p>端口号，默认 6379<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730036042-accb83bb-44e4-4823-914f-5ce7a9d5b7d0.jpeg#averageHue=%2319190c&amp;id=AFndT&amp;originHeight=49&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **tcp-backlog**</code></pre><p>设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。<br>在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。<br>注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值（128），所以需要确认增大/proc/sys/net/core/somaxconn和/proc/sys/net/ipv4/tcp_max_syn_backlog（128）两个值来达到想要的效果<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730036258-460d724a-fdc6-44f4-ae8e-bf1cb61d6206.jpeg#averageHue=%23181709&amp;id=mzQHJ&amp;originHeight=123&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **timeout**</code></pre><p>一个空闲的客户端维持多少秒会关闭，0表示关闭该功能。即永不关闭。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730036579-56d82572-9069-4270-a220-c1ae349220e7.jpeg#averageHue=%233f3918&amp;id=uJCD5&amp;originHeight=172&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **tcp-keepalive**</code></pre><p>对访问客户端的一种心跳检测，每个n秒检测一次。<br>单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730036855-e756b5c6-337a-46c7-9e45-437a9e839122.jpeg#averageHue=%233b3616&amp;id=oa00J&amp;originHeight=238&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>###GENERAL通用###</strong><ol><li><strong>daemonize</strong></li></ol></li></ol><p>是否为后台进程，设置为yes<br>守护进程，后台启动<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730037109-0c0be9df-1f8a-415e-b6cf-a29983811cec.jpeg#averageHue=%231b1b0d&amp;id=vJVEz&amp;originHeight=47&amp;originWidth=607&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **pidfile**</code></pre><p>存放pid文件的位置，每个实例会产生一个不同的pid文件<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730037384-bb32e365-75ec-4f41-b5c5-95960eabde47.jpeg#averageHue=%23171709&amp;id=FE36Z&amp;originHeight=151&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **loglevel **</code></pre><p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为<strong>notice</strong><br>四个级别根据使用阶段来选择，生产环境选择notice 或者warning<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730037735-a056dc8c-7e81-4f07-898b-7821baff9e59.jpeg#averageHue=%2319190a&amp;id=ABUFP&amp;originHeight=112&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **logfile **</code></pre><p>日志文件名称<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730037986-95002380-8b6a-4856-915c-e7439c59cbd2.jpeg#averageHue=%230d0e04&amp;id=ZZEqN&amp;originHeight=66&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **databases 16 **</code></pre><p>设定库的数量 默认16，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730038238-3a52dc70-2dc6-46cd-aff3-15695bf3bb31.jpeg#averageHue=%231b1a0e&amp;id=NAV13&amp;originHeight=60&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>###SECURITY安全###</strong><ol><li><strong>设置密码</strong></li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730038485-b721f0bf-38ca-4a40-9eaf-56f55f1e7ad1.jpeg#averageHue=%23161507&amp;id=YZ4fD&amp;originHeight=206&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>访问密码的查看、设置和取消<br>在命令中设置密码，只是临时的。重启redis服务器，密码就还原了。<br>永久设置，需要再配置文件中进行设置。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730038741-02fe699c-751b-4a4e-938f-7d1d4b4daf9e.jpeg#averageHue=%23f8f3f3&amp;id=G7UGU&amp;originHeight=356&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>#### LIMITS限制 ###</strong><ol><li><strong>maxclients</strong></li></ol></li></ol><ul><li>设置redis同时可以与多少个客户端进行连接。</li><li>默认情况下为10000个客户端。</li><li>如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730039000-f90e6ed1-eba5-4226-b9b5-50017f44ffda.jpeg#averageHue=%23111107&amp;id=oWW5t&amp;originHeight=151&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **maxmemory **</code></pre><ul><li>建议<strong>必须设置</strong>，否则，将内存占满，造成服务器宕机</li><li>设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。</li><li>如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。</li><li>但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730039266-f1e3c844-46e9-49db-9ba6-c739649153f3.jpeg#averageHue=%23070802&amp;id=jGg2L&amp;originHeight=350&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **maxmemory-policy**</code></pre><ul><li>volatile-lru：使用LRU算法移除key，只对设置了过期时间的键；（最近最少使用）</li><li>allkeys-lru：在所有集合key中，使用LRU算法移除key</li><li>volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键</li><li>allkeys-random：在所有集合key中，移除随机的key</li><li>volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key</li><li>noeviction：不进行移除。针对写操作，只是返回错误信息</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730039585-06e1a32b-282f-424b-91e0-51c8e44825d2.jpeg#averageHue=%23181707&amp;id=BQlIS&amp;originHeight=348&amp;originWidth=616&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **maxmemory-samples**</code></pre><ul><li>设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个。</li><li>一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730039834-216147c3-2b02-488c-8c31-e35b22d07085.jpeg#averageHue=%23131206&amp;id=tHMcu&amp;originHeight=153&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>Redis的发布和订阅</strong><ol><li><strong>什么是发布和订阅</strong></li></ol></li></ol><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。<br>Redis 客户端可以订阅任意数量的频道。</p><ol><li><strong>Redis的发布和订阅</strong></li></ol><p>1、客户端可以订阅频道如下图<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730040062-c5a4d2ce-fa30-4c07-ad84-6ce4421511db.png#averageHue=%23e7ebd9&amp;id=jba6O&amp;originHeight=214&amp;originWidth=516&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>2、当给这个频道发布消息后，消息就会发送给订阅的客户端<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730040377-91b7001c-de87-47f5-9971-e1b500f6feaf.png#averageHue=%23eaeae9&amp;id=CEjqK&amp;originHeight=303&amp;originWidth=471&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>发布订阅命令行实现</strong></li><li>打开一个客户端订阅channel1</li></ol><p>SUBSCRIBE channel1<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730040629-5d1e893c-fb8a-4320-8280-7284fb8dedac.png#averageHue=%230c0a09&amp;id=wW3l8&amp;originHeight=154&amp;originWidth=541&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>2、打开另一个客户端，给channel1发布消息hello<br>publish channel1 hello<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730040869-9547417c-700c-4bef-9c9d-c650dab1b686.png#averageHue=%23110f0d&amp;id=bv7O0&amp;originHeight=50&amp;originWidth=495&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>返回的1是订阅者数量<br>3、打开第一个客户端可以看到发送的消息<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730041137-08dbd908-930c-46bc-892d-c3975a44515b.png#averageHue=%230a0807&amp;id=Opd93&amp;originHeight=227&amp;originWidth=552&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>注：发布的消息没有持久化，如果在订阅的客户端收不到hello，只能收到订阅后发布的消息</p><ol><li><strong>Redis新数据类型</strong><ol><li><strong>Bitmaps</strong><ol><li><strong>简介</strong></li></ol></li></ol></li></ol><p>现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730041380-1e9c0ca4-5e84-47b2-9984-4647f3a6b1a1.png#averageHue=%23e9e9e9&amp;id=uehK8&amp;originHeight=115&amp;originWidth=628&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>合理地使用操作位能够有效地提高内存使用率和开发效率。<br>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p><ol><li>Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</li><li>Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730041676-b07a50a5-97e1-453e-9c45-420743a1144d.png#averageHue=%23cdcccc&amp;id=DojKK&amp;originHeight=81&amp;originWidth=822&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **命令**</code></pre><p>1、setbit<br>（1）格式<br>setbit<key><offset><value>设置Bitmaps中某个偏移量的值（0或1）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730041887-6e6d1411-b201-4d9c-8da2-5e2e7512b457.png#averageHue=%23110f0d&amp;id=za5A6&amp;originHeight=37&amp;originWidth=519&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>*offset:偏移量从0开始<br>（2）实例<br>每个独立用户是否访问过网站存放在Bitmaps中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的id。<br>设置键的第offset个位的值（从0算起） ， 假设现在有20个用户，userid=1， 6， 11， 15， 19的用户对网站进行了访问， 那么当前Bitmaps初始化结果如图<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730042156-2c62c32d-62a3-45f7-854d-3bf1cf1e489f.png#averageHue=%23ececec&amp;id=KepT0&amp;originHeight=135&amp;originWidth=646&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>unique:users:20201106代表2020-11-06这天的独立访问用户的Bitmaps<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730042383-9e87289b-c3fe-4884-bc89-37897d0108fe.png#averageHue=%23100e0c&amp;id=k5Jkg&amp;originHeight=251&amp;originWidth=652&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>注：<br>很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。<br>在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。<br>2、getbit<br>（1）格式<br>getbit<key><offset>获取Bitmaps中某个偏移量的值<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730042647-7b0094f9-0323-4d9a-a8be-ca2552194b79.png#averageHue=%23100e0c&amp;id=ogPG6&amp;originHeight=35&amp;originWidth=444&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>获取键的第offset位的值（从0开始算）<br>（2）实例<br>获取id=8的用户是否在2020-11-06这天访问过， 返回0说明没有访问过：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730042882-62c46e10-5689-4e65-856e-a6b2ac7468be.png#averageHue=%23100e0c&amp;id=lo73f&amp;originHeight=154&amp;originWidth=633&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>注：因为100根本不存在，所以也是返回0<br>3、bitcount<br>统计<strong>字符串</strong>被设置为1的bit数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。<br>（1）格式<br>bitcount<key>[start end] 统计字符串从start字节到end字节比特值为1的数量<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730043084-62a931d2-c5e0-4b31-b14a-cfe895317f1e.png#averageHue=%2315120f&amp;id=nw0n4&amp;originHeight=29&amp;originWidth=526&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>（2）实例<br>计算2022-11-06这天的独立访问用户数量<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730043338-e4615ff4-d54b-4821-b778-1a9bd1824324.png#averageHue=%230c0a07&amp;id=rcLg5&amp;originHeight=62&amp;originWidth=657&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>start和end代表起始和结束字节数， 下面操作计算用户id在第1个字节到第3个字节之间的独立访问用户数， 对应的用户id是11， 15， 19。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730043539-b573ced4-e2ab-463b-831e-c17c49ba60a6.png#averageHue=%23100d0c&amp;id=VstjJ&amp;originHeight=51&amp;originWidth=662&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>举例： K1 【01000001 01000000  00000000 00100001】，对应【0，1，2，3】<br>bitcount K1 1 2  ： 统计下标1、2字节组中bit=1的个数，即01000000  00000000<br>–》bitcount K1 1 2 　　--》1<br>bitcount K1 1 3  ： 统计下标1、2字节组中bit=1的个数，即01000000  00000000 00100001<br>–》bitcount K1 1 3　　--》3<br>bitcount K1 0 -2  ： 统计下标0到下标倒数第2，字节组中bit=1的个数，即01000001  01000000   00000000<br>–》bitcount K1 0 -2　　--》3<br>注意：redis的setbit设置或清除的是bit位置，而bitcount计算的是byte位置。<br>4、bitop<br>(1)格式<br>bitop  and(or/not/xor) <destkey> [key…]<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730043743-ba80e6ed-b5da-4394-9bcf-19467d02a666.png#averageHue=%2313100e&amp;id=j9TK6&amp;originHeight=29&amp;originWidth=691&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。<br>(2)实例<br>2020-11-04 日访问网站的userid=1,2,5,9。<br>setbit unique:users:20201104 1 1<br>setbit unique:users:20201104 2 1<br>setbit unique:users:20201104 5 1<br>setbit unique:users:20201104 9 1<br>2020-11-03 日访问网站的userid=0,1,4,9。<br>setbit unique:users:20201103 0 1<br>setbit unique:users:20201103 1 1<br>setbit unique:users:20201103 4 1<br>setbit unique:users:20201103 9 1<br>计算出两天都访问过网站的用户数量<br>bitop and unique:users:and:20201104_03<br>unique:users:20201103unique:users:20201104<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730043980-be07c887-3214-4b9d-87c3-d4df59d7233c.png#averageHue=%230a0907&amp;id=seAnr&amp;originHeight=129&amp;originWidth=1181&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>bitop and操作返回值是位串中为1的个数。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730044227-82e0367b-be06-4164-88df-f1f6713b6fc5.png#averageHue=%23f0efef&amp;id=fiQAN&amp;originHeight=394&amp;originWidth=617&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>计算出任意一天都访问过网站的用户数量（例如月活跃就是类似这种） ， 可以使用or求并集<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730044526-f201de03-2143-4c20-9153-9d6aa4f54b63.png#averageHue=%230a0807&amp;id=pl4Ku&amp;originHeight=126&amp;originWidth=1183&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **Bitmaps与set对比**</code></pre><p>假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表</p><table><thead><tr><th>set和Bitmaps存储一天活跃用户对比</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据</td><td></td><td></td><td></td></tr><tr><td>类型</td><td>每个用户id占用空间</td><td>需要存储的用户量</td><td>全部内存量</td></tr><tr><td>集合</td><td></td><td></td><td></td></tr><tr><td>类型</td><td>64位</td><td>50000000</td><td>64位*50000000 = 400MB</td></tr><tr><td>Bitmaps</td><td>1位</td><td>100000000</td><td>1位*100000000 = 12.5MB</td></tr></tbody></table><p>很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的</p><table><thead><tr><th>set和Bitmaps存储独立用户空间对比</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据类型</td><td>一天</td><td>一个月</td><td>一年</td></tr><tr><td>集合类型</td><td>400MB</td><td>12GB</td><td>144GB</td></tr><tr><td>Bitmaps</td><td>12.5MB</td><td>375MB</td><td>4.5GB</td></tr></tbody></table><p>但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0。</p><table><thead><tr><th>set和Bitmaps存储一天活跃用户对比（独立用户比较少）</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据类型</td><td>每个userid占用空间</td><td>需要存储的用户量</td><td>全部内存量</td></tr><tr><td>集合类型</td><td>64位</td><td>100000</td><td>64位*100000 = 800KB</td></tr><tr><td>Bitmaps</td><td>1位</td><td>100000000</td><td>1位*100000000 = 12.5MB</td></tr></tbody></table><ol><li><strong>HyperLogLog</strong><ol><li><strong>简介</strong></li></ol></li></ol><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。<br>但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。<br>解决基数问题有很多种方案：<br>（1）数据存储在MySQL表中，使用distinct count计算不重复个数<br>（2）使用Redis提供的hash、set、bitmaps等数据结构来处理<br>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。<br>能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog<br>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。<br>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。<br>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。<br>什么是基数?<br>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p><pre><code>  1. **命令**</code></pre><p>1、pfadd<br>（1）格式<br>pfadd <key>&lt; element&gt; [element …]   添加指定元素到 HyperLogLog 中<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730044807-6a71eed0-0b1f-44a4-839b-e33e56882e07.png#averageHue=%23100d0c&amp;id=Yw5RO&amp;originHeight=31&amp;originWidth=620&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>（2）实例<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730045083-57372cbe-5fc9-467d-b162-15c621ebaf03.png#averageHue=%23100d0c&amp;id=RDA2W&amp;originHeight=177&amp;originWidth=447&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>将所有元素添加到指定HyperLogLog数据结构中。如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0。<br>2、pfcount<br>（1）格式<br>pfcount<key> [key …] 计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730045284-0ea0a0a4-29f5-4d7a-a2d1-e1d0ff413a83.png#averageHue=%23100e0c&amp;id=ymRaK&amp;originHeight=32&amp;originWidth=482&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>（2）实例<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730045569-ff64944a-93ae-4f3e-b189-25091586aa3a.png#averageHue=%230f0d0b&amp;id=tIUfy&amp;originHeight=375&amp;originWidth=473&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>3、pfmerge<br>（1）格式<br>pfmerge<destkey><sourcekey> [sourcekey …]  将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730045959-ae3fb38f-f426-41e2-9abd-33317a976419.png#averageHue=%23151210&amp;id=bQZBn&amp;originHeight=27&amp;originWidth=744&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>（2）实例<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730046204-9eef0e6b-7a15-410d-83bd-65d4a7d7e358.png#averageHue=%230d0b09&amp;id=KDaCu&amp;originHeight=182&amp;originWidth=495&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>Geospatial</strong><ol><li><strong>简介</strong></li></ol></li></ol><p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p><pre><code>  1. **命令**</code></pre><p>1、geoadd<br>（1）格式<br>geoadd<key>&lt; longitude&gt;<latitude><member> [longitude latitude member…]   添加地理位置（经度，纬度，名称）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730046502-25494722-7483-4493-8757-95fb5196cbc5.png#averageHue=%230b0806&amp;id=aAHRQ&amp;originHeight=30&amp;originWidth=754&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>（2）实例<br>geoadd china:city 121.47 31.23 shanghai<br>geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730046771-cd8f0b9f-c7ec-4cf4-b994-023b74e0753d.png#averageHue=%23070503&amp;id=mzQwF&amp;originHeight=96&amp;originWidth=898&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。<br>有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。<br>当坐标位置超出指定范围时，该命令将会返回一个错误。<br>已经添加的数据，是无法再次往里面添加的。<br>2、geopos<br>（1）格式<br>geopos  <key><member> [member…]  获得指定地区的坐标值<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730047046-9212fba5-b8c3-4ec3-8dd7-ff0823d9c79c.png#averageHue=%230d0a07&amp;id=ujxFG&amp;originHeight=27&amp;originWidth=464&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>（2）实例<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730047304-a8479a43-fdca-4b12-92a1-683084423427.png#averageHue=%23120e0a&amp;id=N5gjj&amp;originHeight=61&amp;originWidth=423&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>3、geodist<br>（1）格式<br>geodist<key><member1><member2>  [m|km|ft|mi ]  获取两个位置之间的直线距离<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730047526-463fa02f-03df-488e-93ed-16c6ff5a7bdb.png#averageHue=%230c0906&amp;id=LaFSb&amp;originHeight=28&amp;originWidth=564&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>（2）实例<br>获取两个位置之间的直线距离<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730047763-e55e7def-edf0-4318-8b5d-4bfb091fa53d.png#averageHue=%23090704&amp;id=OwVHS&amp;originHeight=50&amp;originWidth=557&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>单位：<br>m 表示单位为米[默认值]。<br>km 表示单位为千米。<br>mi 表示单位为英里。<br>ft 表示单位为英尺。<br>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位<br>4、georadius<br>（1）格式<br>georadius<key>&lt; longitude&gt;<latitude>radius  m|km|ft|mi   以给定的经纬度为中心，找出某一半径内的元素<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730048028-db65bfe1-ddcd-4996-a673-88e25f0bfb7d.png#averageHue=%230d0a07&amp;id=giAcC&amp;originHeight=26&amp;originWidth=671&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>经度 纬度 距离 单位<br>（2）实例<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730048304-448a2baf-96e7-44ec-a154-990d2526f401.png#averageHue=%23090604&amp;id=iFc6n&amp;originHeight=60&amp;originWidth=519&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>Redis_Jedis_测试</strong><ol><li><strong>Jedis所需要的jar包</strong><br>| &lt;<strong>dependency</strong>&gt;<br>&lt;<strong>groupId</strong>&gt;redis.clients&lt;/<strong>groupId</strong>&gt;<br>&lt;<strong>artifactId</strong>&gt;jedis&lt;/<strong>artifactId</strong>&gt;<br>&lt;<strong>version</strong>&gt;3.2.0&lt;/<strong>version</strong>&gt;<br>&lt;/<strong>dependency</strong>&gt; |<br>| — |</li></ol></li></ol><p>什么是Jedis?<br>Jedis是redis的java客户端，集成了Redis的命令操作，提供连接池操作。</p><ol><li><strong>连接Redis注意事项</strong></li></ol><p>禁用Linux的防火墙：Linux(CentOS7)里执行命令<br>**systemctl stop/disable firewalld.service   **<br>redis.conf中注释掉bind 127.0.0.1 ,然后 protected-mode no<br>1.查看redis进程的命令： ps -ef | grep redis。<br>2.关于prptected-mode no的解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">protected-mode no 是一个用于关闭 Redis 的保护模式的配置选项。</span><br><span class="line">保护模式是 Redis 3.2 版本后引入的一种安全机制，</span><br><span class="line">它的目的是防止 Redis 实例被外部网络访问和利用。https://www.jianshu.com/p/ddd19ec819dchttps://blog.csdn.net/zzhongcy/article/details/123653851</span><br><span class="line"></span><br><span class="line">当保护模式开启时，如果 Redis 实例没有指定绑定地址（bind）</span><br><span class="line">或者没有设置访问密码（requirepass），那么它只接受来自本地回环地址</span><br><span class="line">（127.0.0.1 或者 ::1）和 Unix 域套接字的连接请求。这样可以避免 </span><br><span class="line">Redis 实例被暴露在公网上，造成数据泄露或者被恶意攻击。https://www.jianshu.com/p/ddd19ec819dchttps://blog.csdn.net/zzhongcy/article/details/123653851</span><br><span class="line"></span><br><span class="line">如果你想让 Redis 实例能够接受来自外部网络的连接请求</span><br><span class="line">，你可以采用以下几种方法之一：</span><br><span class="line"></span><br><span class="line">•  关闭保护模式，将 protected-mode no 设置为 no ，然后重启服务器。</span><br><span class="line">但是这样做需要确保 Redis 实例不会被公网访问，否则会有安全风险。https://www.jianshu.com/p/ddd19ec819dchttps://blog.csdn.net/zzhongcy/article/details/123653851</span><br><span class="line"></span><br><span class="line">•  开启保护模式，但是指定绑定地址（bind），让 Redis 实例只监听特定</span><br><span class="line">的网络接口。例如，如果你想让 Redis 实例只监听 192.168.1.100 这个地址，你可以在配置文件中设置 bind 192.168.1.100 ，然后重启服务器。https://www.jianshu.com/p/ddd19ec819dchttps://blog.csdn.net/zzhongcy/article/details/123653851</span><br><span class="line"></span><br><span class="line">•  开启保护模式，但是设置访问密码（requirepass），让 Redis 实例要</span><br><span class="line">求客户端提供密码才能连接。例如，如果你想让 Redis 实例的密码为 mypass </span><br><span class="line">，你可以在配置文件中设置 requirepass mypass ，然后重启服务器。</span><br><span class="line">https://www.jianshu.com/p/ddd19ec819dchttps://blog.csdn.net/zzhongcy/article/details/123653851</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">命令ps -ef中，选项-ef是两个单独的选项-e和-f的组合。</span><br><span class="line"></span><br><span class="line">-e选项：它表示显示所有进程，而不仅仅是当前用户的进程。它会列出所有</span><br><span class="line">正在运行的进程，包括系统进程和其他用户的进程。</span><br><span class="line"></span><br><span class="line">-f选项：它表示以全格式显示进程信息。它会显示更详细的信息，如进</span><br><span class="line">程的PID（进程ID）、PPID（父进程ID）、CPU使用情况、内存使用情况等。</span><br></pre></td></tr></table></figure><ol><li><p><strong>Jedis常用操作</strong></p><ol><li><strong>创建动态的工程</strong></li><li><strong>创建测试程序</strong><br>| package com.atguigu.jedis;<br>import redis.clients.jedis.Jedis;<br>public class Demo01 {<br>public static void main(String[] args) {<br>Jedis jedis = new Jedis(“192.168.137.3”,6379);//注意这里连接的是redis-server<br>而不是redis-sentinel<br>String pong = jedis.ping();<br>System.out.println(“连接成功：”+pong);<br>jedis.close();<br>}<br>} |<br>| — |</li></ol></li><li><p><strong>测试相关数据类型</strong></p><ol><li><p><strong>Jedis-API:    Key</strong><br>| jedis.<strong>set</strong>(“k1”, “v1”);<br>jedis.set(“k2”, “v2”);<br>jedis.set(“k3”, “v3”);<br>Set<String> keys = jedis.<strong>keys</strong>(“*”);<br>System.out.println(keys.size());<br>for (String key : keys) {<br>System.out.println(key);<br>}<br>System.out.println(jedis.<strong>exists</strong>(“k1”));<br>System.out.println(jedis.<strong>ttl</strong>(“k1”));<br>System.out.println(jedis.<strong>get</strong>(“k1”)); |<br>| — |</p></li><li><p><strong>Jedis-API:    String</strong><br>| jedis.<strong>mset</strong>(“str1”,“v1”,“str2”,“v2”,“str3”,“v3”);<br>System.<em>out</em>.println(jedis.<strong>mget</strong>(“str1”,“str2”,“str3”)); |<br>| — |</p></li><li><p><strong>Jedis-API:    List</strong><br>| List<String> list = jedis.<strong>lrange</strong>(“mylist”,0,-1);<br>for (String element : list) {<br>System.out.println(element);<br>} |<br>| — |</p></li><li><p><strong>Jedis-API:    set</strong><br>| jedis.sadd(“orders”, “order01”);<br>jedis.sadd(“orders”, “order02”);<br>jedis.sadd(“orders”, “order03”);<br>jedis.sadd(“orders”, “order04”);<br>Set<String> smembers = jedis.<strong>smembers</strong>(“orders”);<br>for (String order : smembers) {<br>System.out.println(order);<br>}<br>jedis.<strong>srem</strong>(“orders”, “order02”); |<br>| — |</p></li><li><p><strong>Jedis-API:    hash</strong><br>| jedis.<strong>hset</strong>(“hash1”,“userName”,“lisi”);<br>System.out.println(jedis.<strong>hget</strong>(“hash1”,“userName”));<br>Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();<br>map.put(“telphone”,“13810169999”);<br>map.put(“address”,“atguigu”);<br>map.put(“<a href="mailto:email%22,%22abc@163.com">email&quot;,&quot;abc@163.com</a>”);<br>jedis.<strong>hmset</strong>(“hash2”,map);<br>List<String> result = jedis.<strong>hmget</strong>(“hash2”, “telphone”,“email”);<br>for (String element : result) {<br>System.out.println(element);<br>} |<br>| — |</p></li><li><p><strong>Jedis-API:    zset</strong><br>| jedis.<strong>zadd</strong>(“zset01”, 100d, “z3”);<br>jedis.zadd(“zset01”, 90d, “l4”);<br>jedis.zadd(“zset01”, 80d, “w5”);<br>jedis.zadd(“zset01”, 70d, “z6”);</p></li></ol></li></ol><p>Set<String> zrange = jedis.<strong>zrange</strong>(“zset01”, 0, -1);<br>for (String e : zrange) {<br>System.out.println(e);</p><table><thead><tr><th>}</th></tr></thead></table><ol><li><strong>Redis_Jedis_实例</strong><ol><li><strong>完成一个手机验证码功能</strong></li></ol></li></ol><p>要求：<br>1、输入手机号，点击发送后随机生成6位数字码，2分钟有效<br>2、输入验证码，点击验证，返回成功或失败<br>3、每个手机号每天只能输入3次<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730048567-6aa26936-21dc-4110-8bba-d0bea1ab89f0.jpeg#averageHue=%23eae8e0&amp;id=sLE5A&amp;originHeight=165&amp;originWidth=516&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>Redis与Spring Boot整合</strong></li></ol><p>Spring Boot整合Redis非常简单，只需要按如下步骤整合即可</p><ol><li><p><strong>整合步骤</strong></p></li><li><p>在pom.xml文件中引入redis相关依赖<br>| <em><!-- redis --></em>&lt;<strong>dependency</strong>&gt;<br>&lt;<strong>groupId</strong>&gt;org.springframework.boot&lt;/<strong>groupId</strong>&gt;<br>&lt;<strong>artifactId</strong>&gt;spring-boot-starter-data-redis&lt;/<strong>artifactId</strong>&gt;<br>&lt;/<strong>dependency</strong>&gt;<br><em><!-- spring2.X集成redis所需common-pool2--></em>&lt;<strong>dependency</strong>&gt;<br>&lt;<strong>groupId</strong>&gt;org.apache.commons&lt;/<strong>groupId</strong>&gt;<br>&lt;<strong>artifactId</strong>&gt;commons-pool2&lt;/<strong>artifactId</strong>&gt;<br>&lt;<strong>version</strong>&gt;2.6.0&lt;/<strong>version</strong>&gt;<br>&lt;/<strong>dependency</strong>&gt; |<br>| — |</p></li><li><p>application.properties配置redis配置<br>| #Redis服务器地址<br>spring.data.redis.host=8.130.50.249<br>#Redis服务器连接端口<br>spring.data.redis.port=**6379<br>**#Redis数据库索引（默认为0）<br>spring.data.redis.database= **0<br>**#连接超时时间（毫秒）<br>spring.data.redis.timeout=1800000<br>#连接池最大连接数（使用负值表示没有限制）<br>spring.data.redis.jedis.pool.max-active=**20<br>**#最大阻塞等待时间(负数表示没限制)<br>spring.data.redis.jedis.pool.max-wait=-1<br>#连接池中的最大空闲连接<br>spring.data.redis.jedis.pool.max-idle=**5<br>**#连接池中的最小空闲连接<br>spring.data.redis.jedis.pool.min-idle=<strong>0</strong> |<br>| — |</p></li><li><p>添加redis配置类<br>| @EnableCaching<br>@Configuration<br>**public class **RedisConfig **extends **CachingConfigurerSupport {</p><p>@Bean<br>**public **RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) {<br>RedisTemplate&lt;String, Object&gt; template = **new **RedisTemplate&lt;&gt;();<br>RedisSerializer<String> redisSerializer = <strong>new <strong>StringRedisSerializer();<br>Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <strong>new <strong>Jackson2JsonRedisSerializer(Object.<strong>class</strong>);<br>ObjectMapper om = <strong>new <strong>ObjectMapper();<br>om.setVisibility(PropertyAccessor.</strong><em>ALL</em></strong>, JsonAutoDetect.Visibility.</strong><em>ANY</em></strong>);<br>om.enableDefaultTyping(ObjectMapper.DefaultTyping.</strong><em>NON_FINAL</em></strong>);<br>jackson2JsonRedisSerializer.setObjectMapper(om);<br>template.setConnectionFactory(factory);_//key序列化方式<br><em>template.setKeySerializer(redisSerializer);</em>//value序列化<br><em>template.setValueSerializer(jackson2JsonRedisSerializer);</em>//value hashmap序列化<br>_template.setHashValueSerializer(jackson2JsonRedisSerializer);<br>**return **template;<br>}</p><p>@Bean<br>**public **CacheManager cacheManager(RedisConnectionFactory factory) {<br>RedisSerializer<String> redisSerializer = <strong>new <strong>StringRedisSerializer();<br>Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <strong>new <strong>Jackson2JsonRedisSerializer(Object.<strong>class</strong>);_//解决查询缓存转换异常的问题<br>_ObjectMapper om = <strong>new <strong>ObjectMapper();<br>om.setVisibility(PropertyAccessor.</strong><em>ALL</em></strong>, JsonAutoDetect.Visibility.</strong><em>ANY</em></strong>);<br>om.enableDefaultTyping(ObjectMapper.DefaultTyping.</strong><em>NON_FINAL</em></strong>);<br>jackson2JsonRedisSerializer.setObjectMapper(om);_// 配置序列化（解决乱码的问题）,过期时间600秒<br>_RedisCacheConfiguration config = RedisCacheConfiguration.<em>defaultCacheConfig</em>()<br>.entryTtl(Duration.<em>ofSeconds</em>(600))<br>.serializeKeysWith(RedisSerializationContext.SerializationPair.<em>fromSerializer</em>(redisSerializer))<br>.serializeValuesWith(RedisSerializationContext.SerializationPair.<em>fromSerializer</em>(jackson2JsonRedisSerializer))<br>.disableCachingNullValues();<br>RedisCacheManager cacheManager = RedisCacheManager.<em>builder</em>(factory)<br>.cacheDefaults(config)<br>.build();<br>**return **cacheManager;<br>}<br>} |<br>| — |<br>|  |<br>|  |</p></li></ol><p>4、测试一下<br>RedisTestController中添加测试方法</p><p>| @RestController<br>@RequestMapping(<strong>“/redisTest”</strong>)<br><strong>public class <strong>RedisTestController {<br>@Autowired<br><strong>private <strong>RedisTemplate <strong>redisTemplate</strong>;<br>@GetMapping<br><strong>public <strong>String testRedis() {<br>_//设置值到redis<br>_<strong>redisTemplate</strong>.opsForValue().set(</strong>“name”</strong>,</strong>“lucy”</strong>);<br>_//从redis获取值<br>_String name = (String)<strong>redisTemplate</strong>.opsForValue().get(</strong>“name”</strong>);<br>**return **name;<br>}</p><table><thead><tr><th>}</th></tr></thead></table><ol><li><strong>Redis_事务_锁机制_秒杀</strong><ol><li><strong>Redis的事务定义</strong></li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730048825-54893261-bf10-4de3-a66c-f7b8b69c7a63.jpeg#averageHue=%23e0dfdb&amp;id=jmvjN&amp;originHeight=66&amp;originWidth=625&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>Redis事务的主要作用就是串联多个命令防止别的命令插队。</p><ol><li><strong>Multi、Exec、discard</strong></li></ol><p>从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。<br>组队的过程中可以通过discard来放弃组队。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730049147-dc3307d8-1793-4200-9f46-8d71c8175710.png#averageHue=%23fdfbfb&amp;id=ITVQ2&amp;originHeight=309&amp;originWidth=693&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br><strong>案例：</strong></p><p>| <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730049420-5fee2564-1c4f-4b27-9f0d-5081fa588321.jpeg#averageHue=%23615c55&amp;id=u9oHB&amp;originHeight=117&amp;originWidth=159&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><table><thead><tr><th>组队成功，提交成功</th></tr></thead><tbody><tr><td><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730049688-69b9a09e-c48f-48d0-95d8-2f3368017f39.jpeg#averageHue=%23060605&amp;id=PqyhT&amp;originHeight=122&amp;originWidth=389&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></td></tr><tr><td>组队阶段报错，提交失败</td></tr><tr><td><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730049917-4a5ea3be-4561-417e-8316-cd2266f3a8b2.jpeg#averageHue=%23080707&amp;id=BLVOz&amp;originHeight=152&amp;originWidth=330&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></td></tr><tr><td>组队成功，提交有成功有失败情况</td></tr></tbody></table><ol><li><strong>事务的错误处理</strong></li></ol><p>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730050175-662baba3-e42b-4d7e-97a5-fbaf395b7141.jpeg#averageHue=%23f6f5f5&amp;id=tNetC&amp;originHeight=270&amp;originWidth=617&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730050447-d9680bf2-fda6-4551-b0eb-ba707f216ac3.jpeg#averageHue=%23ebebe3&amp;id=JAArc&amp;originHeight=269&amp;originWidth=614&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>为什么要做成事务</strong></li></ol><p>想想一个场景：有很多人有你的账户,同时去参加双十一抢购</p><ol><li><strong>事务冲突的问题</strong><ol><li><strong>例子</strong></li></ol></li></ol><p>一个请求想给金额减8000<br>一个请求想给金额减5000<br>一个请求想给金额减1000<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730050721-2562fa91-e6be-4801-bec9-b54b906cddf4.jpeg#averageHue=%23fac47d&amp;id=oYHnE&amp;originHeight=215&amp;originWidth=616&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **悲观锁**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730050986-995b2faa-d872-406f-9ba7-cdca0f1a0d29.jpeg#averageHue=%23f1c084&amp;id=w0mhj&amp;originHeight=169&amp;originWidth=613&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br><strong>悲观锁(Pessimistic Lock)</strong>, 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。<strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。</p><pre><code>  1. **乐观锁**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730051248-472694bb-fce1-419f-b8b8-ee0b46349fac.jpeg#averageHue=%23f9e5d3&amp;id=pMR6f&amp;originHeight=195&amp;originWidth=613&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>**乐观锁(Optimistic Lock), **顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis就是利用这种check-and-set机制实现事务的。</p><pre><code>  1. **WATCH key [key ...]**</code></pre><p>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务<strong>执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730051584-c6030859-5595-4dd5-af27-cd9f93ef166e.jpeg#averageHue=%23f5edec&amp;id=jXO1L&amp;originHeight=180&amp;originWidth=314&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **unwatch**</code></pre><p>取消 WATCH 命令对所有 key 的监视。<br>如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了。<br><a href="http://doc.redisfans.com/transaction/exec.html">http://doc.redisfans.com/transaction/exec.html</a></p><ol><li><strong>Redis事务三特性</strong></li></ol><ul><li>单独的隔离操作<ul><li>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li></ul></li><li>没有隔离级别的概念<ul><li>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</li></ul></li><li>不保证原子性<ul><li>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li></ul></li></ul><ol><li><strong>Redis_事务_秒杀案例</strong><ol><li><strong>解决计数器和人员记录的事务操作</strong></li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730051888-55bb4789-36fb-4865-ac03-920446cb6b8d.jpeg#averageHue=%23fdfefd&amp;id=cx1Bh&amp;originHeight=189&amp;originWidth=614&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>Redis事务–秒杀并发模拟</strong></li></ol><p>使用工具ab模拟测试<br>CentOS6 默认安装<br>CentOS7需要手动安装</p><pre><code>  1. **联网：yum install httpd-tools**  2. **无网络**</code></pre><p>（1） 进入cd  /run/media/root/CentOS 7 x86_64/Packages（路径跟centos6不同）<br>（2） 顺序安装<br>apr-1.4.8-3.el7.x86_64.rpm<br>apr-util-1.5.2-6.el7.x86_64.rpm<br>httpd-tools-2.4.6-67.el7.centos.x86_64.rpm</p><pre><code>  1. **测试及结果**     1. **通过ab测试**</code></pre><p>vim postfile 模拟表单提交参数,以&amp;符号结尾;存放当前目录。<br>内容：prodid=0101&amp;<br>ab -n 2000 -c 200 -k -p ~/postfile -T application/x-www-form-urlencoded <a href="http://192.168.2.115:8081/Seckill/doseckill">http://192.168.2.115:8081/Seckill/doseckill</a></p><pre><code>     1. **超卖**</code></pre><p>| <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730052159-72c632b8-c258-476c-ab16-ba02e679e609.jpeg#averageHue=%23efefe9&amp;id=e0BcE&amp;originHeight=320&amp;originWidth=117&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""> | <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730052444-7f1821af-9326-4c5b-8ff9-3a55c795e243.jpeg#averageHue=%230e0908&amp;id=RzNKd&amp;originHeight=138&amp;originWidth=360&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>  |<br>| — | — |</p><ol><li><strong>超卖问题</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730052742-4e563233-bb89-48ce-9b0d-a6d4836dd0f9.jpeg#averageHue=%23f8e5db&amp;id=VNTTo&amp;originHeight=348&amp;originWidth=547&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>利用乐观锁淘汰用户，解决超卖问题。</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730053044-acd5fa54-be05-4269-b369-47acf2f2a3e9.jpeg#averageHue=%23f6ddd3&amp;id=wpIeY&amp;originHeight=289&amp;originWidth=613&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>| //增加乐观锁<br>jedis.watch(qtkey);</p><p><a href="//3.xn--fcr37t4sc0rk">//3.判断库存</a><br>String qtkeystr = jedis.get(qtkey);<br>if(qtkeystr==null || “”.equals(qtkeystr.trim())) {<br>System.out.println(“未初始化库存”);<br>jedis.close();<br>return false ;<br>}</p><p>int qt = Integer.parseInt(qtkeystr);<br>if(qt&lt;=0) {<br>System.err.println(“已经秒光”);<br>jedis.close();<br>return false;<br>}</p><p>//增加事务<br>Transaction <strong>multi</strong> = jedis.multi();</p><p><a href="//4.xn--z8q55u3pai4f">//4.减少库存</a><br><a href="//jedis.decr">//jedis.decr</a>(qtkey);<br><strong>multi</strong>.decr(qtkey);</p><p><a href="//5.xn--gmqv8g">//5.加人</a><br><a href="//jedis.sadd">//jedis.sadd</a>(usrkey, uid);<br><strong>multi</strong>.sadd(usrkey, uid);</p><p>//执行事务<br>List<Object> list = <strong>multi</strong>.exec();</p><p>//判断事务提交是否失败<br>if(list==null || list.size()==0) {<br>System.out.println(“秒杀失败”);<br>jedis.close();<br>return false;<br>}<br>System.err.print<strong>ln(&quot;秒杀成</strong>功&quot;);<br>jedis.close(); | <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730053362-ccd953c7-236d-448b-8ad2-5a5b050b2997.jpeg#averageHue=%23080606&amp;id=Rhbmv&amp;originHeight=311&amp;originWidth=331&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730053594-7a639b97-8a83-49f7-9005-c3a535b71ec4.jpeg#averageHue=%23e6e4dd&amp;id=jeZiO&amp;originHeight=319&amp;originWidth=127&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""> |<br>| — | — |</p><ol><li><strong>继续增加并发测试</strong><ol><li><strong>连接有限制</strong></li></ol></li></ol><p>ab -n 2000 -c 200 -k -p postfile -T ‘application/x-www-form-urlencoded’ <a href="http://192.168.140.1:8080/seckill/doseckill">http://192.168.140.1:8080/seckill/doseckill</a><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730053896-5957fed5-aab7-4802-bbbb-f886c8d8c83e.jpeg#averageHue=%230f0c0c&amp;id=oPqVJ&amp;originHeight=83&amp;originWidth=626&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>增加-r参数，-r   Don’t exit on socket receive errors.<br>**ab -n 2000 -c 100 -r -p postfile -T ‘application/x-www-form-urlencoded’ **<a href="http://192.168.140.1:8080/seckill/doseckill"><strong>http://192.168.140.1:8080/seckill/doseckill</strong></a></p><pre><code>  1. **已经秒光，可是还有库存**</code></pre><p>ab -n 2000 -c 100 -p postfile -T ‘application/x-www-form-urlencoded’ <a href="http://192.168.137.1:8080/seckill/doseckill">http://192.168.137.1:8080/seckill/doseckill</a><br>已经秒光，可是还有库存。原因，就是乐观锁导致很多请求都失败。先点的没秒到，后点的可能秒到了。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730054113-9d5a6de0-5d17-45bd-97b9-874049d61baf.jpeg#averageHue=%23797269&amp;id=d14LS&amp;originHeight=108&amp;originWidth=302&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **连接超时，通过连接池解决**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730054288-27c5b05f-a94c-4b63-a525-e6d16c0375a3.jpeg#averageHue=%2393bbe1&amp;id=VLdEy&amp;originHeight=86&amp;originWidth=619&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **连接池**</code></pre><p>节省每次连接redis服务带来的消耗，把连接好的实例反复利用。<br>通过参数管理连接的行为<br>代码见项目中</p><ul><li>链接池参数<ul><li>MaxTotal：控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；如果赋值为-1，则表示不限制；如果pool已经分配了MaxTotal个jedis实例，则此时pool的状态为exhausted。</li><li>maxIdle：控制一个pool最多有多少个状态为idle(空闲)的jedis实例；</li><li>MaxWaitMillis：表示当borrow一个jedis实例时，最大的等待毫秒数，如果超过等待时间，则直接抛JedisConnectionException；</li><li>testOnBorrow：获得一个jedis实例的时候是否检查连接可用性（ping()）；如果为true，则得到的jedis实例均是可用的；</li></ul><ol><li><strong>解决库存遗留问题</strong><ol><li><strong>LUA脚本</strong></li></ol></li></ol></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730054477-cae19266-6238-4723-8a4c-c28305a736d8.jpeg#averageHue=%23e8e9e7&amp;id=D7HPy&amp;originHeight=129&amp;originWidth=138&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>Lua 是一个小巧的<a href="http://baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80">脚本语言</a>，Lua脚本可以很容易的被C/C++ 代码调用，也可以反过来调用C/C++的函数，Lua并没有提供强大的库，一个完整的Lua解释器不过200k，所以Lua不适合作为开发独立应用程序的语言，而是作为嵌入式脚本语言。<br>很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。<br>这其中包括魔兽争霸地图、魔兽世界、博德之门、愤怒的小鸟等众多游戏插件或外挂。<br><a href="https://www.w3cschool.cn/lua/">https://www.w3cschool.cn/lua/</a></p><pre><code>  1. **LUA脚本在Redis中的优势**</code></pre><p>将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连接redis的次数。提升性能。<br>LUA脚本是类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作。<br>但是注意redis的lua脚本功能，只有在Redis 2.6以上的版本才可以使用。<br>利用lua脚本淘汰用户，解决超卖问题。<br>redis 2.6版本以后，通过lua脚本解决<strong>争抢问题</strong>，实际上是<strong>redis 利用其单线程的特性，用任务队列的方式解决多任务并发问题</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730054720-4b5108cf-836f-454d-8d3a-5e6610f33167.jpeg#averageHue=%23fae0be&amp;id=Iy2sW&amp;originHeight=225&amp;originWidth=600&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>Redis_事务_秒杀案例_代码</strong><ol><li><strong>项目结构</strong></li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730054907-f204ef93-9675-4e13-97f0-f9c305933a1f.png#averageHue=%23faf7f2&amp;id=clsqt&amp;originHeight=209&amp;originWidth=215&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **第一版：简单版 **</code></pre><p>老师点10次，正常秒杀<br>同学一起点试一试，秒杀也是正常的。这是因为还达不到并发的效果。<br>使用工具ab模拟并发测试，会出现超卖情况。查看库存会出现负数。</p><pre><code>  1. **第二版：加事务-乐观锁(解决超卖),但出现遗留库存和连接超时**  2. **第三版：连接池解决超时问题 **  3. **第四版：解决库存依赖问题，LUA脚本**</code></pre><p>| local userid=KEYS[1];<br>local prodid=KEYS[2];<br>local qtkey=“sk:”…prodid…“:qt”;<br>local usersKey=“sk:”…prodid.&quot;:usr’;<br>local userExists=redis.call(“sismember”,usersKey,userid);<br>if tonumber(userExists)==1 then<br>return 2;<br>end<br>local num= redis.call(“get” ,qtkey);<br>if tonumber(num)&lt;=0 then<br>return 0;<br>else<br>redis.call(“decr”,qtkey);<br>redis.call(“sadd”,usersKey,userid);<br>end</p><table><thead><tr><th>return 1;</th></tr></thead></table><ol><li><strong>Redis持久化之RDB</strong><ol><li><strong>总体介绍</strong></li></ol></li></ol><p>官网介绍：<a href="http://www.redis.io">http://www.redis.io</a><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730055181-21b42629-abdb-408d-8139-72b3db4826e7.jpeg#averageHue=%23dddcd8&amp;id=LuJfp&amp;originHeight=240&amp;originWidth=612&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>Redis 提供了2个不同形式的持久化方式。</p><ul><li>RDB（Redis DataBase）</li><li>AOF（Append Of File）<ol><li><strong>RDB（Redis DataBase）</strong><ol><li><strong>官网介绍</strong></li></ol></li></ol></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730055430-a04d534c-6813-404e-afa9-ad374a47ae7f.jpeg#averageHue=%23e1dfdc&amp;id=L2nnI&amp;originHeight=389&amp;originWidth=606&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **是什么**</code></pre><p>在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里</p><pre><code>  1. **备份是如何执行的**</code></pre><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。<strong>RDB的缺点是最后一次持久化后的数据可能丢失</strong>。</p><pre><code>  1. **Fork**</code></pre><ul><li><p>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p></li><li><p>在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“<strong>写时复制技术</strong>”</p></li><li><p><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p><pre><code>1. **RDB持久化流程**</code></pre></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730055601-d03945eb-508f-499e-acde-dd485a30138d.png#averageHue=%23eeeded&amp;id=mZlnw&amp;originHeight=330&amp;originWidth=475&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **dump.rdb文件**</code></pre><p>在redis.conf中配置文件名称，默认为dump.rdb<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730055806-a8519103-df9a-4e33-98b1-320aca70fbcd.png#averageHue=%23160606&amp;id=F2yMJ&amp;originHeight=84&amp;originWidth=473&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **配置位置**</code></pre><p>rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下<br>dir “/myredis/”<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730056042-a0f2e26f-c64f-4e30-b801-e772b0abaf58.png#averageHue=%230b0808&amp;id=LxeNT&amp;originHeight=200&amp;originWidth=719&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **如何触发RDB快照；保持策略**     1. **配置文件中默认的快照配置**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730056324-6811ad3a-8f85-4229-9f2b-a4345a12125f.png#averageHue=%23160808&amp;id=ikta5&amp;originHeight=220&amp;originWidth=699&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>     1. **命令save VS bgsave**</code></pre><p>save ：save时只管保存，其它不管，全部阻塞。手动保存。不建议。<br><strong>bgsave：Redis会在后台异步进行快照操作， 快照同时还可以响应客户端请求。</strong><br>可以通过lastsave 命令获取最后一次成功执行快照的时间</p><pre><code>     1. **flushall命令**</code></pre><p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</p><pre><code>     1. **###SNAPSHOTTING快照###**     2. **Save**</code></pre><p>格式：save 秒钟 写操作次数<br>RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，<br><strong>默认是1分钟内改了1万次，或5分钟内改了10次，或15分钟内改了1次。</strong><br>禁用<br>不设置save指令，或者给save传入空字符串</p><pre><code>     1. **stop-writes-on-bgsave-error**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730056566-b7477281-0ae2-4042-ae1d-7fb4ad566669.png#averageHue=%23130a0a&amp;id=uEi7h&amp;originHeight=134&amp;originWidth=725&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes.</p><pre><code>     1. **rdbcompression 压缩文件**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730056786-cf02a974-a051-438d-b27e-6c6acbc7b15e.png#averageHue=%23120c0c&amp;id=AnH3A&amp;originHeight=129&amp;originWidth=724&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。<br>如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes.</p><pre><code>     1. **rdbchecksum 检查完整性**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730057060-2dd5e796-841a-4e7a-8f95-8fbf34cc5eda.png#averageHue=%230e0707&amp;id=vfML2&amp;originHeight=105&amp;originWidth=724&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>在存储快照后，还可以让redis使用CRC64算法来进行数据校验，<br>但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能<br>推荐yes.</p><pre><code>     1. **rdb的备份**</code></pre><p>先通过config get dir  查询rdb文件的目录<br>将*.rdb的文件拷贝到别的地方<br>rdb的恢复</p><pre><code>  - 关闭Redis  - 先把备份的文件拷贝到工作目录下 cp dump2.rdb dump.rdb  - 启动Redis, 备份数据会直接加载  1. **优势**</code></pre><ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高更适合使用</li><li>节省磁盘空间</li><li>恢复速度快</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730057328-1a1bd3cf-aa53-4fa3-99a7-8766afb7f633.jpeg#averageHue=%23a6d477&amp;id=bdgqK&amp;originHeight=202&amp;originWidth=479&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **劣势**</code></pre><ul><li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li><li>虽然Redis在fork时使用了<strong>写时拷贝技术</strong>,但是如果数据庞大时还是比较消耗性能。</li><li>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。<br>1. <strong>如何停止</strong></li></ul><p>动态停止RDB：redis-cli config set save “”#save后给空值，表示禁用保存策略</p><pre><code>  1. **小总结**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730057646-f8b197f6-79c1-4fc4-acc6-f7bec75f94eb.jpeg#averageHue=%23f9f9f9&amp;id=Dm0u6&amp;originHeight=403&amp;originWidth=613&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>Redis持久化之AOF</strong><ol><li><strong>AOF（Append Only File）</strong><ol><li><strong>是什么</strong></li></ol></li></ol></li></ol><p>以<strong>日志</strong>的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(<strong>读操作不记录</strong>)， <strong>只许追加文件但不可以改写文件</strong>，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p><pre><code>  1. **AOF持久化流程**</code></pre><p>（1）客户端的请求写命令会被append追加到AOF缓冲区内；<br>（2）AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；<br>（3）AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；<br>（4）Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的；<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730057886-6d5c494b-e7a7-4115-9575-2e78ef90c48d.png#averageHue=%23edecec&amp;id=DNPfE&amp;originHeight=383&amp;originWidth=233&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **AOF默认不开启**</code></pre><p>可以在redis.conf中配置文件名称，默认为 appendonly.aof<br>AOF文件的保存路径，同RDB的路径一致。</p><pre><code>  1. **AOF和RDB同时开启，redis听谁的？**</code></pre><p>AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）</p><pre><code>  1. **AOF启动/修复/恢复**</code></pre><ul><li>AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</li><li>正常恢复</li><li>修改默认的appendonly no，改为yes</li><li>将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir)</li><li>恢复：重启redis然后重新加载</li><li>异常恢复</li><li>修改默认的appendonly no，改为yes</li><li>如遇到<strong>AOF文件损坏</strong>，通过/usr/local/bin/<strong>redis-check-aof–fix appendonly.aof</strong>进行恢复</li><li>备份被写坏的AOF文件</li><li>恢复：重启redis，然后重新加载<br>1. <strong>AOF同步频率设置</strong></li></ul><p>appendfsync always<br>始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好<br>appendfsync everysec<br>每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。<br>appendfsync no<br>redis不主动进行同步，把同步时机交给操作系统。</p><pre><code>  1. **Rewrite压缩**</code></pre><p>1是什么：<br>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof<br>2重写原理，如何实现重写<br>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。<br>no-appendfsync-on-rewrite：<br>如果 no-appendfsync-on-rewrite=yes ,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）<br>如果 no-appendfsync-on-rewrite=no,  还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）<br>触发机制，何时重写<br>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发<br>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。<br>auto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）<br>auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。<br>例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB<br>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,<br>如果Redis的AOF当前大小&gt;= base_size +base_size*100% (默认)且当前大小&gt;=64mb(默认)的情况下，Redis会对AOF进行重写。<br>3、重写流程<br>（1）bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。<br>（2）主进程fork出子进程执行重写操作，保证主进程不会阻塞。<br>（3）子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。<br>（4）1).子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。2).主进程把aof_rewrite_buf中的数据写入到新的AOF文件。<br>（5）使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730058156-e7a60505-1151-4537-8a78-0ea8a294fccd.png#averageHue=%23f6f6f6&amp;id=DnxVL&amp;originHeight=638&amp;originWidth=701&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **优势**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730058439-66ee9250-8f65-48b6-bc41-58850a528e74.jpeg#averageHue=%23cad496&amp;id=f4Efc&amp;originHeight=106&amp;originWidth=536&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ul><li>备份机制更稳健，丢失数据概率更低。</li><li>可读的日志文本，通过操作AOF稳健，可以处理误操作。<br>1. <strong>劣势</strong></li><li>比起RDB占用更多的磁盘空间。</li><li>恢复备份速度要慢。</li><li>每次读写都同步的话，有一定的性能压力。</li><li>存在个别Bug，造成恢复不能。<br>1. **  小总结**</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730058786-ed4e3683-45aa-4285-8764-3d48c440bd73.jpeg#averageHue=%23faf9f8&amp;id=yjMkA&amp;originHeight=326&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>总结(Which one)</strong><ol><li><strong>用哪个好</strong></li></ol></li></ol><p>官方推荐两个都启用。<br>如果对数据不敏感，可以选单独用RDB。<br>不建议单独用 AOF，因为可能会出现Bug。<br>如果只是做纯内存缓存，可以都不用。</p><pre><code>  1. **官网建议**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730059011-3a34fc84-6548-4124-8b48-303d3df871d0.jpeg#averageHue=%23faf9f9&amp;id=MvDwj&amp;originHeight=341&amp;originWidth=610&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ul><li>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</li><li>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.</li><li>Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大</li><li>只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</li><li>同时开启两种持久化方式</li><li>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据, 因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</li><li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？</li><li>建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)， 快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</li><li>性能建议<br>| 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。</li></ul><p>如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。<br>代价,一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。<br>只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。</p><table><thead><tr><th>默认超过原大小100%大小时重写可以改到适当的数值。</th></tr></thead></table><ol><li><strong>Redis_主从复制</strong><ol><li><strong>是什么</strong></li></ol></li></ol><p>主机数据更新后根据配置和策略， 自动同步到备机的master/slaver机制，<strong>Master以写为主，Slave以读为主</strong></p><ol><li><strong>能干嘛</strong></li></ol><ul><li>读写分离，性能扩展</li><li>容灾快速恢复</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730059288-8136969e-2728-44c0-92f1-403eaab1bc16.jpeg#averageHue=%23fefcf2&amp;id=KK85J&amp;originHeight=206&amp;originWidth=324&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>怎么玩：主从复制</strong></li></ol><p>拷贝多个redis.conf文件include(写绝对路径)<br>开启daemonize yes<br>Pid文件名字pidfile<br>指定端口port<br>Log文件名字<br>dump.rdb名字dbfilename<br>Appendonly 关掉或者换名字</p><pre><code>  1. **新建redis6379.conf，填写以下内容**</code></pre><p>include /myredis/redis.conf<br>pidfile /var/run/redis_6379.pid<br>port 6379<br>dbfilename dump6379.rdb<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730059500-a043faca-b0c8-4ca1-bea2-ca501c4ee043.jpeg#averageHue=%23686259&amp;id=b4oWf&amp;originHeight=70&amp;originWidth=265&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **新建redis6380.conf，填写以下内容**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730059753-1adb8e30-94f0-436c-85a5-5267413c6a65.jpeg#averageHue=%23696359&amp;id=Q5Svi&amp;originHeight=76&amp;originWidth=273&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **新建redis6381.conf，填写以下内容**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730060016-2ceaeb23-5896-4990-848e-f5bfdfae8f67.jpeg#averageHue=%23827b73&amp;id=wdYqu&amp;originHeight=79&amp;originWidth=270&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>slave-priority 10<br>设置从机的优先级，值越小，优先级越高，用于选举主机时使用。默认100</p><pre><code>  1. **启动三台redis服务器**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730060260-b04a3052-e6b0-487b-aec1-3a3290ccc001.jpeg#averageHue=%239a9589&amp;id=yy6Ru&amp;originHeight=68&amp;originWidth=428&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **查看系统进程，看看三台服务器是否启动**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730060610-89904f51-3b40-46ca-848b-6a81c80c9cda.jpeg#averageHue=%235e5951&amp;id=U3EWV&amp;originHeight=100&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **查看三台主机运行情况**</code></pre><p>info replication<br>打印主从复制的相关信息</p><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730060901-a0b333aa-8379-4a88-a487-9ec66fbc18bd.jpeg#averageHue=%235a5853&amp;id=dElMA&amp;originHeight=180&amp;originWidth=612&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **配从(库)不配主(库) **</code></pre><p>slaveof  <ip><port><br>成为某个实例的从服务器<br>1、在6380和6381上执行: slaveof 127.0.0.1 6379<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730061199-cc3e0dca-3cc4-4183-bec2-31ac0c33d1d7.jpeg#averageHue=%231f1d1d&amp;id=yKo9V&amp;originHeight=191&amp;originWidth=611&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>2、在主机上写，在从机上可以读取数据<br>在从机上写数据报错<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730061424-10f974eb-e268-4ed3-970a-58624217171e.jpeg#averageHue=%23625b51&amp;id=NxioL&amp;originHeight=38&amp;originWidth=513&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>3、主机挂掉，重启就行，一切如初<br>4、从机重启需重设：slaveof 127.0.0.1 6379<br>可以将配置增加到文件中。永久生效。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730061676-2e200633-8bbd-4339-8cfa-12e606c17002.jpeg#averageHue=%230b0a09&amp;id=SapCx&amp;originHeight=248&amp;originWidth=538&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>常用3招</strong><ol><li><strong>一主二仆</strong></li></ol></li></ol><p>切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的k1,k2,k3是否也可以复制？<br>从机是否可以写？set可否？<br>主机shutdown后情况如何？从机是上位还是原地待命？<br>主机又回来了后，主机新增记录，从机还能否顺利复制？<br>其中一台从机down后情况如何？依照原有它能跟上大部队吗？</p><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730061938-227d99d9-6b81-481e-863e-528691c14421.jpeg#averageHue=%23fbfbf8&amp;id=xOZvU&amp;originHeight=109&amp;originWidth=284&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **薪火相传**</code></pre><p>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。<br>用 slaveof  <ip><port><br>中途变更转向:会清除之前的数据，重新建立拷贝最新的<br>风险是一旦某个slave宕机，后面的slave都没法备份<br>主机挂了，从机还是从机，无法写数据了<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730062220-2562dda9-6423-4298-81e7-2579ef008c95.jpeg#averageHue=%23fafaf7&amp;id=I2xJV&amp;originHeight=89&amp;originWidth=407&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730062487-6c6e8c25-d0b8-446f-bcdc-36fab2a44a0e.jpeg#averageHue=%23191616&amp;id=R9Lra&amp;originHeight=153&amp;originWidth=625&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **反客为主**</code></pre><p>当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。<br>用 slaveof  no one  将从机变为主机。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730062734-bb999b61-30d6-4f9b-8428-f7718dd62b06.jpeg#averageHue=%237c766e&amp;id=DfAOO&amp;originHeight=145&amp;originWidth=616&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>复制原理</strong></li></ol><ul><li>Slave启动成功连接到master后会发送一个sync命令</li><li>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步</li><li>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li><li>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</li><li>但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730062965-da099463-4551-4b5f-948b-90d3dd45f71c.jpeg#averageHue=%23fbfbf9&amp;id=iFoVd&amp;originHeight=157&amp;originWidth=397&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>哨兵模式(sentinel)</strong><ol><li><strong>是什么</strong></li></ol></li></ol><p><strong>反客为主的自动版</strong>，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730063255-4b1a1df6-440e-404a-9038-9dcd704a13f8.jpeg#averageHue=%23fdfdfa&amp;id=yTMO9&amp;originHeight=200&amp;originWidth=305&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **怎么玩(使用步骤)**     1. **调整为一主二仆模式，6379带着6380、6381**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730063529-6128db26-5298-4980-bb0b-aa20b60715d1.jpeg#averageHue=%231e1c1b&amp;id=O9Zhq&amp;originHeight=192&amp;originWidth=615&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>     1. **自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错**     2. **配置哨兵,填写内容**</code></pre><p>sentinel monitor mymaster 127.0.0.1 6379 1<br>其中mymaster为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量。</p><pre><code>     1. **启动哨兵**</code></pre><p>/usr/local/bin<br>redis做压测可以用自带的redis-benchmark工具<br>执行redis-sentinel  /myredis/sentinel.conf<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730063836-22f7cd8d-4279-494b-8bdb-60758c46aa30.jpeg#averageHue=%230a0605&amp;id=K9J6x&amp;originHeight=517&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>     1. **当主机挂掉，从机选举中产生新的主机**</code></pre><p>(大概10秒左右可以看到哨兵窗口日志，切换了新的主机)<br>哪个从机会被选举为主机呢？根据优先级别：slave-priority<br>原主机重启后会变为从机。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730064132-98b85c71-677b-42f0-8e44-79623a2d24c9.jpeg#averageHue=%235a564f&amp;id=pV7en&amp;originHeight=496&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>     1. **复制延时**</code></pre><p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p><pre><code>  1. **故障恢复**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730064417-c797bdf6-42f1-4a57-9584-25f699de26fe.jpeg#averageHue=%23ececec&amp;id=LHDIf&amp;originHeight=301&amp;originWidth=553&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>优先级在redis.conf中默认：slave-priority 100，值越小优先级越高<br>偏移量是指获得原主机数据最全的<br>每个redis实例启动后都会随机生成一个40位的runid</p><pre><code>  1. **主从复制**</code></pre><p>| **private static **JedisSentinelPool <em>jedisSentinelPool</em>=<strong>null</strong>;<br>**public static  **Jedis getJedisFromSentinel(){<strong>if</strong>(<em>jedisSentinelPool</em>==<strong>null</strong>){<br>Set<String> sentinelSet=<strong>new <strong>HashSet&lt;&gt;();<br>sentinelSet.add(</strong>“192.168.11.103:26379”</strong>);</p><pre><code>        JedisPoolConfig jedisPoolConfig =**new **JedisPoolConfig();        jedisPoolConfig.setMaxTotal(10); _//最大可用连接数_jedisPoolConfig.setMaxIdle(5); _//最大闲置连接数_jedisPoolConfig.setMinIdle(5); _//最小闲置连接数_jedisPoolConfig.setBlockWhenExhausted(**true**); _//连接耗尽是否等待_jedisPoolConfig.setMaxWaitMillis(2000); _//等待时间_jedisPoolConfig.setTestOnBorrow(**true**); _//取连接的时候进行一下测试 ping pong</code></pre><p>jedisSentinelPool_=<strong>new <strong>JedisSentinelPool(</strong>“mymaster”</strong>,sentinelSet,jedisPoolConfig);**return **<em>jedisSentinelPool</em>.getResource();<br>}<strong>else</strong>{**return **<em>jedisSentinelPool</em>.getResource();<br>}</p><table><thead><tr><th>}</th></tr></thead></table><ol><li><strong>Redis集群</strong><ol><li><strong>问题</strong></li></ol></li></ol><p>容量不够，redis如何进行扩容？<br>并发写操作， redis如何分摊？<br>另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。<br>之前通过代理主机来解决，但是redis3.0中提供了解决方案。就是无中心化集群配置。</p><ol><li><strong>什么是集群</strong></li></ol><p>Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。<br>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p><ol><li><strong>删除持久化数据</strong></li></ol><p>将rdb,aof文件都删除掉。</p><ol><li><strong>制作6个实例，6379,6380,6381,6389,6390,6391</strong><ol><li><strong>配置基本信息</strong></li></ol></li></ol><p>开启daemonize yes<br>Pid文件名字<br>指定端口<br>Log文件名字<br>Dump.rdb名字<br>Appendonly 关掉或者换名字</p><pre><code>  1. **redis cluster配置修改**</code></pre><p>cluster-enabled yes    打开集群模式<br>cluster-config-file nodes-6379.conf  设定节点配置文件名<br>cluster-node-timeout 15000   设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。</p><p>| include /home/bigdata/redis.conf<br>port 6379<br>pidfile “/var/run/redis_6379.pid”<br>dbfilename “dump6379.rdb”<br>dir “/home/bigdata/redis_cluster”<br>logfile “/home/bigdata/redis_cluster/redis_err_6379.log”<br>cluster-enabled yes<br>cluster-config-file nodes-6379.conf</p><table><thead><tr><th>cluster-node-timeout 15000</th></tr></thead></table><pre><code>  1. **修改好redis6379.conf文件，拷贝多个redis.conf文件**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730064711-25ff6879-8c94-4ff2-912e-19dc08501733.jpeg#averageHue=%2352524a&amp;id=uCbvU&amp;originHeight=122&amp;originWidth=146&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **使用查找替换修改另外5个文件**</code></pre><p>例如：:%s/6379/6380</p><pre><code>  1. **启动6个redis服务**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730065009-ba59696d-4822-48c4-93e0-816f06495ae3.jpeg#averageHue=%2358534d&amp;id=aum7N&amp;originHeight=390&amp;originWidth=576&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>将六个节点合成一个集群</strong></li></ol><p>组合之前，请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730065368-75e6de27-eeb8-4e87-a5ab-aad76a30ab41.jpeg#averageHue=%239a9488&amp;id=LnPSN&amp;originHeight=325&amp;originWidth=551&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ul><li>合体：</li></ul><p>cd  /opt/redis-6.2.1/src</p><table><thead><tr><th>redis-cli --cluster create --cluster-replicas 1 192.168.11.101:6379 192.168.11.101:6380 192.168.11.101:6381 192.168.11.101:6389 192.168.11.101:6390 192.168.11.101:6391</th></tr></thead></table><p>此处不要用127.0.0.1， 请用真实IP地址<br>–replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730065713-2362c661-8190-45e5-af40-b67d53a1a702.jpeg#averageHue=%23090505&amp;id=BB1yK&amp;originHeight=229&amp;originWidth=613&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730066034-314aefd9-6dbd-44ce-aaaa-235bdb11969b.jpeg#averageHue=%23656059&amp;id=upEEw&amp;originHeight=400&amp;originWidth=453&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ul><li>普通方式登录</li></ul><p>可能直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，应该以集群方式登录。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730066308-ffcffe03-91f5-486f-a8d4-ab6fd5acd1e3.jpeg#averageHue=%2390887c&amp;id=cKQ0P&amp;originHeight=96&amp;originWidth=352&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>-c 采用集群策略连接，设置数据会自动切换到相应的写主机</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730066592-57524d74-ea9c-4c77-a0be-922f9b6fa646.jpeg#averageHue=%23110908&amp;id=HUIXr&amp;originHeight=136&amp;originWidth=545&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>通过 cluster nodes 命令查看集群信息</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730067892-bcf1e26e-d09d-49e7-ab1d-30c7e1bcd569.jpeg#averageHue=%23373734&amp;id=ZEIAM&amp;originHeight=70&amp;originWidth=619&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>redis cluster 如何分配这六个节点?</strong></li></ol><p>一个集群至少要有三个主节点。<br>选项 --cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。<br>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。</p><ol><li><strong>什么是slots</strong></li></ol><p><strong>[OK] All nodes agree about slots configuration.</strong><br><strong>&gt;&gt;&gt; Check for open slots…</strong><br><strong>&gt;&gt;&gt; Check slots coverage…</strong><br><strong>[OK] All 16384 slots covered.</strong><br>一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个，<br>集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。<br>集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点， 其中：<br>节点 A 负责处理 0 号至 5460 号插槽。<br>节点 B 负责处理 5461 号至 10922 号插槽。<br>节点 C 负责处理 10923 号至 16383 号插槽。</p><ol><li><strong>在集群中录入值</strong></li></ol><p>在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。<br>redis-cli客户端提供了 –c 参数实现自动重定向。<br>如 redis-cli  -c –p 6379 登入后，再录入、查询键值对可以自动重定向。<br>不在一个slot下的键值，是不能使用mget,mset等多键操作。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730068169-f49380f0-681e-41d7-8b82-32c7a26bc5f6.jpeg#averageHue=%235d5850&amp;id=ovTRs&amp;originHeight=38&amp;originWidth=477&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730068454-8358ba48-2f36-4d66-8cb6-1c760ec33013.jpeg#averageHue=%23635d54&amp;id=tiyJ9&amp;originHeight=51&amp;originWidth=477&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>查询集群中的值</strong></li></ol><p>CLUSTER GETKEYSINSLOT <slot><count> 返回 count 个 slot 槽中的键。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730068715-d5089a9d-586c-4755-85ab-2f07e10e337e.jpeg#averageHue=%230b0a09&amp;id=trh58&amp;originHeight=159&amp;originWidth=458&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>故障恢复</strong></li></ol><p>如果主节点下线？从节点能否自动升为主节点？注意：<strong>15秒超时</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730069111-379b6de7-4859-4afe-b479-807245c3400a.jpeg#averageHue=%233e3e3b&amp;id=nO7l1&amp;originHeight=69&amp;originWidth=612&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>主节点恢复后，主从关系会如何？主节点回来变成从机。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/28066124/1693730069586-dc99921d-5a48-491a-bb57-67c66f78919f.jpeg#averageHue=%233c3c39&amp;id=E6CJd&amp;originHeight=69&amp;originWidth=611&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?<br>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉<br>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。<br>redis.conf中的参数  cluster-require-full-coverage</p><ol><li><strong>集群的Jedis开发</strong></li></ol><p>即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。<br>无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。</p><p>| public class JedisClusterTest {<br>public static void main(String[] args) { <br>Set<HostAndPort>set =new HashSet<HostAndPort>();<br>set.add(new HostAndPort(“192.168.31.211”,6379));<br>JedisCluster jedisCluster=new JedisCluster(set);<br>jedisCluster.set(“k1”, “v1”);<br>System.<em>out.println(jedisCluster.get(“k1”));</em><br>}</p><table><thead><tr><th>}</th></tr></thead></table><ol><li><strong>Redis 集群提供了以下好处</strong></li></ol><p>实现扩容<br>分摊压力<br>无中心配置相对简单</p><ol><li><strong>Redis 集群的不足</strong></li></ol><p>多键操作是不被支持的<br>多键的Redis事务是不被支持的。lua脚本不被支持<br>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</p><ol><li><strong>Redis应用问题解决</strong><ol><li><strong>缓存穿透</strong><ol><li><strong>问题描述</strong></li></ol></li></ol></li></ol><p>key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730069953-275cddcd-e44c-40e5-9b9f-d46ded46ad78.png#averageHue=%23faf4f3&amp;id=TrOEm&amp;originHeight=329&amp;originWidth=677&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **解决方案**</code></pre><p>一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。<br>解决方案：</p><ol><li>**对空值缓存：**如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟</li><li><strong>设置可访问的名单（白名单）：</strong></li></ol><p>使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</p><ol><li><strong>采用布隆过滤器</strong>：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。</li></ol><p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)<br>将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。</p><ol><li>**进行实时监控：**当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务<ol><li><strong>缓存击穿</strong><ol><li><strong>问题描述</strong></li></ol></li></ol></li></ol><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730070215-e34d05fd-bf8e-40e6-af86-88ae9eb44e95.png#averageHue=%23faf6f5&amp;id=xAfbW&amp;originHeight=343&amp;originWidth=723&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **解决方案**</code></pre><p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。<br>解决问题：<br>**（1）预先设置热门数据：**在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长<br>**（2）实时调整：**现场监控哪些数据热门，实时调整key的过期时长<br><strong>（3）使用锁：</strong></p><ol><li>就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。</li><li>先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key</li><li>当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；</li><li>当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730070470-f8183b79-bf14-4a22-9fbc-3cc4835cb2af.png#averageHue=%23fbfbfb&amp;id=VBlaP&amp;originHeight=411&amp;originWidth=448&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>缓存雪崩</strong><ol><li><strong>问题描述</strong></li></ol></li></ol><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。<br>缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key<br>正常访问<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730070765-88efeeb3-4ea4-4960-ae38-84aa60eb556d.png#averageHue=%23faf8f7&amp;id=LHa9y&amp;originHeight=484&amp;originWidth=826&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>缓存失效瞬间<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730071077-28e3b97a-2cdc-4f8a-a415-8e0ec739bfbe.png#averageHue=%23faf8f7&amp;id=qyRBl&amp;originHeight=473&amp;originWidth=826&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><pre><code>  1. **解决方案**</code></pre><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕！<br>解决方案：</p><ol><li>**构建多级缓存架构：**nginx缓存 + redis缓存 +其他缓存（ehcache等）</li><li><strong>使用锁或队列：</strong></li></ol><p>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况</p><ol><li><strong>设置过期标志更新缓存：</strong></li></ol><p>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</p><ol><li><strong>将缓存失效时间分散开：</strong></li></ol><p>比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><ol><li><strong>分布式锁</strong><ol><li><strong>问题描述</strong></li></ol></li></ol><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！<br>分布式锁主流的实现方案：</p><ol><li><p>基于数据库实现分布式锁</p></li><li><p>基于缓存（Redis等）</p></li><li><p>基于Zookeeper<br>每一种分布式锁解决方案都有各自的优缺点：</p></li><li><p>性能：redis最高</p></li><li><p>可靠性：zookeeper最高<br>这里，我们就基于redis实现分布式锁。</p><ol><li><strong>解决方案：使用redis实现分布式锁</strong></li></ol></li></ol><p>redis:命令</p><h1>set sku:1:info “OK” NX PX 10000</h1><p>EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。<br>PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。<br>NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。<br>XX ：只在键已经存在时，才对键进行设置操作。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730071356-417caa2a-c06b-40b6-a1a1-57e0999e745e.png#averageHue=%23f7ebda&amp;id=QibzD&amp;originHeight=413&amp;originWidth=516&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><p>多个客户端同时获取锁（setnx）</p></li><li><p>获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</p></li><li><p>其他客户端等待重试</p><ol><li><strong>编写代码</strong></li></ol></li></ol><p>Redis: set num 0</p><p>| @GetMapping(<strong>“testLock”</strong>)<strong>public void <strong>testLock(){<br>_//1获取锁，setne<br>_Boolean lock = <strong>redisTemplate</strong>.opsForValue().setIfAbsent(</strong>“lock”</strong>, <strong>“111”</strong>);<br>_//2获取锁成功、查询num的值<br>_<strong>if</strong>(lock){<br>Object value = <strong>redisTemplate</strong>.opsForValue().get(<strong>“num”</strong>);<br>_//2.1判断num为空return<br>_<strong>if</strong>(StringUtils.<em>isEmpty</em>(value)){<br><strong>return</strong>;<br>}<br>_//2.2有值就转成成int<br>_<strong>int <strong>num = Integer.<em>parseInt</em>(value+</strong>“”</strong>);<br>_//2.3把redis的num加1<br>_<strong>redisTemplate</strong>.opsForValue().set(<strong>“num”</strong>, ++num);<br>_//2.4释放锁，del<br>_<strong>redisTemplate</strong>.delete(<strong>“lock”</strong>);</p><pre><code>&#125;**else**&#123;    _//3获取锁失败、每隔0.1秒再获取    _**try **&#123;        Thread._sleep_(100);        testLock();    &#125; **catch **(InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><table><thead><tr><th>}</th></tr></thead></table><p>重启，服务集群，通过网关压力测试：<br>ab -n 1000 -c 100 <a href="http://192.168.140.1:8080/test/testLock">http://192.168.140.1:8080/test/testLock</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730071601-fe3ab0bd-e460-4b8b-849a-182bb9e26043.png#averageHue=%23080604&amp;id=gLlai&amp;originHeight=339&amp;originWidth=675&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>查看redis中num的值：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730071805-569a0a60-558e-439f-bb0f-003547344d5b.png#averageHue=%23070503&amp;id=cqeJ7&amp;originHeight=79&amp;originWidth=254&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>基本实现。<br>问题：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放<br>解决：设置过期时间，自动释放锁。</p><pre><code>  1. **优化之设置锁的过期时间**</code></pre><p>设置过期时间有两种方式：</p><ol><li>首先想到通过expire设置过期时间（缺乏原子性：如果在setnx和expire之间出现异常，锁也无法释放）</li><li>在set时指定过期时间（推荐）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730072097-a77ddcab-ed0e-4a5b-b5f2-4c8880d8f329.png#averageHue=%23e5ba99&amp;id=Rzw5k&amp;originHeight=469&amp;originWidth=535&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>设置过期时间：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730072368-07cc7a51-aa40-4613-9e55-361b8f4a67f5.png#averageHue=%23f9f9f9&amp;id=dn0YL&amp;originHeight=366&amp;originWidth=938&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>压力测试肯定也没有问题。自行测试<br>问题：可能会释放其他服务器的锁。</li></ol><p>场景：如果业务逻辑的执行时间是7s。执行流程如下</p><ol><li>index1业务逻辑没执行完，3秒后锁被自动释放。</li><li>index2获取到锁，执行业务逻辑，3秒后锁被自动释放。</li><li>index3获取到锁，执行业务逻辑</li><li>index1业务逻辑执行完成，开始调用del释放锁，这时释放的是index3的锁，导致index3的业务只执行1s就被别人释放。</li></ol><p>最终等于没锁的情况。</p><p>解决：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁</p><pre><code>  1. **优化之UUID防误删**</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730072580-28c79e0f-3450-45e9-82d6-fa412efc8ee4.png#averageHue=%23eac79d&amp;id=OZwju&amp;originHeight=477&amp;originWidth=535&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730072856-6390182a-5813-4629-a70c-f663a2a33437.png#averageHue=%23fcf5f3&amp;id=Z1TwL&amp;originHeight=464&amp;originWidth=682&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>问题：删除操作缺乏原子性。<br>场景：</p><ol><li>index1执行删除时，查询到的lock值确实和uuid相等</li></ol><p>uuid=v1<br>set(lock,uuid)；<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730073160-2aaca9d4-f781-484d-ba52-a8ff40078ed7.png#averageHue=%23d6c0a0&amp;id=ufXoz&amp;originHeight=28&amp;originWidth=590&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li>index1执行删除前，lock刚好过期时间已到，被redis自动释放</li></ol><p>在redis中没有了lock，没有了锁。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730073432-cd41f3c8-78eb-4eb5-a00b-364c584de07b.png#averageHue=%23d5cca5&amp;id=z7cRe&amp;originHeight=24&amp;originWidth=379&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li>index2获取了lock</li></ol><p>index2线程获取到了cpu的资源，开始执行方法<br>uuid=v2<br>set(lock,uuid)；</p><ol><li>index1执行删除，此时会把index2的lock删除</li></ol><p>index1 因为已经在方法中了，所以不需要重新上锁。index1有执行的权限。index1已经比较完成了，这个时候，开始执行<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730073672-4a90d87b-fc4d-4c89-bcfb-94163aed807f.png#averageHue=%23d5cca5&amp;id=v1xgD&amp;originHeight=24&amp;originWidth=379&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>删除的index2的锁！</p><pre><code>  1. **优化之LUA脚本保证删除的原子性**</code></pre><p>| @GetMapping(<strong>“testLockLua”</strong>)**public void **testLockLua() {_    //1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中<br>_String uuid = UUID.<em>randomUUID</em>().toString();<br>_//2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！<br>_String skuId = <strong>“25”</strong>; _// 访问skuId 为25号的商品 100008348542<br>_String locKey = **“lock:” **+ skuId; _// 锁住的是每个商品的数据</p><pre><code>// 3 获取锁_Boolean lock = **redisTemplate**.opsForValue().setIfAbsent(locKey, uuid, 3, TimeUnit.**_SECONDS_**);_// 第一种： lock 与过期时间中间不写任何的代码。// redisTemplate.expire(&quot;lock&quot;,10, TimeUnit.SECONDS);//设置过期时间// 如果true_**if **(lock) &#123;    _// 执行的业务逻辑开始    // 获取缓存中的num 数据    _Object value = **redisTemplate**.opsForValue().get(**&quot;num&quot;**);    _// 如果是空直接返回    _**if **(StringUtils._isEmpty_(value)) &#123;        **return**;    &#125;    _// 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！    _**int **num = Integer._parseInt_(value + **&quot;&quot;**);    _// 使num 每次+1 放入缓存    _**redisTemplate**.opsForValue().set(**&quot;num&quot;**, String._valueOf_(++num));    _/*使用lua脚本来锁*/    // 定义lua 脚本    _String script = **&quot;if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end&quot;**;    _// 使用redis执行lua执行    _DefaultRedisScript&lt;Long&gt; redisScript = **new **DefaultRedisScript&lt;&gt;();    redisScript.setScriptText(script);    _// 设置一下返回值类型 为Long    // 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型，    // 那么返回字符串与0 会有发生错误。    _redisScript.setResultType(Long.**class**);    _// 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。    _**redisTemplate**.execute(redisScript, Arrays._asList_(locKey), uuid);&#125; **else **&#123;    _// 其他线程等待    _**try **&#123;        _// 睡眠        _Thread._sleep_(1000);        _// 睡醒了之后，调用方法。        _testLockLua();    &#125; **catch **(InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><table><thead><tr><th>}</th></tr></thead></table><p>Lua 脚本详解：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730073899-6d3141e9-8519-4cdb-8541-2dd6e8bdc18d.png#averageHue=%23fdfcfb&amp;id=ETVfk&amp;originHeight=480&amp;originWidth=1028&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>项目中正确使用：</p><p>|</p><ol><li>定义key，key应该是为每个sku定义的，也就是每个sku有一把锁。</li></ol><p>String locKey =<strong>“lock:”</strong>+skuId; <em>// 锁住的是每个商品的数据</em></p><table><thead><tr><th>Boolean lock = <strong>redisTemplate</strong>.opsForValue().setIfAbsent(locKey, uuid,3,TimeUnit.<strong><em>SECONDS</em></strong>);</th></tr></thead><tbody><tr><td><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730074191-2c9f99ec-d32f-48b3-b315-1ff9b4ca3aaf.png#averageHue=%23fcf8f6&amp;id=zrxML&amp;originHeight=403&amp;originWidth=1234&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></td></tr></tbody></table><pre><code>  1. **总结**</code></pre><p>1、加锁</p><p>| _// 1. 从redis中获取锁,set k1 v1 px 20000 nx_String uuid = UUID.<em>randomUUID</em>().toString();<br>Boolean lock = <strong>this</strong>.<strong>redisTemplate</strong>.opsForValue()<br>.setIfAbsent(<strong>“lock”</strong>, uuid, 2, TimeUnit.<strong><em>SECONDS</em></strong>); |<br>| — |</p><ol><li><p>使用lua释放锁<br>| <em>// 2. 释放锁 del_String script = <strong>“if redis.call(‘get’, KEYS[1]) == ARGV[1] then return redis.call(‘del’, KEYS[1]) else return 0 end”</strong>;</em>// 设置lua脚本返回的数据类型_DefaultRedisScript<Long> redisScript = <strong>new <strong>DefaultRedisScript&lt;&gt;();_// 设置lua脚本返回类型为Long_redisScript.setResultType(Long.<strong>class</strong>);<br>redisScript.setScriptText(script);<strong>redisTemplate</strong>.execute(redisScript, Arrays.<em>asList</em>(</strong>“lock”</strong>),uuid); |<br>| — |</p></li><li><p>重试<br>| Thread.<em>sleep</em>(500);<br>testLock(); |<br>| — |</p></li></ol><p>为了确保分布式锁可用，我们至少要确保锁的实现同时<strong>满足以下四个条件</strong>：</p><ul><li>互斥性。在任意时刻，只有一个客户端能持有锁。</li><li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li><li>加锁和解锁必须具有原子性。</li></ul><ol><li><strong>Redis6.0新功能</strong><ol><li><strong>ACL</strong><ol><li><strong>简介</strong></li></ol></li></ol></li></ol><p>Redis ACL是Access Control List（访问控制列表）的缩写，该功能允许根据可以执行的命令和可以访问的键来限制某些连接。<br>在Redis 5版本之前，Redis 安全规则只有密码控制 还有通过rename 来调整高危命令比如 flushdb ， KEYS* ， shutdown 等。Redis 6 则提供ACL的功能对用户进行更细粒度的权限控制 ：<br>（1）接入权限:用户名和密码<br>（2）可以执行的命令<br>（3）可以操作的 KEY<br>参考官网：<a href="https://redis.io/topics/acl">https://redis.io/topics/acl</a></p><pre><code>  1. **命令**</code></pre><p>1、使用acl list命令展现用户权限列表<br>（1）数据说明<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730074431-05b634e8-61c0-434c-a443-98aa75f7c092.png#averageHue=%23b0adab&amp;id=FB9YM&amp;originHeight=179&amp;originWidth=554&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>2、使用acl cat命令<br>（1）查看添加权限指令类别<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730074718-a4d67980-3dbd-460a-b8bc-5cf765f8f8b4.png#averageHue=%230a0705&amp;id=WeuV7&amp;originHeight=353&amp;originWidth=201&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>（2）加参数类型名可以查看类型下具体命令<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730074979-70b85580-5a5c-4cdd-b862-5e4e55a68541.png#averageHue=%23070503&amp;id=ixrMP&amp;originHeight=336&amp;originWidth=257&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>3、使用acl whoami命令查看当前用户<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730075281-c2b829f3-ef21-4de1-b410-f92965d4e1b1.png#averageHue=%230f0b08&amp;id=TpN1o&amp;originHeight=34&amp;originWidth=212&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>4、使用aclsetuser命令创建和编辑用户ACL<br>（1）ACL规则<br>下面是有效ACL规则的列表。某些规则只是用于激活或删除标志，或对用户ACL执行给定更改的单个单词。其他规则是字符前缀，它们与命令或类别名称、键模式等连接在一起。</p><table><thead><tr><th>ACL规则</th><th></th><th></th></tr></thead><tbody><tr><td>类型</td><td>参数</td><td>说明</td></tr><tr><td>启动和禁用用户</td><td><strong>on</strong></td><td>激活某用户账号</td></tr><tr><td></td><td><strong>off</strong></td><td>禁用某用户账号。注意，已验证的连接仍然可以工作。如果默认用户被标记为off，则新连接将在未进行身份验证的情况下启动，并要求用户使用AUTH选项发送AUTH或HELLO，以便以某种方式进行身份验证。</td></tr><tr><td>权限的添加删除</td><td><strong>+<command></strong></td><td>将指令添加到用户可以调用的指令列表中</td></tr><tr><td></td><td><strong>-<command></strong></td><td>从用户可执行指令列表移除指令</td></tr><tr><td></td><td><strong>+@<category></strong></td><td>添加该类别中用户要调用的所有指令，有效类别为@admin、@set、@sortedset…等，通过调用ACL CAT命令查看完整列表。特殊类别@all表示所有命令，包括当前存在于服务器中的命令，以及将来将通过模块加载的命令。</td></tr><tr><td></td><td>-@<actegory></td><td>从用户可调用指令中移除类别</td></tr><tr><td></td><td><strong>allcommands</strong></td><td>+@all的别名</td></tr><tr><td></td><td><strong>nocommand</strong></td><td>-@all的别名</td></tr><tr><td>可操作键的添加或删除</td><td><strong>~<pattern></strong></td><td>添加可作为用户可操作的键的模式。例如~*允许所有的键</td></tr></tbody></table><p>（2）通过命令创建新用户默认权限<br>acl setuser user1<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730075555-fb2539f0-9a30-41cf-a945-db4f7b570a59.png#averageHue=%230c0906&amp;id=hG7rS&amp;originHeight=82&amp;originWidth=295&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>在上面的示例中，我根本没有指定任何规则。如果用户不存在，这将使用just created的默认属性来创建用户。如果用户已经存在，则上面的命令将不执行任何操作。<br>（3）设置有用户名、密码、ACL权限、并启用的用户<br>acl setuser user2 on &gt;password ~cached:* +get<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730075866-dd1a0cfb-2d9d-4c28-9b53-ed1a51a031b1.png#averageHue=%23090604&amp;id=R4oZ1&amp;originHeight=127&amp;originWidth=669&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>(4)切换用户，验证权限<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730076093-e51c4181-36eb-4d57-9f5a-f0eafdd9b50d.png#averageHue=%23070503&amp;id=yITh8&amp;originHeight=242&amp;originWidth=673&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>IO多线程</strong><ol><li><strong>简介</strong></li></ol></li></ol><p>Redis6终于支撑多线程了，告别单线程了吗？<br>IO多线程其实指<strong>客户端交互部分</strong>的<strong>网络IO</strong>交互处理模块<strong>多线程</strong>，而非<strong>执行命令多线程</strong>。Redis6执行命令依然是单线程。</p><pre><code>  1. **原理架构**</code></pre><p>Redis 6 加入多线程,但跟 Memcached 这种从 IO处理到数据访问多线程的实现模式有些差异。Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题。整体的设计大体如下:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730076372-2cc09b37-398c-4e0c-87c5-b4aca4d719ba.png#averageHue=%2397a72b&amp;id=zmIJm&amp;originHeight=411&amp;originWidth=656&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br>另外，多线程IO默认也是不开启的，需要再配置文件中配置<br>io-threads-do-reads  yes<br>io-threads 4</p><ol><li><strong>工具支持 Cluster</strong></li></ol><p>之前老版Redis想要搭集群需要单独安装ruby环境，Redis 5 将 redis-trib.rb 的功能集成到 redis-cli 。另外官方 redis-benchmark 工具开始支持 cluster 模式了，通过多线程的方式对多个分片进行压测。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1693730076655-3a897056-f7ac-4c50-bd1b-ce082189a699.png#averageHue=%230d0a07&amp;id=Phaot&amp;originHeight=290&amp;originWidth=673&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li><strong>Redis新功能持续关注</strong></li></ol><p>Redis6新功能还有：<br>1、RESP3新的 Redis 通信协议：优化服务端与客户端之间通信<br>2、Client side caching客户端缓存：基于 RESP3 协议实现的客户端缓存功能。为了进一步提升缓存的性能，将客户端经常访问的数据cache到客户端。减少TCP网络交互。<br>3、Proxy集群代理模式：Proxy 功能，让 Cluster 拥有像单实例一样的接入方式，降低大家使用cluster的门槛。不过需要注意的是代理不改变 Cluster 的功能限制，不支持的命令还是不会支持，比如跨 slot 的多Key操作。<br>4、Modules API<br>Redis 6中模块API开发进展非常大，因为Redis Labs为了开发复杂的功能，从一开始就用上Redis模块。Redis可以变成一个框架，利用Modules来构建不同系统，而不需要从头开始写然后还要BSD许可。Redis一开始就是一个向编写各种系统开放的平台。</p>]]></content>
    
    
      
      
    <summary type="html"> &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h2 id=&quot;框架高级课程系列之Redis6&quot;&gt;框架高级课程系列之Redis6&lt;/h2&gt;
&lt;p&gt;尚硅谷JavaEE教研组&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;NoSQL数据库简介&lt;</summary>
      
    
    
    
    <category term="中间件" scheme="http://www.bojiboqi.fun/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="redis" scheme="http://www.bojiboqi.fun/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>服务器那些事</title>
    <link href="http://www.bojiboqi.fun/2024/01/26/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85%EF%BC%9F/"/>
    <id>http://www.bojiboqi.fun/2024/01/26/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85%EF%BC%9F/</id>
    <published>2024-01-26T10:48:59.175Z</published>
    <updated>2024-01-26T10:56:01.850Z</updated>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h1>1.服务器遭遇到挖矿程序！</h1><p><a href="https://blog.csdn.net/qq_28513801/article/details/127890305">服务器遭到newinit.sh木马挖矿攻击记录_抛物线.的博客-CSDN博客</a><br><a href="https://blog.csdn.net/qq_47464056/article/details/125970479">阿里云服务器被挖矿的解决方法_阿里云被挖矿_Daryl179的博客-CSDN博客</a><br><a href="https://www.renfei.net/posts/1003501">Redis 未授权访问漏洞分析 cleanfda 脚本复现漏洞挖矿</a><br><a href="https://blog.51cto.com/u_13540373/4861152">redis如何设置密码_51CTO博客_redis设置账号密码</a><br>总结：<br>1.原因可能是没有设置redis的密码，并且注释了bind让其他人都可以随便连接redis<br>2.主要是ZZH和zzhs文件造成的，他们在/etc目录下<br>3.lsattr用来显示文件属性，<a href="http://www.ha97.com/5172.html">（总结）Linux的chattr与lsattr命令详解</a>chattr可以改变文件属性<br>4.查看redis靠哪个配置文件启动：<br>a.启动redis-cli；b.输入info c.在server模块下查看config_flie,后面的就是启动的redis所依靠的配置文件</p><h1>2.Linux不小心用cat打开二进制文件显示乱码的解决方法？</h1><p>1，直接输入reset就可以了</p><h1>修改host文件访问被DNS污染的网站：</h1><p><a href="https://www.cnblogs.com/wangmaoling/p/6646460.html">修改host文件浏览国外网站 - 小兔额乖乖 - 博客园</a><a href="https://zhuanlan.zhihu.com/p/32234805">修改hosts访问外网</a></p><h1>3.ping</h1><p>ping后面跟的是域名，而域名不需要加http,https等协议了，不然会ping不出的。通过ping可以得知该域名的网站，但是如果ping的是被屏蔽的网站的话！那么ping出来的ip地址是错误的。</p>]]></content>
    
    
      
      
    <summary type="html"> &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h1&gt;1.服务器遭遇到挖矿程序！&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_28513801/article/details/127890305</summary>
      
    
    
    
    <category term="搞基" scheme="http://www.bojiboqi.fun/categories/%E6%90%9E%E5%9F%BA/"/>
    
    
    <category term="bug" scheme="http://www.bojiboqi.fun/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>web前端</title>
    <link href="http://www.bojiboqi.fun/2024/01/26/web%E5%89%8D%E7%AB%AF%EF%BC%9A/"/>
    <id>http://www.bojiboqi.fun/2024/01/26/web%E5%89%8D%E7%AB%AF%EF%BC%9A/</id>
    <published>2024-01-26T10:46:33.202Z</published>
    <updated>2024-01-26T10:53:35.104Z</updated>
    
    <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h1>1.VScode的使用：</h1><h2 id="如何快速生成HTML模板">如何快速生成HTML模板</h2><p>输入！然后tab就可以快速生成html模板了</p><h1>绘制三角形：</h1><h2 id="总结：">总结：</h2><p>1.<a href="https://blog.csdn.net/qq_44537625/article/details/100040169">display:flex(弹性盒子布局)详解_display: flex_羡阳公子的博客-CSDN博客</a><br>2.<a href="https://blog.csdn.net/weixin_44015669/article/details/115663156">CSS：N种使用CSS 绘制三角形的方法_三角形css_打瞌睡的兔兔小姐的博客-CSDN博客</a><a href="https://blog.csdn.net/hhhhhhhssss/article/details/119177898">【前端怪谈】两个行内块元素之间的间距问题_行内块元素间距问题_hhhhhhhssss的博客-CSDN博客</a><a href="https://zhuanlan.zhihu.com/p/160929003">css之div盒子居中常用方法大全</a></p><h1>2.如何在输入框前设置图片：</h1><p><a href="https://blog.csdn.net/heromps/article/details/112576867">input里面添加图片_input输入框添加图片_heromps的博客-CSDN博客</a></p><h2 id="输入框文本缩进的方法：">输入框文本缩进的方法：</h2><p>**CSS中的text-indent属性可以实现：**text-indent 属性规定文本块中首行文本的缩进。可以给改属性赋值px,百分比等，默认是0；<br>注释：允许使用负值。如果使用负值，那么首行会被缩进到左边。<br><a href="https://worktile.com/kb/p/24580">html的缩进属性介绍 • Worktile社区</a><br>3.Live Server是一款在vscode上面修改编码刷新界面就可以反馈在浏览器的插件</p><h1>第3次实验总结：</h1><h4 id="1-如何在无序列表的列表项下边生成下划线">1.如何在无序列表的列表项下边生成下划线</h4><p>只需要设置无序列表项的下边框就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ul li &#123;</span><br><span class="line">border-bottom: 1px solid black; /* 设置下划线的宽度、样式和颜色 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-js中动态生成的元素也受css的影响">2.js中动态生成的元素也受css的影响</h4><h4 id="3-行内块元素，块元素，行元素的区别：">3.行内块元素，块元素，行元素的区别：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">每个块级元素都是独自占一行；</span><br><span class="line">高度，行高，外边距（margin）以及内边距（padding）都可以控制；</span><br><span class="line">元素的宽度如果不设置的话，默认为父元素的宽度（父元素宽度100%；</span><br><span class="line">多个块状元素标签写在一起，默认排列方式为从上至下</span><br><span class="line">一般作为容器使用</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;  // 定义地址 </span><br><span class="line">&lt;caption&gt;  // 定义表格标题 </span><br><span class="line">&lt;dd&gt;      // 定义列表中定义条目 </span><br><span class="line">&lt;div&gt;     // 定义文档中的分区或节 </span><br><span class="line">&lt;dl&gt;    // 定义列表 </span><br><span class="line">&lt;dt&gt;     // 定义列表中的项目 </span><br><span class="line">&lt;fieldset&gt;  // 定义一个框架集 </span><br><span class="line">&lt;form&gt;  // 创建 HTML 表单 </span><br><span class="line">&lt;h1&gt;    // 定义最大的标题</span><br><span class="line">&lt;h2&gt;    // 定义副标题</span><br><span class="line">&lt;h3&gt;     // 定义标题</span><br><span class="line">&lt;h4&gt;     // 定义标题</span><br><span class="line">&lt;h5&gt;     // 定义标题</span><br><span class="line">&lt;h6&gt;     // 定义最小的标题</span><br><span class="line">&lt;hr&gt;     // 创建一条水平线</span><br><span class="line">&lt;legend&gt;    // 元素为 fieldset 元素定义标题</span><br><span class="line">&lt;li&gt;     // 标签定义列表项目</span><br><span class="line">&lt;noframes&gt;    // 为那些不支持框架的浏览器显示文本，于 frameset 元素内部</span><br><span class="line">&lt;noscript&gt;    // 定义在脚本未被执行时的替代内容</span><br><span class="line">&lt;ol&gt;     // 定义有序列表</span><br><span class="line">&lt;ul&gt;    // 定义无序列表</span><br><span class="line">&lt;p&gt;     // 标签定义段落</span><br><span class="line">&lt;pre&gt;     // 定义预格式化的文本</span><br><span class="line">&lt;table&gt;     // 标签定义 HTML 表格</span><br><span class="line">&lt;tbody&gt;     // 标签表格主体（正文）</span><br><span class="line">&lt;td&gt;    // 表格中的标准单元格</span><br><span class="line">&lt;tfoot&gt;     // 定义表格的页脚（脚注或表注）</span><br><span class="line">&lt;th&gt;    // 定义表头单元格</span><br><span class="line">&lt;thead&gt;    // 标签定义表格的表头</span><br><span class="line">&lt;tr&gt;     // 定义表格中的行</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">行内元素不可以设置宽（width）和高（height）,或者说设置了高宽无效</span><br><span class="line">不会独占一行，相邻的行内元素会排列在同一行里，直到一行排不下才会自动换行，其宽度随元素的内容而</span><br><span class="line">变化；</span><br><span class="line">高宽无效，对外边距（margin）和内边距（padding）仅设置左右方向有效 上下无效；</span><br><span class="line">设置行高有效，等同于给父级元素设置行高；</span><br><span class="line">元素的宽度就是它包含的文字或图片的宽度，不可改变；</span><br><span class="line">行内元素中不能放块级元素，a 链接里面不能再放链接；</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;a&gt;     // 标签可定义锚 </span><br><span class="line">&lt;abbr&gt;     // 表示一个缩写形式 </span><br><span class="line">&lt;acronym&gt;     // 定义只取首字母缩写 </span><br><span class="line">&lt;b&gt;     // 字体加粗 </span><br><span class="line">&lt;bdo&gt;     // 可覆盖默认的文本方向 </span><br><span class="line">&lt;big&gt;     // 大号字体加粗 </span><br><span class="line">&lt;br&gt;     // 换行 </span><br><span class="line">&lt;cite&gt;     // 引用进行定义 </span><br><span class="line">&lt;code&gt;    // 定义计算机代码文本</span><br><span class="line">&lt;dfn&gt;     // 定义一个定义项目</span><br><span class="line">&lt;em&gt;     // 定义为强调的内容</span><br><span class="line">&lt;i&gt;     // 斜体文本效果</span><br><span class="line">&lt;kbd&gt;     // 定义键盘文本</span><br><span class="line">&lt;label&gt;     // 标签为 input 元素定义标注（标记）</span><br><span class="line">&lt;q&gt;     // 定义短的引用</span><br><span class="line">&lt;samp&gt;     // 定义样本文本</span><br><span class="line">&lt;select&gt; // 创建单选或多选菜单</span><br><span class="line">&lt;small&gt;     // 呈现小号字体效果</span><br><span class="line">&lt;span&gt;     // 组合文档中的行内元素</span><br><span class="line">&lt;strong&gt; // 加粗</span><br><span class="line">&lt;sub&gt;     // 定义下标文本</span><br><span class="line">&lt;sup&gt;     // 定义上标文本</span><br><span class="line">&lt;textarea&gt;     // 多行的文本输入控件</span><br><span class="line">&lt;tt&gt;     // 打字机或者等宽的文本效果</span><br><span class="line">&lt;var&gt;    // 定义变量</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">高度、行高、外边距以及内边距都可以控制；</span><br><span class="line">默认宽度就是它本身内容的宽度，不独占一行，但是之间会有空白缝隙，设置它上一级的 font-size 为 0，</span><br><span class="line">才会消除间隙；</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;button&gt; </span><br><span class="line">&lt;input&gt;   </span><br><span class="line">&lt;textarea&gt; </span><br><span class="line">&lt;select&gt; </span><br><span class="line">&lt;img&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-ul元素和li元素之间是有一定的间隔的，去掉他们之间间隙的方法：">4.ul元素和li元素之间是有一定的间隔的，去掉他们之间间隙的方法：</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695973720293-633d2c10-4755-4ea9-b58e-4a3a872fd229.png#averageHue=%23fcf9f6&amp;clientId=u09562b73-ac0f-4&amp;from=paste&amp;height=268&amp;id=u231ef2a4&amp;originHeight=335&amp;originWidth=506&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=13386&amp;status=done&amp;style=none&amp;taskId=ua14eb321-7cef-4b76-9cd2-d8935def6ae&amp;title=&amp;width=404.8" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ul&#123;</span><br><span class="line">margin-left:-50px;</span><br><span class="line">&#125;</span><br><span class="line">//利用margin负数左移原理对齐，但是不建议。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//其实这里的li可以看出是ul元素中的内容，浏览器默认设置了它与li之间的左padding;只有我们手动</span><br><span class="line">把padding设置为0就可以解决你。</span><br><span class="line">ul&#123;</span><br><span class="line">padding:0px;&#125;</span><br></pre></td></tr></table></figure><h4 id="5-去除行内块元素之间的空格：">5.去除行内块元素之间的空格：</h4><p>浏览器处理空格的规则：文字的前部和后部的空格都会忽略，内部的连续空格只会算作一个。浏览器会自动把换行符号转成普通的空格键。<br>white-space ：是css针对浏览器对应空格处理的方法。<br>产生原因：html文档中标签与标签之间有换行符和空格，而这些会被解析为文本节点，其中换行符被解析为1个空格，多个连续的空格会被解析为1个空格。这些空格的文本节点在行之间会占据一定的空间的，因此在行内元素和行内块元素之间会有空格，这空格的参数是因为这些标签之间的换行符和空格产生的。<br>消除方法：<br>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;child1&quot;&gt;child1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;child2&quot;&gt;child2&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>方法1：把这些标签紧密书写，让其中没有换行符号和空格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;child1&quot;&gt;child1&lt;/div&gt;&lt;div class=&quot;child2&quot;&gt;child2&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>方法2：使用margin为负值移动特定的元素（不建议）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.child2 &#123;</span><br><span class="line">    margin-left: -5px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法3：空格也是文本的一种可以在其父节点设置font-size: 0,这样就会让子元素中的文字不会显示，同理想要在标签当中的文本也不会显示，这个时候我们在额外设置子标签中的文本大小就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.wrapper &#123;</span><br><span class="line">    font-size: 0;</span><br><span class="line">&#125;</span><br><span class="line">.child1, .child2 &#123;</span><br><span class="line">    font-size: 14px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法4：既然是有标签之间的换行符和空格产生的，我们可以在这之间添加一个不会显示在浏览器上的内容占据换行符和空格就好了。没错这种内容就是注释。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;Resolve Resolve5&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;span&gt;左侧行内元素&lt;/span&gt;&lt;!-- 消除行内元素换行导致的空白</span><br><span class="line"></span><br><span class="line">--&gt;&lt;span&gt;右侧行内元素&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>方法5：使用负的文字间距（letter-spacing）。通过将行内元素和行内块元素之间的文字间距设为负值，同样可以达到移除空白间距的效果。<br>方法6：使用float</p><h4 id="CSS中的float属性：">CSS中的float属性：</h4><p><a href="https://juejin.cn/post/6844903616155746312">CSS 深入理解之 float 浮动 - 掘金</a><br><a href="https://segmentfault.com/a/1190000016153055">滑动验证页面</a><br>1.浮动的概念：就是一个元素脱离了标准流，然后在原本的位置浮起来了（第一个浮起来的元素在本行，后面的可能会紧跟前面浮动元素的行）。其后的块级元素会移动占据浮动元素原来的位置，其中块级元素里面的内容不会占据浮动元素原来的位置，而是环绕它<br>2.特性：包裹性：包裹指的是一个浮动元素，如果子元素宽度足够小，则浮动元素的宽度就是该子元素的宽度。<br>自适应指的是如果浮动元素的父元素有设置宽度，并且浮动元素的子元素宽度超出了父元素，则浮动元素的宽度最终表现为父元素的宽度；<br>破坏性：浮动元素会让父元素发生高度塌陷。也就是父元素的高度为0（父元素没有边框的情况，有边框的话高度在边框的1~2倍之间）<br>块状化：一旦元素float的属性不为none，则其display计算值就是block或者table。这里的块状化意思是可以像block元素一样设置宽和高，并不是真正的块元素。<br>没有任何的margin重叠：也就是说上下左右两个浮动元素之间的大小是其各自元素设置的margin之和。</p><h4 id="清除浮动：">清除浮动：</h4><p>1.清除元素只是清除元素自身的浮动效果，没有浮动的元素也可以清除浮动。清除浮动是让<strong>元素盒子的边不能和前面的浮动元素相邻。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695989142535-5930cc04-db98-4143-80f3-e74d6b566892.png#averageHue=%23edece6&amp;clientId=u09562b73-ac0f-4&amp;from=paste&amp;height=381&amp;id=u3ede46a3&amp;originHeight=476&amp;originWidth=1091&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=295486&amp;status=done&amp;style=none&amp;taskId=ued3eb689-8ac2-45a3-b9ef-19cf61840b3&amp;title=&amp;width=872.8" alt="image.png"><br>上面的clear:left表示该元素的左边不能有浮动元素存在。clear:right表示该元素右边不能有浮动元素，clear:both表示该元素的左右都不能有浮动元素。<br>2.使用伪类元素清除：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695989985378-4fde44d2-ee10-42e9-8367-6af06fe74cfd.png#averageHue=%23f6f5f4&amp;clientId=u09562b73-ac0f-4&amp;from=paste&amp;height=171&amp;id=u37b1cdc3&amp;originHeight=214&amp;originWidth=470&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=11705&amp;status=done&amp;style=none&amp;taskId=ubc4bfcc2-ac48-4a6b-853a-61e19481582&amp;title=&amp;width=376" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1695989991357-02c5c0d3-447d-493c-b92b-3b99576ce4fc.png#averageHue=%23f4f3f3&amp;clientId=u09562b73-ac0f-4&amp;from=paste&amp;height=211&amp;id=ub857d9f9&amp;originHeight=264&amp;originWidth=323&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=7547&amp;status=done&amp;style=none&amp;taskId=ud2261c90-d4e4-45c6-b997-3d9b84e41ef&amp;title=&amp;width=258.4" alt="image.png"><br>这里的.clearfix:after::after 是 CSS 中的一种特殊选择器，它可以在选中的元素的末尾插入一个虚拟的子元素。这个虚拟的子元素可以用于添加样式、内容或进行其他操作。</p><h4 id="导航栏的书写：">导航栏的书写：</h4><p>给每一个导航栏设置一个index属性，然后获取所有相应的div元素，利用排他算法，想把其他设置为空，然后在设置特定的结果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">html</span> lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-<span class="number">8</span>&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; <span class="attribute">content</span>=&quot;IE=edge&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; <span class="attribute">content</span>=&quot;<span class="attribute">width</span>=device-<span class="attribute">width</span>, initial-scale=<span class="number">1.0</span>&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">* &#123;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.table</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">100px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.table_title</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.table_title</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line"><span class="attribute">color</span>:<span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.table_title</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line"><span class="attribute">list-style</span>: none;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line"><span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.p1</span> <span class="selector-tag">ul</span>&#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.p1</span> <span class="selector-tag">li</span>&#123;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> dashed gray;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.hong</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#aaa</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;<span class="selector-tag">table</span>&quot;&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;table_title&quot;&gt;</span><br><span class="line">        &lt;<span class="selector-tag">ul</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">li</span> class=&quot;hong&quot; &gt;热门排行&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">li</span> &gt;美图速递&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">li</span>&gt;前沿科技&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">        &lt;/<span class="selector-tag">ul</span>&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;table_content&quot;&gt;</span><br><span class="line">        &lt;<span class="selector-tag">div</span> style=&quot;<span class="attribute">display</span>:block;&quot; class=&quot;p1&quot;&gt;</span><br><span class="line">            &lt;<span class="selector-tag">ul</span>&gt;</span><br><span class="line">                &lt;<span class="selector-tag">li</span>&gt;习近平出席推进“一带一路”建设工作<span class="number">5</span>周年座谈会&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">                &lt;<span class="selector-tag">li</span>&gt;中共时隔接近三年再修党纪条例子&amp;nbsp;这些高压线不能碰&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">                &lt;<span class="selector-tag">li</span>&gt;全国高中<span class="number">2019</span>年秋季起分步实施新课程使用新教材&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">                &lt;<span class="selector-tag">li</span>&gt;个税法修正草案将二申&amp;nbsp;起征点会否超<span class="number">5000</span>元?&lt;/<span class="selector-tag">li</span>&gt;    </span><br><span class="line">            &lt;/<span class="selector-tag">ul</span>&gt;</span><br><span class="line">        &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">div</span> class=&quot;p1&quot; hidden&gt;</span><br><span class="line">            &lt;<span class="selector-tag">ul</span>&gt;</span><br><span class="line">                &lt;<span class="selector-tag">li</span>&gt;鹅教官,羊陪练......这所中学养的动物成了“网红”&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">                &lt;<span class="selector-tag">li</span>&gt;最伤身体的<span class="number">10</span>个生活习惯,一定要避开&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">                &lt;<span class="selector-tag">li</span>&gt;<span class="number">12</span>岁孩子带着父亲去西藏&amp;nbsp;吃住行自己拿主义&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">                &lt;<span class="selector-tag">li</span>&gt;<span class="number">16</span>岁男孩暑假干了俩月工地,练出满是肌肉,只为赚学费&lt;/<span class="selector-tag">li</span>&gt;    </span><br><span class="line">            &lt;/<span class="selector-tag">ul</span>&gt;</span><br><span class="line">        &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="selector-tag">var</span> lis = document<span class="selector-class">.querySelector</span>(&#x27;<span class="selector-class">.table_title</span>&#x27;)<span class="selector-class">.querySelectorAll</span>(&#x27;<span class="selector-tag">li</span>&#x27;);</span><br><span class="line">        <span class="selector-tag">var</span> divs = document<span class="selector-class">.querySelector</span>(&#x27;<span class="selector-class">.table_content</span>&#x27;)<span class="selector-class">.querySelectorAll</span>(&#x27;<span class="selector-tag">div</span>&#x27;);</span><br><span class="line">        for(<span class="selector-tag">var</span> <span class="selector-tag">i</span> = <span class="number">0</span>; <span class="selector-tag">i</span> &lt; lis<span class="selector-class">.length</span>; <span class="selector-tag">i</span>++) &#123;</span><br><span class="line">        lis<span class="selector-attr">[i]</span><span class="selector-class">.setAttribute</span>(&#x27;index&#x27;,<span class="selector-tag">i</span>);</span><br><span class="line">        lis<span class="selector-attr">[i]</span><span class="selector-class">.onmouseover</span> = function() &#123;</span><br><span class="line">        for(<span class="selector-tag">var</span> <span class="selector-tag">i</span> = <span class="number">0</span>; <span class="selector-tag">i</span> &lt; lis<span class="selector-class">.length</span>; <span class="selector-tag">i</span>++) &#123;</span><br><span class="line">        lis<span class="selector-attr">[i]</span><span class="selector-class">.className</span> = &#x27;&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-tag">var</span> index = this<span class="selector-class">.getAttribute</span>(&#x27;index&#x27;);</span><br><span class="line">        this<span class="selector-class">.className</span> = &#x27;hong&#x27;;</span><br><span class="line">        for(<span class="selector-tag">var</span> <span class="selector-tag">i</span> = <span class="number">0</span>;<span class="selector-tag">i</span> &lt; divs<span class="selector-class">.length</span>; <span class="selector-tag">i</span>++)&#123;</span><br><span class="line">        divs<span class="selector-attr">[i]</span><span class="selector-class">.style</span><span class="selector-class">.display</span> = &#x27;<span class="attribute">none</span>&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        divs<span class="selector-attr">[index]</span><span class="selector-class">.style</span><span class="selector-class">.display</span> = &#x27;block&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">html</span>&gt;</span><br></pre></td></tr></table></figure><p>localstory:<br><a href="https://juejin.cn/post/7149380173027573767">前端本地存储之LocalStorage - 掘金</a><br><a href="https://so.csdn.net/so/search?q=localStorage&amp;spm=1001.2101.3001.7020">localStorage</a>存取数组和对象不像存取字符串那样，<strong>需要序列化和反序列化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rolePower=[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>]</span><br><span class="line">存：localStorage.setItem(<span class="string">&#x27;rolePower&#x27;</span>,JSON.stringify(rolePower))</span><br><span class="line">取：JSON.parse(localStorage.getItem(<span class="string">&quot;rolePower&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> userNews=&#123;id: <span class="string">&quot;aa&quot;</span>, userId: <span class="string">&quot;1234&quot;</span>, loginName: <span class="string">&quot;test&quot;</span>, name: <span class="string">&quot;测试&quot;</span>, orgId: <span class="string">&quot;1001&quot;</span>&#125;</span><br><span class="line">存：localStorage.setItem(<span class="string">&#x27;user&#x27;</span>,JSON.stringify(userNews))</span><br><span class="line">取：JSON.parse(localStorage.getItem(<span class="string">&quot;user&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html"> &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h1&gt;1.VScode的使用：&lt;/h1&gt;
&lt;h2 id=&quot;如何快速生成HTML模板&quot;&gt;如何快速生成HTML模板&lt;/h2&gt;
&lt;p&gt;输入！然后tab就可以快速生成html模板了&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    <category term="课程作业" scheme="http://www.bojiboqi.fun/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="前端" scheme="http://www.bojiboqi.fun/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Curl用法</title>
    <link href="http://www.bojiboqi.fun/2024/01/26/SpringSecurity/"/>
    <id>http://www.bojiboqi.fun/2024/01/26/SpringSecurity/</id>
    <published>2024-01-26T10:44:50.271Z</published>
    <updated>2024-01-26T10:46:06.330Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1>1.curl::</h1><p><a href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html">curl 的用法指南 - 阮一峰的网络日志</a><br>1.用curl访问本地的请求的时候要加上请求协议（本地window的命令行访问的时候）：<br>例子：其中的http：//不能省略<br>curl <a href="http://localhost:8080/student/query">http://localhost:8080/student/query</a><br>但是在git的命令行访问可以不用添加请求协议。<br>2.gitBash中的curl和window命令行的区别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在 Windows 上，curl 命令实际上是 PowerShell</span><br><span class="line">的一个别名，它调用的是 Invoke-WebRequest 命令，而不是</span><br><span class="line">真正的 curl 程序。Invoke-WebRequest 命令的语法和参数</span><br><span class="line">与 curl 不完全相同，所以您的命令会报错。</span><br><span class="line"></span><br><span class="line">•  在 Git Bash 上，curl 命令是真正的 curl 程序，它</span><br><span class="line">是一个跨平台的命令行工具，用于传输数据。curl 程序的</span><br><span class="line">语法和参数与您的命令相匹配，所以您的命令可以正常运行。</span><br></pre></td></tr></table></figure><p>-XPOST和-XGET指定请求的方式。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694611548130-acaa0438-e465-43cf-9d6e-b35ddf3d401b.png#averageHue=%23728c79&amp;clientId=ucef60b48-7be3-4&amp;from=paste&amp;height=656&amp;id=u2eb4139f&amp;originHeight=820&amp;originWidth=1485&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=952125&amp;status=done&amp;style=none&amp;taskId=u21b5a8d2-b91a-45e1-a58e-d3200307ccb&amp;title=&amp;width=1188" alt="image.png"><br>UUID:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UUID是指通用唯一标识符（Universally Unique Identifier）或称为GUID（Globally Unique Identifier）。它是一个标准化的标识符，用于在计算系统中唯一地标识实体或对象。</span><br><span class="line"></span><br><span class="line">UUID是由128位数字组成的字符串，通常以32个十六进制数字的形式表示，按照特定的格式进行排列。每个UUID都可以被认为是在全球范围内唯一的，尽管实际上存在极其低的碰撞概率。</span><br><span class="line"></span><br><span class="line">UUID的生成过程基于一组算法和标识符来源，以确保生成的标识符在理论上是唯一的。它不依赖于中央机构的注册或分配过程，因此可以在分布式系统中独立地生成。</span><br><span class="line"></span><br><span class="line">UUID的主要用途是在分布式系统中唯一标识对象。例如，在数据库中，可以使用UUID作为主键来确保每个实体具有唯一的标识符。它还广泛用于各种应用程序和领域，如软件开发、网络通信、数据同步等。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694611975024-e22777d3-736b-42d1-a1b0-b8f23abbf6c9.png#averageHue=%233b3b46&amp;clientId=ucef60b48-7be3-4&amp;from=paste&amp;height=93&amp;id=u778f921a&amp;originHeight=116&amp;originWidth=1317&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=162042&amp;status=done&amp;style=none&amp;taskId=ue348014f-836a-4523-a40e-7febda6c3a9&amp;title=&amp;width=1053.6" alt="image.png"><br>加入了spring-security安全框架，访问页面就被保护起来了。<img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694612139027-475c4264-3b91-41c9-beec-21517b5bb4e9.png#averageHue=%23030405&amp;clientId=ucef60b48-7be3-4&amp;from=paste&amp;height=281&amp;id=uc6d4130a&amp;originHeight=351&amp;originWidth=1527&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=231037&amp;status=done&amp;style=none&amp;taskId=u63bc6ef0-4af5-4138-9991-8767d6c69d8&amp;title=&amp;width=1221.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694612446560-8eada2e0-cef8-47e5-94ae-d08b6f6d42c7.png#averageHue=%23282c35&amp;clientId=ucef60b48-7be3-4&amp;from=paste&amp;height=280&amp;id=ufc7c12f3&amp;originHeight=350&amp;originWidth=652&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=152507&amp;status=done&amp;style=none&amp;taskId=u062b6340-befd-4f79-a366-c0d53cfa94c&amp;title=&amp;width=521.6" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694612865502-c58620f8-c264-4197-9d34-8a49b0df53a0.png#averageHue=%233d5456&amp;clientId=ucef60b48-7be3-4&amp;from=paste&amp;height=708&amp;id=u9b6f0a37&amp;originHeight=885&amp;originWidth=1558&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=1029390&amp;status=done&amp;style=none&amp;taskId=u11084b65-c03f-4c9a-90f3-4e4be8a1a97&amp;title=&amp;width=1246.4" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694616557090-266184b9-b2ef-4375-be84-574f9b54383e.png#averageHue=%232e343e&amp;clientId=ucef60b48-7be3-4&amp;from=paste&amp;height=126&amp;id=ud95cc5fe&amp;originHeight=157&amp;originWidth=775&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=131346&amp;status=done&amp;style=none&amp;taskId=u8ead350c-a6f1-40dd-b8a0-162b08df9f2&amp;title=&amp;width=620" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694614826396-0d55c071-9b60-4b15-bbe7-ede5250a0147.png#averageHue=%232c3039&amp;clientId=ucef60b48-7be3-4&amp;from=paste&amp;height=122&amp;id=u626669b0&amp;originHeight=153&amp;originWidth=1034&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=169538&amp;status=done&amp;style=none&amp;taskId=u1873c44d-b5b8-411b-9b4a-ec31fcf5062&amp;title=&amp;width=827.2" alt="image.png"><br>（上图最终返回的是一个user对象，如果没有使用UserDetails的方法，就会更加默认或者配置文件来创建user.这种方法创建的user不需要加密器。如果是使用UserDetails注入依赖的方式创建user的时候，创建user的方法要传入一个加密器，这个时候就需要往容器中注入加密器Bean）<br>选中一个类或者接口按住ctrl+H可以查看该类或接口的层次结构。<br>2.<br>InMemoryUserDetailsManager manager=new InMemoryUserDetailsManager();<br>manager.createUser(user1);<br>上面的代码是在内存中创建一个user1新用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过InMemoryUserDetailsManager对象可以在内存中添加、</span><br><span class="line">删除和查询用户的身份验证和授权信息。该方法常用于演示</span><br><span class="line">和测试中。并非持久性的实现。</span><br></pre></td></tr></table></figure><p>MD5等一些加密算法是单向的，也就是无法通过密文解析出明文。同样的明文经过MD5的加密得到的密文是不一样的。但是可以通过passwordEncoder.matches方法匹配成功。<br>@Slf4j<br>@Slf4j 是一个 Lombok 的注解，它用于为类生成一个日志对象，通常命名为 log 。这个日志对象是使用 SLF4J 接口创建的，可以与不同的日志框架（例如 Log4j、Logback 等）兼容。使用 @Slf4j 注解可以省去手动声明和初始化日志对象的代码，简化了日志输出的操作。例如，您可以在类上添加 @Slf4j 注解，然后在方法中使用 <a href="http://log.info">log.info</a>(“Hello World”) 来输出日志信息。<a href="http://www.slf4j.org/https://www.baeldung.com/slf4j-with-log4j2-logback">http://www.slf4j.org/https://www.baeldung.com/slf4j-with-log4j2-logback</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694666072395-fb1b672c-32a4-4c6e-ba76-7e85592ab3ee.png#averageHue=%23728666&amp;clientId=ub7726463-2cc9-4&amp;from=paste&amp;height=278&amp;id=uf5ecd589&amp;originHeight=347&amp;originWidth=1062&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=339701&amp;status=done&amp;style=none&amp;taskId=ub3f3b95e-bccb-4304-8ba3-b67365677d1&amp;title=&amp;width=849.6" alt="image.png"><br>•  当您同时使用 roles() 和 authorities() 方法来为用户分配角色和权限时，Spring Security 会将它们合并成一个 GrantedAuthority 的集合，并赋值给用户的 authorities 属性。但是，如果您在 authorities() 方法中指定了一个以 ROLE_ 开头的权限，那么它会与 roles() 方法中指定的角色发生冲突，导致后者被覆盖。<a href="https://howtodoinjava.com/spring-security/spring-boot-role-based-authorization/https://dev.inherency.net/2020/01/spring-security-authority-vs-role.html">https://howtodoinjava.com/spring-security/spring-boot-role-based-authorization/https://dev.inherency.net/2020/01/spring-security-authority-vs-role.html</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694669694506-0d890d45-2575-4224-bd23-5b1c2616c45d.png#averageHue=%23faf9f9&amp;clientId=ub7726463-2cc9-4&amp;from=paste&amp;height=350&amp;id=u97e2f114&amp;originHeight=437&amp;originWidth=1412&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=50266&amp;status=done&amp;style=none&amp;taskId=uc5125ea6-8de9-4b59-b7a4-c0f6b9d3b2d&amp;title=&amp;width=1129.6" alt="image.png"><br>@EnableGlobalMethodSecurity(prePostEnabled = true) 是一个 Spring Security 的注解，它用于开启全局的方法级别的安全控制。这个注解的 prePostEnabled 属性表示是否启用 Spring Security 的 pre post 注解，例如 @PreAuthorize 和 @PostAuthorize，这些注解可以在方法执行前后进行权限检查和决策。<a href="https://www.baeldung.com/spring-enablemethodsecurityhttps://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/config/annotation/method/configuration/EnableGlobalMethodSecurity.html">https://www.baeldung.com/spring-enablemethodsecurityhttps://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/config/annotation/method/configuration/EnableGlobalMethodSecurity.html</a></p><p>例如，您可以在您的 Controller 类上添加 @EnableGlobalMethodSecurity(prePostEnabled = true) 注解，然后在您的方法上添加 @PreAuthorize(“hasAuthority(‘admin’)”) 注解，这样就可以限制只有拥有 admin 权限的用户才能访问该方法。<a href="https://stackoverflow.com/questions/74910066/enableglobalmethodsecurity-is-deprecated-in-the-new-spring-boot-3-0">https://stackoverflow.com/questions/74910066/enableglobalmethodsecurity-is-deprecated-in-the-new-spring-boot-3-0</a></p><p>需要注意的是，@EnableGlobalMethodSecurity 注解已经在 Spring Security 5.6 版本中被废弃，取而代之的是 @EnableMethodSecurity 注解，它提供了更灵活的方式来配置不同类型的方法安全控制。<a href="https://blog.csdn.net/niugang0920/article/details/90516898">https://blog.csdn.net/niugang0920/article/details/90516898</a></p><h2 id="Resource">@Resource</h2><h2 id="private-ObjectMapper-objectMapper">private ObjectMapper objectMapper;</h2><p>ObjectMapper 是一个 Jackson 库中的类，它用于读写 JSON 数据，可以将 Java 对象和 JSON 字符串相互转换。@Resource 注解是一个 Java EE 标准的注解，它用于指定要注入的资源的名称或类型，可以与 Spring 框架的自动装配功能配合使用</p><h2 id="Builder">@Builder:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Builder 是一个 Lombok 注解，用于自动生成构建器模式的代码。通过在类上添加 @Builder 注解，可以自动生成一个内部静态类（Builder 类），该类提供了一种更简洁的方式来创建类的实例。</span><br><span class="line"></span><br><span class="line">使用 @Builder 注解后，Lombok 会自动生成以下内容：</span><br><span class="line"></span><br><span class="line">内部静态类（Builder 类）：生成一个内部静态类，该类具有与目标类相同的字段，并提供链式调用的方法来设置这些字段的值。</span><br><span class="line">构建器方法：在目标类中生成一个静态方法，该方法返回 Builder 类的实例，用于创建目标类的对象。</span><br><span class="line">链式调用方法：在 Builder 类中生成用于设置字段值的方法，这些方法返回 Builder 类的实例本身，以支持链式调用。</span><br><span class="line">使用 @Builder 注解可以简化创建对象的过程，不再需要手动编写繁琐的构造方法或使用大量的 setXxx() 方法来设置字段的值。</span><br><span class="line"></span><br><span class="line">以下是一个示例：</span><br><span class="line">import lombok.Builder;</span><br><span class="line">import lombok.Getter;</span><br><span class="line"></span><br><span class="line">@Getter</span><br><span class="line">@Builder</span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在其他地方使用</span><br><span class="line">Person person = Person.builder()</span><br><span class="line">    .name(&quot;John&quot;)</span><br><span class="line">    .age(25)</span><br><span class="line">    .address(&quot;123 Main St&quot;)</span><br><span class="line">    .build();</span><br><span class="line">在上述示例中，@Builder 注解为 Person 类生成了一个内部的 Builder 类。然后，通过链式调用的方式</span><br><span class="line">设置字段的值，并使用 build() 方法创建了一个 Person 对象。</span><br><span class="line"></span><br><span class="line">总结：@Builder 是一个 Lombok 注解，用于自动生成构建器模式的代码，简化创建对象的过程。它生</span><br><span class="line">成一个内部静态的 Builder 类，提供了链式调用的方式来设置字段的值，并最终创建目标类的对象。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694680461972-efed5e42-bcf1-443a-aacc-f4c26162c6fd.png#averageHue=%23675237&amp;clientId=ub7726463-2cc9-4&amp;from=paste&amp;height=309&amp;id=u41ceb554&amp;originHeight=386&amp;originWidth=1094&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=304835&amp;status=done&amp;style=none&amp;taskId=u5d30fe76-3db5-4cf0-97fe-8ce3b230223&amp;title=&amp;width=875.2" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694680761541-17242a60-0ef6-4325-b203-d106f2f52611.png#averageHue=%23d6e2e2&amp;clientId=ub7726463-2cc9-4&amp;from=paste&amp;height=69&amp;id=ua6cf48e5&amp;originHeight=86&amp;originWidth=760&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=40420&amp;status=done&amp;style=none&amp;taskId=ua74bd619-4dee-4ce9-a721-3e06127c0f7&amp;title=&amp;width=608" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest//这里使用@SpringBootTest的原因是：该注解会</span><br><span class="line">//    启动整个应用程序上下文：@SpringBootTest 注解会加载完整的 Spring 应用程序上下文，包括所有的配置、组件和依赖。</span><br><span class="line">//    这样就不用自己去解决相关依赖问题了，比如下面的测试：就需要 SysUser对象，如果没有在springboot的环境下测试</span><br><span class="line">//    那么SysUserServiceImpl类下的SysUserDao无法在整个测试环境中创建，自然就会报空指针异常了。如果在springboot</span><br><span class="line">//    环境下测试，那SysUserDao的实例管理就交给了IOC了</span><br><span class="line">class SysUserServiceImplTest &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private SysUserService sysUserService;</span><br><span class="line">    @Test</span><br><span class="line">    void getByUserName() &#123;</span><br><span class="line">        SysUser sysUser = sysUserService.getByUserName(&quot;dddd&quot;);</span><br><span class="line">        assertNull(sysUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694684945700-15b02ed7-5cfe-4952-8feb-89c47d9c5f3d.png#averageHue=%234d5e53&amp;clientId=ub7726463-2cc9-4&amp;from=paste&amp;height=337&amp;id=ud23eaca0&amp;originHeight=421&amp;originWidth=1297&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=439342&amp;status=done&amp;style=none&amp;taskId=u9e8f1480-cce6-4a1f-9de5-b6e82df3513&amp;title=&amp;width=1037.6" alt="image.png">安全上下文获取的认证信息是实现了UserDetails接口的类，如果自己没有覆盖就是系统默认的User类，否则为自己配置的实现类。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694685496426-558cb20c-72f8-44d9-b6fe-4a8dc0b90acc.png#averageHue=%233c4657&amp;clientId=ub7726463-2cc9-4&amp;from=paste&amp;height=150&amp;id=ub30cdf13&amp;originHeight=188&amp;originWidth=406&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=75636&amp;status=done&amp;style=none&amp;taskId=u19e048ed-406f-4170-bf53-87c57bee712&amp;title=&amp;width=324.8" alt="image.png"><br>10开始看源码<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694687888251-384842e9-9568-4b64-a3c9-a825cc17eb1c.png#averageHue=%23654a36&amp;clientId=ub7726463-2cc9-4&amp;from=paste&amp;height=134&amp;id=ua894d2d6&amp;originHeight=167&amp;originWidth=1125&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=135532&amp;status=done&amp;style=none&amp;taskId=u4945c0dd-addd-4efc-9d89-25c21c714c4&amp;title=&amp;width=900" alt="image.png"><br>验证码的好处：一定程度上防止别人利用for循环脚本破解密码。<br>@ConfigurationProperties(prefix = “spring.security”) 是一个 Spring Boot 的注解，它用于将配置文件中的属性绑定到一个 Java 类中的字段。这个注解的 prefix 属性指定了属性的前缀，也就是配置文件中的键的公共部分。<br>@EnableGlobalMethodSecurity(prePostEnabled = true)用于开启全局的方法级别的安全控制。这个注解的 prePostEnabled 属性表示是否启用 Spring Security 的 pre post 注解，例如 @PreAuthorize 和 @PostAuthorize，这些注解可以在方法执行前后进行权限检查和决策。在 Spring Security 5.6 版本中被废弃，取而代之的是 @EnableMethodSecurity 注解<br>ObjectMapper 是一个 Jackson 库中的类，它用于读写 JSON 数据，可以将 Java 对象和 JSON 字符串相互转换。<br>map-underscore-to-camel-case: true 这个键用于指定 MyBatis 是否开启驼峰命名法的转换<br><a href="https://zhuanlan.zhihu.com/p/112244547">MyBatis中 #{} 和 ${} 区别</a><br>安全上下文（SecurityContext）是一个接口，它定义了与当前执行线程关联的最小安全信息。安全上下文存储在SecurityContextHolder中，可以通过SecurityContextHolder.getContext()方法获取。安全上下文包含了当前经过身份验证的用户的Authentication对象，以及一些其他的安全相关的信息。Authentication对象又包含了用户的主体（Principal）、凭证（Credentials）、权限（Authorities）等信息。Spring Security在认证和授权的过程中，会使用安全上下文中的信息来进行判断和处理。<a href="https://blog.csdn.net/qq_41071876/article/details/122290308">Spring Security核心组件之安全上下文_这是一条海鱼的博客-CSDN博客</a><br><a href="https://cloud.tencent.com/developer/article/1838816">Spring Security 实战干货：如何获取当前用户信息-腾讯云开发者社区-腾讯云</a><br>@Controller是用于处理普通的HTTP请求，而@RestController是用于处理RESTful风格的HTTP请求。@RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用，它会自动将返回值序列化为JSON或XML格式的数据，而@Controller则需要手动进行序列化或者配合视图解析器来返回指定页面。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694738995817-85859cfd-11c0-408b-8b12-0149e29b4606.png#averageHue=%235b614c&amp;clientId=ub7726463-2cc9-4&amp;from=paste&amp;height=446&amp;id=u8bc5bdad&amp;originHeight=557&amp;originWidth=1293&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=195200&amp;status=done&amp;style=none&amp;taskId=ucaf3d586-0e40-46b3-b816-8e2474de109&amp;title=&amp;width=1034.4" alt="image.png"><br>session<br>Session（会话）是在Web开发中用于跟踪用户状态和存储用户数据的一种机制。它是建立在HTTP协议之上的一种状态管理方式。<br>在Web应用中，每个用户与服务器之间的交互都是通过HTTP请求和响应进行的。由于HTTP协议的无状态性，服务器无法直接识别不同的用户或跟踪用户的状态。这就需要使用会话来解决这个问题。<br>会话通过在服务器端存储用户的状态信息，并为每个用户分配一个唯一的标识符（Session ID）来跟踪用户。当用户首次访问服务器时，服务器会为该用户创建一个新的会话，并将会话ID发送给客户端，通常是通过Cookie或URL重写的方式。<br>客户端在随后的请求中会携带会话ID，服务器根据会话ID识别用户，并根据需要读取或修改会话中存储的数据。这样就可以实现在多个请求之间共享用户状态和数据的功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Base64URL是Base64编码的一种变体，它可以安全地用于URL和其他一些特殊字符可能有特殊含义的场合。它与标准的Base64有以下几点不同：</span><br><span class="line"></span><br><span class="line">•  它用&#x27;-&#x27;和&#x27;_&#x27;分别替换了&#x27;+&#x27;和&#x27;/&#x27;字符，以避免URL编码或解码的需要。</span><br><span class="line"></span><br><span class="line">•  它省略了末尾的填充&#x27;=&#x27;字符，以使编码后的字符串更短，也避免与查询参数或分隔符混淆。</span><br><span class="line"></span><br><span class="line">•  它使用与Base64相同的字母表，由A-Z, a-z, 0-9, -, 和 _ 组成。</span><br><span class="line"></span><br><span class="line">Base64URL通常用于以紧凑和便携的方式编码二进制数据，如加密密钥、令牌或标识符。例如，JSON Web Tokens (JWTs)使用Base64URL来编码它们的头部、有效载荷和签名部分。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/28066124/1694746646263-7ea77d1f-1f2c-4cee-8f62-c62ecde18275.png#averageHue=%23f9f9f9&amp;clientId=ub7726463-2cc9-4&amp;from=paste&amp;height=286&amp;id=u2c6346e0&amp;originHeight=357&amp;originWidth=963&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=39212&amp;status=done&amp;style=none&amp;taskId=ucbced83c-e82f-4756-ad51-792239d639f&amp;title=&amp;width=770.4" alt="image.png"><br>token非法或者过期后都会验证不通过。<br><a href="https://www.cnblogs.com/longfurcat/p/9417912.html">核心组件之SecurityContextHolder - 猫毛·波拿巴 - 博客园</a><br>spting security从前端传来的用户名和密码储存在哪个变量中？<br>在Spring Security中，从前端传来的用户名和密码通常存储在UsernamePasswordAuthenticationToken对象中。<br>http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);<br>http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) 是Spring Security中用于配置会话管理的一行代码。<br>这行代码的作用是设置会话创建策略为STATELESS，也就是无状态会话。在无状态会话中，服务器不会在后端存储任何与会话相关的信息，也不会分配会话ID给客户端。<br>具体地说，这行代码的含义是：</p><ol><li>http.sessionManagement()：获取HttpSecurity对象的会话管理配置。</li><li>.sessionCreationPolicy(SessionCreationPolicy.STATELESS)：设置会话创建策略为STATELESS，即无状态会话。</li></ol><p>设置会话创建策略为STATELESS的主要目的是在构建基于令牌（Token）的身份验证机制时使用。在无状态会话中，服务器不维护任何会话状态，所有的认证信息都包含在每个请求的令牌中。这使得应用程序可以更轻松地进行横向扩展，因为服务器不需要存储会话状态。<br>需要注意的是，在使用无状态会话时，通常需要使用其他机制（如JWT）来存储和传递身份验证信息，以便每个请求都能够进行身份验证。<br>总结：http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) 是Spring Security中用于配置会话管理的代码，将会话创建策略设置为无状态会话，适用于构建基于令牌的身份验证机制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h1&gt;1.curl::&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ruanyifeng.com/blog/2019/09/curl-reference.html&quot;&gt;curl</summary>
      
    
    
    
    <category term="杂项" scheme="http://www.bojiboqi.fun/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>软件测试</title>
    <link href="http://www.bojiboqi.fun/2024/01/26/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    <id>http://www.bojiboqi.fun/2024/01/26/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</id>
    <published>2024-01-26T10:43:10.827Z</published>
    <updated>2024-01-26T10:43:59.504Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1>1.Junit单元测试教程:</h1><h2 id="基础测试：">基础测试：</h2><p>官方文档：<a href="https://junit.org/junit5/docs/current/user-guide/index.html#migrating-from-junit4">JUnit 5 User Guide</a><br>教学链接：<a href="https://blog.csdn.net/weixin_44170221/article/details/106463482">超级详细的Junit单元测试教程_何学长在奔跑的博客-CSDN博客</a><br>注意：<br>1.Junit4中的断言是Assert.assertEquals这种样式的（也就是教学链接里面的样子）<br>但是Junit5中的断言是直接使用assertEquals。<br>2.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method.invoke(junitClass.newInstance()); invoke是调用反射类的方法</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/wyx1990/p/12732902.html">Eclipse搭建selenium环境 - 景月 - 博客园</a><br>超时测试：&quot;@Test (timeout=&quot;规定的时间）</p><h2 id="参数测试：">参数测试：</h2><p><a href="https://blog.csdn.net/w605283073/article/details/80051229">JUnit4 参数化测试（ Parameterized tests）_junit参数化测试_明明如月学长的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
&lt;h1&gt;1.Junit单元测试教程:&lt;/h1&gt;
&lt;h2 id=&quot;基础测试：&quot;&gt;基础测试：&lt;/h2&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://junit.org/junit5/doc</summary>
      
    
    
    
    <category term="课程作业" scheme="http://www.bojiboqi.fun/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="软件测试" scheme="http://www.bojiboqi.fun/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
