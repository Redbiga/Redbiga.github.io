<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>山麋一笑</title>
  
  
  <link href="http://www.bojiboqi.fun/atom.xml" rel="self"/>
  
  <link href="http://www.bojiboqi.fun/"/>
  <updated>2024-04-23T00:29:56.886Z</updated>
  <id>http://www.bojiboqi.fun/</id>
  
  <author>
    <name>山麋一笑</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CountDownLatch</title>
    <link href="http://www.bojiboqi.fun/2024/04/23/CountDownLatch/"/>
    <id>http://www.bojiboqi.fun/2024/04/23/CountDownLatch/</id>
    <published>2024-04-23T00:28:10.656Z</published>
    <updated>2024-04-23T00:29:56.886Z</updated>
    
    <content type="html"><![CDATA[<p><a name="nnrGe"></a></p><h2 id="CountDownLatch介绍"><a href="https://so.csdn.net/so/search?q=CountDownLatch&amp;spm=1001.2101.3001.7020">CountDownLatch</a>介绍</h2><p><a name="MAMnE"></a></p><h3 id="CountDownLatch概述">CountDownLatch概述</h3><ol><li><code>CountDownLatch</code>一般用作多线程倒计时计数器，强制它们等待其他一组（<code>CountDownLatch</code>的初始化决定）任务执行完成。</li><li>有一点要说明的是<code>CountDownLatch</code>初始化后计数器值递减到0的时候，不能再复原的，这一点区别于<code>Semaphore</code>，<code>Semaphore</code>是可以通过<code>release</code>操作恢复信号量的。<br><a name="zJV6U"></a></li></ol><h3 id="CountDownLatch使用原理">CountDownLatch使用原理</h3><p><a name="O7Xui"></a></p><h4 id="使用原理">使用原理</h4><ol><li>创建CountDownLatch并设置计数器值。</li><li>启动多线程并且调用CountDownLatch实例的countDown()方法。</li><li>主线程调用 <code>await()</code> 方法，这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务，count值为0，停止阻塞，主线程继续执行。<br><a name="CP8uS"></a></li></ol><h4 id="使用模板">使用模板</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class CountDownLatchModule &#123;</span><br><span class="line"></span><br><span class="line">    //线程数</span><br><span class="line">    private static int N = 10;</span><br><span class="line"></span><br><span class="line">    // 单位：min</span><br><span class="line">    private static int countDownLatchTimeout = 5;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建CountDownLatch并设置计数值，该count值可以根据线程数的需要设置</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(N);</span><br><span class="line"></span><br><span class="line">//创建线程池</span><br><span class="line">        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">            cachedThreadPool.execute(() -&gt;&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; do something!&quot;);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    System.out.println(&quot;Exception: do something exception&quot;);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    //该线程执行完毕-1</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;main thread do something-1&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            countDownLatch.await(countDownLatchTimeout, TimeUnit.MINUTES);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(&quot;Exception: await interrupted exception&quot;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;countDownLatch: &quot; + countDownLatch.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;main thread do something-2&quot;);</span><br><span class="line">        //若需要停止线程池可关闭;</span><br><span class="line">//        cachedThreadPool.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">main thread do something-1</span><br><span class="line">pool-1-thread-1 do something!</span><br><span class="line">pool-1-thread-2 do something!</span><br><span class="line">pool-1-thread-3 do something!</span><br><span class="line">pool-1-thread-5 do something!</span><br><span class="line">pool-1-thread-6 do something!</span><br><span class="line">pool-1-thread-7 do something!</span><br><span class="line">pool-1-thread-8 do something!</span><br><span class="line">pool-1-thread-4 do something!</span><br><span class="line">pool-1-thread-9 do something!</span><br><span class="line">pool-1-thread-10 do something!</span><br><span class="line">countDownLatch: java.util.concurrent.CountDownLatch@76fb509a[Count = 0]</span><br><span class="line">main thread do something-2</span><br></pre></td></tr></table></figure><p><a name="bmOsl"></a></p><h3 id="CountDownLatch常用方法">CountDownLatch常用方法</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713798181770-025cd5c4-0c3d-441a-9865-75f13237611e.png#averageHue=%234c4940&amp;clientId=ub188d3be-42e2-4&amp;from=paste&amp;id=uc431f572&amp;originHeight=286&amp;originWidth=448&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=35225&amp;status=done&amp;style=none&amp;taskId=u64936027-77e7-45ec-9fa5-d4ce12a8b88&amp;title=" alt="image.jpg"></p><ul><li><code>public void await() throws InterruptedException</code>：调用<code>await()</code>方法的线程会被挂起，等待直到<code>count</code>值为<code>0</code>再继续执行。</li><li><code>public boolean await(long timeout, TimeUnit unit) throws InterruptedException</code>：同<code>await()</code>，若等待<code>timeout</code>时长后，<code>count</code>值还是没有变为0，不再等待，继续执行。时间单位如下常用的毫秒、天、小时、微秒、分钟、纳秒、秒。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713798181944-8b8dca81-e858-4dbe-a938-cd7fb80d382f.png#averageHue=%23364452&amp;clientId=ub188d3be-42e2-4&amp;from=paste&amp;id=ua6ea971c&amp;originHeight=234&amp;originWidth=626&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=58236&amp;status=done&amp;style=none&amp;taskId=ua0b715db-36a0-4ca6-a6d7-a85becb332f&amp;title=" alt="image.jpg"></li><li><code>public void countDown()</code>： count值递减1.</li><li><code>public long getCount()</code>：获取当前count值。</li><li><code>public String toString()</code>：重写了toString()方法，多打印了count值，具体参考源码。<br><a name="BCkdh"></a></li></ul><h3 id="CountDownLatch使用场景">CountDownLatch使用场景</h3><p>一个程序中有N个任务在执行，我们可以创建值为N的CountDownLatch，当每个任务完成后，调用一下<code>countDown()</code>方法进行递减<code>count值</code>，再在主线程中使用<code>await()</code>方法等待任务执行完成，主线程继续执行。<br><a name="GJ85B"></a></p><h2 id="CountDownLatch源码">CountDownLatch源码</h2><p><a name="tdICX"></a></p><h3 id="构造方法源码">构造方法源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Constructs a &#123;@code CountDownLatch&#125; initialized with the given count.</span><br><span class="line">     *</span><br><span class="line">     * @param count the number of times &#123;@link #countDown&#125; must be invoked</span><br><span class="line">     *        before threads can pass through &#123;@link #await&#125;</span><br><span class="line">     * @throws IllegalArgumentException if &#123;@code count&#125; is negative</span><br><span class="line">     */</span><br><span class="line">    public CountDownLatch(int count) &#123;</span><br><span class="line">        if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);</span><br><span class="line">        this.sync = new Sync(count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a name="pJ53W"></a></p><h3 id="toString-方法源码">toString()方法源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Returns a string identifying this latch, as well as its state.</span><br><span class="line">     * The state, in brackets, includes the String &#123;@code &quot;Count =&quot;&#125;</span><br><span class="line">     * followed by the current count.</span><br><span class="line">     *</span><br><span class="line">     * @return a string identifying this latch, as well as its state</span><br><span class="line">     */</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return super.toString() + &quot;[Count = &quot; + sync.getCount() + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a name="BOSBI"></a></p><h2 id="CountDownLatch示例">CountDownLatch示例</h2><p><a name="QHUXs"></a></p><h3 id="作为线程启动信号">作为线程启动信号</h3><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class CountDownLatchTest &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * a start signal that prevents any worker from proceeding</span><br><span class="line">     * until the driver is ready for them to proceed;</span><br><span class="line">     * @param args</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        CountDownLatch startSignal = new CountDownLatch(1);</span><br><span class="line">        CountDownLatch doneSignal = new CountDownLatch(10);</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            // create and start threads</span><br><span class="line">            new Thread(new Worker(startSignal, doneSignal)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        // don&#x27;t let run yet</span><br><span class="line">        System.out.println(&quot;do something else 1&quot;);</span><br><span class="line">        // let all threads proceed</span><br><span class="line">        startSignal.countDown();</span><br><span class="line">        System.out.println(&quot;do something else 2&quot;);</span><br><span class="line">        // wait for all to finish</span><br><span class="line">        doneSignal.await();</span><br><span class="line">        System.out.println(&quot;wait for all to finsh&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Worker implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">        private final CountDownLatch startSignal;</span><br><span class="line">        private final CountDownLatch doneSignal;</span><br><span class="line"></span><br><span class="line">        Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line">            this.startSignal = startSignal;</span><br><span class="line">            this.doneSignal = doneSignal;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                startSignal.await();</span><br><span class="line">                doWork();</span><br><span class="line">                doneSignal.countDown();</span><br><span class="line">            &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void doWork() &#123;</span><br><span class="line">            System.out.println(&quot;do work!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">do something else 1</span><br><span class="line">do something else 2</span><br><span class="line">do work!</span><br><span class="line">do work!</span><br><span class="line">do work!</span><br><span class="line">do work!</span><br><span class="line">do work!</span><br><span class="line">do work!</span><br><span class="line">do work!</span><br><span class="line">do work!</span><br><span class="line">do work!</span><br><span class="line">do work!</span><br><span class="line">wait for all to finsh</span><br></pre></td></tr></table></figure><p>从运行结果可以看出：</p><ol><li>主线程先打印<code>do something else 1</code>和<code>do something else 2</code>。因为<code>startSignal.countDown();</code>完后，count才为0，子线程才能打印。</li><li>因为<code>startSignal.await();</code>是在子线程内，所有子线程都等待<code>startSignal.countDown()</code>执行后才能打印<code>do work!</code>。</li><li><code>doneSignal.await();</code>等待所有子线程执行后，每次都<code>doneSignal.countDown()</code>，最后count为0，主线程才执行打印<code>wait for all to finsh</code>。<br><a name="qoqNn"></a></li></ol><h3 id="作为线程等待完成信号">作为线程等待完成信号</h3><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class CountDownLatchTest2 &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * a completion signal that allows the driver to wait</span><br><span class="line">     * until all workers have completed.</span><br><span class="line">     * @param args</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        CountDownLatch doneSignal = new CountDownLatch(5);</span><br><span class="line">        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            // create and start threads</span><br><span class="line">            cachedThreadPool.execute(new Worker(doneSignal, i));</span><br><span class="line">        &#125;</span><br><span class="line">        // don&#x27;t let run yet</span><br><span class="line">        System.out.println(&quot;do something else 1&quot;);</span><br><span class="line">        // wait for all to finish</span><br><span class="line">        doneSignal.await();</span><br><span class="line">        System.out.println(&quot;===========================count: &quot; + doneSignal.getCount());</span><br><span class="line">        System.out.println(&quot;do something else 2&quot;);</span><br><span class="line">        cachedThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Worker implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">        private final CountDownLatch doneSignal;</span><br><span class="line">        private final int i;</span><br><span class="line"></span><br><span class="line">        Worker(CountDownLatch doneSignal, int i) &#123;</span><br><span class="line">            this.doneSignal = doneSignal;</span><br><span class="line">            this.i = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                doWork();</span><br><span class="line">                doneSignal.countDown();</span><br><span class="line">                System.out.println(&quot;i = &quot; + i + &quot;, &quot; + doneSignal.toString());</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void doWork() &#123;</span><br><span class="line">            System.out.println(&quot;do work!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">do something else 1</span><br><span class="line">do work!</span><br><span class="line">i = 0, java.util.concurrent.CountDownLatch@128abd43[Count = 4]</span><br><span class="line">do work!</span><br><span class="line">i = 1, java.util.concurrent.CountDownLatch@128abd43[Count = 3]</span><br><span class="line">do work!</span><br><span class="line">i = 2, java.util.concurrent.CountDownLatch@128abd43[Count = 2]</span><br><span class="line">do work!</span><br><span class="line">i = 3, java.util.concurrent.CountDownLatch@128abd43[Count = 1]</span><br><span class="line">do work!</span><br><span class="line">i = 4, java.util.concurrent.CountDownLatch@128abd43[Count = 0]</span><br><span class="line">===========================count: 0</span><br><span class="line">do something else 2</span><br><span class="line">do work!</span><br><span class="line">i = 5, java.util.concurrent.CountDownLatch@128abd43[Count = 0]</span><br><span class="line">do work!</span><br><span class="line">i = 6, java.util.concurrent.CountDownLatch@128abd43[Count = 0]</span><br><span class="line">do work!</span><br><span class="line">i = 7, java.util.concurrent.CountDownLatch@128abd43[Count = 0]</span><br><span class="line">do work!</span><br><span class="line">i = 8, java.util.concurrent.CountDownLatch@128abd43[Count = 0]</span><br><span class="line">do work!</span><br><span class="line">i = 9, java.util.concurrent.CountDownLatch@128abd43[Count = 0]</span><br></pre></td></tr></table></figure><p>从运行结果可以看出，主线程是等待其他线程运行了5次结束后就打印了<code>do something else 2</code>信息，因为CountDownLatch数值为5。</p><blockquote><p>来自: <a href="https://blog.csdn.net/Andya_net/article/details/106237511">Java—CountDownLatch使用详解_java countdownlatch用法-CSDN博客</a></p></blockquote><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;nnrGe&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;CountDownLatch介绍&quot;&gt;&lt;a href=&quot;https://so.csdn.net/so/search?q=CountDownLatch&amp;amp;spm=1001.2101.3001.7020&quot;&gt;C</summary>
      
    
    
    
    <category term="java基础" scheme="http://www.bojiboqi.fun/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="并发" scheme="http://www.bojiboqi.fun/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="java基础" scheme="http://www.bojiboqi.fun/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>深入了解 JDK自带工具- jps</title>
    <link href="http://www.bojiboqi.fun/2024/04/22/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%20JDK%E8%87%AA%E5%B8%A6%E5%B7%A5%E5%85%B7-%20jps/"/>
    <id>http://www.bojiboqi.fun/2024/04/22/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%20JDK%E8%87%AA%E5%B8%A6%E5%B7%A5%E5%85%B7-%20jps/</id>
    <published>2024-04-22T06:34:29.767Z</published>
    <updated>2024-04-22T23:27:26.542Z</updated>
    
    <content type="html"><![CDATA[<p>本文将对JVM自带的工具jps（Java Process Status）进行深入详细的分析与讲解。我们会探讨它的基本功能、如何使用、以及在实际场景中的应用。本文将深入分析jps工具的用法、输出信息的含义以及如何在日常开发和维护中受益于它。</p><p><strong>jps简介</strong></p><p>JPS（Java Process Status）是Java JDK自带的一款命令行工具，用于查看当前所有运行在JVM上的java进程。它位于JDK的bin目录下，当我们启动一个Java程序时，会启动一个JVM进程，使用JPS便可以查看当前系统中的所有Java进程和它们的状态。开发者可以用它快速获取Java应用程序进程的基本信息，如进程ID（LVMID）和主类名称。这个工具在查找特定Java进程、诊断问题、或是启动其他JDK工具时非常有用。</p><p><strong>基本用法</strong></p><p><strong>JPS命令格式：jps [options] [hostid]</strong><br />其中，options参数是可选的，hostid参数也是可选的。如果不输入任何参数，则JPS将显示当前所有的Java进程。<br />下面我们来详细介绍一下JPS命令的常用选项：</p><ul><li><strong>-l：输出主类或jar文件的完整路径</strong></li><li><strong>-q：只输出进程号</strong></li><li><strong>-m：输出传递给main方法的参数</strong></li><li><strong>-v：输出传递给JVM的参数</strong></li><li><strong>-V：显示版本信息</strong></li><li><strong>-n：指定输出进程数量的最大值</strong></li><li><strong>-x：显示没有响应的进程</strong></li><li><strong>-u：显示Java进程的详细用户信息，或指定用户的进程信息。需要注意的是，显示的用户信息取决于运行jps命令的用户权限</strong>。</li></ul><p>除了这些选项之外，还有一些常用的过滤器，可以帮助我们更快地查找到我们需要的信息。常用的过滤器有：</p><ul><li><strong><a href="http://com.xxx">com.xxx</a>.*：匹配以com.xxx开头的进程</strong></li><li><strong><a href="http://org.xxx">org.xxx</a>.*：匹配以org.xxx开头的进程</strong></li><li>*<strong>.Main：匹配含有Main方法的主类</strong></li><li><strong>12345：匹配进程号为12345的进程</strong></li></ul><p>使用过滤器时，可以在选项后面跟上多个过滤器，用空格分隔开即可。</p><p><strong>使用案例</strong><br /><strong>查看当前所有Java进程</strong><br />如果查看当前系统中所有的Java进程，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1jps</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">119273 Jps</span><br><span class="line">220645 Main</span><br></pre></td></tr></table></figure><p>在这个例子中，有两个Java进程正在运行。其中，进程ID为19273的进程正在执行<code>jps</code>命令本身，而进程ID为20645的进程则是一个名为<code>Main</code>的Java应用程序。<br /><strong>查看指定进程ID的进程信息</strong><br />如果查看进程ID为20645的Java进程的详细信息，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1jps -l 20645</span><br></pre></td></tr></table></figure><p>这将会输出类似如下的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">120645 com.example.Main</span><br></pre></td></tr></table></figure><p>这表示进程ID为20645的Java进程是由<code>com.example.Main</code>这个主类启动的。<br /><strong>查看进程的主类和参数</strong><br />如果要同时查看所有Java进程的主类和参数，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1jps -lv</span><br></pre></td></tr></table></figure><p>这将会输出类似如下的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">119273 sun.tools.jps.Jps -Dapplication.home=/usr/lib/jvm/java-8-oracle -Xms8m</span><br><span class="line">2</span><br><span class="line">320645 com.example.Main arg1 arg2</span><br></pre></td></tr></table></figure><p>在这段输出中，第一行是<code>jps</code>命令本身的运行信息。第二行则是另一个Java应用的信息。可以看到，它是由<code>com.example.Main</code>这个主类启动的，并且传递了两个参数<code>arg1</code>和<code>arg2</code>。<br /><strong>模糊匹配过滤进程</strong><br />要查找所有以com.xxx开头的进程，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1jps -l com.xxx.*</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11234 com.xxx.Application1</span><br><span class="line">25678 com.xxx.Application2</span><br></pre></td></tr></table></figure><p>在上述示例中，jps -l <a href="http://com.xxx">com.xxx</a>.* 命令列出了两个匹配的Java进程，它们的主类名分别是 com.xxx.Application1 和 com.xxx.Application2，并显示了它们的进程ID（1234和5678）。这个命令对于查找特定包名的Java进程非常有用，以便进一步管理和监控它们。<br /><strong>查看特定用户的进程</strong><br />如果查看特定用户的Java进程，可以使用 <code>-u</code> 选项，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1jps -u username</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11234 com.example.App1</span><br><span class="line">25678 com.example.App2</span><br></pre></td></tr></table></figure><p>在上述示例中，jps -u john 命令列出了用户&quot;john&quot;启动的两个Java进程，它们的主类名分别是 “com.example.App1” 和 “com.example.App2”，并显示了它们的进程ID（1234和5678）。这个命令对于查找特定用户的Java进程以进行监控和管理非常有用。</p><p><strong>实际应用场景</strong><br /><strong>监视Java进程</strong><br />使用jps，您可以轻松地查看当前系统上运行的所有Java进程。这对于监视应用程序是否正在运行，以及查找特定进程的信息非常有用。<br /><strong>调试和诊断</strong><br />如果应用程序出现问题，您可以使用jps来查找进程ID，然后使用其他工具如jstack、jmap、jvisualvm等来分析问题。例如，jstack可以用来生成线程堆栈跟踪，以识别死锁或性能瓶颈。<br /><strong>管理多个Java进程</strong><br />在开发和部署环境中，可能会运行多个Java进程。jps帮助您快速识别和管理这些进程，而无需手动查看操作系统的进程列表。<br /><strong>定位进程</strong><br />如果您有多个Java进程，可能需要定位特定进程以进行操作。jps提供了进程ID，可以用于与进程交互，如使用jmap生成堆转储。<br /><strong>监控应用程序状态</strong><br />通过定期运行jps，您可以监视应用程序的运行状态。如果某个进程意外终止，您可以及时发现问题并采取适当的措施。</p><p><strong>注意事项</strong></p><p>jps仅显示当前用户的Java进程。如果需要查看其他用户的Java进程，可能需要使用管理员权限。<br />由于jps是基于JVM内部的管理接口实现的，如果JVM出现了严重的内部错误，可能导致jps无法正确列出进程。</p><p><strong>总 结</strong></p><p>综上所述，Java Process Status（jps）是一个强大的命令行工具，可帮助Java开发人员和系统管理员快速地查看和管理Java进程，调试、管理和监控Java应用程序。通过了解jps的基本用法和使用案例，可以更好地使用它来诊断问题、管理多个进程和监控应用程序状态。无论是在开发、测试还是生产环境，jps都是一个有用的工具，可以提高工作效率和准确性。</p><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文将对JVM自带的工具jps（Java Process Status）进行深入详细的分析与讲解。我们会探讨它的基本功能、如何使用、以及在实际场景中的应用。本文将深入分析jps工具的用法、输出信息的含义以及如何在日常开发和维护中受益于它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;jp</summary>
      
    
    
    
    <category term="java基础" scheme="http://www.bojiboqi.fun/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java基础" scheme="http://www.bojiboqi.fun/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Caffeine介绍及使用</title>
    <link href="http://www.bojiboqi.fun/2024/04/22/Caffeine%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.bojiboqi.fun/2024/04/22/Caffeine%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/</id>
    <published>2024-04-22T06:34:19.031Z</published>
    <updated>2024-04-22T06:47:58.635Z</updated>
    
    <content type="html"><![CDATA[<p><a name="wuhQz"></a></p><h3 id=""></h3><p><a name="WHIfr"></a></p><h4 id="Cache是一种带有存储和移除策略的Map。"><strong>Cache是一种带有存储和移除策略的Map</strong>。</h4><p><a name="YdaUD"></a></p><h3 id="二、Caffeine基础">二、Caffeine基础</h3><blockquote><p>Caffeine官网: <a href="https://github.com/ben-manes/caffeine">https://github.com/ben-manes/caffeine</a></p></blockquote><p><a name="AhGiw"></a></p><h4 id="1-功能一览">1. 功能一览</h4><p>Caffeine 提供了灵活的构造来创建具有以下功能组合的缓存：</p><ul><li>自动将条目自动加载到缓存中，可以选择异步加载</li><li>基于频率和新近度超过最大值时基于大小的逐出，提供过期策略</li><li>自上次访问或上次写入以来测得的基于时间的条目到期</li><li>发生第一个陈旧的条目请求时，异步刷新</li><li>键自动包装在弱引用中</li><li>值自动包装在弱引用或软引用中</li><li>逐出（或以其他方式删除）条目的通知</li><li>写入传播到外部资源</li><li>缓存访问统计信息的累积<br><a name="K9QXG"></a></li></ul><h4 id="2-缓存加载策略介绍">2. 缓存加载策略介绍</h4><p><a name="sxYqm"></a></p><h5 id="2-1-Cache手动创建">2.1 Cache手动创建</h5><p>最普通的一种缓存，无需指定加载方式，需要手动调用put()进行加载。需要注意的是put()方法对于已存在的key将进行覆盖，这点和Map的表现是一致的。在获取缓存值时，如果想要在缓存值不存在时，原子地将值写入缓存，则可以调用get(key, k -&gt; value)方法，该方法将避免写入竞争。调用invalidate()方法，将手动移除缓存。<br />在多线程情况下，当使用get(key, k -&gt; value)时，如果有另一个线程同时调用本方法进行竞争，则后一线程会被阻塞，直到前一线程更新缓存完成；而若另一线程调用getIfPresent()方法，则会立即返回null，不会被阻塞。<br />一段简单的示例代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;Object, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                //初始数量</span><br><span class="line">                .initialCapacity(10)</span><br><span class="line">                //最大条数</span><br><span class="line">                .maximumSize(10)</span><br><span class="line">                //expireAfterWrite和expireAfterAccess同时存在时，以expireAfterWrite为准</span><br><span class="line">                //最后一次写操作后经过指定时间过期</span><br><span class="line">                .expireAfterWrite(1, TimeUnit.SECONDS)</span><br><span class="line">                //最后一次读或写操作后经过指定时间过期</span><br><span class="line">                .expireAfterAccess(1, TimeUnit.SECONDS)</span><br><span class="line">                //监听缓存被移除</span><br><span class="line">                .removalListener((key, val, removalCause) -&gt; &#123; &#125;)</span><br><span class="line">                //记录命中</span><br><span class="line">                .recordStats()</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        cache.put(&quot;1&quot;,&quot;张三&quot;);</span><br><span class="line">        //张三</span><br><span class="line">        System.out.println(cache.getIfPresent(&quot;1&quot;));</span><br><span class="line">        //存储的是默认值</span><br><span class="line">        System.out.println(cache.get(&quot;2&quot;,o -&gt; &quot;默认值&quot;));</span><br></pre></td></tr></table></figure><p><a name="QJqct"></a></p><h5 id="2-2-Loading-Cache自动创建">2.2 Loading Cache自动创建</h5><p>LoadingCache是一种自动加载的缓存。其和普通缓存不同的地方在于，当缓存不存在/缓存已过期时，若调用get()方法，则会自动调用CacheLoader.load()方法加载最新值。调用getAll()方法将遍历所有的key调用get()，除非实现了CacheLoader.loadAll()方法。使用LoadingCache时，需要指定CacheLoader，并实现其中的load()方法供缓存缺失时自动加载。<br />在多线程情况下，当两个线程同时调用get()，则后一线程将被阻塞，直至前一线程更新缓存完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, String&gt; loadingCache = Caffeine.newBuilder()</span><br><span class="line">        //创建缓存或者最近一次更新缓存后经过指定时间间隔，刷新缓存；refreshAfterWrite仅支持LoadingCache</span><br><span class="line">        .refreshAfterWrite(10, TimeUnit.SECONDS)</span><br><span class="line">        .expireAfterWrite(10, TimeUnit.SECONDS)</span><br><span class="line">        .expireAfterAccess(10, TimeUnit.SECONDS)</span><br><span class="line">        .maximumSize(10)</span><br><span class="line">        //根据key查询数据库里面的值，这里是个lamba表达式</span><br><span class="line">        .build(key -&gt; new Date().toString());</span><br></pre></td></tr></table></figure><p><a name="ZVWiE"></a></p><h5 id="2-3-Async-Cache异步获取">2.3 Async Cache异步获取</h5><p>AsyncCache是Cache的一个变体，其响应结果均为CompletableFuture，通过这种方式，AsyncCache对异步编程模式进行了适配。默认情况下，缓存计算使用ForkJoinPool.commonPool()作为线程池，如果想要指定线程池，则可以覆盖并实现Caffeine.executor(Executor)方法。synchronous()提供了阻塞直到异步缓存生成完毕的能力，它将以Cache进行返回。<br />在多线程情况下，当两个线程同时调用get(key, k -&gt; value)，则会返回同一个CompletableFuture对象。由于返回结果本身不进行阻塞，可以根据业务设计自行选择阻塞等待或者非阻塞。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AsyncLoadingCache&lt;String, String&gt; asyncLoadingCache = Caffeine.newBuilder()</span><br><span class="line">        //创建缓存或者最近一次更新缓存后经过指定时间间隔刷新缓存；仅支持LoadingCache</span><br><span class="line">        .refreshAfterWrite(1, TimeUnit.SECONDS)</span><br><span class="line">        .expireAfterWrite(1, TimeUnit.SECONDS)</span><br><span class="line">        .expireAfterAccess(1, TimeUnit.SECONDS)</span><br><span class="line">        .maximumSize(10)</span><br><span class="line">        //根据key查询数据库里面的值</span><br><span class="line">        .buildAsync(key -&gt; &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            return new Date().toString();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">//异步缓存返回的是CompletableFuture</span><br><span class="line">CompletableFuture&lt;String&gt; future = asyncLoadingCache.get(&quot;1&quot;);</span><br><span class="line">future.thenAccept(System.out::println);</span><br></pre></td></tr></table></figure><p><a name="UFywy"></a></p><h4 id="3-移除策略-淘汰机制-介绍">3. 移除策略(淘汰机制)介绍</h4><p>驱逐策略在创建缓存的时候进行指定。常用的有基于容量的驱逐和基于时间的驱逐。<br />基于容量的驱逐需要指定缓存容量的最大值，当缓存容量达到最大时，Caffeine将使用LRU策略对缓存进行淘汰；基于时间的驱逐策略如字面意思，可以设置在最后访问/写入一个缓存经过指定时间后，自动进行淘汰。<br />驱逐策略可以组合使用，任意驱逐策略生效后，该缓存条目即被驱逐。</p><ul><li>LRU 最近最少使用，淘汰最长时间没有被使用的页面。</li><li>LFU 最不经常使用，淘汰一段时间内使用次数最少的页面</li><li>FIFO 先进先出</li></ul><p><strong>Caffeine有4种缓存淘汰设置</strong></p><ol><li>大小 （LFU算法进行淘汰）</li><li>权重 （大小与权重 只能二选一）</li><li>时间 (设置过期时间，类似redis)</li><li>引用 （不常用，本文不介绍）</li></ol><p>一段示例代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class CacheTest &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 缓存大小淘汰</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void maximumSizeTest() throws InterruptedException &#123;</span><br><span class="line">        Cache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                //超过10个后会使用W-TinyLFU算法进行淘汰</span><br><span class="line">                .maximumSize(10)</span><br><span class="line">                .evictionListener((key, val, removalCause) -&gt; &#123;</span><br><span class="line">                    log.info(&quot;淘汰缓存：key:&#123;&#125; val:&#123;&#125;&quot;, key, val);</span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; 20; i++) &#123;</span><br><span class="line">            cache.put(i, i);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(500);//缓存淘汰是异步的</span><br><span class="line"></span><br><span class="line">        // 打印还没被淘汰的缓存</span><br><span class="line">        System.out.println(cache.asMap());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 权重淘汰</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void maximumWeightTest() throws InterruptedException &#123;</span><br><span class="line">        Cache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                //限制总权重，若所有缓存的权重加起来&gt;总权重就会淘汰权重小的缓存</span><br><span class="line">                .maximumWeight(100)</span><br><span class="line">                .weigher((Weigher&lt;Integer, Integer&gt;) (key, value) -&gt; key)</span><br><span class="line">                .evictionListener((key, val, removalCause) -&gt; &#123;</span><br><span class="line">                    log.info(&quot;淘汰缓存：key:&#123;&#125; val:&#123;&#125;&quot;, key, val);</span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        //总权重其实是=所有缓存的权重加起来</span><br><span class="line">        int maximumWeight = 0;</span><br><span class="line">        for (int i = 1; i &lt; 20; i++) &#123;</span><br><span class="line">            cache.put(i, i);</span><br><span class="line">            maximumWeight += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;总权重=&quot; + maximumWeight);</span><br><span class="line">        Thread.sleep(500);//缓存淘汰是异步的</span><br><span class="line"></span><br><span class="line">        // 打印还没被淘汰的缓存</span><br><span class="line">        System.out.println(cache.asMap());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 访问后到期（每次访问都会重置时间，也就是说如果一直被访问就不会被淘汰）</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void expireAfterAccessTest() throws InterruptedException &#123;</span><br><span class="line">        Cache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                .expireAfterAccess(1, TimeUnit.SECONDS)</span><br><span class="line">                //可以指定调度程序来及时删除过期缓存项，而不是等待Caffeine触发定期维护</span><br><span class="line">                //若不设置scheduler，则缓存会在下一次调用get的时候才会被动删除</span><br><span class="line">                .scheduler(Scheduler.systemScheduler())</span><br><span class="line">                .evictionListener((key, val, removalCause) -&gt; &#123;</span><br><span class="line">                    log.info(&quot;淘汰缓存：key:&#123;&#125; val:&#123;&#125;&quot;, key, val);</span><br><span class="line"></span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line">        cache.put(1, 2);</span><br><span class="line">        System.out.println(cache.getIfPresent(1));</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        System.out.println(cache.getIfPresent(1));//null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 写入后到期</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void expireAfterWriteTest() throws InterruptedException &#123;</span><br><span class="line">        Cache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                .expireAfterWrite(1, TimeUnit.SECONDS)</span><br><span class="line">                //可以指定调度程序来及时删除过期缓存项，而不是等待Caffeine触发定期维护</span><br><span class="line">                //若不设置scheduler，则缓存会在下一次调用get的时候才会被动删除</span><br><span class="line">                .scheduler(Scheduler.systemScheduler())</span><br><span class="line">                .evictionListener((key, val, removalCause) -&gt; &#123;</span><br><span class="line">                    log.info(&quot;淘汰缓存：key:&#123;&#125; val:&#123;&#125;&quot;, key, val);</span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line">        cache.put(1, 2);</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        System.out.println(cache.getIfPresent(1));//null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="KgNiG"></a></p><h4 id="4-刷新机制">4. 刷新机制</h4><p><code>refreshAfterWrite()</code>表示x秒后自动刷新缓存的策略，可以配合淘汰策略使用，需要注意的是刷新机制只支持LoadingCache和AsyncLoadingCache</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static int NUM = 0;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void refreshAfterWriteTest() throws InterruptedException &#123;</span><br><span class="line">    LoadingCache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">            .refreshAfterWrite(1, TimeUnit.SECONDS)</span><br><span class="line">            //模拟获取数据，每次获取就自增1</span><br><span class="line">            .build(integer -&gt; ++NUM);</span><br><span class="line"></span><br><span class="line">    //获取ID=1的值，由于缓存里还没有，所以会自动放入缓存</span><br><span class="line">    System.out.println(cache.get(1));// 1</span><br><span class="line"></span><br><span class="line">    // 延迟2秒后，理论上自动刷新缓存后取到的值是2</span><br><span class="line">    // 但其实不是，值还是1，因为refreshAfterWrite并不是设置了n秒后重新获取就会自动刷新</span><br><span class="line">    // 而是x秒后&amp;&amp;第二次调用getIfPresent的时候才会被动刷新</span><br><span class="line">    Thread.sleep(2000);</span><br><span class="line">    System.out.println(cache.getIfPresent(1));// 1</span><br><span class="line"></span><br><span class="line">    //此时才会刷新缓存，而第一次拿到的还是旧值</span><br><span class="line">    System.out.println(cache.getIfPresent(1));// 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="oxQjr"></a></p><h4 id="5-统计">5. 统计</h4><p>Caffeine提供了常用的统计功能，包括命中次数、命中率、总条数、加载时间等，通过<code>cache.stats()</code>可以获取到统计数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">        //创建缓存或者最近一次更新缓存后经过指定时间间隔，刷新缓存；refreshAfterWrite仅支持LoadingCache</span><br><span class="line">        .refreshAfterWrite(1, TimeUnit.SECONDS)</span><br><span class="line">        .expireAfterWrite(1, TimeUnit.SECONDS)</span><br><span class="line">        .expireAfterAccess(1, TimeUnit.SECONDS)</span><br><span class="line">        .maximumSize(10)</span><br><span class="line">        //开启记录缓存命中率等信息</span><br><span class="line">        .recordStats()</span><br><span class="line">        //根据key查询数据库里面的值</span><br><span class="line">        .build(key -&gt; &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            return new Date().toString();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">cache.put(&quot;1&quot;, &quot;shawn&quot;);</span><br><span class="line">cache.get(&quot;1&quot;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * hitCount :命中的次数</span><br><span class="line"> * missCount:未命中次数</span><br><span class="line"> * requestCount:请求次数</span><br><span class="line"> * hitRate:命中率</span><br><span class="line"> * missRate:丢失率</span><br><span class="line"> * loadSuccessCount:成功加载新值的次数</span><br><span class="line"> * loadExceptionCount:失败加载新值的次数</span><br><span class="line"> * totalLoadCount:总条数</span><br><span class="line"> * loadExceptionRate:失败加载新值的比率</span><br><span class="line"> * totalLoadTime:全部加载时间</span><br><span class="line"> * evictionCount:丢失的条数</span><br><span class="line"> */</span><br><span class="line">System.out.println(cache.stats());</span><br></pre></td></tr></table></figure><p><a name="qomoY"></a></p><h4 id="6-总结">6. 总结</h4><p>上述一些策略在创建时都可以进行自由组合，一般情况下有两种方法</p><ul><li>设置 maxSize、refreshAfterWrite，不设置 expireAfterWrite/expireAfterAccess</li></ul><p>设置expireAfterWrite当缓存过期时会同步加锁获取缓存，所以设置expireAfterWrite时性能较好，但是某些时候会取旧数据,适合允许取到旧数据的场景</p><ul><li>设置 maxSize、expireAfterWrite/expireAfterAccess，不设置 refreshAfterWrite</li></ul><p>数据一致性好，不会获取到旧数据，但是性能没那么好（对比起来），适合获取数据时不耗时的场景<br><a name="P373x"></a></p><h3 id="三、Springboot整合Caffeine">三、Springboot整合Caffeine</h3><p><a name="W3UT5"></a></p><h4 id="1-常用注解">1. 常用注解</h4><ul><li>@Cacheable：表示该方法支持缓存。当调用被注解的方法时，如果对应的键已经存在缓存，则不再执行方法体，而从缓存中直接返回。当方法返回null时，将不进行缓存操作。</li><li>@CachePut：表示执行该方法后，其值将作为最新结果更新到缓存中，每次都会执行该方法。</li><li>@CacheEvict：表示执行该方法后，将触发缓存清除操作。</li><li>@Caching：用于组合前三个注解，例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Caching(cacheable = @Cacheable(&quot;CacheConstants.GET_USER&quot;),</span><br><span class="line">         evict = &#123;@CacheEvict(&quot;CacheConstants.GET_DYNAMIC&quot;,allEntries = true)&#125;</span><br><span class="line">public User find(Integer id) &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解属性说明:</p><ul><li>cacheNames/value：缓存组件的名字，即cacheManager中缓存的名称。</li><li>key：缓存数据时使用的key。默认使用方法参数值，也可以使用SpEL表达式进行编写。</li><li>keyGenerator：和key二选一使用。</li><li>cacheManager：指定使用的缓存管理器。</li><li>condition：在方法执行开始前检查，在符合condition的情况下，进行缓存</li><li>unless：在方法执行完成后检查，在符合unless的情况下，不进行缓存</li><li>sync：是否使用同步模式。若使用同步模式，在多个线程同时对一个key进行load时，其他线程将被阻塞。<br><a name="SfU61"></a></li></ul><h4 id="2-整合实战">2. 整合实战</h4><p><strong>2.1 新建springboot项目并引入如下依赖:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.ben-manes.caffeine&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;caffeine&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>2.2 缓存常量类</strong><br />CacheConstants.java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CacheConstants &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 默认过期时间（配置类中我使用的时间单位是秒，所以这里如 3*60 为3分钟）</span><br><span class="line">     */</span><br><span class="line">    public static final int DEFAULT_EXPIRES = 3 * 60;</span><br><span class="line">    public static final int EXPIRES_5_MIN = 5 * 60;</span><br><span class="line">    public static final int EXPIRES_10_MIN = 10 * 60;</span><br><span class="line"></span><br><span class="line">    public static final String GET_USER = &quot;GET:USER&quot;;</span><br><span class="line">    public static final String GET_DYNAMIC = &quot;GET:DYNAMIC&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.3 缓存配置类CacheConfig</strong><br />CacheConfig.java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableCaching</span><br><span class="line">public class CacheConfig &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Caffeine配置说明：</span><br><span class="line">     * initialCapacity=[integer]: 初始的缓存空间大小</span><br><span class="line">     * maximumSize=[long]: 缓存的最大条数</span><br><span class="line">     * maximumWeight=[long]: 缓存的最大权重</span><br><span class="line">     * expireAfterAccess=[duration]: 最后一次写入或访问后经过固定时间过期</span><br><span class="line">     * expireAfterWrite=[duration]: 最后一次写入后经过固定时间过期</span><br><span class="line">     * refreshAfterWrite=[duration]: 创建缓存或者最近一次更新缓存后经过固定的时间间隔，刷新缓存</span><br><span class="line">     * weakKeys: 打开key的弱引用</span><br><span class="line">     * weakValues：打开value的弱引用</span><br><span class="line">     * softValues：打开value的软引用</span><br><span class="line">     * recordStats：开发统计功能</span><br><span class="line">     * 注意：</span><br><span class="line">     * expireAfterWrite和expireAfterAccess同事存在时，以expireAfterWrite为准。</span><br><span class="line">     * maximumSize和maximumWeight不可以同时使用</span><br><span class="line">     * weakValues和softValues不可以同时使用</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public CacheManager cacheManager() &#123;</span><br><span class="line">        SimpleCacheManager cacheManager = new SimpleCacheManager();</span><br><span class="line">        List&lt;CaffeineCache&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        //循环添加枚举类中自定义的缓存，可以自定义</span><br><span class="line">        for (CacheEnum cacheEnum : CacheEnum.values()) &#123;</span><br><span class="line">            list.add(new CaffeineCache(cacheEnum.getName(),</span><br><span class="line">                    Caffeine.newBuilder()</span><br><span class="line">                            .initialCapacity(50)</span><br><span class="line">                            .maximumSize(1000)</span><br><span class="line">                            .expireAfterAccess(cacheEnum.getExpires(), TimeUnit.SECONDS)</span><br><span class="line">                            .build()));</span><br><span class="line">        &#125;</span><br><span class="line">        cacheManager.setCaches(list);</span><br><span class="line">        return cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.4 调用缓存</strong><br />这里要注意的是Cache和@Transactional一样也使用了代理，类内调用将失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * value：缓存key的前缀。</span><br><span class="line"> * key：缓存key的后缀。</span><br><span class="line"> * sync：设置如果缓存过期是不是只放一个请求去请求数据库，其他请求阻塞，默认是false（根据个人需求）。</span><br><span class="line"> * unless：不缓存空值,这里不使用，会报错</span><br><span class="line"> * 查询用户信息类</span><br><span class="line"> * 如果需要加自定义字符串，需要用单引号</span><br><span class="line"> * 如果查询为null，也会被缓存</span><br><span class="line"> */</span><br><span class="line">@Cacheable(value = CacheConstants.GET_USER,key = &quot;&#x27;user&#x27;+#userId&quot;,sync = true)</span><br><span class="line">@CacheEvict</span><br><span class="line">public UserEntity getUserByUserId(Integer userId)&#123;</span><br><span class="line">    UserEntity userEntity = userMapper.findById(userId);</span><br><span class="line">    System.out.println(&quot;查询了数据库&quot;);</span><br><span class="line">    return userEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章:<br /><a href="https://blog.csdn.net/lemon_TT/article/details/122905113">https://blog.csdn.net/lemon_TT/article/details/122905113</a></p><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;wuhQz&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a name=&quot;WHIfr&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;Cache是一种带有存储和移除策略的Map。&quot;&gt;&lt;strong&gt;Cache是一种带有存储和移除策略的Map&lt;/stron</summary>
      
    
    
    
    <category term="中间件" scheme="http://www.bojiboqi.fun/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="categories" scheme="http://www.bojiboqi.fun/tags/categories/"/>
    
    <category term="缓存" scheme="http://www.bojiboqi.fun/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>如何设计一个高并发系统？</title>
    <link href="http://www.bojiboqi.fun/2024/04/22/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%EF%BC%9F/"/>
    <id>http://www.bojiboqi.fun/2024/04/22/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%EF%BC%9F/</id>
    <published>2024-04-22T06:34:04.286Z</published>
    <updated>2024-04-22T23:27:56.628Z</updated>
    
    <content type="html"><![CDATA[<p><a name="P7lcA"></a></p><h3 id="前言"><strong>前言</strong></h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712845381522-18f55fda-f758-48d1-ad08-4ff7400eaba9.png#averageHue=%23fefefe&amp;clientId=u05213f45-1bbd-4&amp;from=paste&amp;id=u6565f4a5&amp;originHeight=1652&amp;originWidth=1024&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=155927&amp;status=done&amp;style=none&amp;taskId=uea1e0fe3-df65-4121-aff9-7b5a74a9fb2&amp;title=" alt="image.jpg"><br><a name="c1GJ7"></a></p><h3 id="1-页面静态化"><strong>1 页面静态化</strong></h3><p>对于高并发系统的页面功能，我们必须要做<code>静态化</code>设计。<br />如果并发访问系统的用户非常多，每次用户访问页面的时候，都通过服务器动态渲染，会导致服务端承受过大的压力，而导致页面无法正常加载的情况发生。<br />我们可以使用<code>Freemarker</code>或<code>Velocity</code>模板引擎，实现页面静态化功能。<br />以商城官网首页为例，我们可以在<code>Job</code>中，每隔一段时间，查询出所有需要在首页展示的数据，汇总到一起，使用模板引擎生成到html文件当中。<br />然后将该<code>html</code>文件，通过<code>shell</code>脚本，自动同步到前端页面相关的服务器上。<br><a name="znwQr"></a></p><h3 id="2-CDN加速"><strong>2 CDN加速</strong></h3><p>虽说页面静态化可以提升网站网页的访问速度，但还不够，因为用户分布在全国各地，有些人在北京，有些人在成都，有些人在深圳，地域相差很远，他们访问网站的网速各不相同。<br />如何才能让用户最快访问到活动页面呢？<br />这就需要使用CDN，它的全称是Content Delivery Network，即<a href="https://cloud.tencent.com/product/cdn?from_column=20065&amp;from=20065">内容分发网络</a>。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712845388973-520096dd-18c1-4cd2-b619-ede8f2702155.png#averageHue=%23f6f5f5&amp;clientId=u05213f45-1bbd-4&amp;from=paste&amp;id=u509d2aa1&amp;originHeight=477&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=344530&amp;status=done&amp;style=none&amp;taskId=u07f49ccc-d109-4e12-882c-3710f1f870f&amp;title=" alt="image.jpg"><br />使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。<br />CDN加速的基本原理是：将网站的静态内容（如图片、CSS、JavaScript文件等）复制并存储到分布在全球各地的服务器节点上。<br />当用户请求访问网站时，CDN系统会根据用户的地理位置，自动将内容分发给离用户最近的服务器，从而实现快速访问。<br />国内常见的CDN提供商有阿里云CDN、腾讯云CDN、百度云加速等，它们提供了全球分布的节点服务器，为全球范围内的网站加速服务。<br><a name="VGB46"></a></p><h3 id="3-缓存"><strong>3 缓存</strong></h3><p>在高并发的系统中，<code>缓存</code>可以说是必不可少的技术之一。<br />目前缓存有两种：</p><ol><li>基于应用服务器的内存缓存，也就是我们说的二级缓存。</li><li>使用缓存中间件，比如：Redis、Memcached等，这种是分布式缓存。</li></ol><p>这两种缓存各有优缺点。<br />二级缓存的性能更好，但因为是基于应用服务器内存的缓存，如果系统部署到了多个服务器节点，可能会存在数据不一致的情况。<br />而Redis或Memcached虽说性能上比不上二级缓存，但它们是分布式缓存，避免多个服务器节点数据不一致的问题。<br />缓存的用法一般是这样的：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712845385974-4e3595bb-c0a6-404a-8499-c239c14908d1.png#averageHue=%23fbfaf9&amp;clientId=u05213f45-1bbd-4&amp;from=paste&amp;id=ud5e28409&amp;originHeight=721&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=235755&amp;status=done&amp;style=none&amp;taskId=u1a5f1f55-2a76-458f-8a85-6fe49b9b700&amp;title=" alt="image.jpg"><br />使用缓存之后，可以减轻访问数据库的压力，显著的提升系统的性能。<br />有些业务场景，甚至会分布式缓存和二级缓存一起使用。<br />比如获取商品分类数据，流程如下：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712845382632-586941b7-5056-4e06-b37a-303e27349621.png#averageHue=%23f5f4f3&amp;clientId=u05213f45-1bbd-4&amp;from=paste&amp;id=u0c4d7b99&amp;originHeight=1276&amp;originWidth=972&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=185090&amp;status=done&amp;style=none&amp;taskId=u298f555f-8b1d-4906-898f-17357f7685f&amp;title=" alt="image.jpg"><br />不过引入缓存，虽说给我们的系统性能带来了提升，但同时也给我们带来了一些新的问题，比如：《<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNjMwMTgzMQ%3D%3D%26mid%3D2247493521%26idx%3D1%26sn%3Dbff84e7a819d79e4b8eb7e722e96ddfc%26chksm%3Dc0e83f79f79fb66f2e7bf03a104580b404ea0a3c977846e428f13c1f12fbad46d4d778b2da14%26token%3D902535653%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect&amp;source=article&amp;objectId=2327500">数据库和缓存双向数据库一致性问题</a>》、《<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNjMwMTgzMQ%3D%3D%26mid%3D2247491225%26idx%3D1%26sn%3Dbfb14f28911efaa6e3a615870fff9a5c%26chksm%3Dc0ebc671f79c4f6718a63bbec91d79a4b05e1dd2a7c00ed9bf6a9f582abd4c6e5c870148ff89%26token%3D902535653%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect&amp;source=article&amp;objectId=2327500">缓存穿透、击穿和雪崩问题</a>》等。<br />我们在使用缓存时，一定要结合实际业务场景，切记不要为了缓存而缓存。<br><a name="TneLN"></a></p><h3 id="4-异步"><strong>4 异步</strong></h3><p>有时候，我们在高并发系统当中，某些接口的业务逻辑，没必要都同步执行。<br />比如有个用户请求接口中，需要做业务操作，发站内通知，和记录操作日志。为了实现起来比较方便，通常我们会将这些逻辑放在接口中同步执行，势必会对接口性能造成一定的影响。<br />接口内部流程图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712845379600-a6332178-6970-428f-bcda-0832c7ea0226.png#averageHue=%23f1ecea&amp;clientId=u05213f45-1bbd-4&amp;from=paste&amp;id=u2977f963&amp;originHeight=656&amp;originWidth=308&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=29654&amp;status=done&amp;style=none&amp;taskId=ub07f53d7-a958-4d27-8f38-a022d95a162&amp;title=" alt="image.jpg"><br />这个接口表面上看起来没有问题，但如果你仔细梳理一下业务逻辑，会发现只有业务操作才是核心逻辑，其他的功能都是非核心逻辑。<br />在这里有个原则就是：核心逻辑可以同步执行，同步写库。非核心逻辑，可以异步执行，异步写库。<br />上面这个例子中，发站内通知和用户操作日志功能，对实时性要求不高，即使晚点写库，用户无非是晚点收到站内通知，或者运营晚点看到用户操作日志，对业务影响不大，所以完全可以异步处理。<br />通常异步主要有两种：多线程 和 mq。<br><a name="ZWGrn"></a></p><h4 id="4-1-线程池"><strong>4.1 线程池</strong></h4><p>使用线程池改造之后，接口逻辑如下：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712845382594-370ed86b-ebfe-4f63-a93f-3e37b2954b7f.png#averageHue=%23f8f6f5&amp;clientId=u05213f45-1bbd-4&amp;from=paste&amp;id=ufe6748cb&amp;originHeight=572&amp;originWidth=912&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=34817&amp;status=done&amp;style=none&amp;taskId=ub660f3d9-4e89-4d83-b243-8ef34b196ad&amp;title=" alt="image.jpg"><br />发站内通知和用户操作日志功能，被提交到了两个单独的线程池中。<br />这样接口中重点关注的是业务操作，把其他的逻辑交给线程异步执行，这样改造之后，让接口性能瞬间提升了。<br />但使用线程池有个小问题就是：如果服务器重启了，或者是需要被执行的功能出现异常了，无法重试，会丢数据。<br />那么这个问题该怎么办呢？<br><a name="Y1j4j"></a></p><h4 id="4-2-mq"><strong>4.2 mq</strong></h4><p>使用mq改造之后，接口逻辑如下：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712845384683-db090404-feca-4c85-a60d-a024ab5cacfe.png#averageHue=%23f7f6f5&amp;clientId=u05213f45-1bbd-4&amp;from=paste&amp;id=u0e218c9b&amp;originHeight=621&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=83775&amp;status=done&amp;style=none&amp;taskId=ude6cfe86-c575-4368-a592-438ad5673a1&amp;title=" alt="image.jpg"><br />对于发站内通知和用户操作日志功能，在接口中并没真正实现，它只发送了mq消息到mq服务器。然后由mq消费者消费消息时，才真正的执行这两个功能。<br />这样改造之后，接口性能同样提升了，因为发送mq消息速度是很快的，我们只需关注业务操作的代码即可。<br><a name="DNFXM"></a></p><h3 id="5-多线程处理"><strong>5 多线程处理</strong></h3><p>在高并发系统当中，用户的请求量很大。<br />假如我们现在用mq处理业务逻辑。<br />一下子有大量的用户请求，产生了大量的mq消息，保存到了mq服务器。<br />而mq的消费者，消费速度很慢。<br />可能会导致大量的消息积压问题。<br />从而严重影响数据的实时性。<br />我们需要对消息的消费者做优化。<br />最快的方式是使用<code>多线程</code>消费消息，比如：改成线程池消费消息。<br />当然核心线程数、最大线程数、队列大小 和 线程回收时间，一定要做成配置的，后面可以根据实际情况动态调整。<br />这样改造之后，我们可以快速解决消息积压问题。<br />除此之外，在很多数据导入场景，用多线程导入数据，可以提升效率。</p><blockquote><p>温馨提醒一下：使用多线程消费消息，可能会出现消息的顺序问题。如果你的业务场景中，需要保证消息的顺序，则要用其他的方式解决问题。感兴趣的小伙伴，可以找我私聊。</p></blockquote><p><a name="IrQjm"></a></p><h3 id="6-分库分表"><strong>6 分库分表</strong></h3><p>有时候，高并发系统的吞吐量受限的不是别的，而是数据库。<br />当系统发展到一定的阶段，用户并发量大，会有大量的数据库请求，需要占用大量的数据库连接，同时会带来磁盘IO的性能瓶颈问题。<br />此外，随着用户数量越来越多，产生的数据也越来越多，一张表有可能存不下。由于数据量太大，sql语句查询数据时，即使走了索引也会非常耗时。<br />这时该怎么办呢？<br />答：需要做<code>分库分表</code>。<br />如下图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712845396916-5baee798-c609-4823-8b7f-653b7fd544b8.png#clientId=u05213f45-1bbd-4&amp;from=paste&amp;id=ub9e058e3&amp;originHeight=878&amp;originWidth=1042&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=351674&amp;status=done&amp;style=none&amp;taskId=ube138651-11f9-49e6-9f16-37ac20e21ee&amp;title=" alt="image.jpg"><br />图中将用户库拆分成了三个库，每个库都包含了四张用户表。<br />如果有用户请求过来的时候，先根据用户id路由到其中一个用户库，然后再定位到某张表。<br />路由的算法挺多的：</p><ul><li>根据id取模，比如：id=7，有4张表，则7%4=3，模为3，路由到用户表3。</li><li>给id指定一个区间范围，比如：id的值是0-10万，则数据存在用户表0，id的值是10-20万，则数据存在用户表1。</li><li>一致性hash算法</li></ul><p>分库分表主要有两个方向：<code>垂直</code>和<code>水平</code>。<br />说实话垂直方向（即业务方向）更简单。<br />在水平方向（即数据方向）上，分库和分表的作用，其实是有区别的，不能混为一谈。</p><ul><li>分库：是为了解决数据库连接资源不足问题，和磁盘IO的性能瓶颈问题。</li><li>分表：是为了解决单表数据量太大，sql语句查询数据时，即使走了索引也非常耗时问题。此外还可以解决消耗cpu资源问题。</li><li>分库分表：可以解决 数据库连接资源不足、磁盘IO的性能瓶颈、检索数据耗时 和 消耗cpu资源等问题。</li></ul><p>如果在有些业务场景中，用户并发量很大，但是需要保存的数据量很少，这时可以只分库，不分表。<br />如果在有些业务场景中，用户并发量不大，但是需要保存的数量很多，这时可以只分表，不分库。<br />如果在有些业务场景中，用户并发量大，并且需要保存的数量也很多时，可以分库分表。<br />关于分库分表更详细的内容，可以看看我另一篇文章，里面讲的更深入《<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNjMwMTgzMQ%3D%3D%26mid%3D2247490459%26idx%3D1%26sn%3D1e4296228c00aa4203aab481575ac916%26chksm%3Dc0ebc373f79c4a658de7ce7f0d8cf30b1f45adb346c2386321779e7cf85a757a12337d3ae233%26token%3D2041133408%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect&amp;source=article&amp;objectId=2327500">阿里二面：为什么分库分表？</a>》<br><a name="r28xF"></a></p><h3 id="7-池化技术"><strong>7 池化技术</strong></h3><p>其实不光是高并发系统，为了性能考虑，有些低并发的系统，也在使用<code>池化技术</code>，比如：数据库连接池、线程池等。<br />池化技术是<code>多例设计模式</code>的一个体现。<br />我们都知道<code>创建</code>和<code>销毁</code>数据库连接是非常耗时耗资源的操作。<br />如果每次用户请求，都需要创建一个新的数据库连接，势必会影响程序的性能。<br />为了提升性能，我们可以创建一批数据库连接，保存到内存中的某个集合中，缓存起来。<br />这样的话，如果下次有需要用数据库连接的时候，就能直接从集合中获取，不用再额外创建数据库连接，这样处理将会给我们提升系统性能。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712845385015-8d0f0747-8eb3-4aa0-86d2-e9cb231a792f.png#clientId=u05213f45-1bbd-4&amp;from=paste&amp;id=ua3fd53c3&amp;originHeight=686&amp;originWidth=830&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=125157&amp;status=done&amp;style=none&amp;taskId=u2b019e73-ace8-4bd6-b109-f20c8f52fd5&amp;title=" alt="image.jpg"><br />当然用完之后，需要及时归还。<br />目前常用的数据库连接池有：Druid、C3P0、hikari和DBCP等。<br><a name="vv1Q4"></a></p><h3 id="8-读写分离"><strong>8 读写分离</strong></h3><p>不知道你有没有听说过<code>二八原则</code>，在一个系统当中可能有80%是读数据请求，另外20%是写数据请求。<br />不过这个比例也不是绝对的。<br />我想告诉大家的是，一般的系统读数据请求会远远大于写数据请求。<br />如果读数据请求和写数据请求，都访问同一个数据库，可能会相互抢占数据库连接，相互影响。<br />我们都知道，一个数据库的数据库连接数量是有限，是非常宝贵的资源，不能因为读数据请求，影响到写数据请求吧？<br />这就需要对数据库做<code>读写分离</code>了。<br />于是，就出现了主从读写分离架构：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712845386314-3f42d421-6366-4dc6-84a6-e10ee2587d4e.png#clientId=u05213f45-1bbd-4&amp;from=paste&amp;id=u1806c17c&amp;originHeight=323&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=103907&amp;status=done&amp;style=none&amp;taskId=u1e81d050-cc7c-411f-8ced-dbd49176a6a&amp;title=" alt="image.jpg"><br />考虑刚开始用户量还没那么大，选择的是一主一从的架构，也就是常说的一个<code>master</code>，一个<code>slave</code>。<br />所有的写数据请求，都指向主库。一旦主库写完数据之后，立马异步同步给从库。这样所有的读数据请求，就能及时从从库中获取到数据了（除非网络有延迟）。<br />但这里有个问题就是：如果用户量确实有些大，如果master挂了，升级slave为master，将所有读写请求都指向新master。<br />但此时，如果这个新master根本扛不住所有的读写请求，该怎么办？<br />这就需要一主多从的架构了：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712845391373-9098e0fa-a6c6-4769-8dde-060bdde7ee02.png#clientId=u05213f45-1bbd-4&amp;from=paste&amp;id=ufc418546&amp;originHeight=707&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=157273&amp;status=done&amp;style=none&amp;taskId=u765ea8dd-89de-4024-a19c-a7d0fc0909e&amp;title=" alt="image.jpg"><br />上图中我列的是一主两从，如果master挂了，可以选择从库1或从库2中的一个，升级为新master。假如我们在这里升级从库1为新master，则原来的从库2就变成了新master的的slave了。<br />调整之后的架构图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712845389553-751f093d-d5bc-4f3b-8770-1bca1755d6c4.png#clientId=u05213f45-1bbd-4&amp;from=paste&amp;id=ub95e4de7&amp;originHeight=752&amp;originWidth=550&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=106413&amp;status=done&amp;style=none&amp;taskId=u4a2646a1-487c-4949-95af-89759321c09&amp;title=" alt="image.jpg"><br />这样就能解决上面的问题了。<br />除此之外，如果查询请求量再增大，我们还可以将架构升级为一主三从、一主四从…一主N从等。<br><a name="jKDHQ"></a></p><h3 id="9-索引"><strong>9 索引</strong></h3><p>在高并发的系统当中，用户经常需要查询数据，对数据库增加<code>索引</code>，是必不可少的一个环节。<br />尤其是表中数据非常多时，加了索引，跟没加索引，执行同一条sql语句，查询相同的数据，耗时可能会相差N个数量级。<br />虽说索引能够提升SQL语句的查询速度，但索引也不是越多越好。<br />在insert数据时，需要给索引分配额外的资源，对insert的性能有一定的损耗。<br />我们要根据实际业务场景来决定创建哪些索引，索引少了，影响查询速度，索引多了，影响写入速度。<br />很多时候，我们需要经常对索引做优化。</p><ol><li>可以将多个单个索引，改成一个联合索引。</li><li>删除不要索引。</li><li>使用explain关键字，查询SQL语句的执行计划，看看哪些走了索引，哪些没有走索引。</li><li>要注意索引失效的一些场景。</li><li>必要时可以使用force index来强制查询sql走某个索引。</li></ol><p>如果你想进一步了解explain的详细用法，可以看看我的另一篇文章《<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNjMwMTgzMQ%3D%3D%26mid%3D2247490262%26idx%3D1%26sn%3Da67f610afa984ecca130a54a3be453ab%26chksm%3Dc0ebc23ef79c4b2869dea998e413c5cbea6aeeea01ee74efc7c1a5fc228baa7beca215adf3ea%26token%3D751314179%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect&amp;source=article&amp;objectId=2327500">explain | 索引优化的这把绝世好剑，你真的会用吗？</a>》。<br />如果你想进一步了解哪些情况下索引会失效，可以看看我的另一篇文章《<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNjMwMTgzMQ%3D%3D%26mid%3D2247491626%26idx%3D1%26sn%3D18fc949c06f04fe8f4c29b6fc5c66f9c%26chksm%3Dc0e838c2f79fb1d45c6f9b2ab188bb4663414690bab0718a7d46beb875e6b83e5e67ec27d2ff%26token%3D902535653%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect&amp;source=article&amp;objectId=2327500">聊聊索引失效的10种场景，太坑了</a>》。<br><a name="LpqFR"></a></p><h3 id="10-批处理"><strong>10 批处理</strong></h3><p>有时候，我们需要从指定的用户集合中，查询出有哪些是在数据库中已经存在的。<br />实现代码可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;User&gt; queryUser(List&lt;User&gt; searchList) &#123;</span><br><span class="line">    if (CollectionUtils.isEmpty(searchList)) &#123;</span><br><span class="line">        return Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; result = Lists.newArrayList();</span><br><span class="line">    searchList.forEach(user -&gt; result.add(userMapper.getUserById(user.getId())));</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里如果有50个用户，则需要循环50次，去查询数据库。我们都知道，每查询一次数据库，就是一次远程调用。<br />如果查询50次数据库，就有50次远程调用，这是非常耗时的操作。<br />那么，我们如何优化呢？<br />答：<code>批处理</code>。<br />具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;User&gt; queryUser(List&lt;User&gt; searchList) &#123;</span><br><span class="line">    if (CollectionUtils.isEmpty(searchList)) &#123;</span><br><span class="line">        return Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Long&gt; ids = searchList.stream().map(User::getId).collect(Collectors.toList());</span><br><span class="line">    return userMapper.getUserByIds(ids);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供一个根据用户id集合<code>批量查询</code>用户的接口，只远程调用一次，就能查询出所有的数据。<br />这里有个需要注意的地方是：id集合的大小要做限制，最好一次不要请求太多的数据。要根据实际情况而定，建议控制每次请求的记录条数在500以内。<br><a name="m0LXV"></a></p><h3 id="11-集群"><strong>11 集群</strong></h3><p>系统部署的服务器节点，可能会down机，比如：服务器的磁盘坏了，或者操作系统出现内存不足问题。<br />为了保证系统的高可用，我们需要部署多个节点，构成一个<code>集群</code>，防止因为部分服务器节点挂了，导致系统的整个服务不可用的情况发生。<br />集群有很多种：</p><ol><li>应用服务器集群</li><li>数据库集群</li><li>中间件集群</li><li>文件服务器集群</li></ol><p>我们以中间件<code>Redis</code>为例。<br />在高并发系统中，用户的数据量非常庞大时，比如用户的缓存数据总共大小有40G，一个服务器节点只有16G的内存。<br />这样需要部署3台服务器节点。<br />该业务场景，使用普通的master/slave模式，或者使用哨兵模式都行不通。<br />40G的数据，不能只保存到一台服务器节点，需要均分到3个master服务器节点上，一个master服务器节点保存13.3G的数据。<br />当有用户请求过来的时候，先经过路由，根据用户的id或者ip，每次都访问指定的服务器节点。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712845390316-6a9587c2-546e-4427-a8bf-dc79e151daae.png#clientId=u05213f45-1bbd-4&amp;from=paste&amp;id=u9edb3f10&amp;originHeight=781&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=218688&amp;status=done&amp;style=none&amp;taskId=ucaa28eb4-295d-4d38-8150-8935d4b6e5d&amp;title=" alt="image.jpg"><br />这用就构成了一个集群。<br />但这样有风险，为了防止其中一个master服务器节点挂掉，导致部分用户的缓存访问不了，还需要对数据做备份。<br />这样每一个master，都需要有一个slave，做数据备份。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712845396885-1ecd1df0-e5e0-4d53-9777-8b1747877d59.png#clientId=u05213f45-1bbd-4&amp;from=paste&amp;id=u085aff34&amp;originHeight=959&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=337180&amp;status=done&amp;style=none&amp;taskId=ucbe2fe73-e2da-4d42-86b6-3cfd765bc47&amp;title=" alt="image.jpg"><br />如果master挂了，可以将slave升级为新的master，而不影响用户的正常使用。<br><a name="K3lsP"></a></p><h3 id="12-负载均衡"><strong>12 负载均衡</strong></h3><p>如果我们的系统部署到了多台服务器节点。那么哪些用户的请求，访问节点a，哪些用户的请求，访问节点b，哪些用户的请求，访问节点c？<br />我们需要某种机制，将用户的请求，转发到具体的服务器节点上。<br />这就需要使用<code>负载均衡</code>机制了。<br />在linux下有<code>Nginx</code>、<code>LVS</code>、<code>Haproxy</code>等服务可以提供负载均衡服务。<br />在SpringCloud微服务架构中，大部分使用的负载均衡组件就是<code>Ribbon</code>、<code>OpenFegin</code>或<code>SpringCloud Loadbalancer</code>。<br />硬件方面，可以使用<code>F5</code>实现负载均衡。它可以基于交换机实现负载均衡，性能更好，但是价格更贵一些。<br />常用的负载均衡策略有：</p><ol><li><code>轮询</code>：每个请求按时间顺序逐一分配到不同的服务器节点，如果服务器节点down掉，能自动剔除。</li><li><code>weight权重</code>：weight代表权重默认为1，权重越高，服务器节点被分配到的概率越大。weight和访问比率成正比，用于服务器节点性能不均的情况。</li><li><code>ip hash</code>：每个请求按访问ip的hash结果分配, 这样每个访客固定访问同一个服务器节点，它是解诀Session共享的问题的解决方案之一。</li><li><code>最少连接数</code>：把请求转发给连接数较少的服务器节点。轮询算法是把请求平均的转发给各个服务器节点，使它们的负载大致相同；但有些请求占用的时间很长，会导致其所在的服务器节点负载较高。这时least_conn方式就可以达到更好的负载均衡效果。</li><li><code>最短响应时间</code>：按服务器节点的响应时间来分配请求，响应时间短的服务器节点优先被分配。</li></ol><p>当然还有其他的策略，在这里就不给大家一一介绍了。<br><a name="tbxs1"></a></p><h3 id="13-限流"><strong>13 限流</strong></h3><p>对于高并发系统，为了保证系统的稳定性，需要对用户的请求量做<code>限流</code>。<br />特别是秒杀系统中，如果不做任何限制，绝大部分商品可能是被机器抢到，而非正常的用户，有点不太公平。<br />所以，我们有必要识别这些非法请求，做一些限制。那么，我们该如何现在这些非法请求呢？<br />目前有两种常用的限流方式：</p><ul><li>基于nginx限流</li><li>基于redis限流<br><a name="K1WBN"></a></li></ul><h4 id="13-1-对同一用户限流"><strong>13.1 对同一用户限流</strong></h4><p>为了防止某个用户，请求接口次数过于频繁，可以只针对该用户做限制。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712845391454-bf14b388-c3d1-4a90-9d03-5ee0ca4ddf8e.png#clientId=u05213f45-1bbd-4&amp;from=paste&amp;id=u32b5b3fd&amp;originHeight=728&amp;originWidth=678&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=101315&amp;status=done&amp;style=none&amp;taskId=u606477cb-5559-4851-b217-7ee7fc8d052&amp;title=" alt="image.jpg"><br />限制同一个用户id，比如每分钟只能请求5次接口。<br><a name="gT3xx"></a></p><h4 id="13-2-对同一ip限流"><strong>13.2 对同一ip限流</strong></h4><p>有时候只对某个用户限流是不够的，有些高手可以模拟多个用户请求，这种nginx就没法识别了。<br />这时需要加同一ip限流功能。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712845392348-65514f77-9c90-4040-9d4a-419000f53998.png#clientId=u05213f45-1bbd-4&amp;from=paste&amp;id=ubb6b8b76&amp;originHeight=724&amp;originWidth=666&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=95854&amp;status=done&amp;style=none&amp;taskId=u664d9884-9cdf-4eb3-b656-9d75772ae9d&amp;title=" alt="image.jpg"><br />限制同一个ip，比如每分钟只能请求5次接口。<br />但这种限流方式可能会有误杀的情况，比如同一个公司或网吧的出口ip是相同的，如果里面有多个正常用户同时发起请求，有些用户可能会被限制住。<br><a name="SSHlH"></a></p><h4 id="13-3-对接口限流"><strong>13.3 对接口限流</strong></h4><p>别以为限制了用户和ip就万事大吉，有些高手甚至可以使用代理，每次都请求都换一个ip。<br />这时可以限制请求的接口总次数。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712845395984-538d61ed-4783-4a28-9f01-0f3a5d6f3bee.png#clientId=u05213f45-1bbd-4&amp;from=paste&amp;id=ude9528c9&amp;originHeight=722&amp;originWidth=666&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=98732&amp;status=done&amp;style=none&amp;taskId=u137e4c8d-4841-4352-a53e-7c5bf1e1131&amp;title=" alt="image.jpg"><br />在高并发场景下，这种限制对于系统的稳定性是非常有必要的。但可能由于有些非法请求次数太多，达到了该接口的请求上限，而影响其他的正常用户访问该接口。看起来有点得不偿失。<br><a name="sLpRN"></a></p><h4 id="13-4-加验证码"><strong>13.4 加验证码</strong></h4><p>相对于上面三种方式，加验证码的方式可能更精准一些，同样能限制用户的访问频次，但好处是不会存在误杀的情况。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712845393220-de332903-179a-4a70-aadd-a89513ab93e2.png#clientId=u05213f45-1bbd-4&amp;from=paste&amp;id=u7228c357&amp;originHeight=842&amp;originWidth=664&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=113971&amp;status=done&amp;style=none&amp;taskId=u5dadc7dc-a246-4eac-8d91-d83323bc445&amp;title=" alt="image.jpg"><br />通常情况下，用户在请求之前，需要先输入验证码。用户发起请求之后，服务端会去校验该验证码是否正确。只有正确才允许进行下一步操作，否则直接返回，并且提示验证码错误。<br />此外，验证码一般是一次性的，同一个验证码只允许使用一次，不允许重复使用。<br />普通验证码，由于生成的数字或者图案比较简单，可能会被破解。优点是生成速度比较快，缺点是有安全隐患。<br />还有一个验证码叫做：<code>移动滑块</code>，它生成速度比较慢，但比较安全，是目前各大互联网公司的首选。<br><a name="FArUN"></a></p><h3 id="14-服务降级"><strong>14 服务降级</strong></h3><p>前面已经说过，对于高并发系统，为了保证系统的稳定性，需要做限流。<br />但光做限流还不够。<br />我们需要合理利用服务器资源，保留核心的功能，将部分非核心的功能，我们可以选择屏蔽或者下线掉。<br />我们需要做<code>服务降级</code>。<br />我们在设计高并发系统时，可以预留一些服务降级的开关。<br />比如在秒杀系统中，核心的功能是商品的秒杀，对于商品的评论功能，可以暂时屏蔽掉。<br />在服务端的<a href="https://cloud.tencent.com/product/tsecc?from_column=20065&amp;from=20065">分布式配置中心</a>，比如：apollo中，可以增加一个开关，配置是否展示评论功能，默认是true。<br />前端页面通过服务器的接口，获取到该配置参数。<br />如果需要暂时屏蔽商品评论功能，可以将apollo中的参数设置成false。<br />此外，我们在设计高并发系统时，还可以预留一些兜底方案。<br />比如某个分类查询接口，要从redis中获取分类数据，返回给用户。但如果那一条redis挂了，则查询数据失败。<br />这时候，我们可以增加一个兜底方案。<br />如果从redis中获取不到数据，则从apollo中获取一份默认的分类数据。<br />目前使用较多的熔断降级中间件是：<code>Hystrix</code> 和 <code>Sentinel</code>。</p><ul><li>Hystrix是Netflix开源的熔断降级组件。</li><li>Sentinel是阿里中间件团队开源的一款不光具有熔断降级功能，同时还支持系统负载保护的组件。</li></ul><p>二者的区别如下图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712845395132-3f4e4ff8-65b5-4132-9d82-794cc5f65bd5.png#clientId=u05213f45-1bbd-4&amp;from=paste&amp;id=udde197a0&amp;originHeight=737&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=261256&amp;status=done&amp;style=none&amp;taskId=u566d1c3e-0c7b-431c-b2c1-bfe08c1bc18&amp;title=" alt="image.jpg"><br><a name="ATSjo"></a></p><h3 id="15-故障转移"><strong>15 故障转移</strong></h3><p>在高并发的系统当中，同一时间有大量的用户访问系统。<br />如果某一个应用服务器节点处于假死状态，比如CPU使用率100%了，用户的请求没办法及时处理，导致大量用户出现请求超时的情况。<br />如果这种情况下，不做任何处理，可能会影响系统中部分用户的正常使用。<br />这时我们需要建立<code>故障转移</code>机制。<br />当检测到经常接口超时，或者CPU打满，或者内存溢出的情况，能够自动重启那台服务器节点上的应用。<br />在SpringCloud微服务当中，可以使用<code>Ribbon</code>做<a href="https://cloud.tencent.com/product/clb?from_column=20065&amp;from=20065">负载均衡器</a>。<br />Ribbon是Spring Cloud中的一个负载均衡器组件，它可以检测服务的可用性，并根据一定规则将请求分发至不同的服务节点。在使用Ribbon时，需要注意以下几个方面：</p><ol><li>设置请求超时时间，当请求超时时，Ribbon会自动将请求转发到其他可用的服务上。</li><li>设置服务的健康检查，Ribbon会自动检测服务的可用性，并将请求转发至可用的服务上。</li></ol><p>此外，还需要使用<code>Hystrix</code>做熔断处理。<br />Hystrix是SpringCloud中的一个熔断器组件，它可以自动地监测所有通过它调用的服务，并在服务出现故障时自动切换到备用服务。在使用Hystrix时，需要注意以下几个方面：</p><ol><li>设置断路器的阈值，当故障率超过一定阈值后，断路器会自动切换到备用服务上。</li><li>设置服务的超时时间，如果服务在指定的时间内无法返回结果，断路器会自动切换到备用服务上。到其他的能够正常使用的服务器节点上。<br><a name="qaCKi"></a></li></ol><h3 id="16-异地多活"><strong>16 异地多活</strong></h3><p>有些高并发系统，为了保证系统的稳定性，不只部署在一个机房当中。<br />为了防止机房断电，或者某些不可逆的因素，比如：发生地震，导致机房挂了。<br />需要把系统部署到多个机房。<br />我们之前的游戏登录系统，就部署到了深圳、天津和成都，这三个机房。<br />这三个机房都有用户的流量，其中深圳机房占了40%，天津机房占了30%，成都机房占了30%。<br />如果其中的某个机房突然挂了，流量会被自动分配到另外两个机房当中，不会影响用户的正常使用。<br />这就需要使用<code>异地多活</code>架构了。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712845396551-101db254-e616-44e1-a4b8-0367fe3af60f.png#clientId=u05213f45-1bbd-4&amp;from=paste&amp;id=ue03b5f7c&amp;originHeight=821&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=236330&amp;status=done&amp;style=none&amp;taskId=u78755f1f-4ced-4174-9c86-9f79c4e055e&amp;title=" alt="image.jpg"><br />用户请求先经过第三方的DNS服务器解析，然后该用户请求到达路由服务器，部署在云服务器上。<br />路由服务器，根据一定的算法，会将该用户请求分配到具体的机房。<br />异地多活的难度是多个机房需要做数据同步，如何保证数据的一致性？<br><a name="AOOEu"></a></p><h3 id="17-压测"><strong>17 压测</strong></h3><p>高并发系统，在上线之前，必须要做的一件事是做<code>压力测试</code>。<br />我们先要预估一下生产环境的请求量，然后对系统做压力测试，之后评估系统需要部署多少个服务器节点。<br />比如预估有10000的qps，一个服务器节点最大支持1000pqs，这样我们需要部署10个服务器节点。<br />但假如只部署10个服务器节点，万一突增了一些新的用户请求，服务器可能会扛不住压力。<br />因此，部署的服务器节点，需要把预估用户请求量的多一些，比如：按3倍的用户请求量来计算。<br />这样我们需要部署30个服务器节点。<br />压力测试的结果跟环境有关，在dev环境或者test环境，只能压测一个大概的趋势。<br />想要更真实的数据，我们需要在pre环境，或者跟生产环境相同配置的专门的压测环境中，进行压力测试。<br />目前市面上做压力测试的工具有很多，比如开源的有：Jemter、LoaderRunnder、Locust等等。<br />收费的有：阿里自研的云压测工具PTS。<br><a name="wamWq"></a></p><h3 id="18-监控"><strong>18 监控</strong></h3><p>为了出现系统或者SQL问题时，能够让我们及时发现，我们需要对系统做监控。<br />目前业界使用比较多的开源监控系统是：<code>Prometheus</code>。<br />它提供了 <code>监控</code> 和 <code>预警</code> 的功能。<br />架构图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712845396759-75cf3b5a-97a8-4163-b6e9-90d7ca0b8e06.png#clientId=u05213f45-1bbd-4&amp;from=paste&amp;id=u755cc14a&amp;originHeight=648&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=131333&amp;status=done&amp;style=none&amp;taskId=u673e0da1-dc85-4535-9a3f-03d13efa53e&amp;title=" alt="image.jpg"><br />我们可以用它监控如下信息：</p><ul><li>接口响应时间</li><li>调用第三方服务耗时</li><li>慢查询sql耗时</li><li>cpu使用情况</li><li>内存使用情况</li><li>磁盘使用情况</li><li>数据库使用情况</li></ul><p>等等。。。<br />它的界面大概长这样子：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712845397527-220b78a9-06cc-48fb-89ea-fa1c4d696c16.png#clientId=u05213f45-1bbd-4&amp;from=paste&amp;id=uf35705d6&amp;originHeight=406&amp;originWidth=778&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=86208&amp;status=done&amp;style=none&amp;taskId=u76284ef4-02a2-4033-a352-4647fa3ba36&amp;title=" alt="image.jpg"><br />可以看到mysql当前qps，活跃线程数，连接数，缓存池的大小等信息。<br />如果发现数据量连接池占用太多，对接口的性能肯定会有影响。<br />这时可能是代码中开启了连接忘了关，或者并发量太大了导致的，需要做进一步排查和系统优化。<br />截图中只是它一小部分功能，如果你想了解更多功能，可以访问Prometheus的官网：<a href="https://prometheus.io/">https://prometheus.io/</a><br />其实，高并发的系统中，还需要考虑安全问题，比如：</p><ol><li>遇到用户不断变化ip刷接口怎办？</li><li>遇到用户大量访问缓存中不存在的数据，导致缓存雪崩怎么办？</li><li>如果用户发起ddos攻击怎么办？</li><li>用户并发量突增，导致服务器扛不住了，如何动态扩容？</li></ol><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;P7lcA&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2024/png/28066124/1712845381522-</summary>
      
    
    
    
    <category term="高并发" scheme="http://www.bojiboqi.fun/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="高并发" scheme="http://www.bojiboqi.fun/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>第 1 章 研发自测基础 - 《Java 研发自测》</title>
    <link href="http://www.bojiboqi.fun/2024/04/22/%E7%AC%AC%201%20%E7%AB%A0%20%E7%A0%94%E5%8F%91%E8%87%AA%E6%B5%8B%E5%9F%BA%E7%A1%80%20-%20%E3%80%8AJava%20%E7%A0%94%E5%8F%91%E8%87%AA%E6%B5%8B%E3%80%8B/"/>
    <id>http://www.bojiboqi.fun/2024/04/22/%E7%AC%AC%201%20%E7%AB%A0%20%E7%A0%94%E5%8F%91%E8%87%AA%E6%B5%8B%E5%9F%BA%E7%A1%80%20-%20%E3%80%8AJava%20%E7%A0%94%E5%8F%91%E8%87%AA%E6%B5%8B%E3%80%8B/</id>
    <published>2024-04-22T06:31:49.927Z</published>
    <updated>2024-04-22T23:27:15.588Z</updated>
    
    <content type="html"><![CDATA[<p>软件测试是一个非常专业的领域，甚至有一些大学也设置了软件测试课程。虽然大多数软件公司都会设置软件测试类的岗位，但是对于一个优秀的研发人员来说，保证软件质量也应该是份内的事情。<br />研发人员如果从研发的角度关注测试，那么只需要一丁点投入，就可以换取巨大的价值。因为研发人员熟悉技术方案、编码的细节，甚至所有的分支流程，且了解基本的测试概念，在本地开发过程中就能发现大量的问题，这样就避免了反复移交测试等流程，极大地提高了效率。另外，编写出高质量的代码，可以给研发人员带来满足感和信心，避免了反复调试。而且交付高质量的程序后，研发人员也可以更好地集中精力进行下一段程序的开发，避免了因为被打断而造成的上下文切换带来的精力消耗。<br />本章会介绍软件测试的一些基本概念和知识，由于本书是面向研发人员的，因此在内容组织上会主要关注在白盒测试上。<br />本章涵盖的内容以及学习目标如下：</p><ul><li>了解软件测试的基本概念。</li><li>理解常见的测试分类。</li><li>掌握测试用例设计的一般方法。</li><li>了解哪些类型的测试适合研发人员自测完成。</li><li>一些准备测试数据的技巧。<br><a name="Tq4QA"></a></li></ul><h2 id="1-1-软件测试的基本概念">1.1 软件测试的基本概念</h2><p>软件测试是一项专业的工作，里面涉及一些专业术语和概念，了解它们可以更好地与质量工程师沟通，本节将精选部分概念进行解释，这些概念是了解软件测试的基础。<br><a name="ctNwK"></a></p><h3 id="1-1-1-软件测试">1.1.1 软件测试</h3><p>软件工程中的很多概念来自传统的工程行业，测试（Testing）是一种检验产品质量的活动。因此，通常意义上的 “软件测试” 被定义为特定环境下检查软件是否存在错误，以及能否满足业务需求和设计的活动或过程。<br />但是软件的含义不仅仅是程序本身，还包括文档、数据和其他基础设施，因此对软件质量的保证并没有局限于代码本身。这也是越来越多的公司将测试工程师（Software Test Engineer）的岗位转变为质量工程师 （Quality Assurance）的原因。<br />由于对软件的修改伴随着整个软件生命周期，业界开始提倡全流程测试，或者叫全生命周期质量保证。编写单元测试或者特定类型的测试只是软件测试的一小部分。<br />软件开发过程中，无论采用的是瀑布开发模式还是敏捷开发模式，都会存在需求分析、设计、编码、测试、运行等过程。在基于全流程测试的发展过程中，越来越多的测试类型被提出来，比如需求测试、架构测试、设计测试、单元测试、集成测试等。<br />不仅仅是测试人员需要关注测试结果，整个团队都需要对质量负责。团队工程能力包含了对软件质量的要求，可以参考能力成熟度模型集成的描述。<br />能力成熟度模型集成（CMMI）是一个组织过程改进框架，CMMI 中的不同等级描述了不同层次的软件开发能力，也就是软件工程成熟度。CMMI 对软件质量提出了要求，这些要求也是很多公司对质量工程师的诉求。<br />此外，想要保证软件的质量，对软件测试和开发过程的度量也非常重要，除了测试本身之外，还需要利用统计技术对测试的结果进行量化。这种从测试人员关注测试，到团队关注测试的转变，让软件测试从作坊式的定性操作，转变为科学的定量操作。质量的度量指标和方法非常多样，比如有测试覆盖率、每千行代码的缺陷率等指标。质量的度量指标可以同比或者环比软件质量的变化。<br />为确保在软件的整个生命周期中对需求、开发、运维的质量进行测试和验证，合理的分析和规划必不可少。这些分析包括软件项目启动时期测试策略的制定，对设计指标的核定，提取需求中的设计指标等。<br />现代的软件测试提倡测试的工作不在开发完成后开始，也不在运营投产后结束。项目开始时测试人员就需要参与对需求的验证和评审，因此也就衍生出了测试左移的概念，而对运营期质量提出要求，则相应产生了测试右移的概念。<br><a name="ztFal"></a></p><h3 id="1-1-2-缺陷">1.1.2 缺陷</h3><p>如果软件没有按照我们的期望运行，我们会说软件有 Bug。Bug 的原意是 “臭虫”，这个名称的来源是继电器计算机中飞进的一只飞蛾。<br />被公认为世界上最早一批程序员中的葛丽丝·霍普女士在 Mark II 计算机上工作时，设备无法正常工作了，整个团队都不知道怎么回事。后来经过排查发现是一只飞蛾飞入设备内部引起的故障（Mark II 是一台继电器计算机，异物的侵入会导致元件无法工作）。葛丽丝·霍普女士在她的笔记中记录了这个故事，说明问题的根因是一个虫子引起的， Bug 这个词也流传了下来。<br />不过在软件工程领域，更多使用缺陷（Defeat）来描述软件没有按照预期运行的现象。缺陷描述的不仅仅是程序编码上的错误，还包括需求和设计的不合理，运营期间的配置问题，以及基础设施故障等。<br />在实际工作中，缺陷的引入可能会发生在软件开发生命周期的任何一个环节中，可以使用正交缺陷分类（Orthogonal DefectClassification）法划分缺陷，具体如下。</p><ul><li>需求缺陷：需求本身不合理或者缺乏系统性考虑，造成一致性问题或逻辑矛盾。</li><li>设计缺陷：设计方案时未考虑到一些场景，或者在设计上不能满足一些特定场景，造成软件在使用过程中出现问题。</li><li>编码缺陷：由于开发者的疏忽或者其他原因，在编码阶段引入的缺陷。</li><li>配置缺陷：在投入生产使用的过程中，由于配置不合理或者环境发生变化造成的缺陷，比如更换操作系统后软件无法兼容。</li></ul><p>为了更清晰地描述缺陷这个概念，人们区分了以下几个概念。</p><ul><li>缺陷（Defect）：软件产品中不满足设计需要的部分，它是静态的，一直存在，也就是我们通俗说的 Bug。</li><li>错误（Error）：程序执行有缺陷的代码或者输入特定的数据后，造成程序状态异常。</li><li>失效（Failure）：失效是软件不能正常运行，使用者感知到的状态。一个软件可能有缺陷但是不一定会带来错误并被感知到，失效也有可能是非缺陷造成的，比如运行环境不满足要求等。</li></ul><p>需要注意的是，缺陷并不一定会导致程序运行错误，由缺陷导致程序发生错误，叫做缺陷的激活。缺陷往往需要在特定的条件和场景下才会被激活，例如，一些特别的输入或者运行环境发生变化。<br />未知条件和场景下的缺陷修复起来非常困难，软件测试的工作就是将能复现这些缺陷的场景找出来，以便于修复。<br />另外，现在也有很多公司根据优先级和严重性对导致问题的缺陷进行分类，比如将缺陷分为 4 个级别：</p><ul><li>P0 致命：非常严重的线上事故（比如让整个系统瘫痪），需要停下手上的工作立即修复。如果不能在一定时间内修复，需要上报，通过其他途径来解决（比如使用备用方案）。</li><li>P1 严重：部分重要功能不可使用，虽然优先级没有 P0 那么高，但是也需要立即修复并发布补丁。</li><li>P2 一般：次要功能不可使用，会给用户带来不便，但是由于需要平衡正常工作节奏，因此不会立即修复，在迭代发布时修复即可。</li><li>P3 轻微：会给用户带来不便，或者 UI、文案上存在需要调整的内容。在不影响开发节奏的前提下，进行优化处理即可。</li></ul><p>说明：上述分类中的字母 P 是 Priority 的首字母缩写，中文含义是优先级。<br><a name="TFNf6"></a></p><h3 id="1-1-3-测试用例">1.1.3 测试用例</h3><p>测试用例（Test Case，TC）是一组测试输入和预期的集合。简单来说就是包含测试内容需要的输入信息、预期及结果，以及特定的测试环境。<br />在不同的软件开发模型中，测试用例呈现的方式不同。在瀑布模型中，通常会有完善的表格来管理测试用例，并持续维护；使用敏捷的方式，测试用例往往跟随着用户故事（用户故事是一种敏捷需求澄清的方法，包含可验收的最小特性集）；RUP（统一软件开发过程）则要求测试用例可以追溯验证系统行为，采用类似瀑布的方式维护测试用例，但是每个迭代都需要更新，并持续维护。<br />测试用例的规格在 IEEE 标准和国标（GB/T）上都有被定义过，主要包含如下内容：</p><ul><li>被测试的对象，对应软件特性或者需求。</li><li>给予的条件，包括输入信息和测试环境，输入信息包含了测试数据和操作步骤（执行路径）。</li><li>期望的结果，包含软件的执行预期，即期待的程序输出。</li></ul><p>如果能严格和良好地基于测试用例进行实践，可以用较小的成本覆盖大量的测试场景，并能准确地让问题重现。<br />在一些团队会使用思维导图作为测试用例，但是这种形式比较难以维护。越来越多的公司会创建自己的测试管理平台，思维导图则作为测试用例的补充。<br />编写好的测试用例，需要遵守如下的原则：</p><ul><li>期望的结果可判定。测试用例有明确的判定标准，比如系统登录成功显示 “登录成功” 文案以及个人信息。</li><li>测试用例可重复执行。测试用例应该能被反复执行，并且结果保持稳定。</li><li>测试用例具有代表性。测试用例的设计应该从典型到特殊延展，并能覆盖核心业务场景。</li></ul><p>让测试用例具有代表性是设计测试用例的难点，设计者需要从不同的角度选取测试场景，达到最优的测试性价比。有些公司会把正常的流程和符合预期的结果叫做正向用例，把一些异常处理的场景叫做反向用例。<br />另外最为关键的地方是设计测试数据时，需要考虑到大量的边界值。边界值指的是介于正常数据和错误数据之间的临界数据，比如 0 是正数和整数之间的一个边界值。用户输入往往难以穷尽，借助边界值作为代表性测试数据是一种常用的方式。<br><a name="y0lcx"></a></p><h3 id="1-1-4-测试金字塔">1.1.4 测试金字塔</h3><p>软件测试有很多类型，测试金字塔的核心理念是：不同测试类型的收益和性价比是不一样的。关于软件测试的分类会在后面逐步讲解。<br />为了取得最优的测试效果，在不同性价比的测试上投入的时间也应不一样的。通常来说，基于界面的测试，自动化难度高，且为了能覆盖更多的的场景，并让测试正常运行，需要准备的数据量也更多，相应地投入的时间也会较多。<br />单元测试则不太一样，测试的目标更加精确，需要准备的测试数据量较少，同时单元测试运行得更快，因此投入的时间较少。<br />在 《Succeeding with Agile》[^1] 一书中提出了一个测试金字塔，形象地描述了界面测试、服务测试和单元测试的差异。图 1-1 是简单的测试金字塔，可以用来描述不同测试类型的执行速度和消耗资源的情况。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712849903355-0b8799bc-b3d8-4613-b304-7f41c2efeab8.png#clientId=ud9ce2bc5-7541-4&amp;from=paste&amp;id=uc2ec10e8&amp;originHeight=368&amp;originWidth=644&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=25356&amp;status=done&amp;style=none&amp;taskId=ubd011db0-8f0f-47d6-849d-3f097064196&amp;title=" alt="image.jpg"><br />图 1-1 测试金字塔<br />实际上测试金字塔中层次的划分取决于所采用的技术栈，并不拘泥于图 1-1 中所示这三层。在微服务系统中，我们通常使用的测试金字塔可以描述为：单元测试、API 测试、界面测试。<br />测试金字塔的每一层都可以选用不同的工具来实现自动化，在后面的内容中，会逐步介绍一些自动化测试工具。<br />测试金字塔只是一种对测试划分方法的模型，这种模型可以有非常多的解释和变种。在一些测试金字塔中我们可能会看到手工测试、验收测试等内容，也可能会有非常多层。测试金字塔主要应用于敏捷过程的测试工作中，在其他的软件开发过程中也不同的测试模型，例如 V 模型。<br><a name="O1N8d"></a></p><h3 id="1-1-5-测试策略">1.1.5 测试策略</h3><p>从测试金字塔又可以引申出另外一个非常重要的测试概念，那就是测试策略。测试策略描述的是一个项目或者产品如何组织测试活动，以获取最大的价值。<br />完整的测试策略就是一个项目的完整测试框架，涵盖了关于质量的各方面测试清单，以及对应的实施方式。测试策略可以是一份详尽的文档，也可以是一个图示或者一份简单的检查清单。<br />同事林冰玉老师在一次分享中展示了图 1-2 （一份简单明了的测试策略），用于说明测试策略。此图描述了敏捷团队活动中的测试实践，图中左下角使用了一个测试象限，描述哪些测试应该自动进行，中间展示的是一个四层的测试金字塔。测试金字塔中的测试实践为：单元测试、API 集成测试、端到端测试、探索式测试。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712849904078-c22cb704-9a84-4630-83a6-5fbaf9bb9c0e.png#clientId=ud9ce2bc5-7541-4&amp;from=paste&amp;id=ubcfcd1ef&amp;originHeight=638&amp;originWidth=1264&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=183920&amp;status=done&amp;style=none&amp;taskId=u061c3d0f-e3a3-494b-8e7f-fbfab296540&amp;title=" alt="image.jpg"><br />图 1-2 一份简单明了的测试策略<br />注：图片来源于 <a href="https://www.bylinzi.com/2020/01/10/one-page-test-strategy%E3%80%82">https://www.bylinzi.com/2020/01/10/one-page-test-strategy。</a><br />测试策略中需要包含如下内容。</p><ul><li>测试原则：所有的实践都应该围绕这个原则展开，比如 “团队为质量负责”。</li><li>测试范围：功能特性、性能、安全、可用性、可靠性等。</li><li>测试方法：需求和设计评审、静态代码分析、单元测试、集成测试、E2E 测试、安全建模、渗透测试、探索性测试等。</li></ul><p>如果将测试策略延展，还可以包括各项软件质量度量的内容等。<br><a name="TlBJD"></a></p><h3 id="1-1-6-测试左移和测试右移">1.1.6 测试左移和测试右移</h3><p>这是两个比较新的概念，在传统的软件测试教程中有类似的概念，但是叫法不同。<br />测试左移是指在软件进入测试阶段之前就介入测试，QA（测试人员）在设计阶段就参与，并对设计阶段的各项活动进行评估。在需求澄清的时候就应该参与，并对需求、用户故事等输出进行检查。另外，在研发人员进入设计阶段后，也可以对输出的技术方案进行评估，验证技术方案是否能满足设计目标。测试左移还可以提前准备用例和测试环境，调整测试方案以具备更好的测试性。<br />测试右移是指软件进入发布阶段后也需要 QA 参与，软件发布后 QA 需要持续关注线上预警和监控，及时发现问题，并尝试在测试环境中重现。这样 QA 就可以驱动研发人员在开发过程中考虑接入监控、告警等基础设施，开发团队需要比市场、业务方以及用户更快地发现问题，并制定解决措施。<br />测试左移和测试右移听起来比较晦涩，简单来说就是 QA 参与敏捷项目的全生命周期。<br><a name="HqhL7"></a></p><h3 id="1-1-7-质量度量">1.1.7 质量度量</h3><p>在现代软件的开发过程中，度量是一种非常重要的实践。度量可以通过用量化的方法取代定性的结论，来评估软件的质量、过程和测试有效性等，让管理层能做出合理的决策。对于人员配比、能效提升、绩效考核等各个方面都有一定意义。<br />质量度量的指标研究包含以下几个方面：</p><ul><li>对于产品的质量进行衡量。</li><li>对于测试的有效性进行衡量。</li><li>对于测试的完整性进行衡量。</li><li>对于测试过程和软件开发过程的分析和改进。</li></ul><p>对于普通测试人员和研发人员来说，我们不需要特别去设计这些度量指标，可以根据国际、国内的指标标准提取一些合适自己的指标，作为公司内部使用的度量体系。<br />ISO/IEC 9126 标准从功能性、可靠性、易用性、效率、可维护性、可移植性这 6 个特性进行度量，和前面对缺陷的理解类似，ISO/IEC 9126 标准将这些指标划分为通用、内部指标、外部指标。内部指标的含义是，侧重在交付前的度量，不关注缺陷被激活的情况，更加关注软件的本质问题。<br />在国内也有相应的度量体系，GB/T 延用了 ISO/IEC 9126 中的指标，从 6 个方面对软件质量进行评估。在 《GB/T 32904—2016 软件质量量化评价规范》中，该文档给出了一套根据指标计算软件质量的方法，其中参考使用的标准体系如图 1-3 所示。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712849905912-e2dc764d-f841-42e8-8188-455606952b11.png#clientId=ud9ce2bc5-7541-4&amp;from=paste&amp;id=u8dc162dc&amp;originHeight=772&amp;originWidth=742&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=540288&amp;status=done&amp;style=none&amp;taskId=u2ba7d1d7-daae-40a3-963a-78cbc43c760&amp;title=" alt="image.jpg"><br />图 1-3 GB/T 标准体系<br />对于测试有效性和完整性的衡量可以参考一些主流软件公司的做法，比如某公司会根据千行代码（代码规模一般不作为唯一手段）为基线统计一些测试能力的指标：</p><ul><li>每千行用例数。</li><li>每千行缺陷率。</li><li>用例平均执行时间。</li><li>缺陷平均回归次数。</li><li>有效缺陷率（经过确认特性描述不清楚导致的缺陷）。</li></ul><p>通过度量后，会根据缺陷的优先级和严重程度进行加权计算，获得每个版本的软件质量指数。<br />在应用指标的时候，还需要做出区分。由于有一些项目是建立在遗留系统之上的，它的开发过程、逻辑和完全从头开始的项目很不一样。因此我们在使用这些指标的时候，可以根据项目的类型做出取舍。根据软件系统遗留特性可以将项目划分为绿地工程、棕地工程、维护性工程。</p><ul><li>绿地工程：一项绿地工程可能是在全新的领域中开发，不需要考虑历史遗留问题。绿地工程往往存在需求无法清晰描述特性，有效缺陷率低，缺陷修复的成本低，缺陷回归的效率高等特点。</li><li>棕地工程：此类工程中的系统通常是现有系统的一部分，或者是其子系统。需要考虑与其他系统尤其是与历史遗留系统（Legacy system）的集成问题。这类项目往往缺陷回归次数高，缺陷的修复成本很大。</li><li>维护性工程：指的是不再开发新功能的系统，只完成维护性工作。<br><a name="jBZuH"></a></li></ul><h2 id="1-2-软件的测试分类">1.2 软件的测试分类</h2><p>不同维度下人们对软件测试的分类极不一致。比如，根据开发过程进行分类，软件的测试类型有：单元测试、集成测试、系统测试和验收测试，这些类型分别和软件开发过程中的各个阶段相适配。但是如果从被测试的对象角度来看，软件测试又可以分为静态测试和动态测试。如果是以测试人员对代码的了解程度来看，则可以分为白盒测试、黑盒测试、灰盒测试。根据是否是自动化运行的测试来区分，又可以分为自动化测试和手工测试。<br />当然还有一些非常时髦的测试类型，比如契约测试、弹珠测试、冒烟测试等。这些名目繁多的测试，会给团队造成困扰。此外，由于中英文翻译的原因，像 E2E 这类名称没有准确中文含义的测试，更容易让团队成员摸不着头脑。<br />本书将根据前面提到的测试策略和测试金字塔，并参考 GB/T 的规范，对一个敏捷团队需要进行的测试类型进行简化。为了更加容易理解和记忆，本书将其分为功能性测试和非功能性测试。<br />正如字面上的理解，功能性测试对应的是功能性的需求，针对软件特性的业务目标和逻辑。非功能性测试，针对的是非功能性的要求。这些要求可能在业务需求上没有做明确的说明，但是不能满足这些要求则会给软件交付带来巨大的风险。<br />**功能性测试 **</p><ul><li>单元测试。</li><li>集成测试。</li><li>系统测试。</li><li>验收测试。</li></ul><p>**非功能性测试 **</p><ul><li>静态分析。</li><li>安全测试。</li><li>性能测试。</li></ul><p>就一般的软件而言，一个敏捷团队做好这 7 项测试就能涵盖绝大部分测试需求。实际上，很多公司都没有做到，或者做好这 7 类测试。下面就这 7 类测试进行简单的介绍。<br><a name="v2xNc"></a></p><h3 id="1-2-1-单元测试">1.2.1 单元测试</h3><p>单元测试（Unit Testing）是指对软件中最小可测试单元进行测试。“单元” 的粒度并没有一个明确的界限，细粒度的单元测试含义一般是对方法、类等代码结构进行测试和验证。粗粒度的单元测试可以是对一个最小的软件特性进行验证，根据设计需求文档或者设计文档进行验证。<br />单元测试往往处于测试金字塔的最低端。因为单元测试能透明地验证方法、类这一类代码结构，因此编写自动化运行的测试也比较简单。在目前的语义下，单元测试默认有自动化运行的含义。<br />对软件质量来说，单元测试有非常积极的作用，是测试金字塔中最重要的部分。通过单元测试可以将复杂的测试用例进行拆解，比如从较大规模的测试路径分解成小规模的测试。且单元测试的难度相对较小，测试效率也相应较高。单元测试对环境要求低，隔离性好，为同时运行多个测试用例提供了可能性。<br />另外，研发人员积极编写单元测试，在遇到问题时可以帮助定位缺陷。<br><a name="VLFBx"></a></p><h3 id="1-2-2-集成测试">1.2.2 集成测试</h3><p>集成测试（Integration Testing）是指在单元测试的基础上，对一部分软件模块进行组合或者在组装后进行的测试。在微服务时代，通常来说集成测试是对一个服务的 API 进行测试，因此在很多文章和书籍中都会有 API 测试。请注意 API 这个词的含义过于广泛，包括 RESTful API 和操作系统等软件接口的概念，需要根据上下文确定含义。<br />集成测试需要启动部分或者整个应用的上下文，因此相对单元测试来说，集成测试需要准备的环境更多。在微服务的技术栈下，通常集成测试等同于单个服务的 API 测试。<br />随着 DevOps 的发展，持续集成的概念得到了广泛关注，集成测试自然也就非常重要了。好的集成测试能保证一个服务部署到测试环境后，不会影响到其他依赖的服务。<br />在一些大的项目中，服务众多且相互依赖。早期的集成测试大多是手工完成的，会在集成测试时，先进行一个快速地冒烟测试（Smoke Testing）。冒烟测试是对软件的基本功能进行快速验证的过程。冒烟测试来源于早期硬件开发，在对硬件组件更改后直接给设备通电，如果没有冒烟就通过测试。冒烟测试用来检查主要的功能是否正常，避免因为其中一个服务异常而对整套测试环境造成中断。<br />在 CI/CD 发展比较好的团队，会在服务部署到正式的测试环境前，对 API 进行自动化的测试，如果测试发现问题，会停止部署到测试环境。集成测试的依据是技术设计文档，比如 API 设计等材料。<br />一般情况下，研发人员也会参与集成测试，或者是在研发人员的配合下由 QA 完成集成测试。<br><a name="TsY02"></a></p><h3 id="1-2-3-系统测试">1.2.3 系统测试</h3><p>系统测试（System Testing）是指对完整的软件产品进行端到端的测试，某种程度上可以等同于 E2E 测试。<br />系统测试需要搭建完整的环境，以便在真实或者模拟系统的环境下对软件进行验证，确认是否达到设计目标。需要配置的完整的软硬件环境和基础设施包括数据库、网络连接、DNS 等。<br />系统测试往往是黑盒测试，此测试会模拟正常的用户在使用整个应用程序时的各种操作。系统测试不仅要发现缺陷，还应该提出不限于需求规格范围的反馈，甚至还包括一些使用过程中的便利性问题。<br />系统测试的依据是需求文档，包括 QA 在需求澄清阶段的任何输入。<br><a name="Pfjoo"></a></p><h3 id="1-2-4-验收测试">1.2.4 验收测试</h3><p>验收测试（Acceptance Testing）是指在软件开发后期，需求的提出方对软件进行验收确认时进行的测试。<br />如果是软件交付性质的项目，甲方往往会派出测试专家，从用户的角度进行测试，确认是否满足需求规格。在互联网或者其他产品型的公司，验收测试则是产品上线或者软件发布后，由业务方在真实的环境下进行验证。<br />对一个在运行中的互联网产品来说，验收测试需要得到特别的授权。因为在生产环境中，一般会产生数据或者留下痕迹，在有条件的情况下可以考虑清理或者隐藏这些信息。<br><a name="TDrGR"></a></p><h3 id="1-2-5-静态分析">1.2.5 静态分析</h3><p>软件的静态分析（Static Analysis）是指对软件的各种结构和成分进行扫描，提前发现问题，它通常被作为测试的补充。静态分析一般都是用自动化的工具或者平台在日常进行扫描和监测的。<br />德国飞机涡轮机的发明者帕布斯·海恩提出的一个在航空界关于飞行安全的法则，法则指出：每一起严重事故的背后，必然有 29 次轻微事故和 300 起未遂先兆以及 1000 起事故隐患。应用于软件开发中，如果项目中代码混乱不堪，必然会在某个时候爆发大量的问题。<br />静态分析的目的就是通过扫描的手段发现代码中的一些通用问题，或者找出违反编码、安全规范的代码。常见的扫描工具如下。</p><ul><li>Checkstyle：Java 代码风格扫描。</li><li>FindBugs：从代码模式上发现潜在问题。</li><li>ArchUnit：架构规范扫描，验证软件包的组织合理性。</li><li>OWASP Dependency-Track：对依赖的第三方软件和库进行检查，发现是否存在安全风险。</li></ul><p>除此之外，市面上还有一些其他的扫描工具，比如：PMD、FortifySCA 这些都属于静态分析的内容。<br><a name="qvRWF"></a></p><h3 id="1-2-6-安全测试">1.2.6 安全测试</h3><p>安全测试（Security Testing）是指对系统的安全要求进行验证的一类测试。安全测试针对的是代码执行、命令执行、病毒植入、端口扫描、DoS 攻击、SQL 注入攻击、CSRF 攻击、XSS 攻击、数据遍历、越权、认证绕过、金额篡改等安全问题的测试。<br />由于互联网项目会将用户信息暴露到公网，近些年来企业对安全测试的要求又有一定提高，数据隐私、威胁建模也都被包含在安全测试的领域。</p><ul><li>数据隐私是指软件系统在使用用户的信息时，需要满足当地法律合规的要求，且应尽力保护用户的隐私数据。</li><li>威胁建模是通过一些建模工具来分析软件会受到哪些方面的安全威胁，并制定测试策略的过程。STRIDE 是常用的威胁模型，它包含欺骗、篡改、否认、信息泄露、DoS 威胁、特权提升 6 个方面，从这些方面可以结构化地制定应对措施。</li></ul><p>在一些大的团队中，安全测试往往会由专门的安全专家进行或者给予指导。没有条件的，则由研发人员和 QA 共同完成。<br><a name="FVTvm"></a></p><h3 id="1-2-7-性能测试">1.2.7 性能测试</h3><p>性能测试（Performance Testing）是指针对软件性能指标进行的测试。性能测试包括了软件响应速度和用户容量等方面的内容。<br />响应速度代表用户使用软件的等待时间，对于一些常规操作而言，等待时间过长，会极大地影响用户使用。一般对 Web 程序来说，页面的加载时间不超过 2 秒，否则会造成大量的用户流失。<br />用户容量代表着有多少用户能同时使用该软件。单机软件对用户容量要求不高，对于互联网项目，性能测试需要涵盖容量指标。性能测试中有一种负载测试，用于通过模拟用户递增的方式找出系统的最大容量，以及验证系统是否能通过增加服务的方式水平扩容。<br />性能测试工具包括 JMeter、AB、K6 等。JMeter、AB 都是 Apache 基金会的产品，具有良好的使用口碑。K6 是一款新的性能测试工具，能使用 JavaScript 语法编写自动化的性能测试脚本，对 Web 程序相当友好。<br><a name="tOuCW"></a></p><h2 id="1-3-测试用例设计入门">1.3 测试用例设计入门</h2><p>一般讲解测试的书籍会将测试分为白盒测试和黑盒测试，然后提供更具体的测试用例设计方法，比如等价划分、因果图法、决策表法、边界值分析等。<br />但是，对于大部分的研发人员来说都用不到这么多复杂的方法，因此这里只介绍几种常用的，这些方法在后文会逐一用到。<br />测试用例设计的本质思想是，将原本需要穷举的所有测试数据进行科学的归类、选择、划分，以期用最少的测试数据就可以达到最佳的测试效果。<br />设计测试用例遵守的基本思想是 MECE 原则，它是 Mutually Exclusive,Collectively Exhaustive 的缩写，中文意思是 “相互独立，完全穷尽”。这是一种拆解和分析问题的方法，最开始来自于《金字塔原理》一书，能比较好地指导用例设计的相关实践。<br />在设计测试用例时，每个用例的执行（无论是人工还是自动化）都有成本，那么需要尽可能的节约。相互独立的意思是拆分的用例没有交叉，完全穷尽是说拆分的问题需要覆盖到所有的情况。比如，把测试数据用户分为男性用户和学生用户，这样就发生了重叠。当然，MECE 是一种理想情况，在测试过程中，很难达到这种情况，否则缺陷也就不会存在了。但是，我们可以尽可能地参考这个原则来设计用例，让每个用例都物尽其用。<br><a name="XxfsV"></a></p><h3 id="1-3-1-等价类划分">1.3.1 等价类划分</h3><p>等价类的划分其实来自于数学的集合论，指的是可以将输入域的集合划分为几个等价子集合，等价类中的元素对于揭露程序中的错误来说是等效的。从划分合理的等价类中取出任意一条数据作为输入条件，均可获得同样的测试效果，这样就可以提高测试效率。<br />通俗地来说，在同一个等价类中，只要有一条测试数据让软件出错，那么这个等价类中的其他数据往往也会让软件出错。<br />举一个例子，在一款支付软件中，正确的输入是常规大小的数字，输入其他诸如 “&amp;* (” 这样的特殊字符或字母，则会给予提示。那么， 输入字母 A 和 B 就没什么区别，可以将它们视为同一个等价类中。<br />正是因为正确的输入和错误的输入差异非常明显，所以就形成了天然的划分方式，一般将等价类划分为有效等价类和无效等价类。<br />有效等价类是指对软件来说合理、有意义的输入数据集合。一般来说，有效的等价类只需要一组即可，在有些情况下可以设计多个，一些团队称之为正向测试（Happy Path）。<br />无效的等价类是指对软件来说不合理、无意义的输入数据集合，相对于有效等价类来说，无效等价类的情况多得多，需要继续划分。无效等价类又被叫做反向测试。<br />等价类划分有几项固定模式可以参考：</p><ul><li>如果规定了输入数值的范围，可以设定一个有效等价类，两个无效的等价类。</li><li>如果规定了输入的数值的规则，可以设定一个符合规则的等价类，两个违法规则的等价类。</li><li>如果规定了输入的数是一个整数，可以参考的等价类有 0、正整数、负整数和小数等。</li><li>如果规定输入的是一个字符串，可以参考的等价类有正确的字符串、空、空白字符串和超长的字符串等。</li></ul><p>下面来看一个通过等价类划分，设计测试用例的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">支付平台在处理用户输入时，要求用户输入符合要求的金额 X，有如下规则，如果满足规则输入框校验通过，否则提示错误：</span><br><span class="line"></span><br><span class="line">1. 用户只能输入大于 0 小于等于 2000 的金额。</span><br><span class="line">2. 金额的单位是精确到两位小数的人民币元。</span><br></pre></td></tr></table></figure><p>经过分析，我们可以使用表 1-1 所示的等价类划分来设计测试用例。</p><table><thead><tr><th>用例</th><th>等价类型</th><th>X</th><th>预期</th></tr></thead><tbody><tr><td>Case 1</td><td>有效等价类</td><td>0&lt;x&lt;2000,x 是整数</td><td>校验通过</td></tr><tr><td>Case 2</td><td>有效等价类</td><td>0&lt;x&lt;2000,x 是两位小数</td><td>校验通过</td></tr><tr><td>Case 3</td><td>有效等价类</td><td>x = 2000</td><td>校验通过</td></tr><tr><td>Case 4</td><td>无效等价类</td><td>x = 0</td><td>提示错误</td></tr><tr><td>Case 5</td><td>无效等价类</td><td>x = -1</td><td>提示错误</td></tr><tr><td>Case 6</td><td>无效等价类</td><td>x=0.001</td><td>提示错误</td></tr><tr><td>Case 7</td><td>无效等价类</td><td>x=张三</td><td>提示错误</td></tr><tr><td>Case 8</td><td>无效等价类</td><td>x=^&amp;*^&amp;</td><td>提示错误</td></tr><tr><td>Case 9</td><td>无效等价类</td><td>x=</td><td>提示错误</td></tr></tbody></table><p><a name="TiZAT"></a></p><h3 id="1-3-2-边界值法">1.3.2 边界值法</h3><p>边界值分析法（Boundary Value Analysis，BVA） 是一种对等价类划分做出有效补充的测试方法。<br />边界值法是建立在业界共识上的，即软件的错误往往出现在输入输出域的边界上，而不是输入输出域的内部，因此在选择测试数据时，边界值比内部的数据更有价值。<br />依然使用前面的例子，程序会对用户的输入值进行检查，检查的条件往往都是基于边界值设定的。伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(input &lt;= 0 || !isANumber(input) || input &gt; 2000)&#123;</span><br><span class="line">  throw new Exception(&quot;input error&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这段代码可以看出，0、2000 都是一个典型的边界值，数字和非数字字符之间也是一个边界，因为在计算机内部数字和非数字字符的编码值不同。<br />使用边界值法选择测试数据时，应当选取刚好等于、刚好大于、刚好小于的值作为输入。<br />边界值分析法有几项固定模式可以参考：</p><ul><li>如果规定了输入数值的范围，可以选择刚好等于、刚好大于、刚好小于的值。</li><li>如果规定输入的是一个集合，可以选择空集合、超出最大值的集合、一个元素的集合。</li><li>使用规则的临界条件。比如，规则 “输入不为空的字符串” 的临界输入是不可见的字符串（空格、制表符等）。<br><a name="Uz1ng"></a></li></ul><h3 id="1-3-3-场景法">1.3.3 场景法</h3><p>前面介绍的几种测试用例的设计方法都是针对单次操作的，软件往往都需要进行多次操作。因此，我们需要测试组合后的操作，通过组合操作来设计测试用例，即为使用场景法。<br />软件的流程控制都是通过事件的触发来完成的。单个事件的测试可以用前面介绍的方法来完成，多个事件则需要根据不同的顺序构建不同的事件流，我们将每个事件触发的情景称为场景。<br />根据事件组合而来的用例，也可以称为复合用例。执行复合用例，可以暴露大量的流程问题，提高测试效果。<br />如图 1-4 所示，场景法一般包含基本流和备选流。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712849903356-678afcdc-b2bb-4963-b23c-08826acde232.png#clientId=ud9ce2bc5-7541-4&amp;from=paste&amp;id=u4debf382&amp;originHeight=652&amp;originWidth=466&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=23999&amp;status=done&amp;style=none&amp;taskId=ubb81d19d-af3a-4417-9f3b-5793e2b4560&amp;title=" alt="image.jpg"><br />图 1-4 用例流示意图<br />图 1-4 中的直线表示基本流，是最简单的测试路径，曲线表示备选流，是在某个特定的条件下所发生的异常行为。<br />备选流可以从基本流的任何节点开始，也可以回退、跳过基本流的节点。<br />使用场景法的基本操作方法如下：<br />1）根据业务规则，画出基本流的所有的节点。<br />2）考虑每一个节点的异常情况，并画出异常节点。<br />3）根据可达性，这些节点构成一个有向的图。<br />4）对这个图进行遍历，设计用例。<br />场景法的注意事项：</p><ul><li>场景的划分和选择比较重要，软件的场景可能比较多，需要从最重要的场景开始选择。</li><li>一个场景中可能有多个用户角色，需要特别注意多个角色交替操作的情况。</li><li>设计场景可以参考开发文档中的用例（Use Case）设计。</li></ul><p>下面是使用场景法设计测试用例的案例。<br />需求说明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一款收银机软件，业务设定为服务员也需要让收银员来操作系统，不记座位模式，使用号牌，收银员可以进行选菜、下单、退菜、打单、结账等操作。后厨可以进行出菜操作。</span><br></pre></td></tr></table></figure><p>如图 1-5 所示，我们可以根据上述需求来设计用例并进行测试，表 1-2 给出了对应的测试用例。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712849904241-f7a21af6-0e35-4f94-bba0-a7852610e82b.png#clientId=ud9ce2bc5-7541-4&amp;from=paste&amp;id=uc8ceba7e&amp;originHeight=650&amp;originWidth=460&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=50395&amp;status=done&amp;style=none&amp;taskId=uba301ce0-c665-4195-84b2-155d59c9094&amp;title=" alt="image.jpg"><br />图 1-5 点餐用例<br />表 1-2 使用用例流设计用例</p><table><thead><tr><th>名称</th><th>步骤</th></tr></thead><tbody><tr><td>基本流</td><td>1. 收银员开始点餐，启动软件后，能加载菜品列表，并显示详情2. 收银员选择菜品，并设定数量、口味等，确认菜品无误后进入下一步3. 收银员收到用户费用后，进入下单打印界面，打印小票给后厨，并打印账单给客户，收银员可以在结账后回到点餐状态，为下一次点餐做准备4. 后厨看到小票开始做菜，出菜后由后厨确认出菜5. 系统接收到确认某个订单的所有出菜信息后，标记订单完成，用于统计和收银员对账</td></tr><tr><td>备选流 1 - 未结账回退</td><td>1. 收银员开始点餐，启动软件后，能加载菜品列表，并显示详情2. 收银员确认菜品无误后，进入下单打印界面3. 收银员可以选择返回上一步，软件记录之前的菜品选择</td></tr><tr><td>备选流 2 - 结账后退菜</td><td>顾客可能点单后选择退菜，软件允许相应的操作1. 完成基本流的前两个步骤2. 从历史订单进入，选择退菜操作，只能选择未出菜的菜品项目</td></tr><tr><td>备选流 3 - 结账后取消订单</td><td>顾客可能点单后选择取消订单，软件允许相应的操作1. 完成基本流的前两个步骤2. 从历史订单进入，选择取消订单操作，只能选择未发生出菜的订单</td></tr></tbody></table><p><a name="qdji3"></a></p><h2 id="1-4-研发人员自测范围">1.4 研发人员自测范围</h2><p>上面介绍的只是测试工作的部分入门或者基础知识，对于研发人员来说，并不需要关注所有的测试工作任务。<br />研发人员需要关注一些和研发相关的测试，降低将代码转测（将开发完成的功能提交给 QA 进行测试）后的缺陷率。降低转测后缺陷率的收益是显而易见的。大公司往往都有这方面的要求，并且和部门绩效相关，缺陷率可以直接用于考核。转测失败或者在高测试环境发现问题，非常不利于调试和解决，尽可能地在开发环境中甚至在本地发现和解决可以大大提高开发效率。<br />不过，哪些质量保证的工作由研发来做，哪些工作由 QA 来做往往争议颇多。最简单的一个方法则就是 ** 白盒测试大部分由研发人员完成，黑盒测试大部分由 QA 来完成，由两者一起对最终质量负责。** 图 1-6 给出了一个开发自测的范围，但是最重要的是需要和团队达成共识。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712849904011-bfb54b36-0324-4975-96a5-6810aac2b124.png#clientId=ud9ce2bc5-7541-4&amp;from=paste&amp;id=ueb689620&amp;originHeight=752&amp;originWidth=1592&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=119847&amp;status=done&amp;style=none&amp;taskId=u95c6445e-7ec3-4504-babd-e06fa59694e&amp;title=" alt="image.jpg"><br />图 1-6 研发人员和测试人员的分工<br />根据测试金字塔的划分方式可知，一般单元测试、集成测试需要研发人员自己完成，并且通常来说，这类测试的自动化测试代码都和业务代码在一个仓库中。这里说说这样划分的考量和经验。<br />单元测试需要大量依赖模拟（Mock），同时需要分析代码的分支结构才能写出有效的测试用例。此外，这部分测试会引用目标代码，它需要和目标代码保持一致的技术栈，而这些只有研发人员自己最熟悉，所以研发人员可以用最高的效率来编写测试。一般来说，合格的研发人员都需要会编写单元测试（这也是一些大厂的必备要求）。<br />集成测试在前面的定义中是指单个模块、服务的测试，进行集成测试往往需要启动应用上下文，这类测试关注的是单个 API 的能力。一般来说，研发人员用 API 为基本粒度交付特性，这类测试保证对外的 API 能力，同时可以验收单个业务质量。在一些 QA 人员相对充足的情况下，可以让 QA 参与，共同完成。<br />除此之外，如果把代码规范扫描、安全扫描的结果也算测试的一部分的话，那么同样需要研发人员关注。不过这类工作，一般是公司 QA 部门统一配置、维护的。<br />一般来说，研发人员的测试工作不仅仅是针对新功能进行测试，持续维护才是最重要的事情，因为随着软件产品走向发展后期，大部分工作都将是维护和改进。<br />值得注意的是，研发人员的自测任务往往不只是在新编写软件的时候加入，在重构、修复缺陷、数据迁移的时候也需要及时增加测试，下面详细说明这几个场景。<br><a name="YdTVm"></a></p><h3 id="1-4-1-新交付的需求">1.4.1 新交付的需求</h3><p>对于新的需求，一般会让 QA 帮忙提前准备好单元测试和集成测试的用例。<br />单元测试可以直接使用 JUnit 这类测试框架，通过模拟依赖实现细致的测试用例，尽量覆盖更多的分支。<br />集成测试可以使用 Spring MockMVC 这类测试框架，通过启动应用来验证 API 的逻辑是否正确。由于集成测试的成本很高，用来编写复杂用例会拖慢开发和测试，因此，测试关键的基本场景即可。<br />在编写单元测试和集成测试时，如果熟悉 TDD（测试驱动开发）也可以直接使用 TDD，先编写测试再编写实现，不过 TDD 有一定的学习成本。这些内容的具体操作在后面的内容中会逐步讲解。<br />测试覆盖率可以将单元测试和集成测试叠加计算，一般集成测试可以快速地跑完一个主要流程，获得大部分的测试覆盖率，然后使用单元测试弥补没有覆盖的分支，进一步获得更高的测试覆盖率。<br><a name="H6DyE"></a></p><h3 id="1-4-2-缺陷处理">1.4.2 缺陷处理</h3><p>如果修复了一个 Bug，那么需要及时更新、补充测试，这一点很重要。目的是为了避免同类问题再次出现，或者在其他的场景中出现。另外，修复 Bug 往往会写一些补丁代码，这类代码其他同事很难理解。补充测试后，可以通过测试的语义来描述这段难以理解的逻辑，和注释相比，测试可以同步更新，如果后期相关代码改错了，测试则无法通过。<br><a name="CrUqC"></a></p><h3 id="1-4-3-重构">1.4.3 重构</h3><p>进行重构时，需要先编写单元测试、API 测试或契约测试，保护原有行为不受破坏。重构的含义是，在业务规则不变的情况下，改造或重新设计代码，提高可维护性和代码质量。<br />因此，重构也是添加测试的重要时机。<br><a name="OFSvT"></a></p><h3 id="1-4-4-数据迁移">1.4.4 数据迁移</h3><p>数据迁移的结果验证是一件比较困难的事情，保证数据迁移的结果正确的方法有两种。<br />一种是不要手动迁移数据，一定要使用脚本，用一些轻量级的 ETL 工具可以完成这类工作。比如，Spring Batch 可以用 Java 写迁移脚本，而且可以给这类脚本编写单元测试。<br />其次是编写简单的代码对结果进行校验。即使迁移脚本通过了单元测试，也有可能在运行时因配置错误造成数据错误，因此可以编写一个简单的校验程序，统计迁移前后的数据，或逐行校验。<br><a name="Yutvw"></a></p><h2 id="1-5-测试数据的构造和安全">1.5 测试数据的构造和安全</h2><p>在软件测试的过程中，测试数据的构造看似是一件小事，但是如果能通过高效的方式操作则可以节省大量的时间。有一些团队会直接使用生产环境的真实数据进行测试，实际上这种做法违反了信息安全和合规的要求，需要特别注意。可以使用相关工具来构造测试数据，这些随机生成的数据，使用起来不仅很高效，还避免了安全和合规风险。<br><a name="uV6tn"></a></p><h3 id="1-5-1-高效测试数据构造">1.5.1 高效测试数据构造</h3><p>下面介绍一些工具和技巧来快速、高效地构造测试数据。<br><a name="XYBqJ"></a></p><h4 id="1-通用文本数据构造">1. 通用文本数据构造</h4><p>可能有读者深有体会，构造测试数据往往能榨干灵感，好在一些常见的测试数据可以通过一些开源工具来实现，比如目前有多种语言的 Faker 库，它使用的是 Python、JavaScript 等脚本语言。JavaScript 的 Faker 版本 faker.js 可以部署并运行在浏览器上，进行在线数据生成。如图 1-7 所示，faker.js 可以随机生成一些用户信息。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712849904094-6347b306-a5b1-489f-ac37-d23eaab896ca.png#clientId=ud9ce2bc5-7541-4&amp;from=paste&amp;id=u35525811&amp;originHeight=1134&amp;originWidth=1438&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=103535&amp;status=done&amp;style=none&amp;taskId=ua85c6a7b-fb38-4cc2-97a2-b2f8ddf33a0&amp;title=" alt="image.jpg"><br />图 1-7 随机构造个人数据<br />在需要的时候也可以将 faker.js 的 npm 包放到前端的代码库中使用。<br><a name="iAaa6"></a></p><h4 id="2-文件构造">2. 文件构造</h4><p>有时候需要构造不同大小的文件来完成测试，可是要找到刚好合适的文件大小和 MIME 类型来满足边界值并不是很容易，事实上，这可以通过网站 <a href="http://fakefilegenerator.com">fakefilegenerator.com</a> 来实现，它可以生成所需类型和大小的文件。<br />提示：MIME 的全称是 Multipurpose Internet Mail Extensions，即多用途互联网邮件扩展类型，在文件的头部标明文件的类型，避免依赖文件后缀来识别文件类型。目前常见的文件类型会在 IANA 机构进行注册进行管理。<br />如果只是想要构造空文件（不介意内容），可以使用命令快速实现，它可以构造任意大小的文件。在 Linux 中， /dev/zero 文件是一个特殊的设备文件，在被读取时会提供无限的空字符。可以通过 dd 命令复制 /dev/zero 文件来构造新的文件。dd 命令的基本用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=&lt;输入文件&gt; of=&lt;输出文件&gt; bs=&lt;复制块大小&gt; count=&lt;复制次数&gt;</span><br></pre></td></tr></table></figure><p>例如，如果需要生成 10 MB 大小的文件，可以使用下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=output.txt bs=1M count=10</span><br></pre></td></tr></table></figure><p>在 Linux 中还有一个 truncate 命令，可以将文件任意缩小或拓展到指定的大小：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo hello &gt; test.txt</span><br><span class="line">truncate -s 1024 test.txt</span><br></pre></td></tr></table></figure><p>提示：在 Mac OS 下要使用 truncate 命令需要单独安装，可以使用 brewinstall truncate 快速安装该命令。<br />在 Windows 中就更简单了，Windows 提供了一个 fsutil 命令可以提供指定文件大小的空文件，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsutil file createnew &lt;输出的文件名&gt; &lt;文件大小（字节）&gt;</span><br></pre></td></tr></table></figure><p><a name="MljUf"></a></p><h4 id="3-图片构造">3. 图片构造</h4><p>当我们需要构造一些特定尺寸的图片时，其实不需要在网上到处寻找。有一些图片占位符网站提供了动态生成图片的服务，通过构造图片链接可以获得合适的图片。<br />例如，在 <a href="http://placeholder.com">placeholder.com</a> 网站上，可以通过构造 URL 来生成满足尺寸、背景、文字等不同需求的图片。如图 1-8 到图 1-11 所示，在 URL 后面设置相关的参数即可构造出想要的图片 。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712849904365-5d02b3b8-d8a9-4118-90d5-a7207b95a184.png#clientId=ud9ce2bc5-7541-4&amp;from=paste&amp;id=u1732bdcc&amp;originHeight=150&amp;originWidth=150&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=373&amp;status=done&amp;style=none&amp;taskId=u7a1f6691-9ba2-40c9-9358-555c9cea39e&amp;title=" alt="image.jpg"><br />图 1-8 构建正方形图片<br />注：图片来源 <a href="https://via.placeholder.com/150%E3%80%82">https://via.placeholder.com/150。</a><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712849904409-b3a8b831-6b0d-4461-bba4-aca2a6cf263f.png#clientId=ud9ce2bc5-7541-4&amp;from=paste&amp;id=uf02bdff4&amp;originHeight=100&amp;originWidth=200&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=555&amp;status=done&amp;style=none&amp;taskId=ua3cbd0d8-3c8b-4f3f-ae11-4263dc34a3a&amp;title=" alt="image.jpg"><br />图 1-9 构建矩形图片<br />注：图片来源 <a href="https://via.placeholder.com/200x100%E3%80%82">https://via.placeholder.com/200x100。</a><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712849904472-d2bd0288-dd06-4247-859a-fe69bdbb58b7.png#clientId=ud9ce2bc5-7541-4&amp;from=paste&amp;id=uad7423bb&amp;originHeight=100&amp;originWidth=200&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=555&amp;status=done&amp;style=none&amp;taskId=u2759d948-11ce-480c-a064-40467910056&amp;title=" alt="image.jpg"><br />图 1-10 修改背景色<br />注：图片来源 <a href="https://via.placeholder.com/200x100/fff%E3%80%82">https://via.placeholder.com/200x100/fff。</a><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712849904533-0ca2fff3-818d-4198-ab19-959f9e98c7db.png#clientId=ud9ce2bc5-7541-4&amp;from=paste&amp;id=u8dbfcd9d&amp;originHeight=100&amp;originWidth=200&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=445&amp;status=done&amp;style=none&amp;taskId=u68a1780e-dc9c-4d4b-be55-e90798cf6aa&amp;title=" alt="image.jpg"><br />图 1-11 增加文字<br />注：图片来源 <a href="https://via.placeholder.com/200x100/fff?text=placeholder%E3%80%82">https://via.placeholder.com/200x100/fff?text=placeholder。</a><br><a name="INf0V"></a></p><h4 id="4-高效文本操作">4. 高效文本操作</h4><p>如果经常需要批量处理数据时，通过批量的文本操作，可以大大节省我们的时间和缩小工作量。支持批量操作的编辑器非常多，这里以 Sublime 为例，说明批量编辑的方法。<br />Sublime 可以使用多光标功能批量进行数据操作，很方便，以下面这段文本为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">逍遥游</span><br><span class="line">齐物论</span><br><span class="line">养生主</span><br><span class="line">人间世</span><br><span class="line">德充符</span><br><span class="line">大宗师</span><br><span class="line">应帝王</span><br></pre></td></tr></table></figure><p>如果需要去除换行，并且增加引号将每个词引用起来，然后放到代码的数组中使用，那么在 Sublime 编辑器中，我们可以先全选，再使用 快捷键 Ctrl + Shift + L，获得每行的光标。然后使用 Ctrl + 左导航键移动光标至行首，接下来就可以自由编辑了。<br />提示：在 Mac OS 系统中，一般 Ctrl 键由 Command 代替。<br />在 Sublime 中还有一个非常有用的选中功能。如果一个文本中出现了多次重复的字符串，那么可以选中其中一个字符串，然后按下 Ctrl + D 键，这样就可以拓展选中下一个相同的字符串，也就可以快速批量编辑选中的重复字符串了。<br />和 Ctrl + D 键相似的一组快捷键是 Alt + F3，选中文本按下快捷键，可以一次性选择文本中出现的所有相同文本，并同时进行编辑。可以使用这种方法快速替换相同的字符串。此外，换行符也可以被选中，可以用于去掉批量换行符。<br><a name="HYBOV"></a></p><h3 id="1-5-2-测试数据的安全">1.5.2 测试数据的安全</h3><p>由于在测试过程中，数据的管理没有生产环境上那么严格，因此可能存在一定的数据安全风险，尤其是在金融、银行、军工等重要领域，因此我们需要注意对测试数据做一些保护和管理，以及了解一些数据保护相关的法律法规。<br><a name="REA0j"></a></p><h4 id="1-信息泄露风险">1. 信息泄露风险</h4><p>有一些团队会直接使用生产上的数据作为测试环境数据，实际上这不是非常好的做法，虽然对于一些棘手的缺陷，需要使用生产环境的数据来重现，但是这不应该作为一种常态化的操作方法。生产数据需要和非生产的环境严格隔离，并且需要采取必要的权限管理措施，比如对测试数据进行脱敏。<br />测试数据脱敏主要有三种方式：删除、置换和漂白。<br />删除是指将测试数据中的部分或者全部敏感信息去除的处理方式，删除后的数据是原来数据的子集；置换是指将敏感数据进行替换或者掩码处理，使用特殊的符号抹掉部分信息；漂白是指通过特定算法将原来的敏感信息进行加工和处理，虽然数据内容变化了，但是特征未变，还是能作为测试数据使用的（比如随机生成一个新的身份证号码）。<br />由于数据脱敏具有特殊性，因此很多公司会通过专门的部门来完成。从实现上来看，数据脱敏又可以分为静态脱敏和动态脱敏。静态脱敏是指需要测试数据时才人工地从数据源获取并处理数据；而动态脱敏可以通过脱敏服务进行数据采集，然后经过脱敏算法加工，再分发给使用方。使用方不仅可以用于测试，也可用于业务侧的数据导出、报送审批、存档等流程。<br><a name="kHehi"></a></p><h4 id="2-信息数据保护法规">2. 信息数据保护法规</h4><p>哪些数据属于敏感信息，以及如何管理呢？一般可以参考的信息是相关法律法规，以及行业相关监管部门的要求。<br />2018 年 5 月 25 日，欧洲联盟出台《通用数据保护条例》用于欧盟内部的数据管理。《中华人民共和国个人信息保护法》是 2021 年 11 月 1 日通过的我国关于个人信息安全的首部法律。《中华人民共和国个人信息保护法》规定了个人信息处理者有义务对个人信息进行分类、加密处理，以及规定了敏感信息的范围和处理规则。<br><a name="HGVM7"></a></p><h2 id="1-6-小结">1.6 小结</h2><p>本章介绍了测试工作的基础知识、测试的基本概念，以及可以用于团队沟通的基本术语。其中，测试金字塔和测试策略的使用需要在团队中达成一致，让团队为最终的质量负责，才能产出高质量的软件产品。<br />对于研发人员来说，测试用例的设计不需要用到过于复杂的技巧。在编写单元测试中，往往只需要使用边界值和等价类划分方法；在编写 API 测试时，可以适当使用场景法的方式。<br />本章的概念较多，这些概念是后续内容的铺垫，从下一章开始本书将逐步介绍更多实践相关的内容。<br />[^1]: Mike Cohn 的经典书籍，中文名称为《Scrum敏捷软件开发》.清华大学出版社, 2010.</p><blockquote><p>来自: <a href="https://java-self-testing.github.io/java-self-testing-book/01-self-testing-fundamentals/">第 1 章 研发自测基础 - 《Java 研发自测》</a></p></blockquote><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;软件测试是一个非常专业的领域，甚至有一些大学也设置了软件测试课程。虽然大多数软件公司都会设置软件测试类的岗位，但是对于一个优秀的研发人员来说，保证软件质量也应该是份内的事情。&lt;br /&gt;研发人员如果从研发的角度关注测试，那么只需要一丁点投入，就可以换取巨大的价值。因为研发人</summary>
      
    
    
    
    <category term="测试" scheme="http://www.bojiboqi.fun/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="spring测试" scheme="http://www.bojiboqi.fun/tags/spring%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>第 2 章 代码评审 - 《Java 研发自测》</title>
    <link href="http://www.bojiboqi.fun/2024/04/22/%E7%AC%AC%202%20%E7%AB%A0%20%E4%BB%A3%E7%A0%81%E8%AF%84%E5%AE%A1%20-%20%E3%80%8AJava%20%E7%A0%94%E5%8F%91%E8%87%AA%E6%B5%8B%E3%80%8B/"/>
    <id>http://www.bojiboqi.fun/2024/04/22/%E7%AC%AC%202%20%E7%AB%A0%20%E4%BB%A3%E7%A0%81%E8%AF%84%E5%AE%A1%20-%20%E3%80%8AJava%20%E7%A0%94%E5%8F%91%E8%87%AA%E6%B5%8B%E3%80%8B/</id>
    <published>2024-04-22T06:29:33.315Z</published>
    <updated>2024-04-22T23:26:57.697Z</updated>
    
    <content type="html"><![CDATA[<p>在软件开发过程中，除了可以从功能角度发现问题以外，还可以通过代码检视发现一些显而易见的问题，做好这部分工作带来的收益甚至比测试人员手动测试还高。<br />在实践中，对代码进行评审可以从如下三个层面把控：</p><ul><li>静态代码分析。</li><li>每日代码评审。</li><li>代码合入请求。</li></ul><p>**静态代码分析 ** 是指在代码提交时使用工具自动扫描，或者在流水线中让构建服务器代为扫描。一般来说，大的公司会有专门的部门采购各种代码分析工具，我们可以从代码风格、潜在的缺陷、合规和安全等方面系统地检查代码中存在的问题。扫描不合格的代码不予发布，避免为产品带来潜在的风险。<br />**每日代码评审 ** 是指团队每日一起评审当日或上一日的代码，一般在下午下班前进行，时间需要控制在 30～60 分钟。每日代码评审除了可以用于提高代码质量以外，也可以用于团队的技术交流和问题沟通，毕竟大家工作在同一个代码仓库里。<br />代码评审一般由人工完成，可使用 Git、GitLab、IntelliJ IDEA 等工具。代码评审作为静态代码分析的补充方法，一般不会涉及已经被静态代码分析所覆盖的内容。<br />**代码合入请求 ** 是指在必要时通过合入请求来合入代码。具体合入方式取决于团队使用的 Git 工作流，一般敏捷团队会使用主干开发的方式。在一个新的迭代开启后，团队会在主干上开发、提交代码，并且会在需要发布的时候创建一个 Release 分支来冻结代码。代码冻结后，如果还有缺陷需要修复，为了保证测试的可靠性，避免多次全量回归，就需要通过合入请求来合入。<br />上述每一个层面都有不同的价值，它们不仅可以合理管理代码质量，还能做到不打扰开发人员的日常工作，不增加额外的负担。<br />本章将围绕这三个层面展开，目标是基于对代码的静态代码分析、人工检查等方法来提高代码质量，涵盖的内容如下：</p><ul><li>静态代码分析。</li><li>人工代码评审的方法和实践。</li><li>Git 工作流。<br><a name="SXtDN"></a></li></ul><h2 id="2-1-常用的静态代码分析工具">2.1 常用的静态代码分析工具</h2><p>一些大的公司都会进行静态代码分析，他们一般会通过一些定制化的工具或者平台来完成此项工作。对于中小团队来说，可以选用下面几种开源的静态代码分析工具。</p><ul><li>Checkstyle，可以用于检查代码风格，例如代码的缩进、每行的最大长度、换行等规范问题。</li><li>ArchUnit，可以用于检查代码的分层关系，避免不合理的代码依赖关系出现，比如循环引用等。</li><li>FindBugs，可以用于检查潜在的缺陷，例如打开的文件没有关闭、潜在的内存泄漏等。</li><li>OWASP Dependency-Check，可以用于检查引入的第三方代码包是否有公开的漏洞等。</li></ul><p>这些工具基本都有 IDE 插件，相关插件的使用比较简单，不需要过多介绍，如果希望将其集成到构建过程中，则需要使用相应的配置。海外的 Java 项目一般使用 Gradle（一种构建工具，与 Maven 类似），国内的 Java 项目则使用 Maven 较多。<br />下面以使用 Maven 为例，介绍一下如何配置这几种静态代码分析工具，并给出各个配置项的含义。本章的代码示例都是 Maven 多模块实现的，这里也推荐使用 IntelliJ IDEA 作为开发工具， 它是业界公认的优秀 Java 开发工具。<br />本节的示例代码可以在 Git 仓库 <a href="https://github.com/java-self-testing/java-self-testing-example">https://github.com/java-self-testing/java-self-testing-example</a> 中下载。<br><a name="rt7uy"></a></p><h3 id="2-1-1-Checkstyle">2.1.1 Checkstyle</h3><p>Checkstyle 是一款 Java 静态代码分析工具，可帮助程序员编写符合编码规范的 Java 代码。它会自动完成检查，能让程序员避免手工做这些琐碎的事情。<br />Checkstyle 自带了 Sun 公司和谷歌公司的 Java 代码风格配置文件，我们可基于此定义适合自己团队的代码规范。可以通过 IDEA 插件、Maven、Gradle 等不同的工具和平台来运行 Checkstyle，如果有错误提示，Checkstyle 会中断构建并提供友好的报告。<br><a name="WeGiv"></a></p><h4 id="1-在-Maven-中使用-Checkstyle">1. 在 Maven 中使用 Checkstyle</h4><p>创建一个 Maven 模块，在 Pom 文件中添加如代码清单 2-1 所示的配置。<br />代码清单 2-1 Checkstyle 中的 Pom 配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-checkstyle-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.1.2&lt;/version&gt;</span><br><span class="line">            &lt;dependencies&gt;</span><br><span class="line">                &lt;!--  Checkstyle plugin 使用的 Checkstyle 库，可以自定义版本  --&gt;</span><br><span class="line">                &lt;dependency&gt;</span><br><span class="line">                    &lt;groupId&gt;com.puppycrawl.tools&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;checkstyle&lt;/artifactId&gt;</span><br><span class="line">                    &lt;version&gt;8.40&lt;/version&gt;</span><br><span class="line">                &lt;/dependency&gt;</span><br><span class="line">            &lt;/dependencies&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                &lt;!--  加入到 maven 的构建生命周期中去  --&gt;</span><br><span class="line">                &lt;execution&gt;</span><br><span class="line">                    &lt;id&gt;checkstyle&lt;/id&gt;</span><br><span class="line">                    &lt;phase&gt;validate&lt;/phase&gt;</span><br><span class="line">                    &lt;goals&gt;</span><br><span class="line">                        &lt;goal&gt;check&lt;/goal&gt;</span><br><span class="line">                    &lt;/goals&gt;</span><br><span class="line">                    &lt;configuration&gt;</span><br><span class="line">                        &lt;failOnViolation&gt;true&lt;/failOnViolation&gt;</span><br><span class="line">                    &lt;/configuration&gt;</span><br><span class="line">                &lt;/execution&gt;</span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>配置完成后，可以直接使用 Maven 命令检查代码风格：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn checkstyle:check</span><br></pre></td></tr></table></figure><p><a name="YHWu7"></a></p><h4 id="2-自定义代码风格检查规则">2. 自定义代码风格检查规则</h4><p>Checkstyle 默认的风格可能会与我们日常开发的习惯不相符，直接使用有可能会导致在日常的开发过程中 IDE 格式化的结果和 Checkstyle 冲突、默认的参数过于苛刻等问题。虽然可以将 Checkstyle 的配置文件导入 IDE 格式化器的相关配置中，但如果有新同事加入，则又需要额外配置。所以，我们一般都会对 Checkstyle 默认的配置文件做一些修改，将其调整为适合自己团队的工作方式，尽量按照 IDE 的默认格式化风格来操作。<br />在 Maven 的 Pom 文件中通过 checkstyle.config.location 属性可以配置一个 XML 文件来定制 Checkstyle 规则，具体参考如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;!--   自定义的配置文件，相对于 Pom 文件的路径     --&gt;</span><br><span class="line">    &lt;checkstyle.config.location&gt;checkstyle/checkstyle.xml&lt;/checkstyle.config.location&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure><p>我们在实际项目中通常都需要定制上述规则，代码清单 2-2 基于 Google Java 代码规则对配置做了调整，并给出了具体说明。<br />代码清单 2-2 自定义 Checkstyle 规则的配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE module PUBLIC</span><br><span class="line">        &quot;-//Checkstyle//DTD Checkstyle Configuration 1.3//EN&quot;</span><br><span class="line">        &quot;https://checkstyle.org/dtds/configuration_1_3.dtd&quot;&gt;</span><br><span class="line">&lt;module name = &quot;Checker&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;charset&quot; value=&quot;UTF-8&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--违规级别，用于提示给构建工具，如果是 error 级别会让构建失败--&gt;</span><br><span class="line">    &lt;property name=&quot;severity&quot; value=&quot;warning&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--扫描的文件类型--&gt;</span><br><span class="line">    &lt;property name=&quot;fileExtensions&quot; value=&quot;java, properties, xml&quot;/&gt;</span><br><span class="line">    &lt;!-- Excludes all &#x27;module-info.java&#x27; files              --&gt;</span><br><span class="line">    &lt;!-- See https://checkstyle.org/config_filefilters.html --&gt;</span><br><span class="line">    &lt;!-- 排除 &#x27;module-info.java&#x27; 模块描述文件 --&gt;</span><br><span class="line">    &lt;module name=&quot;BeforeExecutionExclusionFileFilter&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;fileNamePattern&quot; value=&quot;module\-info\.java$&quot;/&gt;</span><br><span class="line">    &lt;/module&gt;</span><br><span class="line">    &lt;!-- https://checkstyle.org/config_filters.html#SuppressionFilter --&gt;</span><br><span class="line">    &lt;!--定义忽略规则文件位置--&gt;</span><br><span class="line">    &lt;module name=&quot;SuppressionFilter&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;file&quot; value=&quot;$&#123;org.checkstyle.google.suppressionfilter.config&#125;&quot;</span><br><span class="line">                  default=&quot;checkstyle-suppressions.xml&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;optional&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/module&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Checks for whitespace                               --&gt;</span><br><span class="line">    &lt;!-- See http://checkstyle.org/config_whitespace.html --&gt;</span><br><span class="line">    &lt;!--检查文件空白制表字符--&gt;</span><br><span class="line">    &lt;module name=&quot;FileTabCharacter&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;eachLine&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/module&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--检查单行长度，原规则是 100，但是往往不够用，所以会设置长一点--&gt;</span><br><span class="line">    &lt;module name=&quot;LineLength&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;fileExtensions&quot; value=&quot;java&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;max&quot; value=&quot;160&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;ignorePattern&quot; value=&quot;^package.*|^import.*|a href|href|http://|https://|ftp://&quot;/&gt;</span><br><span class="line">    &lt;/module&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--检查 Java 源代码语法树--&gt;</span><br><span class="line">    &lt;module name=&quot;TreeWalker&quot;&gt;</span><br><span class="line">        &lt;!--检查类型和文件名是否匹配，类名和文件名需要对应--&gt;</span><br><span class="line">        &lt;module name=&quot;OuterTypeFilename&quot;/&gt;</span><br><span class="line">        &lt;!--检查不合规的文本，考虑使用特殊转义序列来代替八进制值或 Unicode 值。--&gt;</span><br><span class="line">        &lt;module name=&quot;IllegalTokenText&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot; value=&quot;STRING_LITERAL, CHAR_LITERAL&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;format&quot;</span><br><span class="line">                      value=&quot;\\u00(09|0(a|A)|0(c|C)|0(d|D)|22|27|5(C|c))|\\(0(10|11|12|14|15|42|47)|134)&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;message&quot;</span><br><span class="line">                      value=&quot;Consider using special escape sequence instead of octal value or Unicode escaped value.&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--避免使用 Unicode 转义--&gt;</span><br><span class="line">        &lt;module name=&quot;AvoidEscapedUnicodeCharacters&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;allowEscapesForControlCharacters&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;allowByTailComment&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;allowNonPrintableEscapes&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--避免在 import 语句中使用 * --&gt;</span><br><span class="line">        &lt;module name=&quot;AvoidStarImport&quot;/&gt;</span><br><span class="line">        &lt;!--每个文件中只允许有一个顶级类--&gt;</span><br><span class="line">        &lt;module name=&quot;OneTopLevelClass&quot;/&gt;</span><br><span class="line">        &lt;!--该类语句不允许换行--&gt;</span><br><span class="line">        &lt;module name=&quot;NoLineWrap&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot; value=&quot;PACKAGE_DEF, IMPORT, STATIC_IMPORT&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查空块--&gt;</span><br><span class="line">        &lt;module name=&quot;EmptyBlock&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;option&quot; value=&quot;TEXT&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot;</span><br><span class="line">                      value=&quot;LITERAL_TRY, LITERAL_FINALLY, LITERAL_IF, LITERAL_ELSE, LITERAL_SWITCH&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查代码块周围的大括号，这些大括号不允许省略--&gt;</span><br><span class="line">        &lt;module name=&quot;NeedBraces&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot;</span><br><span class="line">                      value=&quot;LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查代码块的左花括号的位置--&gt;</span><br><span class="line">        &lt;module name=&quot;LeftCurly&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot;</span><br><span class="line">                      value=&quot;ANNOTATION_DEF, CLASS_DEF, CTOR_DEF, ENUM_CONSTANT_DEF, ENUM_DEF,</span><br><span class="line">                    INTERFACE_DEF, LAMBDA, LITERAL_CASE, LITERAL_CATCH, LITERAL_DEFAULT,</span><br><span class="line">                    LITERAL_DO, LITERAL_ELSE, LITERAL_FINALLY, LITERAL_FOR, LITERAL_IF,</span><br><span class="line">                    LITERAL_SWITCH, LITERAL_SYNCHRONIZED, LITERAL_TRY, LITERAL_WHILE, METHOD_DEF,</span><br><span class="line">                    OBJBLOCK, STATIC_INIT, RECORD_DEF, COMPACT_CTOR_DEF&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查代码块的右花括号的位置--&gt;</span><br><span class="line">        &lt;module name=&quot;RightCurly&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;id&quot; value=&quot;RightCurlySame&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot;</span><br><span class="line">                      value=&quot;LITERAL_TRY, LITERAL_CATCH, LITERAL_FINALLY, LITERAL_IF, LITERAL_ELSE,</span><br><span class="line">                    LITERAL_DO&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查代码块的右花括号的位置，必须单独一行--&gt;</span><br><span class="line">        &lt;module name=&quot;RightCurly&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;id&quot; value=&quot;RightCurlyAlone&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;option&quot; value=&quot;alone&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot;</span><br><span class="line">                      value=&quot;CLASS_DEF, METHOD_DEF, CTOR_DEF, LITERAL_FOR, LITERAL_WHILE, STATIC_INIT,</span><br><span class="line">                    INSTANCE_INIT, ANNOTATION_DEF, ENUM_DEF, INTERFACE_DEF, RECORD_DEF,</span><br><span class="line">                    COMPACT_CTOR_DEF&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;module name=&quot;SuppressionXpathSingleFilter&quot;&gt;</span><br><span class="line">            &lt;!-- suppresion is required till https://github.com/checkstyle/checkstyle/issues/7541 --&gt;</span><br><span class="line">            &lt;property name=&quot;id&quot; value=&quot;RightCurlyAlone&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;query&quot; value=&quot;//RCURLY[parent::SLIST[count(./*)=1]</span><br><span class="line">                                     or preceding-sibling::*[last()][self::LCURLY]]&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查关键字后面的空格--&gt;</span><br><span class="line">        &lt;module name=&quot;WhitespaceAfter&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot;</span><br><span class="line">                      value=&quot;COMMA, SEMI, TYPECAST, LITERAL_IF, LITERAL_ELSE,</span><br><span class="line">                    LITERAL_WHILE, LITERAL_DO, LITERAL_FOR, DO_WHILE&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查关键字是否被空格包围，一般是语句，比如空构造函数--&gt;</span><br><span class="line">        &lt;module name=&quot;WhitespaceAround&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;allowEmptyConstructors&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;allowEmptyLambdas&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;allowEmptyMethods&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;allowEmptyTypes&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;allowEmptyLoops&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;ignoreEnhancedForColon&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot;</span><br><span class="line">                      value=&quot;ASSIGN, BAND, BAND_ASSIGN, BOR, BOR_ASSIGN, BSR, BSR_ASSIGN, BXOR,</span><br><span class="line">                    BXOR_ASSIGN, COLON, DIV, DIV_ASSIGN, DO_WHILE, EQUAL, GE, GT, LAMBDA, LAND,</span><br><span class="line">                    LCURLY, LE, LITERAL_CATCH, LITERAL_DO, LITERAL_ELSE, LITERAL_FINALLY,</span><br><span class="line">                    LITERAL_FOR, LITERAL_IF, LITERAL_RETURN, LITERAL_SWITCH, LITERAL_SYNCHRONIZED,</span><br><span class="line">                    LITERAL_TRY, LITERAL_WHILE, LOR, LT, MINUS, MINUS_ASSIGN, MOD, MOD_ASSIGN,</span><br><span class="line">                    NOT_EQUAL, PLUS, PLUS_ASSIGN, QUESTION, RCURLY, SL, SLIST, SL_ASSIGN, SR,</span><br><span class="line">                    SR_ASSIGN, STAR, STAR_ASSIGN, LITERAL_ASSERT, TYPE_EXTENSION_AND&quot;/&gt;</span><br><span class="line">            &lt;message key=&quot;ws.notFollowed&quot;</span><br><span class="line">                     value=&quot;WhitespaceAround: &#x27;&#x27;&#123;0&#125;&#x27;&#x27; is not followed by whitespace. Empty blocks may only be represented as &#x27;&#123;&#125;&#x27; when not part of a multi-block statement (4.1.3)&quot;/&gt;</span><br><span class="line">            &lt;message key=&quot;ws.notPreceded&quot;</span><br><span class="line">                     value=&quot;WhitespaceAround: &#x27;&#x27;&#123;0&#125;&#x27;&#x27; is not preceded with whitespace.&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查每行只有一个语句--&gt;</span><br><span class="line">        &lt;module name=&quot;OneStatementPerLine&quot;/&gt;</span><br><span class="line">        &lt;!--避免变量连续定义和换行定义，每个变量都需要在自己的行中单独定义--&gt;</span><br><span class="line">        &lt;module name=&quot;MultipleVariableDeclarations&quot;/&gt;</span><br><span class="line">        &lt;!--检查数组类型定义的风格--&gt;</span><br><span class="line">        &lt;module name=&quot;ArrayTypeStyle&quot;/&gt;</span><br><span class="line">        &lt;!--检查 switch 必须具有 default 子句--&gt;</span><br><span class="line">        &lt;module name=&quot;MissingSwitchDefault&quot;/&gt;</span><br><span class="line">        &lt;!--检查 switch 语句，case 子句如果有代码，必须使用 break 语句或抛出异常--&gt;</span><br><span class="line">        &lt;module name=&quot;FallThrough&quot;/&gt;</span><br><span class="line">        &lt;!--检查常量是否用大写定义--&gt;</span><br><span class="line">        &lt;module name=&quot;UpperEll&quot;/&gt;</span><br><span class="line">        &lt;!--检查修饰符是否符合顺序--&gt;</span><br><span class="line">        &lt;module name=&quot;ModifierOrder&quot;/&gt;</span><br><span class="line">        &lt;!--检查空行，在必要的地方需要空行--&gt;</span><br><span class="line">        &lt;module name=&quot;EmptyLineSeparator&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot;</span><br><span class="line">                      value=&quot;PACKAGE_DEF, IMPORT, STATIC_IMPORT, CLASS_DEF, INTERFACE_DEF, ENUM_DEF,</span><br><span class="line">                    STATIC_INIT, INSTANCE_INIT, METHOD_DEF, CTOR_DEF, VARIABLE_DEF, RECORD_DEF,</span><br><span class="line">                    COMPACT_CTOR_DEF&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;allowNoEmptyLineBetweenFields&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--定义一些不允许换行的关键字，比如点、逗号等--&gt;</span><br><span class="line">        &lt;module name=&quot;SeparatorWrap&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;id&quot; value=&quot;SeparatorWrapDot&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot; value=&quot;DOT&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;option&quot; value=&quot;nl&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;module name=&quot;SeparatorWrap&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;id&quot; value=&quot;SeparatorWrapComma&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot; value=&quot;COMMA&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;option&quot; value=&quot;EOL&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;module name=&quot;SeparatorWrap&quot;&gt;</span><br><span class="line">            &lt;!-- ELLIPSIS is EOL until https://github.com/google/styleguide/issues/259 --&gt;</span><br><span class="line">            &lt;property name=&quot;id&quot; value=&quot;SeparatorWrapEllipsis&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot; value=&quot;ELLIPSIS&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;option&quot; value=&quot;EOL&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;module name=&quot;SeparatorWrap&quot;&gt;</span><br><span class="line">            &lt;!-- ARRAY_DECLARATOR is EOL until https://github.com/google/styleguide/issues/258 --&gt;</span><br><span class="line">            &lt;property name=&quot;id&quot; value=&quot;SeparatorWrapArrayDeclarator&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot; value=&quot;ARRAY_DECLARATOR&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;option&quot; value=&quot;EOL&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;module name=&quot;SeparatorWrap&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;id&quot; value=&quot;SeparatorWrapMethodRef&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot; value=&quot;METHOD_REF&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;option&quot; value=&quot;nl&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查包名称是否符合规则--&gt;</span><br><span class="line">        &lt;module name=&quot;PackageName&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;format&quot; value=&quot;^[a-z]+(\.[a-z][a-z0-9]*)*$&quot;/&gt;</span><br><span class="line">            &lt;message key=&quot;name.invalidPattern&quot;</span><br><span class="line">                     value=&quot;Package name &#x27;&#x27;&#123;0&#125;&#x27;&#x27; must match pattern &#x27;&#x27;&#123;1&#125;&#x27;&#x27;.&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查类型名称是否符合规则--&gt;</span><br><span class="line">        &lt;module name=&quot;TypeName&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot; value=&quot;CLASS_DEF, INTERFACE_DEF, ENUM_DEF,</span><br><span class="line">                    ANNOTATION_DEF, RECORD_DEF&quot;/&gt;</span><br><span class="line">            &lt;message key=&quot;name.invalidPattern&quot;</span><br><span class="line">                     value=&quot;Type name &#x27;&#x27;&#123;0&#125;&#x27;&#x27; must match pattern &#x27;&#x27;&#123;1&#125;&#x27;&#x27;.&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查实例成员变量是否符合规则--&gt;</span><br><span class="line">        &lt;module name=&quot;MemberName&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;format&quot; value=&quot;^[a-z][a-z0-9][a-zA-Z0-9]*$&quot;/&gt;</span><br><span class="line">            &lt;message key=&quot;name.invalidPattern&quot;</span><br><span class="line">                     value=&quot;Member name &#x27;&#x27;&#123;0&#125;&#x27;&#x27; must match pattern &#x27;&#x27;&#123;1&#125;&#x27;&#x27;.&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查参数名称是否符合规则--&gt;</span><br><span class="line">        &lt;module name=&quot;ParameterName&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;format&quot; value=&quot;^[a-z]([a-z0-9][a-zA-Z0-9]*)?$&quot;/&gt;</span><br><span class="line">            &lt;message key=&quot;name.invalidPattern&quot;</span><br><span class="line">                     value=&quot;Parameter name &#x27;&#x27;&#123;0&#125;&#x27;&#x27; must match pattern &#x27;&#x27;&#123;1&#125;&#x27;&#x27;.&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查 Lambda 名称是否符合规则--&gt;</span><br><span class="line">        &lt;module name=&quot;LambdaParameterName&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;format&quot; value=&quot;^[a-z]([a-z0-9][a-zA-Z0-9]*)?$&quot;/&gt;</span><br><span class="line">            &lt;message key=&quot;name.invalidPattern&quot;</span><br><span class="line">                     value=&quot;Lambda parameter name &#x27;&#x27;&#123;0&#125;&#x27;&#x27; must match pattern &#x27;&#x27;&#123;1&#125;&#x27;&#x27;.&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查 catch 参数名称是否符合规则--&gt;</span><br><span class="line">        &lt;module name=&quot;CatchParameterName&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;format&quot; value=&quot;^[a-z]([a-z0-9][a-zA-Z0-9]*)?$&quot;/&gt;</span><br><span class="line">            &lt;message key=&quot;name.invalidPattern&quot;</span><br><span class="line">                     value=&quot;Catch parameter name &#x27;&#x27;&#123;0&#125;&#x27;&#x27; must match pattern &#x27;&#x27;&#123;1&#125;&#x27;&#x27;.&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查本地变量名称是否符合规则--&gt;</span><br><span class="line">        &lt;module name=&quot;LocalVariableName&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;format&quot; value=&quot;^[a-z]([a-z0-9][a-zA-Z0-9]*)?$&quot;/&gt;</span><br><span class="line">            &lt;message key=&quot;name.invalidPattern&quot;</span><br><span class="line">                     value=&quot;Local variable name &#x27;&#x27;&#123;0&#125;&#x27;&#x27; must match pattern &#x27;&#x27;&#123;1&#125;&#x27;&#x27;.&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;module name=&quot;PatternVariableName&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;format&quot; value=&quot;^[a-z]([a-z0-9][a-zA-Z0-9]*)?$&quot;/&gt;</span><br><span class="line">            &lt;message key=&quot;name.invalidPattern&quot;</span><br><span class="line">                     value=&quot;Pattern variable name &#x27;&#x27;&#123;0&#125;&#x27;&#x27; must match pattern &#x27;&#x27;&#123;1&#125;&#x27;&#x27;.&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查类类型参数(泛型)名称是否符合规则--&gt;</span><br><span class="line">        &lt;module name=&quot;ClassTypeParameterName&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;format&quot; value=&quot;(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)&quot;/&gt;</span><br><span class="line">            &lt;message key=&quot;name.invalidPattern&quot;</span><br><span class="line">                     value=&quot;Class type name &#x27;&#x27;&#123;0&#125;&#x27;&#x27; must match pattern &#x27;&#x27;&#123;1&#125;&#x27;&#x27;.&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查字段（record 为 Java 新特性）名称是否符合规则--&gt;</span><br><span class="line">        &lt;module name=&quot;RecordComponentName&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;format&quot; value=&quot;^[a-z]([a-z0-9][a-zA-Z0-9]*)?$&quot;/&gt;</span><br><span class="line">            &lt;message key=&quot;name.invalidPattern&quot;</span><br><span class="line">                     value=&quot;Record component name &#x27;&#x27;&#123;0&#125;&#x27;&#x27; must match pattern &#x27;&#x27;&#123;1&#125;&#x27;&#x27;.&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查字段（record 为 Java 新特性）类型名称是否符合规则--&gt;</span><br><span class="line">        &lt;module name=&quot;RecordTypeParameterName&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;format&quot; value=&quot;(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)&quot;/&gt;</span><br><span class="line">            &lt;message key=&quot;name.invalidPattern&quot;</span><br><span class="line">                     value=&quot;Record type name &#x27;&#x27;&#123;0&#125;&#x27;&#x27; must match pattern &#x27;&#x27;&#123;1&#125;&#x27;&#x27;.&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查方法类型参数名称是否符合规则--&gt;</span><br><span class="line">        &lt;module name=&quot;MethodTypeParameterName&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;format&quot; value=&quot;(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)&quot;/&gt;</span><br><span class="line">            &lt;message key=&quot;name.invalidPattern&quot;</span><br><span class="line">                     value=&quot;Method type name &#x27;&#x27;&#123;0&#125;&#x27;&#x27; must match pattern &#x27;&#x27;&#123;1&#125;&#x27;&#x27;.&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查接口类型参数名称是否符合规则--&gt;</span><br><span class="line">        &lt;module name=&quot;InterfaceTypeParameterName&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;format&quot; value=&quot;(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)&quot;/&gt;</span><br><span class="line">            &lt;message key=&quot;name.invalidPattern&quot;</span><br><span class="line">                     value=&quot;Interface type name &#x27;&#x27;&#123;0&#125;&#x27;&#x27; must match pattern &#x27;&#x27;&#123;1&#125;&#x27;&#x27;.&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--不允许定义无参的 finalize 方法--&gt;</span><br><span class="line">        &lt;module name=&quot;NoFinalizer&quot;/&gt;</span><br><span class="line">        &lt;!--检查尖括号的空白字符规则--&gt;</span><br><span class="line">        &lt;module name=&quot;GenericWhitespace&quot;&gt;</span><br><span class="line">            &lt;message key=&quot;ws.followed&quot;</span><br><span class="line">                     value=&quot;GenericWhitespace &#x27;&#x27;&#123;0&#125;&#x27;&#x27; is followed by whitespace.&quot;/&gt;</span><br><span class="line">            &lt;message key=&quot;ws.preceded&quot;</span><br><span class="line">                     value=&quot;GenericWhitespace &#x27;&#x27;&#123;0&#125;&#x27;&#x27; is preceded with whitespace.&quot;/&gt;</span><br><span class="line">            &lt;message key=&quot;ws.illegalFollow&quot;</span><br><span class="line">                     value=&quot;GenericWhitespace &#x27;&#x27;&#123;0&#125;&#x27;&#x27; should followed by whitespace.&quot;/&gt;</span><br><span class="line">            &lt;message key=&quot;ws.notPreceded&quot;</span><br><span class="line">                     value=&quot;GenericWhitespace &#x27;&#x27;&#123;0&#125;&#x27;&#x27; is not preceded with whitespace.&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查缩进规则--&gt;</span><br><span class="line">        &lt;module name=&quot;Indentation&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;basicOffset&quot; value=&quot;2&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;braceAdjustment&quot; value=&quot;2&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;caseIndent&quot; value=&quot;2&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;throwsIndent&quot; value=&quot;4&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;lineWrappingIndentation&quot; value=&quot;4&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;arrayInitIndent&quot; value=&quot;2&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查是否以大写字母作为缩写的长度--&gt;</span><br><span class="line">        &lt;module name=&quot;AbbreviationAsWordInName&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;ignoreFinal&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;allowedAbbreviationLength&quot; value=&quot;0&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot;</span><br><span class="line">                      value=&quot;CLASS_DEF, INTERFACE_DEF, ENUM_DEF, ANNOTATION_DEF, ANNOTATION_FIELD_DEF,</span><br><span class="line">                    PARAMETER_DEF, VARIABLE_DEF, METHOD_DEF, PATTERN_VARIABLE_DEF, RECORD_DEF,</span><br><span class="line">                    RECORD_COMPONENT_DEF&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查覆写方法在类中的顺序--&gt;</span><br><span class="line">        &lt;module name=&quot;OverloadMethodsDeclarationOrder&quot;/&gt;</span><br><span class="line">        &lt;!--检查变量声明与第一被使用之间的距离--&gt;</span><br><span class="line">        &lt;module name=&quot;VariableDeclarationUsageDistance&quot;/&gt;</span><br><span class="line">        &lt;!--检查 import 语句的顺序--&gt;</span><br><span class="line">        &lt;module name=&quot;CustomImportOrder&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;sortImportsInGroupAlphabetically&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;separateLineBetweenGroups&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;customImportOrderRules&quot; value=&quot;STATIC###THIRD_PARTY_PACKAGE&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot; value=&quot;IMPORT, STATIC_IMPORT, PACKAGE_DEF&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--检查方法名称和左括号之间的空格--&gt;</span><br><span class="line">        &lt;module name=&quot;MethodParamPad&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot;</span><br><span class="line">                      value=&quot;CTOR_DEF, LITERAL_NEW, METHOD_CALL, METHOD_DEF,</span><br><span class="line">                    SUPER_CTOR_CALL, ENUM_CONSTANT_DEF, RECORD_DEF&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查关键字前面的空格--&gt;</span><br><span class="line">        &lt;module name=&quot;NoWhitespaceBefore&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot;</span><br><span class="line">                      value=&quot;COMMA, SEMI, POST_INC, POST_DEC, DOT,</span><br><span class="line">                    LABELED_STAT, METHOD_REF&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;allowLineBreaks&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查括号前后是否需要空格--&gt;</span><br><span class="line">        &lt;module name=&quot;ParenPad&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot;</span><br><span class="line">                      value=&quot;ANNOTATION, ANNOTATION_FIELD_DEF, CTOR_CALL, CTOR_DEF, DOT, ENUM_CONSTANT_DEF,</span><br><span class="line">                    EXPR, LITERAL_CATCH, LITERAL_DO, LITERAL_FOR, LITERAL_IF, LITERAL_NEW,</span><br><span class="line">                    LITERAL_SWITCH, LITERAL_SYNCHRONIZED, LITERAL_WHILE, METHOD_CALL,</span><br><span class="line">                    METHOD_DEF, QUESTION, RESOURCE_SPECIFICATION, SUPER_CTOR_CALL, LAMBDA,</span><br><span class="line">                    RECORD_DEF&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查运算符换行的规则--&gt;</span><br><span class="line">        &lt;module name=&quot;OperatorWrap&quot;&gt;</span><br><span class="line">            &lt;!-- 操作符需要在新行--&gt;</span><br><span class="line">            &lt;property name=&quot;option&quot; value=&quot;NL&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot;</span><br><span class="line">                      value=&quot;BAND, BOR, BSR, BXOR, DIV, EQUAL, GE, GT, LAND, LE, LITERAL_INSTANCEOF, LOR,</span><br><span class="line">                    LT, MINUS, MOD, NOT_EQUAL, PLUS, QUESTION, SL, SR, STAR, METHOD_REF &quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查注解位置规则，比如类的定义中注释需要单独一行--&gt;</span><br><span class="line">        &lt;module name=&quot;AnnotationLocation&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;id&quot; value=&quot;AnnotationLocationMostCases&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot;</span><br><span class="line">                      value=&quot;CLASS_DEF, INTERFACE_DEF, ENUM_DEF, METHOD_DEF, CTOR_DEF,</span><br><span class="line">                      RECORD_DEF, COMPACT_CTOR_DEF&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查注解位置规则，变量定义注释可以一行定义多个--&gt;</span><br><span class="line">        &lt;module name=&quot;AnnotationLocation&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;id&quot; value=&quot;AnnotationLocationVariables&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot; value=&quot;VARIABLE_DEF&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;allowSamelineMultipleAnnotations&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--这部分是注释相关的配置--&gt;</span><br><span class="line">        &lt;!--块注释中 @ 子句后面不能为空--&gt;</span><br><span class="line">        &lt;module name=&quot;NonEmptyAtclauseDescription&quot;/&gt;</span><br><span class="line">        &lt;!--检查注释位置，块注释必须在所有注解前面--&gt;</span><br><span class="line">        &lt;module name=&quot;InvalidJavadocPosition&quot;/&gt;</span><br><span class="line">        &lt;!--检查注释必须统一缩进--&gt;</span><br><span class="line">        &lt;module name=&quot;JavadocTagContinuationIndentation&quot;/&gt;</span><br><span class="line">        &lt;!--检查描述性注释，方法的块注释第一行必须总结这个方法，一般我们不要求，会关闭此行--&gt;</span><br><span class="line">&lt;!--        &lt;module name=&quot;SummaryJavadoc&quot;&gt;--&gt;</span><br><span class="line">&lt;!--            &lt;property name=&quot;forbiddenSummaryFragments&quot;--&gt;</span><br><span class="line">&lt;!--                      value=&quot;^@return the *|^This method returns |^A [&#123;]@code [a-zA-Z0-9]+[&#125;]( is a )&quot;/&gt;--&gt;</span><br><span class="line">&lt;!--        &lt;/module&gt;--&gt;</span><br><span class="line">        &lt;!--检查注释段落，段落之间需要换行，另外使用了 &lt;p&gt; 标签不能有空格--&gt;</span><br><span class="line">        &lt;module name=&quot;JavadocParagraph&quot;/&gt;</span><br><span class="line">        &lt;!--检查注释段落，块标签之前需要一个空格，比如 @return --&gt;</span><br><span class="line">        &lt;module name=&quot;RequireEmptyLineBeforeBlockTagGroup&quot;/&gt;</span><br><span class="line">        &lt;!--检查注释段落块标签顺序 --&gt;</span><br><span class="line">        &lt;module name=&quot;AtclauseOrder&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;tagOrder&quot; value=&quot;@param, @return, @throws, @deprecated&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;target&quot;</span><br><span class="line">                      value=&quot;CLASS_DEF, INTERFACE_DEF, ENUM_DEF, METHOD_DEF, CTOR_DEF, VARIABLE_DEF&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查 public 方法的注释规则 --&gt;</span><br><span class="line">        &lt;module name=&quot;JavadocMethod&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;scope&quot; value=&quot;public&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;allowMissingParamTags&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;allowMissingReturnTag&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;allowedAnnotations&quot; value=&quot;Override, Test&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot; value=&quot;METHOD_DEF, CTOR_DEF, ANNOTATION_FIELD_DEF, COMPACT_CTOR_DEF&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--对于一些方法可以忽略方法的注释规则。例如，带有Override 注解的方法--&gt;</span><br><span class="line">        &lt;module name=&quot;MissingJavadocMethod&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;scope&quot; value=&quot;public&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;minLineCount&quot; value=&quot;2&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;allowedAnnotations&quot; value=&quot;Override, Test&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot; value=&quot;METHOD_DEF, CTOR_DEF, ANNOTATION_FIELD_DEF,</span><br><span class="line">                                   COMPACT_CTOR_DEF&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查方法必须提供注释的规则 --&gt;</span><br><span class="line">        &lt;module name=&quot;MissingJavadocType&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;scope&quot; value=&quot;protected&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot;</span><br><span class="line">                      value=&quot;CLASS_DEF, INTERFACE_DEF, ENUM_DEF,</span><br><span class="line">                      RECORD_DEF, ANNOTATION_DEF&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;excludeScope&quot; value=&quot;nothing&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查方法名是否符合规则 --&gt;</span><br><span class="line">        &lt;module name=&quot;MethodName&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;format&quot; value=&quot;^[a-z][a-z0-9][a-zA-Z0-9_]*$&quot;/&gt;</span><br><span class="line">            &lt;message key=&quot;name.invalidPattern&quot;</span><br><span class="line">                     value=&quot;Method name &#x27;&#x27;&#123;0&#125;&#x27;&#x27; must match pattern &#x27;&#x27;&#123;1&#125;&#x27;&#x27;.&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--单行注释规则,单行注释不允许使用块中的标签 --&gt;</span><br><span class="line">        &lt;module name=&quot;SingleLineJavadoc&quot;/&gt;</span><br><span class="line">        &lt;!--检查空的 catch 块--&gt;</span><br><span class="line">        &lt;module name=&quot;EmptyCatchBlock&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;exceptionVariableName&quot; value=&quot;expected&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!--检查注释代码之间的缩进--&gt;</span><br><span class="line">        &lt;module name=&quot;CommentsIndentation&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;tokens&quot; value=&quot;SINGLE_LINE_COMMENT, BLOCK_COMMENT_BEGIN&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;!-- https://checkstyle.org/config_filters.html#SuppressionXpathFilter --&gt;</span><br><span class="line">        &lt;module name=&quot;SuppressionXpathFilter&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;file&quot; value=&quot;$&#123;org.checkstyle.google.suppressionxpathfilter.config&#125;&quot;</span><br><span class="line">                      default=&quot;checkstyle-xpath-suppressions.xml&quot; /&gt;</span><br><span class="line">            &lt;property name=&quot;optional&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">    &lt;/module&gt;</span><br><span class="line">&lt;/module&gt;</span><br></pre></td></tr></table></figure><p><a name="lmZh2"></a></p><h3 id="2-1-2-FindBugs">2.1.2 FindBugs</h3><p>FindBugs 是一个开源工具，可用于对 Java 代码执行静态代码分析，其由马里兰大学 Bill Pugh 领导的团队研发，实现原理是对字节码进行扫描并进行模式识别。和 Checkstyle 不一样的是，FindBugs 会通过对代码的模式进行分析来发现潜在的 Bug 和安全问题，而 Checkstyle 只能作为检查代码风格的工具。虽然 FindBugs 和 Checkstyle 的部分功能重叠，但两者的定位明显不同。<br />FindBugs 中包含下面几种问题类型。</p><ul><li>Correctness：由开发人员疏忽造成的正确性问题，比如无限递归调用。</li><li>Bad practice：代码中的一些坏习惯，比如使用 == 对 String 做判定。</li><li>Dodgy code：糟糕的代码，能工作但不是好的实现，比如冗余的流程控制。</li><li>Multithreaded Correctness：多线程和并发问题。</li><li>Malicious Code Vulnerability：恶意代码漏洞。</li><li>Security：安全问题。</li><li>Experimental：经验性问题。</li><li>Internationalization：国际化问题。</li></ul><p>静态代码分析在一些公司的研发过程中是非常重要的环节，通常用于提交代码后的第一轮检查，如果存在问题，就不会走后面的发布流程。可见，静态代码分析是质量门禁的一部分。<br />在日常工作中，使用 FindBugs 检查并修复代码问题对个人技能的提升也有一定的帮助，能驱使开发者在编写代码时有意识地规避一些潜在的问题。<br />FindBugs 有两种常用的使用方式，使用 IntelliJ IDEA 的插件做本地分析，或者作为 Maven、Gradle 的任务在构建过程中运行。<br><a name="wV5Cq"></a></p><h4 id="1-使用-IntelliJ-IDEA-的插件-FindBugs">1. 使用 IntelliJ IDEA 的插件 FindBugs</h4><p>FindBugs 插件在 IntelliJ IDEA 早期的版本中是独立提供的，后来需要先安装 QAPlug 这个静态代码分析工具，并作为 QAPlug 的一个模块提供。<br />QAPlug 提供了代码分析和扫描的功能，并且能集成 PMD 等诸多模块。不过，使用它们需要同时安装 QAPlug 和 FindBugs 这两个插件，并且要在安装后重启。<br />通过 IDEA 首选项的插件市场即可安装 QAPlug 和 FindBugs，如图 2-1 所示。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712849919160-207df0e4-84cf-4f99-b001-8a98d59fe0a9.png#clientId=u2f715dd5-4179-4&amp;from=paste&amp;id=u60ab6187&amp;originHeight=987&amp;originWidth=1363&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=148630&amp;status=done&amp;style=none&amp;taskId=u6092c47a-9d99-4bd5-893e-96953cf1415&amp;title=" alt="image.jpg"><br />图 2-1 插件安装<br />这两个插件的使用方法比较简单，参考图 2-2，直接在需要扫描的目录或者模块上点击右键，就会弹出代码分析菜单。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712849921704-37fa35f7-c2df-4640-a89f-0de063e8aa49.png#clientId=u2f715dd5-4179-4&amp;from=paste&amp;id=u85d2da1e&amp;originHeight=786&amp;originWidth=1363&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=383961&amp;status=done&amp;style=none&amp;taskId=u2c829e6d-5ca7-42fe-b8ae-409be2a418c&amp;title=" alt="image.jpg"><br />图 2-2 代码分析<br />分析完成后，在底部面板中会弹出分析结果，如图 2-3 所示。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712849918419-4757ead8-6b29-4df4-b743-3a0256b041fd.png#clientId=u2f715dd5-4179-4&amp;from=paste&amp;id=ua1bf36a4&amp;originHeight=381&amp;originWidth=1363&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=84088&amp;status=done&amp;style=none&amp;taskId=u34eae31d-23c9-4ee3-b316-3026a9a0b6e&amp;title=" alt="image.jpg"><br />图 2-3 分析结果<br />从图 2-3 可以看出，这里扫描出代码中存在一个问题，即在某一个方法中使用了浮点类型做数学运算，存在潜在的精度问题。<br><a name="veXlu"></a></p><h4 id="2-在-Maven-中使用-FindBugs">2. 在 Maven 中使用 FindBugs</h4><p>想要在构建过程中使用 FindBugs（如果存在问题可以让构建失败），可以使用 Maven 的插件来运行。<br />创建 Maven 项目后，在 Pom 文件的 build 块中添加 Maven 插件即可开启 FindBugs 功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;findbugs-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.0.4&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;effort&gt;Max&lt;/effort&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;check&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><p>在 configuration 属性的配置中，effort 参数比较常用，其含义是使用不同程度的算力进行分析。Effort 参数有 max 和 min 这两个值，使用 max 意味着需要花费更多的内存和时间来找出更多的缺陷；使用 min 则会关闭一些需要花费更多时间和内存的分析项。如果发现运行过程中耗时严重，可以调整这个值。<br />其他参数及其配置方式可以参考 FindBugs 和 FindBugs Maven 插件的相关文档。<br><a name="p30Zs"></a></p><h4 id="3-FindBugs-的高频错误集合">3. FindBugs 的高频错误集合</h4><p>在示例项目中，可能有读者已经找到了 FindBugs 模块，这个模块中提供了一些典型的问题，这些问题在日常修复 FindBugs 时出现的频率较高。即便你不使用 FindBugs，也需要了解这些常见的问题模式，虽然这些问题 IDE 往往也都会提示。<br />**精度问题 **<br />由于计算机通过二进制无法完全表达某些小数，因此会对精度进行取舍，故而我们在使用小数进行数学运算时需要注意精度问题。示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static void mathCalculate() &#123;</span><br><span class="line">    double number1 = 0.1;</span><br><span class="line">    double number2 = 0.2;</span><br><span class="line">    double number3 = 0.3;</span><br><span class="line">    if (number1 + number2 == number3) &#123;</span><br><span class="line">        System.out.println(&quot;精度问题示例&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**无限递归调用 **<br />递归程序需要设定基本的结束条件，否则会一直运行下去，直到栈溢出。示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String name() &#123;</span><br><span class="line">        return name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person testPerson = new Person(&quot;test&quot;);</span><br><span class="line">testPerson.name();</span><br></pre></td></tr></table></figure><p>**空指针问题 **<br />Java 是完全面向对象的语言，因此我们在使用对象中的成员时需要注意对象是否存在。示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static void nullIssue() &#123;</span><br><span class="line">    String test = null;</span><br><span class="line">    if (test != null || test.length() &gt; 0) &#123;</span><br><span class="line">        System.out.println(&quot;空指针异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (test == null &amp;&amp; test.length() &gt; 0) &#123;</span><br><span class="line">        System.out.println(&quot;相反的情况，导致空指针异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**潜在死锁问题 **<br />synchronized 是对象排他锁，而字符串的字面量是整个 JVM 共享的，因此容易造成死锁，我们往往也容易疏忽。示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static final String lockField = &quot;LOCK_PLACE_HOLDER&quot;;</span><br><span class="line">private static void deadLock() &#123;</span><br><span class="line">    synchronized (lockField) &#123;</span><br><span class="line">        System.out.println(&quot;死锁问题&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态的死锁比较难扫描出来，在后面的内容中会专门讨论这个话题。<br />**忘记使用 throw 语句抛出异常 **<br />异常被创建后不使用 throw 语句抛出，编译器并不会报错，但是应该抛出的异常没有被抛出，则可能存在潜在的业务逻辑问题。示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static void noThrow() &#123;</span><br><span class="line">    boolean condition = false;</span><br><span class="line">    if (condition) &#123;</span><br><span class="line">        // 忘记 throw 一个异常，仅仅创建了</span><br><span class="line">        new RuntimeException(&quot;Dissatisfied condition&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**相等判定问题 **<br />对象是否相等需要根据具体的逻辑来判断，像基本类型一样简单根据运算符 == 来进行判定并不可靠。示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static void equalsString() &#123;</span><br><span class="line">    String sting1 = &quot;test&quot;;</span><br><span class="line">    String sting2 = &quot;test&quot;;</span><br><span class="line"></span><br><span class="line">    if (sting1 == sting2) &#123;</span><br><span class="line">        System.out.println(&quot;不安全的相等判定&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**字符串循环拼接 **<br />字符串是不可变对象，采用字符串循环拼接方式会导致代码性能低下，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static void stringConcat() &#123;</span><br><span class="line">    String sting = &quot;test&quot;;</span><br><span class="line">    // 应该使用 String Builder</span><br><span class="line">    for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">        sting += sting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**忘记使用返回值 **<br />在一些方法中，方法不会对参数本身做修改，因此需要接收返回值实现业务逻辑，这部分往往会出现 Bug，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static void forgotReturnValue() &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;hello&quot;);</span><br><span class="line">    // map 需要使用返回值</span><br><span class="line">    list.stream().map(String::toUpperCase);</span><br><span class="line">    String hello = &quot;hello  &quot;;</span><br><span class="line">    // 字符串操作也需要返回值</span><br><span class="line">    hello.trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**数组不使用迭代器删除元素 **<br />如果数组不使用迭代器删除元素，而是直接在 for 循环中删除，那么会触发 Concurrent-ModificationException，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static void arrayListRemoveException() &#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // 直接在 for 循环中删除了元素</span><br><span class="line">    for (String item : list) &#123;</span><br><span class="line">        list.remove(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**资源忘记关闭 **<br />Java 的垃圾回收器只负责处理内存回收，字节流、网络、文件、进程等相关资源都需要手动关闭。比如下面的字节流：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static void forgotCloseStream() &#123;</span><br><span class="line">    ByteArrayOutputStream out = new ByteArrayOutputStream();</span><br><span class="line">    ObjectOutputStream s = null;</span><br><span class="line">    // 需要关闭流</span><br><span class="line">    try &#123;</span><br><span class="line">        s = new ObjectOutputStream(out);</span><br><span class="line">        s.writeObject(1);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**数据截断 **<br />强制类型转换也会存在潜在的 Bug，它会导致数据被截断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static void objectCastIssue() &#123;</span><br><span class="line">    long number = 1000L;</span><br><span class="line">    // 数据会被截断</span><br><span class="line">    int number2 = (int) number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些问题都非常常见，通过 FindBugs 基本都可以找出来，如此一来，即可有效地减少代码评审的压力。<br><a name="jAvQ9"></a></p><h3 id="2-1-3-ArchUnit">2.1.3 ArchUnit</h3><p>通过 Checkstyle 解决了代码的风格问题，又使用 FindBugs 解决了基本的代码质量问题，现在还需要解决开发过程中的架构规范问题。<br />有足够经验的开发者都知道，软件项目和架构极其容易腐化。如果没有很好地管控，无论是采用 MVC 的三层架构还是 DDD 的四层架构，代码的结构都会在几个月内变得混乱不堪。<br />我曾经接手过一个项目，它的依赖关系非常混乱。在这个项目中，开发者常常将 API 接口参数的 Request、Response 等对象用于数据库、Redis 存储，这导致架构的下层完全依赖于上层结构。我不得不花费大量的时间和精力进行重构，并且在每日进行 Code Review 时不停地向项目成员强调包结构的重要性，以免项目的新人因为不熟悉情况而随意放置代码。<br />事实上，可以让包结构检查成为自动化检查的一部分，从而节省团队技术经理的管理精力。ArchUnit 作为一个小型、简单、可扩展的开源 Java 测试库，可用于验证预定义的应用程序体系结构和约束关系。<br />在使用 ArchUnit 之前，我们需要讨论一下常见的代码划分包结构的方式。因微服务和单体系统下代码的背景不同，故而不同项目的包结构划分策略也会有所不同，这里按照单体系统下的结构来说明。<br><a name="Oysmg"></a></p><h4 id="1-常见-的-Java-工程的包结构">1. 常见 的 Java 工程的包结构</h4><p>Java 应用项目中一般有两种组织代码的方式。一种是按照 “大平层” 的风格组织，即将同一类代码放到一个包中，比如 Service、Dao；还有一种是按照业务模块来划分，每个模块下有自己的 “大平层”。<br />另外，不同的代码也会有不同的层次划分方式。这里介绍两种，一种是 MVC 风格的三层结构，即 Controller、Service 和 Dao；另外一种是 DDD 的四层结构，即 Interface、Application、Domain 和 Infrastructure。<br />提示：DDD 是领域驱动设计（Domain-driven design）的英文缩写，也指 Eric Evans 在 2003 年所出版的图书《领域驱动设计：软件核心复杂度的解决方法》，该书提出了一种四层的软件分层结构。<br />上述两个维度包含以下 4 种包组织的方式，下面一一说明。<br />**MVC 大平层分包 **<br />这是一种最简单的分包方式，如图 2-4 所示，按照最初 MVC 模式的逻辑，业务应该写在 Controller 中。但是随着前后端分离的发展，View 层消失了。在 Spring Boot 等框架中，Controller 通过 RESTful 的注解代替了 View 层，主流的做法演化成将业务逻辑写在 Service 中。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712849918284-1dd711cd-00f5-4b1d-bb04-9fd470479c76.png#clientId=u2f715dd5-4179-4&amp;from=paste&amp;id=u2d383674&amp;originHeight=392&amp;originWidth=444&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=14143&amp;status=done&amp;style=none&amp;taskId=u147a2a8e-6270-4626-bdf9-72746055344&amp;title=" alt="image.jpg"><br />图 2-4 MVC 大平层分包<br />为了保持架构整洁，这种分包结构下需要有如下简单规则：</p><ul><li>相同类型的文件放到相同的包中。</li><li>上层对象可以依赖下层对象，禁止反向依赖。</li><li>Request 对象只能在 Controller 中使用，为了保持 Service 层的复用性，不允许在 Service 中引用 Controller 层的任何类。</li><li>不建议将 Model 直接用于接口的数据输出，而应该转换为特定的 Response 类。</li><li>所有文件需要使用包名作为结尾，例如 UserController、UserService、UserModel、UserDao 等。</li></ul><p>这是一种最简单、清晰的包结构划分，这里还没有涉及枚举、远程调用、工厂等更为细节的包结构设计，可以继续按照需要拓展。<br />**MVC 按照模块分包 **<br />大平层的分包方式在大多数项目中已经够用，但是对于一些复杂的项目，这种包结构会受到团队的质疑，这是因为业务很复杂时，每一个目录下的文件都会非常多。这时，可根据业务划分模块，每个模块下再设置单独的大平层结构，如图 2-5 所示。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712849918924-5cbf8bdd-90a6-44c0-a35b-ec8a8d301aa7.png#clientId=u2f715dd5-4179-4&amp;from=paste&amp;id=u7f79189b&amp;originHeight=400&amp;originWidth=1156&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=30992&amp;status=done&amp;style=none&amp;taskId=ue44d7c3f-c369-4a80-81ba-8d39a04d637&amp;title=" alt="image.jpg"><br />图 2-5 MVC 按模块分包<br />在规模较大、复杂的应用中按照模块分包，可以将单个开发者的认知负载降低。虽然按照这种方式分包可以将各个业务模块分开，简化单个模块的开发复杂度，但是会让系统整体变得复杂。我们在享受这种分包好处的同时，需要额外注意它带来的问题。例如用户模块的 Controller 可以访问商品模块的 Service，商品模块的 Service 又可以转而访问用户模块的 Dao，随着时间的流逝，虽然各个模块的文件看起来都是分开的，但是业务依然会混乱。<br />为了解决这个问题，在使用这种分包方式时，除了需要遵守上面的规则以外，还需要额外增加如下规则：</p><ul><li>跨模块访问时，不允许直接访问 Dao，而是应访问对方的 Service。</li><li>模块之间应该通过 Service 互相访问，而不是通过表关联。</li><li>模块之间不允许存在循环依赖，如果产生循环依赖，应该重新设计。</li></ul><p>**DDD 大平层分包 **<br />MVC 分包方式虽然能满足大部分项目的需求，但是对于越来越复杂的规模化应用来说，也有一定的局限性。<br />举个例子，当我们的应用需要支持多个角色的操作时，MVC 就会带来一定的混乱。这里的角色不是指管理员和超级管理员那种仅仅是权限不同的角色，而是指管理员、用户、代理商等完全不同的操作逻辑和交互行为。这种思想和 DDD 的分层思想不谋而合。<br />如图 2-6 所示，DDD 的四层结构使用了不同的概念。</p><ul><li>Interface 层：用于隔离接口差异，即比如 XML、WebSocket、JSON 等。</li><li>Application 层：用于隔离应用差异，即将用户的操作和管理员的操作区分开。</li><li>Domain 层：用于复用业务逻辑。</li><li>Infrastructure 层：一些基础设施，例如数据库、Redis、远程访问等。</li></ul><p>可以看到， DDD 大平层分包方式划分的包结构和 MVC 区别不算大，主要是将应用层隔离，而将领域层的同类型代码放到一起，使用规则也类似。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712849918674-57344cbb-1d9c-4fe3-8a20-186ff5ce60ff.png#clientId=u2f715dd5-4179-4&amp;from=paste&amp;id=ubc920be2&amp;originHeight=506&amp;originWidth=754&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=35742&amp;status=done&amp;style=none&amp;taskId=u7c54fc52-aa25-477d-a30a-20fdec92255&amp;title=" alt="image.jpg"><br />图 2-6 DDD 大平层分包<br />**DDD 基于模块分包 **<br />DDD 也可以基于模块分包，如图 2-7 所示，这里的模块划分只会针对于领域对象和领域服务进行，其中涉及一个专门的术语——上下文。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712849919475-68bc174f-d742-4660-951e-9fad0597514e.png#clientId=u2f715dd5-4179-4&amp;from=paste&amp;id=u048ca57d&amp;originHeight=580&amp;originWidth=772&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=38173&amp;status=done&amp;style=none&amp;taskId=u6e08b77a-af87-4a03-bc28-88a209a98aa&amp;title=" alt="image.jpg"><br />图 2-7 DDD 基于模块分包<br />需要注意的是 ，DDD 基于模块分包并不是一股脑地将所有的 Controller、Service 纳入某个模块中，这种做法会造成业务进一步混乱。它是将应用和领域分开，再按照不同的逻辑进行拆分。<br />DDD 基于模块分包时，需要遵守如下规则：</p><ul><li>应用可依赖于领域，领域不允许依赖于应用。</li><li>上下文之间不允许存在循环依赖。</li><li>上下文之间的访问需要通过 Domain Service 完成，不能直接调用对方的数据层。</li></ul><p>以上四种分包的方式虽然有所不同，但是相差得不多。我们应该根据自己的业务情况来选择分包的方式，如果简单的业务使用较为复杂的包结构，会带来非常多的样板代码，降低开发效率。<br />分层的本质是隔离差异，如果在系统可知的运行时间内没有差异的出现，可以先不考虑分层，这种分层除了人为增加复杂度之外往往没有任何好处。<br />当然，还有洋葱架构、六边形架构等其他架构方式，但是相对小众，这里暂且不做分析。<br />考虑好分包方式后，我们就可以配置 ArchUnit 检查条件和约束规则了。后文将以 “MVC 大平层分包” 方式为例，说明如何使用 ArchUnit 对包结构进行检查。当然，不使用 ArchUnit 也可以通过团队契约、多模块的项目设计对团队开发做一些约束。<br><a name="n3Y4m"></a></p><h4 id="2-ArchUnit-的原理">2. ArchUnit 的原理</h4><p>ArchUnit 利用反射和字节码技术获取所有的包、类、字段等信息，并通过特定的分析来确定对象之间的访问关系。ArchUnit 使用 ASM 作为分析字节码的工具，代价是 ArchUnit 中很多规则的定义不是类型安全的。<br />ArchUnit 支持的检查特性有：</p><ul><li>包依赖检查。</li><li>类依赖检查。</li><li>类和包的位置约定检查。</li><li>继承检查。</li><li>分层依赖检查。</li><li>循环依赖检查（Spring 支持双向依赖往往会导致循环现象）。</li></ul><p>ArchUnit 本身也是按照分层架构设计的，其 API 分为如下三层。</p><ul><li>Core：核心层，处理一些基本的类、字节码等操作，用于对导入的类进行断言。</li><li>Lang：处理各种规则的语法和架构逻辑，并提供一些基本的检查器。</li><li>Library：定义一些更为复杂的预定义规则。<br><a name="ONVK9"></a></li></ul><h4 id="3-ArchUnit-使用入门">3. ArchUnit 使用入门</h4><p>ArchUnit 的使用比较简单，可以通过 JUnit 的 Runner 运行，也可以通过 Maven、Gradle 等构建工具来运行。下面以 JUnit 作为示例，演示如何使用 ArchUnit。<br />ArchUnit 支持不同的测试框架，这里使用的是 JUnit 4（关于 JUnit，将在下一章介绍）。ArchUnit 更像是进行代码规范的检查而不是测试，虽然它使用了 JUnit 平台，但其实大家更愿意把它划分到静态代码分析中。<br />在 Maven 中使用 ArchUnit，首先需要添加相关的依赖，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;4.13&lt;/version&gt;</span><br><span class="line">  &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.tngtech.archunit&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;archunit&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;0.14.1&lt;/version&gt;</span><br><span class="line">  &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在图 2-8 中准备了一个 Demo 应用，它有三个包和三个主要的类。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712849919086-abce8b79-a203-4160-a99d-04edd6a3018d.png#clientId=u2f715dd5-4179-4&amp;from=paste&amp;id=uce8f3b85&amp;originHeight=320&amp;originWidth=710&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=33163&amp;status=done&amp;style=none&amp;taskId=ub99a8d0d-a9ab-4527-821a-b4a5ac7112f&amp;title=" alt="image.jpg"><br />图 2-8 分层示例<br />我们可以使用下面的规则编写 ArchUnit 测试：</p><ul><li>Controller 中的类不允许被 Service、Dao 访问。</li><li>所有的类名必须使用当前的包名结尾。</li></ul><p>然后在对应的测试目录下，编写一个测试类 ArchUnitTest，并添加一个测试用例来限制类名，所有的 Controller 文件必须以 Controller 结束：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void file_name_should_end_with_package_name() &#123;</span><br><span class="line">    JavaClasses importedClasses = new ClassFileImporter().importPackages(this.getClass().getPackage().getName());</span><br><span class="line"></span><br><span class="line">    classes().that().resideInAPackage(&quot;..controller&quot;)</span><br><span class="line">            .should().haveSimpleNameEndingWith(&quot;Controller&quot;)</span><br><span class="line">            .check(importedClasses);</span><br><span class="line">    classes().that().resideInAPackage(&quot;..service&quot;)</span><br><span class="line">            .should().haveSimpleNameEndingWith(&quot;Service&quot;)</span><br><span class="line">            .check(importedClasses);</span><br><span class="line">    classes().that().resideInAPackage(&quot;..dao&quot;)</span><br><span class="line">            .should().haveSimpleNameEndingWith(&quot;Dao&quot;)</span><br><span class="line">            .check(importedClasses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，importedClasses 为被覆盖的范围，ArchUnit 可以通过 ClassFileImporter、JavaTypeImporter 等方式加载需要被验证的类。<br />上面这段测试中包含了 3 条验证规则，下面这段代码就是其中一条。使用 ArchUnit 只需要按照类似的做法编写这些规则即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">classes().that().resideInAPackage(&quot;..controller&quot;)</span><br><span class="line">            .should().haveSimpleNameEndingWith(&quot;Controller&quot;)</span><br><span class="line">            .check(importedClasses);</span><br></pre></td></tr></table></figure><p>这是一个典型链式风格的 API，classes() 方法是 ArchUnit lang 层的工具方法，用于声明基本的规则，大部分基本规则都可以使用 classes() 方法来初始化声明。that() 方法后面的内容代表哪些符合规则的类会被筛选到。ArchUnit 提供了大量的筛选器，比如类型、是否使用了某种注解等。should() 方法后面接的是断言规则，比如类名规则、依赖规则等。<br />接下来实现 MVC 分层架构的依赖检查，这里会用到 library 包中的预定义规则方法 layeredArchitecture()，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void should_obey_MVC_architecture_rule() &#123;</span><br><span class="line"> JavaClasses importedClasses = new ClassFileImporter().importPackages(this.getClass().getPackage().getName());</span><br><span class="line">    layeredArchitecture()</span><br><span class="line">            .layer(&quot;Controller&quot;).definedBy(&quot;..controller..&quot;)</span><br><span class="line">            .layer(&quot;Service&quot;).definedBy(&quot;..service..&quot;)</span><br><span class="line">            .layer(&quot;Dao&quot;).definedBy(&quot;..dao..&quot;)</span><br><span class="line"></span><br><span class="line">            .whereLayer(&quot;Controller&quot;).mayNotBeAccessedByAnyLayer()</span><br><span class="line">            .whereLayer(&quot;Service&quot;).mayOnlyBeAccessedByLayers(&quot;Controller&quot;)</span><br><span class="line">            .whereLayer(&quot;Dao&quot;).mayOnlyBeAccessedByLayers(&quot;Service&quot;);</span><br><span class="line">  layeredArchitecture.check(importedClasses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码时，在 IDEA 编辑器边缘会出现绿色的运行按钮，单击此按钮即可作为单元测试运行。这里使用 layeredArchitecture() 将 controller、service 和 dao 三个包中的类分别定义为 Controller、Service 和 Dao 层，并声明其约束关系。如果出现错误的依赖关系，测试就不会通过。<br />官网使用了一张图来说明三层架构下的依赖关系（如图 2-9 所示），可以看到，这里只允许下层类被上层调用，以此来守护代码的架构。在编写本书时，官网的示例代码存在部分未更新的情况，如果按照官网的说明不能运行，可以参考本书提供的示例代码。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712849920297-873407a6-37f4-45fd-88f1-d96a583fed65.png#clientId=u2f715dd5-4179-4&amp;from=paste&amp;id=ucc5a5ced&amp;originHeight=1076&amp;originWidth=1254&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=162070&amp;status=done&amp;style=none&amp;taskId=u6bd5214d-d705-482f-9f86-b98f9dd2308&amp;title=" alt="image.jpg"><br />图 2-9 ArchUnit 的依赖示意图<br />（注：图片来源于 <a href="https://www.archunit.org/%EF%BC%89">https://www.archunit.org/）</a><br><a name="dbHAX"></a></p><h3 id="2-1-4-OWASP-Dependency-Check">2.1.4 OWASP Dependency-Check</h3><p>架构的问题解决后，还需要避免在项目中使用开源软件带来的安全问题。开放式 Web 应用程序安全项目（OWASP）是一个非营利组织，提供了安全标准、数据库、社区和培训。其中一个工具 OWASP Dependency-Check 可以对第三方依赖包中的知名漏洞进行检查，扫描结果受漏洞数据库的更新影响。<br />OWASP Dependency-Check 可以报告现有的第三方依赖的 CVE。CVE 的英文全称是 Common Vulnerabilities &amp; Exposures，可以简单地理解为业界已知的漏洞批漏。<br />OWASP 的安全扫描和 fortify 等安全扫描工具有所不同，它依赖于开放的漏洞信息，不能完全代替模式分析类安全扫描工具。即便如此，基于 OWASP Dependency-Check 进行的依赖检查也是必须的，因为现代项目依赖的组件较多，通过人工检查的方式较难及时发现漏洞。<br />OWASP 的依赖检查支持主流的语言和包管理工具，对于 Java 语言来说，我们可以继续使用 Maven 插件来运行 OWASP Dependency-Check。与 Checkstyle 类似，首先创建一个模块，在 Pom 文件中添加相关依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.owasp&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dependency-check-maven&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;6.1.3&lt;/version&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;check&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><p>在真实的项目中，依赖包的变化没有那么频繁，如果每次构建都运行这个检查会让构建变慢。比较好的做法是使用 CI/CD 工具，比如 Jenkins，设定一个定时的任务在夜间运行。关于 Jenkins 的使用，请参考本书测试工程化部分。<br />使用 OWASP Dependency-Check 时需要意识到，它并不能取代安全测试。由于它的实现机制是通过 CVE 库来报告问题的，因此受制于该库的更新情况，存在一定程度上的滞后问题。<br><a name="Tr6su"></a></p><h2 id="2-2-代码评审">2.2 代码评审</h2><p>这里的代码评审是指人工查看代码是否存在问题或者改进点，人工进行代码评审更加关注设计，因为代码的设计往往不能被自动化的静态代码分析发现。比如，团队某个成员编写的代码使用了拼音作为变量名，虽然能通过静态代码分析，但这不是一个好的设计，不良的命名方法会让代码的可读性大大降低。<br><a name="t5jcn"></a></p><h3 id="2-2-1-代码评审的场景">2.2.1 代码评审的场景</h3><p>代码评审是国际软件业界公认的最有效的软件工程实践之一，人工代码评审和测试的不同点在于，人工代码评审不只是发现代码中的错误，它还能预防一些错误的发生。<br />我们可通过纠正开发者的编码习惯和风格，来提高软件的质量。举个例子，如果没有为关键程序添加事务处理机制，那么测试人员往往不会测试出问题，但是在高并发的情况下会有一定的机会暴露缺乏此机制的问题。在代码评审阶段，若能及时发现团队成员没有增加事务相关的注解，就能避免潜在问题的出现。代码评审也让团队的协作风格趋于统一，我们可以在评审过程中整理一些代码规范，让团队成员按照相似的风格进行开发。<br />综上所述，虽然我们可以在一定程度上使用静态代码分析来保证代码质量，但静态代码分析无法解决所有问题，因此不能完全依赖于它，在一些场景中我们需要让团队成员一起来做代码评审。<br />在团队日常的开发工作中，有如下几种代码评审方式。<br />1）** 每日代码评审。** 一般是在每天下午下班前拿出 1 个小时来对当天的代码做评审。如果一个团队共有 8 个成员，那么相当于需要花费一个人天。有一些项目经理特别不理解为什么需要花时间来做这件事情。实际上，每日代码评审非常重要，不仅可以分摊需要评审的代码量，也可以让团队的编码风格日趋统一，如此往复需要指出的错误就会越来越少。此外，每日代码评审也是团队进行技术交流的一个契机，团队成员彼此之间可以清晰地了解对方在做什么。<br />2）** 发布前代码评审。** 发布前进行代码评审的目的是避免产品中有明显不合适的代码。有时候一些错误测试人员很有可能没有覆盖住，而通过发布前代码评审就能快速识别。如果团队的版本管理策略是在 Release 分支上发布，那么通过与另一个分支上之前发布的版本对比，也就可以看出两者之间的差异。发布前代码评审的工作量比较大，一些创业团队不愿意做是可以理解的，对于成熟的公司，如果是有大量用户的产品，则需要认真进行此评审。<br />3）<strong>Hotfix 代码评审。</strong> 一个新版本发布后，往往会有一些问题需要及时修复，我们将这种修复叫作 Hotfix。Hotfix 通常不会改动太多地方，测试人员也无力全部进行回归测试，所以 Hotfix 一般是通过 Pull Request 来完成的，在此过程中，会由有经验的技术经理来把关合入的代码是否存在明显的问题。<br />一般来说，上述三种主要的代码评审方式都发生在团队内部。其中，每日代码评审和发布前的代码评审通常需要团队成员一起参加，对此，可以使用一个大屏配合 IDE 在本地完成。<br><a name="vn1xW"></a></p><h3 id="2-2-2-代码评审的工具">2.2.2 代码评审的工具</h3><p>代码评审基于如下工具来进行可以提高效率。</p><ul><li>代码版本管理工具，比如 Git、SVN、Mercurial 等，不过目前大都使用 Git 。Git 的分布式特性很出色，工具链也完善，如果没有别的限制因素，可以默认使用 Git。</li><li>代码托管平台，GitLab、Github 以及国内的 Gitee 都不错，如果在企业内部使用，可以选择自己搭建 GitLab，不过 GitLab 比较复杂，因此也可以使用 Gogs 通过 Docker 容器快速启动一套 Git 代码托管平台。</li><li>代码对比工具。代码托管平台一般会提供内置的代码对比工具，不过访问比较慢。还有专业的代码对比工具软件（比如 BeyondCompare），以及集成到 IDE Git 客户端中的代码对比工具（比如 IntelliJ IDEA 等）。IntelliJ IDEA 在大部分项目中完全够用，而且在多人参与的代码评审活动中效率也比较高。</li><li>专用的代码评审工具。这类工具是专门为代码评审而设计的，比如 Gerrit。Gerrit 可以在网页中做类似于 GitLab、Github 的工作，而且还有一些额外的工作流管理能力。</li></ul><p>一般来说，对于非开源项目，GitLab 与 IntelliJ IDEA 是一个比较好的工具组合，配置和使用简单，维护成本也比较低。<br><a name="jBBKc"></a></p><h3 id="2-2-3-代码评审的注意事项">2.2.3 代码评审的注意事项</h3><p>一般来说，代码评审对技巧的要求不高，根据团队的习惯和风格审核即可。历史上可以追溯的代码评审方法有 IBM 公司在 1972 年提出的培根法。培根法将代码评审的参与人分为代码作者、审查者和主持人，这些人员组成评审委员会。<br />培根法要求先由代码作者进行代码叙述，然后由审查者提出问题。审查者需要提前阅读代码，并准备问题。由于培根法评审的速度实在太慢，采用此方法的团队并不多。IBM 表示他们在一些关键的模块中使用了这种方法，最终带来的收益并不低。据统计，由于减少了项目后期修改和返工的时间，代码评审使得项目的开发时间反而提前了 30%。<br />对于普通的团队，还是建议根据场景来制定合适的评审策略，在成本和收益之间权衡。下面是根据不同场景提出的代码评审注意事项。<br><a name="LScCh"></a></p><h4 id="1-每日代码评审">1. 每日代码评审</h4><p>一般我们讨论得比较多的是每日代码评审，因为需要全员参与，时间又比较有限，因此主持人要有较强的组织能力，而且为了高效地进行代码评审，团队也需要达成一些契约。<br />**（1）小步提交 <strong><br />团队成员需要保持良好的代码提交习惯——小步提交代码。每完成一个小阶段的开发或重构工作都需要提交一次代码，在避免更改丢失的同时也可为更好地评审代码打下基础。每一次的提交都需要使用有意义、风格一致的文本描述，也需要遵守相应的规则，比如使用看板卡片管理任务的团队会按照 “# [卡号] [描述]” 的模式提交代码。<br /></strong>（2）描述要具体 <strong><br />在进行代码评审的时候避免使用诸如 “这个地方的实现不优雅” 这类似是而非的用语，应该使用更为具体的表述，比如 “使用了太多的 if 语句，是否可以使用策略模式等设计模式改进设计”。此外，还要避免提出带有个人习惯的意见，例如 &quot;应该使用 switch 语句而非多个 if 语句” 等。<br /></strong>（3）及时修改 <strong><br />代码评审过程中提出的问题，需要代码作者自行记录，并且尽可能在当天完成修复和处理。一些零碎的小事放到以后做都是不现实的。<br /></strong>（4）专注参与 <strong><br />如果是线下评审，最好使用大屏或专门的会议室，避免大家一边进行代码评审一边做其他的事情。如果是远程工作，通过视频会议评审，则建议所有人打开摄像头，主持人可以使用一些主持技巧，比如不定时对部分参与人员点名，唤起大家的注意力。<br /></strong>（5）聚焦当下 <strong><br />最糟糕的代码评审就是突然岔开话题，进行技术方案、业务方案的讨论，这会浪费大家的时间。如果话题被岔开，那将会是一个无底洞，就像《爱丽丝梦游仙境》中兔子洞的故事（Rabbit Hole）所描述的一样。代码评审应该专注于当下的代码问题，避免陷入技术和业务细节，如果遇到这种情况，可以提出在专门的技术会议中讨论。<br /></strong>（6）控制好时间 <strong><br />代码评审中最难的就是时间控制，一般一个正常的开发团队每天每人的工作量至少需要 10 分钟才能描述清楚，因此，需要给每个人设定一个时间窗口，避免超时。一般来说可根据人数设定时间，如果超时了，就立马停止，第二天继续，这样会越来越快。<br /></strong>（7）分组评审 <strong><br />如果团队规模过大，无论如何也无法在 1 个小时内完成评审，就需要进行分组。为了让所有的开发者都能了解全局，以及保持知识传递，可以按周、迭代频率等重新分组。<br /></strong>（8）知识整理 **<br />重复出现的问题不应该被重复提出，对于一些常见的问题，团队可以整理一份评审清单，当有新人参与项目时，评审清单有利于其更快地适应团队风格，也可以降低发现问题的成本和偶然性，同时开发者在提交代码的时候也可以参考清单自己先评审一遍。<br><a name="MbGGl"></a></p><h4 id="2-发布前的代码评审">2. 发布前的代码评审</h4><p>发布前的代码评审不用全员参与，可以由技术经理挑选几个关键人员参加，如果遇到无法理解的部分，可以邀请提交人来进一步解释。发布前的代码评审着重于处理对线上具有破坏性的修改，从而避免一些危害。<br />此外，它还可以发现因管理问题带来的线上游离变更，比如前一个迭代进行了 Hotfix，但是没有及时合并到主干上，导致生产上有相关代码但是当前发布的版本中却没有，这样一来，发布完成后就会出现问题。<br><a name="JI8Kp"></a></p><h4 id="3-Hotfix-代码评审">3. Hotfix 代码评审</h4><p>Hotfix 代码评审比较简单，一般在代码托管平台中对 Pull Request 进行设定即可，比如，必须有多少人通过才允许合并等。此外，通过 Pull Request 也可以追溯 Hotfix 的变更记录。<br />在一些管理严格的公司中，Hotfix 还需要经过多级审核才发布，毕竟对于 Hotfix 来说，全量执行手动的回归测试不太现实，所以折中的方法是对变更的代码进行严格评审。<br><a name="zE3R9"></a></p><h3 id="2-2-4-Java-代码评审清单">2.2.4 Java 代码评审清单</h3><p>这里为 Java 开发者整理了一份基本的评审清单，为了避免清单冗长，里面不包含静态扫描能发现的问题，具体如下：</p><ul><li>有没有 IntelliJ IDEA 的黄色警告。若存在黄色警告，往往意味着代码可以被优化或者存在潜在的问题。</li><li>数据的输入是否进行了验证，比如类型、长度、格式、范围等。</li><li>提供的 API 是否做了鉴权，尤其是数据的鉴权。</li><li>需要配置的值是否是硬编码，需要使用常量或配置文件存放配置。</li><li>注释和方法的命名是否与代码语义一致并容易理解。</li><li>是否使用了足够便捷的解决方案，比如库函数已提供的逻辑就不需要自己再写一遍了。</li><li>是否使用适当的数据结构，比如合理选择 HashMap、ArrayList 等。</li><li>是否做了合理的异常处理。</li><li>API 的设计是否符合规范和语义。</li><li>是否有足够多且合理的测试。<br><a name="AT6EV"></a></li></ul><h2 id="2-3-Git-工作流和保护">2.3 Git 工作流和保护</h2><p>Git 作为一款出色的分布式代码版本管理工具，由 Linux 的作者 Linus 开发，目前，它已经成为我们日常开发离不开的工具。用好 Git，并且采用适当的工作流，可以让代码评审工作事半功倍。<br><a name="e9xe1"></a></p><h3 id="2-3-1-Git-工作流">2.3.1 Git 工作流</h3><p>在团队协作中，代码评审的方式和代码版本管理有一定关系，代码版本管理的工作流和分支策略是一个讨论比较多的话题。Git 工作流说明了团队如何使用 Git 分支，并按照一定约定进行协作。Git 工作流有很多派别，比如 Git Flow、GitHub Flow、GitLab Flow 等。</p><ul><li>Git Flow：项目存在两个长期分支，即一个主干分支，一个开发分支，开发者一起工作在开发分支中，发布时合并到主干分支中。此外，还有一些短期存在的分支，比如特性分支、预发分支等。</li><li>GitHub Flow：项目以一个主干分支作为长期分支，每个开发者在自己的开发分支中工作，然后通过 Pull Request 合并到主干分支。</li><li>GitLab Flow：项目遵守上游优先原则，只以一个主分支作为长期分支。开发者在主干分支上开发，待测试稳定后，使用发布分支发布。后续的 Hotfix 都需要合并到发布分支和主分支上。</li></ul><p>从实用和经济的角度来说，个人比较推荐 GitLab Flow，当然，具体应该视团队情况而定，比如团队人数、是否需要和其他团队联调（这是个比较重要的因素，若使用分支开发会比较麻烦）等。<br />如图 2-10 所示，对于大多数使用敏捷工作方式的团队来说，比较好的分支策略可以用一句话概括：** 主干开发，分支发布 **。这种策略尤其适合一个迭代一个版本的开发节奏，但如果采用的是持续发布方式，因为这种方式没有固定的版本周期，所以此策略未必合适。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712849919919-aeaf6d9a-c85d-435e-9e5e-d64751e726da.png#clientId=u2f715dd5-4179-4&amp;from=paste&amp;id=uceed5d4c&amp;originHeight=272&amp;originWidth=998&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=26195&amp;status=done&amp;style=none&amp;taskId=ua38a96d1-3fcf-4ffc-bf3d-1d0cdea6822&amp;title=" alt="image.jpg"><br />图 2-10 一种分支策略<br />“主干开发，分支发布” 的分支策略有以下几个规则需要团队遵守：</p><ul><li>团队应使用 Git rebase 命令而不是 merge 命令拉取代码，以避免提交日志混乱。</li><li>团队在主干开发，每个迭代结束的前几天创建 Release 分支，每一次发布使用一个新的分支，应使用语义化版本号（Semantic Versioning）[^1] 来命名，比如 v2.1 分支。创建 Release 分支时可以同步创建标签，以便早期发布的 Release 分支可以被删除。</li><li>Release 分支可以部署到预发环境中，主干只能部署到开发和测试环境。</li><li>在将 Release 分支发布到产品环境之前，要基于上一次的 Release 分支做发布前的代码评审。</li><li>如果预发环境出现问题需要修复，以 Release 分支为基线创建 Hotfix 分支，并提交 Pull Request，团队批准后可以先部署到预发环境中，再部署到产品环境中。</li><li>部署到产品环境后，需要将 Release 分支的变更同步到主干，避免下次上线丢失更新。<br><a name="oOGE5"></a></li></ul><h3 id="2-3-2-Git-Hooks">2.3.2 Git Hooks</h3><p>静态代码分析和代码评审需要与代码的分支控制相结合才能起到好的效果，如果 Checkstyle 等检查没有通过，代码不应被推送到 Git 服务器上。<br />Git Hooks 是由 Shell 脚本构成的。Hook（钩子）这个概念在操作系统和带有插件系统的软件中广泛存在，这里将其用于 Git 的某个生命周期。所有默认有效的钩子都可以在. git/hooks / 目录中找到。钩子用于控制 Git 工作的流程时，又分为客户端钩子和服务器钩子，客户端钩子会在执行 push 命令之前运行在开发者的本地机器上，服务器钩子会在推送后运行在 Git 服务器上。<br />下面是一些常见的客户端和服务器钩子。客户端钩子：</p><ul><li>pre-commit</li><li>prepare-commit-msg</li><li>commit-msg</li><li>post-commit</li></ul><p>服务器端钩子：</p><ul><li>pre-receive</li><li>post-receive</li><li>update</li></ul><p>一般我们会通过配置 pre-commit 到项目中，来促使团队成员在提交代码时进行一些检查，所进行的检查包括：</p><ul><li>运行单元测试。</li><li>运行代码检查（比如 Checkstyle）。</li><li>提交的信息检查。</li></ul><p>如果有 Git 服务器的配置权限，也可以通过配置 pre-receive 在服务器端运行检查。本地检查无疑是最高效且方便的手段之一，但是组织一群人来手动安装这类脚本明显是一件费力不讨好的事。为了防止团队成员忘记设置本地钩子脚本，我们可以在构建工具中添加安装钩子脚本的任务，让开发者在第一次启动项目时自动添加相关钩子。<br />由于几乎所有的 Maven 使用者都会执行 mvn install 命令来初始化项目，因此可以使用插件 git-build-hook 来安装 Hook 脚本，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;com.rudikershaw.gitbuildhook&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;git-build-hook-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;gitConfig&gt;</span><br><span class="line">          &lt;!-- 指定代码库中的 Hook 脚本位置，插件会帮助安装到 gitconfig 中 --&gt;</span><br><span class="line">          &lt;core.hooksPath&gt;hooks-directory/&lt;/core.hooksPath&gt;</span><br><span class="line">          &lt;custom.configuration&gt;true&lt;/custom.configuration&gt; </span><br><span class="line">        &lt;/gitConfig&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">      &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;goals&gt;       </span><br><span class="line">            &lt;!-- 配置执行 Hook 安装的生命中周期 --&gt;</span><br><span class="line">            &lt;goal&gt;install&lt;/goal&gt;</span><br><span class="line">          &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">      &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>将上面的配置放置到相应的 Pom 文件中，团队成员执行了 mvn install 命令后，钩子脚本就会自动安装。如果下一次团队成员使用 Git 相应命令提交和推送代码，就会触发相应的钩子脚本。<br />下面是一个触发钩子脚本的示例，把这个文件保存为 pre-commit 并放到 hooks-directory 目录中，项目初始化后，在提交代码时此脚本就会被执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># 需要运行的命令</span><br><span class="line">mvn clean build</span><br><span class="line"># 获取上一个命令的执行结果</span><br><span class="line">RESULT=$?</span><br><span class="line"># 使用上一个命令的执行结果来退出，这样做可以选择是否中断构建</span><br><span class="line">exit $RESULT</span><br></pre></td></tr></table></figure><p>Gradle 可以更灵活地编写、构建脚本和任务，下面是 Java Gradle 的一个 pre-commit 脚本示例，在项目的根目录中添加 pre-commit 文件，通过配置 Gradle 脚本可以使项目初始化时自动安装该钩子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">task installGitHooks(type: Copy) &#123;</span><br><span class="line">    from new File(rootProject.rootDir, &#x27;pre-commit&#x27;)</span><br><span class="line">    into &#123;</span><br><span class="line">        new File(rootProject.rootDir, &#x27;.git/hooks&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    fileMode 0755</span><br><span class="line">&#125;</span><br><span class="line">build.dependsOn installGitHooks</span><br></pre></td></tr></table></figure><p><a name="pqyDZ"></a></p><h3 id="2-3-3-分支保护">2.3.3 分支保护</h3><p>在没有 Pull Request 和代码评审的情况下，不应该把代码直接推送到 Release 分支。因为 Git 代码托管平台有分支保护功能，所以可以基于前面的分支策略设定几个简单的规则。</p><ul><li>受保护的分支均不可删除、强制推送，避免代码库受损。</li><li>Release 分支不接受直接推送，必须使用 Pull Request 的方式提交补丁合并，并需要在 2 人以上的团队成员批准后才能合并。</li><li>如果条件允许，合并到 Release 分支的临时分支可以自动删除。</li></ul><p>图 2-11 是 GitLab 的分支保护界面，配置好分支保护以后，就可以避免因为误操作或者恶意操作导致团队的代码库丢失。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712849919689-6220a81a-dcbc-4e30-94da-e76b5885c328.png#clientId=u2f715dd5-4179-4&amp;from=paste&amp;id=u41fb5ef7&amp;originHeight=326&amp;originWidth=1363&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=66690&amp;status=done&amp;style=none&amp;taskId=u2f059dae-c58a-4cc8-a5bb-52684c09bc5&amp;title=" alt="image.jpg"><br />图 2-11 GitLab 的分支保护设置<br><a name="Et5Ay"></a></p><h2 id="2-4-小结">2.4 小结</h2><p>本章介绍了代码评审的几种形式，包括静态代码分析和人工代码评审。基于静态代码分析的各种工具，可以低成本地提高静态代码分析的能力和效果。<br />为了弥补静态代码分析的不足，可以根据场景对代码进行评审，评审也是团队整体学习的契机。提高代码质量、互相学习、知识共享是每日代码评审的动力，保持节奏感和坚持是从中获益的必要条件。<br />最后，为了更高效地实现静态代码分析和代码评审，我们需要基于适合团队的版本管理工作流来实现更好地团队协作。主流的版本管理方式有 Git Flow、GitHub Flow、GitLab Flow 等，具体需要根据产品类型和规模进行选择，我们也可以定制适合自己的版本管理工作流。此外，通过 Git Hooks 和分支保护可以充分地挖掘 Git 的潜力，让团队协作更安全和流畅。<br />[^1]: 参考网站 <a href="https://semver.org/">https://semver.org/</a></p><blockquote><p>来自: <a href="https://java-self-testing.github.io/java-self-testing-book/02-code-review/">第 2 章 代码评审 - 《Java 研发自测》</a></p></blockquote><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在软件开发过程中，除了可以从功能角度发现问题以外，还可以通过代码检视发现一些显而易见的问题，做好这部分工作带来的收益甚至比测试人员手动测试还高。&lt;br /&gt;在实践中，对代码进行评审可以从如下三个层面把控：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态代码分析。&lt;/li&gt;
&lt;li&gt;每日代码</summary>
      
    
    
    
    <category term="测试" scheme="http://www.bojiboqi.fun/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="spring测试" scheme="http://www.bojiboqi.fun/tags/spring%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>第 4 章 测试替身 - 《Java 研发自测》</title>
    <link href="http://www.bojiboqi.fun/2024/04/22/%E7%AC%AC%204%20%E7%AB%A0%20%E6%B5%8B%E8%AF%95%E6%9B%BF%E8%BA%AB%20-%20%E3%80%8AJava%20%E7%A0%94%E5%8F%91%E8%87%AA%E6%B5%8B%E3%80%8B/"/>
    <id>http://www.bojiboqi.fun/2024/04/22/%E7%AC%AC%204%20%E7%AB%A0%20%E6%B5%8B%E8%AF%95%E6%9B%BF%E8%BA%AB%20-%20%E3%80%8AJava%20%E7%A0%94%E5%8F%91%E8%87%AA%E6%B5%8B%E3%80%8B/</id>
    <published>2024-04-22T06:29:22.468Z</published>
    <updated>2024-04-22T23:25:47.773Z</updated>
    
    <content type="html"><![CDATA[<p>测试替身是单元测试中非常有用的一个概念，用来隔离组件之间的依赖关系，让不可测试的组件变得可以测试。<br>曾听很多朋友说，测试替身这个概念非常难理解，它有种浓浓的翻译味。我一直在尝试找一个合适的类比来说明这些概念，直到有一次我家的灯泡坏了，我带着这个灯泡到一家五金店购买新的灯泡。老板在柜子里翻出一个差不多的灯泡，然后插到门后预留的一个灯座上，灯泡亮了起来。我忽然灵光一闪，这不就是测试替身一个绝妙的类比么？代替真实灯座（基础设施）进行验证（单元测试）的装置就是测试替身。<br>合理运用测试替身可以在运行测试时去除对运行环境的依赖。这也给了我们一个启示，那就是尽可能地使用清晰的边界来设计代码，让编写单元测试更加容易。<br>编写单元测试有时候不是那么容易。对于前面提到的类比，假如灯泡是通过电线直接连接到供电系统的而不是灯座，那么测试就会变得非常困难。<br>本章的目标是解决单元测试在实际编写的过程中遇到的各种困难，通过测试替身让单元测试可以顺利进行。在 Java 技术栈中，我们可以使用 Mockito、PowerMock 这两种测试替身工具。<br>本章涵盖的内容有：</p><ul><li>使用 Mockito 实现 public 方法的模拟，用于解决大部分可测性问题。</li><li>使用 PowerMock 实现特殊的测试场景。比如在被测试的代码中有一段 Sytem.out. printf 代码，我们很难进行替换，那么就需要使用更特殊的方法。<br><a name="tcjup"></a></li></ul><h2 id="4-1-测试替身简介">4.1 测试替身简介</h2><p>一个完整的应用程序或者一个系统有时很难提供一个纯粹的类来进行单元测试，对象之间的依赖往往交织在一起，需要拆成各个单元才能逐个击破，这也是单元测试的必要条件。<br>要将这些交织在一起的对象拆开，需要通过一些工具来模拟相关数据或替换具有某些特定行为的类等。网站 <a href="https://xunitpatterns.com/">xunitpatterns.com</a> 把这些工具称为 Test Double，翻译过来就是 “测试替身”。<br>在不同的测试图书中对测试替身有不同的说法。比如，在一些图书中将 Stubs 表述为测试替身，但在有些图书中 Stubs 被作为测试替身中的一类来看待。<br>Martin Fowler 为了让这些概念更容易理解，在他的网站 <a href="https://martinfowler.com/bliki/TestDouble.html">https://martinfowler.com/bliki/TestDouble.html</a> 上重新给出了测试替身的含义，下面主要结合 Martin Fowler 的看法针对测试替身相关概念给出说明。一般情况下，日常交流中会直接使用英文来描述这些概念，为了理解方便，这里也提供相应的中文名称以供参考。<br>我们将 Test Double 作为抽象概念，描述多种测试替身的集合，而测试替身具体的种类使用下面的概念阐述（名词形式）。</p><ul><li>Dummy ：哑对象（数据）。此对象仅仅用于填充参数列表，实际上不会用到它们，对测试结果也没有任何影响。</li><li>Fake： 一些假的对象或者组件。它可完整替代依赖组件。例如内存数据库 H2，一般只会在测试环境下起作用，不会应用于生产。</li><li>Stub： 桩件。为被测试对象提供数据，没有任何行为，往往是测试对象依赖关系的上游数据。</li><li>Spy：间谍对象。它代理了待测对象所依赖的对象，其行为往往由被代理的真实对象提供，代理的目的是了解被依赖对象内部的运行过程。</li><li>Mock： 模拟对象。用于模拟被测试对象的依赖，它往往是一个具有特定行为的对象。开发者在测试开始前根据期望设置预期返回的结果，被测试对象在调用这个模拟对象的方法时，返回预先设定的值。</li></ul><p>在实际开发中，不同的测试框架对这些概念的实现会有一些不同，但大体上不会差太多。例如，在前面我们将 Stub 理解为给被测试对象提供数据的对象，而在 Mockito 的源码中，为模拟对象设置预期行为的过程也叫作 Stub，动词为 Stubbing。测试框架往往会提供与 Mock、Spy 相关的实现，Stub、Fake、Dummy 则需要自己配置或者实现，在本章以及后续的章节中将会聚焦于 Mock、Spy 的原理和使用上。<br>注意：为了表述清晰，后文中 Mock、Spy 使用中文名称表述。Mock 翻译为中文时，动词为 “模拟”，名词为 “模拟对象”；Spy 翻译为中文时，动词为 “监视”，名词为 “间谍对象”。<br>图 4-1 简单说明了这些测试替身分别有什么用，在实际项目中不必全部引入，根据需要使用即可。以用户注册为例，我们编写的单元测试会聚焦于注册部分的代码，至于其他部分，能模拟就尽量想办法模拟。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712881878041-693deab5-63c6-4d3d-8c2a-1f3d452c94aa.png#clientId=ude3f3669-5424-4&amp;from=paste&amp;id=uef593057&amp;originHeight=946&amp;originWidth=1363&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=114317&amp;status=done&amp;style=none&amp;taskId=uf9c5b214-3eca-4f79-bb86-3776ec48a0f&amp;title=" alt="image.jpg"><br>图 4-1 各种测试替身的解释<br>下面我们使用 Mockito 来测试依赖关系复杂的对象。<br>本章的示例代码见 <a href="https://martinfowler.com/bliki/TestDouble.html">https://github.com/java-self-testing/java-self-testing-example/tree/master/stubs</a>。<br><a name="zNvD5"></a></p><h2 id="4-2-Mockito">4.2 Mockito</h2><p>图 4-2 为 Mockito 的 Logo，画面中包含了一杯莫吉托鸡尾酒，Mockito 的名称就是由莫吉托（Mojito）的谐音而来。<br><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/28066124/1712881877631-11faade6-5530-47ed-937c-b8e015c2f716.jpeg#clientId=ude3f3669-5424-4&amp;from=paste&amp;id=u6570dc64&amp;originHeight=252&amp;originWidth=503&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=10638&amp;status=done&amp;style=none&amp;taskId=ue55bd405-eb81-4458-a152-fbc34e7be1b&amp;title=" alt="image.jpg"><br>图 4-2 Mockito 的 Logo<br>Mockito 是一个易用的模拟框架，可以通过干净、流式的 API 编写出容易阅读的测试代码。Mockito 和 JUnit 4 配合得非常完美，在 StackOverflow 社区的投票中排名较高，另外它也是 GitHub 中引用占比非常高的一个框架。<br>Mockito 最常用的是 mock、spy 这两个方法，它的大部分工作都可以通过这两个静态方法来完成。使用 mock 方法输入一个需要模拟的类型后，Mockito 会构造一个模拟对象，并提供一系列方法操控所生成的模拟对象。例如，根据参数返回特定的值、抛出异常或验证这个模拟对象中的方法是否被调用，以及通过何种参数调用等。spy 方法在使用上与 mock 方法类似，唯一不同的是它需要传入一个实例化好的对象，Mockito 会代理这个方法而不是新建一个模拟类。<br>选择 Mockito 的另外一个原因还在于它的生态和可拓展性。后面我们在介绍一些静态方法、私有方法的模拟和测试时，会借助 PowerMock 来完成，PowerMock 和 Mockito 能很好地协作。<br><a name="YSdwY"></a></p><h3 id="4-1-1-使用-mock-方法">4.1.1 使用 mock 方法</h3><p>在下面的示例代码中，stubs 模块有一个 UserService 对象，用来演示用户注册的逻辑。在 register 方法中，注册的过程分为对密码进行 Hash 计算、让数据持久化和发送邮件这三个步骤，事实上，实际场景下的注册方法比这更加复杂，这里做了大量简化，以便于我们将注意力集中在单元测试上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ppublic class UserService &#123;</span><br><span class="line">    private UserRepository userRepository;</span><br><span class="line">    private EmailService emailService;</span><br><span class="line">    private EncryptionService encryptionService;</span><br><span class="line"></span><br><span class="line">    public UserService(UserRepository userRepository, EmailService emailService, EncryptionService encryptionService) &#123;</span><br><span class="line">        this.userRepository = userRepository;</span><br><span class="line">        this.emailService = emailService;</span><br><span class="line">        this.encryptionService = encryptionService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void register(User user) &#123;</span><br><span class="line">        user.setPassword(encryptionService.sha256(user.getPassword()));</span><br><span class="line"></span><br><span class="line">        userRepository.saveUser(user);</span><br><span class="line"></span><br><span class="line">        String emailSubject = &quot;Register Notification&quot;;</span><br><span class="line">        String emailContent = &quot;Register Account successful! your username is &quot; + user.getUsername();</span><br><span class="line">        emailService.sendEmail(user.getEmail(), emailSubject, emailContent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了演示 Mockito 的基本使用方法，这里没有使用 Spring 框架，需要读者自己通过构造函数组织对象依赖关系。<br>我们的测试目标是 register 方法，与之前的示例不同，这里的被测试方法没有返回值，因此无法根据返回值断言，如果测试过程中没有发生异常就代表功能和逻辑正常。另外，这个方法会调用其他对象，复杂的依赖关系在现实中很常见，示例中已经简化了。<br>在上述示例中，UserService 对象的构造方法需要传人 userRepository、emailService、encryptionService 这三个对象，否则无法工作。<br>下面演示的是应用了模拟对象的测试示例。首先，创建一个 Maven 项目或者模块，在 Pom 文件中增加 Mockito 的依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.13&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mockito&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.28.2&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>Mockito 使用了 Byte Buddy 作为代理技术，根据暴露出来的 API 可知，只需要传入一个类作为参数就可以生成一个代理对象，并指定这个代理对象的行为以便返回特定的值，从而完成测试工作。<br>在下面的测试代码中，会使用 Mockito 创建我们需要的被依赖对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class UserServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void should_register() &#123;</span><br><span class="line">        // 使用 Mockito 模拟三个对象</span><br><span class="line">        UserRepository mockedUserRepository = mock(UserRepository.class);</span><br><span class="line">        EmailService mockedEmailService = mock(EmailService.class);</span><br><span class="line">        EncryptionService mockedEncryptionService = mock(EncryptionService.class);</span><br><span class="line">        UserService userService = new UserService(mockedUserRepository, mockedEmailService, mockedEncryptionService);</span><br><span class="line"></span><br><span class="line">        // Given</span><br><span class="line">        User user = new User(&quot;admin@test.com&quot;, &quot;admin&quot;, &quot;xxx&quot;);</span><br><span class="line"></span><br><span class="line">        // When</span><br><span class="line">        userService.register(user);</span><br><span class="line"></span><br><span class="line">        // Then</span><br><span class="line">        verify(mockedEmailService).sendEmail(</span><br><span class="line">                eq(&quot;admin@test.com&quot;),</span><br><span class="line">                eq(&quot;Register Notification&quot;),</span><br><span class="line">                eq(&quot;Register Account successful! your username is admin&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，mock 方法帮我们创建了一个模拟对象，而非真实的对象。mock 方法是一个静态方法，来自 Mockito，为了让内容简短，我们一般直接导入静态方法。Mockito 类是 Mockito 的门面类，提供了大量的静态方法供开发者使用。<br>上述示例是以 Given…When…Then 的方式来组织测试代码的，这可让测试看起来更为清晰。Given…When…Then 是一种测试的风格，前面在介绍单元测试时已经使用过，由于这里使用了测试替身，这种风格体现得更加明显，下面简单介绍一下。<br>很多文章认为这种测试用例的风格是行为驱动开发（BDD）的一部分，很多 E2E 测试框架将其作为默认的代码组织形式，因此被广泛推荐使用。其基本思想是将编写场景（或测试）分解为以下三个部分：</p><ul><li>Given 部分描述在开始指定的行为之前程序的状态，可以将其视为测试的前提条件。</li><li>When 部分触发被测试对象的调用。</li><li>Then 部分检查和断言指定行为所产生的变化。这种变化可以是方法调用成功的返回值、抛出的异常、下游的方法被调用等。</li></ul><p>Mockito 也提供了一个门面类 BDDMockito 来让开发者使用相关 API 编写 BDD 风格的测试。在单元测试中，BDD 不是必选项，但我们依然可以模仿与之类似的风格。<br>按照这个模式，一个测试中应该只包含一组 Given…When…Then，如果出现多组，则建议拆分成多个测试。<br>对 register 方法来说，想要让测试更有效，就需要验证传给 sendEmail 方法的参数是否符合我们的预期。这里可以使用 verify 方法传入模拟对象，并调用相关方法。verify 还可以传入验证的次数，如果是一个循环，被模拟的对象可能会不止一次被调用，不传入的情况下默认是 1。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">verify(mockedEmailService).sendEmail(</span><br><span class="line">                eq(&quot;admin@test.com&quot;),</span><br><span class="line">                eq(&quot;Register Notification&quot;),</span><br><span class="line">                eq(&quot;Register Account successful! your username is admin&quot;));</span><br></pre></td></tr></table></figure><p>verify(mockedEmailService) 等价于 verify(mockedEmailService, 1)。<br>在上述代码中，verify(mockedEmailService) 等价于 verify(mockedEmailService, 1) 。这里还需要验证发送邮件的参数是否是我们所期望的。比如验证发送邮件的地址是否为 “<a href="mailto:admin@test.com">admin@test.com</a>”，发送的内容中是否包含了用户名等信息。<br>上述代码使用了 eq 方法进行对比，需要注意的是，eq 方法和 assertThat 中的 equalTo 不太一样。eq 方法是通过对参数进行验证来实现对比的，它来自于 ArgumentMatchers 对象。<br>我们知道，只有被成功拦截的对象才能用 verify 方法验证。一个形象的例子是，当你去政务中心办理新的身份证时，工作人员会在数个工作日内完成办理，然后通过邮递员派发到指定的收货地址。政务中心的高级检查人员来检查身份证办理的工作是否做到位时，并不需要去监控证件办理人员的一举一动，只需要到下游的环节抽查办理的结果即可。最高明的方法无疑是悄悄扮演成邮递员与办事员对接工作。检查人员就是这里被模拟的对象，那么 “方法” 被调用的时候，下游的 “参数” 也就被传递到检查人员手上。<br>容易联想的是，检查点可以是调用的次数、调用的参数、调用的延时等，而实现的细节和每步的逻辑在 verify 方法中并不需要检查。反之，包含数十个 verify 断言方法的测试让编写者和阅读者都感到困惑，它们的职责不够单一，检查点互相覆盖，但又没有充分发挥作用。<br><a name="Mjt3D"></a></p><h3 id="4-2-2-捕捉参数对象">4.2.2 捕捉参数对象</h3><p>前面我们验证了邮件发送的内容是否符合我们的预期，但是并没有验证传入 userRepository. saveUser 方法的内容是否按照我们的预期执行。因此我们不仅需要验证 saveUser 方法的调用次数，还需要验证传入的对象。<br>在 Java 中，如果修改了一个对象的属性值，在进行相等判断时，只会通过引用比较对象。因此，无法起到断言和校验的作用。所以在使用 verify 方法进行验证时，需要捕捉传人的参数对象，再通过前面介绍的断言来完成验证。<br>在这种情况下，可以通过 ArgumentCaptor 构建一个 Argument 对象，并捕捉参数，再用于断言。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArgumentCaptor&lt;User&gt; argument = ArgumentCaptor.forClass(User.class);</span><br><span class="line">verify(mockedUserRepository).saveUser(argument.capture());</span><br><span class="line"></span><br><span class="line">assertEquals(&quot;admin@test.com&quot;, argument.getValue().getEmail());</span><br><span class="line">assertEquals(&quot;admin&quot;, argument.getValue().getUsername());</span><br></pre></td></tr></table></figure><p><a name="sYZ8M"></a></p><h3 id="4-2-3-设置模拟对象的行为">4.2.3 设置模拟对象的行为</h3><p>在 register 方法中，我们通过 encryptionService.sha256 方法来对密码进行 Hash 计算。在单元测试中，我们可以修改模拟对象中方法的行为，从而实现一个完整的单元测试。<br>在不预设返回值的情况下，调用模拟对象的方法会按照下面的规则返回默认值：</p><ul><li>如果方法的返回值是一个包装类型，模拟对象会默认返回 null。</li><li>如果是基本类型，会返回相应的默认值，例如数字类型会返回 0，布尔类型会返回 false。</li></ul><p>因此，为了测试各种行为，需要让模拟对象按照我们的意图返回数据或者做一些其他操作。通过 when(…). thenReturn(…) 语句可以修改模拟对象中被模拟的方法被调用时的行为或返回值。<br>下面的示例中，sha256 方法传入了一个 any 方法，它是参数匹配器，通过匹配一些条件来决定是否修改被模拟方法的行为或返回值。如果 any 方法不带参数，则意味着任何参数都满足条件。如果 any 方法使用 any(Class type) 的形式传入一个参数类型，那么它会限定具体的参数类型。类似地，ArgumentMatchers 类中还有 eq、contains 等方法用于更精确的匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">when(mockedEncryptionService.sha256(any()))</span><br><span class="line">  .thenReturn(&quot;cd2eb0837c9b4c962c22d2ff8b5441b7b45805887f051d39bf133b583baf6860&quot;);</span><br></pre></td></tr></table></figure><p>when 方法可接收一个模拟对象或间谍对象（后面会讨论）作为参数，随后会调用以下几个方法预置行为。</p><ul><li>thenReturn：预置一个返回值。</li><li>thenThrow：抛出一个异常。</li><li>thenCallRealMethod：调用间谍对象上被代理的原始方法。</li><li>thenAnswer：返回一个 Answer 对象，Answer 对象是预置行为的封装类，上面三种都是一种 Answer 的实现。</li></ul><p>仔细观察你会发现，这里赋予一个模拟对象相应行为的操作是通过直接调用这个模拟对象上的方法，并传递一个参数匹配对象来实现的。使用这种语法设置模拟对象的预期行为，就像调用普通方法一样方便，但是容易让人感到困惑。<br>我第一次使用这个语法的时候感到不可思议，这驱使我去阅读了 Mockito 的源代码。Mockito 在线程的上下文中会记录模拟对象的状态，如果还没有被赋予期望的行为，模拟对象上的方法被调用则会被认为是设置阶段。若存在模拟对象的方法已经被设置了行为，那么它再被调用会返回先前设置的返回值或触发相应逻辑。<br>这种设计有点像一把特殊设计的枪，第一次扣下扳机时只是为了让子弹上膛，第二次扣下扳机才会发射子弹。<br>Mockito 还有一些隐藏的规则，若想避免掉入这些陷阱则需要了解一下：</p><ul><li>可以多次定义预置行为，后续的定义会覆盖前面的设置，以最后一次为准。但是不推荐这种做法，这是一种代码坏味道，引入了一些无效的代码，而且会让可读性下降。</li><li>一旦预置了行为，无论调用多少次每次调用都会返回相同的内容。</li><li>Mockito 还提供了其他形式的语法，以便更灵活地给模拟对象设置预期行为。<br><a name="AbUsI"></a></li></ul><h4 id="1-do-…-when-…-语法">1. do(…).when(…) 语法</h4><p>注意，对于没有返回值的方法，不能使用 when(…).thenReturn(…) 这种语法设置预期行为，这是因为 when 方法需要接收一个被模拟方法的返回值作为参数，如果被模拟方法没有返回值，可以使用 do(…).when(…) 语法，取得的效果类似。在下面这种情况下，把预置的行为写在前面即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">doThrow(new RuntimeException()).when(mockedList).clear();</span><br><span class="line"></span><br><span class="line">// 下面的调用会触发异常抛出</span><br><span class="line">mockedList.clear();</span><br></pre></td></tr></table></figure><p>相关的一系列方法的说明如下。</p><ul><li>doReturn：预置一个返回值。</li><li>doThrow：抛出一个异常。</li><li>doNothing：什么都不做。</li><li>doCallRealMethod：调用间谍对象上被代理的原始方法。</li><li>doAnswer：前面几种方法的封装。</li></ul><p>需要特别注意的是，这里的 when 不是接收方法调用后的返回值，而是会接收模拟对象本身，注意区分这两种情况。<br><a name="Pg8hG"></a></p><h4 id="2-BDD-风格语法">2. BDD 风格语法</h4><p>还记得前面提到的 Given…When…Then 的测试风格吗？<br>在 Mockito 默认 API 提供的方法中，when 方法被用于定义模拟对象的预置行为，但这样一来就与 BDD 的风格不一致了，在可读性上会受到一定的影响。<br>Mockito 为了鼓励使用 BDD 测试风格，也提供了一套 API，在这套 API 里，使用 BDD-Mockito 类中的方法代替了 Mockito 类（BDDMock 为 Mockito 的方法别名），可以模仿 BDD 的风格进行测试。它的用法很简单，将前面的 when 修改为 given，将 then 替换为 will 即可。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">given(mockedEncryptionService.sha256(any()))</span><br><span class="line">        .willReturn(&quot;cd2eb0837c9b4c962c22d2ff8b5441b7b45805887f051d39bf133b583baf6860&quot;);</span><br></pre></td></tr></table></figure><p>在团队达成共识的情况下，利用上述方法别名可以提高测试的自解释性。<br><a name="y58QN"></a></p><h3 id="4-2-4-参数匹配器">4.2.4 参数匹配器</h3><p>参数匹配器是 Mockito 的一个特色功能，可以让 Mock 变得更加灵活，用于区分同一个方法多次被不同的参数调用的情况。参数校验器和 JUnit 中断言的匹配器是类似的模式。<br>Mockito 需要借助参数匹配器来绑定预置行为，参数匹配器也会用于 verify 方法中，起到断言的作用。<br>为了暴露 ArgumentMatchers 中的 API，Mockito 类直接继承了 ArgumentMatchers 类，这足以说明它的重要性。<br>前面的例子中使用了 any 参数匹配器，其用途是让任何参数都可匹配到。如果使用 any 参数匹配器，下面的代码执行后会打印 true。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List mockedList = mock(List.class);</span><br><span class="line">when(mockedList.add(any())).thenReturn(true);</span><br><span class="line"></span><br><span class="line">System.out.println(mockedList.add(null));</span><br></pre></td></tr></table></figure><p>如果想要得到更为细致的类型匹配，可以使用 any(Class)、anyxxx 等关于类型的参数匹配器。因为没有匹配上，下面的代码会打印出 false，这是 Mockito 默认的行为导致的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List mockedList = mock(List.class);</span><br><span class="line">// 等价于 any(Boolean.class);</span><br><span class="line">when(mockedList.add(anyBoolean())).thenReturn(true);</span><br><span class="line"></span><br><span class="line">System.out.println(mockedList.add(null));</span><br></pre></td></tr></table></figure><p>在上述代码中最容易弄错的是 null 值的处理，由于字面量（不经过定义而在代码中直接使用的值）、参数匹配器、断言中的匹配器均有多种的写法，开发者非常容易被误导。<br>使用下面这段代码可以体验不同的匹配方式带来的不同效果。注意，理解在不同情况下对 null 值的处理方式，可以避免很多未知的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List mockedList = mock(List.class);</span><br><span class="line">// 等价 isNull()</span><br><span class="line">when(mockedList.add(eq(null))).thenReturn(false);</span><br><span class="line"></span><br><span class="line">// 这里是在真实调用，传入字面量</span><br><span class="line">System.out.println(mockedList.add(null));</span><br><span class="line"></span><br><span class="line">// 这里是在验证，仍然使用参数匹配器</span><br><span class="line">verify(mockedList).add(isNull());</span><br><span class="line"></span><br><span class="line">// 这里是在断言，使用断言中的匹配器</span><br><span class="line">assertThat(mockedList.get(0), nullValue());</span><br><span class="line">assertThat(mockedList.get(0), equalTo(null));</span><br><span class="line">assertThat(mockedList.get(0), new IsNull());</span><br></pre></td></tr></table></figure><p><a name="mYPp9"></a></p><h3 id="4-2-5-使用-spy-方法">4.2.5 使用 spy 方法</h3><p>如果项目中的对象很多，对所有待测试对象所依赖的对象都进行模拟，工作量会非常大，我们不得不想办法减少相应的工作量。试想，如果对象 B 依赖 A，对象 A 已经通过了单元测试，那么可以认为 A 是可信任的。A 的结果可以在多数情况下直接用于测试，它并不影响测试的正确性。<br>要想实现上述设想，可以使用 spy 方法。spy 方法相当于对被测试对象需要依赖的方法进行代理，在不改变原来的逻辑的情况下，对所依赖的对象进行监听，也可以对部分方法设置预期行为。可以说 spy 方法实现了一种特殊的模拟。其内部实现和 mock 方法类似，可以看作是局部模拟行为。<br>由于被 spy 方法应用的对象往往会有自己的实现，因此可以省去 given 方法。间谍对象依然可以和模拟对象一样被验证，以及给部分方法预置行为。<br>例如，对于 EncryptionService，我们给 sha256 方法一个真实的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public String sha256(String text) &#123;</span><br><span class="line">    MessageDigest md = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        md = MessageDigest.getInstance(&quot;SHA-256&quot;);</span><br><span class="line">        return new BigInteger(1, md.digest(text.getBytes())).toString(16);</span><br><span class="line">    &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 register 的单元测试中，修改 EncryptionService 类的 mock 方法为 spy 方法，并删除 mockedEncryptionService 的 Given 操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EncryptionService mockedEncryptionService = spy(new EncryptionService());</span><br></pre></td></tr></table></figure><p>重新运行测试，可以得到与使用 mock 方法同样的测试结果。使用 spy 方法可以大大减少测试样板代码，避免重复工作。使用 spy 方法就像是一个间谍侵人需要注入的对象观察下游对象的行为，并记录一切，然后在测试完成后汇报他看到的信息一样。<br>应用了 spy 方法的对象也可以被验证，在下面的示例中，仍然可以验证 register 方法确实调用了 sha256 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verify(mockedEncryptionService).sha256(eq(&quot;xxx&quot;));</span><br></pre></td></tr></table></figure><p><a name="NO9mA"></a></p><h3 id="4-2-6-使用注解">4.2.6 使用注解</h3><p>如果每次都编写 mock、spy 方法来创建模拟对象，代码会显得冗长且不易阅读。利用 Java 注解的能力，可以让模拟行为提前自动准备好，在实际工作中，大多数情况下会通过注解完成测试，从而减少测试的代码量。<br>使用注解只需要修改需要被模拟的三个对象，并使用注解代替手动创建即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Mock</span><br><span class="line">UserRepository mockedUserRepository;</span><br><span class="line">@Mock</span><br><span class="line">EmailService mockedEmailService;</span><br><span class="line">@Spy</span><br><span class="line">EncryptionService mockedEncryptionService = new EncryptionService();</span><br></pre></td></tr></table></figure><p>如果只是加上注解，测试方法并不知道这个测试类需要处理注解并初始化模拟行为，因此需要在测试类上添加一个 Runner 让 Mockito 有机会去处理注解。Rumner 中的逻辑运行在所有生命周期钩子的最前面，具有最大的灵活性。<br>我们可在测试类上增加下面的注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(MockitoJUnitRunner.class)</span><br></pre></td></tr></table></figure><p>到目前为止，想要充分利用 Mockito 的特性可以使用 MockitoJUnitRunner，还可以通过 PowerMockRunner 来配合使用 PowerMock，通过 SpringRumner 来配合使用 Spring。我们也可以定义一个基类，在基类上使用 @RunWith 注解修饰，这样就不必在所有的子类中重复定义了。<br>@mock 注解等价于 mock 方法，@spy 注解类似，等价于 spy 方法。拿到模拟对象或间谍对象以后，还需要将模拟出来的对象注入被测试类中才能使用。Mockito 提供了 @InjectMocks 注解来完成这部分工作。@InjectMocks 的注入工作是根据类型来实现的，类似于依赖注人，但如果需要注入一个类的不同实例，注解就无能为力了。<br>使用注解的完整测试代码如下，也可以在 GitHub 上的示例代码仓库中找到此代码段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(MockitoJUnitRunner.class)</span><br><span class="line">public class UserServiceAnnotationTest &#123;</span><br><span class="line"></span><br><span class="line">    @Mock</span><br><span class="line">    UserRepository mockedUserRepository;</span><br><span class="line">    @Mock</span><br><span class="line">    EmailService mockedEmailService;</span><br><span class="line">    @Spy</span><br><span class="line">    EncryptionService mockedEncryptionService = new EncryptionService();</span><br><span class="line"></span><br><span class="line">    @InjectMocks</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void should_register() &#123;</span><br><span class="line">        // Given</span><br><span class="line">        User user = new User(&quot;admin@test.com&quot;, &quot;admin&quot;, &quot;xxx&quot;);</span><br><span class="line"></span><br><span class="line">        // When</span><br><span class="line">        userService.register(user);</span><br><span class="line"></span><br><span class="line">        // Then</span><br><span class="line">        verify(mockedEncryptionService).sha256(eq(&quot;xxx&quot;));</span><br><span class="line">        verify(mockedEmailService).sendEmail(</span><br><span class="line">                eq(&quot;admin@test.com&quot;),</span><br><span class="line">                eq(&quot;Register Notification&quot;),</span><br><span class="line">                eq(&quot;Register Account successful! your username is admin&quot;));</span><br><span class="line">        // 为了验证传入方法的参数是否正确，可以使用参数捕获器ArgumentCaptor来捕获传入方法的参数。</span><br><span class="line">        ArgumentCaptor&lt;User&gt; argument = ArgumentCaptor.forClass(User.class);</span><br><span class="line">        verify(mockedUserRepository).saveUser(argument.capture());</span><br><span class="line"></span><br><span class="line">        assertEquals(&quot;admin@test.com&quot;, argument.getValue().getEmail());</span><br><span class="line">        assertEquals(&quot;admin&quot;, argument.getValue().getUsername());</span><br><span class="line">        assertEquals(&quot;cd2eb0837c9b4c962c22d2ff8b5441b7b45805887f051d39bf133b583baf6860&quot;, argument.getValue().getPassword());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="MbWnS"></a></p><h3 id="4-2-7-其他技巧">4.2.7 其他技巧</h3><p>在使用 Mockito 的时候，还有一些技巧可以用来排错，在遇到问题的时候可能会对我们有帮助。<br><a name="jZpFA"></a></p><h4 id="1-清理模拟状态">1. 清理模拟状态</h4><p>如果需要在一个测试方法中反复设置模拟对象的行为，以及重复验证被模拟的方法是否被调用，但是模拟对象上的状态反复变化会干扰测试，那么可以使用 reset 方法清理掉此状态。<br>当然，一般情况下不必手动清理模拟状态，测试结束后 Mockito 会自动清理。如果在一些测试场景中，必须使用 reset 方法手动清理，也请先考虑是否应该将其拆分成多个不同的测试。<br><a name="OEPRU"></a></p><h4 id="2-获取模拟状态">2. 获取模拟状态</h4><p>使用 Mockito 时，可能会因为错误操作导致模拟不生效，为方便调试，可以打印出模拟对象的信息来探查原因，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EncryptionService mockedEncryptionService = mock(EncryptionService.class);</span><br><span class="line"></span><br><span class="line">given(mockedEncryptionService.sha256(any()))</span><br><span class="line">  .willReturn(&quot;cd2eb0837c9b4c962c22d2ff8b5441b7b45805887f051d39bf133b583baf6860&quot;);</span><br><span class="line"></span><br><span class="line">MockingDetails mockingDetails = Mockito.mockingDetails(mockedEncryptionService);</span><br><span class="line">System.out.println(mockingDetails.isMock());</span><br><span class="line">System.out.println(mockingDetails.getStubbings());</span><br></pre></td></tr></table></figure><p>执行上述代码即可输出当前对象的模拟状态。通过检查输出的结果，我们可以判断参数匹配是否工作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">[encryptionService.sha256(&lt;any&gt;); stubbed with: [Returns:</span><br><span class="line">cd2eb0837c9b4c962c22d2ff8b5441b7b45805887f051d39bf133b583baf6860]]</span><br></pre></td></tr></table></figure><p><a name="EBGiy"></a></p><h4 id="3-使用-Lambda-风格校验参数">3. 使用 Lambda 风格校验参数</h4><p>使用参数捕获来验证下游对象是否正常工作的代码较为冗长，这时可以使用 Matcher 来实现 Lambda 风格的参数校验。原理为参数校验器 argThat 接受一个 ArgumentMatcher 接口的实例，可以使用匿名的方式实现该接口。这个接口只有一个 matches 方法，在 Java 1.8 之后，可以简写为箭头函数，也就是 Lambda 风格的写法。<br>校验 mockedEncryptionService 的 sha256 方法的，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">verify(mockedEncryptionService).sha256(argThat(new ArgumentMatcher&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean matches(String argument) &#123;</span><br><span class="line">        return argument.equals(&quot;xxx&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>改写成 Lambda 后变得非常简洁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">verify(mockedEncryptionService).sha256(argThat(argument -&gt; &#123;</span><br><span class="line">    return argument.equals(&quot;xxx&quot;);</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>甚至可以写成一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verify(mockedEncryptionService).sha256(argThat(argument -&gt; argument.equals(&quot;xxx&quot;)));</span><br></pre></td></tr></table></figure><p>上面的例子可能过于简单无法说明使用 Lambda 表达式进行断言的方便性，更复杂的例子参考示例代码库中 lambda_verify_object_example 测试示例。<br>关于 Mockito 实现的详情可以阅读本书的最后一章，进一步了解这些测试框架和库的源码分析过程。<br><a name="LEW3l"></a></p><h2 id="4-3-增强测试：静态、私有方法的处理">4.3 增强测试：静态、私有方法的处理</h2><p>Mockito 很强大，能帮我们完成大部分模拟工作，但是对于一些特殊的方法它还是无能为力。<br>例如，当我们获取系统当前的时间戳时，可能会调用 System.currentTimeMillis()，但我们无法模拟这个方法。我们有可能会遇到一些有趣的现象，部分测试过了一段时间后就无法通过了，这是因为在实现中可能有对系统时间戳进行检查的逻辑。再比如财务报销单相关的逻辑，费用产生几个月后再进行报销测试就会失败。这是因为我们在初次测试时，使用的模拟数据是一个固定的时间，因此几个月后重新运行相关的单元测试就无法通过了。<br>另外，实际项目中不可避免地需要模拟系统中的静态方法、私有方法，以及对一些私有方法进行测试（虽然不推荐测试私有方法），如果遇到的是遗留系统，public 方法很大，测试的成本非常高，这时也可以采用技术手段测试私有方法。<br>配合 Mockito 使用的另外一个框架是 PowerMock。PowerMock 支持各种模拟框架并对这些框架提供了拓展。powermock-api-mockito 是一个拓展库，它通过拓展 Mockito 并结合 PowerMock 功能来做增强测试，解决模拟静态、私有方法的困难，并在必要时测试静态、私有方法。<br>虽然应尽可能地避免使用 PowerMock 这类对封装性破坏较大的库，但是在特殊的场景下还是可以少量使用，它可以快速解决一些不必要的麻烦，具体视情况而定。PowerMock 主要面向有测试经验的开发人员，尽量不要交给初级的开发人员使用。<br>虽然 PowerMock 和 Mockito 都是通过操作字节码来实现模拟功能的，不过两者在实现上有较大的区别，定位也不一样。Mockito 是通过对被模拟的类进行字节码处理来实现一个代理类的，用于控制预置的所有逻辑。PowerMock 则是对被测试的代码进行处理，通过替换被测试代码的字节码来实现一些高级功能。因此它也额外提供了一些对私有方法、变量访问的功能，可以方便地访问被测试类的内部状态。<br>这部分的示例代码见 <a href="https://github.com//java-self-testing/java-self-testing-example/tree/master/powermock">https://github.com//java-self-testing/java-self-testing-example/tree/master/powermock</a> 。<br><a name="sxjXv"></a></p><h3 id="4-3-1-模拟静态方法">4.3.1 模拟静态方法</h3><p>为了便于演示模拟静态方法的过程，下面会给前面示例中的 User 对象增加 createAt 字段，createAt 字段在 register 方法内被填充，然后进行持久化。<br>更新后的 User 对象如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private String email;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    private Instant createAt;</span><br><span class="line"></span><br><span class="line">    public User(String email, String username, String password, Instant createAt) &#123;</span><br><span class="line">        this.email = email;</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.password = password;</span><br><span class="line">        this.createAt = createAt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并给 user 对象设置对应的值，也就是 Instant.now() 方法的返回值，即系统当前的时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.setCreateAt(Instant.now());</span><br></pre></td></tr></table></figure><p>依据前面的测试可知，这会给测试带来不便，因此需要想办法模拟 Instant.now 这个方法，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(&quot;&quot;, argument.getValue().getCreateAt());</span><br></pre></td></tr></table></figure><p>首先，引入 PowerMock 的相关依赖。PowerMock 有两个模块，一个是对 JUnit 的封装，另外一个是对 Mockito 的封装。它们间接地依赖了 JUnit 和 Mockito，因此可以先把原来的测试依赖移除，再添加这两个依赖。由于 powermock-api-mockito2 对 Mockito 的版本有一定的兼容性要求，所以建议使用下面的方式添加依赖，避免冲突。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.powermock&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;powermock-module-junit4&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.2&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.powermock&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;powermock-api-mockito2&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.2&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>然后，使用 PowerMockRunner 代替 Mockito 的 Runner，并使用 @PrepareForTest 对用到该静态方法的地方进行初始化。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(PowerMockRunner.class)</span><br><span class="line">@PrepareForTest(UserService.class)</span><br></pre></td></tr></table></figure><p>如此，在测试过程中，我们就可以模拟 Instant 类中的静态方法了，并且会影响 UserService 中使用它的地方。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Instant moment = Instant.ofEpochSecond(1596494464);</span><br><span class="line"></span><br><span class="line">PowerMockito.mockStatic(Instant.class);</span><br><span class="line">PowerMockito.when(Instant.now()).thenReturn(moment);</span><br></pre></td></tr></table></figure><p>模拟完成后，Instant.now() 就会按照我们期望的值返回结果，测试代码自然也就可以按照预先设定的值来进行断言了。由于 PowerMock 与 Mockito 能很好地在一起工作，因此可以继续使用 Mockito 的 API 来编写测试。对于特殊的模拟行为，使用 PowerMock 中的语法代替 Mockito 中的语法即可。完整的测试如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(PowerMockRunner.class)</span><br><span class="line">// 使用 PrepareForTest 让模拟行为在被测试代码中生效</span><br><span class="line">@PrepareForTest(&#123;UserService.class&#125;)</span><br><span class="line">public class UserServiceAnnotationTest &#123;</span><br><span class="line"></span><br><span class="line">    @Mock</span><br><span class="line">    UserRepository mockedUserRepository;</span><br><span class="line">    @Mock</span><br><span class="line">    EmailService mockedEmailService;</span><br><span class="line"></span><br><span class="line">    @Spy</span><br><span class="line">    EncryptionService mockedEncryptionService = new EncryptionService();</span><br><span class="line"></span><br><span class="line">    @InjectMocks</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void should_register() &#123;</span><br><span class="line">        // 模拟前生成一个 Instant 实例</span><br><span class="line">        Instant moment = Instant.ofEpochSecond(1596494464);</span><br><span class="line"></span><br><span class="line">        // 模拟并设定期望返回值</span><br><span class="line">        PowerMockito.mockStatic(Instant.class);</span><br><span class="line">        PowerMockito.when(Instant.now()).thenReturn(moment);</span><br><span class="line"></span><br><span class="line">        // Given</span><br><span class="line">        User user = new User(&quot;admin@test.com&quot;, &quot;admin&quot;, &quot;xxx&quot;, null);</span><br><span class="line"></span><br><span class="line">        // When</span><br><span class="line">        userService.register(user);</span><br><span class="line"></span><br><span class="line">        // Then</span><br><span class="line">        verify(mockedEmailService).sendEmail(</span><br><span class="line">                eq(&quot;admin@test.com&quot;),</span><br><span class="line">                eq(&quot;Register Notification&quot;),</span><br><span class="line">                eq(&quot;Register Account successful! your username is admin&quot;));</span><br><span class="line"></span><br><span class="line">        ArgumentCaptor&lt;User&gt; argument = ArgumentCaptor.forClass(User.class);</span><br><span class="line">        verify(mockedUserRepository).saveUser(argument.capture());</span><br><span class="line"></span><br><span class="line">        assertEquals(&quot;admin@test.com&quot;, argument.getValue().getEmail());</span><br><span class="line">        assertEquals(&quot;admin&quot;, argument.getValue().getUsername());</span><br><span class="line">        assertEquals(&quot;cd2eb0837c9b4c962c22d2ff8b5441b7b45805887f051d39bf133b583baf6860&quot;, argument.getValue().getPassword());</span><br><span class="line">        assertEquals(moment, argument.getValue().getCreateAt());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面介绍一下使用 PowerMock 时需要特别注意的地方，从而避免在实际项目中碰到问题。@PrepareForTest 中的参数为一个被处理的目标类，这个类不是被模拟的类，而是被测试的类（业务代码），目的是让被测试代码中的特殊模拟生效。例如，在上面的示例子中，被测试的类是 UserService，我们需要模拟的是 Instant.now 方法，这个方法要在 UserService 中使用，因此我们需要处理的类是 UserService 而不是 Instant。这是使用 PowerMock 的过程中最常见的一个陷阱，原因是静态方法是类级别的方法，需要在被测试类加载前准备完毕。想要特殊模拟在被测试代码中生效，就需要使用 @PrepareForTest 进行处理。具体的实现是在 PowerMockRunner 中完成的，其中用了很多字节码级别的技术，想要关心具体实现的读者可以参考源码。<br>上面的例子中，我们不需要验证 Instant.now 方法的调用情况。如果在某些情况下需要验证静态方法，可以使用 PowerMock 的 verifyStatic 方法重新加载修改后的类，然后进行验证。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PowerMockito.verifyStatic(Static.class);</span><br><span class="line">Static.thirdStaticMethod(Mockito.anyInt());</span><br></pre></td></tr></table></figure><p>需要注意的是，每次验证都需要调用 verifyStatic，因为这两句代码是成对出现的。<br><a name="e3kqy"></a></p><h3 id="4-3-2-模拟构造方法">4.3.2 模拟构造方法</h3><p>有时候被测试的代码中可能会直接使用 new 关键字创建一个对象，这种情况就不太好隔离被创建的对象了。如果不使用 PowerMock，甚至这段代码都不能被测试。对此，有两个途径可解决：一是使用工厂方法进行解耦，即用依赖注入代替直接使用 new 关键字：另一种方式是使用 PowerMock 对构造方法进行模拟。<br>第一种方法相当于修改被测试的代码，在重构时这样做不太安全，因此可以考虑使用第二种方法。在 PowerMock 中使用 whenNew 这个方法可以拦截构造方法的调用，直接返回其他对象或者异常。对构造方法进行模拟是 PowerMock 中最常用的特性之一。<br>如果在处理一个遗留系统时，在 UserService 中的 register 方法中发现了这样一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void register(User user) &#123;</span><br><span class="line">    user.setPassword(encryptionService.sha256(user.getPassword()));</span><br><span class="line">    user.setCreateAt(Instant.now());</span><br><span class="line"></span><br><span class="line">    userRepository.saveUser(user);</span><br><span class="line"></span><br><span class="line">    sendEmail(user);</span><br><span class="line"></span><br><span class="line">    // 代码中有一个直接被 new 出来的对象，让这个方法无法被轻易模拟</span><br><span class="line">    (new LogService()).log(&quot;finished register action&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么可以使用 whenNew 方法传入一个准备好的模拟对象，以此替换原有的实现，从而达到可测试的目的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Given</span><br><span class="line">User user = new User(&quot;admin@test.com&quot;, &quot;admin&quot;, &quot;xxx&quot;, null);</span><br><span class="line"></span><br><span class="line">LogService mockedLogService = mock(LogService.class);</span><br><span class="line">whenNew(LogService.class).withNoArguments().thenReturn(mockedLogService);</span><br><span class="line"></span><br><span class="line">// When</span><br><span class="line">userService.register(user);</span><br><span class="line"></span><br><span class="line">// Then </span><br><span class="line">Mockito.verify(mockedLogService).log(any());</span><br></pre></td></tr></table></figure><p>使用 Mockito 准备一个模拟对象，在 new 语句执行时，PowerMock 会将这个模拟对象返回，这样后续的断言就可以得到保障，把不可测的代码变成了可测试的代码。<br>自然地，如果需要验证构造方法是否被调用，可以使用 verifyNew(LogService.class). withNoArguments()。<br><a name="bwOUe"></a></p><h3 id="4-3-3-模拟私有方法">4.3.3 模拟私有方法</h3><p>与前面的问题类似，在进行重构时，我们发现类中有一些特别长的私有方法，这些私有方法比较复杂，使得测试成本很高。<br>一种解决方式是通过重构将这些私有方法搬到另外一个类中，使得类的私有方法数量处于较少的状态。另外一种是通过 PowerMock 对私有方法进行模拟操作。使用 PowerMock 模拟私有方法非常简单，只需要使用 PowerMockito 类中的 when 方法代替 Mockito 中的同名方法即可。因为直接调用私有方法会出现 Java 语法报错，所以 PowerMockito 类中的 when 方法提供了与 Mockito 类似的 API，但是它的方法名需要以字符串作为额外的参数传人。<br>假如 LogService 对象中有一个私有方法 _log 用于发送日志到日志平台，由于一些基础设施的原因导致测试失败，那么可以使用 PowerMock 将其隔离，让其他的测试逻辑正常进行。<br>下面的示例代码演示了如何使用 PowerMock 模拟私有方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class LogService &#123;</span><br><span class="line">    public void log(String content) &#123;</span><br><span class="line">        _log(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void _log(String content) &#123;</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的代码用于当 _log 被调用时不让其有副作用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(PowerMockRunner.class)</span><br><span class="line">@PrepareForTest(&#123;LogService.class&#125;)</span><br><span class="line">public class PrivateTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void private_test() throws Exception &#123;</span><br><span class="line">        LogService logService = mock(LogService.class);</span><br><span class="line">        PowerMockito.doNothing().when(logService, &quot;_log&quot;, any());</span><br><span class="line"></span><br><span class="line">        logService.log(&quot;test data&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是需要注意的是，处理私有方法时要处理以下两个对象：被模拟的对象和被测试的对象。在前面的例子中，UserService 是被测试的对象，LogService 是需要被模拟的对象。如果是 LogService 中的私有方法需要被隔离掉，@PrepareForTest 中的参数则应该设置为 LogService 而不是 Userservice。同理，如果 UserService 中有一个私有方法，我们想做一些处理，该怎么办呢？首先，需要将 @PrepareForTest 的参数设置为 UserService，其次，由于 UserService 是被测试对象，无法应用 when 方法，因此需要使用 spy 方法包装处理。<br><a name="VLseG"></a></p><h3 id="4-3-4-反射工具箱">4.3.4 反射工具箱</h3><p>如果一个被测试对象有一个私有属性，但是由于某些原因无法赋予模拟对象，导致测试困难，那么可以使用反射方式修改它的可访问性。例如，某 Person 类上有一个私有属性 name，现在需要为其赋予一个新的值，那么可以像下面这样编写代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person person = new Person();</span><br><span class="line">Class&lt;?&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line">Field field = clazz.getDeclaredField(&quot;name&quot;);</span><br><span class="line">field.setAccessible(true);</span><br><span class="line">// 赋值</span><br><span class="line">field.set(person, &quot;new name&quot;);</span><br></pre></td></tr></table></figure><p>上述代码比较烦琐，Mockito 和 PowerMock 都提供了一组反射工具类，用于访问私有成员，比 Java 本身的反射能力要强一些。<br><a name="XyYCY"></a></p><h4 id="1-访问私有属性">1. 访问私有属性</h4><p>比如，我们在 LogService 中增加了一个 prefix 属性，用于打印日志的前缀，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private String prefix = &quot;warning: &quot;;</span><br><span class="line">...</span><br><span class="line">private void _log(String content) &#123;</span><br><span class="line">  System.out.println(prefix + content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么使用 Mockito（非 PowerMock）的 FieldSetter 工具类可以直接修改私有属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LogService logService = new LogService();</span><br><span class="line">FieldSetter.setField(</span><br><span class="line">        logService, LogService.class.getDeclaredField(&quot;prefix&quot;),</span><br><span class="line">        &quot;error: &quot;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">logService.log(&quot;test data&quot;);</span><br></pre></td></tr></table></figure><p><a name="kbA1R"></a></p><h4 id="2-测试私有方法">2. 测试私有方法</h4><p>如果我们遇到某个私有方法时，想要测试它，一种比较好的方法是将私有方法修改为包级别私有，并将测试代码放到同一个包下，但是它处于 test 目录下（比如，待测试的私有方法位于 src/main/java 中，测试代码位于 src/test/java 中），这样测试代码就能访问到该方法了。<br>另外一种方法是，使用一些辅助工具，例如，使用 PowerMock 中的 Whitebox 类等，提供对私有方法、属性的访问。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Whitebox.invokeMethod(testObj, &quot;method1&quot;, new Long(10L));</span><br></pre></td></tr></table></figure><p>大部分情况下建议避免使用反射方式，因为它会大大破坏封装性。不过，在处理遗留系统时，如果因为没有测试保护而不敢贸然修改源代码，且遗留系统中会有很多代码不具备可测试性，那么可以酌情使用这类方法添加一些测试守护重构。<br>对于新实现的代码，如果出现了需要用到反射才能完成测试的情况，则说明代码中存在坏味道，需要及时处理。<br><a name="DfrOQ"></a></p><h2 id="4-4-测试代码的结构模式">4.4 测试代码的结构模式</h2><p>使用测试替身后，测试代码的结构会变得有些复杂，对于如何良好地组织测试代码的结构，一些专家也总结了几种模式。<br><a name="FPEAB"></a></p><h3 id="4-4-1-准备-执行-断言">4.4.1 准备 - 执行 - 断言</h3><p>准备 - 执行 - 断言（Arrange-Act-Assert）是一种主流的单元测试代码结构模式，它非常类似 “三段论” 的文章结构：</p><ul><li>准备：准备测试数据、模拟依赖对象、初始化测试状态（如果有的话）。</li><li>执行：对测试目标进行调用，执行相关方法和逻辑。</li><li>断言：验证执行的结果是否满足预期，包括进行断言、对 Mock 中的下游对象参数进行验证等。</li></ul><p>其实从本章的开始，我们就是按照这种结构来介绍单元测试的，每个测试方法基本具有类似的结构。在 BDD 中，Given…When…Then 的语法结构也与之类似。<br>在敏捷开发中，用户故事可以认为是一个功能特性单位，评价一个用户故事是否完成，可以使用多个验收条件。验收条件可以看作功能测试的测试用例，单元测试只不过是其微观形态。<br>这种模式非常简单，很容易和团队达成一致，从而写出结构合理、统一的单元测试来。<br><a name="Cx1vR"></a></p><h3 id="4-4-2-四阶段测试">4.4.2 四阶段测试</h3><p>四阶段测试（Four-Phase Test）是准备-执行-断言的拓展，该模式描述了创建简洁、可读且结构良好的测试需要具备如下4个阶段。</p><ul><li>设置：建立测试的先决条件，包括模拟依赖对象、准备测试数据。</li><li>执行：对系统做一些事情，对测试目标进行调用。</li><li>验证：检查预期结果，断言和对模拟对象中的下游对象参数进行验证。</li><li>清理：测试结束后将被测系统恢复到初始状态。</li></ul><p>看起来和准备-执行-断言模式类似，对吧？其实只是对它做了一些补充，对测试各部分的职责进行了划分，越来越多的测试框架也在参考这种模式的实现。<br>在 JUnit 中，@Beforexxx 方法中可以实现一些通用的准备工作，因此可以将其视作设置的一部分。前面提到过另外一个概念 Fixture，此概念在很多测试中都能看到，翻译为中文是测试夹具或测试工具类，意思是在设置阶段进行的通用的准备工作（封装为测试 Fixture）。<br>JUnit 的 @Afterxxx 方法对应的是清理工作，大部分情况下可以自动处理。图 4-3 展示一个测试类（一般也是一个测套件）和多个测试之间的关系。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712881877731-c5f0409d-0f5f-4183-893e-93a9a897c0d8.png#clientId=ude3f3669-5424-4&amp;from=paste&amp;id=uf2bb5037&amp;originHeight=418&amp;originWidth=926&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=31897&amp;status=done&amp;style=none&amp;taskId=u8034fbe5-9fd8-4bf1-acd1-d37c328c8a5&amp;title=" alt="image.jpg"><br>图 4-3 测试代码的结构<br><a name="MWKHX"></a></p><h2 id="4-5-基于测试替身的反思">4.5 基于测试替身的反思</h2><p>使用测试替身编写测试，会驱使我们去思考如何设计出更好的业务代码结构。通常情况下，人们容易对他人严苛，对自己宽容，但编写测试的时候是难得的对自己 “严苛” 的时候。可测试的业务代码一般都具有清晰的层次结构。<br><a name="KfQuA"></a></p><h3 id="4-5-1-“大泥球”">4.5.1 “大泥球”</h3><p>“大泥球” 是一个用来比喻糟糕的软件设计的术语。一份不经过设计、随意堆砌的代码，没有清晰的结构特征，就像一个泥球一样，毫无结构可言。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">所谓的大泥球就是一个随意结构化、蔓延的、不经心的、意大利面条式的代码混合体。系统展现了无可争议的表象：不受管制的增长、重复、权宜之计的修补。信息被系统中相距很远的模块杂乱地共享，重要信息常变为全局的或者重复的。</span><br><span class="line"></span><br><span class="line">———— Brian Foote &amp; Joseph Yoder</span><br></pre></td></tr></table></figure><p>产生 “大泥球” 的原因可能有：</p><ul><li>开发者往往只是关注如何编写代码，而不是关注设计。由于缺乏前期的设计，遇到问题或者新特性时直接进行碎片式的修改，让代码变得混乱和混沌。</li><li>用户的需求发生变化，但是架构的演进没有跟上，系统变得越来越复杂，维护也变得越来越昂贵。</li><li>开发者受设计能力的制约。</li></ul><p>“大泥球” 的代码非常难测试，这些代码往往源自一些遗留系统，需要使用大量的测试替身技巧才能勉强编写出一些测试来保护代码。<br>为了解决 “大泥球” 的问题，除了使用面向对象的 SOLID 原则增强设计和开发以外，还需要注意使用 “编排和复用分离” 的技巧。有的时候，我们无论让方法分解得多小，都很难绝对地消除重复，或者消除重复的代价是又造成了其他方面的耦合。这时，根据代码的职责进行简单的划分，就可以让其职责变清晰，比如，我们可以将代码分为编排逻辑和复用逻辑。<br>编排逻辑指的是用于组织原子方法的逻辑，例如用户在注册时会组合调用存储、发送邮件、加密等方法，就可以看作是编排逻辑。编排逻辑关注于场景，而非具体的事情。对于编排逻辑来说，重复优于复用。因为编排本身具有业务含义，如果复用编排逻辑会让这些业务含义混合在一起，那么这种复用并没有带来好处。此外，编排相关的方法彼此之间也不应该互相调用。<br>复用逻辑指的是可以被多个场景使用的通用逻辑，例如发送邮件时，只需要关注发送邮件这个动作即可，至于发送之后是否需要存储，则交由编排逻辑来处理。<br>在进行单元测试时，复用逻辑几乎不需要使用测试替身，因为它足够原子化：编排逻辑则需要使用大量的测试替身，好在这其中没有多少逻辑，所以单元测试也还是比较容易实现。另外，E2E 测试应该更关注编排逻辑这一部分，如果单元测试处理这部分逻辑的成本过高，也可以交给 E2E 测试。<br><a name="hezUr"></a></p><h3 id="4-5-2-分层过多">4.5.2 分层过多</h3><p>另外一种代码结构也会让测试变得困难，就是分层过多的代码结构。这种代码可能存在过度设计，比如，一个简单的功能由 3～4 层代码实现。如果根据分层进行单元测试，会造成测试和替身数量远远多于源代码。<br>分层过多主要是因为设计者没有清晰地认识每个类的职责，他认为分层越多越清晰。实际上，这种做法反而让代码的可读性下降了。因为阅读者往往需要追溯非常多的方法才能找到真正实现业务逻辑的地方。<br>分层过多的问题如何解决？这取决于设计者对业务逻辑的认知，另外也可以借鉴一些思维方法。通过认识论我们知道，对于现实世界中的一个行为，我们可以基于 “主体” 和 “客体” 来进行分析。也就是说，在现实世界中，主体通过操作客体来完成一项任务。而在面向对象中，具有行为的 Service 通常会操作一些 Entity、DTO 等具有属性和数据的对象，它们之间也构成了主客关系。<br>在分层设计中，首先需要弄清楚 “主体” 类的职责是什么，如果某些 “主体” 类的职责一致或者类似，则应该考虑合并。<br><a name="feeNp"></a></p><h3 id="4-5-3-滥用测试替身">4.5.3 滥用测试替身</h3><p>过多地使用测试替身也会带来问题，比如，封装性会受到破坏，测试代码比业务代码还长很多，在这种情况下，不使用测试替身反而会更加简单和高效。<br>滥用测试替身会带来如下问题。</p><ul><li>测试难以理解。过于复杂的模拟行为让测试代码变得极其难以理解，尤其是具有全局状态再配合模拟行为的测试。复杂的测试有可能会让不熟悉代码的开发者花上一整天的时间来修复出现的问题，极大地降低了开发效率。</li><li>重构成本增加。如果重构的目标代码里包含具有测试替身的测试代码，那么会导致一系列测试需要重新修改。</li></ul><p>滥用测试替身往往是为了追求完美的单元测试覆盖率，比如试图让单元测试达到 100%，从而想尽办法进行极端的模拟。事实上，在编写测试代码之前，应该先和团队达成一定的共识，优先覆盖最重要的逻辑，为真正需要测试的地方添加单元测试。<br><a name="jGi3q"></a></p><h2 id="4-6-小结">4.6 小结</h2><p>本章介绍了什么是测试替身，以及如何使用测试替身来让单元测试更为简单。在实际工作中，被测试的代码不一定容易被模拟和测试。通过关注前期设计、变更适配需求让代码具有很好的测试性，在实际开发过程中是非常重要的一件事。<br>当我们确实需要对私有方法进行测试以及行为模拟时，可以使用 PowerMock 对私有方法进行模拟和验证，并使用反射工具（例如 Whitebox、FieldSetter 等）来访问私有属性和方法。<br>当我们的测试变得非常复杂时，团队成员需要就测试代码的组织结构达成契约，这时，可以参考一些测试代码的结构模式。通过遵循同样的编写风格和模式，可以让团队中的代码风格更统一，提高开发效率和体验。<br>最后介绍了如何通过单元测试来感受源代码的设计质量，以及如何通过测试替身的实现难度来反思代码设计中的一些问题。<br>我们应该避免使用 “大泥球” 样的代码结构，在设计代码时，也要注意免去不必要的分层，当然更不能滥用测试替身，以免降低测试的可阅读性和可维护性。</p><blockquote><p>来自: <a href="https://java-self-testing.github.io/java-self-testing-book/04-testing-doubles/">第 4 章 测试替身 - 《Java 研发自测》</a></p></blockquote><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;测试替身是单元测试中非常有用的一个概念，用来隔离组件之间的依赖关系，让不可测试的组件变得可以测试。&lt;br&gt;
曾听很多朋友说，测试替身这个概念非常难理解，它有种浓浓的翻译味。我一直在尝试找一个合适的类比来说明这些概念，直到有一次我家的灯泡坏了，我带着这个灯泡到一家五金店购买新</summary>
      
    
    
    
    <category term="测试" scheme="http://www.bojiboqi.fun/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="spring测试" scheme="http://www.bojiboqi.fun/tags/spring%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>第 5 章 Spring 应用的测试 - 《Java 研发自测》</title>
    <link href="http://www.bojiboqi.fun/2024/04/22/%E7%AC%AC%205%20%E7%AB%A0%20Spring%20%E5%BA%94%E7%94%A8%E7%9A%84%E6%B5%8B%E8%AF%95%20-%20%E3%80%8AJava%20%E7%A0%94%E5%8F%91%E8%87%AA%E6%B5%8B%E3%80%8B/"/>
    <id>http://www.bojiboqi.fun/2024/04/22/%E7%AC%AC%205%20%E7%AB%A0%20Spring%20%E5%BA%94%E7%94%A8%E7%9A%84%E6%B5%8B%E8%AF%95%20-%20%E3%80%8AJava%20%E7%A0%94%E5%8F%91%E8%87%AA%E6%B5%8B%E3%80%8B/</id>
    <published>2024-04-22T06:29:11.007Z</published>
    <updated>2024-04-22T23:25:24.823Z</updated>
    
    <content type="html"><![CDATA[<p>为了更好地理解 Spring 相关的测试内容，这里延续前面购买灯泡的类比。在现代社会中，人们大都使用一些具有装饰性或者功能性的灯具。在这种灯具中，灯泡有可能被放到某个灯槽中，或者被包裹在富有艺术感的金属材料里面。因此，我们也就不得不按照厂商的要求来测试或者组装，以实现相应的功能。<br />软件开发也是一样，掌握了 JUnit 和 Mockito 的相关知识后，虽然可以编写大部分测试，但是如果项目中使用了 Spring，它独特的依赖注入方法还是可能会让我们有些无所适从。客观地说，测试需要与业务代码所处的生态环境相结合，这是无法逃避的事实，我们得想办法解决它。<br />Java 开发中目前最流行的体系就是 Spring 生态，日常工作中需要结合 Spring 来实现的测试需求非常多，而且比较重要，但大部分讲解单元测试或 TDD 的图书都很少涉及 Spring 相关知识。基于此，本章将围绕 Spring、Spring Boot 来讲解如何编写单元测试，目标是在 Spring Boot 这种主流的 Spring 框架下，充分利用其技术体系来完成测试（不一定只是单元测试）。<br />我在写这章内容时使用的 Spring Boot 版本是 2.4，在该版本中，对应的单元测试框架已经是 JUnit 5，因此，从本章开始会将 JUnit 版本切换到 JUnit 5。如果读者不熟悉 JUnit 5，可以到第 3 章查看 JUnit 4 和 JUnit5 的区别。<br />本章涵盖的内容有：</p><ul><li>Spring 测试的配置。</li><li>分层测试。</li><li>测试工具集。</li></ul><p>值得注意的是，从本章开始，将会慢慢脱离单元测试的范围，在将依赖注入容器、技术设施等组件结合到一起后，我们的测试会更加 “接地气”，也不再是纯粹的单元测试了。<br />本章示例代码见 <a href="https://github.com/java-self-testing/java-self-testing-example/tree/master/spring">https://github.com/java-self-testing/java-self-testing-example/tree/master/spring</a>。<br><a name="NWHva"></a></p><h2 id="5-1-理解-Spring-测试体系">5.1 理解 Spring 测试体系</h2><p>在 Spring 技术体系下编写单元测试，有时候会觉得概念比较混乱，难以理解。试着从网上找一些代码贴上去，不知道为什么程序就工作了，出现问题自然也不知道要怎么解决。Spring 的每一个子项目（组件）的测试模块都会提供相应的测试工具，比如 Spring 对应的有 Spring Test 模块，Spring Boot 对应的有 Spring Boot Testing 模块。对于刚刚开始依赖这些包编写测试的开发者来说，有时分不清哪些类来自哪个包，很容易感到困惑。<br />图 5-1 是 Spring 的生态体系和对应的测试体系的包关系图。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712881898780-ed718949-24e5-418e-85ec-7504d48aed01.png#clientId=u61f6852d-71c7-4&amp;from=paste&amp;id=u44ea4497&amp;originHeight=728&amp;originWidth=1246&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=75095&amp;status=done&amp;style=none&amp;taskId=u6c1da6c2-6e27-400c-a718-ff4140a6f1f&amp;title=" alt="image.jpg"><br />图 5-1 Spring 生态和测试体系<br />图 5-1 的左边给出了 Spring 生态下常用的包，具体说明如下。</p><ul><li>spring-core 是一个依赖注入库，通过依赖注人功能管理各种类。</li><li>spring-mvc 提供了与 Web 服务器编程相关的功能及 MVC 模式的实现。</li><li>spring-security-core 是安全框架的核心包，提供了相关的过滤器来实现 Web 安全和鉴权。</li><li>spring-boot 是 Spring 生态的脚手架，它是真正意义上的框架，用于集成整个 Spring 生态体系，通过 spring-boot-autoconfigure 来实现自动化的配置，这样我们就不用自己配置了。</li><li>spring-boot-starter 发布了各种依赖的 Pom 集合，方便将各种依赖包引入项目中。</li></ul><p>图 5-1 的右侧是上述包提供的相应测试模块，以及用于测试的工具。比如，spring-test 提供了用于单元测试的 Runner，MockMvc 相关的类（spring-mvc 属于 Spring Framework，没有单独的测试模块）；spring-boot-test 提供了 @SpringBootTest 这类自动化配置的注解及自动化测试配置；spring-security-test 提供了一些模拟用户的工具。<br />除了 Spring 体系下的这些包，我们还可能会用到其他一些工具，这些工具于不同的层次提供不同的功能：</p><ul><li>JUnit：作为单元测试工具它已经成为 Java 单元测试事实上的标准。</li><li>Hamcrest：JUnit 内置的依赖的断言库。</li><li>AssertJ：流式断言库。</li><li>Mockito：模拟工具，用于实现测试替身。</li><li>JSONassert：用于断言 JSON 节点，做 API 测试时用得比较多。</li><li>JsonPath：可以通过 XPath 语法访问 JSON。</li></ul><p>虽然 Spring Boot 也能用于实现命令行、桌面工具的开发（比如 JavaFX 可以和 Spring Boot 结合开发桌面应用），但它主要应用于服务端应用开发，所以大部分相关的测试工具都是为服务端开发准备的。总地来说，我们讨论 Spring Boot 的时候，应该将更多的关注放在服务端应用开发上。<br />在实际项目中，可以有以下测试类型：</p><ul><li>只使用 JUnit 就可以测试的简单对象、静态方法类。</li><li>启动 Spring 上下文来进行测试。如果被测试对象是纳入 IOC 容器管理的 Bean 对象， 需要使用 Spring Test 的 Runner+Mockito 隔离被测试的对象，虽然这时需要启动 Spring 上下文，但是容器中只放了必要的被测试对象，因此仍然可以看作是单元测试。</li><li>启动 Spring Boot 上下文来进行测试。例如想要测试 Controller 是否能真正反馈我们 需要的响应，可以使用 Spring Boot Test 这个框架启动一个模拟的 Spring Boot 上下文，不过这接近于集成测试，Spring Boot 文档中也将这部分内容划分为集成测试了。</li></ul><p>这三种测试类型，测试的粒度由低到高，测试运行的时间也是由少到多。我们需要尽可能地选用低成本的测试方法，在缩短测试运行时间的同时减少样板代码。<br />如果需要在 Spring Boot 项目加入测试依赖，只需要引入 spring-boot-starter-test 包即可。spring-boot-starter-test 基本上引入了需要用到的所有测试功能，已经间接依赖了 JUnit、Mockito，开箱即用。<br />至于测试需要使用的其他依赖包，则需要单独添加，在后面的示例中也会逐步补充说明。由于 Spring 使用的是统一的依赖版本管理器，因此不需要为 Spring 组件设置版本，如果希望和本书的代码保持一致，可以选择 2.4 系列的版本。如果是已经存在的项目，加入下面的依赖到 Pom 文件中即可开箱使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>上面介绍了 Spring 下的三种测试类型，对于只使用 JUnit 就可以测试的简单对象、静态方法类，直接使用 JUnit 和 Mockito 完成测试即可，无须再讨论。下面聊聊如何使用 Spring 容器加载 Bean 进行单元测试和全量启动 Spring Boot 的自动化测试配置。<br><a name="XkIFR"></a></p><h2 id="5-2-启动-Spring-上下文测试">5.2 启动 Spring 上下文测试</h2><p>假设有一个简单的 Spring Boot 后端 Web 项目，里面包含 Controller、Service、Entity、Mapper 等分层和模块。为了接近国内主流开发风格，其中的持久化库选择了 MyBatis。图 5-2 为示例代码的包结构图。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712881898770-5b11ebfa-bc6d-49e7-b4b4-6a06018b3d04.png#clientId=u61f6852d-71c7-4&amp;from=paste&amp;id=u993bed96&amp;originHeight=922&amp;originWidth=638&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=91360&amp;status=done&amp;style=none&amp;taskId=ufc12cfb9-759f-42d6-ab6d-9c87b8b6b54&amp;title=" alt="image.jpg"><br />图 5-2 示例代码的结构<br />一般来说，主要逻辑都会写在 Service 中，因此，Service 也就成了我们的主要测试目标。下面将对其编写测试。<br />UserService 中的主要逻辑用于实现添加用户、列出用户等功能，UserService 依赖于 UserMapper，如果只是测试 UserService，然后模拟依赖的 Mapper 其实非常容易，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">    public static final String KEY = &quot;ea416ed0759d46a8de58f63a59077499&quot;;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    public User add(User user) &#123;</span><br><span class="line">        user.setCreateAt(Instant.now());</span><br><span class="line">        user.setUpdateAt(Instant.now());</span><br><span class="line">        user.setPassword(hash(user.getPassword()));</span><br><span class="line">        userMapper.insert(user);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;User&gt; listAll() &#123;</span><br><span class="line">        return userMapper.selectAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String hash(String text) &#123;</span><br><span class="line">        return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, KEY).hmacHex(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Spring 中，常规的做法是使用 @Autowired 注解来注入依赖的 UserMapper，并将其设置为私有属性。这时需要模拟 UserMapper，但由于出现了私有成员，因此无法直接使用 Mockito 进行模拟。<br />在测试替身部分，我们提供了一些方法来解决私有成员的模拟问题。可以使用 PowerMock 或者反射工具来实现模拟，比如 FieldSetter。在 Spring Test 的工具集中还可以使用 Reflection-TestUtils 实现类似的效果。<br />也可以使用 Spring 的构造方法来注入新模拟的对象，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private final UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">public UserService(UserMapper userMapper) &#123;</span><br><span class="line">    this.userMapper = userMapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要被依赖的对象非常多的时候，这样编写代码会稍稍有点麻烦，也无法解决与 @Value 等类似的注解问题。对于这种情况，在 Spring 中可以使用 SpringExtension 来运行测试，并集成 Spring 的依赖注入功能。<br />注意：在单元测试部分我们提到了，JUnit 5 中 Runner 被替换成了 Extension，注解 @RunWith 也被替换成了 @ExtendWith。<br />下面创建一个 UserServiceTest 测试并使用 SpringExtension 作为测试的 JUnit 拓展。由于这个拓展初始化了 Mockito 注解的相关行为，因此可以实现与 MockitoExtension 相似的功能，此外，它还提供了与 Spring 结合更为紧密的其他功能。<br />创建的基础测试环境如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ExtendWith(SpringExtension.class)</span><br><span class="line">public class UserServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @InjectMocks</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @Mock</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面添加 2 个测试，用来测试列出、添加用户这两个功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void should_list_users() &#123;</span><br><span class="line">  userService.listAll();</span><br><span class="line">  Mockito.verify(userMapper).selectAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void should_add_user() &#123;</span><br><span class="line">  User user = new User() &#123;&#123;</span><br><span class="line">    setUsername(&quot;zhangsan&quot;);</span><br><span class="line">    setPassword(&quot;123456&quot;);</span><br><span class="line">  &#125;&#125;;</span><br><span class="line"></span><br><span class="line">  userService.add(user);</span><br><span class="line"></span><br><span class="line">  ArgumentCaptor&lt;User&gt; argument = ArgumentCaptor.forClass(User.class);</span><br><span class="line">  Mockito.verify(userMapper).insert(argument.capture());</span><br><span class="line"></span><br><span class="line">  assertEquals(&quot;zhangsan&quot;, argument.getValue().getUsername());</span><br><span class="line">  assertEquals(&quot;667f1213e4a57dbee7cd9e8993b82adef1032f7681a5d5c941c30281f90e7eceba629cc9ccf3f133fb478f3f54d9537c2dd50895380f659370c2a14147449ac4&quot;, argument.getValue().getPassword());</span><br><span class="line">  assertNotNull(argument.getValue().getCreateAt());</span><br><span class="line">  assertNotNull(argument.getValue().getUpdateAt());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，一组基本的测试就完成了。在大多数情况下，使用 SpringExtension＋Mockito 能完成大部分的测试工作。SpringExtension 起到了与 MockitoExtension 类似的功能，又能与 Spring 依赖注入一起使用，非常适合 Service 的测试工作。<br />SpringExtension 是 spring-test 模块中的类，到目前为止，我们引入的相关库与 Spring Boot 还没有任何关系，因此这里也不会启动整个上下文，几乎不会影响测试效率。<br />在 JUnit 4 中，测试不是通过 Extension 运行的，只需要将 @ExtendWith（SpringExtension. class）替换为 @RunWith（SpringRunner.class）即可实现兼容。SpringRunner 是 SpringJUnit4 ClassRunner 的子类，它是一个 final 类，不能被继承用于拓展。如果希望拓展 Runner，可以直接使用 SpringJUnit4ClassRunner 或者拓展 SpringJunit4ClassRunner 类来实现。<br><a name="Ke4FF"></a></p><h2 id="5-3-启动-Spring-Boot-上下文测试">5.3 启动 Spring Boot 上下文测试</h2><p>使用 SpringExtension 后即可使用 @Autowired 来加载其他的对象，这是 Spring Test 框架提供的功能。我们知道，Spring Boot 的作用是实现自动化配置，通过自动化配置可定义大量的 Bean。<br />如果仅仅要测试 Service 的逻辑而模拟 Mapper，看起来好像无法验证数据是否被真正地写入数据库中了，这样的测试显得很鸡肋。于是人们想到，既然可以将 Service 和 Mapper 一起测试，为何不启动 Spring Boot 呢？<br><a name="wtobQ"></a></p><h3 id="5-3-1-SpringBootTest">5.3.1 @SpringBootTest</h3><p>既然启动 Spring Boot 上下文就可以使用 Spring Boot 完整的功能进行测试，那么需要模拟的东西自然相对较少，因为 @SpringBootTest 帮我们启动了 Spring MVC、初始化数据库连接、日志等一系列配置。<br />利用上述特性，UserServiceTest 就不用模拟 UserMapper 了，Spring Boot Test 会自动完成一系列配置，以进行更真实的测试。<br />在 test 目录下，创建与 Application 路径相同的包和一个测试类，使用 @SpringBootTest 修饰这个测试类。由于 @SpringBootTest 中已经默认包含了 @ExtendWith（{SpringExtension. class}），因此可以省略这一行注解，但在 JUnit4 中依然需要用到 @RunWith 注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">public class ApplicationTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void should_list_users() &#123;</span><br><span class="line">        userService.listAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void should_add_user() &#123;</span><br><span class="line">        User user = new User() &#123;&#123;</span><br><span class="line">            setUsername(&quot;zhangsan&quot;);</span><br><span class="line">            setPassword(&quot;123456&quot;);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line"></span><br><span class="line">        userService.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>userService 是这个上下文中真实的对象，在上述代码中，@SpringBootTest 会创建依赖的 UserMapper，以便我们访问数据库。上面的例子只是验证了被测试的代码能否运行，还没有断言，我们可以增加一些测试数据进行断言。<br />严格来说，这种测试不算单元测试。虽然测试程序的起点是 Service，但是我们并没有模拟 Mapper，而是使用了真实的 Mapper 将数据写入内存数据库中。整个过程会加载所有需要用到的 Bean，会启动全部的上下文，一般这种配置方式会用于 E2E 测试。<br />在持久库选择了 MyBatis 的情况下，为了处理 MyBatis 相关的配置，我们需要使用 mybatis-spring-boot-starter 包和 H2 内嵌数据库，在 Pom 文件中加入相关的依赖即可实现，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.h2database&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;h2&lt;/artifactId&gt;</span><br><span class="line">  &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>mybatis-spring-boot-starter 在这里用于处理与 Mapper 相关的逻辑，H2 充当了内存数据库，Starter 则会根据环境需要自动进行配置。<br />由于这种方式没有模拟依赖的对象，因此不能进行断言，需要直接获取并判断数据库的数据（如果是 API 测试，可以通过 API 查询来进行验证）。<br />Spring Test 框架提供了一个简单但是常用的类 JdbcTestUtils，该类可以使用 JdbcTemplate 来统计和操作数据库表。当执行添加用户的操作时，可以使用 JdbcTestUtils 统计数据库用户表记录行数来进行断言。也可以通过 JdbcTemplate 查询具体的数据来进行验证，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void should_add_user() &#123;</span><br><span class="line">    User user = new User() &#123;&#123;</span><br><span class="line">        setUsername(&quot;zhangsan&quot;);</span><br><span class="line">        setPassword(&quot;123456&quot;);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    userService.add(user);</span><br><span class="line">    int count = JdbcTestUtils.countRowsInTable(jdbcTemplate, &quot;user&quot;);</span><br><span class="line">    assertEquals(1, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要说 @SpringBootTest 启动了全部的上下文环境也不算对，默认情况下，@SpringBootTest 没有启动 Web 服务器，只是启动了应用上下文和模拟的服务器环境。通过 webEnvironment 属性可以修改设置，启动随机端口、固定端口的 Web 服务器，或者彻底不使用 Web 环境。<br />启动一个随机端口的示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest(</span><br><span class="line">        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>相应的模式说明如下。</p><ul><li>MOCK：默认模式，加载 Web 类型的上下文环境，但是提供的是模拟的运行环境，不启动 Web 服务器。</li><li>RANDOM_PORT：启动真实的内嵌服务器，并使用随机端口，可以避免测试时与其他应用端口冲突。</li><li>DEFINED_PORT：启动真实的内嵌服务器，并使用定义的端口，端口可以在测试的配置中添加。</li><li>NONE：不加载 Web 类型的上下文，也不模拟任何 Web 环境。</li></ul><p>另外，还可以配置一个 classes 参数来确定包扫描的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@ContextConfiguration(classes=...)&#125;：</span><br><span class="line">@SpringBootTest(</span><br><span class="line">        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,</span><br><span class="line">        classes = &#123;Application.class&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>默认情况下，Spring Boot 会通过扫描入口类包下的所有类来注册相关的 Bean。但是如果因某些原因无法做到，则可以使用 classes 参数来配置需要扫描的目标类。例如，在多模块项目下，配置了多个启动应用（比如前台、Admin 可以独立启动，但是它们在一个代码库中），它们共享一个 common 模块，这样就可以在各自的启动应用中独立运行测试，只要替换 classes 中的值即可实现相互之间不受干扰。<br />另外，@SpringBootTest 注解也可以通过 value 参数注入配置，用于激活与测试相关的 Profile 或者定义端口，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest(</span><br><span class="line">        value = &#123;&quot;server.port=9090&quot;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><a name="G8rvt"></a></p><h3 id="5-3-2-对-Bean-的模拟和监视">5.3.2 对 Bean 的模拟和监视</h3><p>通过测试替身部分的介绍我们知道，模拟和监视相关注解的使用与 Runner 密切相关，即必须有相应的 Runner 才可以，在 JUnit5 中 SpringExtension 帮我们完成了相关工作。<br />使用 Spring 之后，对象之间的依赖是通过 Bean 完成的，而不是简单的赋值，所以在 Spring 的测试中使用 @Mock 后，依然会保留 @Autowired 方式来注人被模拟的对象，不过也仅此而已。<br />而在 Spring Boot 的测试中，还提供了另外一个注解 @MockBean。@MockBean 必须在 SpringBoot 的测试上下文中工作，可以简单地将 @MockBean 理解为以模拟对象的方式定义一个 Bean，然后将模拟对象无差别地放到了容器中。它的生命周期与普通的 Bean 类似。比如，在使用 SpringExtension 的 UserServiceTest 中，UserMapper 是通过注解 @InjectMocks 的方式加载到 UserService 中的，在这个场景下不会有额外的 Bean 被加载进来。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@ExtendWith(SpringExtension.class)</span><br><span class="line">public class UserServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @InjectMocks</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @Mock</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里如果使用了 @MockBean 就可以省略掉 @InjectMocks，只是这样一来，就需要使用 @Autowired 来获取 UserService 的 Bean 了。请注意区分这两种形式的写法。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">public class UserServiceMockBeanTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @MockBean</span><br><span class="line">    // 注意，要求 UserMapper 没有被定义过才能被模拟</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void should_list_users() &#123;</span><br><span class="line">        userService.listAll();</span><br><span class="line">        Mockito.verify(userMapper).selectAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 @MockBean 注解时，内部创建的依然是 Mockito 的模拟对象，不过它是以 Bean 的方式存在的，并且会以此形式初始化 ApplicationContext 上下文。@MockBean 可用于任何测试类的属性上，也可以用于 @Configuration 修饰的类的属性上（用来准备测试配置）。Spring 提供的 ApplicationContext 上下文会被缓存，这是为了节省测试的时间。使用 @MockBean 创建的对象会自动在测试完成后重置。如果是自己创建的对象，要注意是否需要清理测试过程中的状态改变。<br />使用 @MockBean 的前提是容器中不存在同类型的 Bean，如果 Bean 已经存在，@MockBean 就会失效。下文会介绍如何指定测试需要的部分 Bean，而不是加载全部的 Bean。如果一个 Bean 已经被其他配置定义，也可以直接使用 @SpyBean 对这个 Bean 进行包装和监视，从而达到完成测试的目的。<br />使用 Spring Testing 时，解决业务代码中的 Bean 和测试中需要模拟的 Bean 的冲突有时会非常麻烦，但借助 Spring Boot 强大的配置可以有很多方法绕过这些问题。</p><ul><li>使用 Profile 机制专门为测试启动一个 Profile，被模拟的 Bean 在特定的 Profile 下不启动，避免与模拟的 Bean 发生冲突。</li><li>使用不同的 YAML 文件进行配置，源代码中的 YAML 用于正常的业务，在测试目录下使用专门的 YAML 文件来开启和关闭某些特性。</li></ul><p>在下面的示例中，使用了专门的文件来配置内存数据库、日志级别、端口等，避免测试时影响正常的启动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// application.yml 位于 /test/resources 下 </span><br><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line"></span><br><span class="line">logging.file: logs/application.log</span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    org:</span><br><span class="line">      springframework:</span><br><span class="line">        web: DEBUG</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url:  jdbc:h2:mem:unit_testing_db</span><br><span class="line">  h2:</span><br><span class="line">    console:</span><br><span class="line">      enabled: true</span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapper/*.xml</span><br></pre></td></tr></table></figure><p><a name="jy0Ek"></a></p><h3 id="5-3-3-Spring-Boot-切片配置">5.3.3 Spring Boot 切片配置</h3><p>正因为 @SpringBootTest 帮我们启动了所有需要的配置，因此使用了 @SpringBootTest 就意味着我们的测试变成了一个集成测试，这会拖慢测试速度。在实际工作中，我们可以按需启用。如果需要测试 MyBatis Mapper 时，可以使用 @MybatisTest 只加载必要的配置。<br />@SpringBootTest 默认会启动所有的自动配置，例如：</p><ul><li>Web 服务器（比如 Tomcat，取决于配置）。</li><li>数据库连接池。</li><li>MyBatis 或者与 JPA 相关的配置，这取决于相应的自动化配置是否被引入。</li></ul><p>通常来说，这样的配置对于单元测试来说太重了。换句话说，如果只想要测试 Controller，其实没必要启动 Web 服务器（使用 MockMvc 就行），测试 Repository 或者 Mapper 也只需要配置与数据库相关的 Bean 即可。<br />spring-boot-test-autoconfigure 模块提供了很多 @…Test 的注解代替 @SpringBootTest 来提供局部的自动化配置。@…Test 会启动应用上下文，并引入有限的 @AutoConfigure…。这些 @…Test 相当于帮你配置了一些 Bean 来真实地验证部分基础设施。官方使用 Testing Slices 来描述这类测试，并通过分层将代码进行分片加载，以达到刚好满足测试需求的目的。<br />例如 @WebMvcTest 就只会启动与 RequestMapping 相关的 Bean，比如 @Controller、@ControllerAdvice、@JsonComponent、Converter、GenericConverter、Filter、WebMvcConfigurer 和 HandlerMethodArgumentResolver 等。<br />使用 @WebMvcTest 就可以只测试引入的 Controller，而不必启动其他相关的 Bean，并且也能让 Controller 上的那些注解生效，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@WebMvcTest(UserController.class)</span><br><span class="line">public class ApplicationTestOnlyController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    @MockBean</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void should_list_users() throws Exception &#123;</span><br><span class="line">        Instant createAndUpdateInstant = Instant.parse(&quot;2021-11-07T00:55:32.026Z&quot;);</span><br><span class="line">        given(this.userService.listAll())</span><br><span class="line">                .willReturn(Lists.newArrayList(new User(1L, &quot;James&quot;, &quot;123456&quot;, createAndUpdateInstant, createAndUpdateInstant)));</span><br><span class="line"></span><br><span class="line">        this.mvc.perform(MockMvcRequestBuilders.get(&quot;/users&quot;)</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON_VALUE))</span><br><span class="line">                .andExpect(status().isOk()).andExpect(</span><br><span class="line">                content().string(&quot;[&#123;\&quot;id\&quot;:1,\&quot;username\&quot;:\&quot;James\&quot;,\&quot;password\&quot;:\&quot;123456\&quot;,\&quot;createAt\&quot;:\&quot;2021-11-07T00:55:32.026Z\&quot;,\&quot;updateAt\&quot;:\&quot;2021-11-07T00:55:32.026Z\&quot;&#125;]&quot;)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例中，只是初始化了 Spring Boot 基本的上下文和与 Spring MVC 相关的配置，从日志中可以看出，Spring Boot 并没有启动与数据库相关的设施。这里的 UserService 有被模拟，因此能正常地返回数据，被该测试影响的有效的代码范围是：</p><ul><li>Spring MVC 相关的逻辑（无 Web 服务器）。</li><li>Controller 中的注解和逻辑。</li></ul><p>除此之外，@WebMvcTest 加载的 Bean 也非常有限，基本只有 UserController，因此仍然可以认为是 Controller 层的单元测试。<br />查阅 @WebMvcTest 和 @SpringBootTest 的部分源码，可以发现它们的不同之处。@WebMvcTest 相当于基于 Spring 所进行的测试，它组合了很多自动化配置的注解，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// @WebMvcTest 的关键注解</span><br><span class="line">@BootstrapWith(WebMvcTestContextBootstrapper.class)</span><br><span class="line">@ExtendWith(&#123;SpringExtension.class&#125;)</span><br><span class="line">@OverrideAutoConfiguration(</span><br><span class="line">    enabled = false</span><br><span class="line">)</span><br><span class="line">@TypeExcludeFilters(&#123;WebMvcTypeExcludeFilter.class&#125;)</span><br><span class="line">@AutoConfigureCache</span><br><span class="line">@AutoConfigureWebMvc</span><br><span class="line">@AutoConfigureMockMvc</span><br><span class="line">@ImportAutoConfiguration</span><br></pre></td></tr></table></figure><p>而 @SpringBootTest 则使用 SpringBootTestContextBootstrapper 构建了完整的测试上下文，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// @SpringBootTest 的关键注解 </span><br><span class="line">@BootstrapWith(SpringBootTestContextBootstrapper.class)</span><br><span class="line">@ExtendWith(SpringExtension.class)</span><br></pre></td></tr></table></figure><p>如果我们只是想测试与框架相关的代码，比如 MyBatis Mapper、Redis 连接、Spring Data JPA 等，也可以使用相应的局部测试注解。<br /><strong>1. @MybatisTest</strong><br />MyBatis 不在默认的自动配置中，如果你是通过 mybatis-spring-boot-autoconfigure 包自动配置的 MyBatis，可以引入 mybatis-spring-boot-test-autoconfigure，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis-spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>若想实现只测试 Mapper 的逻辑，可以在使用 @MybatisTest 时只创建与 Mapper 相关的 Bean，并启动内存模拟数据的存储（如果引入了内存数据库的 Starter），以便进行断言。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@MybatisTest</span><br><span class="line">public class TestForMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void should_save_user() &#123;</span><br><span class="line">        User user = new User() &#123;&#123;</span><br><span class="line">            setUsername(&quot;zhangsan&quot;);</span><br><span class="line">            setPassword(&quot;123456&quot;);</span><br><span class="line">            setCreateAt(Instant.now());</span><br><span class="line">            setUpdateAt(Instant.now());</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        userMapper.insert(user);</span><br><span class="line">        // 下面可以是一些断言</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. @JsonTest</strong><br />在服务器上进行开发时，经常需要反复调试 JSON 的序列化。如果没有取得预期的效果，可以为其编写单独的测试，有针对性地进行调试。下面的示例使用 @JsonTest 加载了与 JSON 相关的自动化配置，然后检查其与预期的是否匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@JsonTest</span><br><span class="line">public class TestForJson &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void should_serialize_properly() throws JsonProcessingException &#123;</span><br><span class="line">        User user = new User() &#123;&#123;</span><br><span class="line">            setUsername(&quot;zhangsan&quot;);</span><br><span class="line">            setPassword(&quot;123456&quot;);</span><br><span class="line">            setCreateAt(Instant.now());</span><br><span class="line">            setUpdateAt(Instant.now());</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        assertEquals(&quot;&#123;\&quot;id\&quot;:0,\&quot;username\&quot;:\&quot;zhangsan\&quot;,\&quot;password\&quot;:\&quot;123456\&quot;,\&quot;createAt\&quot;:\&quot;2021-11-07T02:00:45.126Z\&quot;,\&quot;updateAt\&quot;:\&quot;2021-11-07T02:00:45.126Z\&quot;&#125;&quot;, this.objectMapper.writeValueAsString(user));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Boot 引入了 AssertJ、JSONAssert 及 JsonPath 来实现更好的断言，其断言方式是使用 Path 路径获取 JSON 中的值。使用 JacksonTester 可以获取转换过程中的 JSON 对象，我们可以再结合 Helper 来编写断言。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private JacksonTester&lt;User&gt; userJacksonTester;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">void should_serialize_properly_with_tester() throws IOException &#123;</span><br><span class="line">    User user = new User() &#123;&#123;</span><br><span class="line">        setUsername(&quot;zhangsan&quot;);</span><br><span class="line">        setPassword(&quot;123456&quot;);</span><br><span class="line">        setCreateAt(Instant.now());</span><br><span class="line">        setUpdateAt(Instant.now());</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    assertThat(this.userJacksonTester.write(user)).hasJsonPath(&quot;@.username&quot;);</span><br><span class="line">    assertThat(this.userJacksonTester.write(user))</span><br><span class="line">            .extractingJsonPathStringValue(&quot;@.username&quot;)</span><br><span class="line">            .isEqualTo(&quot;zhangsan&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 @…Test 不能组合使用，因此如果想要在 @WebMvcTest 里配置其他的 Bean，可以通过 @AutoConfigure… 注解选择性地引入自动配置，或者自己直接创建相关的 Bean。创建的方式是编写一个 @Configuration 修饰的配置类，并放置到 Spring Boot 能扫描到的地方。<br><a name="vxcDT"></a></p><h2 id="5-4-分层测试和测试策略">5.4 分层测试和测试策略</h2><p>在使用 Spring 做测试时，比较头疼的是它的代码分层所需匹配的测试策略。SpringBoot 项目一般会分为 Controller、Service、Repository（或叫 DAO、Mapper）这三层。在编写单元测试时，需要考虑分层隔离测试。<br />如果我们每层都编写单元测试，会出现大量无意义的样板代码；如果不分层测试，为了达到相同的效果需要编写的测试用例的组合就非常多，因此我们需要充分考虑分层测试的策略问题。下面讨论一下在 Web 服务器上开发时常见的分层测试策略。<br><a name="OFMzb"></a></p><h3 id="5-4-1-测试策略">5.4.1 测试策略</h3><p>通过对一些 Spring 项目进行观察，我们发现有一些模式可以参考 1. 严格的单元测试<br />**1. 严格的单元测试 **<br />很多单元测试爱好者，或者说有代码洁癖的开发者希望把每层都拆开测试。编写各自独立的测试时，每个测试文件的位置需要与源代码的位置保持严格的对应关系。基于这种观念，Spring 的测试库不是必须的，只需要使用 JUnit 和 Mockito。<br />近年来，严格的分层受到越来越多的质疑，原因是 Spring 框架通过注解帮我们完成了大量的基础操作，比如数据的持久化、数据的校验等，而对这些逻辑的验证却完全起不到测试的作用。<br />不让 Controller 上的注解发生作用的单元测试，几乎没有测试的内容和价值。<br />**2. 关键单元测试与 API 测试 **<br />另一部分开发者认为不应该通过纯粹的单元测试来验证 API 接口和数据库访问，开发者应该只关注业务逻辑的正确性，与框架相关的测试工作通过 API 测试可以覆盖、验证，开发者只需要针对 Service 层的逻辑进行充分测试即可，与框架、技术设施相关的测试则交给 API 测试来处理。API 测试可以由开发人员和测试人员共同维护，测试人员不必单独维护一套 API 测试，开发人员也不必关注基础设施在单元测试中的集成问题。<br />基于 Web 服务端开发的性质，开发人员往往需要与 Web 服务器、数据库大量打交道，但是，如果仅仅让开发人员关心单元测试，那么他们测试不到 Web 请求及与数据库相关的操作。比如，MyBatis 的 Mapper 中有字段错误，开发人员是无法及时发现的。此外，业务逻辑与数据紧密相关，如果缺乏数据库相关的逻辑，测试的性价比不高。<br />**3. 轻量级集成测试 **<br />另外一种思路是基于前面两个策略做出一些取舍，把部分与 Spring 框架的结合点也算作单元测试的一部分，即看作轻量级的集成测试。<br />对 Controller 层进行测试时，可使用 MockMvc 测试 Controller 相关逻辑是否正确，包括输出格式、头部和异常等。为了避免测不到大量注解，不要直接通过 new 关键字创建 Controller 对象，这样测不到大量的注解。使用 MockMvc 可以做到不启动真正的 Web 服务器就可以测试 Controller 上的注解。<br />对 Service 层和持久层进行测试时，可使用 @DataJpaTest 或 @MybatisTest 自动配置数据库连接，数据库则使用 H2 等内存数据库。至于测试数据，不要直接在数据库中创建数据，建议使用上游的方法操作数据。比如测试用户列出的方法时，应该先确保用户添加的方法没有问题，然后使用该方法创建数据库中的用户，这样可以减少测试成本。图 5-3 展示了这种测试策略。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712881898634-09beed95-1e39-4590-899b-4a7193e19206.png#clientId=u61f6852d-71c7-4&amp;from=paste&amp;id=u509b5cc6&amp;originHeight=346&amp;originWidth=652&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=26878&amp;status=done&amp;style=none&amp;taskId=ufc73a568-dfba-4921-8534-4bcba7b145d&amp;title=" alt="image.jpg"><br />图 5-3 一种分层测试策略的示意图<br />如果对 Service 进行测试，模拟基础设施做纯粹的单元测试完全没有问题，但是这样做基础设施的特性并没有被纳入测试的范围，会造成测试性价比低。权衡之下，在现实项目中往往会采取尽可能地让基础设施通过内嵌的方式参与到测试中的方式，如果实在不能通过内嵌解决（例如一些云基础设施），则通过模拟处理。<br />通过上面的方案，就不需要完整地启动 Spring Boot 的上下文了，装载对应的 Bean 即可。比如对 UserService 进行测试，只需要加载 UserService 的 Bean 以及 Mapper 层，配合内存数据库即可完成测试。<br />**4. 单元测试与集成测试相结合 **<br />如果希望测试代码的有效性和可靠性非常高，可以使用单元测试与集成测试相结合的策略。这种策略能兼顾测试质量和效率，对质量保障很有帮助，当然，能做到的团队也比较少。策略内容如下：</p><ul><li>对 Controller 进行 MockMvc 测试。</li><li>对 Service 进行单元测试，校验所有的业务逻辑，模拟基础设施。</li><li>使用内嵌的基础设施快速验证 Mapper 或者 Repository 中与数据库相关的逻辑。</li></ul><p>额外的代码可由 QA 编写独立的 API 测试，从而构建完整的代码保护网。<br><a name="xvWNG"></a></p><h3 id="5-4-2-Controller-的测试">5.4.2 Controller 的测试</h3><p>如果我们只关注 Controller 的测试，MockMvc 是非常好的选择。在之前介绍切片测试时使用一个示例说明了 MockMvc 的使用方法，下面来详细说一下 MockMve 的执行原理。<br />@WebMvcTest 启动相应的 Bean 并把 UserController 加入模拟的 RequestMapping 中。<br />在测试过程中 MockMvc 不会发起真实的 HTTP 请求，因此需要注入一个 MockMvc 对象来构造请求。<br />我们知道，@WebMvcTest 不会启动整个应用的上下文，UserController 依赖的 Service 没有初始化，因此需要使用 @MockBean 来模拟，否则会报找不到 Bean 的错误。通过 @MockBean 得到模拟对象后，可以用 Mockito 内部的 given 等静态方法进行操作，定义返回值等。最后，我们需要使用 MockMvc 的实例构建请求、发送请求并验证返回值。<br />此处使用的是 @WebMvcTest（MockMvc）而非 @SpringBootTest，它们非常容易被弄混。图 5-4 展示了这两种测试的差异。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712881899139-af5a814f-190b-4ce1-bbc7-ae5a22332beb.png#clientId=u61f6852d-71c7-4&amp;from=paste&amp;id=u5afbd9e3&amp;originHeight=852&amp;originWidth=1660&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=104401&amp;status=done&amp;style=none&amp;taskId=u94b07b40-17a9-4acb-a7ff-845d4e1c338&amp;title=" alt="image.jpg"><br />图 5-4 MockMVC 和 SpringBootTest 的区别<br />注：图片来源于 <a href="https://docs.spring.io/%E3%80%82">https://docs.spring.io/。</a><br />从图 5-4 可以看出，MockMvc 的测试更加轻量级和简单，但是必要时需要手动模拟或者配置一些依赖的 Bean。MockMvc 模拟的是 Web 服务器和 HTTP 协议请求，以及接收、解析一系列关于网络的逻辑，毕竟这部分是 Web 服务器应该充分测试的。<br />在下面的测试示例中，should_list_users 中主要涉及两部分内容，一部分是对模拟的对象给予返回值，另外一部分就是发出请求和验证请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void should_list_users() throws Exception &#123;</span><br><span class="line">  // 模拟 UserService</span><br><span class="line">  given(userService.listAll()).willReturn(</span><br><span class="line">    Arrays.asList(new User() &#123;&#123;</span><br><span class="line">      setId(01L);</span><br><span class="line">      setUsername(&quot;Test user&quot;);</span><br><span class="line">      setPassword(&quot;123456&quot;);</span><br><span class="line">      setCreateAt(Instant.now());</span><br><span class="line">      setUpdateAt(Instant.now());</span><br><span class="line">    &#125;&#125;)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"> // 进行测试调用和断言</span><br><span class="line">this.mvc.perform(get(&quot;/users&quot;).accept(MediaType.APPLICATION_JSON)).andExpect(status().isOk());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this.mvc.perform 这个链式调用语句的工作范围包括（绕过 Web 服务器后的代码执行过程）：</p><ul><li>MockMvc 构造一些假的 HTTP 请求对象。</li><li>TestDispatcherServlet 响应测试的 Servlet。</li><li>RequestMappingHandlerAdapter 根据请求的路径匹配合适的 Controller。</li></ul><p>进行测试调用和断言的这部分链式调用不易理解，现在拆解开来看一下整个过程，里面实际上有很多步骤。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 1. 构建一个模拟请求，get 方法接受一个请求的路径，并设置 accept 头部值为 application-json</span><br><span class="line">MockHttpServletRequestBuilder builder = MockMvcRequestBuilders</span><br><span class="line">        .get(&quot;/users&quot;)</span><br><span class="line">        .accept(MediaType.APPLICATION_JSON);</span><br><span class="line">// 2. 执行这个请求，生成一个 ResultAction</span><br><span class="line">ResultActions perform = this.mvc.perform(builder);</span><br><span class="line">// 3. 定义一个匹配器</span><br><span class="line">ResultMatcher okMatcher = MockMvcResultMatchers.status().isOk();</span><br><span class="line">// 4. 执行这个匹配器进行断言</span><br><span class="line">perform.andExpect(okMatcher);</span><br></pre></td></tr></table></figure><p>MockHttpServletRequestBuilder 可以创建出 GET、POST、PUT、DELETE 等 HTP 请求，如果需要在 URL 上带参数，可以使用重载方法 get（String urITemplate，Object…uriVars）。要使用 POST 可以通过 content 方法设置请求的内容参数，还可以通过 multipart 方法设置文件参数，用于测试文件上传功能。<br />执行构造出来的请求，获得一个 ResultActions 并用于后面的断言，以确认测试结果。执行完成后，断言前使用 ResultMatcher 构造一个匹配器。它除了匹配状态外，还可以匹配返回头消息、消息体等。如果返回的是 JSON 相关内容，则还可以使用 JsonPath 来断言 JSON 数据结构。<br />值得一提的是，必要时可在多次请求之间通过 Cookies 方式传递认证信息。<br><a name="MfaXV"></a></p><h3 id="5-4-3-内嵌基础设施">5.4.3 内嵌基础设施</h3><p>常见的可以被内嵌处理的基础设施有数据库、Redis、MongoDB 等。一般这些内嵌的库又有两种实现方式：</p><ul><li>使用 Java 开发，通过 Jar 包引人，与 Java 的开发体系融合良好。</li><li>使用 C 或者其他语言开发，通过检测运行的操作系统来运行相应的原生发布版。</li></ul><p>例如，内嵌 Redis 是通过下载对应的 Redis 发布版，然后通过 Java 的 ProcessBuilder API 实现的。<br />**1. 内存数据库 **<br />可以选择的内存数据库有 HSQL、H2，H2 相对于 HSQL 来说功能更为完整，但是稍慢。Spring Boot 对 H2 的支持也比较好，相关的自动配置已经被纳入版本管理器中。<br />以 H2 为例，如果需要在项目中使用 H2，先在 Pom 文件中加入相关依赖，并在测试的资源目录下增加相关配置，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.h2database&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;h2&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>然后设置数据源连接串，并开启 H2 控制台，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:h2:mem:unit_testing_db</span><br><span class="line">  h2:</span><br><span class="line">    console:</span><br><span class="line">      enabled: true</span><br></pre></td></tr></table></figure><p>H2 默认控制台的访问路径是（h2-console，可以通过 spring.h2.console.path 属性修改路径。实际上测试前和测试后控制台上都不会有数据，可以通过断点中断测试，并访问 H2 控制台路径。<br />如果使用了 Flyway 等数据迁移工具，那么在测试启动时它也会生效，但由于数据库在内存中，重启会丢失数据，因此不会重复执行迁移任务。<br />H2 也支持将数据落盘，使用的方式是修改连接字符串，即将连接字符串中的 mem 修改成指定的文件路径，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:h2:file:/data/h2:unit_testing_db</span><br></pre></td></tr></table></figure><p><strong>2. 内嵌 Redis</strong><br />如果业务代码中使用了 Redis，且 Redis 的客户端是模拟的，那么测试不到与 Redis 相关的特性，测试性价比降低。对此，也可以通过内嵌 Redis 的方式来充分测试与 Redis 相关的逻辑，测试效率会大大提高。<br />目前 Spring Boot 没有支持内嵌 Redis 的自动配置，因此需要手动配置。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;redis.embedded&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;embedded-redis&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;0.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>可以通过在测试基类中编写 setup 和 teardown 方法来设置内嵌 Redis。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class SpringBaseTest &#123;</span><br><span class="line"></span><br><span class="line">    private RedisServer redisServer;</span><br><span class="line"></span><br><span class="line">    @BeforeClass</span><br><span class="line">    public void setup() throws Exception &#123;</span><br><span class="line">        redisServer = new RedisServer(6379);</span><br><span class="line">        redisServer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterClass</span><br><span class="line">    public void teardown() throws Exception &#123;</span><br><span class="line">        redisServer.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 内嵌 MongoDB</strong><br />Spring Boot 默认支持了内嵌 MongoDB，并且提供了相关的自动配置类。只需要增加依赖，添加修改 YAML 配置即可。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.flapdoodle.embed&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;de.flapdoodle.embed.mongo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>Spring Boot 通过 MongoAutoConfiguration 类初始化了内嵌的 MongoDB 以及 MongoClient 的配置，默认情况下使用随机端口，并对开发人员透明。如果希望修改端口，可以在测试目录下的 YAML 文件中修改属性 spring.data.mongodb.port。<br><a name="U7tC3"></a></p><h2 id="5-5-常用的测试工具集">5.5 常用的测试工具集</h2><p>spring-boot-test-starter 集成了 spring-boot-test、spring-test、Mockito、JsonPath 等库，提供了不少对测试非常有帮助的工具集。由于阅读完所有的文档较为费时，且部分技巧需要深入探查源码才能找到，因此这里整理了部分工具集相关知识供参考。<br><a name="HtOZS"></a></p><h3 id="5-5-1-spring-test-提供的工具集">5.5.1 spring-test 提供的工具集</h3><p>spring-test 提供了数据库统计工具和测试反射工具。<br /><strong>1. JdbcTestUtils</strong><br />JdbcTestUtils 是 Spring Test 库中非常实用的工具，在测试过程中用于操作、统计表中的数据。使用 JdbcTestUtils 时，需要传入一个 JdbcTemplate 作为实际操作数据库的渠道。<br />它提供了以下方法：</p><ul><li>countRowslnTable、countRowslnTableWhere：用于统计（或带条件）给定数据库表的行数。</li><li>deleteFromTables、deleteFromTableWhere：用于清除（或带条件）给定表中的数据。</li><li>dropTables：用于删除给定表。</li></ul><p><strong>2. ReflectionTestUtils</strong><br />在测试中不可避免地要对私有属性、方法进行操作，这可以使用 PowerMock 等工具来完成，但是大部分情况下没有必要引入这么多库。其实 Spring Test 库也丙置了一个工具，可通过反射简化此类操作。<br />例如，给私有属性设置新的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User user = new User() &#123;&#123;</span><br><span class="line">    setUsername(&quot;zhangsan&quot;);</span><br><span class="line">    setPassword(&quot;123456&quot;);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line">ReflectionTestUtils.setField(user, &quot;username&quot;, &quot;wang&quot;);</span><br><span class="line">assertThat(user.getUsername(), equalTo(&quot;wang&quot;));</span><br></pre></td></tr></table></figure><p>访问私有属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertThat(ReflectionTestUtils.getField(user, &quot;username&quot;), equalTo(&quot;wang&quot;));</span><br></pre></td></tr></table></figure><p>调用私有方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// user 对象中有一个 testPrivateMethod 私有方法 </span><br><span class="line">assertThat(</span><br><span class="line">        ReflectionTestUtils.invokeMethod(user, &quot;testPrivateMethod&quot;),</span><br><span class="line">        equalTo(&quot;this is private method&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在方便的时候，ReflectionTestUtils 也可以修改 @Autowired 修饰的私有方法，快速搞定依赖注入，并且可用于 @Value 注解修饰的方法。<br><a name="CbFDd"></a></p><h3 id="5-5-2-spring-boot-test-提供的工具集">5.5.2 spring-boot-test 提供的工具集</h3><p>spring-boot-test 主要是提供了与自动配置相关的工具。<br /><strong>1. TestPropertyValues</strong><br />一般来说很多被 @Value 注解修饰的属性都是私有的，这会给测试造成困难。Spring Boot 提供了 TestProperty Values 工具类来注入配置属性。下面这个例子需要配合 @ContextCon-figuration 来使用，在测试初始化的时候通过 TestProperty Values 插入需要的属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@ContextConfiguration(initializers = PropertyTest.MyPropertyInitializer.class)</span><br><span class="line">public class PropertyTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;testProperty&#125;&quot;)</span><br><span class="line">    private String testProperty;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        assertThat(testProperty).isEqualTo(&quot;foo&quot;);</span><br><span class="line">        assertThat(this.context.getEnvironment().getProperty(&quot;testProperty&quot;)).isEqualTo(&quot;foo&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class MyPropertyInitializer</span><br><span class="line">            implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void initialize(ConfigurableApplicationContext applicationContext) &#123;</span><br><span class="line">            TestPropertyValues.of(&quot;testProperty=foo&quot;).applyTo(applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个工具我们日常用得不多，在动态插入属性时可以使用此方法。如果是静态插入属性，可以使用 @SpringBootTest 注解的 value、properties、args 参数。<br /><strong>2. OutputCapture</strong><br />Spring Boot 提供了 OutputCaptureExtension 来捕获控制台信息，如果代码中使用了 System.out 或者 System.err 输出信息到控制台，那么就可以使用此工具来捕获控制台信息，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@ExtendWith(OutputCaptureExtension.class)</span><br><span class="line">public class OutputCaptureTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test_capture(CapturedOutput output) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;Hello world!&quot;);</span><br><span class="line">        assertThat(output).contains(&quot;world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. TestRestTemplate</strong><br />TestRestTemplate 是一个专门用于测试的 RestTemplate，主要的功能是遇到 400、500 返回的时候不会抛出异常，而是将异常信息放到返回的 ResponseEntity 对象中，以便进行断言和做进一步处理。<br />它默认使用 Apache HTTP Client 作为 HTTP 客户端，但不是强制性的。如果使用的是 Apache HTTP Client 客户端，则还有两个额外的特性：</p><ul><li>不会自动发生跳转，例如 302 响应一般会在返回的头部中加入 location 属性，表明期望的下一跳，可以使用 TestRestTemplate 来断言。</li><li>Cookies 会被忽略，并且会被当作无状态的 HTTP 客户端。<br><a name="OWGl1"></a></li></ul><h2 id="5-6-小结">5.6 小结</h2><p>使用 Spring Boot 会大大简化测试环境的搭建，这都归功于 spring-boot-test：spring-boot-autoconfigure、spring-test 这三个包。一些模拟注解和工具由 Spring Test 和 Mockito 共同提供。<br />正因如此，Spring Boot 环境中的各种测试工具变得难以理解。我们在使用的过程中需要注意相关的特性都是由哪一个具体的组件提供的，这样排查问题时会高效很多。<br />在 Java 开发中，纯粹的单元测试往往更适合公共库、框架类的代码。但对于应用程序来说，不得不和很多基础设施打交道，因此单元测试需要模拟大量的类和组件，工作量变大却收益甚微。对于这种情况，可以考虑通过内嵌基础设施的方式局部进行集成测试，从而有效减少测试代码，节省大量的编程时间。</p><blockquote><p>来自: <a href="https://java-self-testing.github.io/java-self-testing-book/05-testing-with-spring/">第 5 章 Spring 应用的测试 - 《Java 研发自测》</a></p></blockquote><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了更好地理解 Spring 相关的测试内容，这里延续前面购买灯泡的类比。在现代社会中，人们大都使用一些具有装饰性或者功能性的灯具。在这种灯具中，灯泡有可能被放到某个灯槽中，或者被包裹在富有艺术感的金属材料里面。因此，我们也就不得不按照厂商的要求来测试或者组装，以实现相应的</summary>
      
    
    
    
    <category term="测试" scheme="http://www.bojiboqi.fun/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="spring测试" scheme="http://www.bojiboqi.fun/tags/spring%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>第 6 章 RESTful API 测试 - 《Java 研发自测》</title>
    <link href="http://www.bojiboqi.fun/2024/04/22/%E7%AC%AC%206%20%E7%AB%A0%20RESTful%20API%20%E6%B5%8B%E8%AF%95%20-%20%E3%80%8AJava%20%E7%A0%94%E5%8F%91%E8%87%AA%E6%B5%8B%E3%80%8B/"/>
    <id>http://www.bojiboqi.fun/2024/04/22/%E7%AC%AC%206%20%E7%AB%A0%20RESTful%20API%20%E6%B5%8B%E8%AF%95%20-%20%E3%80%8AJava%20%E7%A0%94%E5%8F%91%E8%87%AA%E6%B5%8B%E3%80%8B/</id>
    <published>2024-04-22T06:28:59.645Z</published>
    <updated>2024-04-22T23:25:04.477Z</updated>
    
    <content type="html"><![CDATA[<p>API 测试属于集成测试的范畴，手动进行 API 测试有很多方法，例如：</p><ul><li>使用 Curl 命令。</li><li>使用 Postman。</li><li>使用 Swagger 附带的 UI （用户界面）工具。</li></ul><p>这些方法都有一个共同的问题，就是实现自动化的反复执行比较困难。比较好的做法是通过编码的方式进行 API 测试，最好放到代码仓库中以自动化的形式完成，并集成在 CI （持续集成）流水线中。<br />在一些企业中有专门的 API 测试平台管理相关测试。这种方式的灵活性会稍弱并与企业内部的基础设施强关联，因此本章选用的工具都是基于开源软件实现的。<br />本章的目标是介绍如何基于源代码编写可以维护的 API 测试，涵盖的内容有：</p><ul><li>RESTful API 测试工具集。</li><li>第三方 API 的处理。<br><a name="N6iKn"></a></li></ul><h2 id="6-1-RESTful-API-测试工具集">6.1 RESTful API 测试工具集</h2><p>Spring Boot 的 spring-boot-starter-test Starter 项目已经为我们准备了一套测试工具，不过为了让 API 测试更有效和便利，除了 Spring 测试套件以外，还需要准备一些额外的基础设施。例如，REST Assured 可以作为 API 测试的基本框架，DbUnit 可以用来在多个测试之间隔离数据库的状态，WireMock 可以用来模拟第三方依赖的 API。这些工具可以帮助我们更好地完成测试用例的编写和运行，但在某些场景下不是必选的。<br />在 Spring 的测试体系下，MockMvc 也是 API 自动化测试的一个重要工具，但是我们常常并没有选用它作为 API 测试的工具。这是因为 API 测试已经是一个 E2E 测试了，API 测试关注的是服务是否能提供完整的功能，我们会希望启动完整的上下文来进行端到端的测试。<br />MockMvc 在前面章节介绍过，用来模拟 Web 服务器，以便让 Controller 上的注解可以被测试到，所以常常在分层的单元测试中用于验证 Controller 部分的逻辑。<br />更多的情况下，我们会选用专业的 API 自动化测试工具，比如 REST Assured、Karate DSL 等。本书基于市场占有量选择了以 REST Assured 为例详细讲解 API 测试。实际上，MockMvc 也可以配合 RESTAssured 使用。<br><a name="ehxHw"></a></p><h3 id="6-1-1-REST-Assured">6.1.1 REST Assured</h3><p>REST Assured 由 Johan Haleby 在 Jayway 公司创建。与 MockMvo 不同的是，REST Assured 更像是 Java 中关于测试的领域特定语言（DSL）。它提供了一套链式的 API 来编写 Given、When、Then 风格的测试。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">given().</span><br><span class="line">    param(&quot;key1&quot;, &quot;value1&quot;).</span><br><span class="line">    param(&quot;key2&quot;, &quot;value2&quot;).</span><br><span class="line">when().</span><br><span class="line">    post(&quot;/somewhere&quot;).</span><br><span class="line">then().</span><br><span class="line">    body(containsString(&quot;OK&quot;));</span><br></pre></td></tr></table></figure><p>在上述代码中，通过流式的风格声明了 Given、When、Then 这三种语句块，让 API 测试具有与单元测试类似的风格。<br />REST Assured 的优秀之处还在于提供了 xml-path、json-path 这两个强大的断言库，它可以直接断言返回的数据结构，使用起来非常方便。json-path 也被吸收到 spring-boot-starter-test 中了，基本已成为断言 JSON 数据的必备工具。<br />REST Assured 只是一个单独的测试套件，内含一个 HTTP 客户端，测试时需要启动全量的 Web 服务，且需要依赖 @SpringBootTest 注解启动完整的应用上下文，并创建一个随机端口，避免测试被干扰。如果觉得 Web 服务器启动得太慢，RESTAssured 也可以结合 MockMvc 来使用。<br />创建一个 Maven 项目或者模块，除了要引人 Spring 生态下基本的依赖外，还需要引入下面的依赖包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rest-assured&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.4.0&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>RESTAssured 的配置非常简单，使用下面的脚本即可完成初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest(webEnvironment = RANDOM_PORT, classes = &#123;Application.class&#125;)</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">@LocalServerPort</span><br><span class="line">private int port;</span><br><span class="line"></span><br><span class="line">@BeforeEach</span><br><span class="line">public void setup() &#123;</span><br><span class="line">  System.out.println(&quot;port:&quot; + port);</span><br><span class="line"></span><br><span class="line">  RestAssured.port = port;</span><br><span class="line">  RestAssured.basePath = &quot;/api&quot;;</span><br><span class="line">  RestAssured.enableLoggingOfRequestAndResponseIfValidationFails();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@LocalServerPort 注解可以读取 @SpringBootTest 在启动时创建的随机端口，并将其用于后续的测试中。在 setup 方法中，我们为 REST Assured 配置了端口、API 前缀，并打开了一个特性开关，以便测试失败时打印出请求和返回的详情。<br />上面的代码就是启用 REST Assured 的全部配置，后面会在测试实例中给出完整的使用示例。如果需要实现 MockMvc 的效果，可以使用 spring-mock-mve 库中的 RestAssuredMockMvc 类进行桥接，加快测试速度。<br><a name="EcZ7M"></a></p><h3 id="6-1-2-MariaDB">6.1.2 MariaDB</h3><p>上一章讨论过单元测试中关于基础设施的问题，我们知道，涉及数据库的测试可以使用内嵌的数据库比如 H2 来实现相应的模拟。但是 H2 的功能比较有限，有时候不一定能满足需要。比如，在做 E2E 测试时，H2 无法模拟出与 MySQL 同样的功能，SQL 语法上也与其存在一定的差异。这时，可以使用 MariaDB 来模拟 MySQL，并通过 MariaDB4j 这个工具从测试中启动 MariaDB。<br />MariaDB 是数据库管理系统 MySQL 的一个分支，主要由开源社区维护，在一定程度上可以将其看作 MySQL。<br />MariaDB4j 实际上只是一个启动器，真正的数据库还是会由与操作系统相关的二进制包启动。为了使用随机的数据库端口，我们不再使用 Spring Boot 的自动配置，而是直接给上下文配置一个 DataSource。来看个示例，老规矩，先引入一个依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;ch.vorburger.mariaDB4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mariaDB4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>然后在测试模块中引入一个配置类。在测试模块中定义的相关 Bean 也会被加载到 Spring Boot 的上下文中，但是不会对业务代码产生影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MariaDB4jSpringConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DataSourceProperties dataSourceProperties;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MariaDB4jSpringService mariaDB4j() &#123;</span><br><span class="line">        MariaDB4jSpringService mariaDB4jSpringService = new MariaDB4jSpringService();</span><br><span class="line">        mariaDB4jSpringService.getConfiguration().addArg(&quot;--user=root&quot;);</span><br><span class="line">        mariaDB4jSpringService.getConfiguration().addArg(&quot;--character-set-server=utf8&quot;);</span><br><span class="line">        return mariaDB4jSpringService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Primary</span><br><span class="line">    public DataSource dataSource() throws ManagedProcessException &#123;</span><br><span class="line">        String dbname = UUID.randomUUID().toString().substring(0, 8);</span><br><span class="line">        mariaDB4j().getDB().createDB(dbname);</span><br><span class="line">        return DataSourceBuilder.create()</span><br><span class="line">                .driverClassName(dataSourceProperties.getDriverClassName())</span><br><span class="line">                .url(mariaDB4j().getConfiguration().getURL(dbname))</span><br><span class="line">                .username(dataSourceProperties.getUsername())</span><br><span class="line">                .password(dataSourceProperties.getPassword())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MariaDB4jSpringService 继承了 MariaDB4jService，并实现了 Lifecycle 接口，它是启动 MariaDB4jService 的原生 API，可以启动和关停数据库。MariaDB4jSpringService 实现了 Spring 的生命周期钩子，让数据库随着 Spring 的生命周期启动和关停。<br />DataSource Bean 自定义了数据库名称，并获得了 MariaDB4j 中的默认配置，然后以此来创建数据源。在 DataSource 的配置中使用了 DataSourceProperties 的配置，该配置来源于我们在 YAML 文件（application.yml）中配置的数据库连接信息，这样可以将原本需要连接真实 MySQL 的数据源切换成内置的临时数据库。<br><a name="IQiOV"></a></p><h3 id="6-1-3-DbUnit">6.1.3 DbUnit</h3><p>通常情况下，我们会结合数据库来进行 E2E 测试，每执行一个测试用例，测试数据就有可能会污染数据库。对于这种情况，DbUnit 可以帮助我们在测试前暂存数据库的状态，并在测试后恢复，避免测试之间产生干扰。<br />如果我们的数据库中没有初始数据，可以直接做清空操作，则不需要 DbUnit 的帮助。但是，一般来说我们会使用 Flyway 管理数据库的表结构，而且为了开发方便，也会将一些初始数据同步写入。系统中总是需要初始化一些默认数据，例如超级管理员的账号和密码等，通过 Flyway 管理会非常方便。如果测试运行前数据库中有一些默认数据（而且是通过 Flyway 管理的），就不能通过简单地清空数据库来重置数据库状态，这时 DbUnit 就派上用场了。<br />按照惯例，将 DbUnit 加入项目中时，先引入需要的依赖包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.dbunit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dbunit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>上述代码中，DbUnit 的实现方式比较朴素，主要提供了一个 IDataSet 接口，它通过 CSV、XML、SQL 等实现方式把数据临时存储下来，如图 6-1 所示。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712881908953-4f6249da-5953-43c0-9979-7f40f5d2f2a9.png#averageHue=%23848483&amp;clientId=u30cfec57-467a-4&amp;from=paste&amp;id=uc513de4d&amp;originHeight=274&amp;originWidth=1314&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=77368&amp;status=done&amp;style=none&amp;taskId=u1e84aec7-9e3d-4942-85fe-95940f11527&amp;title=" alt="image.jpg"><br />图 6-1 DbUnit 暂存数据集的几种方式<br />DbUnit 还提供了一个工具类 DatabaseOperation，可以通过它来操作数据库和数据集，实现备份、还原和清空等功能。<br />下面是一个封装好的服务，将其加载到测试之前和之后的方法中即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class ResetDbService &#123;</span><br><span class="line"></span><br><span class="line">    private static IDatabaseConnection conn;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DataSource dataSource;</span><br><span class="line">    private File tempFile;</span><br><span class="line"></span><br><span class="line">    // 备份数据状态的方法</span><br><span class="line">    public void backup() throws Exception &#123;</span><br><span class="line">        this.getConnection();</span><br><span class="line">        this.backupCustom();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 恢复数据状态的方法</span><br><span class="line">    public void rollback() throws Exception &#123;</span><br><span class="line">        this.reset();</span><br><span class="line">        this.closeConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void backupCustom() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            QueryDataSet qds = new QueryDataSet(conn);</span><br><span class="line"></span><br><span class="line">            // 指定需要备份的数据库表，也可以通过编写一个方法来获得数据库中的所有表</span><br><span class="line">            qds.addTable(&quot;user&quot;);</span><br><span class="line">            tempFile = new File(&quot;temp.xml&quot;);</span><br><span class="line">            // 写入到 XML 文件中</span><br><span class="line">            FlatXmlDataSet.write(qds, new FileWriter(tempFile), &quot;UTF-8&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void getConnection() throws DatabaseUnitException &#123;</span><br><span class="line">        conn = new DatabaseConnection(DataSourceUtils.getConnection(dataSource));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void reset() throws FileNotFoundException, DatabaseUnitException, SQLException &#123;</span><br><span class="line">        FlatXmlDataSetBuilder builder = new FlatXmlDataSetBuilder();</span><br><span class="line">        builder.setColumnSensing(true);</span><br><span class="line">        IDataSet ds = builder.build(new FileInputStream(tempFile));</span><br><span class="line"></span><br><span class="line">        DatabaseOperation.CLEAN_INSERT.execute(conn, ds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void closeConnection() throws SQLException &#123;</span><br><span class="line">        if (conn != null) &#123;</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ResetDbService 服务提供了 backup、rollback 这两个方法。backup 会在测试启动时将当前数据库的状态暂存下来，测试完成时再调用 rollback 方法恢复，这样就能始终为每个测试提供一个一致的环境，也不需要手动对特定的数据进行清理，避免遗忘。<br />我们可以在测试的基类中组装这些准备、清理的工作，下面再介绍另外一种更灵活的组装方法。<br><a name="wDvPy"></a></p><h2 id="6-2-API-测试实例">6.2 API 测试实例</h2><p>前面介绍了几种工具的使用，这里通过最小的实例将它们组装起来。为了减少篇幅，下面只贴上必要的代码，完整的代码可以在 GitHub 仓库中找到：<a href="https://github.com/java-self-testing/java-self-testing-example/tree/master/api">https://github.com/java-self-testing/java-self-testing-example/tree/master/api</a>。<br />示例代码的目录结构如图 6-2 所示。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712881908955-7b20844c-ebfc-4542-a2bf-572fe63133b3.png#averageHue=%23444b48&amp;clientId=u30cfec57-467a-4&amp;from=paste&amp;id=u5ebc44d8&amp;originHeight=744&amp;originWidth=615&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=87193&amp;status=done&amp;style=none&amp;taskId=u74c62440-2fcd-4be7-83da-0228fd653e2&amp;title=" alt="image.jpg"><br />图 6-2 API 测试示例<br />下面是示例项目的依赖的包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project</span><br><span class="line">    xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.4.12&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;artifactId&gt;api&lt;/artifactId&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;flyway-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;8.0.25&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ch.vorburger.mariaDB4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mariaDB4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.4.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;rest-assured&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.4.0&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.dbunit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dbunit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.7.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt;</span><br><span class="line">                    &lt;outputDirectory&gt;../package&lt;/outputDirectory&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;8&lt;/source&gt;</span><br><span class="line">                    &lt;target&gt;8&lt;/target&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>源码下面的包中实现了 2 个简单的 API，便于管理员添加和列出用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/api/users&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&quot;)</span><br><span class="line">    public ResponseEntity&lt;List&lt;User&gt;&gt; getAll() &#123;</span><br><span class="line">        return ResponseEntity.ok(userService.listAll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&quot;)</span><br><span class="line">    public ResponseEntity addUser(@RequestBody AddUserRequest addUserRequest) &#123;</span><br><span class="line">        User savedUser = userService.add(addUserRequest);</span><br><span class="line">        return ResponseEntity.created(</span><br><span class="line">                URI.create(&quot;/api/users/&quot; + savedUser.getId())</span><br><span class="line">        ).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试目录中，有一个 TestBase ，是为所有测试类的基类，用于初始化测试上下文。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest(webEnvironment = RANDOM_PORT, classes = &#123;Application.class&#125;)</span><br><span class="line">@TestExecutionListeners(&#123;</span><br><span class="line">        DependencyInjectionTestExecutionListener.class,</span><br><span class="line">        ResetDbListener.class,</span><br><span class="line">&#125;)</span><br><span class="line">public abstract class TestBase &#123;</span><br><span class="line"></span><br><span class="line">    @LocalServerPort</span><br><span class="line">    private int port;</span><br><span class="line"></span><br><span class="line">    @BeforeEach</span><br><span class="line">    public void setUp() &#123;</span><br><span class="line">        System.out.println(&quot;port:&quot; + port);</span><br><span class="line"></span><br><span class="line">        RestAssured.port = port;</span><br><span class="line">        RestAssured.basePath = &quot;/api/&quot;;</span><br><span class="line">        RestAssured.enableLoggingOfRequestAndResponseIfValidationFails();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@TestExecutionListeners 注解是 JUnit 的一种高级用法，可以注册测试生命周期函数，类似于 @BeforeEach 和 @AfterEach 的作用，但是更加简洁，使用该注解时需要实现 TestExecutionListener 接口。<br />下面介绍两个常用的 TestExecutionListener 接口的实现。</p><ul><li>DependencylnjectionTestExecutionListener：可以对测试类中的依赖进行注入，如果没有这个类，就会加载不到 @LocalServerPort，因为它实际上是一个 @Value 注解的包装。</li><li>TransactionalTestExecutionListener：用于保证插入数据库中的测试数据在测试完成之后会进行事务回滚。也就是说，这个监听器可以将插入的数据删除，保证数据库干净。实际上，这个类能起到类似 DbUnit 的作用。但是，它俩又有所不同，DbUnit 可以完整地验证事务的结果，然后进行清理：TransactionalTestExecutionListener 则是让测试中的事务统统不提交。由于 API 测试是一个 E2E 测试，为了提高测试的准确性，需要尽量使用完整的测试方式，因此在某些场景下可以酌情使用 TransactionalTestExecutionListener。</li></ul><p>下面定义一个 ResetDbListener，用来暂存和恢复数据库的状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ResetDbListener extends AbstractTestExecutionListener &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void beforeTestMethod(TestContext testContext) throws Exception &#123;</span><br><span class="line">        ResetDbService resetDbService =</span><br><span class="line">                testContext.getApplicationContext().getBean(ResetDbService.class);</span><br><span class="line">        resetDbService.backup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterTestMethod(TestContext testContext) throws Exception &#123;</span><br><span class="line">        ResetDbService resetDbService =</span><br><span class="line">                testContext.getApplicationContext().getBean(ResetDbService.class);</span><br><span class="line">        resetDbService.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 ResetDbListener 中不能使用依赖注入，因此要使用测试上下文来加载 ResetDbService。前面已经展示过 ResetDbService 的代码，我们也可以自己实现一个其他版本的 ResetDbService。<br />接下来就可以创建测试了，在 UserController 对应的测试目录下创建两个测试，让它们分别对应列出用户和添加用户这两个操作。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class UserControllerTest extends TestBase &#123;</span><br><span class="line">    @Test</span><br><span class="line">    void should_list_all_users() &#123;</span><br><span class="line">        given()</span><br><span class="line">                .contentType(&quot;application/json&quot;)</span><br><span class="line">                .when()</span><br><span class="line">                .get(&quot;/users&quot;)</span><br><span class="line">                .then().statusCode(200);    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void should_add_user() &#123;</span><br><span class="line">        given()</span><br><span class="line">                .contentType(&quot;application/json&quot;)</span><br><span class="line">                .body(Maps.of(</span><br><span class="line">                        &quot;name&quot;, &quot;test-user&quot;,</span><br><span class="line">                        &quot;email&quot;, &quot;test@email.com&quot;,</span><br><span class="line">                        &quot;password&quot;, &quot;123456&quot;</span><br><span class="line">                ))</span><br><span class="line">                .when()</span><br><span class="line">                .post(&quot;/users&quot;)</span><br><span class="line">                .then().statusCode(201);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是两个最基本的测试，由于只是演示，我们没有编写更多的测试用例。在这两个测试中，状态码的断言比较简单，例如在第二个测试中，验证了最终返回的是 201 状态码。但是，对返回值的断言稍显复杂，后面会专门讨论如何实现复杂的断言。<br />到目前为止，基于 REST Assured 的 API 测试就完成了，这里面的每个测试里都只有一个非常简洁的链式结构，可维护性和阅读性都非常高。下面我们来展开看一下 API 测试的各个阶段。<br />以测试用例 should_add_user 为例，其测试的逻辑是提交一组数据给 / users API，用于创建用户。given 方法是门面类 RestAssured 的一个方法，它创建了一个测试规格对象 RequestSpecification 的实例。基于这个实例，在每次调用新的方法后，都会返回一个新的实例用于链式调用。<br />这个调用链有以下几个明显的阶段，每个阶段返回的对象不同。<br />（1）Given 阶段<br />返回 RequestSpecification 实例，用于组织请求的数据。它提供了设置端口、提交数据、Query 参数、Session、请求头等一系列方法，方便构建 HTTP 数据体。<br />（2）When 阶段<br />when 方法与 given 方法所做的事情一样，只是它的语法更符合 BDD 风格。真正的 When 阶段是通过与 HTTP 动词（Method）同名的方法 get、put、post 等实现的。例如，调用 get 方法后会返回 Response 对象。<br />（3）Then 阶段<br />得到返回值后可以通过 Response 上的 getBody、getHeader 等方法直接获得数据并进行断言，然后中断链式调用。也可以使用 then 方法获取 ValidatableResponseOptions 对象，并将其传入各种校验器校验 Response 中的数据，校验的方法有 statusCode、body、header 等。<br />下面是一个获取返回结果的示例，这里基于从列表接口获得的数据进行断言：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String body =  given()</span><br><span class="line">         .contentType(&quot;application/json&quot;)</span><br><span class="line">         .when()</span><br><span class="line">         .get(&quot;/users&quot;).getBody().print();</span><br><span class="line"> Assertions.assertEquals(&quot;[&#123;&quot;id&quot;:&quot;admin-id&quot;,&quot;name&quot;:&quot;admin&quot;,&quot;role&quot;:&quot;ADMIN&quot;,&quot;email&quot;:&quot;admin@test.com&quot;,&quot;password&quot;:&quot;$2a$10$Q9xt3B2Ixe0tGnbCjVWAbunD4lYdf5PpMSYGyLNrD4S38FGUt4NMC&quot;,&quot;createdAt&quot;:&quot;2020-12-16T21:45:41.147Z&quot;,&quot;updatedAt&quot;:&quot;2020-12-16T21:45:41.147Z&quot;&#125;]&quot;, body);</span><br></pre></td></tr></table></figure><p>但是如果要进一步对结果中的属性进行断言，需要先使用 JSON 解析库将字符串解析为 Java 对象，然后再对解析后的对象属性进行断言。如此一来，依赖代码就是冗长的。虽然 ValidatableResponseOptions 提供了直接在调用链上断言的方法，比如在 then 方法后面调用 statusCode(201) 方法来判断状态码，但若面对的是 body 方法中复杂的数据结构，就不能这么简单地完成校验了。<br />为了让断言更容易，可以借用 JsonPath 和 XmIPath 这两种工具，通过传入一个 JSON 路径表达式来访问数据中的特定节点，从而完成断言。在 then 方法后，可以基于 body 方法的各种重载配合 JSON 路径表达式完成简洁和高效的断言。<br><a name="GWWf4"></a></p><h2 id="6-3-使用-JsonPath-断言">6.3 使用 JsonPath 断言</h2><p>由于越来越多的应用都开始使用 RESTful API（RESTful API 的数据格式为 JSON），因此可以使用一种表达式（JsonPath）来进行断言。这里为了演示 JsonPath 的使用，将用户列表的接口修改为 Page 类型了，这样可以让返回结果变得更复杂一些。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// UserController</span><br><span class="line">@GetMapping(&quot;&quot;)</span><br><span class="line">public ResponseEntity&lt;Page&lt;User&gt;&gt; getAll() &#123;</span><br><span class="line">  return ResponseEntity.ok(userService.listAll());</span><br><span class="line">&#125;</span><br><span class="line">// UserService</span><br><span class="line">public Page&lt;User&gt; listAll() &#123;</span><br><span class="line">    return userRepository.findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时返回的数据结构会带上分页信息，相对复杂了一些，具体如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;content&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: &quot;admin-id&quot;,</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;totalPages&quot;: 1,</span><br><span class="line">    &quot;totalElements&quot;: 1,</span><br><span class="line">    &quot;size&quot;: 15,</span><br><span class="line">    &quot;number&quot;: 0,</span><br><span class="line">    &quot;numberOfElements&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>REST Assured 提供的 body 方法可接收一个 JsonPath 和一个 Matcher。大部分情况下，将不同的 JsonPath 和 Matcher 组合使用就可以完成需要的断言。<br />下面是常见的断言示例：</p><ul><li>断言属性。例如 totalPages 属性的值为 1，可以写为. body(“$.totalPages”, is(1))。</li><li>断言数组长度。例如 content 属性的内容长度为 1，可以写为. body(“$.content. size()”, is(1))。</li><li>断言数组中具体的属性。例如 content 属性中第一个元素的 name 属性值为 admin，可以写为. body(“$.content[0].name”,is(“admin”))。</li></ul><p>在 JsonPath 中提供了一些特殊的符号来匹配部分数据结构，可以把这些符号叫作操作符。比如，点号用于匹配对象的属性。表 6-1 列出了常用的操作符。<br />表 6-1 常用 JsonPath 操作符</p><table><thead><tr><th>操作符</th><th>用途</th></tr></thead><tbody><tr><td>$</td><td>要查询的根元素，一般置于表达式之前</td></tr><tr><td>@</td><td>迭代器的当前元素</td></tr><tr><td>*</td><td>通配符操作符，用于模糊匹配</td></tr><tr><td>…</td><td>深度匹配，跨多层级匹配</td></tr><tr><td>.</td><td>子属性匹配</td></tr><tr><td>[‘’ (,‘’)]</td><td>一般用于匹配对象的多个属性</td></tr><tr><td>[ (, )]</td><td>根据数组索引访问</td></tr></tbody></table><p><a name="YLmy1"></a></p><h2 id="6-4-鉴权的处理">6.4 鉴权的处理</h2><p>API 测试的鉴权处理常用如下方法：</p><ul><li>针对 API 使用 Basic 鉴权。现实中，对于暴露给用户的 API 几乎都不会使用这种鉴权方式，但是服务之间鉴权使用得较为广泛。</li><li>针对 API 使用 Token 鉴权。每一个测试可以生成一次鉴权 Token，并在 Header 中使用。</li><li>针对 API 使用 Cookie 鉴权：使用 Session 方式传递鉴权信息，RESTAssured 提供的 SessionFilter 可以作为一种更方便的方法。<br><a name="AP2um"></a></li></ul><h3 id="6-4-1-Basic-鉴权">6.4.1 Basic 鉴权</h3><p>认证信息都是使用 HTTP 头部来传递的，Basic 认证就是将用户名和口令拼接，并进行 Base64 编码，然后放到 Authorization 头信息中。<br />例如，用户名 “admin”，口令 “123456”，使用 “：” 拼接并编码后变为 YWRtaW46 MTIzNDU2。在 HTTP 包中发送的数据如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Basic YWRtaW46MTIzNDU2</span><br></pre></td></tr></table></figure><p>可以手动使用 header 来完成鉴权：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">given().header(&quot;Authorization&quot;, &quot;Basic YWRtaW46MTIzNDU2&quot;)</span><br></pre></td></tr></table></figure><p>也可以使用快捷方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">given().auth().basic(&quot;admin&quot;, &quot;123456&quot;)</span><br></pre></td></tr></table></figure><p>如果需要全局增加鉴权，可以直接使用 RestAssured 类的全局属性，不过这会降低灵活性。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RestAssured.authentication = basic(&quot;admin&quot;, &quot;123456&quot;);</span><br></pre></td></tr></table></figure><p><a name="bFE2O"></a></p><h3 id="6-4-2-Token-鉴权">6.4.2 Token 鉴权</h3><p>Token 鉴权是最灵活的方式，与 Basic 鉴权类似，都是在 HTTP 请求的头部传人认证信息。一般使用 Token 鉴权时都会使用 Bearer 前缀，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer a1e1eb29-2733-4ce3-b2cc-4569df7fdf0e</span><br></pre></td></tr></table></figure><p>与 Token 鉴权类似的还有 JWT 鉴权、OAuth 鉴权等。这些鉴权方式都是通过生成一种简单的凭证实现的，不同之处在于 JWT 是一种自包含凭证，它会将鉴权信息编码到 Token 中，而 OAuth 为分布式鉴权，需要使用 access_token 和 refreshToken 这两种 Token。<br />使用 Token 鉴权时，可以在测试中提前准备一个 Token，并在每个测试中复用。这里因为是在同一个项目中编写的测试用例，所以会在测试中直接使用源代码中的方法，这样更方便。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private AuthorizeService authorizeService;</span><br><span class="line">private String token;</span><br><span class="line"></span><br><span class="line">...  </span><br><span class="line"></span><br><span class="line">@BeforeEach</span><br><span class="line">public void setup() &#123;  </span><br><span class="line">    // 调用父类的初始化方法  </span><br><span class="line">    super.setup();  </span><br><span class="line">    // 设置一个默认测试用户  </span><br><span class="line">    ...   </span><br><span class="line">    this.token = authorizeService.login(User user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test() &#123;    </span><br><span class="line">    given().contentType(&quot;application/json&quot;).header(&quot;Authorization&quot;,&quot;Bearer &quot; + token);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="GB8CZ"></a></p><h3 id="6-4-3-Cookie-鉴权">6.4.3 Cookie 鉴权</h3><p>对于一些使用 Cookie 鉴权的 API，可以通过暂存 Cookie 的方法来实现测试中的鉴权。Cookie 鉴权的原理是用户在初次访问页面或 API 时，服务器会生成一个 Session，此 Session 由 Session ID 标识，并返回给用户在 Cookie 中存储。用户登录后，关联用户凭证信息到这个 Session ID，只要用户每次请求都带上这个 ID，服务器就能识别。<br />由于 Cookie 的自动附加是浏览器的默认功能，因此使用这种方式时开发者不需要做太多工作。<br />我们可以在登录后抽取出 Cookie，然后在下次请求时带上，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 1. 登录并留存 Cookies</span><br><span class="line">Map&lt;String, String&gt; cookies = given()</span><br><span class="line">  .contentType(&quot;application/json&quot;)</span><br><span class="line">  .body(Maps.of(&quot;email&quot;, &quot;test@email.com&quot;, &quot;password&quot;, &quot;123456&quot;))</span><br><span class="line">  .when().post(&quot;/authorizes&quot;)</span><br><span class="line">  .then().statusCode(201).extract().cookies();</span><br><span class="line"></span><br><span class="line">// 2. 使用 cookies 获取用户个人信息</span><br><span class="line">given()</span><br><span class="line">  .contentType(&quot;application/json&quot;)</span><br><span class="line">  .cookies(cookies)</span><br><span class="line">  .when().post(&quot;/authorizes/me&quot;)</span><br><span class="line">  .then().statusCode(200);</span><br></pre></td></tr></table></figure><p>RESTAssured 在 2.0.0 版本之后提供了一个快捷方式，即可以使用 SessionFilter 来保持会话，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SessionFilter sessionFilter = new SessionFilter();</span><br><span class="line">given()</span><br><span class="line">  .contentType(&quot;application/json&quot;)</span><br><span class="line">  .filter(sessionFilter)</span><br><span class="line">  .body(Maps.of(&quot;email&quot;, &quot;test@email.com&quot;, &quot;password&quot;, &quot;123456&quot;))</span><br><span class="line">  .when().post(&quot;/authorizes&quot;)</span><br><span class="line">  .then().statusCode(201);</span><br></pre></td></tr></table></figure><p>当然，还有一种方法是在测试中关闭鉴权，不过这会让测试的价值降低，因此并不推荐。<br><a name="PUznk"></a></p><h2 id="6-5-文件处理">6.5 文件处理</h2><p>有一些 API 需要上传文件，比如导入、上传图片等，因此对其进行测试时就需要处理相应的文件。下面介绍几种可以从测试目录的资源文件夹中读取文件的方法，这里不需要使用绝对路径。<br />假设在测试资源目录中有一个文件用于测试，其文件地址为 “classpath:file/test.pdf”。第一种读取文件的方法是使用 ClassLoader。这时可以直接使用类加载器来加载相应的文件。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = getClass().getClassLoader();</span><br><span class="line">File file = new File(classLoader.getResource(&quot;file/test.pdf&quot;).getFile());</span><br></pre></td></tr></table></figure><p>第二种方法是使用 Google 的 Guava。如果项目中引入了 Google 的 Guava，那么可以使用 Resources 工具类来实现文件的加载，非常方便。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resources.getResource(&quot;file/test.pdf&quot;).getFile();</span><br></pre></td></tr></table></figure><p>如果是文本文件，还可以使用 Resources.toString 来读取文本的内容。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resources.toString(Resources.getResource(&quot;file/test.txt&quot;));</span><br></pre></td></tr></table></figure><p>获取文件或者文件内容后，可以将其用于后续的测试，在 given 方法后可以使用 multiPart 方法来构建表单中的文件数据。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">given()</span><br><span class="line">  .multiPart(Resources.getResource(&quot;file/test.pdf&quot;).getFile())</span><br><span class="line">  .when().post(&quot;/upload&quot;);</span><br></pre></td></tr></table></figure><p>不过采用这种写法时，默认文件表单控件的 name 属性为 “file”，某些 API 会自定义 name 属性需要注意增加相应的参数。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">given()</span><br><span class="line">  .multiPart(&quot;custom_file_name&quot;, Resources.getResource(&quot;file/test.pdf&quot;).getFile())</span><br><span class="line">  .when().post(&quot;/upload&quot;);</span><br></pre></td></tr></table></figure><p><a name="Vt5V9"></a></p><h2 id="6-6-模拟第三方-API">6.6 模拟第三方 API</h2><p>如果我们需要测试的应用依赖于第三方 API，那么我们要先模拟所依赖的 API 才能完成测试，尤其是在微服务架构下，否则会让测试变得比较困难。<br />除了搭建真实的服务以外，我们还可以使用一些工具和方法来进行模拟。在实际工作中，根据自己的需要从形形色色的方法中寻找一个成本和效果都能达到设计目标的方法即可。<br><a name="VUzCU"></a></p><h3 id="6-6-1-使用适配器模式模拟">6.6.1 使用适配器模式模拟</h3><p>一般来说，我们在和第三方 API 对接时，需要先定义一些客户端对象，以便根据场景的不同把与第三方对接的这部分逻辑封装起来，这种模式称为适配器（Adapter）模式。如果适配器的设计良好，只需要模拟对应的对象或者 Bean 即可。<br /><a href="http://xkcd.com">xkcd.com</a> 是一个程序员四格漫画网站，我在 <a href="https://any-api.com">https://any-api.com</a> 中发现了它的 API。这个看上去极其简单的 API 可用来发布一些漫画信息，下面就用它来演示 API 模拟的方法。API 的地址为 <a href="https://xkcd.com/info.0.json%E3%80%82%E8%AE%BF%E9%97%AE%E6%AD%A4%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%8F%AF%E5%BE%97%E5%88%B0">https://xkcd.com/info.0.json。访问此地址，可得到</a> JSON 格式的返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;month&quot;: &quot;6&quot;,</span><br><span class="line">  &quot;num&quot;: 2472,</span><br><span class="line">  &quot;link&quot;: &quot;&quot;,</span><br><span class="line">  &quot;year&quot;: &quot;2021&quot;,</span><br><span class="line">  &quot;news&quot;: &quot;&quot;,</span><br><span class="line">  &quot;safe_title&quot;: &quot;Fuzzy Blob&quot;,</span><br><span class="line">  &quot;transcript&quot;: &quot;&quot;,</span><br><span class="line">  &quot;alt&quot;: &quot;If there&#x27;s no dome, how do you explain the irregularities the board discovered in the zoning permits issued in that area!?&quot;,</span><br><span class="line">  &quot;img&quot;: &quot;https://imgs.xkcd.com/comics/fuzzy_blob.png&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;Fuzzy Blob&quot;,</span><br><span class="line">  &quot;day&quot;: &quot;4&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Spring Boot 的生态中，可以选择的 HTTP 客户端挺多，比如 RestTemplate、Feign 或者简单的 OkHttp 等，在这个例子中，使用的是 RestTemplate。<br />如图 6-3 所示，在项目中添加一个 DailyComicController 和相关的类，用于调用远程的 API。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712881909272-81417b7e-ec1f-4630-a024-8d2999a677dc.png#clientId=u30cfec57-467a-4&amp;from=paste&amp;id=u06690cc2&amp;originHeight=627&amp;originWidth=606&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=78967&amp;status=done&amp;style=none&amp;taskId=u0850f3bb-9b5f-4e70-9152-a810c2806ef&amp;title=" alt="image.jpg"><br />图 6-3 更新后的代码结构<br />Controller 类会调用 XkcdClient，并返回 DailyComic-Response 对象，这个对象目前只有一个 imageLink 属性，从 API 中返回的对应字段为 img。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/api/daily-comic&quot;)</span><br><span class="line">public class DailyComicController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private XkcdClient xkcdClient;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&quot;)</span><br><span class="line">    public ResponseEntity&lt;DailyComicResponse&gt; getCurrentComic() &#123;</span><br><span class="line">        XkcdVO xkcdVO = xkcdClient.getXkcdResponse();</span><br><span class="line">        return ResponseEntity.ok(DailyComicResponse.builder().imageLink(xkcdVO.getImg()).build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XkcdClient 类使用 RestTemplate 的 getForObject 方法来获取远程 API 的数据。Spring 框架已经帮我们封装好了 HTTP 客户端，我们只需要定义一下 RestTemplate 的 Bean。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class XkcdClient &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    public XkcdVO getXkcdResponse() &#123;</span><br><span class="line">        return restTemplate.getForObject(&quot;https://xkcd.com/info.0.json&quot;, XkcdVO.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来编写一个测试，验证这个接口是否能返回需要的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class DailyComicControllerTest extends TestBase &#123;</span><br><span class="line">    @Test</span><br><span class="line">    void get_current_comic() &#123;</span><br><span class="line">        given()</span><br><span class="line">                .contentType(&quot;application/json&quot;)</span><br><span class="line">                .when()</span><br><span class="line">                .get(&quot;/daily-comic&quot;)</span><br><span class="line">                .then().statusCode(200)</span><br><span class="line">                .body(&quot;imageLink&quot;, is(&quot;https://imgs.xkcd.com/comics/fuzzy_blob.png&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果代码编写无误，这个测试可以通过。这时还没有使用任何模拟工具，测试运行时会有如下两个问题。</p><ul><li>每次运行测试时都需要依赖外部的 API，并且要保证能访问到服务目标。</li><li>如果对方的 API 发生了变化，测试就会失败。</li></ul><p>接下来模拟 XkcdClient 的 Bean，首先在 TestBase 中添加如下代码，实现对 Bean 的模拟，这部分在前面章节已经讲过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@MockBean</span><br><span class="line">private XkcdClient xkcdClient;</span><br></pre></td></tr></table></figure><p>然后在测试中使用 @Autowired 获得这个模拟对象，并给予特定的返回值。这里需要注意的是，@MockBean 必须先在 TestBase 类中定义好，然后再使用 @Autowired。下面就是完整的带有 Mock 的测试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class DailyComicControllerTest extends TestBase &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private XkcdClient xkcdClient;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void get_current_comic() &#123;</span><br><span class="line">        BDDMockito.given(xkcdClient.getXkcdResponse()).willReturn(new XkcdVO() &#123;&#123;</span><br><span class="line">            setImg(&quot;https://imgs.xkcd.com/comics/fuzzy_blob.png&quot;);</span><br><span class="line">        &#125;&#125;);</span><br><span class="line"></span><br><span class="line">        given()</span><br><span class="line">                .contentType(&quot;application/json&quot;)</span><br><span class="line">                .when()</span><br><span class="line">                .get(&quot;/daily-comic&quot;)</span><br><span class="line">                .then().statusCode(200)</span><br><span class="line">                .body(&quot;imageLink&quot;, is(&quot;https://imgs.xkcd.com/comics/fuzzy_blob.png&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 @MockBean 的方法模拟第三方 API，对源代码的侵入较强，对实现代码有一些要求。一些比较复杂的系统访问第三方 API 时，相关的实现可能没那么规范，使用 MockBean 也就没那么方便了，这时可以使用外部的 API Mock 工具。这些 Mock 工具的原理是通过启动一个服务来加载相应的 JSON 文件，从而实现定制的返回，它们也会提供简单的规则实现不同的响应需求。<br />开源的 Mock 工具非常多，比如 WireMock、Moco、json-server。下面介绍一个最具有代表性的 Mock 工具：WireMock。<br><a name="lqdrN"></a></p><h3 id="6-6-2-WireMock">6.6.2 WireMock</h3><p>WireMock 是一个 HTTPMock 服务器，它的核心是一个 Web 服务器，可以为特定的请求规则返回相应的内容。另外，它还提供了验证功能，可保证测试的有效性。<br />WireMock 还可以实现录制请求的功能，这项功能可大大减少测试的工作量。当一个请求过来时，WireMock 工具会先把请求转发到服务目标上，或者在返回相应的值后将其缓存下来，并为测试生成对应的文件。另外一个比较有意思的功能是返回错误或延迟的数据，这用于测试一些特殊的场景，以便覆盖更多的测试用例。<br />书中讨论的是 Java API 测试，刚好 WireMock 构建于 JVM 平台之上，它可以单独启动，也可以内嵌在项目中启动，稍后会演示这两种启动方式。由于可以独立启动，因此只要安装了 JRE 环境就可以运行，故而它不限于用于 Java 项目中。<br><a name="d2olW"></a></p><h4 id="1-独立启动">1. 独立启动</h4><p>根据官网的介绍可知，WireMock 通过 Jar 包直接启动时，与命令行程序没有区别。可以在 Maven 仓库中找到 Jar 文件的下载地址 <a href="https://repol.maven.org/maven2/com/github/tomakehurst/wiremock-jre8-standalone/2.28.0/wiremock-jre8-standalone-2.28.0.jar%E3%80%82">https://repol.maven.org/maven2/com/github/tomakehurst/wiremock-jre8-standalone/2.28.0/wiremock-jre8-standalone-2.28.0.jar。</a><br />启动的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar wiremock-jre8-standalone-2.28.0.jar</span><br></pre></td></tr></table></figure><p>官网给出的参数比较多，这里选择几个常用的进行说明。</p><ul><li>–port: 设置一个 HTTP 的端口号。这是为了与 HTTPS 的端口区分开来，因为在 Web 服务器中，两种端口是不同的实现。</li><li>–https-port: 设置一个 HTTPS 端口。需要注意的是，WireMock 依然默认开启 HTTP 端口（默认值为 8080），如果开启了多个 WireMock 实例，最好也同时指定 HTTP 端口。大部分情况下，应用依赖的远程服务地址都是可以配置的。可以让生产使用 HTTPS，测试依然配置为 HTTP。如果需要配置 HTTPS，则需要相应的证书和密钥。</li><li>–bind-address: 主机鉴定绑定，默认绑定的是本地网络适配器（0.0.0.0），如果没有多个网卡，可以忽略。</li><li>–root-dir: 设置模拟数据文件的存放目录，用于存放 mappings 和_files 这两个子目录，默认为当前程序的工作目录。</li><li>–record-mappings: 开启记录模式，把请求到后方的数据记录下来，并存放到目录中。</li><li>–match-headers: 开启记录模式后，把一些请求头中的值也记录下来。</li><li>–enable-stub-cors: 允许自动发送 CORS 响应头，可以解决前端调试时存在的跨域问题，这里默认为关闭状态。</li><li>–help: 显示命令的帮助提示。</li></ul><p>此外，WireMock 还提供了 HTTPS 证书、代理和线程控制等相关参数，但是用得不多，如需使用，查询手册即可。<br />这里还是以 <a href="http://xkcd.com">xkcd.com</a> 的访问值为例进行说明，我们不使用任何参数启动 WireMock，而是通过 API 动态地添加 Mock 数据。为了减少代码，只输出一个 “Hello World”。服务启动后，组织下面的 API 请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST --data &#x27;&#123; &quot;request&quot;: &#123; &quot;url&quot;: &quot;/info.0.json&quot;, &quot;method&quot;:&quot;GET&quot; &#125;, &quot;response&quot;: &#123;&quot;status&quot;: 200, &quot;body&quot;:&quot;&#123;&quot;hello&quot;:&quot;world&quot;&#125;&quot; &#125;&#125;&#x27; </span><br><span class="line">http://localhost:8080/__admin/mappings/new</span><br></pre></td></tr></table></figure><p>其中，/_admin/mappings/new API 是 WireMock 的管理 API，可以使用它设置特定的模拟内容。我们来看一下设置是否成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8080/info.0.json</span><br><span class="line"></span><br><span class="line">&#123;&quot;hello&quot;:&quot;world&quot;&#125;</span><br></pre></td></tr></table></figure><p>大家可能注意到了，每次使用模拟数据时，都需要调用一次 API 先设置模拟数据，这样做比较麻烦，可以直接编写配置文件来实现模拟数据的准备工作。<br />实例启动时会自动创建_files 和 mappings 这两个目录，编写的配置文件可以放到这两个目录中，下面介绍一下这两个目录的使用方法。</p><ul><li>__files: 当 WireMock 启动时，这个目录会被当作一个静态服务器的根路径。例如，在这个目录下编写 hello.html，则可以通过 <a href="http://localhost:8080/hello.html">http://localhost:8080/hello.html</a> 访问。通常，这个目录用于一些没有特定规则的场景，也可以用于大的文件 API，比如需要存放一张图片时。</li><li>mappings: 这个目录可以用于请求映射返回需要的内容，比如匹配请求中的 URL、Header，返回特定的数据。可以用于定义更为复杂的交互场景，适合较为动态的 API。另外，它也具有比__files 更高的优先级。</li></ul><p>mappings 中不能像 __files 一样直接放静态文件（如果这样就不能发挥动态模拟的价值了），需要使用规定的 DSL 语法来实现。依然使用 xkcd 的例子，不过这次是通过定义配置文件的方式来实现模拟数据的准备。<br />在 mappings 目录的 info.0.json 中放入下面的文件内容，注意 body 方法接收的还是 String 类型，因此需要转义为 JSON 的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;request&quot;: &#123;</span><br><span class="line">        &quot;method&quot;: &quot;GET&quot;,</span><br><span class="line">        &quot;url&quot;: &quot;/info.0.json&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;response&quot;: &#123;</span><br><span class="line">        &quot;status&quot;: 200,</span><br><span class="line">      &quot;body&quot;:&quot;&#123;&quot;month&quot;:&quot;6&quot;,&quot;num&quot;:2472,&quot;link&quot;:&quot;&quot;,&quot;year&quot;:&quot;2021&quot;,&quot;news&quot;:&quot;&quot;,&quot;safe_title&quot;:&quot;Fuzzy Blob&quot;,&quot;transcript&quot;:&quot;&quot;,&quot;alt&quot;:&quot;If there&#x27;s no dome, how do you explain the irregularities the board discovered in the zoning permits issued in that area!?&quot;,&quot;img&quot;:&quot;https://imgs.xkcd.com/comics/fuzzy_blob.png&quot;,&quot;title&quot;:&quot;Fuzzy Blob&quot;,&quot;day&quot;:&quot;4&quot;&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="YVfHd"></a></p><h4 id="2-内嵌在-JUnit-平台中使用">2. 内嵌在 JUnit 平台中使用</h4><p>WireMock 不仅提供了独立启动的方式，还可以使用依赖包在测试中启动。通过 WireMock 暴露出来的 API 可实现灵活的配置、验证、重置、录制等功能，这就为我们的测试带来无限的可能。下面演示如何使用 WireMock 在测试中动态地模拟第三方服务。<br />首先，依然是在 POM 文件中添加依赖项，这里参考官网的例子使用了 wiremock-jre8 这个版本，建议大家根据 Java 版本选择合适的 WireMock 发行版。<br />下面创建一个测试类，直接启动 WireMockServer 即可，这与前面介绍的 RedisServer 类似，都是需要启动一个实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class UserMockServerTest extends TestBase &#123;</span><br><span class="line">    private WireMockServer wireMockServer;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @BeforeEach</span><br><span class="line">    public void setUp() &#123;</span><br><span class="line">        super.setUp();</span><br><span class="line">        wireMockServer = new WireMockServer(options().port(9090));</span><br><span class="line">        wireMockServer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterEach</span><br><span class="line">    void tearDown() &#123;</span><br><span class="line">        wireMockServer.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void test_mock_server() &#123;</span><br><span class="line">        String response = restTemplate.getForObject(&quot;http://localhost:9090/users&quot;, String.class);</span><br><span class="line">        System.out.println(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了简化演示，这里没实现源代码中的客户端代码，而是直接使用 RestTemplate 请求启动了 WireMock 的模拟服务。在 test_mock_server 测试中，我们访问 <a href="http://localhost:9090/users">http://localhost:9090/users</a> 会得到一个 404 的错误，因为这里还没有设置任何模拟数据。<br />接下来，编写一个最基本的动态模拟代码，并说明对应方法的用途。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">configureFor(&quot;localhost&quot;, 9090);</span><br><span class="line">stubFor(get(urlEqualTo(&quot;/users&quot;))</span><br><span class="line">        .willReturn(aResponse()</span><br><span class="line">                .withHeader(&quot;Content-Type&quot;, &quot;text/json&quot;)</span><br><span class="line">                .withBody(&quot;&#123;&quot;name&quot;:&quot;john&quot;&#125;&quot;)));</span><br></pre></td></tr></table></figure><p>configureFor(String host, int port) 方法用于给后续的方法 stubFor 配置一个 WireMock 的地址和端口，而 stubFor 的原理又与调用 WireMock 的 / admin 端口一样，因此也需要为其配置对应的端口。<br />stubFor(MappingBuilder mappingBuilder) 方法用于配置模拟的数据，由于 get 方法的重名方法太多（Mockito、JDK 等包中也有 get 方法），建议将 com.github.tomakehurst.wiremock. client.WireMock 这个包使用 “*” 引进来。get、urlEqualTo、aResponse 都是用于构建匹配规则和返回值的相关方法。<br />添加以上的方法后，再次运行测试。顺利的话，测试会通过并打印出需要返回的数据内容。上面通过 Java 语言描述的模拟数据等价于下面的 JSON 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;request&quot;: &#123;</span><br><span class="line">        &quot;method&quot;: &quot;GET&quot;,</span><br><span class="line">        &quot;url&quot;: &quot;/users&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;response&quot;: &#123;</span><br><span class="line">        &quot;status&quot;: 200,</span><br><span class="line">        &quot;body&quot;: &quot;&#123;\&quot;name\&quot;:\&quot;john\&quot;&#125;&quot;,</span><br><span class="line">        &quot;headers&quot;: &#123;</span><br><span class="line">            &quot;Content-Type&quot;: &quot;text/json&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WireMock 类中提供了非常多的 Builder 方法，这样就可以更加灵活地构建模拟 API，这对于构建一些异常返回特别有用。比如，我们可以省略 urlEqualTo 方法，直接使用 okJson 方法构建 JSON 的返回内容。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void test_mock_json() &#123;</span><br><span class="line">    configureFor(&quot;localhost&quot;, 9090);</span><br><span class="line">    stubFor(get(&quot;/users&quot;)</span><br><span class="line">            .willReturn(okJson(&quot;&#123;\&quot;name\&quot;:\&quot;john\&quot;&#125;&quot;)));</span><br><span class="line"></span><br><span class="line">    String response = restTemplate.getForObject(&quot;http://localhost:9090/users&quot;, String.class);</span><br><span class="line">    Assertions.assertEquals(&quot;&#123;\&quot;name\&quot;:\&quot;john\&quot;&#125;&quot;, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当测试服务异常时，也可以使用 unauthorized、forbidden、notFound 等方法构建异常返回。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void mock_status() &#123;</span><br><span class="line">    configureFor(&quot;localhost&quot;, 9090);</span><br><span class="line">    stubFor(get(&quot;/limited-resources&quot;)</span><br><span class="line">            .willReturn(unauthorized()));</span><br><span class="line"></span><br><span class="line">    Assertions.assertThrows(HttpClientErrorException.Unauthorized.class, () -&gt; &#123;</span><br><span class="line">        restTemplate.getForEntity(&quot;http://localhost:9090/limited-resources&quot;, String.class);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以使用 temporaryRedirect 构建跳转方法，比如测试 302、301 跳转。默认的 RestTemplate 开启了自动获取跳转后的数据的功能，这里为了演示方便，断言了跳转到 /redirect-to 后的返回值。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void mock_redirect() &#123;</span><br><span class="line">    configureFor(&quot;localhost&quot;, 9090);</span><br><span class="line">    stubFor(get(&quot;/redirect-to&quot;)</span><br><span class="line">            .willReturn(ok(&quot;new-url&quot;)));</span><br><span class="line">    stubFor(get(&quot;/redirect&quot;)</span><br><span class="line">            .willReturn(temporaryRedirect(&quot;/redirect-to&quot;)));</span><br><span class="line"></span><br><span class="line">    String response = restTemplate.getForObject(&quot;http://localhost:9090/redirect-to&quot;, String.class);</span><br><span class="line">    Assertions.assertEquals(response, &quot;new-url&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想关闭 RestTemplate 的自动跳转，可以自己定义一个 Bean 进行配置。关闭 RestTemplate 的自动跳转（也可以使用前面介绍的 TestRestTemplate）后，可以使用 getForEntity 获取返回的 HTTP 包实体，并获取真实的状态码。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public RestTemplate restTemplate () &#123;</span><br><span class="line">    RestTemplate restTemplate = new RestTemplate();</span><br><span class="line">    final HttpComponentsClientHttpRequestFactory factory =</span><br><span class="line">            new HttpComponentsClientHttpRequestFactory();</span><br><span class="line">    CloseableHttpClient build =</span><br><span class="line">            HttpClientBuilder.create().disableRedirectHandling().build();</span><br><span class="line">    factory.setHttpClient(build);</span><br><span class="line">    restTemplate.setRequestFactory(factory);</span><br><span class="line">    return restTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="YeudV"></a></p><h4 id="3-调用验证">3. 调用验证</h4><p>WireMock 实例在启动后会记录所有的测试请求，并且在重置之前都不会清理掉。它的用处就是获取请求的实际情况，从而判定测试结果。同时，它也可以获取所有请求的详情，为调试 Bug 带来便利。<br />通过 Jar 包独立启动的 WireMock 服务可以通过管理 API 获取匹配结果，但是使用独立启动的 WireMock 服务时，很少会去验证模拟数据的匹配情况。<br />通过内嵌启动的 WireMock 服务使用 Java API 来实现对 API 的验证就比较简单，只需要调用 verify 方法即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void verify_mock_server() &#123;</span><br><span class="line">    // 准备 Mock 数据</span><br><span class="line">    configureFor(&quot;localhost&quot;, 9090);</span><br><span class="line">    stubFor(get(urlEqualTo(&quot;/users&quot;))</span><br><span class="line">            .willReturn(aResponse()</span><br><span class="line">                    .withHeader(&quot;Content-Type&quot;, &quot;text/json&quot;)</span><br><span class="line">                    .withBody(&quot;&#123;\&quot;name\&quot;:\&quot;john\&quot;&#125;&quot;)));</span><br><span class="line"></span><br><span class="line">    // 调用被测试内容</span><br><span class="line">    String response = restTemplate.getForObject(&quot;http://localhost:9090/users&quot;, String.class);</span><br><span class="line">    System.out.println(response);</span><br><span class="line"></span><br><span class="line">    // 验证被依赖 API 是否被调用</span><br><span class="line">    verify(getRequestedFor(urlEqualTo(&quot;/users&quot;))</span><br><span class="line">            .withHeader(&quot;Content-Type&quot;, equalTo(&quot;text/json&quot;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码中的 verify 方法与 Mockito 中的相关方法重名，请注意引入的包是否正确。这里的 getRequestedFor 获得 Builder 对象的语法与准备 Mock 数据时非常相似。verify 方法没有别的参数时，会验证匹配的规则是否至少调用了一次。<br />在这个例子中，restTemplate 对象发出去的请求没有带上 Content-Type，因此测试会失败。测试失败后，可以在控制台查看错误信息，如图 6-4 所示。使用 IntelliJIDEA 运行测试，单击错误信息可以查看差异，从而分析问题产生的原因。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712881908886-418b9676-d0ee-4b73-86eb-d83df0bda8b6.png#clientId=u30cfec57-467a-4&amp;from=paste&amp;id=u9b7cce50&amp;originHeight=294&amp;originWidth=881&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=42285&amp;status=done&amp;style=none&amp;taskId=u8939dc3f-966e-406a-977b-672963bb72f&amp;title=" alt="image.jpg"><br />图 6-4 对比分析错误原因<br />当然，与 Mockito 类似，verify 方法除了默认执行至少一次的校验外，还提供了多种验证操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">verify(lessThan(5), postRequestedFor(urlEqualTo(&quot;/many&quot;)));</span><br><span class="line">verify(lessThanOrExactly(5), postRequestedFor(urlEqualTo(&quot;/many&quot;)));</span><br><span class="line">verify(exactly(5), postRequestedFor(urlEqualTo(&quot;/many&quot;)));</span><br><span class="line">verify(moreThanOrExactly(5), postRequestedFor(urlEqualTo(&quot;/many&quot;)));</span><br><span class="line">verify(moreThan(5), postRequestedFor(urlEqualTo(&quot;/many&quot;)));</span><br></pre></td></tr></table></figure><p><a name="nyZFx"></a></p><h4 id="4-自定义-JUnit-5-Extension">4. 自定义 JUnit 5 Extension</h4><p>我们知道 JUnit4 提供了 Rule，WireMock 也提供了一个 WireMockRule 来集成原生的 API。回顾之前介绍的 Rule，我们知道，Rule 是 JUnit 的一种拓展方式，可以让测试更为灵活，它能起到类似插件的作用。Rule 最基本的使用方式就是 @Rule 注解在测试类中声明。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Rule</span><br><span class="line">public WireMockRule wireMockRule = new WireMockRule();</span><br></pre></td></tr></table></figure><p>也可以增加一些参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Rule</span><br><span class="line">public WireMockRule wireMockRule = new WireMockRule(options().port(8888).httpsPort(8889));</span><br></pre></td></tr></table></figure><p>但是，我们的例子现在已经升级到了 JUnit5 版本，在 Junit5 中使用 Extension 代替了 Rule，让拓展的编写更容易理解。这里使用 WireMock 的原生 API 编写一个 JUnit 5 的 Extension。编写 Extension 的方法比较简单，因为我们可以直接使用 WireMockServer 对象作为父类，然后实现相应的接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class WireMockExtension extends WireMockServer implements BeforeEachCallback, AfterEachCallback &#123;</span><br><span class="line">    public WireMockExtension() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterEach(ExtensionContext context) &#123;</span><br><span class="line">        stop();</span><br><span class="line">        resetAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void beforeEach(ExtensionContext context) &#123;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个极其简单的 Extension 就开发完成了，使用 @RegisterExtension 可以注人 Extension 代替每次手动编写的 start、stop 方法。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class WireMockExtensionTest extends TestBase &#123;</span><br><span class="line">    @RegisterExtension</span><br><span class="line">    WireMockExtension wireMock = new WireMockExtension();</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WireMockServer 提供了根据参数构建模拟服务的方法，在 Extension 中也可以提供相应的方法。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 根据配置构建 WireMockServer</span><br><span class="line">public WireMockExtension(Options options) &#123;</span><br><span class="line">    super(options);</span><br><span class="line">&#125;</span><br><span class="line">// 根据端口构建 WireMockServer</span><br><span class="line">public WireMockExtension(int port, Integer httpsPort) &#123;</span><br><span class="line">    super(port, httpsPort);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="aPkqV"></a></p><h2 id="6-7-API-自动化测试策略">6.7 API 自动化测试策略</h2><p>在编写 API 测试时，测试策略是一件比较令人头疼的事情，相对来说，测试的一些技术问题反而比较好解决。原因是应用架构的水平参差不齐，API 的职责不是那么清晰，从而导致测试变得困难。<br />良好的 API 设计会尽可能地考虑我们之前所说的 MECE 原则（Mutually Exclusive Collectively Exhaustive），也就是说，在功能穷尽的情况下，还会设法做到彼此独立。这样一来，API 的职责就比较单一了，自然我们的测试工作也会相对简单。<br />对于不同的 API 类型，测试策略也会不一样。这里的测试策略与通常意义上的测试策略略有不同，因为已经限定了是 API 测试，所以它的测试目标、类型基本都是确定的，那么我们讨论的重点也就变成了如何更好地为 API 组织测试、如何提高测试有效性，以及如何让测试的编写变得更加便利。<br />在实际工作中，测试策略往往与架构有关，API 测试受架构的制约。例如，在微服务架构中，面向应用的 API 在一些公司叫作 Experience API、前台、BFF 等，而面向内部服务的 API 则叫作领域服务或核心服务 API。<br />下面以餐饮系统为例，说明上述两种 API 的细微差异。用户可以在手机上点餐，通过浏览器或者 APP 访问用户端 API，管理员可以通过管理端 API 管理用户等系统中的资源。这些请求最终都会通过不同的应用 API 到达领域 API 中，如图 6-5 所示。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712881908864-e517f4f3-211c-4a8c-bb3b-1c23279476bb.png#clientId=u30cfec57-467a-4&amp;from=paste&amp;id=u18c790f6&amp;originHeight=508&amp;originWidth=1202&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=46470&amp;status=done&amp;style=none&amp;taskId=u3b9c2c81-d136-423f-b343-e3dcb70d05a&amp;title=" alt="image.jpg"><br />图 6-5 不同类型的 API<br><a name="Ps5Ty"></a></p><h3 id="6-7-1-面向应用的-API">6.7.1 面向应用的 API</h3><p>应用 API 只是对领域 API 的组织和编排，没有特别多的业务逻辑，因此我们的测试重点是验证这套 API 能否完成端到端的验证。这类 API 的测试工作最好按照场景来组织，比较推荐的做法是根据场景来测试，可使用用户旅程（User Journey）测试的风格来组织测试。<br />由于应用 API 依赖于用户服务、产品服务等，因此需要通过模拟这些依赖让场景测试顺利进行。又因为应用 API 中的业务逻辑和分支条件较少，所以不用考虑异常分支就能让测试的覆盖率较高。这类 API 测试也不需要关注后端 API 的业务逻辑中发生了哪些业务异常。<br><a name="xqH06"></a></p><h4 id="1-测试目的">1. 测试目的</h4><p>针对面向应用的 API 进行测试时，目标是测试 API 的业务场景，验证字段是否正常返回，以及最终的后端 API 是否被合理调用。<br><a name="kl4ND"></a></p><h4 id="2-测试准备">2. 测试准备</h4><p>主要使用 WireMock 对依赖的后端 API 进行模拟。在实践中，可以把常用的模拟方法组合成通用的方法，避免重复编写测试代码。另外，这类测试往往与用户的认证有关，因此需要模拟与用户认证相关的行为，具体请参考前面的鉴权处理。<br><a name="MCGyd"></a></p><h4 id="3-测试组织方式">3. 测试组织方式</h4><p>使用用户旅程来组织测试在 JUnit 中有两种风格。<br />第一种是通过类的方式来组织、然后在类的级别中设置通用的 Mock 行为，并通过设置测试方法的运行序列整体运行测试。在 JUnit5 中，可以使用 @Order 注解让测试顺序执行。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@TestMethodOrder(MethodOrderer.OrderAnnotation.class)</span><br><span class="line">public class BuyScenarioTest &#123;</span><br><span class="line">    @BeforeAll</span><br><span class="line">    static void beforeAll() &#123;</span><br><span class="line">        // 这里进行通用的准备</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterAll</span><br><span class="line">    static void afterAll() &#123;</span><br><span class="line">        // 这里进行通用的清理</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    @Order(1)</span><br><span class="line">    void should_list_products() &#123;</span><br><span class="line">        System.out.println(&quot;should_list_products&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    @Order(2)</span><br><span class="line">    void should_get_product_detail() &#123;</span><br><span class="line">        System.out.println(&quot;should_get_product_detail&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    @Order(3)</span><br><span class="line">    void should_add_product_to_shopping_cart() &#123;</span><br><span class="line">        System.out.println(&quot;should_add_product_to_shopping_cart&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在这一层 API 中，我们放弃了对异常（指局部异常，对分支流程的异常还是会测试）的测试，因此让整个测试变得非常容易理解和维护。只有低成本的自动化测试才会让团队有动力持续地维护下去。<br />但习惯了采用这种方式组织测试之后，很多开发者会对那些无意义的 @Order 注解感到厌烦 ------------ 既然我们是使用场景组织 API 测试的，何不就以一个场景作为单位划分测试呢？这就是第二种风格，直接以场景为粒度进行测试，使用一个测试编排多个测试方法。在其他的 BDD 测试框架中，对此是有专门的语法来支持的。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ScenarioTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    void buy_scenario_test() &#123;</span><br><span class="line">        // 这里进行通用的准备</span><br><span class="line">        shouldListProducts();</span><br><span class="line">        shouldGetProductDetail();</span><br><span class="line">        shouldAddProductToShoppingCart();</span><br><span class="line">        ...</span><br><span class="line">        // 这里进行通用的清理</span><br><span class="line">    &#125;</span><br><span class="line">    void shouldListProducts() &#123;</span><br><span class="line">        System.out.println(&quot;should_list_products&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    void shouldGetProductDetail() &#123;</span><br><span class="line">        System.out.println(&quot;should_get_product_detail&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    void shouldAddProductToShoppingCart() &#123;</span><br><span class="line">        System.out.println(&quot;should_add_product_to_shopping_cart&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="IBbUU"></a></p><h3 id="6-7-2-面向领域服务的-API">6.7.2 面向领域服务的 API</h3><p>面向领域服务的 API 不是为最终的场景服务的，而是提供通用的业务能力。以产品服务为例，对于产品服务来说，它提供的是基本的服务能力，例如添加产品、删除产品。领域服务的各个 API 之间的关联性相对较弱，因此可以独立地组织测试数据，不过，需要验证异常测试。<br><a name="gg2qW"></a></p><h4 id="1-测试目标">1. 测试目标</h4><p>针对面向领域服务 API 进行测试时，目标是测试 API 的业务能力，包括单元测试不能覆盖的异常行为。<br><a name="JwQ6g"></a></p><h4 id="2-测试准备-2">2. 测试准备</h4><p>领域服务除了会依赖少量的第三方 API 之外，还会依赖数据库、文件等基础设施。这里参考之前的内容为不同的基础设施准备测试内容：</p><ul><li>启动内嵌的数据库等基础设施。</li><li>直接使用源码中的 Service、Repository 等 Bean 来准备数据库中的内容。</li><li>使用 WireMock 来处理外部系统。<br><a name="lCwwV"></a></li></ul><h4 id="3-测试组织方式-2">3. 测试组织方式</h4><p>由于面向领域服务的 API 提供的基本是原子性的 API，因此其与单元测试的组织风格类似，即保持一个 Controller 对应一个测试类。若为每个 API 单独准备、执行、验证测试用例，那么一个测试类可能会有很多个测试。想让测试结构更加清晰，可以把正向、异常测试组织到一个嵌套测试中。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ProductControllerTest &#123;</span><br><span class="line">    @Nested</span><br><span class="line">    @DisplayName(&quot;query product list suite&quot;)</span><br><span class="line">    class QueryProduct &#123;</span><br><span class="line">        @Test</span><br><span class="line">        void should_list_product_list_with_default_page() &#123;</span><br><span class="line">            System.out.println(&quot;should_list_product_list_with_default_page&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        @Test</span><br><span class="line">        void should_list_product_list_with_specify_page() &#123;</span><br><span class="line">            System.out.println(&quot;should_list_product_list_with_specify_page&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Nested</span><br><span class="line">    @DisplayName(&quot;add product test suite&quot;)</span><br><span class="line">    class AddProduct &#123;</span><br><span class="line">        @Test</span><br><span class="line">        void should_add_product_success() &#123;</span><br><span class="line">            System.out.println(&quot;should_add_product_success&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        @Test</span><br><span class="line">        void should_add_product_failed_when_exceed_product_limitation() &#123;</span><br><span class="line">            System.out.println(&quot;should_add_product_failed_when_exceed_product_limitation&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套类尤其适合这种场景，在 IntelliJIDEA 中运行测试时，可以在测试结果中看到非常清晰的测试结构。图 6-6 展示了嵌套测试执行后的样子。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1712881909256-ecab27b0-9df8-45b1-b723-1b7e5bc8d4ed.png#clientId=u30cfec57-467a-4&amp;from=paste&amp;id=ud6644133&amp;originHeight=377&amp;originWidth=1078&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=105287&amp;status=done&amp;style=none&amp;taskId=ub2031429-3046-42d6-b1d6-6d16ee5b719&amp;title=" alt="image.jpg"><br />图 6-6 使用嵌套类组织测试<br><a name="AZHol"></a></p><h2 id="6-8-小结">6.8 小结</h2><p>在前后端分离和微服务盛行的技术趋势下，API 测试变得越来越重要。本章介绍了如何使用 MockMvc、RESTAssured 等工具实现 API 测试，以及一些相关的注意事项和技巧。API 测试不再是单元测试的范畴，它的测试工具、Mock 工具、测试策略等都与单元测试有所不同。通过 WireMock 可以隔离依赖的第三方 API，让处于错综复杂的调用关系下的 API 更容易被测试。<br />对于微服务来说，不同类型的微服务会提供不同的 API，这些 API 需要使用不同的测试策略，为场景定制测试策略而不是死板地使用同一套方法尤为重要。</p><blockquote><p>来自: <a href="https://java-self-testing.github.io/java-self-testing-book/06-api-testing/">第 6 章 RESTful API 测试 - 《Java 研发自测》</a></p></blockquote><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;API 测试属于集成测试的范畴，手动进行 API 测试有很多方法，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 Curl 命令。&lt;/li&gt;
&lt;li&gt;使用 Postman。&lt;/li&gt;
&lt;li&gt;使用 Swagger 附带的 UI （用户界面）工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些方</summary>
      
    
    
    
    <category term="测试" scheme="http://www.bojiboqi.fun/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="spring测试" scheme="http://www.bojiboqi.fun/tags/spring%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>XSS系列一：什么是XSS攻击</title>
    <link href="http://www.bojiboqi.fun/2024/04/22/XSS%E7%B3%BB%E5%88%97%E4%B8%80%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFXSS%E6%94%BB%E5%87%BB/"/>
    <id>http://www.bojiboqi.fun/2024/04/22/XSS%E7%B3%BB%E5%88%97%E4%B8%80%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFXSS%E6%94%BB%E5%87%BB/</id>
    <published>2024-04-22T06:28:49.515Z</published>
    <updated>2024-04-22T23:30:02.581Z</updated>
    
    <content type="html"><![CDATA[<p><a name="Dwq5j"></a></p><h3 id="1-关于XSS攻击">1.关于<a href="https://so.csdn.net/so/search?q=XSS%E6%94%BB%E5%87%BB&amp;spm=1001.2101.3001.7020">XSS攻击</a></h3><p>XSS全称Cross Site Scripting（跨站脚本），为了与“CSS”区别，就使用XSS作为简称。<br />XSS攻击指恶意用户在html中注入含恶意的JavaScript代码或者恶意的HTML代码。在其他用户浏览该页面时，浏览器会直接编译处理所有代码包括恶意代码，从而作出损害用户利益的攻击。<br />下面通过一个简单的前后端数据交互例子进行叙述，先贴上代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line">//页面代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;head&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;title&gt;存储型XSS测试&lt;/title&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css&quot; integrity=&quot;sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk&quot; crossorigin=&quot;anonymous&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js&quot; integrity=&quot;sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js&quot; integrity=&quot;sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js&quot; integrity=&quot;sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    .demo&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    width: 450px;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    padding: 1.5rem;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    margin-right: 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    margin-left: 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;demo&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &lt;div class=&quot;d-flex justify-content-around mb-3&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;input type=&quot;text&quot; class=&quot;form-control mr-3&quot; placeholder=&quot;输入添加信息&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;button type=&quot;button&quot; class=&quot;btn btn-primary flex-shrink-0&quot; onclick=&quot;addMessage()&quot;&gt;添加&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &lt;div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;table class=&quot;table table-bordered&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          &lt;thead&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          &lt;tr&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &lt;th&gt;信息&lt;/th&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          &lt;/thead&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          &lt;tbody&gt;&lt;/tbody&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;/table&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  const input=document.querySelector(&#x27;input&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  const tbody=document.querySelector(&#x27;tbody&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  function getMessage()&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fetch(&#x27;http://127.0.0.1:9500/message&#x27;,&#123;mode:&#x27;cors&#x27;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    .then(res=&gt;res.json())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    .then(res=&gt;&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      let html=res.reduce((cur,el)=&gt;&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        cur+=`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;tr&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;td&gt;$&#123;el&#125;&lt;/td&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        `</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return cur</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#125;,&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      tbody.innerHTML=html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  getMessage()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  function addMessage()&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fetch(&#x27;http://127.0.0.1:9500/message&#x27;,&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      mode:&#x27;cors&#x27;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      method:&#x27;POST&#x27;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      body:JSON.stringify(&#123;message:input.value&#125;),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      headers: &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#x27;content-type&#x27;: &#x27;application/json&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    .then(()=&gt;getMessage())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">//后端代码node.js</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const express=require(&#x27;express&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const bodyParser = require(&quot;body-parser&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const app=express()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const router=express.Router()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const jsonParser = bodyParser.json()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let message=[&#x27;John&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router.get(&#x27;/&#x27;,function(req,res)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    res.status(200).json(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router.post(&#x27;/&#x27;,jsonParser,function(req,res)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    message.push(req.body.message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    res.status(200).end()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//中间件解决跨域问题</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function cors(req,res,next)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    res.header(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    res.header(&#x27;Access-Control-Allow-Headers&#x27;,&#x27;Content-Type&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    res.header(&#x27;Access-Control-Allow-Methods&#x27;,&#x27;PUT,POST,GET,DELETE,OPTIONS&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    next()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(cors)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(&#x27;/message&#x27;,router)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(function(req,res)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    res.status(404).end()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(9500,function()&#123;&#125;)</span><br></pre></td></tr></table></figure><p>交互效果如下：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713329037647-49b410f2-2312-41f8-a060-b97db0ff7d47.png#clientId=u13a769b9-2184-4&amp;from=paste&amp;id=u8dc64c4f&amp;originHeight=332&amp;originWidth=462&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=85930&amp;status=done&amp;style=none&amp;taskId=u8c39feab-4ca2-4830-beb6-11baa274b47&amp;title=" alt="image.jpg"><br />此时，如果我们插入带恶意的html片段，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;whatever&quot; onerror=alert(&#x27;attack&#x27;)&gt;</span><br></pre></td></tr></table></figure><p>因为src中是一个无效链接，加载失败必然会执行onerror中的回调函数，因此则会出现以下效果:<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713329033698-51338251-2122-4937-b3c8-52e0bcfd6ee5.png#clientId=u13a769b9-2184-4&amp;from=paste&amp;id=ud8f2c450&amp;originHeight=425&amp;originWidth=1043&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=118420&amp;status=done&amp;style=none&amp;taskId=uc4e5ec9b-277c-4eed-a6aa-036268780b3&amp;title=" alt="image.jpg"><br />这就是其中一种XSS攻击的原理的呈现。一般恶意用户会通过onerror回调函数插入script如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;whatever&quot; onerror=&quot;javascript:window.el=document.createElement(&#x27;script&#x27;),window.el.src=&#x27;wrong.js&#x27;,document.head.appendChild(window.el)&quot;&gt;</span><br></pre></td></tr></table></figure><p>通过引入来自外部的恶意脚本，在恶意脚本里就可以进行恶意操作，例如：</p><ol><li>窃取用户Cookie：document.cookie收集用户cookie或者sessionStorage然后发送到别的服务器里</li><li>监听用户行为：通过登陆的键入字符串窃取用户信息</li><li>插入恶意广告：插入恶意iframe或者监听鼠标点击跳转页面</li></ol><p>**拓展：**有人会问为什么onerror函数中不这么写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascript:document.head.innerHTML+=&quot;&lt;script src=&#x27;wrong.js&#x27;&gt;&lt;/script&gt;&quot;</span><br></pre></td></tr></table></figure><p>那是因为HTML5中指定不执行由innerHTML插入的script标签。<br><a name="O2Cv2"></a></p><h3 id="2-XSS攻击的分类">2.XSS攻击的分类</h3><p><a name="XGifO"></a></p><h4 id="1-存储型XSS攻击">1.存储型XSS攻击</h4><p>开头的例子就是存储型XSS攻击，存储型的攻击主要步骤是：</p><ol><li>恶意用户把恶意代码片段提交到服务器的数据库中</li><li>普通用户请求网站，网站把包含恶意代码的数据加载从页面中加载出来</li><li>恶意代码开始运行<br><a name="q4Zzr"></a></li></ol><h4 id="2-反射型XSS攻击">2.反射型XSS攻击</h4><p>有些页面交互中存在用户输入数据后，页面响应时会原封不动地返回这个数据到页面上。例如…还是先贴代码吧：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//后端node.js代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const express=require(&#x27;express&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const app=express()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.get(&#x27;/main/:keyword&#x27;,function(req,res)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    res.send(`搜索内容：$&#123;req.params.keyword&#125;`)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(function(req,res)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    res.status(404).end()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(9501)</span><br></pre></td></tr></table></figure><p>正常交互效果：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713329032808-fac5f162-2565-4780-9a7c-4ea8a148868c.png#clientId=u13a769b9-2184-4&amp;from=paste&amp;id=u81638a97&amp;originHeight=352&amp;originWidth=586&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=53898&amp;status=done&amp;style=none&amp;taskId=ubb688a58-ac46-4f7e-ad08-f1e80c925cb&amp;title=" alt="image.jpg"><br />带XSS攻击的交互效果：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713329040052-8a9b4f02-e38e-4231-bf7e-07d3c21b2517.png#clientId=u13a769b9-2184-4&amp;from=paste&amp;id=u25ee3fdb&amp;originHeight=352&amp;originWidth=1233&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=113129&amp;status=done&amp;style=none&amp;taskId=u635dfcbd-ac22-41eb-bbeb-876c0972a0c&amp;title=" alt="image.jpg"><br><a name="LJ6hM"></a></p><h4 id="3-DOM型XSS攻击">3.DOM型XSS攻击</h4><p>DOM型XSS攻击与反射型XSS攻击类似，都是通过把恶意代码作为参数纳入到url中，诱发用户点击。不过区别在于反射型XSS攻击的页面是通过后端的模板引擎渲染的，而DOM型XSS攻击中的页面是通过前端取出URL中的参数里的恶意代码后，然后通过document.write或者innerHTML等方法渲染到页面上的。<br><a name="cYGsp"></a></p><h3 id="3-XSS攻击预防措施">3.XSS攻击预防措施</h3><p>总结说，一般XSS攻击中注入的恶意代码有两种类型：</p><ul><li>在img或者iframe等标签中，后面接着代码，可能以javascript:开头，。</li><li>以<script>标签包裹着代码</li></ul><p>**拓展：**注意上述两种写法不区分大小写，“javascript:”也可以写成“JaVaScRiPt:”，因为XSS的恶意代码一般都是插入在html标签里，而HTML不区分大小写。<br><a name="hVwQ8"></a></p><h4 id="1-关键字转义：">1.关键字转义：</h4><p>我们可以在后端对&quot;&lt;“,”&gt;&quot;等符号进行转译成HTML能试别的转义符，如下：</p><ol><li>”&lt;“转译成“&lt;”</li><li>“&gt;”转译成“&gt;”</li><li>引号“&quot;”转译成“&quot;”</li></ol><p>转译过程最好在后端进行，如果在前端进行转义，恶意用户可以通过postman等工具直接发起请求绕过前端转义过滤。<br />**存在缺点：**有时候前端如果需要对数据进行处理，例如统计字符串长度等，要再次把特殊字符转义回原来的格式。而且也不能针对以javascript:开头的恶意代码。<br><a name="sXubn"></a></p><h4 id="2-长度限制">2.长度限制</h4><p>对于输入的信息，进行长度限制（前后端都要对提交信息进行校验）。一般XSS嵌入的恶意代码无论是那种类型，都需要相当的长度才能实施。尽管有些代码可以拆分，例如开头举例说明的储存型XSS攻击中的恶意img标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;whatever&quot; onerror=&quot;javascript:window.el=document.createElement(&#x27;script&#x27;),window.el.src=&#x27;wrong.js&#x27;,document.head.appendChild(window.el)&quot;&gt;</span><br></pre></td></tr></table></figure><p>可以把他拆分成三个短的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;whatever&quot; onerror=&quot;javascript:window.el=document.createElement(&#x27;script&#x27;)&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;whatever&quot; onerror=&quot;javascript:window.el.src=&#x27;wrong.js&#x27;&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;whatever&quot; onerror=&quot;javascript:document.head.appendChild(window.el)&quot;&gt;</span><br></pre></td></tr></table></figure><p>甚者可以把代码再拆分成好几段字符串，然后最后拼起来用eval运行。但仍然可以增加XSS攻击的难度。<br><a name="BlDK1"></a></p><h4 id="3-Content-Security-Policy">3.Content Security Policy</h4><blockquote><p>CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。—阮一峰的网络日志</p></blockquote><p>我们可以通过两种方法来开启CSP:<br />(1)后端配置响应头content-security-policy，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//中间件配置csp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function csp(req,res,next)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    res.header(&#x27;Content-Security-Policy&#x27;,&quot;default-src &#x27;self&#x27;;script-src &#x27;self&#x27;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    next()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(csp)</span><br></pre></td></tr></table></figure><p>发出请求时在响应头里可看到：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713329032412-03d1715a-606a-4d19-9608-955dc4f46454.png#clientId=u13a769b9-2184-4&amp;from=paste&amp;id=u1bedd824&amp;originHeight=235&amp;originWidth=481&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=19807&amp;status=done&amp;style=none&amp;taskId=u496decdf-4ec3-4356-8e79-d9e37973921&amp;title=" alt="image.jpg"><br />(2)在网页的head设置meta标签，如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#x27;self&#x27; ;&quot;&gt;</span><br></pre></td></tr></table></figure><p>在开头的例子里，我们可以如上述设置。把default-src设置为’self‘，代表只能加载自己当前域名下的资源。这样子可以防止开头说的引入外部恶意脚本的XSS的攻击：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;whatever&quot; onerror=&quot;javascript:window.el=document.createElement(&#x27;script&#x27;),window.el.src=&#x27;wrong.js&#x27;,document.head.appendChild(window.el)&quot;&gt;</span><br></pre></td></tr></table></figure><p><a name="WOZQo"></a></p><h4 id="4-设置cookie的httpOnly属性">4.设置cookie的httpOnly属性</h4><p>若cookie的httpOnly属性为true，则浏览器的cookie不能通过js脚本获取，即不能通过document.cookie获取。这样子可以防止恶意代码获取用户的cookie。</p><blockquote><p>来自: <a href="https://blog.csdn.net/weixin_40780243/article/details/108898229?spm=1001.2014.3001.5502">XSS系列一：什么是XSS攻击-CSDN博客</a></p></blockquote><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;Dwq5j&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-关于XSS攻击&quot;&gt;1.关于&lt;a href=&quot;https://so.csdn.net/so/search?q=XSS%E6%94%BB%E5%87%BB&amp;amp;spm=1001.2101.3001.702</summary>
      
    
    
    
    <category term="web安全" scheme="http://www.bojiboqi.fun/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="xss" scheme="http://www.bojiboqi.fun/tags/xss/"/>
    
  </entry>
  
  <entry>
    <title>Web前端安全系列之：XSS攻防及Vue防御</title>
    <link href="http://www.bojiboqi.fun/2024/04/22/Web%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%E4%B9%8B%EF%BC%9AXSS%E6%94%BB%E9%98%B2%E5%8F%8AVue%E9%98%B2%E5%BE%A1/"/>
    <id>http://www.bojiboqi.fun/2024/04/22/Web%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%E4%B9%8B%EF%BC%9AXSS%E6%94%BB%E9%98%B2%E5%8F%8AVue%E9%98%B2%E5%BE%A1/</id>
    <published>2024-04-22T06:28:22.096Z</published>
    <updated>2024-04-22T23:30:26.459Z</updated>
    
    <content type="html"><![CDATA[<p><a name="ednPX"></a></p><h3 id="前言-Web-安全的兴起"><a href="https://holazero.cn/blogs/other/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/xss/">前言 Web 安全的兴起</a></h3><p>Web 攻击技术的发展也可以分为几个阶段。在 <code>Web 1.0</code> 时代，人们更多的是关注<a href="https://so.csdn.net/so/search?q=%E6%9C%8D%E5%8A%A1%E5%99%A8&amp;spm=1001.2101.3001.7020">服务器</a>端<br />动态脚本的安全问题，比如将一个可<a href="https://so.csdn.net/so/search?q=%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC&amp;spm=1001.2101.3001.7020">执行脚本</a>（俗称 <code>webshell</code>）上传到服务器上，从而获得权<br />限。后续有出现了<code>SQL</code>注入，<code>SQL</code>注入的出现是<code>Web</code>安全史上的一个里程碑，<code>SQL</code>注入漏洞至今仍然是<code>Web</code>安全领域中的一个重要组成部分。再后续另一个里程碑的安全问题问世–<code>XSS</code>（跨站脚本攻击）。伴随着 <code>Web 2.0</code> 的兴起，<code>XSS</code>、<code>CSRF</code> 等攻击已经变得更为强大。<code>Web</code> 攻击的思路也从服务器端转向了客户端，转向了浏览器和用户。<br /><code>Web</code> 技术发展到今天，构建出了丰富多彩的互联网。互联网业务的蓬勃发展，也催生出了<br />许多新兴的脚本语言，比如 <code>Python</code>、<code>Ruby</code>、<code>NodeJS</code> 等，敏捷开发成为互联网的主旋律。而手机技术、移动互联网的兴起，也给 <code>HTML 5</code> 带来了新的机遇和挑战。与此同时，<code>Web</code> 安全技术，也将紧跟着互联网发展的脚步，不断地演化出新的变化。<br />跨站脚本攻击（<code>XSS</code>）是客户端脚本安全中的头号大敌。<code>OWASP TOP 10</code> 威胁多次把 <code>XSS</code><br />列在榜首，该篇文章将重点介绍<code>XSS</code>的攻防问题<br><a name="wsDcG"></a></p><h3 id="初探XSS">初探<code>XSS</code></h3><p><strong>跨站脚本攻击</strong>，英文全称是 <code>Cross Site Script</code>，本来缩写是 <code>CSS</code>，但是为了和层叠样式表（<code>Cascading Style Sheet</code>，<code>CSS</code>）有所区别，所以在安全领域叫做“<code>XSS</code>”。<br /><code>XSS</code>攻击，通常指黑客通过<code>HTML</code>注入 篡改网页，插入恶意脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击行为。在这种行为最初出现之时，所有的演示案例全是跨域行为，所以叫做 “跨站脚本” 。时至今日，随着<code>Web</code>端功能的复杂化，应用化，是否跨站已经不重要了，但 <code>XSS</code>这个名字却一直保留下来。<br />随着<code>Web</code>发展迅速发展，<code>Web</code>开发已经被应用的非常广泛了，由之前的单一<code>PC</code>端扩展到现在的移动端（<code>APP</code>、<code>H5</code>），甚至包括桌面工具、设备大屏等等，所以在产生的应用场景越来越多，越来越复杂的情况下，同时大多数互联网（尤其是传统行业）的产品开发版本迭代上线时间非常短，一周一版本，两周一大版本的情况下，忽略了安全这一重要属性，一旦遭到攻击，后果将不堪设想。<br><a name="VZH95"></a></p><h3 id="XSS攻击类型分类"><code>XSS</code>攻击类型分类</h3><p><code>XSS</code>攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于<code>DOM XSS</code>；<br><a name="sjLPw"></a></p><h4 id="反射型">反射型</h4><ul><li>【简单描述】将用户输入的存在 XSS 攻击的数据，发送给后台，后台并未对数据进行存储，也未经过任何过滤，直接返回给客户端，被浏览器渲染</li><li>【具体步骤】1、构造出包含恶意代码的 url，url 指向目标网站，参数拼接恶意代码，举例如下：<img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713343678147-79415115-19fb-46bf-bcce-898c417e1168.png#averageHue=%23292e36&amp;clientId=u4a0d4c48-742c-4&amp;from=paste&amp;id=ub0fd354f&amp;originHeight=192&amp;originWidth=840&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=69292&amp;status=done&amp;style=none&amp;taskId=u287ccf31-ac28-4249-83ef-c1347f4f4fe&amp;title=" alt="image.png">2、诱导用户点击，点击后会向服务端发送请求，同时查询参数携带恶意代码3、服务端返回时 <strong>将恶意代码直接拼接在HTML</strong>4、客户端接收并解析执行代码时，恶意代码也被执行</li><li>【特点】<strong>需要攻击者诱使用户操作</strong>：点击一个恶意链接/提交一个表单/进入一个恶意网站</li><li>【常见场景】通过 URL 传递参数的场景，如 <strong>网站搜索、跳转</strong></li></ul><p><a name="GfhVe"></a></p><h4 id="存储型">存储型</h4><p>存储型 <code>XSS</code> 会把用户输入的数据“存储”在服务器端。这种 <code>XSS</code> 具有很强的稳定性。<br />比较常见的一个场景就是，黑客写下一篇包含有恶意 <code>JavaScript</code> 代码的博客文章，文章发表后，所有访问该博客文章的用户，都会在他们的浏览器中执行这段恶意的 <code>JavaScript</code> 代码。黑客把恶意的脚本保存到服务器端，所以这种 <code>XSS</code> 攻击就叫做 <strong>“存储型 <strong><code>**XSS**</code></strong>”</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 例如我们分别在网站中的输入框中输入以下信息，并保存到远程数据库 --&gt;</span><br><span class="line">&lt;img src=&quot;11&quot; onerror=&quot;console.log(window.localStorage)&quot; /&gt;</span><br><span class="line">&lt;img src=&quot;11&quot; onerror=&quot;alert(111)&quot; /&gt;</span><br></pre></td></tr></table></figure><p>页面输入<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713343399009-6e1c8e56-7691-448a-9506-acc7dbdea36a.png#averageHue=%23ededed&amp;clientId=u364131ef-0bd7-4&amp;from=paste&amp;id=ubea3c988&amp;originHeight=767&amp;originWidth=716&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=41926&amp;status=done&amp;style=none&amp;taskId=u43d9ccc1-73f8-4b7d-9e8a-494524337b8&amp;title=" alt="image.jpg"><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713343398965-422cf65f-4d01-4a6d-8e03-ae564e792851.png#averageHue=%23f9f9f9&amp;clientId=u364131ef-0bd7-4&amp;from=paste&amp;id=uf86a7dd3&amp;originHeight=690&amp;originWidth=700&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=38639&amp;status=done&amp;style=none&amp;taskId=u799a18e3-3cf4-4ab9-a4ff-54443219eeb&amp;title=" alt="image.jpg"><br />使用者浏览页面，分别先后触发了<code>alert</code>弹框和<code>localStorage</code>获取本地数据：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713343399262-2869d1e6-2c10-4c42-90ee-09fe369e97e9.png#averageHue=%23fdfcfb&amp;clientId=u364131ef-0bd7-4&amp;from=paste&amp;id=u4da95710&amp;originHeight=608&amp;originWidth=1096&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=71706&amp;status=done&amp;style=none&amp;taskId=u4564a4ef-a4bc-4253-b10d-b2573ef75d8&amp;title=" alt="image.jpg"><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713343399265-f376fe25-c772-4742-97c7-95b0e48d552a.png#averageHue=%23f2eeee&amp;clientId=u364131ef-0bd7-4&amp;from=paste&amp;id=ua8b14c8d&amp;originHeight=167&amp;originWidth=1041&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=65707&amp;status=done&amp;style=none&amp;taskId=udd66dcdf-d891-4706-b82c-ad02464f406&amp;title=" alt="image.jpg"><br />以上就是一个典型的<strong>存储型</strong>攻击。<br><a name="fBLpX"></a></p><h4 id="基于DOM-XSS">基于<code>DOM XSS</code></h4><p>实际上，这种类型的<code>XSS</code>并非按照“数据是否保存在服务器端”来划分，<code>DOM Based XSS</code>从效果上来说也是反射型<code>XSS</code>。单独划分出来，是因为<code>DOM Based XSS</code> 的形成原因比较特别，发现它的安全专家专门提出了这种类型的<code>XSS</code>。<code>DOM 型 XSS</code>跟前两种<code>XSS</code>的区别：<code>DOM 型 XSS</code>攻击中，取出和执行恶意代码由浏览器端完成，属于前端<code>JavaScript</code>自身的安全漏洞，而其他两种<code>XSS</code>都属于服务端的安全漏洞。<br />接下来我们来看一个简单的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;XSS攻防演练&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h3&gt;基于DOM的XSS&lt;/h3&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; id=&quot;input&quot;&gt;</span><br><span class="line">    &lt;button id=&quot;btn&quot;&gt;提交内容&lt;/button&gt;</span><br><span class="line">    &lt;div id=&quot;div&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const input = document.getElementById(&#x27;input&#x27;);</span><br><span class="line">    const btn = document.getElementById(&#x27;btn&#x27;);</span><br><span class="line">    const div = document.getElementById(&#x27;div&#x27;);</span><br><span class="line"></span><br><span class="line">    let inputValue;</span><br><span class="line">     </span><br><span class="line">    input.addEventListener(&#x27;change&#x27;, (e) =&gt; &#123;</span><br><span class="line">        inputValue = e.target.value;</span><br><span class="line">    &#125;, false);</span><br><span class="line"></span><br><span class="line">    btn.addEventListener(&#x27;click&#x27;, () =&gt; &#123;</span><br><span class="line">        div.innerHTML = `&lt;a href=$&#123;inputValue&#125;&gt;链接地址&lt;/a&gt;`</span><br><span class="line">    &#125;, false);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>我们再页面输入框中输入以下文本<code>'' onclick=alert(/xss/)</code>，这里的<code>''</code>引号是为了关闭掉<code>href</code>属性，给它赋予了一个空值。然后点击<code>提交内容</code>按钮，则页面中的<code>&lt;div id=&quot;div&quot;&gt;&lt;/div&gt;</code>标签包含了一下<code>html</code>内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href onlick=&quot;alert(/xss/)&quot;&gt;链接地址&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713343399166-6c9affa7-f367-46ac-bb26-70af74144bcd.png#averageHue=%23f4f2f1&amp;clientId=u364131ef-0bd7-4&amp;from=paste&amp;id=ub17b7a33&amp;originHeight=153&amp;originWidth=289&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=14738&amp;status=done&amp;style=none&amp;taskId=u4126065b-2657-4e6c-9412-f23105c648a&amp;title=" alt="image.jpg"><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713343399448-41c73865-9e65-44c8-bcaf-f5f260ffcb62.png#averageHue=%23fdfbfb&amp;clientId=u364131ef-0bd7-4&amp;from=paste&amp;id=uae8f08a9&amp;originHeight=299&amp;originWidth=1483&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=46584&amp;status=done&amp;style=none&amp;taskId=u390a887c-b6e0-4667-9a21-1bc818829de&amp;title=" alt="image.jpg"><br><a name="bwrH9"></a></p><h3 id="XSS攻击防御"><code>XSS</code>攻击防御</h3><p>关于<code>XSS</code>的防御是非常复杂的，值得幸运的是现代浏览器、前端框架/库已经帮我们做了相当大的一部分工作。<br><a name="wb0AQ"></a></p><h4 id="HttpOnly"><code>HttpOnly</code></h4><p><code>HttpOnly</code> 最早是由微软提出，并在<code>IE 6</code>中最先实现的，至今已经逐渐成为一个标准。浏览器将禁止页面的<code>JavaScript</code>访问带有<code>HttpOnly</code>属性的<code>Cookie</code>。所以我们需要在<code>http</code>的响应头<code>set-cookie</code>时设置<code>httpOnly</code>，让浏览器知道不能通过<code>document.cookie</code>的方式获取到<code>cookie</code>内容。<br />严格地说，<code>HttpOnly</code> 并非为了对抗 <code>XSS——HttpOnly</code> 解决的是<code>XSS</code>后的 <code>Cookie</code> 劫持攻击。所以说使用<code>HttpOnly</code>有助于缓解<code>XSS</code>攻击，但仍然需要其他能够解决<code>XSS</code>漏洞的方案；<br><a name="HYT37"></a></p><h4 id="输入检查">输入检查</h4><p>对于用户的输入内容我们需要持怀疑态度。在对输入不做任何过滤检查的情况下用户可能输入任何字符串。比如我们期望输入的内容是：<code>hello word</code>, 也许我们收到的内容是<code>onclick=alert(/xss/)</code>。<br />在<code>XSS</code>的防御上，输入检查一般是检查用户输入的数据中是否包含一些特殊字符，如<code>＜、＞、’、”</code>等。如果发现存在特殊字符，则将这些字符过滤或者编码。这种输入检查的方式，可以称为<code>“XSS Filter”</code>。互联网上有很多开源的<code>“XSS Filter”</code>的实现。比如一个简单的<code>htmlencode</code>转义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const htmlEncode = function (handleString)&#123;</span><br><span class="line">    return handleString</span><br><span class="line">    .replace(/&amp;/g,&quot;&amp;amp;&quot;)</span><br><span class="line">    .replace(/&lt;/g,&quot;&amp;lt;&quot;)</span><br><span class="line">    .replace(/&gt;/g,&quot;&amp;gt;&quot;)</span><br><span class="line">    .replace(/ /g,&quot;&amp;nbsp;&quot;)</span><br><span class="line">    .replace(/\&#x27;/g,&quot;&amp;#39;&quot;)</span><br><span class="line">    .replace(/\&quot;/g,&quot;&amp;quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是<strong>输入检查</strong>也有弊端，比如</p><ul><li>攻击者绕过前端页面直接使用接口就可以提交恶意代码到远程库中。</li><li>输入数据，还可能会被展示在多个地方，每个地方的语境可能各不相同，如果使用单一的替换操作，则可能会出现问题。输入检查也需要有针对性，如果我们想表达的意思是一个数小于另一个数（ <code>3 &lt; 4</code>）,前端转义后的字符就变成<code>3 &amp;lt; 4</code>，当这个值被存到远端时后，再通过<code>AJAX</code>获取使用就会造成不必要的麻烦，比如我就进行数值计算等等。<br><a name="CA2ay"></a></li></ul><h4 id="输出检查">输出检查</h4><p>一般来说，除富文本的输出外，在变量输出到<code>HTML</code>页面时，可以使用编码或转义的方式来防御<code>XSS</code>攻击。<br />XSS的本质还是一种“HTML 注入”，用户的数据被当成了HTML代码一部分来执行，从而混淆了原本的语义，产生了新的语义。<br />如同输入检查一样，我们可以对输出进行编码转义。<br><a name="zYAKd"></a></p><h5 id="1-在HTML中输出">1.在<code>HTML</code>中输出</h5><p>比如我们的html代码中有这样一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;$htmlVar&lt;/div&gt;</span><br><span class="line">&lt;a href=&quot;&quot;&gt;$htmlVar&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>如果输出的变量没有进行安全处理，直接使用并渲染在页面中，都能导致直接产生<code>XSS</code>。最终的结果可能生成一下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&lt;script&gt;alert(&#x27;我是一个XSS攻击者&#x27;)&lt;/script&gt;&lt;/div&gt;</span><br><span class="line">&lt;a href=&quot;#&quot;&gt;&lt;img href=&quot;&quot; onclick=&quot;alert(&#x27;我是另外一个XSS攻击者&#x27;)&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>这个预防的方法就是对html进行转义检查<br><a name="uyh2V"></a></p><h5 id="2-在HTML属性中输出">2. 在<code>HTML</code>属性中输出</h5><p>如果我们的html属性时动态值，那么利用属性也可以被攻击；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;testXSS&quot; data-name=&quot;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>现在往<code>data-name</code>属性中插入一段未转义的代码<code>&quot;&gt;&lt;script&gt;alert('我是一个XSS攻击者')&lt;/script&gt;&lt;&quot;</code>,结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;testXSS&quot; data-name=&quot;&quot;&gt;&lt;script&gt;alert(&#x27;我是一个XSS攻击者&#x27;)&lt;/script&gt;&lt;&quot;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><a name="fpzM1"></a></p><h5 id="3-在-script-标签中输出">3. 在<code>&lt;script&gt;</code>标签中输出</h5><p>在<code>&lt;script&gt;</code>标签中输出时，首先应该确保输出的变量在引号中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 假设userData是攻击者注入的数据</span><br><span class="line">    let xssVar = userData;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>攻击者需要先闭合引号才能实施XSS攻击：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 假设userData是攻击者注入的数据</span><br><span class="line">    let xssVar = &quot;&quot;;alert(&#x27;我是一个script XSS攻击者&#x27;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><a name="UP3BO"></a></p><h5 id="4-在CSS中输出">4. 在<code>CSS</code>中输出</h5><p>在 <code>CSS</code> 和 <code>style</code>、<code>style attribute</code> 中形成 <code>XSS</code> 的方式非常多样化，所以，一般来说，尽可能禁止用户可控制的变量在“<code>&lt;style&gt;</code>标签”、“<code>HTML</code>标签的<code>style</code>属性”以及“<code>CSS</code> 文件”中输出。如果一定有这样的需求，则推荐使用一个关于CSS转义库。<br><a name="ybkmR"></a></p><h4 id="防御DOM-Based-XSS">防御<code>DOM Based XSS</code></h4><p><code>DOM Based XSS</code>是一种比较特别的<code>XSS</code>漏洞，前文提到的几种防御方法都不太适用，需要特别对待。这个本质上，实际上就是网站前端JavaScript代码本身不够严谨，把不可信的数据当作代码执行了。<br />如果用 <code>Vue/React</code> 技术栈，并且不使用 <code>v-html</code>/<code>dangerouslySetInnerHTML</code>功能，就在前端<code>render</code>阶段避免<code>innerHTML</code>、<code>outerHTML</code>的 <code>XSS</code>隐患。稍后会有专门的<code>Vue</code>关于<code>XSS</code>的防御段落。<br />会触发<code>DOM Based XSS</code>的地方有很多，以下几个地方是<code>JavaScript</code>输出到<code>HTML</code>页面的必经之路。</p><ul><li><code>document.write()</code>;</li><li><code>document.writeln()</code>;</li><li><code>xxx.innerHTML()</code>;</li><li><code>xxx.outerHTML()</code>;</li><li><code>xxx.innerHTML.replace()</code>;</li><li><code>document.attachEvent()</code>;</li><li><code>window.attachEvent()</code>;</li><li><code>window.location()</code>;</li><li><code>window.name</code>;</li></ul><p>所以开发者需要重点关注这几个地方的参数是否可以被用户控制。如果项目中有用到这些的话，一定要避免在字符串中拼接不可信数据。<br><a name="LCYCH"></a></p><h3 id="Vue中的XSS防御"><code>Vue</code>中的<code>XSS</code>防御</h3><p>如果你在项目中使用了<code>Vue</code>作为前端开发框架，恭喜你，<code>Vue</code>将为你解决绝大多数的<code>XSS</code>攻击问题，但是<code>Vue</code>不是一个预防<code>XSS</code>攻击的框架，在开发使用的时候还是有被攻击的漏洞存在；<br><a name="YnI6i"></a></p><h4 id="Vue中的防御措施"><code>Vue</code>中的防御措施</h4><p>不论使用模板还是渲染函数，<code>Vue</code>都会将插值的内容都会自动转义。也就是说对于这份模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;userData&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 从远程获取的数据</span><br><span class="line">    userData = &quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>最终编译后页面显示的<code>html</code>源码内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    &lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>原因是<code>Vue</code>帮我们对数据进行了转义，因此避免了脚本注入。该转义通过诸如 textContent 的浏览器原生的 API 完成，所以除非浏览器本身存在安全漏洞，否则不会存在安全漏洞。转义后的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;lt;script&amp;gt;alert(&amp;quot;xss&amp;quot;)&amp;lt;/script&amp;gt;</span><br></pre></td></tr></table></figure><p><a name="GDozP"></a></p><h4 id="注入HTML">注入<code>HTML</code></h4><p>如果你要动态注入远程的<code>HTML</code>内容，首先你应该确保这些内容是安全有效的，否则你应该采取一些防御措施，去过滤或转义掉一些危险的标签符号；例如你可以这样显示的渲染<code>HTML</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 当使用模版时 --&gt;</span><br><span class="line">&lt;div v-html=&quot;userProvidedHtml&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 当使用渲染函数时 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    h(&#x27;div&#x27;, &#123;</span><br><span class="line">    domProps: &#123;</span><br><span class="line">        innerHTML: this.userProvidedHtml</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;!-- 当使用JSX 的渲染函数时 --&gt;</span><br><span class="line">&lt;div domPropsInnerHTML=&#123;this.userProvidedHtml&#125;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>例如我们可以使用一个简单的方法（或者引用一个更加健壮的库/插件<a href="https://jsxss.com/zh/index.html">XSS</a>来过滤一遍这个远程的<code>userProvidedHtml</code>数据内容，以确保安全；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 一个简单的函数，通过转义&lt;为&amp;lt以及&gt;为&amp;gt来实现防御HTML节点内容</span><br><span class="line">const escape = function(str)&#123;</span><br><span class="line">    return str.replace(/&lt;/g, &#x27;&amp;lt;&#x27;).replace(/&gt;/g, &#x27;&amp;gt;&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="W0wsq"></a></p><h4 id="样式注入">样式注入</h4><p>在使用<code>Vue</code> 要在模板内避免渲染 <code>style</code> 标签:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;&#123;&#123; userProvidedStyles &#125;&#125;&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>这是因为，一但通过<code>userProvidedStyles</code>，恶意用户仍可以提供 <code>CSS</code> 来进行“点击诈骗”，例如将链接的样式设置为一个透明的方框覆盖在“登录”按钮之上。然后再把<code> https://user-XSS-website.com/</code> 做成你的应用的登录页的样子，它们就可能获取一个用户真实的登录信息，所以Vue推荐使用<code>对象语法</code>且只允许用户提供特定的可以安全控制的<code>property</code>的值:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- sanitizedUrl应为受控的地址 --&gt;</span><br><span class="line">&lt;a</span><br><span class="line">  v-bind:href=&quot;sanitizedUrl&quot;</span><br><span class="line">  v-bind:style=&quot;&#123;</span><br><span class="line">    color: userProvidedColor,</span><br><span class="line">    background: userProvidedBackground</span><br><span class="line">  &#125;&quot;</span><br><span class="line">&gt;</span><br><span class="line">  click me</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><a name="dn9Zr"></a></p><h3 id="安全问题“没有银弹”">安全问题“没有银弹”</h3><blockquote><p>在解决安全问题的过程中，不可能一劳永逸，也就是说“没有银弹”。</p></blockquote><blockquote><p>一般来说，人们都会讨厌麻烦的事情，在潜意识里希望能够让麻烦越远越好。而安全，正是一件麻烦的事情，而且是无法逃避的麻烦。任何人想要一劳永逸地解决安全问题，都属于一相情愿，是“自己骗自己”，是不现实的。</p></blockquote><p><a name="mTvgX"></a></p><h3 id="最佳实践">最佳实践</h3><p>通用的规则是只要允许执行未过滤的用户提供的内容 (不论作为 <code>HTML</code>、<code>JavaScript</code> 甚至 <code>CSS</code>)，你就可能令自己处于被攻击的境地。这些建议实际上不论使用 <code>Vue</code>、<code>React</code>还是别的框架甚至不使用框架，都是成立的。<br><a name="HnR8Z"></a></p><h3 id="总结">总结</h3><ul><li>XSS有反射型，储存型，Dom的XSS攻击</li><li>可以采用对script相关html元素进行转义，可以使用csp方法，让浏览器只加载信任服务器的js脚本；设置cookie的属性为HttpOnly这样就不能通过js获取到用户的cookie了</li><li>用户输入检查，防止输入到有xss攻击的数据</li><li>Vue中如果插入内容会自动将html的内容转义；使用v-html插入html元素的时候要注意转义；相关<a>标签时，其中的链接地址采用变量动态绑定，只有当点击的时候才进行赋值，这样就可以防止css注入了。</li></ul><p><a name="eLQoS"></a></p><h4 id="参考文献">参考文献</h4><ul><li><a href="https://baike.baidu.com/item/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2Web%E5%AE%89%E5%85%A8/7992696?fr=aladdin">白帽子讲Web安全</a></li><li><a href="https://vuejs.org/guide/best-practices/security.html#what-vue-does-to-protect-you">Vue官方文档</a></li></ul><blockquote><p>来自: <a href="https://blog.csdn.net/cheng521521/article/details/127423588">Web前端安全系列之：XSS攻防及Vue防御（万字长文）_vue xss-CSDN博客</a></p></blockquote><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;ednPX&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言-Web-安全的兴起&quot;&gt;&lt;a href=&quot;https://holazero.cn/blogs/other/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/xss/&quot;&gt;前言 Web</summary>
      
    
    
    
    <category term="web安全" scheme="http://www.bojiboqi.fun/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="xss" scheme="http://www.bojiboqi.fun/tags/xss/"/>
    
  </entry>
  
  <entry>
    <title>什么是I_O多路复用和Reator</title>
    <link href="http://www.bojiboqi.fun/2024/04/22/%E4%BB%80%E4%B9%88%E6%98%AFI_O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8CReator/"/>
    <id>http://www.bojiboqi.fun/2024/04/22/%E4%BB%80%E4%B9%88%E6%98%AFI_O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8CReator/</id>
    <published>2024-04-22T06:28:11.967Z</published>
    <updated>2024-04-22T23:29:48.107Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1RJ4m1b7cy/?spm_id_from=333.337.search-card.all.click&amp;vd_source=add54d0fcd49c96c6c124259f9775bc3">3分钟彻底理解IO多路复用_哔哩哔哩_bilibili</a><br /><a href="https://www.bilibili.com/video/BV17D421H793/?spm_id_from=333.337.search-card.all.click&amp;vd_source=add54d0fcd49c96c6c124259f9775bc3">趣谈IO多路复用的本质，助你轻松搞懂！_哔哩哔哩_bilibili</a><br />redis为什么这么快<br /><a href="https://www.bilibili.com/video/BV1gi4y1z7HQ/?spm_id_from=333.337.search-card.all.click&amp;vd_source=add54d0fcd49c96c6c124259f9775bc3">Redis 为什么快？单线程和IO多路复用你了解吗？Redis 和 Memcached 的区别 | 架构101 | 面试 | 技术细节_哔哩哔哩_bilibili</a><br><a name="HjXii"></a></p><h4 id="Reactor">Reactor:</h4><p><a href="https://www.xiaolincoding.com/os/8_network_system/reactor.html#%E5%8D%95-reactor-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E8%BF%9B%E7%A8%8B">9.3 高性能网络模式：Reactor 和 Proactor</a></p><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1RJ4m1b7cy/?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=add54d0fcd49c96c6c124259f97</summary>
      
    
    
    
    <category term="操作系统" scheme="http://www.bojiboqi.fun/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="IO" scheme="http://www.bojiboqi.fun/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ消息丢失的场景，MQ消息丢失解决方案 - 博客园</title>
    <link href="http://www.bojiboqi.fun/2024/04/22/RabbitMQ%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%8CMQ%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD/"/>
    <id>http://www.bojiboqi.fun/2024/04/22/RabbitMQ%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%8CMQ%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD/</id>
    <published>2024-04-22T06:26:16.149Z</published>
    <updated>2024-04-22T23:31:16.317Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第一种</strong>：（生产者）生产者弄丢了数据。生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，因为网络问题啥的，都有可能。<br /><strong>第二种</strong>：（服务端）RabbitMQ 弄丢了数据。MQ还没有持久化自己挂了<br /><strong>第三种</strong>：（消费者）消费端弄丢了数据。刚消费到，还没处理，结果进程挂了，比如重启了。<br><a name="KOPGu"></a></p><h2 id="1-针对生产者">1.针对生产者</h2><p><strong>方案1 ：开启RabbitMQ事务</strong><br />可以选择用 RabbitMQ 提供的事务功能，就是生产者发送数据之前开启 RabbitMQ 事务channel.txSelect，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务channel.txRollback，然后重试发送消息；如果收到了消息，那么可以提交事务channel.txCommit。<br /><strong>缺点</strong>： RabbitMQ 事务机制是同步的，你提交一个事务之后会阻塞在那儿，采用这种方式基本上吞吐量会下来，因为太耗性能。</p><p><strong>方案2： 使用confirm机制</strong><br />事务机制和 confirm 机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是 confirm 机制是异步的<br />在生产者开启了confirm模式之后，每次写的消息都会分配一个唯一的id，然后如果写入了rabbitmq之中，rabbitmq会给你回传一个ack消息，告诉你这个消息发送OK了；如果rabbitmq没能处理这个消息，会回调你一个nack接口，告诉你这个消息失败了，你可以进行重试。而且你可以结合这个机制知道自己在内存里维护每个消息的id，如果超过一定时间还没接收到这个消息的回调，那么你可以进行重发<br /><br><a name="qK7el"></a></p><h2 id="2-针对RabbitMQ">2.针对RabbitMQ</h2><p><a name="vRggC"></a></p><h3 id="有三点需要注意：">有三点需要注意：</h3><p>（1）要保证rabbitMQ不丢失消息，那么就需要开启rabbitMQ的持久化机制，即把消息持久化到硬盘上，这样即使rabbitMQ挂掉在重启后仍然可以从硬盘读取消息；<br />（2）如果rabbitMQ单点故障怎么办，这种情况倒不会造成消息丢失，这里就要提到rabbitMQ的3种安装模式，单机模式、普通集群模式、镜像集群模式，这里要保证rabbitMQ的高可用就要配合HAPROXY做镜像集群模式<br><a name="yjg5U"></a></p><h3 id="（1）消息持久化">（1）消息持久化</h3><p>RabbitMQ 的消息默认存放在内存上面，如果不特别声明设置，消息不会持久化保存到硬盘上面的，如果节点重启或者意外crash掉，消息就会丢失。所以就要对消息进行持久化处理。如何持久化，下面具体说明下：<br />要想做到消息持久化，必须满足以下三个条件，缺一不可。<br />1） Exchange 设置持久化<br />2）Queue 设置持久化<br />3）Message持久化发送：发送消息设置发送模式deliveryMode=2，代表持久化消息<br><a name="ub2zm"></a></p><h3 id="（2）设置集群镜像模式">（2）设置集群镜像模式</h3><p>我们先来介绍下RabbitMQ三种部署模式：<br />1）<strong>单节点模式</strong>：最简单的情况，非集群模式，节点挂了，消息就不能用了。业务可能瘫痪，只能等待。<br />2）<strong>普通模式</strong>：消息只会存在与当前节点中，并不会同步到其他节点，当前节点宕机，有影响的业务会瘫痪，只能等待节点恢复重启可用（必须持久化消息情况下）。<br />3）<strong>镜像模式</strong>：消息会同步到其他节点上，可以设置同步的节点个数，但吞吐量会下降。属于RabbitMQ的HA方案<br /><br><a name="azzHw"></a></p><h3 id="（3）消息补偿机制">（3）消息补偿机制</h3><p>为什么还要消息补偿机制呢？难道消息还会丢失，没错，系统是在一个复杂的环境，不要想的太简单了，虽然以上的三种方案，基本可以保证消息的高可用不丢失的问题，<br />比如：持久化的消息，保存到硬盘过程中，当前队列节点挂了，存储节点硬盘又坏了，消息丢了，怎么办？<br />1）生产端首先将业务数据以及消息数据入库，需要在同一个事务中，消息数据入库失败，则整体回滚<br />2）根据消息表中消息状态，失败则进行消息补偿措施，重新发送消息处理。<br /><br><a name="npG57"></a></p><h2 id="3-针对消费者">3.针对消费者</h2><p><strong>方案一：ACK确认机制</strong><br />多个消费者同时收取消息，比如消息接收到一半的时候，一个消费者死掉了(逻辑复杂时间太长，超时了或者消费被停机或者网络断开链接)，如何保证消息不丢？<br />使用rabbitmq提供的ack机制，服务端首先关闭rabbitmq的自动ack，然后每次在确保处理完这个消息之后，在代码里手动调用ack。这样就可以避免消息还没有处理完就ack。才把消息从内存删除。<br />这样就解决了，即使一个消费者出了问题，但不会同步消息给服务端，会有其他的消费端去消费，保证了消息不丢的case。<br /><br><a name="asmLM"></a></p><h2 id="四、总结">四、总结</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713420373165-2a8d88ee-1043-47d2-a994-fd9bb0f5df00.png#averageHue=%23f9f9f8&amp;clientId=ua4be4be5-2607-4&amp;from=paste&amp;id=u011b62d5&amp;originHeight=721&amp;originWidth=1788&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=694770&amp;status=done&amp;style=none&amp;taskId=ucf70f3bd-4b41-4a4f-b7f2-7c166ce036b&amp;title=" alt="image.jpg"><br />如果需要保证消息在整条链路中不丢失，那就需要生产端、mq自身与消费端共同去保障。<br /><strong>生产端</strong>：对生产的消息进行状态标记，开启confirm机制，依据mq的响应来更新消息状态，使用定时任务重新投递超时的消息，多次投递失败进行报警。<br /><strong>mq自身</strong>：开启持久化，并在落盘后再进行ack。如果是镜像部署模式，需要在同步到多个副本之后再进行ack。<br /><strong>消费端</strong>：开启手动ack模式，在业务处理完成后再进行ack，并且需要保证幂等。<br />通过以上的处理，理论上不存在消息丢失的情况，但是系统的吞吐量以及性能有所下降。<br />在实际开发中，需要考虑消息丢失的影响程度，来做出对可靠性以及性能之间的权衡。<br /></p><blockquote><p>来自: <a href="https://www.cnblogs.com/it1042290135/p/17754589.html">RabbitMQ消息丢失的场景，MQ消息丢失解决方案 - —阿峰— - 博客园</a></p></blockquote><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;第一种&lt;/strong&gt;：（生产者）生产者弄丢了数据。生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，因为网络问题啥的，都有可能。&lt;br /&gt;&lt;strong&gt;第二种&lt;/strong&gt;：（服务端）RabbitMQ 弄丢了数据。MQ还没有</summary>
      
    
    
    
    <category term="中间件" scheme="http://www.bojiboqi.fun/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="rabbitmq" scheme="http://www.bojiboqi.fun/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq集群-普通模式_rabbitmq 普通集群-</title>
    <link href="http://www.bojiboqi.fun/2024/04/22/rabbitmq%E9%9B%86%E7%BE%A4-%E6%99%AE%E9%80%9A%E6%A8%A1%E5%BC%8F_rabbitmq%20%E6%99%AE%E9%80%9A%E9%9B%86%E7%BE%A4-/"/>
    <id>http://www.bojiboqi.fun/2024/04/22/rabbitmq%E9%9B%86%E7%BE%A4-%E6%99%AE%E9%80%9A%E6%A8%A1%E5%BC%8F_rabbitmq%20%E6%99%AE%E9%80%9A%E9%9B%86%E7%BE%A4-/</id>
    <published>2024-04-22T06:26:05.372Z</published>
    <updated>2024-04-22T23:31:02.932Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://so.csdn.net/so/search?q=RabbitMQ&amp;spm=1001.2101.3001.7020">RabbitMQ</a>的Cluster模式分为两种</p><ol><li>普通模式</li><li>镜像模式<br><a name="YrVQD"></a></li></ol><h5 id="1-概念解释">1. 概念解释</h5><p><a name="Ibjh7"></a></p><h6 id="1-1-什么是普通模式">1.1 什么是普通模式</h6><p>普通集群模式，就是将 RabbitMQ 部署到多台服务器上，每个服务器启动一个 RabbitMQ 实例，多个实例之间进行消息通信。<br />此时我们创建的队列 Queue，它的元数据（主要就是 Queue 的一些配置信息）会在所有的 RabbitMQ 实例中进行同步，但是队列中的消息只会存在于一个 RabbitMQ 实例上，而不会同步到其他队列。<br />当我们消费消息的时候，如果连接到了另外一个实例，那么那个实例会通过元数据定位到 Queue 所在的位置，然后访问 Queue 所在的实例，拉取数据过来发送给消费者。<br />这种集群可以提高 RabbitMQ 的消息吞吐能力，但是无法保证高可用，因为一旦一个 RabbitMQ 实例挂了，消息就没法访问了，如果<a href="https://so.csdn.net/so/search?q=%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97&amp;spm=1001.2101.3001.7020">消息队列</a>做了持久化，那么等 RabbitMQ 实例恢复后，就可以继续访问了；如果消息队列没做持久化，那么消息就丢了。<br />大致的流程图如下图：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713420961659-81950078-ba9d-4979-8435-06f3e30ea7ad.png#averageHue=%23f9f9f9&amp;clientId=ue2064c1b-b380-4&amp;from=paste&amp;id=u9257db97&amp;originHeight=705&amp;originWidth=1261&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=120969&amp;status=done&amp;style=none&amp;taskId=uf58dca59-1e75-4565-aafe-1b070775e16&amp;title=" alt="image.jpg"><br />*<em>我们会发现，其实队列的数据只是保存了一份，其他的broker只是保留了元数据而已，用来访问交换机，binding或者队列的基本信息（比如地址啥的）</em><br><a name="o99Ym"></a></p><h6 id="1-2-什么是元数据">1.2 什么是元数据</h6><p>元数据包含以下内容：</p><ul><li>队列元数据：队列的名称及属性</li><li>交换器：交换器的名称及属性</li><li>绑定关系元数据：交换器与队列或者交换器与交换器</li><li>vhost元数据：为vhost内的队列，交换器和绑定提供命名空间及安全属性之间的绑定关系<br><a name="t6dik"></a></li></ul><h6 id="1-3-节点类型">1.3 节点类型</h6><p>RabbitMQ 中的节点类型有两种：</p><ul><li>RAM node：内存节点将所有的队列、交换机、绑定、用户、权限和 vhost 的元数据定义存储在内存中，好处是可以使得交换机和队列声明等操作速度更快。</li><li>Disk node：将元数据存储在磁盘中，单节点系统只允许磁盘类型的节点，防止重启 RabbitMQ 的时候，丢失系统的配置信息</li></ul><p>RabbitMQ 要求在集群中至少有一个磁盘节点，所有其他节点可以是内存节点，当节点加入或者离开集群时，必须要将该变更通知到至少一个磁盘节点。如果集群中唯一的一个磁盘节点崩溃的话，集群仍然可以保持运行，但是无法进行其他操作（增删改查），直到节点恢复。为了确保集群信息的可靠性，或者在不确定使用磁盘节点还是内存节点的时候，建议直接用磁盘节点。<br><a name="kErhw"></a></p><h6 id="1-4-缺点">1.4 缺点</h6><p>我们会发现，在这汇总集群方式中的情形下，我们会遇到如下几个问题</p><ol><li>保存队列的节点很难知道</li><li>一旦保存队列信息的节点宕机，其实，集群还是没办法工作<br><a name="cosL3"></a></li></ol><h5 id="2-windows下单机配置rabbitmq集群（普通模式）">2 windows下单机配置rabbitmq集群（普通模式）</h5><p><a name="JtgQ6"></a></p><h6 id="2-1-安装rabbitmq">2.1 安装rabbitmq</h6><p>参考文章<a href="https://blog.csdn.net/bboy_lanfon/article/details/124970244">window下单机搭建RabbitMQ多节点集群</a><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713420962659-a9757561-8fd3-4217-875d-7f4837206067.png#averageHue=%23082c5e&amp;clientId=ue2064c1b-b380-4&amp;from=paste&amp;id=u0af5f69d&amp;originHeight=961&amp;originWidth=1722&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=649473&amp;status=done&amp;style=none&amp;taskId=u2a89f4d0-00f3-41a0-b25d-5d34985711a&amp;title=" alt="image.jpg"><br />分别访问他们的ui管理界面<br /><a href="http://localhost:15673/#/">http://localhost:15673/#/</a><br /><a href="http://localhost:15674/#/">http://localhost:15674/#/</a><br /><a href="http://localhost:15675/#/">http://localhost:15675/#/</a><br />界面应当如下，节点名称应当会变，但是应当可以访问<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713420961711-755ef7c0-e23e-441a-a0b5-4ab466332de1.png#averageHue=%23f7f6f6&amp;clientId=ue2064c1b-b380-4&amp;from=paste&amp;id=ud5a15602&amp;originHeight=844&amp;originWidth=1753&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=121927&amp;status=done&amp;style=none&amp;taskId=uf6293507-0976-4752-8a33-05336de7d12&amp;title=" alt="image.jpg"><br><a name="UFLIn"></a></p><h6 id="2-2-建立集群">2.2 建立集群</h6><p>关闭rabbitmq node 2,3，让他们加入rabbit1集群<br />如果是通过rabbitmq-serve<a href="https://so.csdn.net/so/search?q=r%E6%96%B9&amp;spm=1001.2101.3001.7020">r方</a>式启动的，直接关闭运行界面就可以了，如果是通过rabbitmq-server -detached的话，执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\tools\RabbitMQ Server\rabbitmq_server-3.8.4-2\sbin&gt;rabbitmqctl stop_app</span><br><span class="line">Stopping rabbit application on node rabbit2@DESKTOP-IB5K0.. ... //成功关闭提示</span><br></pre></td></tr></table></figure><p>ok，那我们正式开始，关闭所有的节点（命令基于powershell）<br><a name="ENXTZ"></a></p><h6 id="2-2-1-启动rabbit1，执行-rabbitmq-server-bat-detached">2.2.1 启动rabbit1，执行 .\rabbitmq-server.bat -detached</h6><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713420961220-35730b47-9d85-4937-b457-ec2d0cd29234.png#averageHue=%23b9d750&amp;clientId=ue2064c1b-b380-4&amp;from=paste&amp;id=uf4037f06&amp;originHeight=60&amp;originWidth=716&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=14602&amp;status=done&amp;style=none&amp;taskId=u41890c42-4bda-46a2-b7cd-260c338585a&amp;title=" alt="image.jpg"><br />打开 <a href="http://localhost:15673/#/">http://localhost:15673/#/</a> 查看信息<br><a name="s2mzl"></a></p><h6 id="2-2-2-将-rabbit2-加入-rabbit1，-在rabbit2的目录下执行：">2.2.2 将 rabbit2 加入 rabbit1， 在rabbit2的目录下执行：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\rabbitmqctl.bat join_cluster rabbit1</span><br></pre></td></tr></table></figure><p>出现如下提示，<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713420961328-9dd4df5f-befa-4b71-80c9-86e328ff6582.png#averageHue=%23032759&amp;clientId=ue2064c1b-b380-4&amp;from=paste&amp;id=ue905b570&amp;originHeight=230&amp;originWidth=1118&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=43732&amp;status=done&amp;style=none&amp;taskId=u3b350613-e411-4b7c-8430-db9e3ef4edc&amp;title=" alt="image.jpg"><br />我们查看<a href="http://localhost:15673/#/%EF%BC%8C">http://localhost:15673/#/，</a><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713420961934-3b2e4a52-3f0c-421d-aa1f-980cef5ce45f.png#averageHue=%23f7f4f3&amp;clientId=ue2064c1b-b380-4&amp;from=paste&amp;id=uc9013380&amp;originHeight=843&amp;originWidth=1621&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=96128&amp;status=done&amp;style=none&amp;taskId=u9941a851-cb52-4bc6-b8aa-a18d53e8ff4&amp;title=" alt="image.jpg"><br />rabbit2节点没有启动，但是加进来了。<br><a name="odZ3d"></a></p><h6 id="2-2-3-启动节点rabbit2">2.2.3 启动节点rabbit2</h6><p>在D:\rabbitmq_server-3.10.6-2\sbin 下执行如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713420962173-145bdab0-86c2-4b6a-a089-e4da760fda32.png#averageHue=%23f6f5f5&amp;clientId=ue2064c1b-b380-4&amp;from=paste&amp;id=u1d0f75fc&amp;originHeight=864&amp;originWidth=1690&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=113944&amp;status=done&amp;style=none&amp;taskId=ud63478b7-f553-45be-beca-931919ceb8b&amp;title=" alt="image.jpg"><br />rabbit2节点启动了<br /><strong>同理，注册rabbit3到集群中，并且启动</strong><br />可以在ui中查看到注册进来了<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713420962264-cd7630c3-3897-4608-a59a-7e32d9ff8f0e.png#averageHue=%23f4f4f3&amp;clientId=ue2064c1b-b380-4&amp;from=paste&amp;id=u5043d124&amp;originHeight=785&amp;originWidth=1825&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=143309&amp;status=done&amp;style=none&amp;taskId=u0ada0ab6-c1b0-43fa-850e-f69932f3c35&amp;title=" alt="image.jpg"><br><a name="to2BX"></a></p><h6 id="2-2-4-查看集群状态">2.2.4 查看集群状态</h6><p>我们切换到server-1下执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\rabbitmqctl.bat cluster_status</span><br></pre></td></tr></table></figure><p>可以查看各种节点的信息<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713420962222-988493d9-4165-48c4-a5a8-641cba2707a6.png#averageHue=%23022659&amp;clientId=ue2064c1b-b380-4&amp;from=paste&amp;id=u7eff96a6&amp;originHeight=563&amp;originWidth=928&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=100963&amp;status=done&amp;style=none&amp;taskId=u68d5fc5d-9253-43ef-88b0-bbf231e52c6&amp;title=" alt="image.jpg"><br><a name="e6G2i"></a></p><h6 id="2-2-5-退出集群">2.2.5 退出集群</h6><p>假如我们需要结束节点3，那么在对应的目录下，执行命令如下</p><ol><li>rabbitmq-server -detached （已经启动可以忽略这一步）</li><li>rabbitmqctl stop_app （关闭节点）</li><li>rabbitmqctl reset<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713420962254-d0a1b132-7318-4ae8-a1d5-032088e57942.png#averageHue=%2304295b&amp;clientId=ue2064c1b-b380-4&amp;from=paste&amp;id=uaeeb4a4e&amp;originHeight=144&amp;originWidth=752&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=41907&amp;status=done&amp;style=none&amp;taskId=uf037ce4c-c179-481e-8c98-dd3a26c2f8c&amp;title=" alt="image.jpg"><br />我们查看ui管理，发现节点rabbit3确实没了<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713420962602-aa1337a4-b3ca-4919-b921-b485853536fb.png#averageHue=%23eae9e8&amp;clientId=ue2064c1b-b380-4&amp;from=paste&amp;id=ucca05703&amp;originHeight=264&amp;originWidth=1625&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=67522&amp;status=done&amp;style=none&amp;taskId=u1d30a108-ffe1-494e-b696-3f49f335613&amp;title=" alt="image.jpg"><br />至此，普通集群已初步搭建，这种集群可以提高 RabbitMQ 的消息吞吐能力，但是无法保证高可用，因为一旦一个 RabbitMQ 实例挂了，消息就没法访问了，如果消息队列做了持久化，那么等 RabbitMQ 实例恢复后，才可以继续访问；如果消息队列没做持久化，那么消息就丢了。基于这种情况，我们可以将队列设置为镜像队列来解决<br><a name="dQnCD"></a></li></ol><h5 id="3-spring-boot-rabbitmq集群（单节点配置）">3 spring boot + rabbitmq集群（单节点配置）</h5><p>我们发现无论是访问下面的那个界面，都是出现了集群的信息的<br /><a href="http://localhost:15673/#/">http://localhost:15673/#/</a><br /><a href="http://localhost:15674/#/">http://localhost:15674/#/</a><br /><a href="http://localhost:15675/#/">http://localhost:15675/#/</a><br />前文请参考：<a href="https://editor.csdn.net/md/?articleId=128533455">spring-boot rabbitmq整合</a><br><a name="heM9w"></a></p><h6 id="3-1-发送单点结合，但是在另外的节点也是可以消费的">3.1 发送单点结合，但是在另外的节点也是可以消费的</h6><p>如果publish指定集群的某个节点，其他的节点也是可以访问这个message的，除非该节点宕机了。<br><a name="kFGEn"></a></p><h6 id="3-1-1-生产者设置节点是node1-rabbit1">3.1.1 生产者设置节点是node1-rabbit1</h6><p><strong>测试</strong><br />搭建好集群后，我们需要做个测试，我们发送一个mq消息，会发现三个节点都有这个消息，我们修改配置把publish的broker节点设置为5673，而不是address设置集群地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: 0.0.0.0</span><br><span class="line">    port: 5673</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    publisher-confirms: true    #确认消息已发送到交换机(Exchange)</span><br><span class="line">    publisher-returns: true     #确认消息已发送到队列(Queue)</span><br></pre></td></tr></table></figure><p>如果root没有权限，请改成guest/guest都行，我们发送了一个名为TestDirectQueue的队列，我们去<br /><a href="http://localhost:15673/#/queues">http://localhost:15673/#/queues</a><br /><a href="http://localhost:15674/#/queues">http://localhost:15674/#/queues</a><br /><a href="http://localhost:15675/#/queues">http://localhost:15675/#/queues</a><br />看，我们会发现都有未消费的的message<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713420962671-c3cd57ef-aa5d-497f-b680-0ad6364bc885.png#clientId=ue2064c1b-b380-4&amp;from=paste&amp;id=ua4df8414&amp;originHeight=640&amp;originWidth=1578&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=114599&amp;status=done&amp;style=none&amp;taskId=u4526751c-f575-4e56-badd-0f65212de75&amp;title=" alt="image.jpg"><br><a name="fjC9D"></a></p><h6 id="3-1-2-生产者设置消费者节点是node2-rabbit2">3.1.2 生产者设置消费者节点是node2-rabbit2</h6><p>修改consumer配置为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: 0.0.0.0</span><br><span class="line">    port: 5674</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    virtual-host: pers-xrb</span><br><span class="line">    listener:</span><br><span class="line">      direct:</span><br><span class="line">        retry:</span><br><span class="line">          max-attempts: 3</span><br><span class="line">      simple:</span><br><span class="line">        retry:</span><br><span class="line">          max-attempts: 3</span><br><span class="line">        acknowledge-mode: manual</span><br></pre></td></tr></table></figure><p>启动consumer项目，我们可以发现，message被消费完了<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713420962732-b26049aa-043b-453a-ae28-c9d7b024e1af.png#clientId=ue2064c1b-b380-4&amp;from=paste&amp;id=ucc131262&amp;originHeight=812&amp;originWidth=1590&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=141164&amp;status=done&amp;style=none&amp;taskId=ufb22cdeb-b1be-488e-a76f-3f0da071e0b&amp;title=" alt="image.jpg"><br /><strong>总结</strong><br />我们可以大胆的猜测，保留队列信息的消息在节点1，rabbit1上的，但是集群中的其他节点也是可以消费的。如果节点1的消费者很慢的话，多几个节点也是可以的。但是如果rabbit1节点宕机了，理论上是其他节点应该是消费不了的了。<br><a name="CCQ5o"></a></p><h6 id="3-2-基于3-1，停机publish发布的节点-rabbit1，其他节点会丢失该节点信息">3.2 基于3.1，停机publish发布的节点-rabbit1，其他节点会丢失该节点信息</h6><p><a name="YUJML"></a></p><h6 id="3-2-1-停止保存queue信息的节点">3.2.1 停止保存queue信息的节点</h6><p>如果保存queue 消息队列的节点宕机了的话，那么就会发现，其他节点没有节点信息了，我们发送一个mq后，再执行命令，停止rabbit1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\rabbitmqctl.bat stop_app</span><br></pre></td></tr></table></figure><p>在访问 <a href="http://localhost:15674/#/">http://localhost:15674/#/</a> 或者<a href="http://localhost:15675/#/">http://localhost:15675/#/</a> 我们会发现节点 rabbit1停止了，我们再看queue的消息<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713420962760-e824d3a7-3e37-4dce-8001-018a631272b1.png#clientId=ue2064c1b-b380-4&amp;from=paste&amp;id=u307df8e3&amp;originHeight=856&amp;originWidth=1483&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=128808&amp;status=done&amp;style=none&amp;taskId=u5fd97f7e-20f3-4808-bca9-b518ed63f98&amp;title=" alt="image.jpg"><br />无法获取对应的消息了，启动消费者会报错<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713420963057-e8d31932-2203-4b2e-b14c-6a5f0714f6e1.png#clientId=ue2064c1b-b380-4&amp;from=paste&amp;id=u0b49aab4&amp;originHeight=370&amp;originWidth=1319&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=177928&amp;status=done&amp;style=none&amp;taskId=u7d8792ca-aa70-42c3-b7b8-6587ff735e2&amp;title=" alt="image.jpg"><br><a name="DVu96"></a></p><h6 id="3-2-2-重启停止了的保存queue-消息的节点queue">3.2.2 重启停止了的保存queue 消息的节点queue</h6><p>我们执行命令，重启节点rabbit1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\rabbitmqctl.bat start_app</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713420963144-6cba2b1f-d11f-4c73-8dd2-15dca022518f.png#clientId=ue2064c1b-b380-4&amp;from=paste&amp;id=uae7c57a6&amp;originHeight=712&amp;originWidth=1456&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=104133&amp;status=done&amp;style=none&amp;taskId=u88523699-5579-4ecd-95c4-2ee1b04dfb6&amp;title=" alt="image.jpg"><br />message又可见了，我们再重启消费者，消费成功<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713420963231-a60c65a4-83db-495a-acf9-3f71e7e89965.png#clientId=ue2064c1b-b380-4&amp;from=paste&amp;id=u8cca24a6&amp;originHeight=328&amp;originWidth=1456&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=144579&amp;status=done&amp;style=none&amp;taskId=u61a08117-62a3-45e7-b4a4-e0e40ef7e40&amp;title=" alt="image.jpg"><br><a name="SafW4"></a></p><h5 id="4-spring-boot-rabbitmq集群（多节点配置）">4 spring boot + rabbitmq集群（多节点配置）</h5><p>参考 3. spring boot + rabbitmq集群（单节点配置） 只需要修改配置文件就可以了。<br />通常来说，配置rabbitmq的集群应该如下配置，在address中配置多个地址，通过都好分割</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    publisher-confirms: true    #确认消息已发送到交换机(Exchange)</span><br><span class="line">    publisher-returns: true     #确认消息已发送到队列(Queue)</span><br><span class="line">    addresses: 0.0.0.0:5674,0.0.0.0:5673,0.0.0.0:5675</span><br><span class="line">    listener:</span><br><span class="line">      simple:</span><br><span class="line">        acknowledge-mode: manual</span><br></pre></td></tr></table></figure><p><a name="ct08l"></a></p><h6 id="参考">参考</h6><ol><li><a href="https://www.jb51.net/article/231794.htm">SpringBoot中RabbitMQ集群的搭建详解</a></li><li><a href="https://blog.csdn.net/bboy_lanfon/article/details/124970244">window下单机搭建RabbitMQ多节点集群（超详细）</a></li></ol><p>代码地址： <a href="https://github.com/GitHubsteven/spring-in-action2.0/tree/master/spring-boot-mesage">https://github.com/GitHubsteven/spring-in-action2.0/tree/master/spring-boot-mesage</a></p><blockquote><p>来自: <a href="https://blog.csdn.net/u010714901/article/details/129360483?spm=1001.2014.3001.5501">rabbitmq集群-普通模式_rabbitmq 普通集群-CSDN博客</a></p></blockquote><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://so.csdn.net/so/search?q=RabbitMQ&amp;amp;spm=1001.2101.3001.7020&quot;&gt;RabbitMQ&lt;/a&gt;的Cluster模式分为两种&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;普通模式&lt;/li&gt;
&lt;li&gt;镜像模式</summary>
      
    
    
    
    <category term="中间件" scheme="http://www.bojiboqi.fun/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="rabbitmq" scheme="http://www.bojiboqi.fun/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq集群-镜像模式_rabbitmq镜像集群-</title>
    <link href="http://www.bojiboqi.fun/2024/04/22/rabbitmq%E9%9B%86%E7%BE%A4-%E9%95%9C%E5%83%8F%E6%A8%A1%E5%BC%8F_rabbitmq%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4-/"/>
    <id>http://www.bojiboqi.fun/2024/04/22/rabbitmq%E9%9B%86%E7%BE%A4-%E9%95%9C%E5%83%8F%E6%A8%A1%E5%BC%8F_rabbitmq%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4-/</id>
    <published>2024-04-22T06:25:54.225Z</published>
    <updated>2024-04-22T23:30:53.060Z</updated>
    
    <content type="html"><![CDATA[<p>上文参考： <a href="https://blog.csdn.net/u010714901/article/details/129360483?spm=1001.2014.3001.5501">rabbitmq集群-普通模式</a><br><a name="dHaEw"></a></p><h5 id="1-什么是镜像模式">1. 什么是镜像模式</h5><p>它和普通集群最大的区别在于 Queue 数据和原数据不再是单独存储在一台机器上，而是同时存储在多台机器上。也就是说每个 <a href="https://so.csdn.net/so/search?q=RabbitMQ&amp;spm=1001.2101.3001.7020">RabbitMQ</a> 实例都有一份镜像数据（副本数据）。每次写入消息的时候都会自动把数据同步到多台实例上去，这样一旦其中一台机器发生故障，其他机器还有一份副本数据可以继续提供服务，也就实现了高可用。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713420972483-52bb5c7f-d046-492f-bf9a-a221802d77e8.png#averageHue=%23fbfbfb&amp;clientId=u4b3b2b0a-4f41-4&amp;from=paste&amp;id=ue8d812bb&amp;originHeight=708&amp;originWidth=1476&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=121468&amp;status=done&amp;style=none&amp;taskId=u91878e3d-4ce0-4fc1-929e-53bc826186b&amp;title=" alt="image.jpg"><br><a name="ESMjF"></a></p><h5 id="2-配置镜像队列">2 配置镜像队列</h5><p>所谓的镜像集群模式并不需要额外搭建，只需要我们将队列配置为镜像队列即可。<br />这个配置可以通过网页配置，也可以通过命令行配置，我们分别来看。<br><a name="m50zs"></a></p><h6 id="2-1-网页配置">2.1 网页配置</h6><p>配置页面，我们可以通过配置页面配置不同的policy<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713420972406-52411e27-d2fd-4823-8139-27b71869b1b6.png#averageHue=%23f9f8f7&amp;clientId=u4b3b2b0a-4f41-4&amp;from=paste&amp;id=uef3829d3&amp;originHeight=951&amp;originWidth=1920&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=139769&amp;status=done&amp;style=none&amp;taskId=u13b6d05f-4e72-4936-905e-c921c7033d2&amp;title=" alt="image.jpg"><br />各参数含义如下：</p><ul><li>Name: policy 的名称。</li><li>Pattern: queue 的匹配模式(正则表达式)。</li><li>Definition：镜像定义，主要有三个参数：ha-mode, ha-params, ha-sync-mode。<ul><li>ha-mode：指明镜像队列的模式，有效值为 all、exactly、nodes。其中 all 表示在集群中所有的节点上进行镜像（默认即此）；exactly 表示在指定个数的节点上进行镜像，节点的个数由 ha-params 指定；nodes 表示在指定的节点上进行镜像，节点名称通过 ha-params 指定。</li><li>ha-params：ha-mode 模式需要用到的参数。</li><li>ha-sync-mode：进行队列中消息的同步方式，有效值为 automatic 和 manual。</li><li>priority 为可选参数，表示 policy 的优先级。</li></ul></li></ul><p>add结束，我们可以在其他的ui管理界面比如<a href="http://localhost:15674/#/policies%E7%9C%8B%E5%88%B0%E5%90%8C%E6%AD%A5%E7%9A%84policy">http://localhost:15674/#/policies看到同步的policy</a><br><a name="KBFX4"></a></p><h6 id="2-2-测试配置">2.2 测试配置</h6><p>配置结束后，我们做个测试，测试参考<a href="https://blog.csdn.net/u010714901/article/details/129360483?spm=1001.2014.3001.5501">rabbitmq集群-普通模式</a>中的3.2 基于3.1，停机publish发布的节点-rabbit1，其他节点会丢失该节点信息 在做测试，我们发现节点rabbit2，rabbit3依然存在（截图没有截rabbit3的）<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713420972517-16c80a21-ccc3-4a40-97b2-f5d0db0732ce.png#averageHue=%23e1dfdf&amp;clientId=u4b3b2b0a-4f41-4&amp;from=paste&amp;id=u71245bf5&amp;originHeight=1061&amp;originWidth=1886&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=224348&amp;status=done&amp;style=none&amp;taskId=u11a3f1a0-14f3-4868-8e3c-8311b88ce30&amp;title=" alt="image.jpg"><br />我们停止了rabbit1节点<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713420972403-dd8c05c0-57d5-46e1-bf9f-2fbd1906cf4c.png#averageHue=%23eee6e5&amp;clientId=u4b3b2b0a-4f41-4&amp;from=paste&amp;id=u6c509736&amp;originHeight=376&amp;originWidth=1641&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=76585&amp;status=done&amp;style=none&amp;taskId=ue1e02b9b-4c9f-417e-97b5-c7e786154e6&amp;title=" alt="image.jpg"><br />启动consumer，message被消费了一次<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713420972448-94c2f2fb-8583-4032-aa88-e39e285590c7.png#averageHue=%238f7e5e&amp;clientId=u4b3b2b0a-4f41-4&amp;from=paste&amp;id=u571ae1c4&amp;originHeight=353&amp;originWidth=1431&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=163793&amp;status=done&amp;style=none&amp;taskId=udb5176a1-99c6-414c-a19c-8663fcb7ec6&amp;title=" alt="image.jpg"><br><a name="qfA6V"></a></p><h6 id="2-3-命令行配置">2.3 命令行配置</h6><p>命令行的配置格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy [-p vhost] [--priority priority] [--apply-to apply-to] &#123;name&#125; &#123;pattern&#125; &#123;definition&#125;</span><br></pre></td></tr></table></figure><p>举一个简单的配置案例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy -p / --apply-to queues my_queue_mirror &quot;^&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure><p><a name="i5ske"></a></p><h5 id="3-rabbitmq的集群和单体">3 rabbitmq的集群和单体</h5><p>在高并发下，集群当然是更好的选择，如果数据量很大的话，比如处理数据达到了几千万甚至上亿，集群也很被推荐，但是，集群并不意味着就是比单体更好的，我们都知道，集群也有如下缺点</p><ol><li>增加了运维的成本</li><li>对于单个mq来说，集群是增加了时间成本，而不是降低了，因为message数据管理更加复杂了</li></ol><p>参考 <a href="https://dzone.com/articles/rabbitmq-in-cluster">Using RabbitMQ in Cluster</a></p><blockquote><p>Sending 100k messages to the single instance took about 10 seconds, while sending them to the first instance from cluster took about 54 seconds. There is also a huge difference in processing messages on the receiver side. Receiving messages from single standalone queue took about 43 seconds while receiving then from the clustered HA queue took about 132 seconds.</p></blockquote><p>所以，是否集群也是看业务需求。</p><blockquote><p>来自: <a href="https://blog.csdn.net/u010714901/article/details/129405575">rabbitmq集群-镜像模式_rabbitmq镜像集群-CSDN博客</a></p></blockquote><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上文参考： &lt;a href=&quot;https://blog.csdn.net/u010714901/article/details/129360483?spm=1001.2014.3001.5501&quot;&gt;rabbitmq集群-普通模式&lt;/a&gt;&lt;br&gt;
&lt;a name=&quot;dHaEw</summary>
      
    
    
    
    <category term="中间件" scheme="http://www.bojiboqi.fun/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="rabbitmq" scheme="http://www.bojiboqi.fun/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ如何保证消息的顺序性【重点】-</title>
    <link href="http://www.bojiboqi.fun/2024/04/22/RabbitMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91-/"/>
    <id>http://www.bojiboqi.fun/2024/04/22/RabbitMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91-/</id>
    <published>2024-04-22T06:25:41.639Z</published>
    <updated>2024-04-22T23:31:28.694Z</updated>
    
    <content type="html"><![CDATA[<p><a name="A3PsX"></a></p><h3 id="1-1-保证顺序性的意义">1.1 保证顺序性的意义</h3><p><strong>消息队列中的若干消息如果是对同一个数据进行操作，这些操作具有前后的关系，必须要按前后的顺序执行，否则就会造成数据异常</strong>。<br />举例：<br />比如通过<code>mysql binlog</code>进行两个数据库的数据同步，由于对数据库的数据操作是具有顺序性的，如果操作顺序搞反，就会造成不可估量的错误。比如数据库对一条数据依次进行了 <code>插入-&gt;更新-&gt;删除</code>操作，这个顺序必须是这样，如果在同步过程中，消息的顺序变成了<code>删除-&gt;插入-&gt;更新</code>，那么原本应该被删除的数据，就没有被删除，造成数据的不一致问题。<br><a name="p2X1Q"></a></p><h3 id="1-2-出现顺序错乱的场景">1.2 出现顺序错乱的场景</h3><p>我们还是以<a href="https://so.csdn.net/so/search?q=RabbitMQ&amp;spm=1001.2101.3001.7020">RabbitMQ</a>为例，后续会陆续更新更多的MQ的解决方案。<br><a name="uBmSD"></a></p><h4 id="1-2-1-错乱场景一">1.2.1 错乱场景一</h4><p>①一个<code>queue</code>，有多个<code>consumer</code>去消费，这样就会造成顺序的错误，<code>consumer</code>从<code>MQ</code>里面读取数据是有序的，但是每个<code>consumer</code>的执行时间是不固定的，无法保证先读到消息的<code>consumer</code>一定先完成操作，这样就会出现消息并没有按照顺序执行，造成数据顺序错误。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713422821665-65fb5531-0828-47e0-a4d0-330400286eca.png#averageHue=%23efefef&amp;clientId=u57d7ee55-2ee8-4&amp;from=paste&amp;id=u73191db6&amp;originHeight=495&amp;originWidth=1421&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=169008&amp;status=done&amp;style=none&amp;taskId=ud790b224-a808-455d-883b-b07d2d09f46&amp;title=" alt="image.jpg"><br><a name="QgVAE"></a></p><h4 id="1-2-2-错乱场景二">1.2.2 错乱场景二</h4><p>一个<code>queue</code>对应一个<code>consumer</code>，但是<code>consumer</code>里面进行了多线程消费，这样也会造成消息消费顺序错误。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713422821711-29ff754e-2fd0-4748-a911-315348f4f153.png#averageHue=%23efefef&amp;clientId=u57d7ee55-2ee8-4&amp;from=paste&amp;id=u5910e25b&amp;originHeight=416&amp;originWidth=1610&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=160327&amp;status=done&amp;style=none&amp;taskId=ub842352e-17f9-4ff0-a53f-5a94c45eb9d&amp;title=" alt="image.jpg"><br><a name="Low74"></a></p><h3 id="1-3-保证消息的消费顺序">1.3 保证消息的消费顺序</h3><p><a name="OCVgd"></a></p><h4 id="1-3-1-解决方案一">1.3.1 解决方案一</h4><p>拆分成多个<code>queue</code>，每个<code>queue</code>一个<code>consumer</code>，就是多一些<code>queue</code>而已，确实是麻烦点；这样也会造成吞吐量下降，可以在消费者内部采用多线程的方式取消费。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713422822354-7104c7ac-f1e4-4481-8ac8-b5f50aede044.png#averageHue=%23f1f1f1&amp;clientId=u57d7ee55-2ee8-4&amp;from=paste&amp;id=ufff12605&amp;originHeight=584&amp;originWidth=1387&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=166170&amp;status=done&amp;style=none&amp;taskId=u1400f027-7db0-4820-adbf-dfe54a9b059&amp;title=" alt="image.jpg"><br><a name="pEELa"></a></p><h4 id="1-3-2-解决方案二">1.3.2 解决方案二</h4><p>或者就一个<code>queue</code>但是对应一个<code>consumer</code>，然后这个<code>consumer</code>内部用内存队列做排队，然后分发给底层不同的<code>worker</code>来处理<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713422821947-49369ffb-58e6-4392-b770-6fbde93ad7b4.png#averageHue=%23f0f0f0&amp;clientId=u57d7ee55-2ee8-4&amp;from=paste&amp;id=udbd3648c&amp;originHeight=559&amp;originWidth=1644&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=187965&amp;status=done&amp;style=none&amp;taskId=u9b162a24-d138-4329-a408-23519ba275b&amp;title=" alt="image.jpg"></p><blockquote><p>来自: <a href="https://blog.csdn.net/weixin_42039228/article/details/123526391">RabbitMQ如何保证消息的顺序性【重点】-CSDN博客</a></p></blockquote><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;A3PsX&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-1-保证顺序性的意义&quot;&gt;1.1 保证顺序性的意义&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;消息队列中的若干消息如果是对同一个数据进行操作，这些操作具有前后的关系，必须要按前后的顺序执行，否则就会造成数据异常&lt;/s</summary>
      
    
    
    
    <category term="中间件" scheme="http://www.bojiboqi.fun/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="rabbitmq" scheme="http://www.bojiboqi.fun/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>【RabbitMQ】一文带你搞定RabbitMQ延迟队列</title>
    <link href="http://www.bojiboqi.fun/2024/04/22/%E3%80%90RabbitMQ%E3%80%91%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%90%9E%E5%AE%9ARabbitMQ%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/"/>
    <id>http://www.bojiboqi.fun/2024/04/22/%E3%80%90RabbitMQ%E3%80%91%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%90%9E%E5%AE%9ARabbitMQ%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/</id>
    <published>2024-04-22T06:25:31.199Z</published>
    <updated>2024-04-22T23:29:20.526Z</updated>
    
    <content type="html"><![CDATA[<p><a name="kMFo7"></a></p><h2 id="一、说明">一、说明</h2><p>在上一篇中，介绍了RabbitMQ中的死信队列是什么，何时使用以及如何使用RabbitMQ的死信队列。相信通过上一篇的学习，对于死信队列已经有了更多的了解，这一篇的内容也跟死信队列息息相关，如果你还不了解死信队列，那么建议你先进行上一篇文章的阅读。<br />这一篇里，我们将继续介绍RabbitMQ的高级特性，通过本篇的学习，你将收获：</p><ol><li>什么是延时队列</li><li>延时队列使用场景</li><li>RabbitMQ中的TTL</li><li>如何利用RabbitMQ来实现延时队列<br><a name="eNeer"></a></li></ol><h2 id="二、本文大纲">二、本文大纲</h2><p>以下是本文大纲：<br /><a href="https://i.loli.net/2019/07/28/5d3d74d99699d43032.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713423241491-f674df65-084b-4e62-883f-232d339be8e7.png#averageHue=%232e2635&amp;clientId=u5fb36043-6de7-4&amp;from=paste&amp;id=u2357b6fd&amp;originHeight=630&amp;originWidth=1107&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=52266&amp;status=done&amp;style=none&amp;taskId=u6fde8eb1-889a-4e73-b4e5-f70bac57caa&amp;title=" alt="image.jpg"></a><br />本文阅读前，需要对RabbitMQ以及死信队列有一个简单的了解。<br><a name="aHaIV"></a></p><h2 id="三、什么是延时队列">三、什么是延时队列</h2><p><code>延时队列</code>，首先，它是一种队列，队列意味着内部的元素是<code>有序</code>的，元素出队和入队是有方向性的，元素从一端进入，从另一端取出。<br />其次，<code>延时队列</code>，最重要的特性就体现在它的<code>延时</code>属性上，跟普通的队列不一样的是，<code>普通队列中的元素总是等着希望被早点取出处理，而延时队列中的元素则是希望被在指定时间得到取出和处理</code>，所以延时队列中的元素是都是带时间属性的，通常来说是需要被处理的消息或者任务。<br />简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列。<br><a name="ZDpXX"></a></p><h2 id="四、延时队列使用场景">四、延时队列使用场景</h2><p>那么什么时候需要用延时队列呢？考虑一下以下场景：</p><ol><li>订单在十分钟之内未支付则自动取消。</li><li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。</li><li>账单在一周内未支付，则自动结算。</li><li>用户注册成功后，如果三天内没有登陆则进行短信提醒。</li><li>用户发起退款，如果三天内没有得到处理则通知相关运营人员。</li><li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议。</li></ol><p>这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如：发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；发生店铺创建事件，十天后检查该店铺上新商品数，然后通知上新数为0的商户；发生账单生成事件，检查账单支付状态，然后自动结算未支付的账单；发生新用户注册事件，三天后检查新注册用户的活动数据，然后通知没有任何活动记录的用户；发生退款事件，在三天之后检查该订单是否已被处理，如仍未被处理，则发送消息给相关运营人员；发生预定会议事件，判断离会议开始是否只有十分钟了，如果是，则通知各个与会人员。<br />看起来似乎使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？如果数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求，如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。<br />更重要的一点是，不！优！雅！<br />没错，作为一名有追求的程序员，始终应该追求更优雅的架构和更优雅的代码风格，写代码要像写诗一样优美。【滑稽】<br />这时候，延时队列就可以闪亮登场了，以上场景，正是延时队列的用武之地。<br />既然<code>延时队列</code>可以解决很多特定场景下，带时间属性的任务需求，那么如何构造一个延时队列呢？接下来，本文将介绍如何用RabbitMQ来实现延时队列。<br><a name="PsAtN"></a></p><h2 id="五、RabbitMQ中的TTL">五、RabbitMQ中的TTL</h2><p>在介绍延时队列之前，还需要先介绍一下RabbitMQ中的一个高级特性——<code>TTL（Time To Live）</code>。<br /><code>TTL</code>是什么呢？<code>TTL</code>是RabbitMQ中一个消息或者队列的属性，表明<code>一条消息或者该队列中的所有消息的最大存活时间</code>，单位是毫秒。换句话说，如果一条消息设置了TTL属性或者进入了设置TTL属性的队列，那么这条消息如果在TTL设置的时间内没有被消费，则会成为“死信”（至于什么是死信，请翻看上一篇）。如果同时配置了队列的TTL和消息的TTL，那么较小的那个值将会被使用。<br />那么，如何设置这个TTL值呢？有两种方式，第一种是在创建队列的时候设置队列的“x-message-ttl”属性，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();</span><br><span class="line">args.put(&quot;x-message-ttl&quot;, 6000);</span><br><span class="line">channel.queueDeclare(queueName, durable, exclusive, autoDelete, args);</span><br></pre></td></tr></table></figure><p>这样所有被投递到该队列的消息都最多不会存活超过6s。</p><p>另一种方式便是针对每条消息设置TTL，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties.Builder builder = new AMQP.BasicProperties.Builder();</span><br><span class="line">builder.expiration(&quot;6000&quot;);</span><br><span class="line">AMQP.BasicProperties properties = builder.build();</span><br><span class="line">channel.basicPublish(exchangeName, routingKey, mandatory, properties, &quot;msg body&quot;.getBytes());</span><br></pre></td></tr></table></figure><p>这样这条消息的过期时间也被设置成了6s。</p><p>但这两种方式是有区别的，<strong>如果设置了队列的TTL属性，那么一旦消息过期，就会被队列丢弃，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间。</strong></p><p>另外，还需要注意的一点是，如果不设置TTL，表示消息永远不会过期，如果将TTL设置为0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。</p><p><a name="DxHx5"></a></p><h2 id="六、如何利用RabbitMQ实现延时队列">六、如何利用RabbitMQ实现延时队列</h2><p>前一篇里介绍了如果设置死信队列，前文中又介绍了TTL，至此，利用RabbitMQ实现延时队列的两大要素已经集齐，接下来只需要将它们进行调和，再加入一点点调味料，延时队列就可以新鲜出炉了。</p><p>想想看，<code>延时队列</code>，不就是想要消息延迟多久被处理吗，TTL则刚好能让消息在延迟多久之后成为死信，另一方面，成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就万事大吉了，因为里面的消息都是希望被立即处理的消息。<br />从下图可以大致看出消息的流向：<br /><a href="https://i.loli.net/2019/07/28/5d3d743143ecc85643.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713423241662-5ba794e7-6e24-460b-8b74-6351e79ace73.png#averageHue=%23fefaf3&amp;clientId=u5fb36043-6de7-4&amp;from=paste&amp;id=ub36cc5b0&amp;originHeight=658&amp;originWidth=1944&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=104056&amp;status=done&amp;style=none&amp;taskId=u9911246d-22bc-4ea9-9978-7af39197de7&amp;title=" alt="image.jpg"></a><br />生产者生产一条延时消息，根据需要延时时间的不同，利用不同的routingkey将消息路由到不同的延时队列，每个队列都设置了不同的TTL属性，并绑定在同一个死信交换机中，消息过期后，根据routingkey的不同，又会被路由到不同的死信队列中，消费者只需要监听对应的死信队列进行处理即可。<br />下面来看代码：<br />先声明交换机、队列以及他们的绑定关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RabbitMQConfig &#123;</span><br><span class="line"></span><br><span class="line">    public static final String DELAY_EXCHANGE_NAME = &quot;delay.queue.demo.business.exchange&quot;;</span><br><span class="line">    public static final String DELAY_QUEUEA_NAME = &quot;delay.queue.demo.business.queuea&quot;;</span><br><span class="line">    public static final String DELAY_QUEUEB_NAME = &quot;delay.queue.demo.business.queueb&quot;;</span><br><span class="line">    public static final String DELAY_QUEUEA_ROUTING_KEY = &quot;delay.queue.demo.business.queuea.routingkey&quot;;</span><br><span class="line">    public static final String DELAY_QUEUEB_ROUTING_KEY = &quot;delay.queue.demo.business.queueb.routingkey&quot;;</span><br><span class="line">    public static final String DEAD_LETTER_EXCHANGE = &quot;delay.queue.demo.deadletter.exchange&quot;;</span><br><span class="line">    public static final String DEAD_LETTER_QUEUEA_ROUTING_KEY = &quot;delay.queue.demo.deadletter.delay_10s.routingkey&quot;;</span><br><span class="line">    public static final String DEAD_LETTER_QUEUEB_ROUTING_KEY = &quot;delay.queue.demo.deadletter.delay_60s.routingkey&quot;;</span><br><span class="line">    public static final String DEAD_LETTER_QUEUEA_NAME = &quot;delay.queue.demo.deadletter.queuea&quot;;</span><br><span class="line">    public static final String DEAD_LETTER_QUEUEB_NAME = &quot;delay.queue.demo.deadletter.queueb&quot;;</span><br><span class="line"></span><br><span class="line">    // 声明延时Exchange</span><br><span class="line">    @Bean(&quot;delayExchange&quot;)</span><br><span class="line">    public DirectExchange delayExchange()&#123;</span><br><span class="line">        return new DirectExchange(DELAY_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明死信Exchange</span><br><span class="line">    @Bean(&quot;deadLetterExchange&quot;)</span><br><span class="line">    public DirectExchange deadLetterExchange()&#123;</span><br><span class="line">        return new DirectExchange(DEAD_LETTER_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明延时队列A 延时10s</span><br><span class="line">    // 并绑定到对应的死信交换机</span><br><span class="line">    @Bean(&quot;delayQueueA&quot;)</span><br><span class="line">    public Queue delayQueueA()&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = new HashMap&lt;&gt;(2);</span><br><span class="line">        // x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span><br><span class="line">        args.put(&quot;x-dead-letter-exchange&quot;, DEAD_LETTER_EXCHANGE);</span><br><span class="line">        // x-dead-letter-routing-key  这里声明当前队列的死信路由key</span><br><span class="line">        args.put(&quot;x-dead-letter-routing-key&quot;, DEAD_LETTER_QUEUEA_ROUTING_KEY);</span><br><span class="line">        // x-message-ttl  声明队列的TTL</span><br><span class="line">        args.put(&quot;x-message-ttl&quot;, 6000);</span><br><span class="line">        return QueueBuilder.durable(DELAY_QUEUEA_NAME).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明延时队列B 延时 60s</span><br><span class="line">    // 并绑定到对应的死信交换机</span><br><span class="line">    @Bean(&quot;delayQueueB&quot;)</span><br><span class="line">    public Queue delayQueueB()&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = new HashMap&lt;&gt;(2);</span><br><span class="line">        // x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span><br><span class="line">        args.put(&quot;x-dead-letter-exchange&quot;, DEAD_LETTER_EXCHANGE);</span><br><span class="line">        // x-dead-letter-routing-key  这里声明当前队列的死信路由key</span><br><span class="line">        args.put(&quot;x-dead-letter-routing-key&quot;, DEAD_LETTER_QUEUEB_ROUTING_KEY);</span><br><span class="line">        // x-message-ttl  声明队列的TTL</span><br><span class="line">        args.put(&quot;x-message-ttl&quot;, 60000);</span><br><span class="line">        return QueueBuilder.durable(DELAY_QUEUEB_NAME).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明死信队列A 用于接收延时10s处理的消息</span><br><span class="line">    @Bean(&quot;deadLetterQueueA&quot;)</span><br><span class="line">    public Queue deadLetterQueueA()&#123;</span><br><span class="line">        return new Queue(DEAD_LETTER_QUEUEA_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明死信队列B 用于接收延时60s处理的消息</span><br><span class="line">    @Bean(&quot;deadLetterQueueB&quot;)</span><br><span class="line">    public Queue deadLetterQueueB()&#123;</span><br><span class="line">        return new Queue(DEAD_LETTER_QUEUEB_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明延时队列A绑定关系</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding delayBindingA(@Qualifier(&quot;delayQueueA&quot;) Queue queue,</span><br><span class="line">                                    @Qualifier(&quot;delayExchange&quot;) DirectExchange exchange)&#123;</span><br><span class="line">        return BindingBuilder.bind(queue).to(exchange).with(DELAY_QUEUEA_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明业务队列B绑定关系</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding delayBindingB(@Qualifier(&quot;delayQueueB&quot;) Queue queue,</span><br><span class="line">                                    @Qualifier(&quot;delayExchange&quot;) DirectExchange exchange)&#123;</span><br><span class="line">        return BindingBuilder.bind(queue).to(exchange).with(DELAY_QUEUEB_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明死信队列A绑定关系</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding deadLetterBindingA(@Qualifier(&quot;deadLetterQueueA&quot;) Queue queue,</span><br><span class="line">                                    @Qualifier(&quot;deadLetterExchange&quot;) DirectExchange exchange)&#123;</span><br><span class="line">        return BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEA_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明死信队列B绑定关系</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding deadLetterBindingB(@Qualifier(&quot;deadLetterQueueB&quot;) Queue queue,</span><br><span class="line">                                      @Qualifier(&quot;deadLetterExchange&quot;) DirectExchange exchange)&#123;</span><br><span class="line">        return BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEB_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，创建两个消费者，分别对两个死信队列的消息进行消费：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class DeadLetterQueueConsumer &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = DEAD_LETTER_QUEUEA_NAME)</span><br><span class="line">    public void receiveA(Message message, Channel channel) throws IOException &#123;</span><br><span class="line">        String msg = new String(message.getBody());</span><br><span class="line">        log.info(&quot;当前时间：&#123;&#125;,死信队列A收到消息：&#123;&#125;&quot;, new Date().toString(), msg);</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = DEAD_LETTER_QUEUEB_NAME)</span><br><span class="line">    public void receiveB(Message message, Channel channel) throws IOException &#123;</span><br><span class="line">        String msg = new String(message.getBody());</span><br><span class="line">        log.info(&quot;当前时间：&#123;&#125;,死信队列B收到消息：&#123;&#125;&quot;, new Date().toString(), msg);</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是消息的生产者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class DelayMessageSender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    public void sendMsg(String msg, DelayTypeEnum type)&#123;</span><br><span class="line">        switch (type)&#123;</span><br><span class="line">            case DELAY_10s:</span><br><span class="line">                rabbitTemplate.convertAndSend(DELAY_EXCHANGE_NAME, DELAY_QUEUEA_ROUTING_KEY, msg);</span><br><span class="line">                break;</span><br><span class="line">            case DELAY_60s:</span><br><span class="line">                rabbitTemplate.convertAndSend(DELAY_EXCHANGE_NAME, DELAY_QUEUEB_ROUTING_KEY, msg);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们暴露一个web接口来生产消息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@RequestMapping(&quot;rabbitmq&quot;)</span><br><span class="line">@RestController</span><br><span class="line">public class RabbitMQMsgController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DelayMessageSender sender;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;sendmsg&quot;)</span><br><span class="line">    public void sendMsg(String msg, Integer delayType)&#123;</span><br><span class="line">        log.info(&quot;当前时间：&#123;&#125;,收到请求，msg:&#123;&#125;,delayType:&#123;&#125;&quot;, new Date(), msg, delayType);</span><br><span class="line">        sender.sendMsg(msg, Objects.requireNonNull(DelayTypeEnum.getDelayTypeEnumByValue(delayType)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备就绪，启动！<br />打开rabbitMQ的<a href="http://localhost:15672/">管理后台</a>，可以看到我们刚才创建的交换机和队列信息：<br /><a href="https://i.loli.net/2019/07/28/5d3d54e15534398514.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713423241495-8156a262-bb26-4d68-948a-3145ce04b57a.png#clientId=u5fb36043-6de7-4&amp;from=paste&amp;id=uc07de8b7&amp;originHeight=497&amp;originWidth=888&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=41290&amp;status=done&amp;style=none&amp;taskId=u8ed6e012-6728-4663-a7d4-31f6daa8503&amp;title=" alt="image.jpg"></a><br /><a href="https://i.loli.net/2019/07/28/5d3d54e17df8183993.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713423241524-649ef9e3-4f99-4d83-9a4e-f9b7b017660f.png#clientId=u5fb36043-6de7-4&amp;from=paste&amp;id=uedb4149f&amp;originHeight=535&amp;originWidth=987&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=57513&amp;status=done&amp;style=none&amp;taskId=udfbd6c28-0fc8-4303-abbe-5736857a64f&amp;title=" alt="image.jpg"></a><br /><a href="https://i.loli.net/2019/07/28/5d3d54e16952546955.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713423241524-e9f7e5cf-f6af-4a6e-adf5-3eebfb07d754.png#clientId=u5fb36043-6de7-4&amp;from=paste&amp;id=ud92a024d&amp;originHeight=669&amp;originWidth=720&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=43347&amp;status=done&amp;style=none&amp;taskId=u5f8b7b2a-b96c-4508-85fd-2ab57e5cdba&amp;title=" alt="image.jpg"></a><br />接下来，我们来发送几条消息，<a href="http://localhost:8080/rabbitmq/sendmsg?msg=testMsg1&amp;delayType=1">http://localhost:8080/rabbitmq/sendmsg?msg=testMsg1&amp;delayType=1</a><a href="http://localhost:8080/rabbitmq/sendmsg?msg=testMsg2&amp;delayType=2">http://localhost:8080/rabbitmq/sendmsg?msg=testMsg2&amp;delayType=2</a><br />日志如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-07-28 16:02:19.813  INFO 3860 --- [nio-8080-exec-9] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 16:02:19 CST 2019,收到请求，msg:testMsg1,delayType:1</span><br><span class="line">2019-07-28 16:02:19.815  INFO 3860 --- [nio-8080-exec-9] .l.DirectReplyToMessageListenerContainer : SimpleConsumer [queue=amq.rabbitmq.reply-to, consumerTag=amq.ctag-o-qPpkWIkRm73DIrOIVhig identity=766339] started</span><br><span class="line">2019-07-28 16:02:25.829  INFO 3860 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 16:02:25 CST 2019,死信队列A收到消息：testMsg1</span><br><span class="line">2019-07-28 16:02:41.326  INFO 3860 --- [nio-8080-exec-1] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 16:02:41 CST 2019,收到请求，msg:testMsg2,delayType:2</span><br><span class="line">2019-07-28 16:03:41.329  INFO 3860 --- [ntContainer#0-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 16:03:41 CST 2019,死信队列B收到消息：testMsg2</span><br></pre></td></tr></table></figure><p>第一条消息在6s后变成了死信消息，然后被消费者消费掉，第二条消息在60s之后变成了死信消息，然后被消费掉，这样，一个还算ok的延时队列就打造完成了。<br />不过，等等，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有6s和60s两个时间选项，如果需要一个小时后处理，那么就需要增加TTL为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？？<br />嗯，仔细想想，事情并不简单。<br><a name="iT9ca"></a></p><h2 id="七、RabbitMQ延时队列优化">七、RabbitMQ延时队列优化</h2><p>显然，需要一种更通用的方案才能满足需求，那么就只能将TTL设置在消息属性里了。我们来试一试。<br />增加一个延时队列，用于接收设置为任意延时时长的消息，增加一个相应的死信队列和routingkey：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RabbitMQConfig &#123;</span><br><span class="line"></span><br><span class="line">    public static final String DELAY_EXCHANGE_NAME = &quot;delay.queue.demo.business.exchange&quot;;</span><br><span class="line">    public static final String DELAY_QUEUEC_NAME = &quot;delay.queue.demo.business.queuec&quot;;</span><br><span class="line">    public static final String DELAY_QUEUEC_ROUTING_KEY = &quot;delay.queue.demo.business.queuec.routingkey&quot;;</span><br><span class="line">    public static final String DEAD_LETTER_EXCHANGE = &quot;delay.queue.demo.deadletter.exchange&quot;;</span><br><span class="line">    public static final String DEAD_LETTER_QUEUEC_ROUTING_KEY = &quot;delay.queue.demo.deadletter.delay_anytime.routingkey&quot;;</span><br><span class="line">    public static final String DEAD_LETTER_QUEUEC_NAME = &quot;delay.queue.demo.deadletter.queuec&quot;;</span><br><span class="line"></span><br><span class="line">    // 声明延时Exchange</span><br><span class="line">    @Bean(&quot;delayExchange&quot;)</span><br><span class="line">    public DirectExchange delayExchange()&#123;</span><br><span class="line">        return new DirectExchange(DELAY_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明死信Exchange</span><br><span class="line">    @Bean(&quot;deadLetterExchange&quot;)</span><br><span class="line">    public DirectExchange deadLetterExchange()&#123;</span><br><span class="line">        return new DirectExchange(DEAD_LETTER_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明延时队列C 不设置TTL</span><br><span class="line">    // 并绑定到对应的死信交换机</span><br><span class="line">    @Bean(&quot;delayQueueC&quot;)</span><br><span class="line">    public Queue delayQueueC()&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = new HashMap&lt;&gt;(3);</span><br><span class="line">        // x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span><br><span class="line">        args.put(&quot;x-dead-letter-exchange&quot;, DEAD_LETTER_EXCHANGE);</span><br><span class="line">        // x-dead-letter-routing-key  这里声明当前队列的死信路由key</span><br><span class="line">        args.put(&quot;x-dead-letter-routing-key&quot;, DEAD_LETTER_QUEUEC_ROUTING_KEY);</span><br><span class="line">        return QueueBuilder.durable(DELAY_QUEUEC_NAME).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明死信队列C 用于接收延时任意时长处理的消息</span><br><span class="line">    @Bean(&quot;deadLetterQueueC&quot;)</span><br><span class="line">    public Queue deadLetterQueueC()&#123;</span><br><span class="line">        return new Queue(DEAD_LETTER_QUEUEC_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明延时列C绑定关系</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding delayBindingC(@Qualifier(&quot;delayQueueC&quot;) Queue queue,</span><br><span class="line">                                 @Qualifier(&quot;delayExchange&quot;) DirectExchange exchange)&#123;</span><br><span class="line">        return BindingBuilder.bind(queue).to(exchange).with(DELAY_QUEUEC_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明死信队列C绑定关系</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding deadLetterBindingC(@Qualifier(&quot;deadLetterQueueC&quot;) Queue queue,</span><br><span class="line">                                      @Qualifier(&quot;deadLetterExchange&quot;) DirectExchange exchange)&#123;</span><br><span class="line">        return BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEC_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加一个死信队列C的消费者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = DEAD_LETTER_QUEUEC_NAME)</span><br><span class="line">public void receiveC(Message message, Channel channel) throws IOException &#123;</span><br><span class="line">    String msg = new String(message.getBody());</span><br><span class="line">    log.info(&quot;当前时间：&#123;&#125;,死信队列C收到消息：&#123;&#125;&quot;, new Date().toString(), msg);</span><br><span class="line">    channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次启动！然后访问：<a href="http://localhost:8080/rabbitmq/delayMsg?msg=testMsg1delayTime=5000">http://localhost:8080/rabbitmq/delayMsg?msg=testMsg1delayTime=5000</a> 来生产消息，注意这里的单位是毫秒。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-07-28 16:45:07.033  INFO 31468 --- [nio-8080-exec-4] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 16:45:07 CST 2019,收到请求，msg:testMsg1,delayTime:5000</span><br><span class="line">2019-07-28 16:45:11.694  INFO 31468 --- [nio-8080-exec-5] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 16:45:11 CST 2019,收到请求，msg:testMsg2,delayTime:5000</span><br><span class="line">2019-07-28 16:45:12.048  INFO 31468 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 16:45:12 CST 2019,死信队列C收到消息：testMsg1</span><br><span class="line">2019-07-28 16:45:16.709  INFO 31468 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 16:45:16 CST 2019,死信队列C收到消息：testMsg2</span><br></pre></td></tr></table></figure><p>看起来似乎没什么问题，但不要高兴的太早，在最开始的时候，就介绍过，如果使用在消息属性上设置TTL的方式，消息可能并不会按时“死亡“，因为RabbitMQ只会检查第一个消息是否过期，如果过期则丢到死信队列，索引如果第一个消息的延时时长很长，而第二个消息的延时时长很短，则第二个消息并不会优先得到执行。<br />实验一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-07-28 16:49:02.957  INFO 31468 --- [nio-8080-exec-8] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 16:49:02 CST 2019,收到请求，msg:longDelayedMsg,delayTime:20000</span><br><span class="line">2019-07-28 16:49:10.671  INFO 31468 --- [nio-8080-exec-9] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 16:49:10 CST 2019,收到请求，msg:shortDelayedMsg,delayTime:2000</span><br><span class="line">2019-07-28 16:49:22.969  INFO 31468 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 16:49:22 CST 2019,死信队列C收到消息：longDelayedMsg</span><br><span class="line">2019-07-28 16:49:22.970  INFO 31468 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 16:49:22 CST 2019,死信队列C收到消息：shortDelayedMsg</span><br></pre></td></tr></table></figure><p>我们先发了一个延时时长为20s的消息，然后发了一个延时时长为2s的消息，结果显示，第二个消息会在等第一个消息成为死信后才会“死亡“。<br><a name="u9K5k"></a></p><h2 id="八、利用RabbitMQ插件实现延迟队列">八、利用RabbitMQ插件实现延迟队列</h2><p>上文中提到的问题，确实是一个硬伤，如果不能实现在消息粒度上添加TTL，并使其在设置的TTL时间及时死亡，就无法设计成一个通用的延时队列。<br />那如何解决这个问题呢？不要慌，安装一个插件即可：<a href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a> ，下载rabbitmq_delayed_message_exchange插件，然后解压放置到RabbitMQ的插件目录。<br />接下来，进入RabbitMQ的安装目录下的sbin目录，执行下面命令让该插件生效，然后重启RabbitMQ。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><p>然后，我们再声明几个Bean：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DelayedRabbitMQConfig &#123;</span><br><span class="line">    public static final String DELAYED_QUEUE_NAME = &quot;delay.queue.demo.delay.queue&quot;;</span><br><span class="line">    public static final String DELAYED_EXCHANGE_NAME = &quot;delay.queue.demo.delay.exchange&quot;;</span><br><span class="line">    public static final String DELAYED_ROUTING_KEY = &quot;delay.queue.demo.delay.routingkey&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue immediateQueue() &#123;</span><br><span class="line">        return new Queue(DELAYED_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public CustomExchange customExchange() &#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = new HashMap&lt;&gt;();</span><br><span class="line">        args.put(&quot;x-delayed-type&quot;, &quot;direct&quot;);</span><br><span class="line">        return new CustomExchange(DELAYED_EXCHANGE_NAME, &quot;x-delayed-message&quot;, true, false, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Binding bindingNotify(@Qualifier(&quot;immediateQueue&quot;) Queue queue,</span><br><span class="line">                                 @Qualifier(&quot;customExchange&quot;) CustomExchange customExchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(queue).to(customExchange).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller层再添加一个入口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;delayMsg2&quot;)</span><br><span class="line">public void delayMsg2(String msg, Integer delayTime) &#123;</span><br><span class="line">    log.info(&quot;当前时间：&#123;&#125;,收到请求，msg:&#123;&#125;,delayTime:&#123;&#125;&quot;, new Date(), msg, delayTime);</span><br><span class="line">    sender.sendDelayMsg(msg, delayTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息生产者的代码也需要修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void sendDelayMsg(String msg, Integer delayTime) &#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, msg, a -&gt;&#123;</span><br><span class="line">        a.getMessageProperties().setDelay(delayTime);</span><br><span class="line">        return a;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，再创建一个消费者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = DELAYED_QUEUE_NAME)</span><br><span class="line">public void receiveD(Message message, Channel channel) throws IOException &#123;</span><br><span class="line">    String msg = new String(message.getBody());</span><br><span class="line">    log.info(&quot;当前时间：&#123;&#125;,延时队列收到消息：&#123;&#125;&quot;, new Date().toString(), msg);</span><br><span class="line">    channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一切准备就绪，启动！然后分别访问以下链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/rabbitmq/delayMsg2?msg=msg1&amp;delayTime=20000</span><br><span class="line">http://localhost:8080/rabbitmq/delayMsg2?msg=msg2&amp;delayTime=2000</span><br></pre></td></tr></table></figure><p>日志如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-07-28 17:28:13.729  INFO 25804 --- [nio-8080-exec-2] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 17:28:13 CST 2019,收到请求，msg:msg1,delayTime:20000</span><br><span class="line">2019-07-28 17:28:20.607  INFO 25804 --- [nio-8080-exec-1] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 17:28:20 CST 2019,收到请求，msg:msg2,delayTime:2000</span><br><span class="line">2019-07-28 17:28:22.624  INFO 25804 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 17:28:22 CST 2019,延时队列收到消息：msg2</span><br><span class="line">2019-07-28 17:28:33.751  INFO 25804 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 17:28:33 CST 2019,延时队列收到消息：msg1</span><br></pre></td></tr></table></figure><p>第二个消息被先消费掉了，符合预期。至此，RabbitMQ实现延时队列的部分就完结了。<br><a name="imdFg"></a></p><h2 id="九、总结">九、总结</h2><p>延时队列在需要延时处理的场景下非常有用，使用RabbitMQ来实现延时队列可以很好的利用RabbitMQ的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过RabbitMQ集群的特性，可以很好的解决单点故障问题，不会因为单个节点挂掉导致延时队列不可用或者消息丢失。<br />当然，延时队列还有很多其它选择，比如利用Java的DelayQueu，利用Redis的zset，利用Quartz或者利用kafka的时间轮，这些方式各有特点，但就像炉石传说一般，这些知识就好比手里的卡牌，知道的越多，可以用的卡牌也就越多，遇到问题便能游刃有余，所以需要大量的知识储备和经验积累才能打造出更出色的卡牌组合，让自己解决问题的能力得到更好的提升。<br />但另一方面，随着时间的流逝和阅历的增长，越来越感觉到自己的能力有限，无法独自面对纷繁复杂且多变的业务需求，在很多方面需要其他人的协助才能很好的完成任务。也知道闻道有先后，术业有专攻，不会再狂妄自大，觉得自己能把所有事情都搞定，也将重心慢慢转移到研究如何有效的进行团队合作上来，我相信一个高度协调的团队永远比一个人战斗要更有价值。<br />花了一个周末的时间完成了这篇文章，文中所有的代码都上传到了github，<a href="https://github.com/MFrank2016/delayed-queue-demo%E5%A6%82%E6%9C%89%E9%9C%80%E8%A6%81%E5%8F%AF%E4%BB%A5%E8%87%AA%E8%A1%8C%E6%9F%A5%E9%98%85%EF%BC%8C%E5%B8%8C%E6%9C%9B%E8%83%BD%E5%AF%B9%E4%BD%A0%E6%9C%89%E5%B8%AE%E5%8A%A9%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89%E9%94%99%E8%AF%AF%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%8C%E6%AC%A2%E8%BF%8E%E6%8C%87%E6%AD%A3%EF%BC%8C%E4%B9%9F%E6%AC%A2%E8%BF%8E%E5%85%B3%E6%B3%A8%E6%88%91%E7%9A%84%E5%85%AC%E4%BC%97%E5%8F%B7%E8%BF%9B%E8%A1%8C%E7%95%99%E8%A8%80%E4%BA%A4%E6%B5%81%E3%80%82">https://github.com/MFrank2016/delayed-queue-demo如有需要可以自行查阅，希望能对你有帮助，如果有错误的地方，欢迎指正，也欢迎关注我的公众号进行留言交流。</a><br /><a href="https://i.loli.net/2019/07/14/5d2af6692a8f432182.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713423241902-7cacdd8a-060c-4854-9150-42e6d9bea215.png#clientId=u5fb36043-6de7-4&amp;from=paste&amp;id=u773589b0&amp;originHeight=595&amp;originWidth=597&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=84560&amp;status=done&amp;style=none&amp;taskId=ua00c1b73-14dd-416c-8b91-24812e1e8fb&amp;title=" alt="image.jpg"></a></p><ul><li><a href="https://www.cnblogs.com/mfrank/p/11260355.html#%E4%B8%80%E8%AF%B4%E6%98%8E">一、说明</a></li><li><a href="https://www.cnblogs.com/mfrank/p/11260355.html#%E4%BA%8C%E6%9C%AC%E6%96%87%E5%A4%A7%E7%BA%B2">二、本文大纲</a></li><li><a href="https://www.cnblogs.com/mfrank/p/11260355.html#%E4%B8%89%E4%BB%80%E4%B9%88%E6%98%AF%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97">三、什么是延时队列</a></li><li><a href="https://www.cnblogs.com/mfrank/p/11260355.html#%E5%9B%9B%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">四、延时队列使用场景</a></li><li><a href="https://www.cnblogs.com/mfrank/p/11260355.html#%E4%BA%94rabbitmq%E4%B8%AD%E7%9A%84ttl">五、RabbitMQ中的TTL</a></li><li><a href="https://www.cnblogs.com/mfrank/p/11260355.html#%E5%85%AD%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8rabbitmq%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97">六、如何利用RabbitMQ实现延时队列</a></li><li><a href="https://www.cnblogs.com/mfrank/p/11260355.html#%E4%B8%83rabbitmq%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96">七、RabbitMQ延时队列优化</a></li><li><a href="https://www.cnblogs.com/mfrank/p/11260355.html#%E5%85%AB%E5%88%A9%E7%94%A8rabbitmq%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97">八、利用RabbitMQ插件实现延迟队列</a></li><li><a href="https://www.cnblogs.com/mfrank/p/11260355.html#%E4%B9%9D%E6%80%BB%E7%BB%93">九、总结</a></li></ul><p><strong>EOF</strong><br /><a href="https://pic.cnblogs.com/avatar/1043143/20180825173331.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713423241931-a2d65f23-e30d-4778-b000-4151be84bf2a.png#clientId=u5fb36043-6de7-4&amp;from=paste&amp;id=u75f1766e&amp;originHeight=180&amp;originWidth=180&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=20922&amp;status=done&amp;style=none&amp;taskId=u8d926291-10c8-4898-90a5-834f495bbf8&amp;title=" alt="image.jpg"></a></p><ul><li><strong>本文作者：</strong><a href="https://www.cnblogs.com/mfrank">弗兰克的猫</a></li><li><strong>本文链接：</strong><a href="https://www.cnblogs.com/mfrank/p/11260355.html">https://www.cnblogs.com/mfrank/p/11260355.html</a></li><li><strong>关于博主：</strong> 终生学习，终生成长</li><li><strong>版权声明：</strong> 版权归博主所有，转载请注明出处</li><li><strong>声援博主：</strong> 如果您觉得文章对您有帮助，可以点击文章右下角**【推荐】**一下。</li></ul><blockquote><p>来自: <a href="https://www.cnblogs.com/mfrank/p/11260355.html">【RabbitMQ】一文带你搞定RabbitMQ延迟队列 - 弗兰克的猫 - 博客园</a></p></blockquote><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;kMFo7&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、说明&quot;&gt;一、说明&lt;/h2&gt;
&lt;p&gt;在上一篇中，介绍了RabbitMQ中的死信队列是什么，何时使用以及如何使用RabbitMQ的死信队列。相信通过上一篇的学习，对于死信队列已经有了更多的了解，这一篇的内容也</summary>
      
    
    
    
    <category term="web安全" scheme="http://www.bojiboqi.fun/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="xss" scheme="http://www.bojiboqi.fun/tags/xss/"/>
    
  </entry>
  
  <entry>
    <title>【RabbitMQ】一文带你搞定RabbitMQ死信队列</title>
    <link href="http://www.bojiboqi.fun/2024/04/22/%E3%80%90RabbitMQ%E3%80%91%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%90%9E%E5%AE%9ARabbitMQ%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/"/>
    <id>http://www.bojiboqi.fun/2024/04/22/%E3%80%90RabbitMQ%E3%80%91%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%90%9E%E5%AE%9ARabbitMQ%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/</id>
    <published>2024-04-22T06:24:58.868Z</published>
    <updated>2024-04-22T23:29:09.047Z</updated>
    
    <content type="html"><![CDATA[<p><a name="NdX3v"></a></p><h2 id="一、说明">一、说明</h2><p>RabbitMQ是流行的开源消息队列系统，使用erlang语言开发，由于其社区活跃度高，维护更新较快，性能稳定，深得很多企业的欢心（当然，也包括我现在所在公司【手动滑稽】）。<br />为了保证订单业务的消息数据不丢失，需要使用到RabbitMQ的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。但由于对死信队列的概念及配置不熟悉，导致曾一度陷入百度的汪洋大海，无法自拔，很多文章都看起来可行，但是实际上却并不能帮我解决实际问题。最终，在官网文档中找到了我想要的答案，通过官网文档的学习，才发现对于死信队列存在一些误解，导致配置死信队列之路困难重重。<br />于是本着记录和分享的精神，将死信队列的概念和配置完整的写下来，以便帮助遇到同样问题的朋友。<br><a name="m6XHV"></a></p><h2 id="二、本文大纲">二、本文大纲</h2><p>以下是本文大纲：<br /><a href="https://img2020.cnblogs.com/blog/1043143/202010/1043143-20201029140349282-672707323.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713423313427-2b743302-9a02-455c-887c-a4710239835a.png#averageHue=%232e2635&amp;clientId=u9fb6b966-f505-4&amp;from=paste&amp;id=uc42e7173&amp;originHeight=213&amp;originWidth=507&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=16029&amp;status=done&amp;style=none&amp;taskId=ub782932e-5564-4a1c-b7ba-7af754712a5&amp;title=" alt="image.jpg"></a><br />本文阅读前，需要对RabbitMQ有一个简单的了解，偏向实战配置讲解。<br><a name="qOVKO"></a></p><h2 id="三、死信队列是什么">三、死信队列是什么</h2><p>死信，在官网中对应的单词为“Dead Letter”，可以看出翻译确实非常的简单粗暴。那么死信是个什么东西呢？<br />“死信”是RabbitMQ中的一种消息机制，当你在消费消息时，如果队列里的消息出现以下情况：</p><ol><li>消息被否定确认，使用 <code>channel.basicNack</code> 或 <code>channel.basicReject</code> ，并且此时<code>requeue</code> 属性被设置为<code>false</code>。（这里的<code>requeue</code> 属性被设置为<code>false</code>表示不重新入队）</li><li>消息在队列的存活时间超过设置的TTL时间。</li><li>消息队列的消息数量已经超过最大队列长度。</li></ol><p>那么该消息将成为“死信”。<br />“死信”消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃。<br><a name="k47QP"></a></p><h2 id="四、如何配置死信队列">四、如何配置死信队列</h2><p>这一部分将是本文的关键，如何配置死信队列呢？其实很简单，大概可以分为以下步骤：</p><ol><li>配置业务队列，绑定到业务交换机上</li><li>为业务队列配置死信交换机和路由key</li><li>为死信交换机配置死信队列</li></ol><p>注意，并不是直接声明一个公共的死信队列，然后所以死信消息就自己跑到死信队列里去了。而是为每个需要使用死信的业务队列配置一个死信交换机，这里同一个项目的死信交换机可以共用一个，然后为每个业务队列分配一个单独的路由key。<br />有了死信交换机和路由key后，接下来，就像配置业务队列一样，配置死信队列，然后绑定在死信交换机上。也就是说，死信队列并不是什么特殊的队列，只不过是绑定在死信交换机上的队列。死信交换机也不是什么特殊的交换机，只不过是用来接受死信的交换机，所以可以为任何类型【Direct、Fanout、Topic】。一般来说，会为每个业务队列分配一个独有的路由key，并对应的配置一个死信队列进行监听，也就是说，一般会为每个重要的业务队列配置一个死信队列。<br />有了前文这些陈述后，接下来就是惊险刺激的实战环节，这里省略了RabbitMQ环境的部署和搭建环节。<br />先创建一个Springboot项目。然后在pom文件中添加 <code>spring-boot-starter-amqp</code> 和 <code>spring-boot-starter-web</code> 的依赖，接下来创建一个Config类，这里是关键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RabbitMQConfig &#123;</span><br><span class="line"></span><br><span class="line">    public static final String BUSINESS_EXCHANGE_NAME = &quot;dead.letter.demo.simple.business.exchange&quot;;</span><br><span class="line">    public static final String BUSINESS_QUEUEA_NAME = &quot;dead.letter.demo.simple.business.queuea&quot;;</span><br><span class="line">    public static final String BUSINESS_QUEUEB_NAME = &quot;dead.letter.demo.simple.business.queueb&quot;;</span><br><span class="line">    public static final String DEAD_LETTER_EXCHANGE = &quot;dead.letter.demo.simple.deadletter.exchange&quot;;</span><br><span class="line">    public static final String DEAD_LETTER_QUEUEA_ROUTING_KEY = &quot;dead.letter.demo.simple.deadletter.queuea.routingkey&quot;;</span><br><span class="line">    public static final String DEAD_LETTER_QUEUEB_ROUTING_KEY = &quot;dead.letter.demo.simple.deadletter.queueb.routingkey&quot;;</span><br><span class="line">    public static final String DEAD_LETTER_QUEUEA_NAME = &quot;dead.letter.demo.simple.deadletter.queuea&quot;;</span><br><span class="line">    public static final String DEAD_LETTER_QUEUEB_NAME = &quot;dead.letter.demo.simple.deadletter.queueb&quot;;</span><br><span class="line"></span><br><span class="line">    // 声明业务Exchange</span><br><span class="line">    @Bean(&quot;businessExchange&quot;)</span><br><span class="line">    public FanoutExchange businessExchange()&#123;</span><br><span class="line">        return new FanoutExchange(BUSINESS_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明死信Exchange</span><br><span class="line">    @Bean(&quot;deadLetterExchange&quot;)</span><br><span class="line">    public DirectExchange deadLetterExchange()&#123;</span><br><span class="line">        return new DirectExchange(DEAD_LETTER_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明业务队列A</span><br><span class="line">    @Bean(&quot;businessQueueA&quot;)</span><br><span class="line">    public Queue businessQueueA()&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = new HashMap&lt;&gt;(2);</span><br><span class="line">//       x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span><br><span class="line">        args.put(&quot;x-dead-letter-exchange&quot;, DEAD_LETTER_EXCHANGE);</span><br><span class="line">//       x-dead-letter-routing-key  这里声明当前队列的死信路由key</span><br><span class="line">        args.put(&quot;x-dead-letter-routing-key&quot;, DEAD_LETTER_QUEUEA_ROUTING_KEY);</span><br><span class="line">        return QueueBuilder.durable(BUSINESS_QUEUEA_NAME).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明业务队列B</span><br><span class="line">    @Bean(&quot;businessQueueB&quot;)</span><br><span class="line">    public Queue businessQueueB()&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = new HashMap&lt;&gt;(2);</span><br><span class="line">//       x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span><br><span class="line">        args.put(&quot;x-dead-letter-exchange&quot;, DEAD_LETTER_EXCHANGE);</span><br><span class="line">//       x-dead-letter-routing-key  这里声明当前队列的死信路由key</span><br><span class="line">        args.put(&quot;x-dead-letter-routing-key&quot;, DEAD_LETTER_QUEUEB_ROUTING_KEY);</span><br><span class="line">        return QueueBuilder.durable(BUSINESS_QUEUEB_NAME).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明死信队列A</span><br><span class="line">    @Bean(&quot;deadLetterQueueA&quot;)</span><br><span class="line">    public Queue deadLetterQueueA()&#123;</span><br><span class="line">        return new Queue(DEAD_LETTER_QUEUEA_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明死信队列B</span><br><span class="line">    @Bean(&quot;deadLetterQueueB&quot;)</span><br><span class="line">    public Queue deadLetterQueueB()&#123;</span><br><span class="line">        return new Queue(DEAD_LETTER_QUEUEB_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明业务队列A绑定关系</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding businessBindingA(@Qualifier(&quot;businessQueueA&quot;) Queue queue,</span><br><span class="line">                                    @Qualifier(&quot;businessExchange&quot;) FanoutExchange exchange)&#123;</span><br><span class="line">        return BindingBuilder.bind(queue).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明业务队列B绑定关系</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding businessBindingB(@Qualifier(&quot;businessQueueB&quot;) Queue queue,</span><br><span class="line">                                    @Qualifier(&quot;businessExchange&quot;) FanoutExchange exchange)&#123;</span><br><span class="line">        return BindingBuilder.bind(queue).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明死信队列A绑定关系</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding deadLetterBindingA(@Qualifier(&quot;deadLetterQueueA&quot;) Queue queue,</span><br><span class="line">                                    @Qualifier(&quot;deadLetterExchange&quot;) DirectExchange exchange)&#123;</span><br><span class="line">        return BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEA_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明死信队列B绑定关系</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding deadLetterBindingB(@Qualifier(&quot;deadLetterQueueB&quot;) Queue queue,</span><br><span class="line">                                      @Qualifier(&quot;deadLetterExchange&quot;) DirectExchange exchange)&#123;</span><br><span class="line">        return BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEB_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里声明了两个Exchange，一个是业务Exchange，另一个是死信Exchange，业务Exchange下绑定了两个业务队列，业务队列都配置了同一个死信Exchange，并分别配置了路由key，在死信Exchange下绑定了两个死信队列，设置的路由key分别为业务队列里配置的路由key。</p><p>下面是配置文件application.yml：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: localhost</span><br><span class="line">    password: guest</span><br><span class="line">    username: guest</span><br><span class="line">    listener:</span><br><span class="line">      type: simple</span><br><span class="line">      simple:</span><br><span class="line">          default-requeue-rejected: false</span><br><span class="line">          acknowledge-mode: manual</span><br></pre></td></tr></table></figure><p>这里记得将<code>default-requeue-rejected</code>属性设置为false。<br />接下来，是业务队列的消费代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class BusinessMessageReceiver &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = BUSINESS_QUEUEA_NAME)</span><br><span class="line">    public void receiveA(Message message, Channel channel) throws IOException &#123;</span><br><span class="line">        String msg = new String(message.getBody());</span><br><span class="line">        log.info(&quot;收到业务消息A：&#123;&#125;&quot;, msg);</span><br><span class="line">        boolean ack = true;</span><br><span class="line">        Exception exception = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (msg.contains(&quot;deadletter&quot;))&#123;</span><br><span class="line">                throw new RuntimeException(&quot;dead letter exception&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e)&#123;</span><br><span class="line">            ack = false;</span><br><span class="line">            exception = e;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!ack)&#123;</span><br><span class="line">            log.error(&quot;消息消费发生异常，error msg:&#123;&#125;&quot;, exception.getMessage(), exception);</span><br><span class="line">            channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = BUSINESS_QUEUEB_NAME)</span><br><span class="line">    public void receiveB(Message message, Channel channel) throws IOException &#123;</span><br><span class="line">        System.out.println(&quot;收到业务消息B：&quot; + new String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后配置死信队列的消费者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class DeadLetterMessageReceiver &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = DEAD_LETTER_QUEUEA_NAME)</span><br><span class="line">    public void receiveA(Message message, Channel channel) throws IOException &#123;</span><br><span class="line">        System.out.println(&quot;收到死信消息A：&quot; + new String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = DEAD_LETTER_QUEUEB_NAME)</span><br><span class="line">    public void receiveB(Message message, Channel channel) throws IOException &#123;</span><br><span class="line">        System.out.println(&quot;收到死信消息B：&quot; + new String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，为了方便测试，写一个简单的消息生产者，并通过controller层来生产消息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class BusinessMessageSender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    public void sendMsg(String msg)&#123;</span><br><span class="line">        rabbitTemplate.convertSendAndReceive(BUSINESS_EXCHANGE_NAME, &quot;&quot;, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;rabbitmq&quot;)</span><br><span class="line">@RestController</span><br><span class="line">public class RabbitMQMsgController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BusinessMessageSender sender;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;sendmsg&quot;)</span><br><span class="line">    public void sendMsg(String msg)&#123;</span><br><span class="line">        sender.sendMsg(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一切准备就绪，启动！</p><p>可以从RabbitMQ的管理后台中看到一共有四个队列，除默认的Exchange外还有声明的两个Exchange。</p><p><a href="https://img2020.cnblogs.com/blog/1043143/202010/1043143-20201029140506771-319482381.jpg"><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/28066124/1713423313524-9184fd7f-e81b-402c-b34b-20f675b1dca8.jpeg#averageHue=%23f8f8f7&amp;clientId=u9fb6b966-f505-4&amp;from=paste&amp;id=u36a8f708&amp;originHeight=557&amp;originWidth=1045&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=63742&amp;status=done&amp;style=none&amp;taskId=ubce24e7a-4038-472e-bf44-ab6fe27cff5&amp;title=" alt="image.jpg"></a></p><p><a href="https://img2020.cnblogs.com/blog/1043143/202010/1043143-20201029140536938-1122765461.jpg"><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/28066124/1713423313517-eb516772-f56d-4dbc-b95c-f6a61ae44ba1.jpeg#averageHue=%23f6f6f5&amp;clientId=u9fb6b966-f505-4&amp;from=paste&amp;id=u6ddadfb9&amp;originHeight=613&amp;originWidth=908&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=54828&amp;status=done&amp;style=none&amp;taskId=u90c74dac-3bbc-4509-ad68-a3e443a607a&amp;title=" alt="image.jpg"></a></p><p>接下来，访问一下url，来测试一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/rabbitmq/sendmsg?msg=msg</span><br></pre></td></tr></table></figure><p>日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">收到业务消息A：msg</span><br><span class="line">收到业务消息B：msg</span><br></pre></td></tr></table></figure><p>表示两个Consumer都正常收到了消息。这代表正常消费的消息，ack后正常返回。然后我们再来测试nck的消息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/rabbitmq/sendmsg?msg=deadletter</span><br></pre></td></tr></table></figure><p>这将会触发业务队列A的NCK，按照预期，消息被NCK后，会抛到死信队列中，因此死信队列将会出现这个消息，日志如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">收到业务消息A：deadletter</span><br><span class="line">消息消费发生异常，error msg:dead letter exception</span><br><span class="line">java.lang.RuntimeException: dead letter exception</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">收到死信消息A：deadletter</span><br></pre></td></tr></table></figure><p>可以看到，死信队列的Consumer接受到了这个消息，所以流程到此为止就打通了。</p><p><a name="VwaEN"></a></p><h2 id="五、死信消息的变化">五、死信消息的变化</h2><p>那么“死信”被丢到死信队列中后，会发生什么变化呢？</p><p>如果队列配置了参数 <code>x-dead-letter-routing-key</code> 的话，“死信”的路由key将会被替换成该参数对应的值。如果没有设置，则保留该消息原有的路由key。<br />举个栗子：<br />如果原有消息的路由key是<code>testA</code>，被发送到业务Exchage中，然后被投递到业务队列QueueA中，如果该队列没有配置参数<code>x-dead-letter-routing-key</code>，则该消息成为死信后，将保留原有的路由key<code>testA</code>，如果配置了该参数，并且值设置为<code>testB</code>，那么该消息成为死信后，路由key将会被替换为<code>testB</code>，然后被抛到死信交换机中。<br />另外，由于被抛到了死信交换机，所以消息的Exchange Name也会被替换为死信交换机的名称。<br />消息的Header中，也会添加很多奇奇怪怪的字段，修改一下上面的代码，在死信队列的消费者中添加一行日志输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(&quot;死信消息properties：&#123;&#125;&quot;, message.getMessageProperties());</span><br></pre></td></tr></table></figure><p>然后重新运行一次，即可得到死信消息Header中被添加的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">死信消息properties：MessageProperties [headers=&#123;x-first-death-exchange=dead.letter.demo.simple.business.exchange, x-death=[&#123;reason=rejected, count=1, exchange=dead.letter.demo.simple.business.exchange, time=Sun Jul 14 16:48:16 CST 2019, routing-keys=[], queue=dead.letter.demo.simple.business.queuea&#125;], x-first-death-reason=rejected, x-first-death-queue=dead.letter.demo.simple.business.queuea&#125;, correlationId=1, replyTo=amq.rabbitmq.reply-to.g2dkABZyYWJiaXRAREVTS1RPUC1DUlZGUzBOAAAPQAAAAAAB.bLbsdR1DnuRSwiKKmtdOGw==, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, redelivered=false, receivedExchange=dead.letter.demo.simple.deadletter.exchange, receivedRoutingKey=dead.letter.demo.simple.deadletter.queuea.routingkey, deliveryTag=1, consumerTag=amq.ctag-NSp18SUPoCNvQcoYoS2lPg, consumerQueue=dead.letter.demo.simple.deadletter.queuea]</span><br></pre></td></tr></table></figure><p>Header中看起来有很多信息，实际上并不多，只是值比较长而已。下面就简单说明一下Header中的值：</p><table><thead><tr><th>字段名</th><th>含义</th></tr></thead></table><table><thead><tr><th>x-first-death-exchange</th><th>第一次被抛入的死信交换机的名称</th></tr></thead></table><table><thead><tr><th>x-first-death-reason</th><th>第一次成为死信的原因，<code>rejected</code><br />：消息在重新进入队列时被队列拒绝，由于<code>default-requeue-rejected</code><br /> 参数被设置为<code>false</code><br />。<code>expired</code><br /> ：消息过期。<code>maxlen</code><br /> ： 队列内消息数量超过队列最大容量</th><th></th></tr></thead><tbody><tr><td>x-first-death-queue</td><td>第一次成为死信前所在队列名称</td><td></td></tr><tr><td>x-death</td><td>历次被投入死信交换机的信息列表，同一个消息每次进入一个死信交换机，这个数组的信息就会被更新</td><td></td></tr></tbody></table><p><a name="iy2ZR"></a></p><h2 id="六、死信队列应用场景">六、死信队列应用场景</h2><p>通过上面的信息，我们已经知道如何使用死信队列了，那么死信队列一般在什么场景下使用呢？<br />一般用在较为重要的业务队列中，确保未被正确消费的消息不被丢弃，一般发生消费异常可能原因主要有由于消息信息本身存在错误导致处理异常，处理过程中参数校验异常，或者因网络波动导致的查询异常等等，当发生异常时，当然不能每次通过日志来获取原消息，然后让运维帮忙重新投递消息（没错，以前就是这么干的= =）。通过配置死信队列，可以让未正确处理的消息暂存到另一个队列中，待后续排查清楚问题后，编写相应的处理代码来处理死信消息，这样比手工恢复数据要好太多了。<br><a name="MhTn7"></a></p><h2 id="七、总结">七、总结</h2><p>死信队列其实并没有什么神秘的地方，不过是绑定在死信交换机上的普通队列，而死信交换机也只是一个普通的交换机，不过是用来专门处理死信的交换机。<br />总结一下死信消息的生命周期：</p><ol><li>业务消息被投入业务队列</li><li>消费者消费业务队列的消息，由于处理过程中发生异常，于是进行了nck或者reject操作</li><li>被nck或reject的消息由RabbitMQ投递到死信交换机中</li><li>死信交换机将消息投入相应的死信队列</li><li>死信队列的消费者消费死信消息</li></ol><p>死信消息是RabbitMQ为我们做的一层保证，其实我们也可以不使用死信队列，而是在消息消费异常时，将消息主动投递到另一个交换机中，当你明白了这些之后，这些Exchange和Queue想怎样配合就能怎么配合。比如从死信队列拉取消息，然后发送邮件、短信、钉钉通知来通知开发人员关注。或者将消息重新投递到一个队列然后设置过期时间，来进行延时消费。<br />本篇文章中的demo项目已上传至github，有需要的朋友可以自行下载查阅。<a href="https://github.com/MFrank2016/dead-letter-demo%E2%80%8B">https://github.com/MFrank2016/dead-letter-demo</a><br />如果本文对你有帮助，记得点个赞，也希望能分享给更多的朋友。也欢迎关注我的公众号进行留言交流。<br /><a href="https://img2020.cnblogs.com/blog/1043143/202010/1043143-20201029140518048-1298634336.jpg"><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/28066124/1713423313454-d7982742-d76f-49d5-9398-e6c85b2e3da8.jpeg#clientId=u9fb6b966-f505-4&amp;from=paste&amp;id=u1febaef1&amp;originHeight=595&amp;originWidth=597&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=30224&amp;status=done&amp;style=none&amp;taskId=u8ec55f30-6d64-492c-b7d0-eabb13b0f90&amp;title=" alt="image.jpg"></a></p><ul><li><a href="https://www.cnblogs.com/mfrank/p/11184929.html#%E4%B8%80%E8%AF%B4%E6%98%8E">一、说明</a></li><li><a href="https://www.cnblogs.com/mfrank/p/11184929.html#%E4%BA%8C%E6%9C%AC%E6%96%87%E5%A4%A7%E7%BA%B2">二、本文大纲</a></li><li><a href="https://www.cnblogs.com/mfrank/p/11184929.html#%E4%B8%89%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E6%98%AF%E4%BB%80%E4%B9%88">三、死信队列是什么</a></li><li><a href="https://www.cnblogs.com/mfrank/p/11184929.html#%E5%9B%9B%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97">四、如何配置死信队列</a></li><li><a href="https://www.cnblogs.com/mfrank/p/11184929.html#%E4%BA%94%E6%AD%BB%E4%BF%A1%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%98%E5%8C%96">五、死信消息的变化</a></li><li><a href="https://www.cnblogs.com/mfrank/p/11184929.html#%E5%85%AD%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">六、死信队列应用场景</a></li><li><a href="https://www.cnblogs.com/mfrank/p/11184929.html#%E4%B8%83%E6%80%BB%E7%BB%93">七、总结</a></li></ul><p><strong>EOF</strong><br /><a href="https://pic.cnblogs.com/avatar/1043143/20180825173331.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/28066124/1713423313414-60104b31-7cd5-4243-84e0-338b06a0b157.png#clientId=u9fb6b966-f505-4&amp;from=paste&amp;id=udcacc155&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=20922&amp;status=done&amp;style=none&amp;taskId=ubab7ed2b-5cda-4d6e-b611-b52bd5bd9f5&amp;title=" alt="image.jpg"></a></p><ul><li><strong>本文作者：</strong><a href="https://www.cnblogs.com/mfrank">弗兰克的猫</a></li><li><strong>本文链接：</strong><a href="https://www.cnblogs.com/mfrank/p/11184929.html">https://www.cnblogs.com/mfrank/p/11184929.html</a></li><li><strong>关于博主：</strong> 终生学习，终生成长</li><li><strong>版权声明：</strong> 版权归博主所有，转载请注明出处</li><li><strong>声援博主：</strong> 如果您觉得文章对您有帮助，可以点击文章右下角**【推荐】**一下。</li></ul><blockquote><p>来自: <a href="https://www.cnblogs.com/mfrank/p/11184929.html">【RabbitMQ】一文带你搞定RabbitMQ死信队列 - 弗兰克的猫 - 博客园</a></p></blockquote><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;NdX3v&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、说明&quot;&gt;一、说明&lt;/h2&gt;
&lt;p&gt;RabbitMQ是流行的开源消息队列系统，使用erlang语言开发，由于其社区活跃度高，维护更新较快，性能稳定，深得很多企业的欢心（当然，也包括我现在所在公司【手动滑稽】</summary>
      
    
    
    
    <category term="中间件" scheme="http://www.bojiboqi.fun/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="rabbitmq" scheme="http://www.bojiboqi.fun/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>八大排序算法稳定性分析</title>
    <link href="http://www.bojiboqi.fun/2024/04/22/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90/"/>
    <id>http://www.bojiboqi.fun/2024/04/22/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90/</id>
    <published>2024-04-22T06:24:34.937Z</published>
    <updated>2024-04-22T23:28:48.785Z</updated>
    
    <content type="html"><![CDATA[<p><strong>稳定性定义：</strong><br />排序前后两个相等的数相对位置不变，则算法稳定。<br /><strong>稳定性得好处：</strong><br />从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用<br /><strong>各排序算法的稳定性：</strong><br />1、堆排序、快速排序、希尔排序、直接选择排序<strong>不是稳定</strong>的排序算法；<br />2、基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序<strong>是稳定</strong>的排序算法。<br />一<br />冒泡排序<br />1、小的元素往前调或者把大的元素往后调；<br />2、比较是相邻的两个元素比较，交换也发生在这两个元素之间；<br />3、<strong>稳定排序算法。</strong><br />二<br />选择排序<br />1、每个位置选择当前元素最小的；<br />2、在一趟选择中，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了；<br />3、举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了；<br />4、<strong>不稳定的排序算法。</strong><br />三<br />插入排序<br />1、已经有序的小序列的基础上，一次插入一个元素；<br />2、想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置；<br />3、如果碰见一个和插入元素相 等的，那么插入元素把想插入的元素放在相等元素的后面；<br />4、相等元素的前后顺序没有改变；<br />5、<strong>稳定排序算法。</strong><br />四<br />快速排序<br />1、两个方向，左边的i下标一直往右走，当a[i] &lt;= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]；<br />2、如果i和j都走不动了，i &lt;= j, 交换a[i]和a[j],重复上面的过程，直到i&gt;j；<br />3、交换a[j]和a[center_index]，完成一趟快速排序；<br />4、在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱；<br />5、不稳定发生在中枢元素和a[j] 交换的时刻；<br />6、<strong>不稳定的排序算法。</strong><br />五<br />归并排序<br />1、把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),然后把各个有序的短序列合并成一个有序的长序列，不断合并直到原序列全部排好序；<br />2、合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结 果序列的前面，这样就保证了稳定性；<br />3、<strong>稳定排序算法。</strong><br />六<br />希尔排序(shell)<br />1、按照不同步长对元素进行插入排序；<br />2、当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；<br />3、当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高；<br />4、所以，希尔排序的时间复杂度会比o(n^2)好一些<br />由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元 素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱；<br />5、<strong>不稳定的排序算法。</strong><br />七<br />出基数排序 数：<br />1、按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位；<br />2、有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优 先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前；<br />3、用于整数；<br />4、需要较多的存储空间；<br />5、基于分别排序，分别收集；<br />6、<strong>稳定排序算法。</strong><br />八<br />堆排序<br />1、是选择排序的一种；<br />2、堆的结构是节点i的孩子为2<em>i和2</em>i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点，是完全二叉树；<br />3、在一个长为n 的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n /2-1, n/2-2, …1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了；<br />4、<strong>不稳定的排序算法。</strong><br />九<br />各排序算法的优劣<br /><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/28066124/1713445854913-c8d6e99a-214d-48e1-b825-1f7aa7ffa2b7.jpeg#clientId=ucaf3f613-b594-4&amp;from=paste&amp;id=u3f08c406&amp;originHeight=540&amp;originWidth=638&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=80022&amp;status=done&amp;style=none&amp;taskId=ud03ac671-4f39-4041-84f9-6efc9e7faa5&amp;title=" alt="image.jpg"><br />图片来源于网络<br />为你推荐以下文章 <br />求职者救星！！帮你内推国内一流互联网企业，助力你早日找到dream offer <br />蚂蚁金服Java研发工程师的春招面试经历 | 双非大佬教你如何成为offer收割机 <br />快速搞定8大排序算法 <br />本文参与 <a href="https://cloud.tencent.com/developer/support-plan">腾讯云自媒体分享计划</a>，分享自微信公众号。<br />原始发表：2018-04-26，如有侵权请联系 <a href="mailto:cloudcommunity@tencent.com">cloudcommunity@tencent.com</a> 删除</p><blockquote><p>来自: <a href="https://cloud.tencent.com/developer/article/1182321">八大排序算法稳定性分析，原来稳定性是这个意思…-腾讯云开发者社区-腾讯云</a></p></blockquote><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;稳定性定义：&lt;/strong&gt;&lt;br /&gt;排序前后两个相等的数相对位置不变，则算法稳定。&lt;br /&gt;&lt;strong&gt;稳定性得好处：&lt;/strong&gt;&lt;br /&gt;从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用&lt;br /&gt;&lt;st</summary>
      
    
    
    
    <category term="算法" scheme="http://www.bojiboqi.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序" scheme="http://www.bojiboqi.fun/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 多环境配置都</title>
    <link href="http://www.bojiboqi.fun/2024/04/22/Spring%20Boot%20%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E9%83%BD/"/>
    <id>http://www.bojiboqi.fun/2024/04/22/Spring%20Boot%20%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E9%83%BD/</id>
    <published>2024-04-22T06:23:49.578Z</published>
    <updated>2024-04-22T23:30:42.960Z</updated>
    
    <content type="html"><![CDATA[<p><a name="yqGFk"></a></p><h3 id=""></h3><p><a name="ODYr0"></a></p><h3 id="目录">目录</h3><ul><li>前言</li><li>Spring Boot 自带的多环境配置<ul><li>创建不同环境的配置文件</li><li>指定运行的环境</li></ul></li><li>Maven 的多环境配置<ul><li>创建多环境配置文件</li><li>定义激活的变量</li><li>pom 文件中定义 profiles</li><li>资源过滤</li><li>总结</li></ul></li><li>总结<br><a name="JVhOk"></a></li></ul><h2 id="前言"><strong>前言</strong></h2><p>日常开发中至少有三个环境，分别是开发环境（<code>**dev**</code>），测试环境（<code>**test**</code>），生产环境（<code>**prod**</code>）。<br />不同的环境的各种配置都不相同，比如数据库，端口，<code>**IP**</code>地址等信息。<br />那么这么多环境如何区分，如何打包呢？<br />本篇文章就来介绍一下<code>**Spring Boot**</code> 中多环境如何配置，如何打包。<br><a name="dwHWL"></a></p><h2 id="Spring-Boot-自带的多环境配置"><strong>Spring Boot 自带的多环境配置</strong></h2><p>Spring Boot 对多环境整合已经有了很好的支持，能够在打包，运行间自由切换环境。<br />那么如何配置呢？下面将会逐步介绍。<br><a name="zqpIJ"></a></p><h3 id="创建不同环境的配置文件">创建不同环境的配置文件</h3><p>既然每个环境的配置都不相同，索性将不同环境的配置放在不同的配置文件中，因此需要创建三个不同的配置文件，分别是<code>**application-dev.properties**</code>、<code>**application-test.properties**</code>、<code>**application-prod.properties**</code>。<br /><strong>「注意」</strong>：配置文件的名称一定要是<code>**application-name.properties**</code>或者<code>**application-name.yml**</code>格式。这个<code>**name**</code>可以自定义，主要用于区分。</p><blockquote><p>此时整个项目中就有四个配置文件，加上<code>**application.properties**</code>。</p></blockquote><p><a name="V2CVw"></a></p><h3 id="指定运行的环境">指定运行的环境</h3><p>虽然你创建了各个环境的配置文件，但是<code>**Spring Boot**</code> 仍然不知道你要运行哪个环境，有以下两种方式指定：<br><a name="pkVvW"></a></p><h4 id="配置文件中指定">配置文件中指定</h4><p>在<code>**application.properties**</code>或者<code>**application.yml**</code>文件中指定，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 指定运行环境为测试环境</span><br><span class="line">spring.profiles.active=test</span><br></pre></td></tr></table></figure><p>以上配置有什么作用呢？<br />如果没有指定运行的环境，<code>**Spring Boot**</code> 默认会加载<code>**application.properties**</code>文件，而这个的文件又告诉<code>**Spring Boot**</code> 去找<code>**test**</code>环境的配置文件。<br><a name="lutS4"></a></p><h4 id="运行-jar-的时候指定">运行 jar 的时候指定</h4><p><code>**Spring Boot**</code> 内置的环境切换能够在运行<code>**Jar**</code>包的时候指定环境，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxx.jar --spring.profiles.active=test</span><br></pre></td></tr></table></figure><p>以上命令指定了运行的环境是<code>**test**</code>，是不是很方便呢？<br><a name="GBTPC"></a></p><h2 id="Maven-的多环境配置"><strong>Maven 的多环境配置</strong></h2><p><code>**Maven**</code>本身也提供了对多环境的支持，不仅仅支持<code>**Spring Boot**</code>项目，只要是基于<code>**Maven**</code>的项目都可以配置。<br /><code>**Maven**</code>对于多环境的支持在功能方面更加强大，支持<code>**JDK版本**</code>、<code>**资源文件**</code>、<code>**操作系统**</code>等等因素来选择环境。<br />如何配置呢？下面逐一介绍。<br><a name="Ec89N"></a></p><h3 id="创建多环境配置文件">创建多环境配置文件</h3><p>创建不同环境的配置文件，分别是<code>**application-dev.properties**</code>、<code>**application-test.properties**</code>、<code>**application-prod.properties**</code>。<br />加上默认的配置文件<code>**application.properties**</code>同样是四个配置文件。<br><a name="NdMGo"></a></p><h3 id="定义激活的变量">定义激活的变量</h3><p>需要将<code>**Maven**</code>激活的环境作用于<code>**Spring Boot**</code>，实际还是利用了<code>**spring.profiles.active**</code>这个属性，只是现在这个属性的取值将是取值于<code>**Maven**</code>。配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.active=@profile.active@</span><br></pre></td></tr></table></figure><blockquote><p><code>**profile.active**</code>实际上就是一个变量，在<code>**maven**</code>打包的时候指定的<code>**-P test**</code>传入的就是值。</p></blockquote><p><a name="bGKzh"></a></p><h3 id="pom-文件中定义-profiles">pom 文件中定义 profiles</h3><p>需要在<code>**maven**</code>的<code>**pom.xml**</code>文件中定义不同环境的<code>**profile**</code>，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--定义三种开发环境--&gt;</span><br><span class="line">    &lt;profiles&gt;</span><br><span class="line">        &lt;profile&gt;</span><br><span class="line">            &lt;!--不同环境的唯一id--&gt;</span><br><span class="line">            &lt;id&gt;dev&lt;/id&gt;</span><br><span class="line">            &lt;activation&gt;</span><br><span class="line">                &lt;!--默认激活开发环境--&gt;</span><br><span class="line">                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">            &lt;/activation&gt;</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;!--profile.active对应application.yml中的@profile.active@--&gt;</span><br><span class="line">                &lt;profile.active&gt;dev&lt;/profile.active&gt;</span><br><span class="line">            &lt;/properties&gt;</span><br><span class="line">        &lt;/profile&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--测试环境--&gt;</span><br><span class="line">        &lt;profile&gt;</span><br><span class="line">            &lt;id&gt;test&lt;/id&gt;</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;profile.active&gt;test&lt;/profile.active&gt;</span><br><span class="line">            &lt;/properties&gt;</span><br><span class="line">        &lt;/profile&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--生产环境--&gt;</span><br><span class="line">        &lt;profile&gt;</span><br><span class="line">            &lt;id&gt;prod&lt;/id&gt;</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;profile.active&gt;prod&lt;/profile.active&gt;</span><br><span class="line">            &lt;/properties&gt;</span><br><span class="line">        &lt;/profile&gt;</span><br><span class="line">    &lt;/profiles&gt;</span><br></pre></td></tr></table></figure><p>标签<code>**&lt;profile.active&gt;**</code>正是对应着配置文件中的<code>**@profile.active@**</code>。<br /><code>**&lt;activeByDefault&gt;**</code>标签指定了默认激活的环境，则是打包的时候不指定<code>**-P**</code>选项默认选择的环境。<br />以上配置完成后，将会在IDEA的右侧<code>**Maven**</code>选项卡中出现以下内容：</p><p>1<br />可以选择打包的环境，然后点击<code>**package**</code>即可。<br />或者在项目的根目录下用命令打包，不过需要使用<code>**-P**</code>指定环境，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package package -P test</span><br></pre></td></tr></table></figure><p><code>**maven**</code>中的<code>**profile**</code>的激活条件还可以根据<code>**jdk**</code>、<code>**操作系统**</code>、<code>**文件存在或者缺失**</code>来激活。这些内容都是在<code>**&lt;activation&gt;**</code>标签中配置，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--activation用来指定激活方式，可以根据jdk环境，环境变量，文件的存在或缺失--&gt;</span><br><span class="line">  &lt;activation&gt;</span><br><span class="line">       &lt;!--配置默认激活--&gt;</span><br><span class="line">      &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">                </span><br><span class="line">      &lt;!--通过jdk版本--&gt;</span><br><span class="line">      &lt;!--当jdk环境版本为1.8时，此profile被激活--&gt;</span><br><span class="line">      &lt;jdk&gt;1.8&lt;/jdk&gt;</span><br><span class="line">      &lt;!--当jdk环境版本1.8或以上时，此profile被激活--&gt;</span><br><span class="line">      &lt;jdk&gt;[1.8,)&lt;/jdk&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!--根据当前操作系统--&gt;</span><br><span class="line">      &lt;os&gt;</span><br><span class="line">        &lt;name&gt;Windows XP&lt;/name&gt;</span><br><span class="line">        &lt;family&gt;Windows&lt;/family&gt;</span><br><span class="line">        &lt;arch&gt;x86&lt;/arch&gt;</span><br><span class="line">        &lt;version&gt;5.1.2600&lt;/version&gt;</span><br><span class="line">      &lt;/os&gt;</span><br><span class="line">  &lt;/activation&gt;</span><br></pre></td></tr></table></figure><p><a name="XcFu8"></a></p><h3 id="资源过滤">资源过滤</h3><p>如果你不配置这一步，将会在任何环境下打包都会带上全部的配置文件，但是我们可以配置只保留对应环境下的配置文件，这样安全性更高。<br />这一步配置很简单，只需要在<code>**pom.xml**</code>文件中指定<code>**&lt;resource&gt;**</code>过滤的条件即可，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;resources&gt;</span><br><span class="line">  &lt;!--排除配置文件--&gt;</span><br><span class="line">    &lt;resource&gt;</span><br><span class="line">      &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">      &lt;!--先排除所有的配置文件--&gt;</span><br><span class="line">        &lt;excludes&gt;</span><br><span class="line">          &lt;!--使用通配符，当然可以定义多个exclude标签进行排除--&gt;</span><br><span class="line">          &lt;exclude&gt;application*.properties&lt;/exclude&gt;</span><br><span class="line">        &lt;/excludes&gt;</span><br><span class="line">    &lt;/resource&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--根据激活条件引入打包所需的配置和文件--&gt;</span><br><span class="line">    &lt;resource&gt;</span><br><span class="line">      &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">      &lt;!--引入所需环境的配置文件--&gt;</span><br><span class="line">      &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">      &lt;includes&gt;</span><br><span class="line">        &lt;include&gt;application.yml&lt;/include&gt;</span><br><span class="line">          &lt;!--根据maven选择环境导入配置文件--&gt;</span><br><span class="line">        &lt;include&gt;application-$&#123;profile.active&#125;.yml&lt;/include&gt;</span><br><span class="line">      &lt;/includes&gt;</span><br><span class="line">    &lt;/resource&gt;</span><br><span class="line">  &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>上述配置主要分为两个方面，第一是先排除所有配置文件，第二是根据<code>**profile.active**</code>动态的引入配置文件。<br><a name="l8Nsw"></a></p><h3 id="总结">总结</h3><p>至此，<code>**Maven**</code>的多环境打包已经配置完成，相对来说挺简单，既可以在<code>**IDEA**</code>中选择环境打包，也同样支持命令<code>**-P**</code>指定环境打包。<br><a name="rhGpK"></a></p><h2 id="总结-2"><strong>总结</strong></h2><p>本文介绍了Spring Boot 的两种打包方式，每种方式有各自的优缺点，你更喜欢哪种呢？</p><blockquote><p>源码已经上传，回复关键词<code>**多环境配置**</code>获取。</p></blockquote><blockquote><p>来自: <a href="https://www.cnblogs.com/Chenjiabing/p/13968781.html">嗯，挺全乎儿的，Spring Boot 多环境配置都在这里了，你喜欢哪种？ - 爱撒谎的男孩 - 博客园</a></p></blockquote><meta name="referrer" content="no-referrer">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;yqGFk&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a name=&quot;ODYr0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;目录&quot;&gt;目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;前言&lt;/li&gt;
&lt;li&gt;Spring Boot 自带的多环境配置
&lt;ul&gt;
&lt;</summary>
      
    
    
    
    <category term="spring" scheme="http://www.bojiboqi.fun/categories/spring/"/>
    
    
    <category term="spring" scheme="http://www.bojiboqi.fun/tags/spring/"/>
    
  </entry>
  
</feed>
